ernet character set
    IF_FAILEXIT(hr = HrIStreamWToInetCset(pStmHtmlW, m_hCharset, &pStmHtml));
    
    // Return pStmHtml
    *ppStream = pStmHtml;
    pStmHtml = NULL;
// #ifdef DEBUG

//     WriteStreamToFile(*ppStream, "c:\\dump.htm", CREATE_ALWAYS, GENERIC_WRITE);    
// #endif
    
exit:
    // Cleanup
    SafeRelease(pStmHtml);
    SafeRelease(pStmHtmlW);
    SafeRelease(pStmPlainW);
    SafeRelease(pStmEnriched);
    SafeMemFree(pwszType);
    
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_DoSegmentSplitter
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_DoSegmentSplitter(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPPAGESEGMENT   pSegment=NULL;

    // Trace
    TraceCall("CMessageWebPage::_DoSegmentSplitter");

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

    // If more than one inline bodies ?
    if (S_OK == m_pCallback->OnWebPageSplitter(m_cInline, pSegment->pStream))
    {
        // Rewind the stream
        HrRewindStream(pSegment->pStream);

        // Link Segment into list...
        _VAppendSegment(pSegment);

        // Don't Free It
        pSegment = NULL;
    }

    // Otherwise, free this segment
    else
    {
        // Free It
        _VFreeSegment(pSegment);

        // Done Free it again
        pSegment = NULL;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_InlineTextBody
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_InlineTextBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode, BOOL fSetParents)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rVariant;
    LPSTREAM        pStream=NULL;
    LPPAGESEGMENT   pSegment=NULL;
    LPTREENODEINFO  pCurrent;
    LPSTR           pszFileName=NULL;

    // Tracing
    TraceCall("CMessageWebPage::_InlineTextBody");

    // This node better not already be on the webpage
    Assert(FALSE == ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE));

    // Handle Text Types that I explicitly will never inline
    if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_VCARD))
        goto exit;

    // Inline the body
    if (S_OK != _GetInlineHtmlStream(pTree, pNode, &pStream))
        goto exit;

    // Setup a Variant
    rVariant.vt = VT_LPSTR;

    // If this body has a file name, lets also show it as an attachment
    if (SUCCEEDED(pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_FILENAME), NOFLAGS, &rVariant)))
    {
        // Save the File name
        pszFileName = rVariant.pszVal;
    }

    // Only showing images ?
    if (FALSE == ISFLAGSET(m_rOptions.dwFlags, WPF_IMAGESONLY))
    {
        // Segment Split
        _DoSegmentSplitter();

        // Append a PageSegment
        IF_FAILEXIT(hr = _AllocateSegment(&pSegment, FALSE));

        // Set pStream
        pSegment->pStream = pStream;
        pSegment->pStream->AddRef();

        // Link Segment into list...
        _VAppendSegment(pSegment);

        // Don't Free It
        pSegment = NULL;

        // Report that some data is available
        m_pRequest->OnBindingDataAvailable();

        // Increment number of inline bodies
        m_cInline++;
    }

    // Mark the node as rendered
    rVariant.vt = VT_UI4;
    rVariant.ulVal = TRUE;

    // If this has a filename
    if (pszFileName)
    {
        // Mark it as auto-inlined
        SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)));
    }

    // Set the Property
    SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

    // We have rendered this node on the webpage
    FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);

    // Set parents are on webpage
    if (fSetParents)
    {
        // Raid-45116: new text attachment contains message body on Communicator inline image message
        pCurrent = pNode->pParent;

        // Try to find an alternative parent...
        while(pCurrent)
        {
            // If multipart/alternative, walk all of its children and mark them as being rendered
            if (S_OK == pCurrent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE))
            {
                // Get Parent
                for (LPTREENODEINFO pChild=pCurrent->pChildHead; pChild!=NULL; pChild=pChild->pNext)
                {
                    // Set Resolve Property
                    SideAssert(SUCCEEDED(pChild->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
                }
            }

            // Mark as being on the webpage
            FLAGSET(pCurrent->dwState, NODESTATE_ONWEBPAGE);

            // Get Next Parent
            pCurrent = pCurrent->pParent;
        }
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pszFileName);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_SetContentId
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_SetContentId(LPTREENODEINFO pNode, LPSTR pszCID, ULONG cchCID)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszContentId=NULL;
    GUID            guid;
    WCHAR           wszGUID[64];
    LPSTR           pszFile;
    LPSTR           pszGuid=0;
    LPSTR           pszT;

    // Tracing
    TraceCall("CMessageWebPage::_SetContentId");

    // See of pNode already has a Content-ID
    if (S_FALSE == pNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTID)))
    {
        // $BUG #64186
        //   Create a content-id in the form:
        //   CID:{guid}/<filename>
        //   so that trident's save-as dialog has a meaningful
        //   filename to work with

        // Create a guid
        IF_FAILEXIT(hr = CoCreateGuid(&guid));

        // Convert the GUID to a string
        if (0 == StringFromGUID2(guid, wszGUID, ARRAYSIZE(wszGUID)))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Convert to ANSI
        pszGuid = PszToANSI(CP_ACP, wszGUID);
        if (!pszGuid)
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        // [PaulHi] 6/18/99.  Raid 76531.  Don't append the file name to the GUID ... 
        // it causes encoding problems with Trident International.  In particular the 
        // DBCS characters in the filename can cause the HTML to contain both JIS and 
        // SHIFT-JIS encodings.  I believe this is a Trident bug because we explicitly
        // set the Trident to CP_JAUTODETECT (JIS) and it still performs SHIFT_JIS decoding
        // if the attachment filename is long.  However, the real fix is to make the entire
        // HTML text a single (JIS) encoding, but this is difficult to do because the attachment
        // code is single byte (DBCS) which equates to SHIFT-JIS.  We need to convert fully to
        // Unicode.
        INETCSETINFO    rCharset;
        MimeOleGetCharsetInfo(m_hCharset, &rCharset);
        if (rCharset.cpiInternet != CP_JAUTODETECT) // code page 50932
        {
            // If we have a file-name, append to guid
            if (pNode->pContainer->GetProp(PIDTOSTR(STR_ATT_GENFNAME), &pszFile)==S_OK)
            {
                // Allocate Buffer
                pszT = PszAllocA(lstrlen(pszFile) + lstrlen(pszGuid) + 2);
                if (pszT)
                {
                    // Copy contents and free old GUID
                    wsprintf(pszT, "%s/%s", pszGuid, pszFile);
                    MemFree(pszGuid);
                    pszGuid = pszT;
                }
                MemFree(pszFile);
            }
        }
        else
        {
            // @HACK [PaulHi]  Preempt any JIS encoding problems by just appending "/.".
            // This will allow right-click save image as operation to work without
            // the user seeing the URL GUID.
            pszT = PszAllocA(lstrlen(pszGuid) + 3);
            if (pszT)
            {
                // Copy conents and free old GUID
                wsprintf(pszT, "%s/.", pszGuid);
                MemFree(pszGuid);
                pszGuid = pszT;
            }
        }

        // copy GUID to output buffer
        StrCpyNA(pszCID, pszGuid, cchCID);

        // Store the content-id into the node
        IF_FAILEXIT(hr = pNode->pContainer->SetProp(PIDTOSTR(PID_HDR_CNTID), pszCID));
    }

    // Otheriwse, get the Content-ID from this body
    else
    {
        // Get the Content-Id
        IF_FAILEXIT(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_HDR_CNTID), &pszContentId));

        // Copy it into pszCID
        Assert(lstrlen(pszContentId) <= (LONG)cchCID);

        // Copy the cid to the outbound variable
        lstrcpyn(pszCID, pszContentId, cchCID);
    }

exit:
    // Cleanup
    SafeMemFree(pszContentId);
    SafeMemFree(pszGuid);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_InlineImageBody
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_InlineImageBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszFile=NULL;
    LPSTR           pszExt;
    CHAR            szCID[CCHMAX_CID + 1];
    PROPVARIANT     rVariant;
    LPPAGESEGMENT   pSegment=NULL;

    // Tracing
    TraceCall("CMessageWebPage::_InlineImageBody");

    // This node better not already be on the webpage
    Assert(pTree && pNode && FALSE == ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE));

    // Setup the Variant
    rVariant.vt = VT_UI4;

    // If the body is marked as inline, or autoline attachments is enabled and (slideshow is disabled)
    if (S_OK == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_INLINE, FALSE, FALSE) || ISFLAGSET(m_rOptions.dwFlags, WPF_AUTOINLINE))
    {
        // Get a generated filename from the body
        IF_FAILEXIT(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_ATT_GENFNAME), &pszFile));

        // Look up the file extension of the body
        pszExt = PathFindExtension(pszFile);
        
        // Do I support inlining this object ?
        if (lstrcmpi(pszExt, c_szBmpExt) ==  0  || 
            lstrcmpi(pszExt, c_szJpgExt) ==  0  || 
            lstrcmpi(pszExt, c_szJpegExt) == 0  || 
            lstrcmpi(pszExt, c_szGifExt) ==  0  || 
            lstrcmpi(pszExt, c_szIcoExt) ==  0  ||
            lstrcmpi(pszExt, c_szWmfExt) ==  0  ||
            lstrcmpi(pszExt, c_szPngExt) ==  0  ||
            lstrcmpi(pszExt, c_szEmfExt) ==  0  ||
            lstrcmpi(pszExt, c_szArtExt) ==  0  ||
            lstrcmpi(pszExt, c_szXbmExt) ==  0)
        {
            // Generate a Content-Id for this body
            IF_FAILEXIT(hr = _SetContentId(pNode, szCID, CCHMAX_CID));

            // If the user wants a slide show, then lets mark this body as a slideshow image
            if (ISFLAGSET(m_rOptions.dwFlags, WPF_SLIDESHOW))
            {
                // Mark the node as rendered
                rVariant.vt = VT_UI4;
                rVariant.ulVal = TRUE;

                // Set the Property
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)));

                // Count the number of items in the slide show
                m_cSlideShow++;

                // This node is in the slide show and will be processed at the end of the rendering
                FLAGSET(pNode->dwState, NODESTATE_INSLIDESHOW);

                // Basically, we rendered this body
                FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);

                // Done
                goto exit;
            }

            // Otherwise, inline it and mark it as rendered
            else
            {
                // Segment Splitter
                _DoSegmentSplitter();

                // Append a PageSegment
                IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

                // Write the HTML for an inline image
                IF_FAILEXIT(hr = pSegment->pStream->Write(STR_INLINE_IMAGE1, lstrlen(STR_INLINE_IMAGE1), NULL));

                // Write the CID
                IF_FAILEXIT(hr = pSegment->pStream->Write(szCID, lstrlen(szCID), NULL));

                // Write the HTML for an inline image
                IF_FAILEXIT(hr = pSegment->pStream->Write(STR_INLINE_IMAGE2, lstrlen(STR_INLINE_IMAGE2), NULL));

                // Rewind the stream
                IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

                // Link Segment into list...
                _VAppendSegment(pSegment);

                // Don't Free It
                pSegment = NULL;

                // Report that some data is available
                m_pRequest->OnBindingDataAvailable();

                // Mark the node as rendered
                rVariant.vt = VT_UI4;
                rVariant.ulVal = TRUE;

                // Set the Property
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
                SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &rVariant)));
            
                // Basically, we rendered this body
                FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);

                // Basically, we rendered this body
                goto exit;
            }
        }
    }

    // If we got here, we didn't inline the iamge
    hr = E_FAIL;

exit:
    // Cleanup
    SafeMemFree(pszFile);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::OnBodyBoundToTree
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::OnBodyBoundToTree(LPMESSAGETREE pTree, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszStart=NULL;
    LPSTR           pszType=NULL;
    PROPVARIANT     Variant;
    RESOLVEURLINFO  rInfo;

    // Tracing
    TraceCall("CMessageWebPage::OnBodyBoundToTree");

    // Invalid Args
    Assert(pTree && pNode && BINDSTATE_COMPLETE == pNode->bindstate);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Variant
    Variant.vt = VT_UI4;
    Variant.ulVal = FALSE;

    // Remove PID_ATT_RENDERED and PID_ATT_AUTOINLINED Properties
    pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &Variant);
    pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_AUTOINLINED), 0, &Variant);

    // If pNode is a multipart...
    if (S_OK == pNode->pContainer->IsContentType(STR_CNT_MULTIPART, NULL))
    {
        // Alternative
        if (S_OK == pNode->pContainer->IsContentType(NULL, STR_SUB_ALTERNATIVE))
        {
            // Bound multipart/alternative and non of its bodies got displayed on the web page
            if (FALSE == ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE))
            {
                // Loop through this multipart's alternative bodies...
                for (LPTREENODEINFO pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
                {
                    // text/plain -> text/html
                    if (S_OK == pChild->pContainer->IsContentType(STR_CNT_TEXT, NULL))
                    {
                        // Inline the body
                        IF_FAILEXIT(hr = _InlineTextBody(pTree, pChild, TRUE));

                        // Done
                        break;
                    }
                }
            }
        }
    }

    // Otherwise, non-multipart body
    else
    {
        // If in multipart/mixed or not in a multipart
        if (NULL == pNode->pParent || 
            S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_MIXED) ||
            S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, "report"))
        {
            // Try to inline as an image...
            if (FAILED(_InlineImageBody(pTree, pNode)))
            {
                // If is inline body
                if (S_FALSE == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT, FALSE, FALSE) || ISFLAGSET(pNode->dwState, NODESTATE_AUTOATTACH))
                {
                    // Inline the body
                    IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, FALSE));
                }
            }
        }

        // Otheriwse, is pNode inside of a multipart/related section
        else if (S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_RELATED))
        {
            // If we haven't rendered a body for this multipart/related section yet ?
            if (FALSE == ISFLAGSET(pNode->pParent->dwState, NODESTATE_ONWEBPAGE))
            {
                // Get the start parameter from pNode->pParent
                if (SUCCEEDED(pNode->pParent->pContainer->GetProp(STR_PAR_START, &pszStart)))
                {
                    // Setup Resolve URL Info
                    rInfo.pszInheritBase = NULL;
                    rInfo.pszBase = NULL;
                    rInfo.pszURL = pszStart;
                    rInfo.fIsCID = TRUE;

                    // See if pNode's Content-Id matches this...
                    if (SUCCEEDED(pNode->pContainer->HrResolveURL(&rInfo)))
                    {
                        // Inline the body
                        IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                    }
                }

                // Otherwise, fetch the type parameter
                else if (SUCCEEDED(pNode->pParent->pContainer->GetProp(STR_PAR_TYPE, &pszType)))
                {
                    // Is this the type ?
                    if (S_OK == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTTYPE), pszType, FALSE, FALSE))
                    {
                        // Inline the body
                        IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                    }
                }

                // Otherwise, if this is the first body in the multipart/related section
                else if (pNode == pNode->pParent->pChildHead)
                {
                    // Inline the body
                    IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                }
            }
        }

        // Otheriwse, is pNode inside of a multipart/alternative section
        else if (S_OK == pNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE))
        {
            // If we haven't rendered a body for this multipart/related section yet ?
            if (FALSE == ISFLAGSET(pNode->pParent->dwState, NODESTATE_ONWEBPAGE))
            {
                // Is there are start parameter ?
                if (pNode->pParent->pParent)
                {
                    // Is multipart/related ?
                    if (S_OK == pNode->pParent->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_RELATED))
                    {
                        // Get the Start Parameter
                        pNode->pParent->pParent->pContainer->GetProp(STR_PAR_START, &pszStart);
                    }
                }

                // Something that is not marked as an attachment ?
                if (S_FALSE == pNode->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT, FALSE, FALSE))
                {
                    // Try to inline ?
                    BOOL fTryToInline = TRUE;

                    // If there is a start parameter and this nod'es Content-Id is equal to start...
                    if (pszStart)
                    {
                        // Setup Resolve URL Info
                        rInfo.pszInheritBase = NULL;
                        rInfo.pszBase = NULL;
                        rInfo.pszURL = pszStart;
                        rInfo.fIsCID = TRUE;

                        // See if pNode's Content-Id matches this...
                        if (!SUCCEEDED(pNode->pContainer->HrResolveURL(&rInfo)))
                            fTryToInline = FALSE;
                    }

                    // Try to inline
                    if (fTryToInline)
                    {
                        // If we are rendering HTML
                        if (ISFLAGSET(m_rOptions.dwFlags, WPF_HTML))
                        {
                            // If this body is HTML
                            if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_HTML))
                            {
                                // Inline the body
                                IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                            }

                            // We can convert text/enriched to html
                            else if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED))
                            {
                                // Inline the body
                                IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                            }
                        }

                        // Otherwise, we are rendering plain text, and this body is plain text
                        else if (FALSE == ISFLAGSET(m_rOptions.dwFlags, WPF_HTML))
                        {
                            // Is text/*
                            if (S_OK == pNode->pContainer->IsContentType(STR_CNT_TEXT, STR_SUB_PLAIN))
                            {
                                // Inline the body
                                IF_FAILEXIT(hr = _InlineTextBody(pTree, pNode, TRUE));
                            }
                        }
                    }
                }
            }            
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeMemFree(pszStart);
    SafeMemFree(pszType);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_DoAttachmentLinks
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_DoAttachmentLinks(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    LPHBODY         prghAttach=NULL;
    CHAR            szRes[256];
    LPPAGESEGMENT   pSegment=NULL;
    CHAR            szCID[CCHMAX_CID];
    LPTREENODEINFO  pNode;
    LPSTR           pszDisplay=NULL;
    DWORD           cAttach;
    DWORD           i;

    // Tracing
    TraceCall("CMessageWebPage::_DoAttachmentLinks");

    // Get all the un-rendered stuff from the message
    IF_FAILEXIT(hr = pTree->GetAttachments(&cAttach, &prghAttach));
    
    // No Attachments
    if (0 == cAttach)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, TRUE));

    // Load Attachment Title
    LoadString(g_hLocRes, idsAttachTitleBegin, szRes, ARRAYSIZE(szRes));

    // Write the HTML for the attachment section title...
    IF_FAILEXIT(hr = pSegment->pStream->Write(szRes, lstrlen(szRes), NULL));

    // Loop through the Attachments
    for (i=0; i<cAttach; i++)
    {
        // Get the Node
        pNode = pTree->_PNodeFromHBody(prghAttach[i]);

        // Should not already be on the web page
        Assert(!ISFLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE) && !ISFLAGSET(pNode->dwState, NODESTATE_INSLIDESHOW));

        // Get the display name
        IF_FAILEXIT(hr = pNode->pBody->GetDisplayName(&pszDisplay));

        // Generate a Content-Id for this body
        IF_FAILEXIT(hr = _SetContentId(pNode, szCID, CCHMAX_CID));

        // Write the HTML for a bulleted attachment
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_BEGIN, lstrlen(STR_ATTACH_BEGIN), NULL));

        // Write the Content-Id
        IF_FAILEXIT(hr = pSegment->pStream->Write(szCID, lstrlen(szCID), NULL));

        // Write the HTML for a bulleted attachment
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_MIDDLE, lstrlen(STR_ATTACH_MIDDLE), NULL));

        // Write the friendly name
        IF_FAILEXIT(hr = pSegment->pStream->Write(pszDisplay, lstrlen(pszDisplay), NULL));

        // Write the HTML for a bulleted attachment
        IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_END, lstrlen(STR_ATTACH_END), NULL));

        // Cleanup
        SafeMemFree(pszDisplay);

        // This node is on the webpage
        FLAGSET(pNode->dwState, NODESTATE_ONWEBPAGE);
    }

    // Write the HTML for the attachment title end
    IF_FAILEXIT(hr = pSegment->pStream->Write(STR_ATTACH_TITLE_END, lstrlen(STR_ATTACH_TITLE_END), NULL));

    // Rewind the stream
    IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

    // Link Segment into list...
    _VAppendSegment(pSegment);

    // Don't Free It
    pSegment = NULL;

    // Report that some data is available
    m_pRequest->OnBindingDataAvailable();

exit:
    // Cleanup
    SafeMemFree(prghAttach);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::_DoSlideShow
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::_DoSlideShow(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPTREENODEINFO  pNode;
    LPPAGESEGMENT   pSegment=NULL;
    CHAR            szSlideEnd[255];
    IStream        *pStmHtmlW=NULL;
    LPSTR           pszValueA=NULL;
    LPWSTR          pszValueW=NULL;

    // Tracing
    TraceCall("CMessageWebPage::_DoSlideShow");

    // Invalid Arg
    Assert(pTree);

    // No Slides
    if (0 == m_cSlideShow)
        return S_OK;

    // Load the inline HTML
    IF_FAILEXIT(hr = HrLoadStreamFileFromResourceW(GetACP(), "inline.htm", &pStmHtmlW));

    // Walk through all the nodes and get the things that are marked for the slide show
    for (i=0; i<pTree->m_rTree.cNodes; i++)
    {
        // Get the node
        pNode = pTree->m_rTree.prgpNode[i];
        if (NULL == pNode)
            continue;

        // If not marked NODESTATE_INSLIDESHOW
        if (FALSE == ISFLAGSET(pNode->dwState, NODESTATE_INSLIDESHOW))
            continue;

        // Append the ssimage
        IF_FAILEXIT(hr = pStmHtmlW->Write(STR_SLIDEIMG_BEGIN, lstrlenW(STR_SLIDEIMG_BEGIN) * sizeof(WCHAR), NULL));

        // Get the ContentId
        IF_FAILEXIT(hr = pNode->pContainer->GetProp(PIDTOSTR(PID_HDR_CNTID), &pszValueA));

        // Convert to Unicode
        IF_NULLEXIT(pszValueW = PszToUnicode(MimeOleGetWindowsCP(m_hCharset), pszValueA));

        // Append the Content-ID
        IF_FAILEXIT(hr = pStmHtmlW->Write(pszValueW, lstrlenW(pszValueW) * sizeof(WCHAR), NULL));

        // Free pszValue
        SafeMemFree(pszValueA);
        SafeMemFree(pszValueW);

        // Append the separator
        IF_FAILEXIT(hr = pStmHtmlW->Write(STR_QUOTECOMMASPACEQUOTE, lstrlenW(STR_QUOTECOMMASPACEQUOTE) * sizeof(WCHAR), NULL));

        // Get the Display Name
        IF_FAILEXIT(hr = pNode->pBody->GetDisplayName(&pszValueA));

        // Convert to Unicode
        IF_NULLEXIT(pszValueW = PszToUnicode(MimeOleGetWindowsCP(m_hCharset), pszValueA));

        // Append the Display Name
        IF_FAILEXIT(hr = pStmHtmlW->Write(pszValueW, lstrlenW(pszValueW) * sizeof(WCHAR), NULL));

        // Free pszValue
        SafeMemFree(pszValueA);
        SafeMemFree(pszValueW);

        // Append the separator
        IF_FAILEXIT(hr = pStmHtmlW->Write(STR_QUOTEPARASEMI, lstrlenW(STR_QUOTEPARASEMI) * sizeof(WCHAR), NULL));
    }

    // Format the Ending String
    wsprintf(szSlideEnd, "g_dwTimeOutSec=%d\r\n</SCRIPT>\r\n", (m_rOptions.dwDelay / 1000));

    // Convert to Unicode
    IF_NULLEXIT(pszValueW = PszToUnicode(MimeOleGetWindowsCP(m_hCharset), szSlideEnd));

    // Append the separator
    IF_FAILEXIT(hr = pStmHtmlW->Write(pszValueW, lstrlenW(pszValueW) * sizeof(WCHAR), NULL));

    // Rewind the stream
    IF_FAILEXIT(hr = HrRewindStream(pStmHtmlW));

    // Append a PageSegment
    IF_FAILEXIT(hr = _AllocateSegment(&pSegment, FALSE));

    // Now we have a unicode stream, we have to convert back to internet charset for rootstream
    IF_FAILEXIT(hr = HrIStreamWToInetCset(pStmHtmlW, m_hCharset, &pSegment->pStream));

    // Rewind the stream
    IF_FAILEXIT(hr = HrRewindStream(pSegment->pStream));

    // Link Segment into list...
    _VAppendSegment(pSegment);

    // Don't Free It
    pSegment = NULL;

    // Report that some data is available
    m_pRequest->OnBindingDataAvailable();

exit:
    // Cleanup
    SafeMemFree(pszValueA);
    SafeMemFree(pszValueW);
    SafeRelease(pStmHtmlW);
    if (pSegment)
        _VFreeSegment(pSegment);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::OnBindComplete
// --------------------------------------------------------------------------------
HRESULT CMessageWebPage::OnBindComplete(LPMESSAGETREE pTree)
{
    // Locals
    HRESULT         hr=S_OK;

    // Tracing
    TraceCall("CMessageWebPage::OnBindComplete");

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We Better have a Request
    Assert(pTree && m_pRequest && FALSE == m_fComplete);

    // Attachment Links ?
    if (ISFLAGSET(m_rOptions.dwFlags, WPF_ATTACHLINKS))
        _DoAttachmentLinks(pTree);

    // Slide Show ?
    if (ISFLAGSET(m_rOptions.dwFlags, WPF_SLIDESHOW))
        _DoSlideShow(pTree);

    // Complete
    m_fComplete = TRUE;

    // Tell the Request That we are done
    m_pRequest->OnBindingComplete(S_OK);

    // Release the Request
    SafeRelease(m_pRequest);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageWebPage::OnWebPageSplitter
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageWebPage::OnWebPageSplitter(DWORD cInlined, IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;

    // Tracing
    TraceCall("CMessageWebPage::OnWebPageSplitter");

    // I'm going to put a horizontal line between each segment
    if (cInlined > 0)
    {
        // Write STR_METATAG_PREFIX
        IF_FAILEXIT(hr = pStream->Write(STR_SEGMENT_SPLIT, lstrlen(STR_SEGMENT_SPLIT), NULL));
    }

    // Otherwise, I did nothing
    else
        hr = S_FALSE;

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\webpage.h ===
// --------------------------------------------------------------------------------
// WebPage.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __WEBPAGE_H
#define __WEBPAGE_H

// -----------------------------------------------------------------------------
// Forward Decls
// -----------------------------------------------------------------------------
class CVirtualStream;
class CMessageTree;
class CActiveUrlRequest;
typedef class CActiveUrlRequest *LPURLREQUEST;
typedef CMessageTree *LPMESSAGETREE;
typedef struct tagTREENODEINFO *LPTREENODEINFO;

// -----------------------------------------------------------------------------
// PAGESEGMENT
// -----------------------------------------------------------------------------
typedef struct tagPAGESEGMENT *LPPAGESEGMENT;
typedef struct tagPAGESEGMENT {
    DWORD               cbOffset;           // IStream Read / Seek Offset
    DWORD               cbLength;           // How long is this segment
    BYTE                fLengthKnown;       // Have I computed the length of this segment
    IStream            *pStream;            // The stream containing the data for this segment
    LPPAGESEGMENT       pPrev;              // The previous segment
    LPPAGESEGMENT       pNext;              // The next segment
} PAGESEGMENT;

// -----------------------------------------------------------------------------
// CMessageWebPage
// -----------------------------------------------------------------------------
class CMessageWebPage : public IStream, public IMimeMessageCallback
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CMessageWebPage(LPURLREQUEST pRequest);
    ~CMessageWebPage(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
    STDMETHODIMP Read(LPVOID pvData, ULONG cbData, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP Write(const void *, ULONG, ULONG *) { return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) { return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG *pStat, DWORD dw) { return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Revert(void) { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) { return E_NOTIMPL; }

    // ----------------------------------------------------------------------------
    // IMimeWebaPageCallback (Default Implementation if client doesn't specify)
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnWebPageSplitter(DWORD cInlined, IStream *pStream);

    // -------------------------------------------------------------------------
    // CMessageWebPage Methods
    // -------------------------------------------------------------------------
    HRESULT Initialize(IMimeMessageCallback *pCallback, LPMESSAGETREE pTree, LPWEBPAGEOPTIONS pOptions);
    HRESULT OnBodyBoundToTree(LPMESSAGETREE pTree, LPTREENODEINFO pNode);
    HRESULT OnBindComplete(LPMESSAGETREE pTree);

private:
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    void _VFreeSegmentList(void);
    void _VFreeSegment(LPPAGESEGMENT pSegment);
    void _VAppendSegment(LPPAGESEGMENT pSegment);
    void _VInitializeCharacterSet(LPMESSAGETREE pTree);
    HRESULT _AllocateSegment(LPPAGESEGMENT *ppSegment, BOOL fCreateStream);
    HRESULT _GetInlineHtmlStream(LPMESSAGETREE pTree, LPTREENODEINFO pNode, LPSTREAM *ppStream);
    HRESULT _InlineTextBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode, BOOL fSetParents);
    HRESULT _InlineImageBody(LPMESSAGETREE pTree, LPTREENODEINFO pNode);
    HRESULT _DoAttachmentLinks(LPMESSAGETREE pTree);
    HRESULT _DoSegmentSplitter(void);
    HRESULT _SetContentId(LPTREENODEINFO pNode, LPSTR pszCID, ULONG cchCID);
    HRESULT _ComputeStreamSize(LPDWORD pcbSize);
    HRESULT _DoSlideShow(LPMESSAGETREE pTree);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG                    m_cRef;             // Reference count
    HCHARSET                m_hCharset;         // Character set of the message
    WEBPAGEOPTIONS          m_rOptions;         // WebPage Options
    LPURLREQUEST            m_pRequest;         // Url Request for root stream
    LPPAGESEGMENT           m_pHeadSegment;     // First Segment
    LPPAGESEGMENT           m_pTailSegment;     // Last Segment
    LPPAGESEGMENT           m_pCurrSegment;     // Current Segment
    DWORD                   m_cbOffset;         // Stream Offset
    BYTE                    m_fComplete;        // Has BindComplete been called
    DWORD                   m_cInline;          // Number of inline bodies
    DWORD                   m_cSlideShow;       // Number of images to put into a slide show
    IMimeMessageCallback   *m_pCallback;        // WebPage Callback
    CRITICAL_SECTION        m_cs;               // Critical Section for m_pStream
};

#endif // __WEBPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\wraptext.cpp ===
// --------------------------------------------------------------------------------
// Wraptext.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "inetstm.h"

// --------------------------------------------------------------------------------
// MimeOleWrapTextStream
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleWrapTextStream(
            LPWRAPTEXTINFO   pWrapInfo,
            IStream         *pstmIn, 
            IStream         *pstmOut)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPSTRINGA     rLine;
    CInternetStream cInternet;

    // check params
    if (NULL == pWrapInfo || NULL == pstmIn || NULL == pstmOut)
        return TrapError(E_INVALIDARG);

    // Minimum maximum line length
    if (pWrapInfo->cbMaxLine < 10)
        pWrapInfo->cbMaxLine = 10;

    // Init cLines
    pWrapInfo->cLines = 0;

    // Validate Code Page
    if (IsValidCodePage(pWrapInfo->cpiCodePage) == FALSE)
    {
        Assert(FALSE);
        pWrapInfo->cpiCodePage = CP_ACP;
    }

	// Create text stream object
	CHECKHR(hr = cInternet.HrInitNew(pstmIn));

    // Read lines
    while (1)
    {
		// Read header line...
        CHECKHR(hr = cInternet.HrReadLine(&rLine));

        // Zero bytes read, were done
        if (0 == rLine.cchVal)
            break;

        // Is line longer than ulMaxLen ?
        if (rLine.cchVal > pWrapInfo->cbMaxLine)
        {
            // Wrap and Write the line
            CHECKHR (hr = MimeOleWrapText(pWrapInfo, (LPBYTE)rLine.pszVal, rLine.cchVal, pstmOut));
        }

        else
        {
            // If Folding...
            if (pWrapInfo->fFolding)
            {
                // Write the data
                CHECKHR(hr = pstmOut->Write(g_szTab, 1, NULL));
            }

            // Stuff dots
            else if (pWrapInfo->fStuffLeadDots && '.' == *rLine.pszVal)
            {
                // Write the data
                CHECKHR(hr = pstmOut->Write(c_szPeriod, 1, NULL));
            }

            // Write the line
            CHECKHR(hr = pstmOut->Write(rLine.pszVal, rLine.cchVal, NULL));

            // Increment Line Count
            pWrapInfo->cLines++;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ComputeLineBreakA
// --------------------------------------------------------------------------------
ULONG ComputeLineBreakA(
            LPWRAPTEXTINFO      pWrapInfo, 
            LPBYTE              pbText, 
            ULONG               cbText, 
            ULONG               iText)
    // !!!!!!!  DON'T FORGET ABOUT THE WIDE VERSION !!!!!!!!!!
{
    // Locals
    ULONG   cbLine,
            iScanTo,
            iStart;
    CHAR    ch;
    LONG    iLastWordBreak=-1;
    WORD    wType;

    // Invalid Arg
    Assert(pWrapInfo->cbBreakAfter);

    // Broke on space = FALSE
    pWrapInfo->fLastBreakSpace = FALSE;

    // Set Indent
    cbLine = pWrapInfo->cLines == 0 ? pWrapInfo->cbFirstLineIndent : 0;

    // I can scan at most... (cbText - iText) 
    iScanTo = iText + min(cbText - iText, pWrapInfo->cbMaxLine - cbLine);

    // Set Start
    iStart = iText;

    // Loop to next word break
    while(iText < iScanTo)
    {
        // Get Char
        ch = pbText[iText];

        // IsLeadByte
        if (IsDBCSLeadByteEx(pWrapInfo->cpiCodePage, ch))
        {
            iText+=2;
            continue;
        }

        // End of String
        if (chLF == ch)
        {
            iText++;
            iLastWordBreak = iText;
            pWrapInfo->fLastBreakSpace = FALSE;
            goto exit;
        }

        // Space
        if (' ' == ch || '\t' == ch)
        {
            pWrapInfo->fLastBreakSpace = TRUE;
            iLastWordBreak = iText;
        }

        // Next Character
        iText++;
    }

    // !!!!!!!  DON'T FORGET ABOUT THE WIDE VERSION !!!!!!!!!!
    // 1. If we reached the end of the buffer, break at iText
    // 2. If we didn't find a word break space, break at iText
    // 3. If the word break space was more than cbBreakAfter before iText, then break at iText
    if ((iText < cbText && -1 != iLastWordBreak) && ((iText - iLastWordBreak) <= pWrapInfo->cbBreakAfter))
    {
       pWrapInfo->fLastBreakSpace = TRUE;
    }
    else
    {
        iLastWordBreak = iText;
        pWrapInfo->fLastBreakSpace = FALSE;
    }

exit:
    // !!!!!!!  DON'T FORGET ABOUT THE WIDE VERSION !!!!!!!!!!
    // Done
    return iLastWordBreak - iStart;
}

// --------------------------------------------------------------------------------
// ComputeLineBreakW
// --------------------------------------------------------------------------------
ULONG ComputeLineBreakW(
            LPWRAPTEXTINFO      pWrapInfo, 
            LPBYTE              pbText,
            ULONG               cbText, 
            ULONG               iText)
    // !!!!!!!  DON'T FORGET ABOUT THE ANSI VERSION !!!!!!!!!!
{
    // Locals
    ULONG   cbLine,
            iScanTo,
            iStart;
    WCHAR   wch;
    LONG    iLastWordBreak=-1;
    WORD    wType;

    // Invalid Arg
    Assert(pWrapInfo->cbBreakAfter);

    // Broke on space = FALSE
    pWrapInfo->fLastBreakSpace = FALSE;

    // Set Indent
    cbLine = pWrapInfo->cLines == 0 ? pWrapInfo->cbFirstLineIndent : 0;

    // I can scan at most... (cbText - iText) 
    iScanTo = iText + min(cbText - iText, pWrapInfo->cbMaxLine - cbLine);

    // Set Start
    iStart = iText;

    // Adjust iScnato to 2 boundary
    Assert(iScanTo % 2 == 0);

    // Loop to next word break
    while(iText < iScanTo)
    {
        // I should always have increments of two...
        Assert(iText % 2 == 0 && iText + 2 <= iScanTo);

        // Get Char
        wch = *((WCHAR *)(&pbText[iText]));

        // End of String 0x000D
#ifdef MAC
        if (OLESTR('\r') == wch)
#else   // !MAC
        if (OLESTR('\n') == wch)
#endif  // MAC
        {
            iText+=2;
            iLastWordBreak = iText;
            pWrapInfo->fLastBreakSpace = FALSE;
            goto exit;
        }

        // Space
        if (OLESTR(' ') == wch || OLESTR('\t') == wch)
        {
            pWrapInfo->fLastBreakSpace = TRUE;
            iLastWordBreak = iText;
        }

        // Next Character
        iText+=2;
    }

    // !!!!!!!  DON'T FORGET ABOUT THE ANSI VERSION !!!!!!!!!!
    // 1. If we reached the end of the buffer, break at iText
    // 2. If we didn't find a word break space, break at iText
    // 3. If the word break space was more than cbBreakAfter before iText, then break at iText
    if ((iText < cbText && -1 != iLastWordBreak) && ((iText - iLastWordBreak) <= pWrapInfo->cbBreakAfter))
    {
       pWrapInfo->fLastBreakSpace = TRUE;
    }
    else
    {
        iLastWordBreak = iText;
        pWrapInfo->fLastBreakSpace = FALSE;
    }

exit:
    // !!!!!!!  DON'T FORGET ABOUT THE ANSI VERSION !!!!!!!!!!
    // Done
    return iLastWordBreak - iStart;
}

// --------------------------------------------------------------------------------
// MimeOleWrapText
// --------------------------------------------------------------------------------
MIMEOLEAPI MimeOleWrapText(
            LPWRAPTEXTINFO      pWrapInfo,
            LPBYTE              pbText,
            ULONG               cbText,
            IStream            *pstmDest)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       iText=0,
                iBreak,
                cbLine;
    LPSTR       pszLine;

    // Start Writing
    while(1)
    {
        // Compute Next Line Break.
        cbLine = ComputeLineBreakA(pWrapInfo, pbText, cbText, iText);

        // Done
        if (0 == cbLine)
        {
            // Final Line Wrap
            CHECKHR(hr = pstmDest->Write(c_szCRLF, 2, NULL));

            // Increment Line Count
            pWrapInfo->cLines++;

            // Done
            break;
        }

        // Set pszLine
        pszLine = (LPSTR)(pbText + iText);

        // Stuff dots
        if (pWrapInfo->fStuffLeadDots && '.' == *pszLine)
        {
            // Write the data
            CHECKHR(hr = pstmDest->Write(c_szPeriod, 1, NULL));
        }

        // Write the line
        CHECKHR(hr = pstmDest->Write(pszLine, cbLine, NULL));

        // If there is still more text
        if (iText + cbLine < cbText)
        {
            // If Folding...
            if (pWrapInfo->fFolding)
            {
                // Line Ended with a CRLF
                if (chLF == pszLine[cbLine-1])
                {
                    // Just write the folding character
                    CHECKHR(hr = pstmDest->Write("\t", 1, NULL));
                }

                // Write fold
                else
                {
                    // Write '\r\n\t'
                    CHECKHR(hr = pstmDest->Write(c_szCRLFTab, 3, NULL));
                }
            }

            // Otherwise, just write CRLF
            else if (chLF != pszLine[cbLine-1])
            {
                CHECKHR(hr = pstmDest->Write(c_szCRLF, 2, NULL));
            }

            // Increment Line Count
            pWrapInfo->cLines++;
        }

        // Increment iText
        iText+=cbLine;
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\mimetest\mimetest.cpp ===
// --------------------------------------------------------------------------------
// Mimetest.cpp
//
// This is a console app that has various types of functions that highlight the
// most typical ways to use mimeole. This console app also acts as a test program
// for mimeole, but does not actually do anything.
//
// Here are the files you need to use mimeole:
//
// mimeole.h    - This is the main header file. It is generated from mimeole.idl.
// mimeole.idl  - This is the interface definition file. It has a little bit of
//                documentation. A client should use this file to find out info
//                about mimeole interfaces, data types, utility functions, etc.
// inetcomm.dll - This is the DLL that contains the implementation of everything
//                in mimeole.h. You should run regsvr32.exe on inetcomm.dll.
// msoert2.dll  - inetcomm.dll statically links to this dll. msoert2 is the Microsoft
//                Outlook Express runtime library. msoert2.dll is part of the Outlook
//                Express installation. This DLL does not require any registration.
// shlwapi.dll  - inetcomm.dll statically links to this dll. shlwapi is part of the
//                Internet Explorer installation. shlwapi does not require any
//                registration.
// mlang.dll    - inetcomm.dll will dynamically load this dll. mlang is used to support
//                various character set translations. mlang stands for multi-language.
//                This DLL is part of the Internet Explorer installation. You should
//                run regsvr32.exe on mlang.dll to register it.
// urlmon.dll   - inetcomm.dll will dynamically load this dll. urlmon is used by 
//                inetcomm to support various parts of MHTML as well as rendering
//                MHTML inside of the IE browser.
// SMIME        - SMIME support in mimeole requires the crypto API, which is part of
//                the IE installation.

// Notes: shlwapi and msoert2, as well as any other DLLs that inetcomm.dll statically
//        links to must be either in the same directory as inetcomm.dll, or be located
//        in a directory that is in the system path.
//
//        The DLLs that inetcomm dynamically load are not required. Inetcomm will still
//        work, although certain functionality will be disabled.
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// To use mimeole objects, per COM rules, you must have one file in your project that
// has the #define INITGUID line, and then include mimeole.h. This will cause all of 
// the CLSIDs and IIDs to be defined.
// --------------------------------------------------------------------------------
#define INITGUID

// --------------------------------------------------------------------------------
// This is simply my precompiled header
// --------------------------------------------------------------------------------
#include "pch.h"
#include <shlwapi.h>
#include <shlwapip.h>

// --------------------------------------------------------------------------------
// Part of the initguid process
// --------------------------------------------------------------------------------
#include <initguid.h>

// --------------------------------------------------------------------------------
// Primary mimeole header file
// --------------------------------------------------------------------------------
#include <mimeole.h>
                      

#define DEFINE_HOTSTORE

// --------------------------------------------------------------------------------
// I'm disable various parts of MOSERT so that I can use it from within this test
// program.
// --------------------------------------------------------------------------------
#define MSOERT_NO_PROTSTOR
#define MSOERT_NO_BYTESTM
#define MSOERT_NO_STRPARSE
#define MSOERT_NO_ENUMFMT
#define MSOERT_NO_CLOGFILE
#define MSOERT_NO_DATAOBJ

// --------------------------------------------------------------------------------
// I know you don't have this, but you can if you want it. This header has a bunch
// of slick macros. I will try not to use too many of them.
// --------------------------------------------------------------------------------
#include "d:\\athena\\inc\\msoert.h"

// --------------------------------------------------------------------------------
// Test function Prototypes
// --------------------------------------------------------------------------------
HRESULT MimeTestAppendRfc822(IMimeMessage **ppMessage);
HRESULT MimeTestSettingContentLocation(IMimeMessage **ppMessage);
HRESULT MimeTestGetMultiValueAddressProp(IMimeMessage **ppMessage);
HRESULT MimeTestLookupCharsetHandle(LPCSTR pszCharset, LPHCHARSET phCharset);
HRESULT MimeTestSettingReplyTo(IMimeMessage **ppMessage);
HRESULT MimeTestSplitMessageIntoParts(void);
HRESULT MimeTestRecombineMessageParts(LPWSTR *prgpszFile, ULONG cFiles);
HRESULT MimeTestIsContentType(IMimeMessage **ppMessage);
HRESULT MimeTestBodyStream(IMimeMessage **ppMessage);
HRESULT MimeTestDeleteBody(IMimeMessage **ppMessage);
HRESULT MimeTestEnumHeaderTable(IMimeMessage **ppMessage);
HRESULT MimeTestCDO(IMimeMessage **ppMessage);

// --------------------------------------------------------------------------------
// Utility functions used by mimetest
// --------------------------------------------------------------------------------
HRESULT DumpStreamToConsole(IStream *pStream);
HRESULT ReportError(LPCSTR pszFunction, INT nLine, LPCSTR pszErrorText, HRESULT hrResult);
HRESULT ReportStatus(LPCSTR pszStatusText);
HRESULT CreateMimeMessage(IMimeMessage **ppMessage);
HRESULT SaveMimeMessage(IMimeMessage *pMessage, MIMESAVETYPE savetype, IStream **ppStream);
         
// --------------------------------------------------------------------------------
// Testing Switches
// --------------------------------------------------------------------------------
// #define TEST_MimeTestAppendRfc822
// #define TEST_MimeTestSettingContentLocation
// #define TEST_MimeTestGetMultiValueAddressProp
// #define TEST_MimeTestSettingReplyTo
// #define TEST_MimeTestSplitMessageIntoParts
// #define TEST_MimeTestIsContentType
// #define TEST_MimeTestBodyStream
// #define TEST_MimeTestDeleteBody
// #define TEST_MimeTestEnumHeaderTable
#define TEST_MimeTestCDO

// --------------------------------------------------------------------------------
// MimeTest Entry Point
// --------------------------------------------------------------------------------
void __cdecl main(int argc, char *argv[])
{
    // Locals
    HRESULT hr;
    IMimeMessage *pMessage=NULL;

    // You must always call this if you are going to use COM
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "CoInitialize failed.", hr);
        exit(1);
    }

    IDatabaseTable *pTable;
    HROWSET hRowset;
    MESSAGEINFO Message;
    CoCreateInstance(CLSID_DatabaseTable, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseTable, (LPVOID *)&pTable);
    pTable->Open("d:\\store\\00000004.dbx", 0, &g_MessageTableSchema, NULL);
    pTable->CreateRowset(IINDEX_SUBJECT, 0, &hRowset);
    while (S_OK == pTable->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        printf("%08d: %s\n", Message.idMessage, Message.pszSubject);
        pTable->FreeRecord(&Message);
    }
    pTable->CloseRowset(&hRowset);
    pTable->Release();
    exit(1);


    // ----------------------------------------------------------------------------
    // TEST_MimeTestCDO
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestCDO
    MimeTestCDO(NULL);
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestEnumHeaderTable
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestEnumHeaderTable
    hr = MimeTestEnumHeaderTable(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestEnumHeaderTable failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestDeleteBody
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestDeleteBody
    hr = MimeTestDeleteBody(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestDeleteBody failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestBodyStream
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestBodyStream
    hr = MimeTestBodyStream(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestBodyStream failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestIsContentType
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestIsContentType
    hr = MimeTestIsContentType(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestIsContentType failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestAppendRfc822
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestAppendRfc822
    hr = MimeTestAppendRfc822(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestAppendRfc822 failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestGetMultiValueAddressProp
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestGetMultiValueAddressProp
    hr = MimeTestGetMultiValueAddressProp(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestAppendRfc822 failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestSettingContentLocation
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestSettingContentLocation
    hr = MimeTestSettingContentLocation(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestSettingContentLocation failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestSettingReplyTo
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestSettingReplyTo
    hr = MimeTestSettingReplyTo(NULL);
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestSettingReplyTo failed.", hr);
        goto exit;
    }
#endif

    // ----------------------------------------------------------------------------
    // TEST_MimeTestSplitMessageIntoParts
    // ----------------------------------------------------------------------------
#ifdef TEST_MimeTestSplitMessageIntoParts
    hr = MimeTestSplitMessageIntoParts();
    if (FAILED(hr))
    {
        ReportError("main", __LINE__, "MimeTestSplitMessageIntoParts failed.", hr);
        goto exit;
    }
#endif

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();

    // I called CoInitialize, so lets call this...
    CoUninitialize();

    // Done
    exit(1);
}


// --------------------------------------------------------------------------------
// MimeTestCDO
// --------------------------------------------------------------------------------
//#define RAID_17675
#define RAID_20406
//#define RAID_29961

HRESULT MimeTestCDO(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                  hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    PROPVARIANT              Variant;
    LPSTR                    psz;
    FINDBODY                 FindBody={0};
    HBODY                    hBody;
    HCHARSET                 hCharset;
    IMimeBody               *pBody=NULL;
    IMimeInternational      *pInternat=NULL;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
        goto exit;

#ifdef RAID_29961
    hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, IID_IMimeInternational, (LPVOID *)&pInternat);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
        goto exit;

    hr = pPersistFile->Load(L"j:\\test\\raid29961.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto exit;

    FindBody.pszPriType = "text";
    FindBody.pszSubType = "plain";

    hr = pMessage->FindFirst(&FindBody, &hBody);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
        goto exit;

    hr = pInternat->FindCharset("iso-8859-7", &hCharset);
    if (FAILED(hr))
        goto exit;

    hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
    if (FAILED(hr))
        goto exit;

    pBody->Release();
    pBody = NULL;

    hr = pMessage->FindNext(&FindBody, &hBody);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
        goto exit;

    hr = pInternat->FindCharset("iso-8859-4", &hCharset);
    if (FAILED(hr))
        goto exit;

    hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
    if (FAILED(hr))
        goto exit;

    pBody->Release();
    pBody = NULL;

    hr = pInternat->FindCharset("iso-8859-3", &hCharset);
    if (FAILED(hr))
        goto exit;

    hr = pMessage->SetCharset(hCharset, CSET_APPLY_UNTAGGED);
    if (FAILED(hr))
        goto exit;

    hr = pPersistFile->Save(L"j:\\test\\raid29961_saved.eml", FALSE);
    if (FAILED(hr))
        goto exit;
    
#endif

#ifdef RAID_17675
    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
        goto exit;

    // Load
    hr = pPersistFile->Load(L"c:\\test\\cdo.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto exit;

    ZeroMemory(&Variant, sizeof(PROPVARIANT));
    Variant.vt = VT_EMPTY;        
    hr = pMessage->SetProp("par:content-type:charset", 0, &Variant);
//    if (FAILED(hr))
//        goto exit;

    Variant.vt = VT_LPSTR;        
    hr = pMessage->GetProp("par:content-type:charset", 0, &Variant);
    if (FAILED(hr))
        goto exit;

#endif // RAID_17675

#ifdef RAID_20406

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
        goto exit;

    // Load
    hr = pPersistFile->Load(L"c:\\test\\address.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto exit;

    pMessage->GetAddressFormat(IAT_TO, AFT_DISPLAY_FRIENDLY, &psz);
    printf("AFT_DISPLAY_FRIENDLY: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_DISPLAY_EMAIL, &psz);
    printf("AFT_DISPLAY_EMAIL: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_DISPLAY_BOTH, &psz);
    printf("AFT_DISPLAY_BOTH: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_RFC822_DECODED, &psz);
    printf("AFT_RFC822_DECODED: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_RFC822_ENCODED, &psz);
    printf("AFT_RFC822_ENCODED: %s\n", psz);
    CoTaskMemFree(psz);

    pMessage->GetAddressFormat(IAT_TO, AFT_RFC822_TRANSMIT, &psz);
    printf("AFT_RFC822_TRANSMIT: %s\n", psz);
    CoTaskMemFree(psz);

#endif // RAID_20406

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();
    if (pPersistFile)
        pPersistFile->Release();
    if (pInternat)
        pInternat->Release();

    // Done
    return(hr);
}
 
// --------------------------------------------------------------------------------
// MimeTestEnumHeaderTable
// --------------------------------------------------------------------------------
HRESULT MimeTestEnumHeaderTable(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    IMimeHeaderTable        *pTable=NULL;
    IMimeEnumHeaderRows     *pEnum=NULL;
    ENUMHEADERROW            Row;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile) failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"c:\\test\\multiadd.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    // Get Enumerator
    hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeHeaderTable, (LPVOID *)&pTable);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "pMessage->BindToObject(HBODY_ROOT, IID_IMimeHeaderTable, ...) failed.", hr);
        goto exit;
    }

    // EnumRows
    hr = pTable->EnumRows(NULL, 0, &pEnum);
    if (FAILED(hr))
    {
        ReportError("MimeTestEnumHeaderTable", __LINE__, "pTable->EnumRows failed.", hr);
        goto exit;
    }

    // Loop
    while (S_OK == pEnum->Next(1, &Row, NULL))
    {
        printf("%s: %s\n", Row.pszHeader, Row.pszData);
        CoTaskMemFree(Row.pszHeader);
        CoTaskMemFree(Row.pszData);
    }

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pPersistFile)
        pPersistFile->Release();
    if (pMessage)
        pMessage->Release();
    if (pTable)
        pTable->Release();
    if (pEnum)
        pEnum->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestDeleteBody
// --------------------------------------------------------------------------------
HRESULT MimeTestDeleteBody(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    HBODY                   hBody;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile) failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"d:\\test\\delbody.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"d:\\test\\delbody.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    goto exit;

    // Get the root body
    hr = pMessage->GetBody(IBL_ROOT, NULL, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->GetBody failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->GetBody(IBL_FIRST, hBody, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->GetBody failed.", hr);
        goto exit;
    }

    // Delete the Root
    hr = pMessage->DeleteBody(hBody, DELETE_PROMOTE_CHILDREN);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->DeleteBody failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->GetBody(IBL_ROOT, NULL, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->GetBody failed.", hr);
        goto exit;
    }

    // Delete the Root
    hr = pMessage->DeleteBody(hBody, 0);
    if (FAILED(hr))
    {
        ReportError("MimeTestDeleteBody", __LINE__, "pMessage->DeleteBody failed.", hr);
        goto exit;
    }

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pPersistFile)
        pPersistFile->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestBodyStream
// --------------------------------------------------------------------------------
#if 0
HRESULT MimeTestBodyStream(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IStream                 *pStmSave=NULL;
    IStream                 *pStmBody=NULL;
    IStream                 *pStmText=NULL;
    IStream                 *pStmTxtOut=NULL;
    IMimeBody               *pBody=NULL;
    PROPVARIANT             rVariant;
    IWaveAudio              *pWave=NULL;
    IWaveStream             *pStmWave=NULL;
    DWORD                   cAttach;
    HBODY                   hBody;
    HBODY                   *prghAttach=NULL;
    DWORD                   cb;
    DWORD                   dw;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Create a stream in which to save the message...
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStmText);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateStreamOnHGlobal failed", hr);
        goto exit;
    }

    // Write some text into pStmText
    hr = pStmText->Write("Testing BodyStream.", lstrlen("Testing BodyStream."), NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pStmText->Write failed", hr);
        goto exit;
    }

    // Commit
    pStmText->Commit(STGC_DEFAULT);

    // Rewind it
    HrRewindStream(pStmText);

    // Set the text body
    hr = pMessage->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pStmText, NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->SetTextBody failed", hr);
        goto exit;
    }

    // Attach a file
    hr = pMessage->AttachFile("d:\\waveedit\\test.wav", NULL, NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeMessage::AttachFile failed.", hr);
        goto exit;
    }

    // Save that bad boy to a stream
    hr = CreateTempFileStream(&pStmSave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateTempFileStream failed.", hr);
        goto exit;
    }

    // Save the message
    hr = pMessage->Save(pStmSave, TRUE);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->Save failed.", hr);
        goto exit;
    }

    // Commit
    pStmSave->Commit(STGC_DEFAULT);

    // Release pMessage
    pMessage->Release();
    pMessage = NULL;

    // Rewind pStmSave
    HrRewindStream(pStmSave);

    // Create a new message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Load that message object
    hr = pMessage->Load(pStmSave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeMessage::Load failed.", hr);
        goto exit;
    }

    // Get the text body
    hr = pMessage->GetTextBody(TXT_PLAIN, IET_BINARY, &pStmTxtOut, &hBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->GetTextBody failed.", hr);
        goto exit;
    }

    // Get the attachment, should be the wave file
    hr = pMessage->GetAttachments(&cAttach, &prghAttach);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pMessage->GetAttachments failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->BindToObject(prghAttach[0], IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeMessage::BindToObject failed.", hr);
        goto exit;
    }

    // Get the data stream
    hr = pBody->SaveToFile(IET_BINARY, "d:\\waveedit\\test.new");
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeBody::GetData failed.", hr);
        goto exit;
    }

    // Get the data stream
    hr = pBody->GetData(IET_BINARY, &pStmBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "IMimeBody::GetData failed.", hr);
        goto exit;
    }

    // Feed this into waveedit
#if 0
    hr = CreateWaveEditObject(IID_IWaveAudio, (LPVOID *)&pWave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "CreateWaveEditObject failed.", hr);
        goto exit;
    }

    // Get pStmWave
    hr = pWave->QueryInterface(IID_IWaveStream, (LPVOID *)&pStmWave);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pWave->QueryInterface(IID_IWaveStream...) failed.", hr);
        goto exit;
    }

    // Open the stream
    hr = pStmWave->StreamOpen(pStmBody);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pStmWave->StreamOpen failed.", hr);
        goto exit;
    }

    pWave->GetNumSamples(&dw);

    // Play it
    hr = pWave->Play(WAVE_MAPPER, 0, dw);
    if (FAILED(hr))
    {
        ReportError("MimeTestBodyStream", __LINE__, "pStmWave->Play failed.", hr);
        goto exit;
    }
#endif

    Sleep(8000);

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();
    if (pBody)
        pBody->Release();
    if (pStmBody)
        pStmBody->Release();
    if (pStmSave)
        pStmSave->Release();
    if (pWave)
        pWave->Release();
    if (pStmWave)
        pStmWave->Release();
    if (pStmText)
        pStmText->Release();
    if (pStmTxtOut)
        pStmTxtOut->Release();
    if (prghAttach)
        CoTaskMemFree(prghAttach);

    // Done
    return hr;
}
#endif

// --------------------------------------------------------------------------------
// MimeTestIsContentType
// --------------------------------------------------------------------------------
HRESULT MimeTestIsContentType(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IPersistFile            *pPersistFile=NULL;
    HBODY                   hBody;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestIsContentType", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestIsContentType", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile) failed.", hr);
        goto exit;
    }

    // Load
    hr = pPersistFile->Load(L"d:\\test\\vlad.eml", STGM_READ | STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
    {
        ReportError("MimeTestIsContentType", __LINE__, "IPersistFile::Load failed.", hr);
        goto exit;
    }

    // Get the root body
    hr = pMessage->GetBody(IBL_ROOT, NULL, &hBody);

    // Test for content-Type
    hr = pMessage->IsContentType(hBody, "multipart", NULL);
    if (S_OK == hr)
        printf("The root body of the message is a multipart.");
    else if (S_FALSE == hr)
        printf("The root body of the message is NOT a multipart.");

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pPersistFile)
        pPersistFile->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestSplitMessageIntoParts - How to split a large message into smaller parts
// --------------------------------------------------------------------------------
HRESULT MimeTestSplitMessageIntoParts(void)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessageParts       *pParts=NULL;
    IMimeEnumMessageParts   *pEnumParts=NULL;
    IMimeMessage            *pMessage=NULL;
    IMimeMessage            *pMsgPart=NULL;
    IStream                 *pStream=NULL;
    IPersistFile            *pPersistFile=NULL;
    ULONG                   c;
    ULONG                   cFiles=0;
    ULONG                   i;
    LPWSTR                  *prgpszFile=NULL;
    PROPVARIANT             rVariant;

    // Init the variant
    ZeroMemory(&rVariant, sizeof(PROPVARIANT));

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Attach a large file
    hr = pMessage->AttachFile("c:\\winnt\\winnt256.bmp", NULL, NULL);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::AttachFile(...) failed.", hr);
        goto exit;
    }

    // Split the message into parts
    hr = pMessage->SplitMessage(65536, &pParts);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::SplitMessage(...) failed.", hr);
        goto exit;
    }

    // Get the number of parts
    hr = pParts->CountParts(&cFiles);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessageParts::EnumParts(...) failed.", hr);
        goto exit;
    }

    // Allocate an array
    prgpszFile = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR) * cFiles);
    if (NULL == prgpszFile)
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "CoTaskMemAlloc Failed.", hr);
        goto exit;
    }

    // Init
    ZeroMemory(prgpszFile, sizeof(LPWSTR) * cFiles);

    // Enumerate the parts
    hr = pParts->EnumParts(&pEnumParts);
    if (FAILED(hr))
    {
        ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessageParts::EnumParts(...) failed.", hr);
        goto exit;
    }

    // INit loop var
    i = 0;

    // Enumerate the parts
    while (SUCCEEDED(pEnumParts->Next(1, &pMsgPart, &c)) && 1 == c)
    {
        // Setup the variant
        rVariant.vt = VT_LPWSTR;

        // Get a filename, in unicode
        hr = pMsgPart->GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant);
        if (FAILED(hr))
        {
            ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::GetBodyProp(HBODY_ROOT, PID_ATT_GENFNAME (Unicode), ...) failed.", hr);
            goto exit;
        }

        // QI for IPersistFile
        hr = pMsgPart->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
        if (FAILED(hr))
        {
            ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile, ...) failed.", hr);
            goto exit;
        }

        // Get the message source and dump to file...
        hr = pPersistFile->Save(rVariant.pwszVal, FALSE);
        if (FAILED(hr))
        {
            ReportError("MimeTestSplitMessageIntoParts", __LINE__, "IPersistFile::Save(...) failed.", hr);
            goto exit;
        }

        // Save the filename
        prgpszFile[i++] = rVariant.pwszVal;
        rVariant.pwszVal = NULL;

        // Release the message
        pMsgPart->Release();
        pMsgPart = NULL;
        pPersistFile->Release();
        pPersistFile = NULL;
    }

    // Lets recombine those message parts
    MimeTestRecombineMessageParts(prgpszFile, cFiles);

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pMessage)
        pMessage->Release();
    if (pParts)
        pParts->Release();
    if (pEnumParts)
        pEnumParts->Release();
    if (pMsgPart)
        pMsgPart->Release();
    if (pPersistFile)
        pPersistFile->Release();
    if (rVariant.pwszVal)
        CoTaskMemFree(rVariant.pwszVal);
    if (prgpszFile)
    {
        for (i=0; i<cFiles; i++)
            if (prgpszFile[i])
                CoTaskMemFree(prgpszFile[i]);
        CoTaskMemFree(prgpszFile);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestRecombineMessageParts
// --------------------------------------------------------------------------------
HRESULT MimeTestRecombineMessageParts(LPWSTR *prgpszFile, ULONG cFiles)
{
    // Locals
    HRESULT                     hr=S_OK;
    ULONG                       i=0;
    IMimeMessageParts           *pParts=NULL;
    IMimeMessage                *pMsgPart=NULL;
    IMimeMessage                *pMessage=NULL;
    IPersistFile                *pPersistFile=NULL;

    // Create a message object
    hr = CoCreateInstance(CLSID_IMimeMessageParts, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessageParts, (LPVOID *)&pParts);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "CoCreateInstance(CLSID_IMimeMessageParts, ...) failed.", hr);
        goto exit;
    }

    // Loop through the files
    for (i=0; i<cFiles; i++)
    {
        // Create a mime message object
        hr = CreateMimeMessage(&pMsgPart);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "CreateMimeMessage failed.", hr);
            goto exit;
        }

        // Get an IPersistFile
        hr = pMsgPart->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile, ...) failed.", hr);
            goto exit;
        }

        // Get the message source and dump to file...
        hr = pPersistFile->Load(prgpszFile[i], STGM_READ | STGM_SHARE_DENY_NONE);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "IPersistFile::Load(...) failed.", hr);
            goto exit;
        }

        // Add the message into the parts list
        hr = pParts->AddPart(pMsgPart);
        if (FAILED(hr))
        {
            ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessageParts::AddPart(...) failed.", hr);
            goto exit;
        }

        // Cleanup
        pMsgPart->Release();
        pMsgPart = NULL;
        pPersistFile->Release();
        pPersistFile = NULL;
    }

    // Combine all the parts into a new message
    hr = pParts->CombineParts(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessageParts::CombineParts(...) failed.", hr);
        goto exit;
    }

    // Get an IPersistFile
    hr = pMessage->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "IMimeMessage::QueryInterface(IID_IPersistFile, ...) failed.", hr);
        goto exit;
    }

    // Get the message source and dump to file...
    hr = pPersistFile->Save(L"combined.eml", FALSE);
    if (FAILED(hr))
    {
        ReportError("MimeTestRecombineMessageParts", __LINE__, "IPersistFile::Save(...) failed.", hr);
        goto exit;
    }

exit:
    // Cleanup
    if (pParts)
        pParts->Release();
    if (pMsgPart)
        pMsgPart->Release();
    if (pMessage)
        pMessage->Release();
    if (pPersistFile)
        pPersistFile->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestLookupCharsetHandle
// --------------------------------------------------------------------------------
HRESULT MimeTestLookupCharsetHandle(LPCSTR pszCharset, LPHCHARSET phCharset)
{
    // Locals
    HRESULT                 hr=S_OK;
    INETCSETINFO            rCharset;
    IMimeInternational      *pInternat=NULL;

    // Create a message object
    hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, IID_IMimeInternational, (LPVOID *)&pInternat);
    if (FAILED(hr))
    {
        ReportError("MimeTestLookupCharsetHandle", __LINE__, "CoCreateInstance(CLSID_IMimeInternational, ...) failed.", hr);
        goto exit;
    }

    // Look for character set
    hr = pInternat->FindCharset(pszCharset, phCharset);
    if (FAILED(hr))
    {
        ReportError("MimeTestLookupCharsetHandle", __LINE__, "IMimeInternational::FindCharset(...) failed.", hr);
        goto exit;
    }

    // Lets lookup some character set information
    hr = pInternat->GetCharsetInfo(*phCharset, &rCharset);
    if (FAILED(hr))
    {
        ReportError("MimeTestLookupCharsetHandle", __LINE__, "IMimeInternational::GetCharsetInfo(...) failed.", hr);
        goto exit;
    }

    // Print some stuff
    printf("Charset Name: %s, Windows Codepage: %d, Internet Codepage: %d\n", rCharset.szName, rCharset.cpiWindows, rCharset.cpiInternet);
    
exit:
    // Clenaup
    if (pInternat)
        pInternat->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestSettingContentLocation - How to set the Content-Location header
// --------------------------------------------------------------------------------
HRESULT MimeTestSettingContentLocation(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IStream                 *pStream=NULL;
    PROPVARIANT             rVariant;
    HCHARSET                hCharset;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Setup a variant, I can pass in unicode or ansi
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = L"http://www.microsoft.com";

    // Set the Content-Location of the message
    hr = pMessage->SetProp(PIDTOSTR(PID_HDR_CNTLOC), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "IMimeMessage::SetProp(PIDTOSTR(PID_HDR_CNTLOC), 0, ...) failed.", hr);
        goto exit;
    }

    // Setup a variant, I can pass in unicode or ansi
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = "\"Ken Dacey\" <postmaster>";

    // Set the Content-Location of the message
    hr = pMessage->SetProp(PIDTOSTR(PID_HDR_FROM), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "IMimeMessage::SetProp(PIDTOSTR(PID_HDR_FROM), 0, ...) failed.", hr);
        goto exit;
    }

    // I could also set the content-location like this:
    //
    // 1) pMessage->SetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CNTLOC), 0, &rVariant);
    //
    // 2) pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pProps);
    //    pProps->SetProp(PIDTOSTR(PID_HDR_CNTLOC), 0, &rVariant);

    // Lets save the message in UTF-7
#if 0
    hr = MimeTestLookupCharsetHandle("utf-8", &hCharset);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "MimeTestLookupCharsetHandle(\"utf-7\", ...) failed.", hr);
        goto exit;
    }

    // Set the charset onto the message
    hr = pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "IMimeMessage::SetCharset(\"utf-7\", CSET_APPLY_ALL) failed.", hr);
        goto exit;
    }
#endif

    // Save the mime message to a stream
    hr = SaveMimeMessage(pMessage, SAVE_RFC1521, &pStream);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "SaveMimeMessage(...) failed.", hr);
        goto exit;
    }

    // Dump the stream to the console, and then wait for input so that the user can view it...
    ReportStatus("\n");
    DumpStreamToConsole(pStream);

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestSettingReplyTo - How to set the Reply-To header
// --------------------------------------------------------------------------------
HRESULT MimeTestSettingReplyTo(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IStream                 *pStream=NULL;
    PROPVARIANT             rVariant;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingReplyTo", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Setup a variant, I can pass in unicode or ansi
    rVariant.vt = VT_LPWSTR;
    rVariant.pwszVal = L"Steven Bailey <sbailey@microsoft.com>";

    // Set the Content-Location of the message
    hr = pMessage->SetProp(PIDTOSTR(PID_HDR_REPLYTO), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingReplyTo", __LINE__, "IMimeMessage::SetProp(PIDTOSTR(PID_HDR_REPLYTO), 0, ...) failed.", hr);
        goto exit;
    }

    // Save the mime message to a stream
    hr = SaveMimeMessage(pMessage, SAVE_RFC1521, &pStream);
    if (FAILED(hr))
    {
        ReportError("MimeTestSettingContentLocation", __LINE__, "SaveMimeMessage(...) failed.", hr);
        goto exit;
    }

    // Dump the stream to the console, and then wait for input so that the user can view it...
    ReportStatus("\n");
    DumpStreamToConsole(pStream);

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestGetMultiValueAddressProp
// --------------------------------------------------------------------------------
HRESULT MimeTestGetMultiValueAddressProp(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    PROPVARIANT             rVariant;
    IMimeMessage            *pMessage=NULL;

    // Create a message with some addresses in it
    hr = MimeTestAppendRfc822(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestGetMultiValueAddressProp", __LINE__, "MimeTestAppendRfc822 failed.", hr);
        goto exit;
    }

    // Setup the Variant
    rVariant.vt = VT_LPSTR;

    // Get PID_HDR_TO
    hr = pMessage->GetProp(PIDTOSTR(PID_HDR_TO), 0, &rVariant);
    if (FAILED(hr))
    {
        ReportError("MimeTestGetMultiValueAddressProp", __LINE__, "IMimeMessage::GetProp(PIDTOSTR(PID_HDR_TO), ...) failed.", hr);
        goto exit;
    }

    // Printf It
    printf("PID_HDR_TO = %s\n", rVariant.pszVal);

    // Free it
    CoTaskMemFree(rVariant.pszVal);

exit:
    // Cleanup
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeTestAppendRfc822 - Test IMimeAddressTable::AppendRfc822
// --------------------------------------------------------------------------------
HRESULT MimeTestAppendRfc822(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT                 hr=S_OK;
    IMimeMessage            *pMessage=NULL;
    IMimeAddressTable       *pAdrTable=NULL;
    IStream                 *pStream=NULL;

    // Create a message object
    hr = CreateMimeMessage(&pMessage);
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "CreateMimeMessage failed.", hr);
        goto exit;
    }

    // Get the address table for the message. The address table should only be used on the root body object.
    hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeAddressTable, (LPVOID *)&pAdrTable);
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeMessage::BindToObject(HBDOY_ROOT, IID_IMimeAddressTable, ...) failed.", hr);
        goto exit;
    }

    // Append an RFC 822 formatted addresses
    hr = pAdrTable->AppendRfc822(IAT_TO, IET_DECODED, "test1 <test1@andyj.dns.microsoft.com>");
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeAddressTable::AppendRfc822(...) failed.", hr);
        goto exit;
    }

    // Append an RFC 822 formatted addresses
    hr = pAdrTable->AppendRfc822(IAT_TO, IET_DECODED, "to2 <to2@andyj.dns.microsoft.com>");
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeAddressTable::AppendRfc822(...) failed.", hr);
        goto exit;
    }

    // Append an RFC 822 formatted addresses
    hr = pAdrTable->AppendRfc822(IAT_TO, IET_DECODED, "to3 <to3@andyj.dns.microsoft.com>");
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "IMimeAddressTable::AppendRfc822(...) failed.", hr);
        goto exit;
    }

    // Save the mime message to a stream
    hr = SaveMimeMessage(pMessage, SAVE_RFC1521, &pStream);
    if (FAILED(hr))
    {
        ReportError("MimeTestAppendRfc822", __LINE__, "SaveMimeMessage(...) failed.", hr);
        goto exit;
    }

    // Dump the stream to the console, and then wait for input so that the user can view it...
    ReportStatus("\n");
    DumpStreamToConsole(pStream);

    // Return a message object
    if (ppMessage)
    {
        (*ppMessage) = pMessage;
        (*ppMessage)->AddRef();
    }

exit:
    // Cleanup
    if (pStream)
        pStream->Release();
    if (pAdrTable)
        pAdrTable->Release();
    if (pMessage)
        pMessage->Release();

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CreateMimeMessage - Basic way of creating a COM object.
// --------------------------------------------------------------------------------
HRESULT CreateMimeMessage(IMimeMessage **ppMessage)
{
    // Locals
    HRESULT hr;

    // Create a message object
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)ppMessage);
    if (FAILED(hr))
    {
        ReportError("CreateMimeMessage", __LINE__, "CoCreateInstance(CLSID_IMimeMessage, ...) failed.", hr);
        goto exit;
    }

    // You must always initnew the message object
    hr = (*ppMessage)->InitNew();
    if (FAILED(hr))
    {
        ReportError("CreateMimeMessage", __LINE__, "IMimeMessage::InitNew() failed.", hr);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// Saves a MIME message
// --------------------------------------------------------------------------------
HRESULT SaveMimeMessage(IMimeMessage *pMessage, MIMESAVETYPE savetype, IStream **ppStream)
{
    // Locals
    HRESULT     hr;
    PROPVARIANT rOption;

    // Set the save format option into the message object. The OID_xxx types are defined
    // in mimeole.idl. Go to that file for more information.
    rOption.vt = VT_UI4;
    rOption.ulVal = savetype;
    hr = pMessage->SetOption(OID_SAVE_FORMAT, &rOption);
    if (FAILED(hr))
    {
        ReportError("SaveMimeMessage", __LINE__, "IMimeMessage::SetOption(OID_SAVE_FORMAT, ...) failed", hr);
        goto exit;
    }

    // Create a stream in which to save the message...
    hr = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
    if (FAILED(hr))
    {
        ReportError("SaveMimeMessage", __LINE__, "CreateStreamOnHGlobal failed", hr);
        goto exit;
    }

    // Call the save method on IMimeMessage. Mimeole will call commit on the stream object.
    // After this call, the stream will be positioned at the end.
    hr = pMessage->Save(*ppStream, TRUE);
    if (FAILED(hr))
    {
        ReportError("SaveMimeMessage", __LINE__, "IMimeMessage::Save(...) failed", hr);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// ReportError - Simple function to report an error that has an HRESULT
// --------------------------------------------------------------------------------
HRESULT ReportError(LPCSTR pszFunction, INT nLine, LPCSTR pszErrorText, HRESULT hrResult)
{
    printf("Error(HR = 0x%08X) in %s on line %d - %s\n", hrResult, pszFunction, nLine, pszErrorText);
    return hrResult;
}

// --------------------------------------------------------------------------------
// ReportStatus - Simple function to report a string to the user
// --------------------------------------------------------------------------------
HRESULT ReportStatus(LPCSTR pszStatusText)
{
    printf("Status: %s\n", pszStatusText);
    return S_OK;
}

// --------------------------------------------------------------------------------
// DumpStreamToConsole
// --------------------------------------------------------------------------------
HRESULT DumpStreamToConsole(IStream *pStream)
{
    // Locals
    HRESULT hr=S_OK;
    BYTE    rgbBuffer[2048];
    ULONG   cbRead;

    // This is an msoert function
    HrStreamSeekSet(pStream, 0);

    while(1)
    {
        // Read a block from the stream
        hr = pStream->Read(rgbBuffer, sizeof(rgbBuffer), &cbRead);
        if (FAILED(hr))
        {
            ReportError("DumpStreamToConsole", __LINE__, "DumpStreamToConsole - IStream::Read failed.", hr);
            break;
        }

        // If nothing read, then were done
        if (0 == cbRead)
            break;

        // Print it
        printf("%s", (LPSTR)rgbBuffer);
    }

    // Finaly LF
    printf("\n");

    // Done
    return hr;
}


/*
    DWORD i=1;
    DWORD dw;
    CHAR szDate[255];
    HROWSET hRowset;
    FOLDERINFO Folder;
    MESSAGEINFO Message;
    IMessageStore *pStore;
    IMessageFolder *pFolder;
    CoCreateInstance(CLSID_MessageStore, NULL, CLSCTX_INPROC_SERVER, IID_IMessageStore, (LPVOID *)&pStore);
    pStore->Initialize("d:\\storetest");
    pStore->OpenSpecialFolder(FOLDERID_LOCAL_STORE, FOLDER_INBOX, &pFolder);
    pFolder->CreateRowset(IINDEX_SUBJECT, 0, &hRowset);
    while(S_OK == pFolder->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        dw = FDTF_DEFAULT;
        SHFormatDateTimeA(&Message.ftReceived, &dw, szDate, 255);
        if (Message.pszNormalSubj)
            printf("%05d: %s, %s, %d\n", i, Message.pszNormalSubj, szDate, Message.idMessage);
        else
            printf("%05d: <Empty>, %s, %d\n", i, szDate, Message.idMessage);
        pFolder->FreeRecord(&Message);
        i++;
    }
    pFolder->CloseRowset(&hRowset);
    pFolder->Release();
    pStore->Release();
    exit(1);
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\data.h ===
#define FILTER_NONE             0
#define FILTER_RSA_KEYEX        1
#define FILTER_RSA_SIGN         2
#define FILTER_DSA_SIGN         4
#define FILTER_DH_KEYEX         8
#define FILTER_KEA_KEYEX        16

#define szOID_INFOSEC_keyExchangeAlgorithm "2.16.840.1.101.2.1.1.22"

extern BOOL DoCertDialog(HWND hwndOwner, LPTSTR szTitle, HCERTSTORE hCertStore, PCCERT_CONTEXT *ppCert, int iFilter);
HRESULT HrValidateCert(PCCERT_CONTEXT pccert, HCERTSTORE hstore, HCRYPTPROV hprov,
                       HCERTSTORE * phcertstorOut, DWORD * pdwErrors);

extern  HCERTSTORE              HCertStoreMy;
extern  BYTE                    RgbSignHash[20];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\attrib.h ===
BOOL AuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL UnAuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL UnProtAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\attrib.cpp ===
#include "item.h"
#include <stdio.h>

BOOL DataToString(LPBYTE pb, DWORD cb, LPSTR *szData)
{
    LPSTR   szTmp = NULL;
    CHAR    szNum[5];
    
    szTmp = (LPSTR) malloc(cb*2 + 1);
    if (szTmp != NULL) {
        szTmp[0] = '\0';
        for (;cb > 0;cb -= 1, pb += 1) {
            sprintf(szNum,"%02hX", *pb);
            strcat(szTmp, szNum);
        }
    }
    *szData = szTmp;
    return TRUE;
}

BOOL StringToData(LPSTR szData, LPBYTE *pb, DWORD *cb)
{
    LPBYTE  pbData = NULL;
    LPBYTE  pbTemp = NULL;
    DWORD   cbData = 0;
    CHAR    szNum[5];

    *cb = 0;
    if ((szData != NULL) && (strlen(szData) > 0)) {
        cbData = strlen(szData)/2;
        AssertSz(((strlen(szData) % 2) == 0), "Not in even bytes. ignoring last character");
        pbData = (LPBYTE) malloc(cbData + 3);
        if (pbData != NULL) {
            pbTemp = pbData;
            for (;strlen(szData) > 1;szData += 2, pbTemp += 1) {
                sscanf(szData,"%2X", pbTemp);
            }
            *cb = cbData;
        }
    }
    *pb = pbData;
    return TRUE;
}

BOOL AuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    LPBYTE                      pb;
    LPSTR                       szOID;
    LPSTR                       szASN;
    static CSignData *          psd = NULL;
    CHAR                        rgchOID[256];
    
    switch (message) {
    case WM_INITDIALOG:
        psd = (CSignData *) lParam;
        szOID = psd->GetAuthAttribOID();
        if (szOID != NULL) {
        
            SetDlgItemText(hwnd, IDC_BA_OID, szOID);

            psd->GetAuthAttribData(&pb, &cb);
            if ((cb > 0) && (pb != NULL)) {
                DataToString(pb,cb,&szASN);
                if (szASN != NULL) {
                    SetDlgItemText(hwnd, IDC_BA_ASN, szASN);
                    free(szASN);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_BA_OID,
                           rgchOID, sizeof(rgchOID));
            if (rgchOID[0] != '\0') {
                psd->SetAuthAttribOID(rgchOID);
            }
            else {
                psd->SetAuthAttribOID(NULL);
            }

            cb = SendDlgItemMessage(hwnd, IDC_BA_ASN, WM_GETTEXTLENGTH,0,0);
            szASN = (LPSTR) malloc(cb+1);
            if (szASN != NULL) {
                GetDlgItemText(hwnd, IDC_BA_ASN, szASN, cb+1);
                StringToData(szASN, &pb, &cb);
                psd->SetAuthAttribData(pb, cb);
            }
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL UnAuthAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    LPBYTE                      pb;
    LPSTR                       szOID;
    LPSTR                       szASN;
    static CSignData *          psd = NULL;
    CHAR                        rgchOID[256];
    
    switch (message) {
    case WM_INITDIALOG:
        psd = (CSignData *) lParam;
        szOID = psd->GetUnAuthAttribOID();
        if (szOID != NULL) {
        
            SetDlgItemText(hwnd, IDC_BA_OID, szOID);

            psd->GetUnAuthAttribData(&pb, &cb);
            if ((cb > 0) && (pb != NULL)) {
                DataToString(pb,cb,&szASN);
                if (szASN != NULL) {
                    SetDlgItemText(hwnd, IDC_BA_ASN, szASN);
                    free(szASN);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_BA_OID,
                           rgchOID, sizeof(rgchOID));
            if (rgchOID[0] != '\0') {
                psd->SetUnAuthAttribOID(rgchOID);
            }
            else {
                psd->SetUnAuthAttribOID(NULL);
            }

            cb = SendDlgItemMessage(hwnd, IDC_BA_ASN, WM_GETTEXTLENGTH,0,0);
            szASN = (LPSTR) malloc(cb+1);
            if (szASN != NULL) {
                GetDlgItemText(hwnd, IDC_BA_ASN, szASN, cb+1);
                StringToData(szASN, &pb, &cb);
                psd->SetUnAuthAttribData(pb, cb);
            }
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL UnProtAttribCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    LPBYTE                      pb;
    LPSTR                       szOID;
    LPSTR                       szASN;
    static CEnvData *           ped = NULL;
    CHAR                        rgchOID[256];
    
    switch (message) {
    case WM_INITDIALOG:
        ped = (CEnvData *) lParam;
        szOID = ped->GetUnProtAttribOID();
        if (szOID != NULL) {
        
            SetDlgItemText(hwnd, IDC_BA_OID, szOID);

            ped->GetUnProtAttribData(&pb, &cb);
            if ((cb > 0) && (pb != NULL)) {
                DataToString(pb,cb,&szASN);
                if (szASN != NULL) {
                    SetDlgItemText(hwnd, IDC_BA_ASN, szASN);
                    free(szASN);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_BA_OID,
                           rgchOID, sizeof(rgchOID));
            if (rgchOID[0] != '\0') {
                ped->SetUnProtAttribOID(rgchOID);
            }
            else {
                ped->SetUnProtAttribOID(NULL);
            }

            cb = SendDlgItemMessage(hwnd, IDC_BA_ASN, WM_GETTEXTLENGTH,0,0);
            szASN = (LPSTR) malloc(cb+1);
            if (szASN != NULL) {
                GetDlgItemText(hwnd, IDC_BA_ASN, szASN, cb+1);
                StringToData(szASN, &pb, &cb);
                ped->SetUnProtAttribData(pb, cb);
            }
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\assert.cpp ===
//
//

#include <windows.h>

extern const char SzNull[] = "";

////    AssertFn
//

VOID DigSigAssertFn(LPCTSTR szWhy, LPCTSTR szInfo, int lineno, LPCTSTR fname)
{
    int         nRet;
    TCHAR       rgch[1024];
    
    wsprintf(rgch, "An assertion has occurred in the code.\n"
                   "Assertion was located at File: %s, Line: %d\n"
                   "Assertion condition was %s\n%s\n"
                   "\nPress Ignore to skip assertion, Retry to break into the"
                   " debugger, or Abort to kill the program.\n\n"
                   "Make sure that JIT is setup to use WinDbg please.",
             fname, lineno, szWhy, szInfo);

    nRet = MessageBox(GetActiveWindow(), rgch, "S/MIME Test Assert",
                      MB_ABORTRETRYIGNORE | MB_SYSTEMMODAL |
                      MB_ICONEXCLAMATION | MB_DEFBUTTON3);

    switch( nRet ) {
    case IDABORT:
        FatalAppExit(0, "Terminating App");

    case IDRETRY:
        DebugBreak();
        break;

    case IDIGNORE:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef __cplusplus
extern "C" {
#endif

VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\dbgutil.cpp ===
/***********************************************************************
 *
 * DBGUTIL.CPP
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#include <windows.h>
#include "dbgutil.h"

#define _DBGUTIL_CPP



/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];


    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
        OutputDebugString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\demand.cpp ===
// --------------------------------------------------------------------------------
// Demand.cpp
// Written By: jimsch, brimo, t-erikne (bastardized by sbailey)
// --------------------------------------------------------------------------------
// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------

#include <windows.h>
#include "myassert.h"
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
static HMODULE s_hCrypt = 0;
static HMODULE s_hCryptDlg = 0;
static HMODULE s_hWinTrust = 0;
#if 0
static HMODULE s_hWinINET = 0;
static HMODULE s_hShell32 = 0;
static HMODULE s_hOleAut32 = 0;
static HMODULE s_hComDlg32 = 0;
static HMODULE s_hVersion = 0;
static HMODULE s_hUrlmon = 0;
static HMODULE s_hShDocVw = 0;
static HMODULE s_hInetCPL = 0;
static HMODULE s_hMSO9 = 0;
static HMODULE s_hWinMM = 0;
static HMODULE s_hRichEdit = 0;
static HMODULE s_hMLANG = 0;
static HMODULE s_hWSOCK = 0;
static HMODULE s_hPstoreC = 0;
static HMODULE s_hRAS = 0;
static HMODULE s_hAdvApi = 0;
#endif // 0

static CRITICAL_SECTION g_csDefLoad = {0};

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void InitDemandLoadedLibs(void)
{
    InitializeCriticalSection(&g_csDefLoad);
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandLoadedLibs(void)
{
    EnterCriticalSection(&g_csDefLoad);
    if (s_hCrypt)       FreeLibrary(s_hCrypt);
    if (s_hCryptDlg)    FreeLibrary(s_hCryptDlg);
    if (s_hWinTrust)    FreeLibrary(s_hWinTrust);
#if 0
    FreeLibrary(s_hWinINET);
    FreeLibrary(s_hWSOCK);
    FreeLibrary(s_hShell32);
    FreeLibrary(s_hOleAut32);
    FreeLibrary(s_hComDlg32);
    FreeLibrary(s_hVersion);
    FreeLibrary(s_hUrlmon);
    FreeLibrary(s_hMLANG);
    FreeLibrary(s_hShDocVw);
    FreeLibrary(s_hInetCPL);
    FreeLibrary(s_hMSO9);
    FreeLibrary(s_hWinMM);
    FreeLibrary(s_hRichEdit);
    FreeLibrary(s_hPstoreC);
    FreeLibrary(s_hRAS);
    FreeLibrary(s_hAdvApi);
#endif // 0

    LeaveCriticalSection(&g_csDefLoad);
    DeleteCriticalSection(&g_csDefLoad);
}


// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL DemandLoadCrypt32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary("CRYPT32.DLL");
        AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrA);
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertGetSubjectCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToEncode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgControl)
            GET_PROC_ADDR(s_hCrypt, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCRLToStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCRLsInStore)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CertStrToNameW)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore)
            GET_PROC_ADDR(s_hCrypt, CertAddStoreToCollection)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadCryptDlg
// --------------------------------------------------------------------------------
BOOL DemandLoadCryptDlg(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCryptDlg)
        {
        s_hCryptDlg = LoadLibrary("CRYPTDLG.DLL");
        AssertSz((BOOL)s_hCryptDlg, TEXT("LoadLibrary failed on CRYPTDLG.DLL"));

        if (0 == s_hCryptDlg)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertSelectCertificateA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinTrust
// --------------------------------------------------------------------------------
BOOL DemandLoadWinTrust(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinTrust)
        {
        s_hWinTrust = LoadLibrary("WINTRUST.DLL");
        AssertSz((BOOL)s_hWinTrust, TEXT("LoadLibrary failed on WINTRUST.DLL"));

        if (0 == s_hWinTrust)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinTrust, WinVerifyTrust)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

#if 0
// --------------------------------------------------------------------------------
// DemandLoadWinINET
// --------------------------------------------------------------------------------
BOOL DemandLoadWinINET(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinINET)
        {
        s_hWinINET = LoadLibrary("WININET.DLL");
        AssertSz((BOOL)s_hWinINET, TEXT("LoadLibrary failed on WININET.DLL"));

        if (0 == s_hWinINET)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinINET, RetrieveUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, UnlockUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, InternetQueryOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetSetOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetDialA)
            GET_PROC_ADDR(s_hWinINET, InternetHangUp)
            GET_PROC_ADDR(s_hWinINET, InternetGetConnectedStateExA)
            GET_PROC_ADDR(s_hWinINET, InternetCombineUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCrackUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCloseHandle)
            GET_PROC_ADDR(s_hWinINET, InternetReadFile)
            GET_PROC_ADDR(s_hWinINET, InternetConnectA)
            GET_PROC_ADDR(s_hWinINET, InternetOpenA)
            GET_PROC_ADDR(s_hWinINET, HttpQueryInfoA)
            GET_PROC_ADDR(s_hWinINET, HttpOpenRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpAddRequestHeadersA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestA)
            GET_PROC_ADDR(s_hWinINET, InternetWriteFile)
            GET_PROC_ADDR(s_hWinINET, HttpEndRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestExA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWSOCK32
// --------------------------------------------------------------------------------
BOOL DemandLoadWSOCK32()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWSOCK)
        {
        s_hWSOCK = LoadLibrary("WSOCK32.DLL");
        AssertSz((BOOL)s_hWSOCK, TEXT("LoadLibrary failed on WSOCK32.DLL"));

        if (0 == s_hWSOCK)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWSOCK, WSAStartup)
            GET_PROC_ADDR(s_hWSOCK, WSACleanup)
            GET_PROC_ADDR(s_hWSOCK, WSAGetLastError)
            GET_PROC_ADDR(s_hWSOCK, gethostname)
            GET_PROC_ADDR(s_hWSOCK, gethostbyname)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncGetHostByName)
            GET_PROC_ADDR(s_hWSOCK, inet_addr)
            GET_PROC_ADDR(s_hWSOCK, htons)
            GET_PROC_ADDR(s_hWSOCK, WSACancelAsyncRequest)
            GET_PROC_ADDR(s_hWSOCK, send)
            GET_PROC_ADDR(s_hWSOCK, connect)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncSelect)
            GET_PROC_ADDR(s_hWSOCK, socket)
            GET_PROC_ADDR(s_hWSOCK, inet_ntoa)
            GET_PROC_ADDR(s_hWSOCK, closesocket)
            GET_PROC_ADDR(s_hWSOCK, recv)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHELL32
// --------------------------------------------------------------------------------
BOOL DemandLoadSHELL32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShell32)
        {
        s_hShell32 = LoadLibrary("SHELL32.DLL");
        AssertSz((BOOL)s_hShell32, TEXT("LoadLibrary failed on SHELL32.DLL"));

        if (0 == s_hShell32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShell32, SHGetPathFromIDListA);
            GET_PROC_ADDR(s_hShell32, SHGetSpecialFolderLocation);
            GET_PROC_ADDR_ORDINAL(s_hShell32, SHFree, 195);
            GET_PROC_ADDR(s_hShell32, SHBrowseForFolderA);
            GET_PROC_ADDR(s_hShell32, ShellExecuteA);
            GET_PROC_ADDR(s_hShell32, ShellExecuteExA);
            GET_PROC_ADDR(s_hShell32, DragQueryFileA);
            GET_PROC_ADDR(s_hShell32, SHGetFileInfoA);
            GET_PROC_ADDR(s_hShell32, Shell_NotifyIconA);
            GET_PROC_ADDR(s_hShell32, ExtractIconA);
            GET_PROC_ADDR(s_hShell32, SHFileOperationA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
         
#if 0
// --------------------------------------------------------------------------------
// DemandLoadOLEAUT32
// --------------------------------------------------------------------------------
BOOL DemandLoadOLEAUT32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hOleAut32)
        {
        s_hOleAut32 = LoadLibrary("OLEAUT32.DLL");
        AssertSz((BOOL)s_hOleAut32, TEXT("LoadLibrary failed on OLEAUT32.DLL"));

        if (0 == s_hOleAut32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hOleAut32, SafeArrayCreate);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayPutElement);
            GET_PROC_ADDR(s_hOleAut32, DispInvoke);
            GET_PROC_ADDR(s_hOleAut32, DispGetIDsOfNames);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayDestroy);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetUBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetLBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetElement);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, SysReAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringLen);
            GET_PROC_ADDR(s_hOleAut32, SysAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysFreeString);
            GET_PROC_ADDR(s_hOleAut32, SysStringLen);
            GET_PROC_ADDR(s_hOleAut32, VariantInit);
            GET_PROC_ADDR(s_hOleAut32, LoadTypeLib);
            GET_PROC_ADDR(s_hOleAut32, RegisterTypeLib);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayAccessData);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayUnaccessData);
            GET_PROC_ADDR(s_hOleAut32, SysStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, VariantClear);
            GET_PROC_ADDR(s_hOleAut32, VariantCopy);
            GET_PROC_ADDR(s_hOleAut32, SetErrorInfo);
            GET_PROC_ADDR(s_hOleAut32, CreateErrorInfo);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif

// --------------------------------------------------------------------------------
// DemandLoadCOMDLG32
// --------------------------------------------------------------------------------
BOOL DemandLoadCOMDLG32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hComDlg32)
        {
        s_hComDlg32 = LoadLibrary("COMDLG32.DLL");
        AssertSz((BOOL)s_hComDlg32, TEXT("LoadLibrary failed on COMDLG32.DLL"));

        if (0 == s_hComDlg32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hComDlg32, GetSaveFileNameA);
            GET_PROC_ADDR(s_hComDlg32, GetOpenFileNameA);
            GET_PROC_ADDR(s_hComDlg32, ChooseFontA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadVERSION
// --------------------------------------------------------------------------------
BOOL DemandLoadVERSION(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hVersion)
        {
        s_hVersion = LoadLibrary("VERSION.DLL");
        AssertSz((BOOL)s_hVersion, TEXT("LoadLibrary failed on VERSION.DLL"));

        if (0 == s_hVersion)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hVersion, VerQueryValueA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadURLMON
// --------------------------------------------------------------------------------
BOOL DemandLoadURLMON(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hUrlmon)
        {
        s_hUrlmon = LoadLibrary("URLMON.DLL");
        AssertSz((BOOL)s_hUrlmon, TEXT("LoadLibrary failed on URLMON.DLL"));

        if (0 == s_hUrlmon)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hUrlmon, CreateURLMoniker);
            GET_PROC_ADDR(s_hUrlmon, URLOpenBlockingStreamA);
            GET_PROC_ADDR(s_hUrlmon, FindMimeFromData);
            GET_PROC_ADDR(s_hUrlmon, CoInternetCombineUrl);
            GET_PROC_ADDR(s_hUrlmon, RegisterBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, RevokeBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, FaultInIEFeature);
            GET_PROC_ADDR(s_hUrlmon, CoInternetGetSecurityUrl);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMLANG
// --------------------------------------------------------------------------------
BOOL DemandLoadMLANG(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMLANG)
        {
#ifndef WIN16
        s_hMLANG = LoadLibrary("MLANG.DLL");
#else
        s_hMLANG = LoadLibrary("MLANG16.DLL");
#endif // WIN16
        AssertSz((BOOL)s_hMLANG, TEXT("LoadLibrary failed on MLANG.DLL"));

        if (0 == s_hMLANG)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hMLANG, IsConvertINetStringAvailable)
            GET_PROC_ADDR(s_hMLANG, ConvertINetString)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHDOCVW
// --------------------------------------------------------------------------------
BOOL DemandLoadSHDOCVW()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShDocVw)
        {
        s_hShDocVw = LoadLibrary("SHDOCVW.DLL");
        AssertSz((BOOL)s_hShDocVw, TEXT("LoadLibrary failed on SHDOCVW.DLL"));

        if (0 == s_hShDocVw)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShDocVw, AddUrlToFavorites);
            GET_PROC_ADDR(s_hShDocVw, SetQueryNetSessionCount);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadINETCPL
// --------------------------------------------------------------------------------
BOOL DemandLoadINETCPL()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hInetCPL)
        {
        s_hInetCPL = LoadLibrary("INETCPL.CPL");
        AssertSz((BOOL)s_hInetCPL, TEXT("LoadLibrary failed on INETCPL.CPL"));

        if (0 == s_hInetCPL)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hInetCPL, OpenFontsDialog);
            GET_PROC_ADDR(s_hInetCPL, LaunchConnectionDialog);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMSO9
// --------------------------------------------------------------------------------
BOOL DemandLoadMSO9(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMSO9)
        {
#ifdef DEBUG
        s_hMSO9 = LoadLibrary("mso9d.DLL");
        if (!s_hMSO9)
            s_hMSO9 = LoadLibrary("mso9.DLL");
#else
        s_hMSO9 = LoadLibrary("mso9.DLL");
#endif
        AssertSz((BOOL)s_hMSO9, TEXT("LoadLibrary failed on MSO9.DLL"));

        if (0 == s_hMSO9)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR3(s_hMSO9, _MsoFGetComponentManager@4, MsoFGetComponentManager);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinMM
// --------------------------------------------------------------------------------
BOOL DemandLoadWinMM(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinMM)
        {
        s_hWinMM = LoadLibrary("winmm.dll");
        AssertSz((BOOL)s_hWinMM, TEXT("LoadLibrary failed on WINMM.DLL"));

        if (0 == s_hWinMM)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinMM, sndPlaySoundA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRichEdit
// --------------------------------------------------------------------------------
BOOL DemandLoadRichEdit(void)
{
    if (!s_hRichEdit)
        {
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
        if (!s_hRichEdit)
            return FALSE;
        }

    return TRUE;
}

// --------------------------------------------------------------------------------
// DemandLoadPStoreC
// --------------------------------------------------------------------------------
BOOL DemandLoadPStoreC()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hPstoreC)
        {
        s_hPstoreC = LoadLibrary("PSTOREC.DLL");
        AssertSz((BOOL)s_hPstoreC, TEXT("LoadLibrary failed on PSTOREC.DLL"));

        if (0 == s_hPstoreC)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hPstoreC, PStoreCreateInstance);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRAS
// --------------------------------------------------------------------------------
BOOL DemandLoadRAS()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hRAS)
        {
        s_hRAS = LoadLibrary("RASAPI32.DLL");
        AssertSz((BOOL)s_hRAS, TEXT("LoadLibrary failed on RASAPI32.DLL"));

        if (0 == s_hRAS)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hRAS, RasEnumEntriesA)
            GET_PROC_ADDR(s_hRAS, RasEditPhonebookEntryA)
            GET_PROC_ADDR(s_hRAS, RasCreatePhonebookEntryA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif // 0

BOOL IsWin95()
{
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);

    if (GetVersionExA(&ver))
        {
        return (VER_PLATFORM_WIN32_WINDOWS == ver.dwPlatformId);
        }
    return FALSE;
}

BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    char        rgch1[256];
    char        rgch2[256];

    if (pszContainer != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszContainer, -1, rgch1, sizeof(rgch1),
                            NULL, NULL);
        pszContainer = (LPWSTR) rgch1;
        }

    if (pszProvider != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszProvider, -1, rgch2, sizeof(rgch2),
                            NULL, NULL);
        pszProvider = (LPWSTR) rgch2;
        }

    return CryptAcquireContextA(phProv, (LPCSTR) pszContainer,
                                (LPCSTR) pszProvider, dwProvType, dwFlags);
}

#if 0
BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hAdvApi)
        {
        s_hAdvApi = LoadLibrary("ADVAPI32.DLL");
        AssertSz((BOOL)s_hAdvApi, TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else
            {
            if (IsWin95())
                CryptAcquireContextW = MyCryptAcquireContextW;
            else
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\encode.h ===
class SMimeEncode
{
public:
    SMimeEncode();
    ~SMimeEncode();

    HRESULT HrConfig(DWORD dwFlags,
                     LPTSTR lpszBody,
                     HCRYPTPROV hCryptProv,
                     HCERTSTORE hMYCertStore,
                     HCERTSTORE hCACertStore,
                     HCERTSTORE hABCertStore,
                     PCCERT_CONTEXT lpSigningCertInner,
                     PCCERT_CONTEXT lpSigningCertOuter,
                     PCCERT_CONTEXT lpEncryptionCert,
                     LPTSTR lpszSenderEmail,
                     LPTSTR lpszSenderName,
                     LPTSTR lpszRecipientEmail,
                     LPTSTR lpszRecipientName,
                     LPTSTR lpszOutputFile
    );
    HRESULT HrExecute(void);

protected:
    DWORD m_dwFlags;                    // signing and encryption options

    IStream * m_stmOutput;              // output stream

    LPTSTR m_szSignAlg;
    LPTSTR m_szEncryptAlg;

    LPTSTR  m_szBody;                   // Body string.
    LPTSTR  m_szSubject;                // Subject string.
    CERT_CONTEXT* m_SigningCertInner;
    CERT_CONTEXT* m_SigningCertOuter;
    CERT_CONTEXT* m_EncryptionCert;     // maybe should be multiple?
    HCRYPTPROV m_hCryptProv;
    HCERTSTORE m_hMYCertStore;
    HCERTSTORE m_hCACertStore;
    HCERTSTORE m_hABCertStore;
    LPTSTR m_szSenderEmail;
    LPTSTR m_szSenderName;
    LPTSTR m_szRecipientEmail;          // maybe should be multiple?
    LPTSTR m_szRecipientName;
    LPTSTR m_szOutputFile;
};

typedef class SMimeEncode SMimeEncode;


// Values for dwFlags
#define encode_Encrypt      0x1
#define encode_InnerSign    0x2
#define encode_OuterSign    0x4
#define encode_InnerClear   0x8
#define encode_InnerOpaque  0
#define encode_OuterClear   0x10
#define encode_OuterOpaque  0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\instring.h ===
#define IDD_INPUT_STRING 2001
#define IDD_INPUT_STRING_PROMPT 2002

ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\instring.cpp ===
#include <windows.h>
#include "instring.h"


typedef struct _STRING_BUFFER {
    ULONG cbBuffer;
    LPTSTR lpBuffer;
    LPTSTR lpPrompt;
    LPTSTR lpTitle;
} STRING_BUFFER, *LPSTRING_BUFFER;

BOOL PASCAL InputStringDlgProc(HWND hDlg, WORD message, WORD wParam, LONG lParam) {
    static LPSTRING_BUFFER lpBuffer = NULL;
    USHORT cchString;

    switch (message) {
        case WM_INITDIALOG:
            // DialogBoxParam passes in pointer to buffer description.
            lpBuffer = (LPSTRING_BUFFER)lParam;

            if (lpBuffer->lpPrompt) {
                SetDlgItemText(hDlg, IDD_INPUT_STRING_PROMPT, lpBuffer->lpPrompt);
            }

            if (lpBuffer->lpTitle) {
                SetWindowText(hDlg, lpBuffer->lpTitle);
            }

            SendDlgItemMessage(hDlg,
              IDD_INPUT_STRING,
              EM_LIMITTEXT,
              (WPARAM)(lpBuffer->cbBuffer - 1), // text length, in characters (leave room for null)
              0);                               // not used; must be zero

            return(TRUE);

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    // Get number of characters.
                    cchString = (WORD)SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_LINELENGTH,
                      (WPARAM) 0,
                      (LPARAM) 0);

                    if (cchString == 0) {
                        *(lpBuffer->lpBuffer) = '\0';
                        EndDialog(hDlg, TRUE);
                        lpBuffer->cbBuffer = 0;
                        return FALSE;
                    }

                    // Put the number of characters into first word
                    // of buffer.
                    *((USHORT*)lpBuffer->lpBuffer) = cchString;
                    lpBuffer->cbBuffer = cchString;

                    // Get the characters.
                    SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_GETLINE,
                      (WPARAM)0,        // line 0
                      (LPARAM)lpBuffer->lpBuffer);

                    // Null-terminate the string.
                    lpBuffer->lpBuffer[cchString] = 0;
                    lpBuffer = NULL;    // prevent reuse of buffer
                    EndDialog(hDlg, 0);
                    return(TRUE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

/***************************************************************************

    Name      : InputString

    Purpose   : Brings up a dialog requesting string input

    Parameters: hInstance = hInstance of app
                hwnd = hwnd of parent window
                lpszTitle = Dialog box title
                lpszPrompt = Text in dialog box
                lpBuffer = buffer to fill
                cchBuffer = size of buffer

    Returns   : return ULONG number of characters entered (not including terminating
                NULL)

    Comment   :

***************************************************************************/
ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer) {
    STRING_BUFFER StringBuffer;

    StringBuffer.lpPrompt = lpszPrompt;
    StringBuffer.lpTitle = lpszTitle;
    StringBuffer.cbBuffer = cchBuffer;
    StringBuffer.lpBuffer = lpBuffer;

    DialogBoxParam(hInstance, (LPCTSTR)"InputString", hwnd, (DLGPROC)InputStringDlgProc,
      (LPARAM)&StringBuffer);

    return(StringBuffer.cbBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS, THIS IS C++.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HINSTANCE g_hInst;

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

#define _CRYPT32_

BOOL DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef unsigned long HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCERT_NAME_INFO;
typedef void *HCRYPTMSG;
typedef struct _CMSG_STREAM_INFO *PCMSG_STREAM_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCCERT_NAME_INFO;

LOADER_FUNCTION( DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPTSTR pszValueString, DWORD cszValueString),
    (dwValueType, pValue, pszValueString, cszValueString),
    NULL, Crypt32)
#define CertRDNValueToStrA VAR_CertRDNValueToStrA

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, BYTE * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptEncodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObjectEx VAR_CryptEncodeObjectEx


LOADER_FUNCTION(PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    1, Crypt32)
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetSubjectCertificateFromStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId),
    (hCertStore, dwCertEncodingType, pCertId),
    NULL, Crypt32)
#define CertGetSubjectCertificateFromStore VAR_CertGetSubjectCertificateFromStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToEncode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, void const *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToEncode VAR_CryptMsgOpenToEncode

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgControl,
    (HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, void const *pvCtrlPara),
    (hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara),
    FALSE, Crypt32)
#define CryptMsgControl VAR_CryptMsgControl

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CertAddEncodedCRLToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext),
    (hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext),
    FALSE, Crypt32)
#define CertAddEncodedCRLToStore VAR_CertAddEncodedCRLToStore

LOADER_FUNCTION( PCCRL_CONTEXT, CertEnumCRLsInStore,
    (HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext),
    (hCertStore, pPrevCrlContext),
    NULL, Crypt32)
#define CertEnumCRLsInStore VAR_CertEnumCRLsInStore

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION * rgExtensions),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( BOOL, CertStrToNameW,
    (DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType,
     void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError),
    (dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded,
     ppszError),
    NULL, Crypt32)
#define CertStrToNameW VAR_CertStrToNameW

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded,
     DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded,
     cbCertEncoded, dwAddDisposition, ppCertContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( BOOL, CertAddStoreToCollection,
    (HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags,
     DWORD dwPriority),
    (hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority),
    FALSE, Crypt32)
#define CertAddStoreToCollection VAR_CertAddStoreToCollection

/////////////////////////////////////
// CRYPTDLG.DLL

#define _CRYPTDLG_

// Old cert dialogs
typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A *PCERT_VIEWPROPERTIES_STRUCT_A;
typedef struct tagCSSA *PCERT_SELECT_STRUCT_A;

BOOL DemandLoadCryptDlg();

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertSelectCertificateA,
    (PCERT_SELECT_STRUCT_A pCertSelectInfo),
    (pCertSelectInfo),
    FALSE, CryptDlg)
#define CertSelectCertificateA VAR_CertSelectCertificateA

/////////////////////////////////////
// WINTRUST.DLL

BOOL DemandLoadWinTrust();

LOADER_FUNCTION( LONG, WinVerifyTrust,
    (HWND hwnd, GUID *ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData),
    0, WinTrust)
#define WinVerifyTrust VAR_WinVerifyTrust

#if 0
/////////////////////////////////////
// WININET.DLL

#include <wininet.h>

#define _WININET_

typedef struct _INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFOA;

BOOL DemandLoadWinINET();

LOADER_FUNCTION( BOOL, RetrieveUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, INTERNET_CACHE_ENTRY_INFOA *lpCacheEntryInfo, LPDWORD lpdwCacheEntryInfoBufferSize, DWORD dwReserved),
    (lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved),
    FALSE, WinINET)
#define RetrieveUrlCacheEntryFileA VAR_RetrieveUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, UnlockUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, DWORD dwRes),
    (lpszUrlName, dwRes),
    FALSE, WinINET)
#define UnlockUrlCacheEntryFileA VAR_UnlockUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, InternetQueryOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength),
    (hInternet, dwOption, lpBuffer, lpdwBufferLength),
    NULL, WinINET)
#define InternetQueryOptionA VAR_InternetQueryOptionA

LOADER_FUNCTION( BOOL, InternetSetOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength),
    (hInternet, dwOption, lpBuffer, dwBufferLength),
    NULL, WinINET)
#define InternetSetOptionA VAR_InternetSetOptionA

LOADER_FUNCTION( BOOL, InternetDialA,
    (HWND hwndParent, LPSTR lpszConnectoid, DWORD dwFlags, DWORD *lpdwConnection, DWORD dwReserved),
    (hwndParent, lpszConnectoid, dwFlags, lpdwConnection, dwReserved),
    NULL, WinINET)
#define InternetDialA VAR_InternetDialA

LOADER_FUNCTION( BOOL, InternetHangUp,
    (DWORD dwConnection, DWORD dwReserved),
    (dwConnection, dwReserved),
    NULL, WinINET)
#define InternetHangUp VAR_InternetHangUp

LOADER_FUNCTION(BOOL, InternetGetConnectedStateExA, 
                (LPDWORD dwFlags,  LPTSTR szconn, DWORD size, DWORD reserved),
                (dwFlags, szconn, size, reserved),
                FALSE, WinINET)
#define InternetGetConnectedStateExA  VAR_InternetGetConnectedStateExA

LOADER_FUNCTION(BOOL, InternetCombineUrlA, 
                (LPCSTR lpszBaseUrl, LPCSTR lpszRelativeUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
                (lpszBaseUrl, lpszRelativeUrl, lpszBuffer, lpdwBufferLength, dwFlags),
                FALSE, WinINET)
#define InternetCombineUrlA  VAR_InternetCombineUrlA

LOADER_FUNCTION(BOOL, InternetCrackUrlA, 
                (LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
                (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents),
                FALSE, WinINET)
#define InternetCrackUrlA  VAR_InternetCrackUrlA

LOADER_FUNCTION(BOOL, InternetCloseHandle, 
                (HINTERNET hInternet),
                (hInternet),
                FALSE, WinINET)
#define   InternetCloseHandle   VAR_InternetCloseHandle

LOADER_FUNCTION(BOOL, InternetReadFile, 
                (HINTERNET hInternet, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead),
                (hInternet, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead),
                FALSE, WinINET)
#define   InternetReadFile   VAR_InternetReadFile

LOADER_FUNCTION(HINTERNET, InternetConnectA, 
                (HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort,
                            LPCSTR lpszUserName,LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD dwContext),
                (hInternet, lpszServerName, nServerPort, lpszUserName, lpszPassword, dwService, dwFlags, dwContext),
                NULL, WinINET)
#define   InternetConnectA   VAR_InternetConnectA

LOADER_FUNCTION(HINTERNET, InternetOpenA, 
                (LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags),
                (lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags),
                NULL, WinINET)
#define   InternetOpenA   VAR_InternetOpenA

LOADER_FUNCTION(BOOL, HttpQueryInfoA, 
                (HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex),
                (hRequest, dwInfoLevel, lpBuffer, lpdwBufferLength, lpdwIndex),
                FALSE, WinINET)
#define   HttpQueryInfoA   VAR_HttpQueryInfoA

LOADER_FUNCTION(HINTERNET, HttpOpenRequestA, 
                (HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion,
                            LPCSTR lpszReferrer, LPCSTR FAR * lplpszAcceptTypes, DWORD dwFlags, DWORD dwContext),
                ( hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferrer, lplpszAcceptTypes, dwFlags, dwContext),
                NULL, WinINET)
#define   HttpOpenRequestA   VAR_HttpOpenRequestA

LOADER_FUNCTION(BOOL, HttpAddRequestHeadersA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwModifiers),
                (hRequest, lpszHeaders, dwHeadersLength, dwModifiers),
                FALSE, WinINET)
#define   HttpAddRequestHeadersA   VAR_HttpAddRequestHeadersA

LOADER_FUNCTION(BOOL, HttpSendRequestA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength),
                (hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength),
                FALSE, WinINET)
#define   HttpSendRequestA   VAR_HttpSendRequestA

LOADER_FUNCTION(BOOL, InternetWriteFile, 
                (HINTERNET hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD lpdwNumberOfBytesWritten),
                (hFile, lpBuffer, dwNumberOfBytesToWrite, lpdwNumberOfBytesWritten),
                FALSE, WinINET)
#define   InternetWriteFile   VAR_InternetWriteFile

LOADER_FUNCTION(BOOL, HttpEndRequestA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD dwContext),
                (hRequest, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpEndRequestA   VAR_HttpEndRequestA

LOADER_FUNCTION(BOOL, HttpSendRequestExA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersIn,
                                LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD dwContext),
                (hRequest, lpBuffersIn, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpSendRequestExA   VAR_HttpSendRequestExA

/////////////////////////////////////
// SHELL32.DLL

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

BOOL DemandLoadSHELL32();

LOADER_FUNCTION(BOOL, SHFree, // Actually a void
   (LPVOID lpv),
   (lpv),
   FALSE, SHELL32)
#define SHFree VAR_SHFree

LOADER_FUNCTION(BOOL, SHGetPathFromIDListA,
    (LPCITEMIDLIST pidl, LPSTR pszPath),
    (pidl, pszPath),
    FALSE, SHELL32)
#define SHGetPathFromIDListA VAR_SHGetPathFromIDListA

LOADER_FUNCTION(HRESULT, SHGetSpecialFolderLocation,
    (HWND hwndOwner, int nFolder, LPITEMIDLIST * ppidl),
    (hwndOwner, nFolder, ppidl),
    E_FAIL, SHELL32)
#define SHGetSpecialFolderLocation VAR_SHGetSpecialFolderLocation

LOADER_FUNCTION(LPITEMIDLIST, SHBrowseForFolderA,
    (LPBROWSEINFOA lpbi),
    (lpbi),
    NULL, SHELL32)
#define SHBrowseForFolderA VAR_SHBrowseForFolderA

LOADER_FUNCTION(HINSTANCE, ShellExecuteA,
    (HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd),
    (hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd),
    NULL, SHELL32)
#define ShellExecuteA VAR_ShellExecuteA

LOADER_FUNCTION(BOOL, ShellExecuteExA,
    (LPSHELLEXECUTEINFOA lpExecInfo),
    (lpExecInfo),
    FALSE, SHELL32)
#define ShellExecuteExA VAR_ShellExecuteExA

LOADER_FUNCTION(UINT, DragQueryFileA,
    (HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cb),
    (hDrop, iFile, lpszFile, cb),
    0, SHELL32)
#define DragQueryFileA VAR_DragQueryFileA

LOADER_FUNCTION(DWORD, SHGetFileInfoA,
    (LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags),
    (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags),
    0, SHELL32)
#define SHGetFileInfoA VAR_SHGetFileInfoA

LOADER_FUNCTION(BOOL, Shell_NotifyIconA,
    (DWORD dwMessage, PNOTIFYICONDATAA lpData),
    (dwMessage, lpData),
    FALSE, SHELL32)
#define Shell_NotifyIconA VAR_Shell_NotifyIconA

LOADER_FUNCTION(int, SHFileOperationA,
    (LPSHFILEOPSTRUCTA lpfo),
    (lpfo),
    -1, SHELL32)
#define SHFileOperationA VAR_SHFileOperationA

LOADER_FUNCTION(HICON, ExtractIconA,
    (HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex),
    (hInst, lpszExeFileName, nIconIndex),
    NULL, SHELL32)
#define ExtractIconA VAR_ExtractIconA

#if 0
/////////////////////////////////////
// OLEAUT32.DLL

BOOL DemandLoadOLEAUT32();

#include <olectl.h>

LOADER_FUNCTION(SAFEARRAY *, SafeArrayCreate,
    (VARTYPE vt, UINT cDims, SAFEARRAYBOUND* rgsabound),
    (vt, cDims, rgsabound),
    NULL, OLEAUT32)
#define SafeArrayCreate VAR_SafeArrayCreate

LOADER_FUNCTION(HRESULT, SafeArrayPutElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv),
    (psa, rgIndices, pv),
    E_FAIL, OLEAUT32)
#define SafeArrayPutElement VAR_SafeArrayPutElement

LOADER_FUNCTION(HRESULT, DispInvoke,
    (void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags, DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr),
    (_this, ptinfo, dispidMember, wFlags, pparams, pvarResult, pexcepinfo, puArgErr),
    E_FAIL, OLEAUT32)
#define DispInvoke VAR_DispInvoke

LOADER_FUNCTION(HRESULT, DispGetIDsOfNames,
    (ITypeInfo * ptinfo, OLECHAR ** rgszNames, UINT cNames, DISPID * rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid),
    E_FAIL, OLEAUT32)
#define DispGetIDsOfNames VAR_DispGetIDsOfNames

LOADER_FUNCTION(BSTR, SysAllocStringByteLen,
    (LPCSTR psz, UINT len),
    (psz, len),
    NULL, OLEAUT32)
#define SysAllocStringByteLen VAR_SysAllocStringByteLen

LOADER_FUNCTION(int, SysReAllocString,
    (BSTR * pbstr,  const OLECHAR * sz),
    (pbstr, sz),
    0, OLEAUT32)
#define SysReAllocString VAR_SysReAllocString

LOADER_FUNCTION(BSTR, SysAllocStringLen,
    (const OLECHAR *pch, unsigned int i),
    (pch, i),
    NULL, OLEAUT32)
#define SysAllocStringLen VAR_SysAllocStringLen

LOADER_FUNCTION(BSTR, SysAllocString,
    (const OLECHAR *pch),
    (pch),
    NULL, OLEAUT32)
#define SysAllocString VAR_SysAllocString

LOADER_FUNCTION(BOOL, SysFreeString,  // Actually a void
    (BSTR bs),
    (bs),
    FALSE, OLEAUT32)
#define SysFreeString VAR_SysFreeString

LOADER_FUNCTION(UINT, SysStringLen,
    (BSTR bs),
    (bs),
    0, OLEAUT32)
#define SysStringLen VAR_SysStringLen

LOADER_FUNCTION(BOOL, VariantInit,
    (VARIANTARG * pvarg),
    (pvarg),
    FALSE, OLEAUT32)
#define VariantInit VAR_VariantInit

LOADER_FUNCTION(HRESULT, LoadTypeLib,
    (const OLECHAR  *szFile, ITypeLib ** pptlib),
    (szFile, pptlib),
    E_FAIL, OLEAUT32)
#define LoadTypeLib VAR_LoadTypeLib

LOADER_FUNCTION(HRESULT, RegisterTypeLib,
    (ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir),
    (ptlib, szFullPath, szHelpDir),
    E_FAIL, OLEAUT32)
#define RegisterTypeLib VAR_RegisterTypeLib

LOADER_FUNCTION(HRESULT, SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData),
    (psa, ppvData),
    E_FAIL, OLEAUT32)
#define SafeArrayAccessData VAR_SafeArrayAccessData

LOADER_FUNCTION(HRESULT, SafeArrayUnaccessData,
    (SAFEARRAY * psa),
    (psa),
    E_FAIL, OLEAUT32)
#define SafeArrayUnaccessData VAR_SafeArrayUnaccessData

LOADER_FUNCTION(UINT, SysStringByteLen,
    (BSTR bstr),
    (bstr),
    0, OLEAUT32)
#define SysStringByteLen VAR_SysStringByteLen

LOADER_FUNCTION(HRESULT, SafeArrayDestroy,
    (SAFEARRAY *psa),
    (psa),
    E_FAIL, OLEAUT32)
#define SafeArrayDestroy VAR_SafeArrayDestroy

LOADER_FUNCTION(HRESULT, SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv),
    (psa, rgIndices, pv),
    E_FAIL, OLEAUT32)
#define SafeArrayGetElement VAR_SafeArrayGetElement

LOADER_FUNCTION(HRESULT, SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUbound),
    (psa, nDim, plUbound),
    E_FAIL, OLEAUT32)
#define SafeArrayGetUBound VAR_SafeArrayGetUBound

LOADER_FUNCTION(HRESULT, SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLbound),
    (psa, nDim, plLbound),
    E_FAIL, OLEAUT32)
#define SafeArrayGetLBound VAR_SafeArrayGetLBound

LOADER_FUNCTION(HRESULT, VariantClear,
    (VARIANTARG * pvarg),
    (pvarg),
    E_FAIL, OLEAUT32)
#define VariantClear VAR_VariantClear

LOADER_FUNCTION(HRESULT, VariantCopy,
    (VARIANTARG * pvargDest, VARIANTARG * pvargSrc),
    (pvargDest, pvargSrc),
    E_FAIL, OLEAUT32)
#define VariantCopy VAR_VariantCopy

LOADER_FUNCTION(HRESULT, SetErrorInfo,
    (ULONG dwReserved, IErrorInfo * perrinfo),
    (dwReserved, perrinfo),
    E_FAIL, OLEAUT32)
#define SetErrorInfo VAR_SetErrorInfo

LOADER_FUNCTION(HRESULT, CreateErrorInfo,
    (ICreateErrorInfo ** pperrinfo),
    (pperrinfo),
    E_FAIL, OLEAUT32)
#define CreateErrorInfo VAR_CreateErrorInfo

#endif

/////////////////////////////////////
// COMDLG32.DLL

#include <commdlg.h>

BOOL DemandLoadCOMDLG32();

LOADER_FUNCTION(BOOL, GetSaveFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetSaveFileNameA VAR_GetSaveFileNameA

LOADER_FUNCTION(BOOL, GetOpenFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetOpenFileNameA VAR_GetOpenFileNameA

LOADER_FUNCTION(BOOL, ChooseFontA,
    (LPCHOOSEFONT pcf),
    (pcf),
    FALSE, COMDLG32)
#define ChooseFontA VAR_ChooseFontA

/////////////////////////////////////
// VERSION.DLL

BOOL DemandLoadVERSION();

LOADER_FUNCTION(BOOL, VerQueryValueA,
    (const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, VERSION)
#define VerQueryValueA VAR_VerQueryValueA

LOADER_FUNCTION(BOOL, GetFileVersionInfoA,
    (PSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, VERSION)
#define GetFileVersionInfoA VAR_GetFileVersionInfoA

LOADER_FUNCTION(DWORD, GetFileVersionInfoSizeA,
    (LPSTR lptstrFilename, LPDWORD lpdwHandle),
    (lptstrFilename, lpdwHandle),
    0, VERSION)
#define GetFileVersionInfoSizeA VAR_GetFileVersionInfoSizeA

/////////////////////////////////////
// URLMON.DLL

BOOL DemandLoadURLMON();

LOADER_FUNCTION(HRESULT, CreateURLMoniker,
    (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR *ppmk),
    (pMkCtx, szURL, ppmk),
    E_FAIL, URLMON)
#define CreateURLMoniker VAR_CreateURLMoniker

LOADER_FUNCTION(HRESULT, URLOpenBlockingStreamA,
    (LPUNKNOWN pUnk,LPCSTR pURL,LPSTREAM* ppstm,DWORD i,LPBINDSTATUSCALLBACK p),
    (pUnk, pURL, ppstm, i, p),
    E_FAIL, URLMON)
#define URLOpenBlockingStreamA VAR_URLOpenBlockingStreamA

LOADER_FUNCTION(HRESULT, FindMimeFromData,
    (LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR *ppwzMimeOut, DWORD dwReserved),
    (pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved),
    E_FAIL, URLMON)
#define FindMimeFromData VAR_FindMimeFromData

LOADER_FUNCTION( HRESULT, CoInternetCombineUrl,
    (LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pszResult, cchResult, pcchResult, dwReserved),
    E_FAIL, URLMON)
#define CoInternetCombineUrl VAR_CoInternetCombineUrl

LOADER_FUNCTION( HRESULT, RegisterBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved),
    (pBC, pBSCb, ppBSCBPrev, dwReserved),
    E_FAIL, URLMON)
#define RegisterBindStatusCallback VAR_RegisterBindStatusCallback

LOADER_FUNCTION( HRESULT, RevokeBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb),
    (pBC, pBSCb),
    E_FAIL, URLMON)
#define RevokeBindStatusCallback VAR_RevokeBindStatusCallback

LOADER_FUNCTION( HRESULT, FaultInIEFeature,
    (HWND hwnd,     uCLSSPEC    *classpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
    (hwnd, classpec, pQuery, dwFlags),
    E_FAIL, URLMON)
#define FaultInIEFeature VAR_FaultInIEFeature

LOADER_FUNCTION( HRESULT, CoInternetGetSecurityUrl,
    (LPCWSTR pwzUrl, LPWSTR  *ppwzSecUrl, PSUACTION  psuAction, DWORD   dwReserved),
    (pwzUrl, ppwzSecUrl, psuAction, dwReserved),
    E_FAIL, URLMON)
#define CoInternetGetSecurityUrl VAR_CoInternetGetSecurityUrl

/////////////////////////////////////
// MLANG.DLL

#include <mlang.h>

BOOL DemandLoadMLANG(void);

LOADER_FUNCTION( HRESULT, IsConvertINetStringAvailable,
    (DWORD dwSrcEncoding, DWORD dwDstEncoding),
    (dwSrcEncoding, dwDstEncoding),
    S_FALSE, MLANG)
#define IsConvertINetStringAvailable VAR_IsConvertINetStringAvailable

LOADER_FUNCTION( HRESULT, ConvertINetString,
    (LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize),
    (lpdwMode, dwSrcEncoding, dwDstEncoding, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize),
    E_FAIL, MLANG)
#define ConvertINetString VAR_ConvertINetString

/////////////////////////////////////
// SHDOCVW.DLL

#include <shlobjp.h>
BOOL DemandLoadSHDOCVW();

LOADER_FUNCTION(HRESULT, AddUrlToFavorites,
    (HWND hwnd, LPWSTR pszUrlW, LPWSTR pszTitleW, BOOL fDisplayUI),
    (hwnd, pszUrlW, pszTitleW, fDisplayUI),
    E_FAIL, SHDOCVW)
#define AddUrlToFavorites VAR_AddUrlToFavorites

LOADER_FUNCTION(long, SetQueryNetSessionCount,
    (enum SessionOp Op),
    (Op),
    0, SHDOCVW)
#define SetQueryNetSessionCount VAR_SetQueryNetSessionCount


/////////////////////////////////////
// INETCPL.CPL

BOOL DemandLoadINETCPL();

LOADER_FUNCTION(int, OpenFontsDialog,
    (HWND hwnd, LPCSTR lpszKey),
    (hwnd, lpszKey),
    0, INETCPL)
#define OpenFontsDialog VAR_OpenFontsDialog

LOADER_FUNCTION(BOOL, LaunchConnectionDialog,
    (HWND   hwnd),
    (hwnd),
    FALSE,  INETCPL)
#define LaunchConnectionDialog VAR_LaunchConnectionDialog

/////////////////////////////////////
// MSO9.DLL
#include "msoci.h"
BOOL DemandLoadMSO9();

LOADER_FUNCTION(BOOL, MsoFGetComponentManager,
    (IMsoComponentManager **ppicm),
    (ppicm),
    FALSE, MSO9)
#define MsoFGetComponentManager VAR_MsoFGetComponentManager

/////////////////////////////////////
// WINMM.DLL


BOOL DemandLoadWinMM();

LOADER_FUNCTION(BOOL, sndPlaySoundA,
    (LPCSTR pszSound, UINT fuSound),
    (pszSound, fuSound),
    FALSE, WinMM)
#define sndPlaySoundA VAR_sndPlaySoundA

/////////////////////////////////////
// WSOCK32.DLL

#include <winsock.h>

typedef struct WSAData FAR * LPWSADATA;
typedef unsigned int    u_int;
typedef unsigned short  u_short;
typedef u_int           SOCKET;

BOOL DemandLoadWSOCK32();

LOADER_FUNCTION( int, WSAStartup,
    (WORD wVersionRequired, LPWSADATA lpWSAData),
    (wVersionRequired, lpWSAData),
    WSAVERNOTSUPPORTED, WSOCK32)
#define WSAStartup VAR_WSAStartup

LOADER_FUNCTION( int, WSACleanup,
    (void),
    (),
    SOCKET_ERROR, WSOCK32)
#define WSACleanup VAR_WSACleanup

LOADER_FUNCTION( int, WSAGetLastError,
    (void),
    (),
    0, WSOCK32)
#define WSAGetLastError VAR_WSAGetLastError

LOADER_FUNCTION( int, gethostname,
    (char FAR * name, int namelen),
    (name, namelen),
    SOCKET_ERROR, WSOCK32)
#define gethostname VAR_gethostname

LOADER_FUNCTION( struct hostent FAR *, gethostbyname,
    (const char FAR * name),
    (name),
    NULL, WSOCK32)
#define gethostbyname VAR_gethostbyname

LOADER_FUNCTION( HANDLE, WSAAsyncGetHostByName,
    (HWND hWnd, u_int wMsg, const char FAR * name, char FAR * buf, int buflen),
    (hWnd, wMsg, name, buf, buflen),
    0, WSOCK32)
#define WSAAsyncGetHostByName VAR_WSAAsyncGetHostByName

LOADER_FUNCTION( unsigned long, inet_addr,
    (const char FAR * cp),
    (cp),
    INADDR_NONE, WSOCK32)
#define inet_addr VAR_inet_addr

LOADER_FUNCTION( u_short, htons,
    (u_short hostshort),
    (hostshort),
    0, WSOCK32)
#define htons VAR_htons

LOADER_FUNCTION( int, WSACancelAsyncRequest,
    (HANDLE hAsyncTaskHandle),
    (hAsyncTaskHandle),
    SOCKET_ERROR, WSOCK32)
#define WSACancelAsyncRequest VAR_WSACancelAsyncRequest

LOADER_FUNCTION( int, send,
    (SOCKET s, const char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define send VAR_send

LOADER_FUNCTION( int, connect,
    (SOCKET s, const struct sockaddr FAR *name, int namelen),
    (s, name, namelen),
    SOCKET_ERROR, WSOCK32)
#define connect VAR_connect

LOADER_FUNCTION( int, WSAAsyncSelect,
    (SOCKET s, HWND hWnd, u_int wMsg, long lEvent),
    (s, hWnd, wMsg, lEvent),
    SOCKET_ERROR, WSOCK32)
#define WSAAsyncSelect VAR_WSAAsyncSelect

LOADER_FUNCTION( SOCKET, socket,
    (int af, int type, int protocol),
    (af, type, protocol),
    INVALID_SOCKET, WSOCK32)
#define socket VAR_socket

LOADER_FUNCTION( char FAR *, inet_ntoa,
    (struct in_addr in),
    (in),
    NULL, WSOCK32)
#define inet_ntoa VAR_inet_ntoa

LOADER_FUNCTION( int, closesocket,
    (SOCKET s),
    (s),
    SOCKET_ERROR, WSOCK32)
#define closesocket VAR_closesocket

LOADER_FUNCTION( int, recv,
    (SOCKET s, char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define recv VAR_recv

/////////////////////////////////////
// PSTOREC.DLL

#ifndef __IEnumPStoreProviders_FWD_DEFINED__
    #define __IEnumPStoreProviders_FWD_DEFINED__
    typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */
#ifndef __IPStore_FWD_DEFINED__
    #define __IPStore_FWD_DEFINED__
    typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */
typedef GUID PST_PROVIDERID;

BOOL DemandLoadPStoreC();

LOADER_FUNCTION( HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL, PStoreC)
#define PStoreCreateInstance VAR_PStoreCreateInstance

/////////////////////////////////////
// RICHED32.DLL
// note: special case as we don't use any riched functions but need to LoadLibrary it.

BOOL DemandLoadRichEdit();

/////////////////////////////////////
// RAS.DLL
#include <ras.h>
#include <raserror.h>

extern BOOL DemandLoadRAS(void);

LOADER_FUNCTION( DWORD, RasEnumEntriesA,
    (LPSTR reserved, LPSTR lpszPhoneBook, LPRASENTRYNAMEA lpEntry, LPDWORD lpcb, LPDWORD lpcEntries),
    (reserved, lpszPhoneBook, lpEntry, lpcb, lpcEntries),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEnumEntriesA VAR_RasEnumEntriesA

LOADER_FUNCTION( DWORD, RasEditPhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook, LPSTR lpszEntryName),
    (hwnd, lpszPhoneBook, lpszEntryName),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEditPhonebookEntryA VAR_RasEditPhonebookEntryA

LOADER_FUNCTION( DWORD, RasCreatePhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook),
    (hwnd, lpszPhoneBook),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasCreatePhonebookEntryA VAR_RasCreatePhonebookEntryA

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef unsigned long HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\encrypt.cpp ===
#include "item.h"
extern HINSTANCE        hInst;

const BYTE          RgbRC2_40[] = {
    0x30, 0x0f, 0x30, 0x0d, 0x06, 0x08, 0x2a, 0x86, 
    0x48, 0x86, 0xf7, 0x0d, 0x03, 0x02, 0x02, 0x01,
    0x28
};
const int CbRC2_40 = sizeof(RgbRC2_40);

const BYTE      RgbRC2_128[] = {
    0x30, 0x10, 
      0x30, 0xe, 
        0x6, 0x8, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x3, 0x2,
        0x2, 0x2, 0x0, 0x80
};

const BYTE      Rgb3DES[] = {
    0x30, 0xc, 
      0x30, 0xa,
        0x6, 0x8, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x3, 0x7
};

const BYTE      RgbRC6[] = {
    0x30, 0xc,
      0x30, 0xa,
        0x6, 0x8, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0xd, 0x3, 0x7f
};

const BYTE      RgbSkipjack[] = {
    0x30, 0xd,
      0x30, 0xb,
        0x6, 0x9, 0x60, 0x86, 0x48, 0x01, 0x65, 0x02, 0x01, 0x01, 0x04
};

struct {
    LPSTR               szDesc;
    const BYTE *        rgbAlg;
    DWORD               cbAlg;
} RgEncAlgs[] = {
    {"RC-2 40-bit", RgbRC2_40, sizeof(RgbRC2_40)},
    {"RC-2 64-bit", NULL, 0},
    {"RC-2 128-bit", RgbRC2_128, sizeof(RgbRC2_128)},
    {"DES", NULL, 0},
    {"Triple DES", Rgb3DES, sizeof(Rgb3DES)},
    {"RC-6", RgbRC6, sizeof(RgbRC6)},
    {"Skipjack", RgbSkipjack, sizeof(RgbSkipjack)},
#define ALG_SKIPJACK 6
};
const int Enc_Alg_Max = sizeof(RgEncAlgs)/sizeof(RgEncAlgs[0]);


////////////////////////////////////////////////////////////////////////////////////

HRESULT CEnvData::AddToMessage(DWORD * pulLayers, IMimeMessage * pmm, HWND hwnd)
{
    CRYPT_ATTRIBUTE             attr;
    DWORD                       cb;
    DWORD                       dwType = 0;
    FILETIME                    ft;
    HRESULT                     hr;
    IMimeBody *                 pmb = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    CItem *                     psd;
    BYTE                        rgb[50];
    CRYPT_ATTR_BLOB             valTime;
    PROPVARIANT                 var;
    
    //  Pull out the body interface to set security properties
    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))             goto exit;

    //  Find out what security already exists
    hr = pmb->GetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;
    dwType = var.ulVal;

    //  if any security, then we need to push on a new layer, all previous security
    //  is now on the "y-security" layer and not on the hbody layer
    
    if (dwType & MST_THIS_ENCRYPT) {
        hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;

        hr = pms2->Encode(hwnd, SEF_SENDERSCERTPROVIDED |
                          SEF_ENCRYPTWITHNOSENDERCERT);
        if (FAILED(hr))             goto exit;

        pms2->Release();            pms2 = NULL;
        pmb->Release();             pmb = NULL;
        dwType = 0;

        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;
    }

    //  We are going to put encryption on this layer
    dwType |= MST_THIS_ENCRYPT;
    
    //  Security Type
    var.vt = VT_UI4;
    var.ulVal = dwType;
    hr = pmb->SetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;

    var.vt = VT_BLOB;
    var.blob.cbSize = RgEncAlgs[m_iAlg].cbAlg;
    var.blob.pBlobData = (LPBYTE) RgEncAlgs[m_iAlg].rgbAlg;
    hr = pmb->SetOption(OID_SECURITY_ALG_BULK, &var);
    if (FAILED(hr))     goto exit;

    var.vt = VT_UI4;
    var.ulVal = SEF_SENDERSCERTPROVIDED;
    hr = pmm->SetOption(OID_SECURITY_ENCODE_FLAGS, &var);
    if (FAILED(hr))     goto exit;

    for (psd = Head(); psd != NULL; psd = psd->Next()) {
        hr = psd->AddToMessage(pulLayers, pmm, hwnd);
        if (FAILED(hr))         goto exit;
    }

    if (m_fAttributes  || m_fUnProtAttrib){
        hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;
    }

    if (m_fAttributes) {
        GetSystemTimeAsFileTime(&ft);
        cb = sizeof(rgb);
        if (CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                &ft, 0, 0, rgb, &cb)) {
            attr.pszObjId = szOID_RSA_signingTime;
            attr.cValue = 1;
            attr.rgValue = &valTime;
            valTime.pbData = rgb;
            valTime.cbData = cb;

            hr = pms2->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED, &attr);
            if (FAILED(hr))             goto exit;
        }
    }
    
    if (m_fUnProtAttrib  && (m_szUnProtAttribOID != NULL) && (m_valUnProtAttrib.pbData != NULL)) {
        attr.pszObjId = m_szUnProtAttribOID;
        attr.cValue = 1;
        attr.rgValue = &m_valUnProtAttrib;

        hr = pms2->SetAttribute(0, 0, SMIME_ATTRIBUTE_SET_UNPROTECTED, &attr);
        if (FAILED(hr))             goto exit;
    }

    hr = S_OK;
exit:
    if (pms2 != NULL)           pms2->Release();
    if (pmb != NULL)            pmb->Release();
    *pulLayers += 1;
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CEnvCertTrans::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                                    HWND hwnd)
{
    DWORD               cb;
    HRESULT             hr;
    DWORD               i;
    CRYPT_DATA_BLOB *   pblob;
    PCERT_EXTENSION     pext;
    IMimeBody *         pmb = NULL;
    CMS_RECIPIENT_INFO * precipInfo = NULL;
    IMimeSecurity2 *    psm = NULL;

    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))     goto exit;

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID*) &psm);
    if (FAILED(hr))     goto exit;

    precipInfo = (CMS_RECIPIENT_INFO *) malloc(sizeof(*precipInfo)*m_cCerts);
    if (precipInfo == NULL) goto exit;

    memset(precipInfo, 0, sizeof(*precipInfo)*m_cCerts);

    for (i=0; i<m_cCerts; i++) {
        precipInfo[i].dwRecipientType = CMS_RECIPIENT_INFO_TYPE_UNKNOWN;
        precipInfo[i].pccert = m_rgpccert[i];

        if (m_fUseSKI) {
            pext = CertFindExtension(szOID_SUBJECT_KEY_IDENTIFIER,
                                     m_rgpccert[i]->pCertInfo->cExtension,
                                     m_rgpccert[i]->pCertInfo->rgExtension);
            if (pext == NULL) {
                continue;
            }

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                     szOID_SUBJECT_KEY_IDENTIFIER,
                                     pext->Value.pbData, pext->Value.cbData,
                                     CRYPT_DECODE_ALLOC_FLAG,
                                     NULL, &pblob, &cb)) {
                continue;
            }
            
            precipInfo[i].dwU3 = CMS_RECIPIENT_INFO_KEYID_KEY_ID;
            precipInfo[i].u3.KeyId.pbData = (LPBYTE) malloc(pblob->cbData);
            memcpy(precipInfo[i].u3.KeyId.pbData, pblob->pbData, pblob->cbData);
            precipInfo[i].u3.KeyId.cbData = pblob->cbData;
            LocalFree(pblob);
        }
    }

    hr = psm->AddRecipient(0, m_cCerts, precipInfo);
    if (FAILED(hr)) goto exit;

    for (i=0; i<m_cCerts; i++) {
        if (precipInfo[i].dwU3 == CMS_RECIPIENT_INFO_KEYID_KEY_ID) {
            free(precipInfo[i].u3.KeyId.pbData);
        }
    }

    hr = S_OK;
exit:
    if (psm != NULL)    psm->Release();
    if (pmb != NULL)    pmb->Release();
    if (precipInfo != NULL)     free(precipInfo);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CEnvCertAgree::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                                    HWND hwnd)
{
    DWORD               cCerts;
    HCRYPTPROV          hprov = NULL;
    HRESULT             hr;
    DWORD               i;
    IMimeBody *         pmb = NULL;
    CMS_RECIPIENT_INFO * precipInfo = NULL;
    IMimeSecurity2 *    psm = NULL;
    PROPVARIANT         var;

    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))     goto exit;

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID*) &psm);
    if (FAILED(hr))     goto exit;

    precipInfo = (CMS_RECIPIENT_INFO *) malloc(sizeof(*precipInfo)*m_cCerts);
    if (precipInfo == NULL) goto exit;

    memset(precipInfo, 0, sizeof(*precipInfo)*m_cCerts);

    if (m_cCerts == 0) {
        hr = E_FAIL;
        goto exit;
    }
    
    if (strcmp(m_rgpccert[0]->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
               szOID_INFOSEC_keyExchangeAlgorithm) == 0) {
        DWORD           cb;
        PCRYPT_KEY_PROV_INFO    pInfo;
        //
        //  Get the parameters from the key

        if (!CertGetCertificateContextProperty(m_rgpccert[0],
                                               CERT_KEY_PROV_INFO_PROP_ID,
                                               NULL, &cb)) {
            hr = E_FAIL;
            goto exit;
        }

        pInfo = (PCRYPT_KEY_PROV_INFO) malloc(cb);

        if (!CertGetCertificateContextProperty(m_rgpccert[0],
                                               CERT_KEY_PROV_INFO_PROP_ID,
                                               pInfo, &cb)) {
            hr = E_FAIL;
            goto exit;
        }

        
        //  Setup originator info
        if (!CryptAcquireContextW(&hprov, pInfo->pwszContainerName,
                                  pInfo->pwszProvName, pInfo->dwProvType, 0)) {
            hr = E_FAIL;
            goto exit;
        }

        var.vt = VT_UI4;
        var.ulVal = (DWORD) hprov;
        hr = pmb->SetOption(OID_SECURITY_HCRYPTPROV, &var);
        if (FAILED(hr))         goto exit;

        for (i=1; i<m_cCerts; i++) {
            precipInfo[i-1].dwRecipientType = CMS_RECIPIENT_INFO_TYPE_KEYAGREE;
            precipInfo[i-1].pccert = m_rgpccert[i];

            precipInfo[i-1].KeyEncryptionAlgorithm.pszObjId =
                szOID_INFOSEC_keyExchangeAlgorithm;
            
            precipInfo[i-1].dwU1 = CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE;
            precipInfo[i-1].u1.u4.hprov = hprov;
            precipInfo[i-1].u1.u4.dwKeySpec = AT_KEYEXCHANGE;
            precipInfo[i-1].u1.u4.senderCertId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            precipInfo[i-1].u1.u4.senderCertId.IssuerSerialNumber.Issuer = m_rgpccert[0]->pCertInfo->Issuer;
            precipInfo[i-1].u1.u4.senderCertId.IssuerSerialNumber.SerialNumber = m_rgpccert[0]->pCertInfo->SerialNumber;
            precipInfo[i-1].u1.u4.SubjectPublicKey = m_rgpccert[i]->pCertInfo->SubjectPublicKeyInfo.PublicKey;

            precipInfo[i-1].dwU3 = CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL;
            precipInfo[i-1].u3.IssuerSerial.Issuer = m_rgpccert[i]->pCertInfo->Issuer;
            precipInfo[i-1].u3.IssuerSerial.SerialNumber = m_rgpccert[i]->pCertInfo->SerialNumber;
        }
        hprov = NULL;
        cCerts = m_cCerts - 1;
    }
    else {
        for (i=0; i<m_cCerts; i++) {
            precipInfo[i].dwRecipientType = CMS_RECIPIENT_INFO_TYPE_UNKNOWN;
            precipInfo[i].pccert = m_rgpccert[i];
        }
        cCerts = m_cCerts;
    }

    hr = psm->AddRecipient(0, cCerts, precipInfo);
    if (FAILED(hr)) goto exit;

    hr = S_OK;
exit:
    if (hprov != NULL)          CryptReleaseContext(hprov, 0);
    if (psm != NULL)    psm->Release();
    if (pmb != NULL)    pmb->Release();
    if (precipInfo != NULL)     free(precipInfo);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EncDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       i;
    DWORD                       iSel;
    static CEnvData *           ped = NULL;
    CHAR                        rgch[300];
    
    switch (msg) {
    case WM_INITDIALOG:
        for (i=0; i<sizeof(RgEncAlgs)/sizeof(RgEncAlgs[0]); i++) {
            if (RgEncAlgs[i].rgbAlg != NULL) {
                iSel = SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_ADDSTRING,
                                          0, (LPARAM) RgEncAlgs[i].szDesc);
                SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_SETITEMDATA,
                                   iSel, i);
            }
        }
        SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_SETCURSEL, 0, 0);
        SendDlgItemMessage(hdlg, IDC_EIC_FORCE, BM_SETCHECK, 1, 0);
        break;

    case UM_SET_DATA:
        ped = (CEnvData *) lParam;
        //  Fill in the dialog

        if (ped != NULL) {
            SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_SETCURSEL,
                               ped->GetAlg(), 0);
        }
        SendDlgItemMessage(hdlg, IDC_EIC_ATTRIBUTES, BM_SETCHECK,
                           ((ped != NULL) && (ped->m_fAttributes)), 0);
        SendDlgItemMessage(hdlg, IDC_EIC_UNPROTATTRIB, BM_SETCHECK,
                           ((ped != NULL) && (ped->m_fUnProtAttrib)), 0);

        break;

    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_EIC_ALG_SELECT, CBN_SELCHANGE):
            i = SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT, CB_GETCURSEL, 0, 0);
            ped->SetAlg(SendDlgItemMessage(hdlg, IDC_EIC_ALG_SELECT,
                                           CB_GETITEMDATA, i, 0));
            break;

        case MAKELONG(IDC_EIC_ATTRIBUTES, BN_CLICKED):
            ped->m_fAttributes = SendDlgItemMessage(hdlg, IDC_EIC_ATTRIBUTES,
                                                    BM_GETCHECK, 0, 0);
            break;
            
        case MAKELONG(IDC_EIC_UNPROTATTRIB, BN_CLICKED):
            ped->m_fUnProtAttrib = SendDlgItemMessage(hdlg, IDC_EIC_UNPROTATTRIB, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_EIC_DO_UNPROTATTRIB:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ATTRIB_CREATE), hdlg,
                           UnProtAttribCreateDlgProc, (LPARAM) ped);
            break;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK EncDataComposeDlgProc(CEncItem ** ppei, HWND hdlg, UINT msg,
                                    WPARAM wParam, LPARAM lParam, int iFilter)
{
    DWORD                       i;
    DWORD                       i1;
    PCCERT_CONTEXT              pccert;
    char                        rgch[256];
    
    switch (msg) {
    case WM_INITDIALOG:
        break;

    case UM_SET_DATA:
        //  Back load from dialog
        if (*ppei != NULL) {
            if ((*ppei)->m_rgpccert != NULL) {
                for (i=0; i<(*ppei)->m_cCerts; i++) {
                    CertFreeCertificateContext((*ppei)->m_rgpccert[i]);
                }
                free((*ppei)->m_rgpccert);
                (*ppei)->m_rgpccert = 0;
                (*ppei)->m_cCerts = 0;
            }

            i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCOUNT, 0, 0);
            (*ppei)->m_rgpccert = (PCCERT_CONTEXT *) malloc(sizeof(PCCERT_CONTEXT)*i1);
            for (i=0; i<i1; i++) {
                (*ppei)->m_rgpccert[i] = (PCCERT_CONTEXT) 
                    SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETITEMDATA, i, 0);
            }
            (*ppei)->m_cCerts = i1;
            SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_RESETCONTENT, 0, 0);
        }

        Assert(SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCOUNT, 0, 0) == 0);
        
        *ppei = (CEncItem *) lParam;
        //  Fill in the dialog

        if (*ppei != NULL) {
            for (i=0; i<(*ppei)->m_cCerts; i++) {
                GetFriendlyNameOfCertA((*ppei)->m_rgpccert[i], rgch, sizeof(rgch));
                i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_ADDSTRING, 0, (LPARAM) rgch);
                SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_SETITEMDATA, i1,
                         (LPARAM) CertDuplicateCertificateContext((*ppei)->m_rgpccert[i]));
            }
        }
        
        SendDlgItemMessage(hdlg, IDC_ETC_LIST, BM_SETCHECK,
                           (((*ppei) != NULL) && ((*ppei)->m_fUseSKI)), 0);
        break;

    case WM_DESTROY:
        i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCOUNT, 0, 0);
        for (i=0; i<i1; i++) {
            CertFreeCertificateContext((PCCERT_CONTEXT) 
                  SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETITEMDATA, i, 0));
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_ETC_ADD_CERT:
            pccert = NULL;
            if (DoCertDialog(hdlg, "Choose Enryption Certificate To Add",
                             (*ppei)->GetAllStore(), &pccert, iFilter)) {
                GetFriendlyNameOfCertA(pccert, rgch, sizeof(rgch));
                i1 = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_ADDSTRING, 0, (LPARAM) rgch);
                SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_SETITEMDATA, i1,
                         (LPARAM) pccert);
            }
            break;
            
        case IDC_ETC_DEL_CERT:
            i = SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETCURSEL, 0, 0);
            if (i != LB_ERR) {
                CertFreeCertificateContext((PCCERT_CONTEXT)
                  SendDlgItemMessage(hdlg, IDC_ETC_LIST, LB_GETITEMDATA, i, 0));
            }
            break;
        
        case MAKELONG(IDC_ETC_SKI, BN_CLICKED):
            (*ppei)->m_fUseSKI = SendDlgItemMessage(hdlg, IDC_ETC_SKI, BM_GETCHECK,
                                                    0, 0);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CALLBACK EncTransCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static CEncItem *           pei = NULL;

    return EncDataComposeDlgProc(&pei, hdlg, msg, wParam, lParam, FILTER_RSA_KEYEX);
}
 
BOOL CALLBACK EncAgreeCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       dwFilter = FILTER_DH_KEYEX;
    static CEncItem *           pei = NULL;

    if (pei != NULL) {
        if (pei->GetParent()->GetAlg() == ALG_SKIPJACK) {
            dwFilter = FILTER_KEA_KEYEX;
        }
    }

    return EncDataComposeDlgProc(&pei, hdlg, msg, wParam, lParam, dwFilter);
}

BOOL CALLBACK EncInfoReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD       i;
    
    switch (msg) {
    case WM_INITDIALOG:
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\item.h ===
#include <windows.h>
#include <wintrust.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <mimeole.h>
#include <imnact.h>
#include <imnxport.h>
#include <wab.h>
#include <reg.h>
#include <cryptdlg.h>
#include <smimepol.h>
#include "demand.h"
#include "..\..\ess\essout.h"
#include "myassert.h"

#include "smimetst.h"
#include "data.h"
#include "receipt.h"
#include "attrib.h"

class CMailListKey;


const int TYPE_MSG = 1;

const int TYPE_SIGN_INFO = 2;
const int TYPE_ENV_INFO = 3;

const int TYPE_SIGN_DATA = 4;
const int TYPE_ENV_AGREE = 5;
const int TYPE_ENV_TRANS = 6;
const int TYPE_ENV_MAILLIST = 7;

const int STATE_COMPOSE = 0x0000;
const int STATE_READ = 0x1000;

const int UM_SET_DATA = WM_USER + 1;
const int UM_RESET = WM_USER + 2;
const int UM_FILL = WM_USER + 3;

class CItem
{
    int         m_type;
    int		m_state;
    CItem *     m_pSibling;
    CItem *     m_pChild;
    CItem *     m_pParent;
    
public:
    CItem(int type, int state) {
        m_type = type;
	m_state = state;
        m_pSibling = NULL;
        m_pChild = NULL;
        m_pParent = NULL;
    }
    virtual ~CItem() {
        if (m_pParent != NULL) m_pParent->RemoveAsChild(this);
    }

    virtual HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND) {
        AssertSz(FALSE, "Should never get here. CItem::AddToMessage");
        return E_FAIL;
    }

    virtual HCERTSTORE  GetAllStore(void) {
        if (m_pParent != NULL) return m_pParent->GetAllStore();
        return NULL;
    }
    virtual HCERTSTORE  GetMyStore(void) {
        if (m_pParent != NULL) return m_pParent->GetMyStore();
        return NULL;
    }
    CItem *             GetParent(void) const { return m_pParent; }
    int                 GetType(void) const {return m_type;}
    int			GetState(void) const { return m_state; }
    CItem *             Head(void) const { return m_pChild; }
    void                MakeChild(CItem * pChild, CItem * pAfter);
    CItem *             Next(void) const { return m_pSibling; }
    void                RemoveAsChild(CItem * pChild);
    void                SetParent(CItem * pParent) { m_pParent = pParent; }
};

class CSignInfo;
class CSignData;

class CMessage : public CItem, public IMimeSecurityCallback
{
    HCERTSTORE          m_hCertStoreAll;
    HCERTSTORE          m_hCertStoreMy;
    int                 m_iterations;
    char                m_rgchPlain[CCH_OPTION_STRING];
    char                m_rgchCipher[CCH_OPTION_STRING];

    int                 m_fToFile:1;
    
public:
    CMessage(int state=STATE_READ) : CItem(TYPE_MSG, state) {
        m_hCertStoreMy = NULL;
        strcpy(m_rgchPlain, "<none>");
        strcpy(m_rgchCipher, "c:\\test.eml");
        m_iterations = 1;
        m_fToFile = TRUE;
    }
    ~CMessage() {
        Assert(m_hCertStoreMy == NULL);
    }

    CSignInfo *         Head(void) const { return (CSignInfo *) CItem::Head(); }
    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND, CItem *);
    HRESULT             Decode(HWND);
    HRESULT             Encode(HWND);
    char *              GetCipherFile(void) { return m_rgchCipher; }
    int                 GetFileNameSize(void) const { return CCH_OPTION_STRING; }
    HCERTSTORE          GetAllStore(void);
    HCERTSTORE          GetMyStore(void);
    char *              GetPlainFile(void) { return m_rgchPlain; }
    int&                GetIterationCount(void) { return m_iterations; }
    BOOL                ResetMessage(void);
    void                SetToFile(int i) { m_fToFile = i; }

    //

    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP FindKeyFor(HWND, DWORD, DWORD, const CMSG_CMS_RECIPIENT_INFO *, DWORD *, CMS_CTRL_DECRYPT_INFO *, PCCERT_CONTEXT *);
    STDMETHODIMP GetParameters(PCCERT_CONTEXT, LPVOID, DWORD *, LPBYTE *);
};


class CSignInfo : public CItem
{
    
public:
    DWORD               m_fBlob:1;

    CSignInfo(int state, CMessage * pparent) : CItem(TYPE_SIGN_INFO, state) {
        SetParent(pparent);
        m_fBlob = FALSE;
    }

    ~CSignInfo() {
        AssertSz(Head() == NULL, "Failed to release all children");
        AssertSz(Next() == NULL, "Failed to release all siblings");
    }

    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
    int                 Count(void) const;
    CSignData *         Head(void) const { return (CSignData *) CItem::Head(); }
    CSignInfo *         Next(void) const { return (CSignInfo *) CItem::Next(); }
};

class CSignData : public CItem
{
    CRYPT_ATTR_BLOB     m_valLabel;
    CRYPT_ATTR_BLOB     m_valReceipt;
    CRYPT_ATTR_BLOB     m_valMLHistory;
    CRYPT_ATTR_BLOB     m_valAuthAttrib;
    LPSTR               m_szAuthAttribOID;
    CRYPT_ATTR_BLOB     m_valUnAuthAttrib;
    LPSTR               m_szUnAuthAttribOID;
    
public:
    PCCERT_CONTEXT      m_pccert;
    DWORD               m_ulValidity;
    DWORD               m_fReceipt:1;
    DWORD               m_fLabel:1;
    DWORD               m_fMLHistory:1;
    DWORD               m_fUseSKI:1;
    DWORD               m_fAuthAttrib:1;
    DWORD               m_fUnAuthAttrib:1;
    
    CSignData(int state);
    ~CSignData(void) {
        CertFreeCertificateContext(m_pccert);
        AssertSz(Head() == NULL, "Should never have any children");
        AssertSz(Next() == NULL, "Failed to release all siblings");
        if (m_valLabel.pbData != NULL) free(m_valLabel.pbData);
        if (m_valReceipt.pbData != NULL) free(m_valReceipt.pbData);
        if (m_valMLHistory.pbData != NULL) free(m_valMLHistory.pbData);
        if (m_valAuthAttrib.pbData != NULL) free(m_valAuthAttrib.pbData);
        if (m_szAuthAttribOID != NULL) free(m_szAuthAttribOID);
        if (m_valUnAuthAttrib.pbData != NULL) free(m_valUnAuthAttrib.pbData);
        if (m_szUnAuthAttribOID != NULL) free(m_szUnAuthAttribOID);
    }

    HRESULT CSignData::BuildArrays(DWORD * pCount, DWORD * dwType,
                               PROPVARIANT * rgvHash, PCCERT_CONTEXT * rgpccert,
                               PROPVARIANT * rgvAuthAttr, HCERTSTORE hcertstore,
                                   IMimeSecurity2 * psmime2);
    void                GetLabel(LPBYTE * ppb, DWORD * pcb) {
        *ppb = m_valLabel.pbData;
        *pcb = m_valLabel.cbData;
    }
    void                GetMLHistory(LPBYTE * ppb, DWORD * pcb) {
        *ppb = m_valMLHistory.pbData;
        *pcb = m_valMLHistory.cbData;
    }
    void                GetReceiptData(LPBYTE * ppbReceiptData,
                                       DWORD * pcbReceiptData) {
        *ppbReceiptData = m_valReceipt.pbData;
        *pcbReceiptData = m_valReceipt.cbData;
    }
    void                GetAuthAttribData(LPBYTE * ppbAuthAttribData,
                                       DWORD * pcbAuthAttribData) {
        *ppbAuthAttribData = m_valAuthAttrib.pbData;
        *pcbAuthAttribData = m_valAuthAttrib.cbData;
    }
    LPSTR                GetAuthAttribOID() {
        return m_szAuthAttribOID;
    }
    void                GetUnAuthAttribData(LPBYTE * ppbUnAuthAttribData,
                                       DWORD * pcbUnAuthAttribData) {
        *ppbUnAuthAttribData = m_valUnAuthAttrib.pbData;
        *pcbUnAuthAttribData = m_valUnAuthAttrib.cbData;
    }
    LPSTR                GetUnAuthAttribOID() {
        return m_szUnAuthAttribOID;
    }
    CSignInfo *         GetParent(void) const {
        return (CSignInfo *) CItem::GetParent();
    }
    CSignData *         Next(void) const { return (CSignData *) CItem::Next(); }
    void                SetLabel(LPBYTE, DWORD);
    
    void                SetMLHistory(LPBYTE pbMLHistoryData, DWORD cbMLHistoryData) {
        if (m_valMLHistory.pbData != NULL) {
            free(m_valMLHistory.pbData);
            m_valMLHistory.pbData = NULL;
        }
        if (cbMLHistoryData > 0) {
            m_valMLHistory.pbData = (LPBYTE) malloc(cbMLHistoryData);
            memcpy(m_valMLHistory.pbData, pbMLHistoryData, cbMLHistoryData);
            m_valMLHistory.cbData = cbMLHistoryData;
        }
        return;
    }

    void                SetReceiptData(LPBYTE pbReceiptData, DWORD cbReceiptData) {
        if (m_valReceipt.pbData != NULL) {
            free(m_valReceipt.pbData);
            m_valReceipt.pbData = NULL;
        }
        if (cbReceiptData > 0) {
            m_valReceipt.pbData = (LPBYTE) malloc(cbReceiptData);
            memcpy(m_valReceipt.pbData, pbReceiptData, cbReceiptData);
            m_valReceipt.cbData = cbReceiptData;
        }
        return;
    }
    void                SetAuthAttribData(LPBYTE pbAuthAttribData, DWORD cbAuthAttribData) {
        if (m_valAuthAttrib.pbData != NULL) {
            free(m_valAuthAttrib.pbData);
            m_valAuthAttrib.pbData = NULL;
        }
        if (cbAuthAttribData > 0) {
            m_valAuthAttrib.pbData = (LPBYTE) malloc(cbAuthAttribData);
            memcpy(m_valAuthAttrib.pbData, pbAuthAttribData, cbAuthAttribData);
            m_valAuthAttrib.cbData = cbAuthAttribData;
        }
        return;
    }
    void                SetAuthAttribOID(LPSTR szAuthAttribOID) {
        if (m_szAuthAttribOID != NULL) {
            free(m_szAuthAttribOID);
            m_szAuthAttribOID = NULL;
        }
        if (szAuthAttribOID != NULL) {
            m_szAuthAttribOID = (LPSTR) malloc(strlen(szAuthAttribOID) + 1);
            strcpy(m_szAuthAttribOID, szAuthAttribOID);
        }
        return;
    }
    void                SetUnAuthAttribData(LPBYTE pbUnAuthAttribData, DWORD cbUnAuthAttribData) {
        if (m_valUnAuthAttrib.pbData != NULL) {
            free(m_valUnAuthAttrib.pbData);
            m_valUnAuthAttrib.pbData = NULL;
        }
        if (cbUnAuthAttribData > 0) {
            m_valUnAuthAttrib.pbData = (LPBYTE) malloc(cbUnAuthAttribData);
            memcpy(m_valUnAuthAttrib.pbData, pbUnAuthAttribData, cbUnAuthAttribData);
            m_valUnAuthAttrib.cbData = cbUnAuthAttribData;
        }
        return;
    }
    void                SetUnAuthAttribOID(LPSTR szUnAuthAttribOID) {
        if (m_szUnAuthAttribOID != NULL) {
            free(m_szUnAuthAttribOID);
            m_szUnAuthAttribOID = NULL;
        }
        if (szUnAuthAttribOID != NULL) {
            m_szUnAuthAttribOID = (LPSTR) malloc(strlen(szUnAuthAttribOID) + 1);
            strcpy(m_szUnAuthAttribOID, szUnAuthAttribOID);
        }
        return;
    }
    void        SetDefaultCert() {
        if (SignHash.cbData != 0) {
            m_pccert = CertFindCertificateInStore(GetMyStore(), X509_ASN_ENCODING,
                                          0, CERT_FIND_SHA1_HASH, &SignHash, NULL);
        }
    }
};

class CEnvData : public CItem
{
    int                 m_iAlg;
    CRYPT_ATTR_BLOB     m_valUnProtAttrib;
    LPSTR               m_szUnProtAttribOID;
    
public:
    DWORD               m_fAttributes:1;
    DWORD               m_fUnProtAttrib:1;
    
    CEnvData(int state, CMessage * pparent) : CItem(TYPE_ENV_INFO, state) {
        m_iAlg = 0;
        m_fAttributes = 0;
        m_fUnProtAttrib = FALSE;
        m_valUnProtAttrib.cbData = 0;
        m_valUnProtAttrib.pbData = NULL;
        m_szUnProtAttribOID = NULL;
        SetParent(pparent);
    }
    ~CEnvData(void) {
        AssertSz(Head() == NULL, "Should never have any children");
        AssertSz(Next() == NULL, "Failed to release all siblings");
    }

    HRESULT             AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
    int                 GetAlg(void) const { return m_iAlg; }
    void                GetUnProtAttribData(LPBYTE * ppbUnProtAttribData,
                                       DWORD * pcbUnProtAttribData) {
        *ppbUnProtAttribData = m_valUnProtAttrib.pbData;
        *pcbUnProtAttribData = m_valUnProtAttrib.cbData;
    }
    LPSTR                GetUnProtAttribOID() {
        return m_szUnProtAttribOID;
    }
    CEnvData *          Next(void) const { return (CEnvData *) CItem::Next(); }
    void                SetAlg(int iAlg) { m_iAlg = iAlg; }
    void                SetUnProtAttribData(LPBYTE pbUnProtAttribData, DWORD cbUnProtAttribData) {
        if (m_valUnProtAttrib.pbData != NULL) {
            free(m_valUnProtAttrib.pbData);
            m_valUnProtAttrib.pbData = NULL;
        }
        if (cbUnProtAttribData > 0) {
            m_valUnProtAttrib.pbData = (LPBYTE) malloc(cbUnProtAttribData);
            memcpy(m_valUnProtAttrib.pbData, pbUnProtAttribData, cbUnProtAttribData);
            m_valUnProtAttrib.cbData = cbUnProtAttribData;
        }
        return;
    }
    void                SetUnProtAttribOID(LPSTR szUnProtAttribOID) {
        if (m_szUnProtAttribOID != NULL) {
            free(m_szUnProtAttribOID);
            m_szUnProtAttribOID = NULL;
        }
        if (szUnProtAttribOID != NULL) {
            m_szUnProtAttribOID = (LPSTR) malloc(strlen(szUnProtAttribOID) + 1);
            strcpy(m_szUnProtAttribOID, szUnProtAttribOID);
        }
        return;
    }
};

class CEncItem : public CItem
{
public:
    DWORD               m_cCerts;
    PCCERT_CONTEXT *    m_rgpccert;

    BOOL                m_fUseSKI:1;

    CEncItem(int a, int b) : CItem(a, b) {
        m_cCerts = 0;
        m_rgpccert = 0;
    }

    ~CEncItem() {
        for (DWORD i=0; i<m_cCerts; i++) {
            CertFreeCertificateContext(m_rgpccert[i]);
        }
        if (m_rgpccert != NULL) free(m_rgpccert);
    }

    CEnvData *         GetParent(void) const {
        return (CEnvData *) CItem::GetParent();
    }
};

class CEnvCertTrans : public CEncItem
{
    
public:
    CEnvCertTrans(int state) : CEncItem(TYPE_ENV_TRANS, state) {
    }

    HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
};
    
class CEnvCertAgree : public CEncItem
{
    
public:
    CEnvCertAgree(int state) : CEncItem(TYPE_ENV_AGREE, state) {
    }

    HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
};
    
class CEnvMailList : public CItem
{
    
public:

    DWORD               m_cKeys;
    CMailListKey **     m_rgKeys;

    int                 m_fUsePrivateCSPs:1;

    CEnvMailList(int state) : CItem(TYPE_ENV_MAILLIST, state) {
        m_cKeys = 0;
        m_rgKeys = NULL;
        m_fUsePrivateCSPs = FALSE;
    }

    ~CEnvMailList() {
        if (m_rgKeys != NULL)   LocalFree(m_rgKeys);
    }

    HRESULT     AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\encode.cpp ===
#define INITGUID
#define DEFINE_STRCONST

#include <windows.h>
#include <ole2.h>

#include <initguid.h>
#include <mimeole.h>

#include "encode.h"

#define CORg(command)       \
    if (FAILED(command)) {  \
        goto Error;         \
    }

#define CPRg(command)       \
    if (! (command)) {      \
        goto Error;         \
    }


static LPWSTR s_rgwszValues[] = { NULL };

#define DEBUGFILE 1
#define MAX_LAYERS  3

//------------------------------------------------------------------
//------------------------------------------------------------------
HRESULT WriteBSTRToMultibyteToStream( const BSTR bstrStr, IStream** ppStream )
{
    HRESULT                 hr = S_OK;
    LARGE_INTEGER           liZero = {0};           // for ->Seek()

    char*   pszMessage = NULL;
    int     len = 0;

    if (!ppStream) return E_INVALIDARG;

    len = wcslen(bstrStr);
    CPRg(pszMessage = new char[len + 1]);
    WideCharToMultiByte(CP_ACP, 0, bstrStr, len,
                        pszMessage, len + 1,
                        NULL, NULL );
    pszMessage[len] = '\0';

    CORg(CreateStreamOnHGlobal(NULL, TRUE, ppStream));
    CORg((*ppStream)->Seek(liZero, STREAM_SEEK_SET, NULL));
    CORg((*ppStream)->Write(pszMessage,  len, NULL));
    CORg((*ppStream)->Seek(liZero, STREAM_SEEK_SET, NULL));
Error:
    if (pszMessage) delete[] pszMessage;
    return hr;
}

//------------------------------------------------------------------
SMimeEncode::SMimeEncode() :
    m_dwFlags(0),
    m_stmOutput(NULL),
    m_szSignAlg(NULL),
    m_szEncryptAlg(NULL),
    m_szBody(NULL),
    m_SigningCertInner(NULL),
    m_SigningCertOuter(NULL),
    m_EncryptionCert(NULL),
    m_hCryptProv(NULL),
    m_hMYCertStore(NULL),
    m_hCACertStore(NULL),
    m_hABCertStore(NULL),
    m_szSenderEmail(NULL),
    m_szSenderName(NULL),
    m_szRecipientEmail(NULL),
    m_szRecipientName(NULL),
    m_szOutputFile(NULL)
{

}

#define APPEND_SEPERATOR(subject) \
    if (lstrlen(subject)) {       \
        lstrcat(subject, " | ");  \
    }


//------------------------------------------------------------------
SMimeEncode::~SMimeEncode()
{
    // BUGBUG: Should clean up any allocated members
}

//------------------------------------------------------------------
HRESULT SMimeEncode::HrConfig(
    DWORD dwFlags,
    LPTSTR lpszBody,
    HCRYPTPROV hCryptProv,
    HCERTSTORE hMYCertStore,
    HCERTSTORE hCACertStore,
    HCERTSTORE hABCertStore,
    PCCERT_CONTEXT lpSigningCertInner,
    PCCERT_CONTEXT lpSigningCertOuter,
    PCCERT_CONTEXT lpEncryptionCert,
    LPTSTR lpszSenderEmail,
    LPTSTR lpszSenderName,
    LPTSTR lpszRecipientEmail,
    LPTSTR lpszRecipientName,
    LPTSTR lpszOutputFile
)
{
    HRESULT     hr = S_OK;
    static      char szSubject[257] = "";

    if (dwFlags & encode_Encrypt) {
        // specify an encryption algorithm
        // BUGBUG: Hardcoded in Encode
    }

    if (dwFlags & encode_InnerSign) {
        // specify a signing algorithm
        // BUGBUG: Hardcoded in Encode
    }


    if (dwFlags & encode_OuterSign) {
        // specify a signing algorithm
        // BUGBUG: Hardcoded in Encode
    }

    m_dwFlags = dwFlags;
    m_szBody = lpszBody;
    m_hCryptProv = hCryptProv;
    m_hMYCertStore = hMYCertStore;
    m_hCACertStore = hCACertStore;
    m_hABCertStore = hABCertStore;
    m_SigningCertInner = (PCERT_CONTEXT)lpSigningCertInner;
    m_SigningCertOuter = (PCERT_CONTEXT)lpSigningCertOuter;
    m_EncryptionCert = (PCERT_CONTEXT)lpEncryptionCert;
    m_szSenderEmail = lpszSenderEmail;
    m_szRecipientEmail = lpszRecipientEmail;
    m_szOutputFile = lpszOutputFile;

    // Set a meaningful subject
    lstrcpy(szSubject, "");
    if (dwFlags & encode_InnerSign) {
        APPEND_SEPERATOR(szSubject);
        if (dwFlags & encode_InnerClear) {
            lstrcat(szSubject, "Clear Sign");
        } else {
            lstrcat(szSubject, "Opaque Sign");
        }
    }
    if (dwFlags & encode_Encrypt) {
        APPEND_SEPERATOR(szSubject);
        lstrcat(szSubject, "Encrypt");
    }
    if (dwFlags & encode_OuterSign) {
        APPEND_SEPERATOR(szSubject);
        if (dwFlags & encode_OuterClear) {
            lstrcat(szSubject, "Clear Sign");
        } else {
            lstrcat(szSubject, "Opaque Sign");
        }
    }
    m_szSubject = szSubject;

    return(hr);
}

//------------------------------------------------------------------
HRESULT SMimeEncode::HrExecute(void) {
    // Using the SMIME engine:
    //
    // Build the message tree (attach the body)
    // CoCreateInstance( CLSID_IMimeSecurity )
    //  InitNew()
    // pSMIMEEngine->EncodeBody( IMimeMessageTree*,
    //              hRoot,
    //              SEF_??? | EBF_RECURSE ) OR ???
    //  HrEncodeOpaque( psi, pTree, hbody, pencoderoot, pstmOut )  ????
    //
    HRESULT                 hr = S_OK;
    LARGE_INTEGER           liZero = {0};               // for ->Seek()
    IStream*                pBuildStream = NULL;        // scratch stream
    IStream*                pResultStream = NULL;       // scratch stream
    IMimeMessage*           pMimeRoot = NULL;           // message in process
    IMimeBody*              pMimeRootBody = NULL;       // another version
    IMimeInternational*     pCharSet = NULL;
    HCHARSET                HCharset = 0;
    SYSTEMTIME              stNow;
    PROPVARIANT             var;
    HBODY                   hbBody;
    IMimeSecurity*          pMimeSecurity = NULL;
    ULONG                   dwSecurityType = MST_NONE;
    IPersistFile*           pIPFFileStore = NULL;
    HRESULT                 hrLocal = S_OK;
    WCHAR                   szwFileName[MAX_PATH + 1];
    CHAR                    szFrom[2 * (MAX_PATH + 1) + 1];

    // Multilayer stuff
    BOOL                    fTripleWrap = m_dwFlags & encode_OuterSign;
    ULONG                   ulSecurityLayers = 0;
    ULONG                   iEncryptLayer = (ULONG)-1;
    ULONG                   iInnerSignLayer = (ULONG)-1;
    ULONG                   iOuterSignLayer = (ULONG)-1;
    // Arrays of option values to set
    DWORD                   rgdwSecurityType[MAX_LAYERS] = {0};
    PCCERT_CONTEXT          rgdwCertSigning[MAX_LAYERS] = {0};
    HCERTSTORE              rgdwhCertStore[MAX_LAYERS] = {0};       // optional
    DWORD                   rgdwUserValidity[MAX_LAYERS] = {0};     // decode only
    DWORD                   rgdwROMsgValidity[MAX_LAYERS] = {0};    // decode only
    FILETIME                rgftSigntime[MAX_LAYERS] = {0};         // optional
    PROPVARIANT             rgpvAlgHash[MAX_LAYERS] = {0};
    PROPVARIANT             rgpvSymcaps[MAX_LAYERS] = {0};
    PROPVARIANT             rgpvAuthattr[MAX_LAYERS] = {0};         // optional
    PROPVARIANT             rgpvUnauthattr[MAX_LAYERS] = {0};       // optional


    // This is the ALOGORITHM ID for SHA1, default supported signing alg
    const BYTE c_SHA1_ALGORITHM_ID[] =
      {0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E,
       0x03, 0x02, 0x1A};

    // This is the ALOGORITHM ID for RC2 -- 40 bit, the default encrypt
    const BYTE c_RC2_40_ALGORITHM_ID[] =
      {0x30, 0x0F, 0x30, 0x0D, 0x06, 0x08, 0x2A, 0x86,
       0x48, 0x86, 0xF7, 0x0D, 0x03, 0x02, 0x02, 0x01,
       0x28};


    // get the signing cert from my store
    if (! m_hCryptProv || ! m_hMYCertStore || ! m_hCACertStore || ! m_hABCertStore) {
        hr = E_FAIL;
        goto Error;
    }


    // Create the Message object
    //
    CORg(CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER,
      IID_IMimeMessage, (LPVOID*)&pMimeRoot));

    CORg(pMimeRoot->InitNew());


    CORg(CreateStreamOnHGlobal( NULL, TRUE, &pBuildStream));
    CORg(pBuildStream->Seek(liZero, STREAM_SEEK_SET, NULL));
    CORg(pBuildStream->Write(m_szBody, lstrlen(m_szBody), NULL));
    CORg(pBuildStream->Seek(liZero, STREAM_SEEK_SET, NULL));

    CORg(pMimeRoot->SetTextBody(TXT_PLAIN, IET_8BIT, NULL, pBuildStream, &hbBody));

    // Create the formatted From address
    if (m_szSenderName) {
        lstrcpy(szFrom, "\"");
        lstrcat(szFrom, m_szSenderName);
        lstrcat(szFrom, "\" ");
    } else {
        lstrcpy(szFrom, "");
    }
    lstrcat(szFrom, "<");
    lstrcat(szFrom, m_szSenderEmail);
    lstrcat(szFrom, ">");

    var.vt = VT_LPSTR;
    var.pszVal = szFrom;                            // From Email

    CORg(hr = pMimeRoot->SetProp(PIDTOSTR(PID_HDR_FROM), 0, &var));


    var.vt = VT_LPSTR;                              // ignored?
    var.pszVal = (LPSTR) STR_MIME_TEXT_PLAIN;
    CORg(pMimeRoot->SetBodyProp(hbBody, STR_HDR_CNTTYPE, 0, &var));

    var.vt = VT_LPSTR;                              // ignored?
    var.pszVal = (LPSTR) STR_ENC_QP;
    CORg(pMimeRoot->SetBodyProp(hbBody, STR_HDR_CNTXFER, 0, &var));

    // Set subject
    var.vt = VT_LPSTR;
    var.pszVal = (LPSTR) m_szSubject;
    CORg(pMimeRoot->SetBodyProp(hbBody, STR_HDR_SUBJECT, 0, &var));

    CORg(pMimeRoot->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID*)&pMimeRootBody));


    //
    // Set the security options
    //

    // How many layers?
    if (m_dwFlags & encode_InnerSign) {
        iInnerSignLayer = ulSecurityLayers;
        ulSecurityLayers++;
    }
    if (m_dwFlags & encode_Encrypt) {
        iEncryptLayer = ulSecurityLayers;  // index in arrays
        ulSecurityLayers++;
    }
    if (m_dwFlags & encode_OuterSign) {
        iOuterSignLayer = ulSecurityLayers;
        ulSecurityLayers++;
    }


    // Set up for Inner Signing
    if (m_dwFlags & encode_InnerSign) {
        // specifiy the Security Type for this layer
        rgdwSecurityType[iInnerSignLayer] = m_dwFlags & encode_InnerClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;
        dwSecurityType |= m_dwFlags & encode_InnerClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;

        // Specify the Signing Time for this layer
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &rgftSigntime[iInnerSignLayer]);

        // specify the signature alg for this layer
        rgpvAlgHash[iInnerSignLayer].vt = VT_BLOB;
        rgpvAlgHash[iInnerSignLayer].blob.cbSize = sizeof(c_SHA1_ALGORITHM_ID);
        rgpvAlgHash[iInnerSignLayer].blob.pBlobData = (BYTE*)c_SHA1_ALGORITHM_ID;

        // Specify the signing cert for this layer
        rgdwCertSigning[iInnerSignLayer] = m_SigningCertInner;

        // HCERTSTORE              rgdwhCertStore[MAX_LAYERS] = {0};       // optional
        // PROPVARIANT             rgpvSymcaps[MAX_LAYERS] = {0};
        // PROPVARIANT             rgpvAuthattr[MAX_LAYERS] = {0};         // optional
        // PROPVARIANT             rgpvUnauthattr[MAX_LAYERS] = {0};       // optional
    }

    // Set up for Outer Signing
    if (m_dwFlags & encode_OuterSign) {
        // specifiy the Security Type for this layer
        rgdwSecurityType[iOuterSignLayer] = m_dwFlags & encode_InnerClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;
        dwSecurityType |= m_dwFlags & encode_OuterClear ? MST_THIS_SIGN : MST_THIS_BLOBSIGN;

        // Specify the Signing Time for this layer
        GetSystemTime(&stNow);
        SystemTimeToFileTime(&stNow, &rgftSigntime[iOuterSignLayer]);

        // specify the signature alg for this layer
        rgpvAlgHash[iOuterSignLayer].vt = VT_BLOB;
        rgpvAlgHash[iOuterSignLayer].blob.cbSize = sizeof(c_SHA1_ALGORITHM_ID);
        rgpvAlgHash[iOuterSignLayer].blob.pBlobData = (BYTE*)c_SHA1_ALGORITHM_ID;

        // Specify the signing cert for this layer
        rgdwCertSigning[iOuterSignLayer] = m_SigningCertOuter;

        // HCERTSTORE              rgdwhCertStore[MAX_LAYERS] = {0};       // optional
        // PROPVARIANT             rgpvSymcaps[MAX_LAYERS] = {0};
        // PROPVARIANT             rgpvAuthattr[MAX_LAYERS] = {0};         // optional
        // PROPVARIANT             rgpvUnauthattr[MAX_LAYERS] = {0};       // optional
    }

    // Set up for Encrypting
    if (m_dwFlags & encode_Encrypt) {
        HCERTSTORE aCertStores[3];

        //
        // BUGBUG: Hardcoded to RC2 40-bit
        var.vt = VT_BLOB;
        var.blob.cbSize = sizeof( c_RC2_40_ALGORITHM_ID );
        var.blob.pBlobData = (BYTE*) c_RC2_40_ALGORITHM_ID;
        CORg(hr = pMimeRootBody->SetOption(OID_SECURITY_ALG_BULK, &var));

        // for encryption, get to the right cert store....
        //
        var.caul.cElems = 3;
        aCertStores[0] = CertDuplicateStore(m_hCACertStore);
        aCertStores[1] = CertDuplicateStore(m_hMYCertStore);
        aCertStores[2] = CertDuplicateStore(m_hABCertStore);
        var.caul.pElems = (ULONG*)aCertStores;
        CORg(hr = pMimeRootBody->SetOption(OID_SECURITY_SEARCHSTORES, &var));

        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = 1;
        var.caul.pElems = (ULONG*)&m_EncryptionCert;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_RG_CERT_ENCRYPT, &var));

#ifdef BUGBUG // This isn't right, is it?
        // include the cert...
        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = 1;
        var.caul.pElems = (ULONG*)&m_EncryptionCert;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_RG_CERT_BAG, &var));
#endif // OLD_STUFF

        dwSecurityType |= MST_THIS_ENCRYPT;
        rgdwSecurityType[iEncryptLayer] = MST_THIS_ENCRYPT;
    }

    // Set the OID_SECURITY_TYPE
    if (fTripleWrap) {
        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = ulSecurityLayers;
        var.caul.pElems = rgdwSecurityType;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_TYPE_RG, &var));

        var.vt = VT_VECTOR | VT_FILETIME;
        var.cafiletime.cElems = ulSecurityLayers;
        var.cafiletime.pElems = rgftSigntime;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_SIGNTIME_RG, &var));

        var.vt = VT_VECTOR | VT_UI4;
        var.caul.cElems = ulSecurityLayers;
        var.caul.pElems = (DWORD *)rgdwCertSigning;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_CERT_SIGNING_RG, &var));

        var.vt = VT_VECTOR | VT_VARIANT;
        var.capropvar.cElems = ulSecurityLayers;
        var.capropvar.pElems = rgpvAlgHash;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_ALG_HASH_RG, &var));

        var.vt = VT_VECTOR | VT_VARIANT;
        var.capropvar.cElems = ulSecurityLayers;
        var.capropvar.pElems = rgpvAlgHash;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_ALG_HASH_RG, &var));

    } else {
        // Security Type
        var.vt = VT_UI4;
        var.ulVal = dwSecurityType;
        CORg(pMimeRootBody->SetOption(OID_SECURITY_TYPE, &var));

        if (dwSecurityType & MST_SIGN_MASK) {
            // Signing Time
            var.vt = VT_FILETIME;
            memcpy(&var.filetime, &rgftSigntime[iInnerSignLayer], sizeof(FILETIME));
            CORg(pMimeRootBody->SetOption(OID_SECURITY_SIGNTIME, &var));

            // Hash Algorithm
            var.vt = VT_BLOB;
            memcpy(&var.blob, &rgpvAlgHash[iInnerSignLayer].blob, sizeof(BLOB));
            CORg(hr = pMimeRootBody->SetOption(OID_SECURITY_ALG_HASH, &var));

            // Signing Cert
            var.vt = VT_UI4;
            var.ulVal = (ULONG)m_SigningCertInner;
            CORg(pMimeRootBody->SetOption(OID_SECURITY_CERT_SIGNING, &var));
        }
    }


    // Set the HWND for CAPI calls
    var.vt = VT_UI4;
    var.ulVal = 0;
    CORg(pMimeRootBody->SetOption(OID_SECURITY_HWND_OWNER, &var));


    // all built, get rid of the shadow pointer we are holding
    //
    pMimeRootBody->Release();
    pMimeRootBody = NULL;

    pMimeRoot->Commit(0);

    // SMIME Engine
    //
    CORg(CoCreateInstance(CLSID_IMimeSecurity, NULL, CLSCTX_INPROC_SERVER,
      IID_IMimeSecurity, (LPVOID*) &pMimeSecurity));

    CORg(pMimeSecurity->InitNew());

    // ERRORMESSAGE( Unable to encrypt/encode string )
    CORg(pMimeSecurity->EncodeBody(pMimeRoot, HBODY_ROOT,
      EBF_RECURSE | SEF_SENDERSCERTPROVIDED | SEF_ENCRYPTWITHNOSENDERCERT |
      EBF_COMMITIFDIRTY));

    // Get an Hcharset to force the encoding correctly
    //
    CORg(CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER,
      IID_IMimeInternational, (LPVOID*)&pCharSet));

    CORg(pCharSet->FindCharset("UTF-8", &HCharset));

    CORg(pMimeRoot->SetCharset(HCharset,    // HCharset
      CSET_APPLY_ALL));                     // Applytype


    // dump it to a file
    //
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, m_szOutputFile, -1, szwFileName, MAX_PATH);
    CORg(pMimeRoot->QueryInterface(IID_IPersistFile, (LPVOID*)&pIPFFileStore));
    CORg(pIPFFileStore->Save(szwFileName, FALSE));


    // extract the whole message into a stream
    //
    CORg(CreateStreamOnHGlobal(NULL, TRUE, &pResultStream));
    CORg(pMimeRoot->Save(pResultStream, FALSE));

Error:
    if (pBuildStream)   pBuildStream->Release();
    if (pResultStream)  pResultStream->Release();
    if (pMimeRoot)      pMimeRoot->Release();
    if (pMimeRootBody)  pMimeRootBody->Release();
    if (pCharSet)       pCharSet->Release();
    if (pMimeSecurity)  pMimeSecurity->Release();
    if (pIPFFileStore)  pIPFFileStore->Release();

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\maillist.cpp ===
#include        "item.h"
#include        "maillist.h"
#include        "reg.h"

CMailListKey *          PmlHead = NULL;
extern HINSTANCE        hInst;

#define MLALG_3DES      0
#define MLALG_RC2_40    1
#define MLALG_RC2_128   2

struct {
    LPSTR       szDesc;
} RgAlgs[] = {
    {"3DES"},
    {"RC2 128"},
    {"RC2 40"},
};

BYTE rgbPrivKey[] =
{
0x07, 0x02, 0x00, 0x00, 0x00, 0xA4, 0x00, 0x00,
0x52, 0x53, 0x41, 0x32, 0x00, 0x02, 0x00, 0x00,
0x01, 0x00, 0x00, 0x00, 0xAB, 0xEF, 0xFA, 0xC6,
0x7D, 0xE8, 0xDE, 0xFB, 0x68, 0x38, 0x09, 0x92,
0xD9, 0x42, 0x7E, 0x6B, 0x89, 0x9E, 0x21, 0xD7,
0x52, 0x1C, 0x99, 0x3C, 0x17, 0x48, 0x4E, 0x3A,
0x44, 0x02, 0xF2, 0xFA, 0x74, 0x57, 0xDA, 0xE4,
0xD3, 0xC0, 0x35, 0x67, 0xFA, 0x6E, 0xDF, 0x78,
0x4C, 0x75, 0x35, 0x1C, 0xA0, 0x74, 0x49, 0xE3,
0x20, 0x13, 0x71, 0x35, 0x65, 0xDF, 0x12, 0x20,
0xF5, 0xF5, 0xF5, 0xC1, 0xED, 0x5C, 0x91, 0x36,
0x75, 0xB0, 0xA9, 0x9C, 0x04, 0xDB, 0x0C, 0x8C,
0xBF, 0x99, 0x75, 0x13, 0x7E, 0x87, 0x80, 0x4B,
0x71, 0x94, 0xB8, 0x00, 0xA0, 0x7D, 0xB7, 0x53,
0xDD, 0x20, 0x63, 0xEE, 0xF7, 0x83, 0x41, 0xFE,
0x16, 0xA7, 0x6E, 0xDF, 0x21, 0x7D, 0x76, 0xC0,
0x85, 0xD5, 0x65, 0x7F, 0x00, 0x23, 0x57, 0x45,
0x52, 0x02, 0x9D, 0xEA, 0x69, 0xAC, 0x1F, 0xFD,
0x3F, 0x8C, 0x4A, 0xD0,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

0x64, 0xD5, 0xAA, 0xB1,
0xA6, 0x03, 0x18, 0x92, 0x03, 0xAA, 0x31, 0x2E,
0x48, 0x4B, 0x65, 0x20, 0x99, 0xCD, 0xC6, 0x0C,
0x15, 0x0C, 0xBF, 0x3E, 0xFF, 0x78, 0x95, 0x67,
0xB1, 0x74, 0x5B, 0x60,

0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

};

BYTE rgbSymKey[] = 
{
0x01, 0x02, 0x00, 0x00, 0x02, 0x66, 0x00, 0x00,
0x00, 0xA4, 0x00, 0x00, 0xAD, 0x89, 0x5D, 0xDA,
0x82, 0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12,
0x12, 0x12, 0x02, 0x00
};

int ToInt(char a, char b)
{
    return (a-'0')*10 + b-'0';
}

int ToInt(char a)
{
    return (a-'0');
}

BOOL MSProviderCryptImportKey(HCRYPTPROV hProv, LPBYTE rgbSymKey, DWORD cbSymKey,
                              HCRYPTKEY * phkey)
{
    BOOL fSuccess = FALSE;
    HCRYPTKEY hPrivKey = 0;

    if (!CryptImportKey( hProv,
                         rgbPrivKey,
                         sizeof(rgbPrivKey),
                         0,
                         0,
                         &hPrivKey ))
    {
        goto Ret;
    }

    if (!CryptImportKey( hProv,
                         rgbSymKey,
                         cbSymKey,
                         hPrivKey,
                         0,
                         phkey ))
    {
        goto Ret;
    }

    fSuccess = TRUE;
Ret:
    if (hPrivKey)
        CryptDestroyKey( hPrivKey );

    return fSuccess;
}

////////////////////////////////////////////////////////////////////////////////

BOOL FormatDate(LPSTR rgch, DWORD cch, FILETIME ft)
{
    int                 cch2;
    LPWSTR              pwsz;
    SYSTEMTIME          st;

    if (!FileTimeToSystemTime(&ft, &st)) {
        return FALSE;
    }

    cch2 = GetDateFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, rgch, cch);
    cch2 -= 1;
    rgch[cch2++] = ' ';

    GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL,
                   &rgch[cch2], cch-cch2);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////

CMailListKey::CMailListKey()
{
    m_cRef = 1;
    m_pmlNext = NULL;
    
    m_cbKeyId = 0;
    m_pbKeyId = NULL;

    memset(&m_ft, 0, sizeof(m_ft));
    
    m_cbOtherKeyId = 0;
    m_pbOtherKeyId = NULL;

    m_iAlg = -1;

    m_cbKeyMaterial = 0;
    m_pbKeyMaterial = NULL;

    m_hprov = NULL;
    m_hkey = NULL;
}

CMailListKey::~CMailListKey()
{
    AssertSz(m_cRef == 0, "CMailListKey ref count != 0");
    if (m_pbKeyId != NULL)              free(m_pbKeyId);
    if (m_pbOtherKeyId != NULL)         free(m_pbOtherKeyId);
    if (m_pbKeyMaterial != NULL)        free(m_pbKeyMaterial);
    if (m_hkey != NULL)                 CryptDestroyKey(m_hkey);
    if (m_hprov != NULL)                CryptReleaseContext(m_hprov, 0);
}

void CMailListKey::Release()
{
    m_cRef -= 1;
    if (m_cRef == 0) delete this;
    return;
}

LPSTR CMailListKey::FormatKeyName(LPSTR rgch, DWORD cch)
{
    AssertSz(m_cbKeyId > 0, "Must have some key id");
    memcpy(rgch, m_pbKeyId, min(cch, m_cbKeyId+1));
    rgch[min(cch-1, m_cbKeyId)] = 0;
    return rgch;
}

LPSTR CMailListKey::FormatKeyDate(LPSTR rgch, DWORD cch)
{
    if (m_ft.dwHighDateTime == 0) {
        rgch[0] = 0;
    }
    else {
        FormatDate(rgch, cch, m_ft);
    }
    return rgch;
}

LPSTR CMailListKey::FormatKeyOther(LPSTR rgch, DWORD cch)
{
    memcpy(rgch, m_pbOtherKeyId, min(cch, m_cbOtherKeyId));
    rgch[cch-1] = 0;
    return rgch;
}

LPSTR CMailListKey::FormatKeyAlg(LPSTR rgch, DWORD cch)
{
    AssertSz((MLALG_3DES <= m_iAlg) && (m_iAlg <= MLALG_RC2_128),
             "Must have some key Algorithm");
    Assert(cch > strlen(RgAlgs[m_iAlg].szDesc));
    strcpy(rgch, RgAlgs[m_iAlg].szDesc);
    return rgch;
}

LPSTR CMailListKey::FormatKeyData(LPSTR rgch, DWORD cch)
{
    AssertSz(m_cbKeyMaterial > 0, "Must have some key material");
    memcpy(rgch, m_pbKeyMaterial, min(cch, m_cbKeyMaterial));
    rgch[cch-1] = 0;
    return rgch;
}

BOOL CMailListKey::ParseKeyName(LPSTR psz)
{
    if (m_pbKeyId != NULL) {
        LocalFree(m_pbKeyId);
    }
    m_pbKeyId = (LPBYTE) LocalAlloc(0, strlen(psz));
    if (m_pbKeyId == NULL) {
        return FALSE;
    }

    m_cbKeyId = strlen(psz);
    memcpy(m_pbKeyId, psz, strlen(psz));

    return TRUE;
}

BOOL CMailListKey::ParseKeyData(LPSTR psz)
{
    char        ch1;
    char        ch2;
    DWORD       cb;
    LPBYTE      pb;
    BYTE        rgb[50];

    for (cb = 0, pb = rgb; *psz != 0; cb++, pb++) {
        ch1 = *psz++;
        if (('0' <= ch1) && (ch1 <= '9')) ch1 -= '0';
        else if (('a' <= ch1) && (ch1 <= 'f')) ch1 -= 'a' - 10;
        else if (('A' <= ch1) && (ch1 <= 'F')) ch1 -= 'A' - 10;
        else {
            return FALSE;
        }
        
        ch2 = *psz++;
        if (ch2 == 0) return FALSE;
        else if (('0' <= ch2) && (ch2 <= '9')) ch2 -= '0';
        else if (('a' <= ch2) && (ch2 <= 'f')) ch2 -= 'a' - 10;
        else if (('A' <= ch2) && (ch2 <= 'F')) ch2 -= 'A' - 10;
        else {
            return FALSE;
        }

        *pb = (ch1 << 4) | ch2;
    }
    
    if (m_pbKeyMaterial != NULL) {
        LocalFree(m_pbKeyMaterial);
    }

    switch(m_iAlg) {
    case MLALG_3DES:
        if (cb != 196/8) return FALSE;
        break;

    case MLALG_RC2_40:
        if (cb < 40/8) return FALSE;
        break;

    case MLALG_RC2_128:
        if (cb < 128/8) return FALSE;
        break;

    default:
        Assert(FALSE);
        return FALSE;
    }
    
    m_pbKeyMaterial = (LPBYTE) LocalAlloc(0, cb);
    if (m_pbKeyMaterial == NULL) {
        return FALSE;
    }

    m_cbKeyMaterial = cb;
    memcpy(m_pbKeyMaterial, rgb, cb);
    return TRUE;
}

BOOL CMailListKey::ParseKeyOther(LPSTR psz)
{
    return TRUE;
}

BOOL CMailListKey::ParseKeyDate(LPSTR psz)
{
    DWORD       cb;
    SYSTEMTIME  st = {0};
    
    cb = strlen(psz);
    if ((cb != 12) && (cb != 14)) {
        MessageBox(NULL, "Date format is YYMMDDHHMMSS or YYYYMMDDHHMMSS", "smimetst", MB_OK);
        return FALSE;
    }

    if (cb == 12) {
        st.wYear = ToInt(psz[0], psz[1]) + 1900;
    }
    else {
        st.wYear = ToInt(psz[0])*1000 + ToInt(psz[1])*100 + ToInt(psz[2], psz[3]);
        psz += 2;
    }

    st.wMonth = ToInt(psz[2], psz[3]);
    st.wDay = ToInt(psz[4], psz[5]);
    st.wHour = ToInt(psz[6], psz[7]);
    st.wMinute = ToInt(psz[8], psz[9]);
    st.wSecond = ToInt(psz[10], psz[11]);

    SystemTimeToFileTime(&st, &m_ft);
    
    return TRUE;
}

BOOL CMailListKey::ParseKeyAlg(int i)
{
    m_iAlg = i;
    return TRUE;
}

BOOL CMailListKey::LoadKey(HKEY hkey)
{
    DWORD       cb;
    DWORD       dwType;
    
    RegGetBinary(hkey, "KeyId", &m_pbKeyId, &m_cbKeyId);
    RegGetLong(hkey, "Key Type", &m_iAlg);
    RegGetBinary(hkey, "Key Material", &m_pbKeyMaterial, &m_cbKeyMaterial);
    RegGetBinary(hkey, "Other Id", &m_pbOtherKeyId, &m_cbOtherKeyId);

    cb = sizeof(m_ft);
    RegQueryValueEx(hkey, "Time", 0, &dwType, (LPBYTE) &m_ft, &cb);
    return TRUE;
}
    

BOOL CMailListKey::SaveKey(HKEY hkey)
{
    DWORD       dwDisp;
    HKEY        hkey2 = NULL;
    char        rgch[256];

    FormatKeyName(rgch, sizeof(rgch));
    if (RegCreateKeyEx(hkey, (LPSTR) rgch, 0, NULL, 0, KEY_WRITE, NULL,
                       &hkey2, &dwDisp)) {
        goto exit;
    }
    RegSaveBinary(hkey2, "KeyId", m_pbKeyId, m_cbKeyId);
    RegSaveLong(hkey2, "Key Type", m_iAlg);
    RegSaveBinary(hkey2, "Key Material", m_pbKeyMaterial, m_cbKeyMaterial);
    if (m_pbOtherKeyId != NULL) {
        RegSaveBinary(hkey2, "Other Id", m_pbOtherKeyId, m_cbOtherKeyId);
    }
    if (m_ft.dwHighDateTime != 0) {
        RegSaveBinary(hkey2, "Time", (LPBYTE) &m_ft, sizeof(m_ft));
    }

exit:
    if (hkey2 != NULL)          RegCloseKey(hkey2);
    return TRUE;
}

HRESULT CMailListKey::LoadKey(CMS_RECIPIENT_INFO * precipInfo, BOOL fUsePrivateCSPs)
{
    CMSG_RC2_AUX_INFO           aux;
    DWORD                       dwProvType;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       kt;
    LPBYTE                      pb;
    BLOBHEADER *                pbhdr;
    LPSTR                       pszProvider = NULL;
    BYTE                        rgb[sizeof(rgbSymKey)];

    switch(m_iAlg) {
    case MLALG_3DES:
        precipInfo->KeyEncryptionAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMS3DESwrap;
        kt = CALG_3DES;
        if (!fUsePrivateCSPs) {
            pszProvider = MS_ENHANCED_PROV;
        }
        dwProvType = PROV_RSA_FULL;
        break;

    case MLALG_RC2_40:
        precipInfo->KeyEncryptionAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMSRC2wrap;
        aux.cbSize = sizeof(aux);
        aux.dwBitLen = 40;
        precipInfo->pvKeyEncryptionAuxInfo = (DWORD *) &aux;
        kt = CALG_RC2;
        if (!fUsePrivateCSPs) {
            pszProvider = MS_DEF_PROV;
        }
        dwProvType = PROV_RSA_FULL;
        break;

    case MLALG_RC2_128:
        precipInfo->KeyEncryptionAlgorithm.pszObjId = szOID_RSA_SMIMEalgCMSRC2wrap;
        aux.cbSize = sizeof(aux);
        aux.dwBitLen = 128;
        precipInfo->pvKeyEncryptionAuxInfo = (DWORD *) &aux;
        if (!fUsePrivateCSPs) {
            pszProvider = MS_ENHANCED_PROV;
        }
        kt = CALG_RC2;
        dwProvType = PROV_RSA_FULL;
        break;
    }
    
    precipInfo->dwU1 = CMS_RECIPIENT_INFO_PUBKEY_PROVIDER;
    Assert(m_hprov == NULL);
    Assert(m_hkey == NULL);
#if 1
        // try to open the enhanced provider
    if (!CryptAcquireContext( &m_hprov, "iD2ImportKey", pszProvider, dwProvType,
                              0 )) {
        if (!CryptAcquireContext( &m_hprov, "iD2ImportKey", pszProvider,
                                  dwProvType, CRYPT_NEWKEYSET )) {
            hr = E_FAIL;
            goto exit;
        }
    }

#else // 0 // use this code for exchcsp.dll acting as an rsa provider
    if (!CryptAcquireContext(&m_hprov, NULL, pszProvider, dwProvType,
                             CRYPT_VERIFYCONTEXT)) {
        hr = E_FAIL;
        goto exit;
    }
#endif // 1

    
    memcpy(rgb, rgbSymKey, sizeof(rgbSymKey));

    pbhdr = (BLOBHEADER *) rgb;
    pbhdr->aiKeyAlg = kt;
    pb = &rgb[sizeof(*pbhdr)];
    *((ALG_ID *) pb) = CALG_RSA_KEYX;

    pb += sizeof(ALG_ID);
    for (i=0; i<m_cbKeyMaterial; i++) {
        pb[m_cbKeyMaterial-i-1] = m_pbKeyMaterial[i];
    }
    pb[m_cbKeyMaterial] = 0;

    if (!MSProviderCryptImportKey(m_hprov, rgb, sizeof(rgb), &m_hkey)) {
        hr = E_FAIL;
        CryptReleaseContext(m_hprov, 0);
        m_hprov = NULL;
        goto exit;
    }

    hr = S_OK;
exit:
    return hr;
}

HRESULT CMailListKey::AddToMessage(IMimeSecurity2 * psm, BOOL fUsePrivateCSPs)
{
    CMSG_RC2_AUX_INFO           aux;
    DWORD                       dwProvType;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       kt;
    LPBYTE                      pb;
    BLOBHEADER *                pbhdr;
    LPSTR                       pszProvider;
    CMS_RECIPIENT_INFO          recipInfo = {0};
    BYTE                        rgb[sizeof(rgbSymKey)];

    hr = LoadKey(&recipInfo, fUsePrivateCSPs);
    if (FAILED(hr)) {
        goto exit;
    }
    
    //    recipInfo.cbSize = sizeof(recipInfo);
    recipInfo.dwRecipientType = /*CMS_RECIPIENT_INFO_KEK*/ 3;
    
    recipInfo.u1.u2.hprov = m_hprov;
    recipInfo.u1.u2.hkey = m_hkey;
    
    recipInfo.dwU3 = CMS_RECIPIENT_INFO_KEYID_KEY_ID;
    recipInfo.u3.KeyId.pbData = m_pbKeyId;
    recipInfo.u3.KeyId.cbData = m_cbKeyId;

    if (m_ft.dwHighDateTime != 0) {
        recipInfo.filetime = m_ft;
    }
    if (m_cbOtherKeyId != 0) {
        // M00BUG -- need to set other key id
        //        recipInfo.pOtherAttr =;
    }

    hr = psm->AddRecipient(0, 1, &recipInfo);

exit:
    return hr;
}

HRESULT CMailListKey::FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipIndex,
                                  const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                                  CMS_CTRL_DECRYPT_INFO * pDecryptInfo)
{
    HRESULT             hr;
    CMS_RECIPIENT_INFO  recipInfo = {0};
    CMailListKey *      pml;

    for (pml = PmlHead; pml != NULL; pml = pml->Next()) {
        if ((pRecipInfo->pMailList->KeyId.cbData == pml->m_cbKeyId) &&
            (memcmp(pRecipInfo->pMailList->KeyId.pbData,
                    pml->m_pbKeyId, pml->m_cbKeyId) == 0) &&
            (memcmp(&pRecipInfo->pMailList->Date,
                    &pml->m_ft, sizeof(FILETIME)) == 0)) {
            // M00BUG -- need to check for otherkeyid still.
            break;
        }
    }

    if (pml == NULL) {
        return S_FALSE;
    }

    hr = pml->LoadKey(&recipInfo, FALSE);
    if (FAILED(hr)) {
        return hr;
    }

    pDecryptInfo->maillist.cbSize = sizeof(CMSG_CTRL_MAIL_LIST_DECRYPT_PARA);
    pDecryptInfo->maillist.hCryptProv = pml->m_hprov;
    pDecryptInfo->maillist.pMailList = pRecipInfo->pMailList;
    pDecryptInfo->maillist.dwRecipientIndex = dwRecipIndex;
    pDecryptInfo->maillist.dwKeyChoice = CMSG_MAIL_LIST_HANDLE_KEY_CHOICE;
    pDecryptInfo->maillist.hKeyEncryptionKey = pml->m_hkey;

    pml->m_hprov = NULL;
    pml->m_hkey = NULL;
    return S_OK;
}
    
////////////////////////////////////////////////////////////////////////////////


BOOL CALLBACK MailListAddDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMailListKey *      pkey;
    char                rgch[100];
    
    switch (msg) {
    case WM_INITDIALOG:
        SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_ADDSTRING, 0, (LPARAM) "3DES");
        SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_ADDSTRING, 0, (LPARAM) "RC2 128");
        SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_ADDSTRING, 0, (LPARAM) "RC2 40");
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            pkey = new CMailListKey();
            
            GetDlgItemText(hdlg, IDC_AMLK_ID, rgch, sizeof(rgch));
            if (!pkey->ParseKeyName(rgch)) {
                goto fail;
            }
            
            pkey->ParseKeyAlg(SendDlgItemMessage(hdlg, IDC_AMLK_ALG, CB_GETCURSEL, 0, 0));
            
            GetDlgItemText(hdlg, IDC_AMLK_KEY, rgch, sizeof(rgch));
            if (!pkey->ParseKeyData(rgch)) {
                goto fail;
            }
            
            GetDlgItemText(hdlg, IDC_AMLK_DATE, rgch, sizeof(rgch));
            if (!pkey->ParseKeyDate(rgch)) {
                goto fail;
            }
            
            GetDlgItemText(hdlg, IDC_AMLK_OTHER, rgch, sizeof(rgch));
            if (!pkey->ParseKeyOther(rgch)) {
                goto fail;
            }

            pkey->Next(PmlHead);
            PmlHead = pkey;
            
            EndDialog(hdlg, IDOK);
            break;

        fail:
            pkey->Release();
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        default:
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void InsertItem(HWND hwnd, int iItem, CMailListKey * pml)
{
    int                 k;
    LV_ITEM             lvI;
    char                rgch[256];
    
    lvI.mask = LVIF_PARAM /* | LVIF_STATE | LVIF_IMAGE*/ | LVIF_TEXT;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.iImage = 0;
    lvI.lParam = (DWORD) pml;
    lvI.iItem = iItem;
            
    pml->FormatKeyName(rgch, sizeof(rgch));
    lvI.pszText = rgch;

    k = ListView_InsertItem(hwnd, &lvI);

    ListView_SetItemText(hwnd, k, 2, pml->FormatKeyDate(rgch, sizeof(rgch)));
    ListView_SetItemText(hwnd, k, 3, pml->FormatKeyOther(rgch, sizeof(rgch)));
    ListView_SetItemText(hwnd, k, 4, pml->FormatKeyAlg(rgch, sizeof(rgch)));
    ListView_SetItemText(hwnd, k, 5, pml->FormatKeyData(rgch, sizeof(rgch)));
    return;
}    

BOOL CALLBACK MailListDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMailListKey *      pmlItem;
    HWND                hwnd;
    int                 i;
    LV_COLUMN           lvC;
    LV_ITEM             lvI;
    char                rgch[256];
    
    switch (msg) {
    case WM_INITDIALOG:
        hwnd = GetDlgItem(hdlg, IDC_FML_LIST);

        //  Insert columns
        lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
        lvC.fmt = LVCFMT_LEFT;          // Left justify column
        lvC.cx = 650/5;

        lvC.pszText = "Key Name";
        ListView_InsertColumn(hwnd, 0, &lvC);

        lvC.pszText = "Date";
        ListView_InsertColumn(hwnd, 1, &lvC);

        lvC.pszText = "Other";
        ListView_InsertColumn(hwnd, 2, &lvC);

        lvC.pszText = "Algorithm";
        ListView_InsertColumn(hwnd, 3, &lvC);

        lvC.pszText = "Key Data";
        ListView_InsertColumn(hwnd, 4, &lvC);

        for (i=0, pmlItem = PmlHead; pmlItem != NULL; pmlItem = pmlItem->Next()) {
            InsertItem(hwnd, i, pmlItem);
        }

        if (ListView_GetSelectedCount(hwnd) == 0) {
            EnableWindow(GetDlgItem(hdlg, IDC_FML_DELETE), FALSE);
        }
        SendMessage(hwnd, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog(hdlg, 0);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case IDC_FML_ADD:
            if (DialogBox(hInst, MAKEINTRESOURCE(IDD_FILE_ADD_ML), hdlg,
                          MailListAddDlgProc) == IDOK) {
                hwnd = GetDlgItem(hdlg, IDC_FML_LIST);
                InsertItem(hwnd, 100, PmlHead);
            }
            break;

        case IDC_FML_DELETE:
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

DWORD GetMailListKeys(HKEY hkey)
{
    DWORD               cbData;
    DWORD               dw;
    FILETIME            ft;
    HKEY                hkey2;
    DWORD               i;
    CMailListKey *      pml;
    char                rgch[256];
    
    for (i=0; TRUE; i++) {
        cbData = sizeof(rgch);
        dw = RegEnumKeyEx(hkey, i, rgch, &cbData, NULL, NULL, NULL, &ft);
        if (dw != ERROR_SUCCESS) {
            break;
        }

        dw = RegOpenKey(hkey, rgch, &hkey2);

        pml = new CMailListKey;
        if (pml->LoadKey(hkey2)) {
            pml->Next(PmlHead);
            PmlHead = pml;
        }
        RegCloseKey(hkey2);
    }
    return 0;
}

DWORD SaveMailListKeys(HKEY hkey)
{
    CMailListKey *              pml;

    for (pml = PmlHead; pml != NULL; pml = pml->Next()) {
        pml->SaveKey(hkey);
    }
    
    return 0;
}

///////////////////////////////////////////////////////////////////////////

BOOL CALLBACK EncMLComposeDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cItems;
    BOOL                        f;
    DWORD                       i;
    DWORD                       i1;
    static CEnvMailList *       peml = NULL;
    CMailListKey *              pml;
    CMailListKey *              pml1;
    CHAR                        rgch[300];
    
    switch (msg) {
    case WM_INITDIALOG:
        for (pml = PmlHead; pml != NULL; pml = pml->Next()) {
            pml->FormatKeyName(rgch, sizeof(rgch));
            i = SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_ADDSTRING, 0, (LPARAM) rgch);
            SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_SETITEMDATA, i, (LPARAM) pml);
        }
        break;

    case UM_SET_DATA:
        cItems = SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETCOUNT, 0, 0);

        if (peml != NULL) {
            for (i=i1=0; i<cItems; i++) {
                if (SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETSEL, i, 0)) {
                    i1 += 1;
                }
            }

            if (peml->m_rgKeys != NULL) {
                LocalFree(peml->m_rgKeys);
            }
            peml->m_rgKeys = (CMailListKey **) LocalAlloc(0, i1*sizeof(CMailListKey*));
            for (i=i1=0; i<cItems; i++) {
                if (SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETSEL, i, 0)) {
                    peml->m_rgKeys[i1] = (CMailListKey *) SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_GETITEMDATA, i, 0);
                    i1 += 1;
                }
            }
            peml->m_cKeys = i1;
        }
        
        peml = (CEnvMailList *) lParam;
        if (peml != NULL) {
            Assert(peml->GetType() == TYPE_ENV_MAILLIST);
        
            //  Fill in the dialog

            if ((peml != NULL) && (peml->m_cKeys != NULL)) {
                for (i=0; i<cItems; i++) {
                    pml1 = (CMailListKey *) SendDlgItemMessage(hdlg, IDC_MLC_ID,
                                                               LB_GETITEMDATA, i, 0);
                    for (i1=0, f = FALSE; i1<peml->m_cKeys; i1++) {
                        if (peml->m_rgKeys[i1] == pml1) {
                            f = TRUE;
                            break;
                        }
                    }
                    SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_SETSEL, i, f);
                }
            }
            else {
                for (i=0; i<cItems; i++) {
                    SendDlgItemMessage(hdlg, IDC_MLC_ID, LB_SETSEL, i, FALSE);
                }
            }
        }
        
        SendDlgItemMessage(hdlg, IDC_MLC_CSPS, BM_SETCHECK,
                           ((peml != NULL) && (peml->m_fUsePrivateCSPs)), 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_MLC_CSPS, BN_CLICKED):
            peml->m_fUsePrivateCSPs = SendDlgItemMessage(hdlg, IDC_MLC_CSPS,
                                                         BM_GETCHECK, 0, 0);
            return FALSE;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    return TRUE;
}

///////////////////////////////////////////////////////

HRESULT CEnvMailList::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                                   HWND hwnd)
{
    HRESULT     hr;
    DWORD       i;
    IMimeBody *         pmb = NULL;
    IMimeSecurity2 *    psm = NULL;

    //  Pull out the body interface to set security properties
    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))             goto exit;

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID*) &psm);
    if (FAILED(hr))             goto exit;

    for (i=0; i<m_cKeys; i++) {
        hr = m_rgKeys[i]->AddToMessage(psm, m_fUsePrivateCSPs);
        if (FAILED(hr)) {
            goto exit;
        }
    }
    hr = S_OK;
    
exit:
    if (psm != NULL)            psm->Release();
    if (pmb != NULL)            pmb->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\receipt.h ===
BOOL FormatNames(DWORD cNames, PCERT_NAME_BLOB rgNames, HWND hwnd, DWORD idc);
BOOL ParseNames(DWORD * pcNames, PCERT_NAME_BLOB * prgNames, HWND hwnd, DWORD idc);
BOOL ReceiptCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\myassert.h ===
#ifndef _MYASSERT_H_
#define _MYASSERT_H_

#ifdef assert
#error("Can't use two assert systems")
#endif // assert

#ifdef DEBUG
extern const TCHAR SzNull[];
VOID   DigSigAssertFn(LPCTSTR, LPCTSTR, int, LPCTSTR);

#define SZASSERT

#define Assert(condition)               \
        if (!(condition)) {             \
            static const char SZASSERT szExpr[] = #condition; \
            static const char SZASSERT szFile[] = __FILE__; \
            DigSigAssertFn(szExpr, SzNull, __LINE__, szFile); \
        }

#define AssertSz(condition, szInfo)             \
        if (!(condition)) {             \
            static const char SZASSERT szExpr[] = #condition; \
            static const char SZASSERT szFile[] = __FILE__; \
            DigSigAssertFn(szExpr, szInfo, __LINE__, szFile); \
         }

#else  // !DEBUG

#define Assert(condition)

#define AssertSz(condition, szInfo)

#endif // DEBUG

#endif // _MYASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\maillist.h ===
BOOL CALLBACK EncMLComposeDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

class CMailListKey 
{
    DWORD               m_cRef;
    CMailListKey *      m_pmlNext;
    
    LPBYTE              m_pbKeyId;
    DWORD               m_cbKeyId;
    FILETIME            m_ft;
    LPBYTE              m_pbOtherKeyId;
    DWORD               m_cbOtherKeyId;
    DWORD               m_iAlg;
    LPBYTE              m_pbKeyMaterial;
    DWORD               m_cbKeyMaterial;

    HCRYPTKEY           m_hkey;
    HCRYPTPROV          m_hprov;

    HRESULT             LoadKey(CMS_RECIPIENT_INFO *, BOOL);
public:
    CMailListKey();
    ~CMailListKey();

    void        AddRef() { m_cRef += 1; }
    void        Release();
    CMailListKey * Next() { return m_pmlNext; }
    void        Next(CMailListKey * pkey) { m_pmlNext = pkey; return; }

    HRESULT     AddToMessage(IMimeSecurity2 * psm, BOOL);

    LPSTR       FormatKeyName(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyDate(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyOther(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyAlg(LPSTR rgch, DWORD cch);
    LPSTR       FormatKeyData(LPSTR rgch, DWORD cch);

    BOOL        ParseKeyName(LPSTR psz);
    BOOL        ParseKeyDate(LPSTR psz);
    BOOL        ParseKeyOther(LPSTR psz);
    BOOL        ParseKeyData(LPSTR psz);
    BOOL        ParseKeyAlg(int);

    BOOL        LoadKey(HKEY);
    BOOL        SaveKey(HKEY);

    static HRESULT FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipIndex,
                           const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                           CMS_CTRL_DECRYPT_INFO * pDecryptInfo);
};


BOOL CALLBACK MailListDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\receipt.cpp ===
#include "item.h"

#ifndef CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG
#define CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG 0
#endif

BOOL FormatNames(DWORD cNames, PCERT_NAME_BLOB rgNames, HWND hwnd, DWORD idc)
{
    DWORD                       cb;
    BOOL                        f;
    DWORD                       i;
    DWORD                       i1;
    DWORD                       i2;
    PCERT_ALT_NAME_INFO         pname = NULL;
    WCHAR                       rgwch[4096];
    
    rgwch[0] = 0;

    for (i1=0; i1<cNames; i1++) {
        f = CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                rgNames[i1].pbData, rgNames[i1].cbData,
                                CRYPT_ENCODE_ALLOC_FLAG, NULL, &pname, &cb);
        if (!f) break;

        for (i2=0; i2<pname->cAltEntry; i2++) {
            if (i2 > 0) {
                wcscat(rgwch, L"  ");
            }
            switch( pname->rgAltEntry[i2].dwAltNameChoice ) {
            case CERT_ALT_NAME_RFC822_NAME:
                wcscat(rgwch, L"SMTP: ");
                wcscat(rgwch, pname->rgAltEntry[i2].pwszRfc822Name);
                wcscat(rgwch, L"\r\n");
                break;

            case CERT_ALT_NAME_DIRECTORY_NAME:
                break;
            }
        }
        free(pname);
        pname = NULL;
    }

    if (f) SetDlgItemTextW(hwnd, idc, rgwch);
    return f;
}

BOOL ParseNames(DWORD * pcNames, PCERT_NAME_BLOB * prgNames, HWND hwnd, DWORD idc)
{
    DWORD               cb;
    DWORD               cEntry = 0;
    DWORD               cNames = 0;
    BOOL                f;
    DWORD               i;
    LPWSTR              pwsz;
    LPWSTR              pwsz1;
    CRYPT_DER_BLOB      rgDer[50] = {0};
    CERT_ALT_NAME_INFO  rgNames[50] = {0};
    CERT_ALT_NAME_ENTRY rgEntry[200] = {0};
    WCHAR               rgwch[4096];

    GetDlgItemTextW(hwnd, idc, rgwch, sizeof(rgwch)/sizeof(WCHAR));
    rgwch[4095] = 0;
    
    pwsz = rgwch;

    while (*pwsz != 0) {
        if (cEntry == 200) {
            MessageBox(hwnd, "Can't have more than 200 entries", "smimetst", MB_OK);
            return FALSE;
        }

        if (*pwsz == ' ') {
            while (*pwsz == ' ') pwsz++;
            rgNames[cNames-1].cAltEntry += 1;
        }
        else {
            if (cNames == 50) {
                MessageBox(hwnd, "Can't have more than 50 names", "smimetst", MB_OK);
                return FALSE;
            }
            cNames += 1;
            rgNames[cNames-1].rgAltEntry = &rgEntry[cEntry];
            rgNames[cNames-1].cAltEntry = 1;
        }

        if (_wcsnicmp(pwsz, L"SMTP:", 5) == 0) {
            pwsz += 5;
            while (*pwsz == ' ') pwsz++;
            rgEntry[cEntry].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
            rgEntry[cEntry].pwszRfc822Name = pwsz;
            while ((*pwsz != 0) && (*pwsz != '\n') && (*pwsz != '\r')) pwsz++;
        }
        else if (_wcsnicmp(pwsz, L"X500:", 5) == 0) {
            pwsz += 5;
            while (*pwsz == ' ') pwsz++;
            for (pwsz1 = pwsz; ((*pwsz != 0) && (*pwsz != '\n') &&
                                (*pwsz != '\r')); pwsz++);
            if (*pwsz != 0) {
                *pwsz = 0;
                pwsz++;
            }
            
            rgEntry[cEntry].dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
            f = CertStrToNameW(X509_ASN_ENCODING, pwsz1, 
                               CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG, NULL,
                               NULL, &cb, NULL);
            if (!f) {
                MessageBox(hwnd, "X500 name does not parse", "smimetst", MB_OK);
                return FALSE;
            }
            
            rgEntry[cEntry].DirectoryName.pbData = (LPBYTE) malloc(cb);
            f = CertStrToNameW(X509_ASN_ENCODING, pwsz1,
                               CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG, NULL, 
                               rgEntry[cEntry].DirectoryName.pbData, &cb,
                               NULL);
            if (!f) return FALSE;
            rgEntry[cEntry].DirectoryName.cbData = cb;
        }
        else {
            MessageBox(hwnd, "unknown address type", "smimetst", MB_OK);
            return FALSE;
        }

        if (*pwsz == '\r') {
            *pwsz = 0;
            pwsz++;
        }
        if (*pwsz == '\n') {
            *pwsz = 0;
            pwsz++;
        }
        cEntry += 1;
    }

    *prgNames = (PCERT_NAME_BLOB) malloc(sizeof(CERT_NAME_BLOB) * cNames);
    if (*prgNames == NULL) return FALSE;
    
    for (i=0; i<cNames; i++) {
        f = CryptEncodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                &rgNames[i], CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &(*prgNames)[i].pbData, &(*prgNames)[i].cbData);
        if (!f) return f;
    }
    *pcNames = cNames;
    return f;
}

BOOL ReceiptCreateDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    DWORD                       cbNames;
    BOOL                        f;
    LPBYTE                      pb;
    PSMIME_RECEIPT_REQUEST      pReceipt;
    static CSignData *          psd = NULL;
    CHAR                        rgchContent[256];
    SMIME_RECEIPT_REQUEST       receipt;
    
    switch (message) {
    case WM_INITDIALOG:
        pReceipt = NULL;

        psd = (CSignData *) lParam;
        psd->GetReceiptData(&pb, &cbNames);
        f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Receipt_Request,
                                pb, cbNames, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &pReceipt, &cb);

        if (pReceipt) {
            //  Set Content Identifier -- M00TODO
            SetDlgItemText(hwnd, IDC_RC_CONTENT,
                           (LPSTR) pReceipt->ContentIdentifier.pbData);

            //  Set Top buttons -
            // M00BUG
            if (pReceipt->ReceiptsFrom.cNames > 0) {
                FormatNames(pReceipt->ReceiptsFrom.cNames,
                            pReceipt->ReceiptsFrom.rgNames, hwnd, IDC_RC_FROM_TEXT);
            }

            //  Set ReceiptsTo
            FormatNames(pReceipt->cReceiptsTo, pReceipt->rgReceiptsTo, hwnd,
                        IDC_RC_TO_TEXT);
        }
        else {
            FormatNames(CMyNames, RgMyNames, hwnd, IDC_RC_TO_TEXT);
        }
        break;

    case WM_COMMAND:
        switch(wParam) {
        case MAKELONG(IDC_RC_FROM_ALL, BN_CLICKED):
        case MAKELONG(IDC_RC_FROM_TOP, BN_CLICKED):
            EnableWindow(GetDlgItem(hwnd, IDC_RC_FROM_TEXT), FALSE);
            break;
            
        case MAKELONG(IDC_RC_FROM_SOME, BN_CLICKED):
            EnableWindow(GetDlgItem(hwnd, IDC_RC_FROM_TEXT), TRUE);
            break;
            
        case IDOK:
            memset(&receipt, 0, sizeof(receipt));

            GetDlgItemText(hwnd, IDC_RC_CONTENT,
                           rgchContent, sizeof(rgchContent));
            receipt.ContentIdentifier.pbData = (LPBYTE) rgchContent;
            receipt.ContentIdentifier.cbData = strlen(rgchContent);

            if (SendMessage(GetDlgItem(hwnd, IDC_RC_FROM_ALL), BM_GETCHECK, 0, 0)) {
                receipt.ReceiptsFrom.AllOrFirstTier = SMIME_RECEIPTS_FROM_ALL;
            }
            else if (SendMessage(GetDlgItem(hwnd, IDC_RC_FROM_TOP), BM_GETCHECK, 0, 0)) {
                receipt.ReceiptsFrom.AllOrFirstTier = SMIME_RECEIPTS_FROM_FIRST_TIER;
            }
            else {
                receipt.ReceiptsFrom.AllOrFirstTier = 0;
                if (!ParseNames(&receipt.ReceiptsFrom.cNames,
                                &receipt.ReceiptsFrom.rgNames,
                                hwnd, IDC_RC_FROM_TEXT)) {
                    return FALSE;
                }
            }

            if (!ParseNames(&receipt.cReceiptsTo, &receipt.rgReceiptsTo,
                            hwnd, IDC_RC_TO_TEXT)) {
                free(receipt.ReceiptsFrom.rgNames);
                return FALSE;
            }
            
            f = CryptEncodeObjectEx(X509_ASN_ENCODING,
                                    szOID_SMIME_Receipt_Request, &receipt,
                                    CRYPT_ENCODE_ALLOC_FLAG, NULL, &pb, &cb);
    

            free(receipt.ReceiptsFrom.rgNames);
            free(receipt.rgReceiptsTo);
            if (!f) return FALSE;
            
            psd->SetReceiptData(pb, cb);
            
            // 
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\reg.h ===
#define CCH_OPTION_STRING   (MAX_PATH + 1)

extern void SaveOptions(void);
extern void GetOptions(void);
extern void CleanupOptions(void);
extern BOOL OptionsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

DWORD RegGetLong(HKEY hKey, LPTSTR szName, ULONG * plData);
DWORD RegGetBinary(HKEY hKey, LPTSTR szName, LPBYTE * ppData, ULONG * lpcbData);
DWORD RegSaveLong(HKEY hKey, LPTSTR szName, ULONG lData);
DWORD RegSaveBinary(HKEY hKey, LPTSTR szName, LPBYTE pData, ULONG cbData);


extern TCHAR szSenderEmail[];
extern TCHAR szSenderName[];
extern SBinary SenderEntryID;
extern TCHAR szRecipientEmail[];
extern TCHAR szRecipientName[];
extern SBinary RecipientEntryID;
extern TCHAR szOutputFile[];
extern TCHAR szInputFile[];
extern CRYPT_HASH_BLOB SignHash;
extern DWORD                    CMyNames;
extern PCERT_NAME_BLOB          RgMyNames;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\sign.h ===
BOOL CALLBACK SignDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SignDataReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SignInfoDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\reg.cpp ===
/*
 * REG.c  Registry functions
 *
 */

#include <windows.h>
#include <cryptdlg.h>
#include <wab.h>
#include "demand.h"
#include "data.h"
#include "reg.h"
#include "smimetst.h"
#include "receipt.h"


// Options
TCHAR szSenderEmail[CCH_OPTION_STRING] = "";
TCHAR szSenderName[CCH_OPTION_STRING]  = "";
SBinary SenderEntryID = {0};
TCHAR szRecipientEmail[CCH_OPTION_STRING]  = "";
TCHAR szRecipientName[CCH_OPTION_STRING]  = "";
SBinary RecipientEntryID = {0};
TCHAR szOutputFile[CCH_OPTION_STRING]  = "c:\\SMimeTst.eml";
TCHAR szInputFile[CCH_OPTION_STRING]  = "";
CRYPT_HASH_BLOB SignHash = {0, NULL};
DWORD                   CMyNames = 0;
PCERT_NAME_BLOB         RgMyNames = {0};


const TCHAR szRegKey[] = "Software\\Microsoft\\SMimeTest";

DWORD SaveMailListKeys(HKEY);
DWORD GetMailListKeys(HKEY);


DWORD RegSaveLong(HKEY hKey, LPTSTR szName, ULONG lData) {
    DWORD dwErr;

    dwErr = RegSetValueEx(hKey, szName, 0, REG_DWORD, (LPBYTE)&lData, sizeof(lData));

    return(dwErr);
}

DWORD RegSaveShort(HKEY hKey, LPTSTR szName, USHORT sData) {
    return(RegSaveLong(hKey, szName, (ULONG)sData));
}

DWORD RegSaveBinary(HKEY hKey, LPTSTR szName, LPBYTE pData, ULONG cbData) {
    DWORD dwErr;

    dwErr = RegSetValueEx(hKey, szName, 0, REG_BINARY, pData, cbData);

    return(dwErr);
}

DWORD RegSaveString(HKEY hKey, LPTSTR szName, LPTSTR pszData) {
    DWORD dwErr;

    dwErr = RegSetValueEx(hKey, szName, 0, REG_SZ, (LPBYTE)pszData, lstrlen(pszData) + 1);

    return(dwErr);
}


DWORD RegGetShort(HKEY hKey, LPTSTR szName, USHORT * psData) {
    DWORD dwData = 0;
    DWORD cbData = sizeof(dwData);
    DWORD dwErr;
    DWORD dwType = 0;

    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, (LPBYTE)&dwData, &cbData);

    *psData = (USHORT)dwData;

    return(dwErr);
}

DWORD RegGetLong(HKEY hKey, LPTSTR szName, ULONG * plData) {
    DWORD dwErr;
    DWORD cbData = sizeof(*plData);
    DWORD dwType = 0;

    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, (LPBYTE)plData, &cbData);

    return(dwErr);
}


DWORD RegGetBinary(HKEY hKey, LPTSTR szName, LPBYTE * ppData, ULONG * lpcbData) {
    DWORD dwErr;
    DWORD dwType = 0;
    DWORD cbData = 0;
    LPBYTE pData = NULL;

    if (*ppData) {
        LocalFree(*ppData);
        *ppData = NULL;
        *lpcbData = 0;
    }
    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, pData, &cbData);
    if ((dwErr == ERROR_SUCCESS) && (cbData > 0)) {
        pData = (LPBYTE)LocalAlloc(LPTR, cbData);
        *lpcbData = cbData;
        dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, pData, lpcbData);
        *ppData = pData;
    }

    return(dwErr);
}

DWORD RegGetString(HKEY hKey, LPTSTR szName, LPTSTR pszData) {
    DWORD dwErr;
    DWORD dwType = 0;
    DWORD cbData = CCH_OPTION_STRING;
    TCHAR szExpanded[CCH_OPTION_STRING];

    dwErr = RegQueryValueEx(hKey, szName, 0, &dwType, (LPBYTE)pszData, &cbData);
    if ((REG_EXPAND_SZ == dwType) && (cbData > 0)) {
        ExpandEnvironmentStrings(pszData, szExpanded, cbData);
        lstrcpy(pszData, szExpanded);
    }
    return(dwErr);
}

void SaveOptions(void) {
    HKEY hKey = NULL;
    DWORD dwErr;
    DWORD dwDisposition;

    if (! (dwErr = RegCreateKeyEx(HKEY_CURRENT_USER, szRegKey, 0, NULL, 0, KEY_WRITE, NULL, &hKey, &dwDisposition))) {
        RegSaveString(hKey, "Sender Email", szSenderEmail);
        RegSaveString(hKey, "Sender Name", szSenderName);
        if (SenderEntryID.lpb) {
            RegSaveBinary(hKey, "Sender EntryID", (LPBYTE)SenderEntryID.lpb, SenderEntryID.cb);
        } else {
            RegDeleteValue(hKey, "Sender EntryID");
        }
        RegSaveString(hKey, "Recipient Email", szRecipientEmail);
        RegSaveString(hKey, "Recipient Name", szRecipientName);
        if (RecipientEntryID.lpb) {
            RegSaveBinary(hKey, "Recipient EntryID", (LPBYTE)RecipientEntryID.lpb, RecipientEntryID.cb);
        } else {
            RegDeleteValue(hKey, "Recipient EntryID");
        }
        RegSaveString(hKey, "Output File", szOutputFile);
        RegSaveString(hKey, "Input File", szInputFile);

        RegSaveBinary(hKey, "Signing Hash", SignHash.pbData, SignHash.cbData);

        if (CMyNames > 0) {
            CRYPT_SEQUENCE_OF_ANY       any = {CMyNames, RgMyNames};
            DWORD                       cb;
            BOOL                        f;
            LPBYTE                      pb;
            
            f = CryptEncodeObjectEx(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                                    &any, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pb, &cb);
            RegSaveBinary(hKey, "My Names", pb, cb);
            LocalFree(pb);
        }
        else {
            RegDeleteValue(hKey, "My Names");
        }

        SaveMailListKeys(hKey);
        RegCloseKey(hKey);
    }
}

void GetOptions(void) {
    HKEY hKey = NULL;
    DWORD dwErr;

    if (! (dwErr = RegOpenKeyEx(HKEY_CURRENT_USER, szRegKey, 0, KEY_READ, &hKey))) {
        RegGetString(hKey, "Sender Email", szSenderEmail);
        RegGetString(hKey, "Sender Name", szSenderName);
        RegGetBinary(hKey, "Sender EntryID", &SenderEntryID.lpb, &SenderEntryID.cb);
        RegGetString(hKey, "Recipient Email", szRecipientEmail);
        RegGetString(hKey, "Recipient Name", szRecipientName);
        RegGetBinary(hKey, "Recipient EntryID", &RecipientEntryID.lpb, &RecipientEntryID.cb);
        RegGetString(hKey, "Output File", szOutputFile);
        RegGetString(hKey, "Input File", szInputFile);

        RegGetBinary(hKey, "Signing Hash", &SignHash.pbData, &SignHash.cbData);

        {
            DWORD                       cb = 0;
            PCRYPT_SEQUENCE_OF_ANY      pany;
            LPBYTE                      pb = NULL;
            
            RegGetBinary(hKey, "My Names", &pb, &cb);

            if (cb > 0) {
                CryptDecodeObjectEx(X509_ASN_ENCODING, X509_SEQUENCE_OF_ANY,
                                    pb, cb, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pany, &cb);
                RgMyNames = (PCERT_NAME_BLOB) LocalAlloc(0, cb);
                memcpy(RgMyNames, pany->rgValue, cb);
                CMyNames = pany->cValue;
                LocalFree(pany);
            }
            if (pb != NULL)             LocalFree(pb);
        }

        GetMailListKeys(hKey);
        RegCloseKey(hKey);
    }
}


void CleanupOptions(void) {
    if (SenderEntryID.lpb) {
        LocalFree(SenderEntryID.lpb);
        SenderEntryID.lpb = NULL;
    }
    if (RecipientEntryID.lpb) {
        LocalFree(RecipientEntryID.lpb);
        RecipientEntryID.lpb = NULL;
    }
    if (RgMyNames != NULL) {
        LocalFree(RgMyNames);
        RgMyNames = 0;
    }
}

////    OptionsDlgProc
//
//  Description:  This is the dialog proc function which controls the preset
//      options for a user.  These options are stored in the registry code and
//      are on a per-user basis.
//

BOOL OptionsDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    PCCERT_CONTEXT      pccert;
    char                rgch[256];
    
    switch (message) {
    case WM_INITDIALOG:
        // Fill in the fields from the options
        SetDlgItemText(hwnd, IDC_SENDER_EMAIL, szSenderEmail);
        //            SetDlgItemText(hwnd, IDC_SENDER_NAME, szSenderName);
        SetDlgItemText(hwnd, IDC_RECIPIENT_EMAIL, szRecipientEmail);
        //            SetDlgItemText(hwnd, IDC_RECIPIENT_NAME, szRecipientName);
        if (HCertStoreMy == NULL) {
            HCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                         NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                         L"MY");
            if (HCertStoreMy == NULL) {
                break;
            }
        }
        if (SignHash.cbData != 0) {
            pccert = CertFindCertificateInStore(HCertStoreMy,
                                                X509_ASN_ENCODING, 0,
                                                CERT_FIND_SHA1_HASH,
                                                &SignHash, NULL);
            GetFriendlyNameOfCertA(pccert, rgch, sizeof(rgch));
            SetDlgItemText(hwnd, IDC_O_CERT_NAME, rgch);
            CertFreeCertificateContext(pccert);
        }
        if (CMyNames > 0) {
            FormatNames(CMyNames, RgMyNames, hwnd, IDC_O_MY_NAMES);
        }
        break;

    case WM_COMMAND :
        switch (wParam) {
        case IDOK:
            GetDlgItemText(hwnd, IDC_SENDER_EMAIL, szSenderEmail, CCH_OPTION_STRING);
            //                GetDlgItemText(hwnd, IDC_SENDER_NAME, szSenderName, CCH_OPTION_STRING);
            GetDlgItemText(hwnd, IDC_RECIPIENT_EMAIL, szRecipientEmail, CCH_OPTION_STRING);
            //                GetDlgItemText(hwnd, IDC_RECIPIENT_NAME, szRecipientName, CCH_OPTION_STRING);
            if (!ParseNames(&CMyNames, &RgMyNames, hwnd, IDC_O_MY_NAMES)) {
                return FALSE;
            }
            EndDialog(hwnd, 0);
            break;

        case IDC_O_CERT_CHOOSE:
            pccert = NULL;
            if (SignHash.cbData != 0) {
                pccert = CertFindCertificateInStore(HCertStoreMy,
                                                    X509_ASN_ENCODING, 0,
                                                    CERT_FIND_SHA1_HASH,
                                                    &SignHash, NULL);
            }
            if (DoCertDialog(hwnd, "Choose Signature Certificate",
                             HCertStoreMy, &pccert, FILTER_NONE)) {
                SignHash.pbData = RgbSignHash;
                SignHash.cbData = sizeof(RgbSignHash);
                CertGetCertificateContextProperty(pccert, CERT_SHA1_HASH_PROP_ID,
                                                  SignHash.pbData,
                                                  &SignHash.cbData);
                GetFriendlyNameOfCertA(pccert, rgch, sizeof(rgch));
                SetDlgItemText(hwnd, IDC_O_CERT_NAME, rgch);
            }

            CertFreeCertificateContext(pccert);
            break;

        default:
            return(FALSE);
        }
        break ;

    default:
        return(FALSE);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smtpcall.h ===
// --------------------------------------------------------------------------------
// Smtpcall.h
// --------------------------------------------------------------------------------
#ifndef __SMTPCALL_H
#define __SMTPCALL_H
#include "imnxport.h"

HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP);

// --------------------------------------------------------------------------------
// CSMTPCallback Implementation
// --------------------------------------------------------------------------------
class CSMTPCallback : public ISMTPCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPCallback(void);
    ~CSMTPCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // ISMTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPSMTPRESPONSE              pResponse);
};

#endif // __SMTPCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\sign.cpp ===
#include "item.h"

#define MAX_LAYERS      30
extern HINSTANCE        hInst;

extern const BYTE RgbSHA1AlgId[] =
      {0x30, 0x09, 0x30, 0x07, 0x06, 0x05, 0x2B, 0x0E,
       0x03, 0x02, 0x1A};
extern const int  CbSHA1AlgId = sizeof(RgbSHA1AlgId);

byte RgbEntityId1[] = {0x1, 0x4, 0x7, 0x8, 0x10};
byte RgbEntityId2[] = {0x1, 0x4, 0x7, 0x10, 0x8};

const char      SzPolicyRoot[] = "Software\\Microsoft\\Cryptography\\OID\\EncodingType 1\\SMimeSecurityLabel";
//const char      SzPolicyRoot[] = "Software\\Microsoft\\Cryptography\\SMIME\\SecurityPolicies";

class CSecurityPolicy {
public:
    DWORD               dwFlags;
    char *              szDllName;
    char *              szPolicyOID;
    char *              szFuncName;
    HMODULE             hmod;
    PFNGetSMimePolicy   pfnFuncName;
    ISMimePolicySimpleEdit *      ppolicy;

    CSecurityPolicy() {
        szDllName = szPolicyOID = szFuncName = NULL;
        hmod = 0;
        pfnFuncName = NULL;
        ppolicy = NULL;
        dwFlags = 0;
    }

    ~CSecurityPolicy() {
        free(szDllName);
        free(szPolicyOID);
        free(szFuncName);
        if (ppolicy != NULL)    ppolicy->Release();
        FreeLibrary(hmod);
    }
};

////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK MLDataCreateDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       cb;
    DWORD                       cb2;
    BOOL                        f;
    SMIME_ML_EXPANSION_HISTORY  mlHistory;
    LPBYTE                      pb;
    PSMIME_ML_EXPANSION_HISTORY pMLHistory;
    static PCCERT_CONTEXT       pccert1 = NULL;
    static PCCERT_CONTEXT       pccert2 = NULL;
    static CSignData *          psd = NULL;
    char                        rgch[256];
    SMIME_MLDATA                rgMLData[5];
    
    switch (msg) {
    case WM_INITDIALOG:
        pccert1 = NULL;
        pccert2 = NULL;
        psd = (CSignData *) lParam;
#if 0
        psd->GetMLHistory(&pb, &cb);
        if (cb > 0) {
            f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_MLExpansion_History,
                                    pb, cb, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pMLHistory, &cb2);
        }
#endif // 0
        break;
        
    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_MLC_SELECT1, BN_CLICKED):
            if (DoCertDialog(hdlg, "Choose ML Data Certificate",
                             psd->GetMyStore(), &pccert1,
                             FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(pccert1, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_MLC_CERT1, rgch);
            }
            break;
            
        case MAKELONG(IDC_MLC_SELECT2, BN_CLICKED):
            if (DoCertDialog(hdlg, "Choose ML Data Certificate",
                             psd->GetMyStore(), &pccert2,
                             FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(pccert2, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_MLC_CERT2, rgch);
            }
            break;
            
        case MAKELONG(IDC_MLC_ABSENT1, BN_CLICKED):
        case MAKELONG(IDC_MLC_NONE1, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES1), FALSE);
            break;

        case MAKELONG(IDC_MLC_INSTEAD1, BN_CLICKED):
        case MAKELONG(IDC_MLC_ALSO1, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES1), TRUE);
            break;
            
        case MAKELONG(IDC_MLC_ABSENT2, BN_CLICKED):
        case MAKELONG(IDC_MLC_NONE2, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES2), FALSE);
            break;

        case MAKELONG(IDC_MLC_INSTEAD2, BN_CLICKED):
        case MAKELONG(IDC_MLC_ALSO2, BN_CLICKED):
            EnableWindow(GetDlgItem(hdlg, IDC_MLC_NAMES2), TRUE);
            break;
            
        case IDOK:
            memset(&mlHistory, 0, sizeof(mlHistory));
            memset(rgMLData, 0, sizeof(rgMLData));

            mlHistory.cMLData = 0;
            mlHistory.rgMLData = rgMLData;
            
            mlHistory.cMLData = 1;

            if (pccert1 == NULL) {
                break;
            }

            if (SendDlgItemMessage(hdlg, IDC_MLC_ID1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwChoice = SMIME_MLDATA_SUBJECT_KEY_IDENTIFIER;
                rgMLData[0].SubjectKeyIdentifier.cbData = sizeof(RgbEntityId1);
                rgMLData[0].SubjectKeyIdentifier.pbData = RgbEntityId1;
            }
            else {
                rgMLData[0].dwChoice = SMIME_MLDATA_ISSUER_SERIAL_NUMBER;
                rgMLData[0].u.SerialNumber = pccert1->pCertInfo->SerialNumber;
                rgMLData[0].u.Issuer = pccert1->pCertInfo->Issuer;
            }

            GetSystemTimeAsFileTime(&rgMLData[0].ExpansionTime);
            
            if (SendDlgItemMessage(hdlg, IDC_MLC_ABSENT1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_NO_CHANGE;
            }
            else if (SendDlgItemMessage(hdlg, IDC_MLC_NONE1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_NONE;
            }
            else if (SendDlgItemMessage(hdlg, IDC_MLC_INSTEAD1, BM_GETCHECK, 0, 0)) {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_INSTEAD_OF;
                if (!ParseNames(&rgMLData[0].cNames, &rgMLData[0].rgNames,
                                hdlg, IDC_MLC_NAMES1)) {
                    return FALSE;
                }
            }
            else {
                rgMLData[0].dwPolicy = SMIME_MLPOLICY_IN_ADDITION_TO;
                if (!ParseNames(&rgMLData[0].cNames, &rgMLData[0].rgNames,
                                hdlg, IDC_MLC_NAMES1)) {
                    return FALSE;
                }
            }

            if (SendDlgItemMessage(hdlg, IDC_MLC_INCLUDE2, BM_GETCHECK, 0, 0)) {
                mlHistory.cMLData = 2;

                if (pccert2 == NULL) {
                    break;
                }

                if (SendDlgItemMessage(hdlg, IDC_MLC_ID2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwChoice = SMIME_MLDATA_SUBJECT_KEY_IDENTIFIER;
                    rgMLData[1].SubjectKeyIdentifier.cbData = sizeof(RgbEntityId2);
                    rgMLData[1].SubjectKeyIdentifier.pbData = RgbEntityId2;
                }
                else {
                    rgMLData[1].dwChoice = SMIME_MLDATA_ISSUER_SERIAL_NUMBER;
                    rgMLData[1].u.SerialNumber = pccert2->pCertInfo->SerialNumber;
                    rgMLData[1].u.Issuer = pccert2->pCertInfo->Issuer;
                }

                GetSystemTimeAsFileTime(&rgMLData[1].ExpansionTime);
            
                if (SendDlgItemMessage(hdlg, IDC_MLC_ABSENT2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_NO_CHANGE;
                }
                else if (SendDlgItemMessage(hdlg, IDC_MLC_NONE2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_NONE;
                }
                else if (SendDlgItemMessage(hdlg, IDC_MLC_INSTEAD2, BM_GETCHECK, 0, 0)) {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_INSTEAD_OF;
                    if (!ParseNames(&rgMLData[1].cNames, &rgMLData[1].rgNames,
                                    hdlg, IDC_MLC_NAMES2)) {
                        return FALSE;
                    }
                }
                else {
                    rgMLData[1].dwPolicy = SMIME_MLPOLICY_IN_ADDITION_TO;
                    if (!ParseNames(&rgMLData[1].cNames, &rgMLData[1].rgNames,
                                    hdlg, IDC_MLC_NAMES2)) {
                        return FALSE;
                    }
                }
            }

            f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_MLExpansion_History,
                                    &mlHistory, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                    &pb, &cb);
            if (!f) return FALSE;
            
            psd->SetMLHistory(pb, cb);
            
        case IDCANCEL:
            CertFreeCertificateContext(pccert1);
            CertFreeCertificateContext(pccert2);
            EndDialog(hdlg, wParam);
            break;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////

void InitPolicies(HWND hdlg, DWORD idc1, DWORD idc2, DWORD idc3, DWORD idc4)
{
    DWORD       cbData;
    DWORD       cbMaxData;
    DWORD       cval;
    DWORD       dw;
    FILETIME    ft;
    HKEY        hkey;
    HKEY        hkey2;
    DWORD       i;
    DWORD       i1;
    DWORD       iSel;
    CSecurityPolicy * p;
    char *      pbData = NULL;
    char        rgch[256];

    if (RegOpenKey(HKEY_LOCAL_MACHINE, SzPolicyRoot, &hkey)) {
        return;
    }

    for (i=0; TRUE; i++) {
        cbData =sizeof(rgch);
        dw = RegEnumKeyEx(hkey, i, rgch, &cbData, NULL, NULL, NULL, &ft);
        if (dw != ERROR_SUCCESS) {
            break;
        }

        dw = RegOpenKey(hkey, rgch, &hkey2);

        dw = RegQueryInfoKey(hkey2, NULL, NULL, NULL, NULL, NULL, NULL, &cval,
                             NULL, &cbMaxData, NULL, NULL);

        pbData = (LPSTR) malloc(cbMaxData);

        p = new CSecurityPolicy;

        p->szPolicyOID = _strdup(rgch);

        cbData = cbMaxData;
        dw = RegQueryValueEx(hkey2, "DllPath", NULL, &dw, (LPBYTE) pbData, &cbData);
        p->szDllName = _strdup(pbData);

        dw = RegQueryValueEx(hkey2, "FuncName", NULL, &dw, (LPBYTE) pbData, &cbData);
        if (*pbData != 0) {
            p->szFuncName = _strdup(pbData);
        }

        cbData = cbMaxData;
        dw = RegQueryValueEx(hkey2, "CommonName", NULL, &dw, (LPBYTE) pbData, &cbData);
            
        iSel = SendDlgItemMessage(hdlg, idc1, CB_ADDSTRING, 0, (LPARAM) pbData);
        Assert(iSel != CB_ERR);
        if (iSel == CB_ERR) {
            continue;
        }

        SendDlgItemMessage(hdlg, idc1, CB_SETITEMDATA, iSel, (LPARAM) p);

        free(pbData);   pbData = NULL;

        RegCloseKey(hkey2);     hkey2 = NULL;
    }

    //exit:
    if (pbData != NULL)         free(pbData);
    if (hkey != NULL)           RegCloseKey(hkey);
    if (hkey2 != NULL)          RegCloseKey(hkey2);
}

void PolicyFillClassifications(HWND hwnd, DWORD idc1, DWORD idc2, DWORD idc3,
                               DWORD dw)
{
    DWORD                       cb;
    DWORD                       cbEncode;
    DWORD                       cbMax;
    DWORD                       cClassifications = 0;
    DWORD                       cval;
    DWORD                       dwValue;
    DWORD                       dwDefaultClassification;
    HRESULT                     hr;
    DWORD                       i;
    int                         iSel;
    DWORD                       iSetSel;
    CSecurityPolicy *           p;
    LPBYTE                      pbEncode;
    DWORD *                     pdwClassifications = NULL;
    LPWSTR *                    pwszClassifications = NULL;
    WCHAR                       rgwch[256];
    
    iSel = SendDlgItemMessage(hwnd, IDC_SD_POLICY, CB_GETCURSEL, 0, 0);
    p = (CSecurityPolicy *) SendDlgItemMessage(hwnd, idc1, CB_GETITEMDATA,
                                               iSel, 0);
    if (((int) p) == CB_ERR) {
        return;
    }
    
    if (p->hmod == NULL) {
        p->hmod = LoadLibrary(p->szDllName);
        if (p->hmod == NULL) {
            return;
        }
    }

    if (p->pfnFuncName == NULL) {
        p->pfnFuncName = (PFNGetSMimePolicy) GetProcAddress(p->hmod, p->szFuncName);
        if (p->pfnFuncName == NULL) {
            return;
        }
    }

    if (p->ppolicy == NULL) {
        p->pfnFuncName(0, p->szPolicyOID, 1252, IID_ISMimePolicySimpleEdit,
                       (LPUNKNOWN *) &p->ppolicy);
    }

    p->ppolicy->GetPolicyInfo(0, &p->dwFlags);

    // get the classification information.
    hr = p->ppolicy->GetClassifications(0, &cClassifications, &pwszClassifications,
                                        &pdwClassifications, 
                                        &dwDefaultClassification);
    if (FAILED(hr)) {
        goto Error;    
    }

    
    SendDlgItemMessage(hwnd, idc2, CB_RESETCONTENT, 0, 0);
    for (i=0, iSetSel = 0; i<cClassifications; i++) {
        iSel = SendDlgItemMessageW(hwnd, idc2, CB_ADDSTRING, 0, (LPARAM) pwszClassifications[i]);
        SendDlgItemMessage(hwnd, idc2, CB_SETITEMDATA, iSel, pdwClassifications[i]);
        if (dwDefaultClassification == pdwClassifications[i]) {
            iSetSel = i;
        }
    }
    SendDlgItemMessage(hwnd, idc2, CB_SETCURSEL, iSetSel, 0);

    EnableWindow(GetDlgItem(hwnd, idc3), !!(p->dwFlags & SMIME_POLICY_EDIT_UI));
Error:
    return;
}


BOOL CALLBACK SignInfoDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static CSignInfo *          psi = NULL;

    switch (msg) {
    case UM_SET_DATA:
        psi = (CSignInfo *) lParam;

        SendDlgItemMessage(hdlg, IDC_SI_BLOB_SIGN, BM_SETCHECK,
                           ((psi != NULL) && (psi->m_fBlob)), 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case MAKELONG(IDC_SI_BLOB_SIGN, BN_CLICKED):
            psi->m_fBlob = SendDlgItemMessage(hdlg, IDC_SI_BLOB_SIGN,
                                              BM_GETCHECK, 0, 0);
            return FALSE;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


BOOL CALLBACK SignDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       c;
    DWORD                       cb;
    DWORD                       cbEncode;
    DWORD                       cch;
    DWORD                       dw;
    BOOL                        f;
    DWORD                       i;
    CSecurityPolicy *           p;
    LPBYTE                      pb;
    LPBYTE                      pbEncode;
    SMIME_SECURITY_LABEL *      plabel;
    static CSignData *          psd = NULL;
    LPWSTR                      psz;
    CHAR                        rgch[300];

    switch (msg) {
    case WM_INITDIALOG:
        InitPolicies(hdlg, IDC_SD_POLICY, IDC_SD_CLASSIFICATION,
                     IDC_SD_PRIVACY_MARK, IDC_SD_ADVANCED);
        SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_SETCURSEL, 0, 0);
        PolicyFillClassifications(hdlg, IDC_SD_POLICY, IDC_SD_CLASSIFICATION,
                                  IDC_SD_ADVANCED, 0);
        break;

    case UM_SET_DATA:
        // Need to extract and build a security label
        if (psd != NULL) {
            if (SendDlgItemMessage(hdlg, IDC_SD_LABEL, BM_GETCHECK, 0, 0)) {
                DWORD                           dw;
                DWORD                           iSel;
                SMIME_SECURITY_LABEL            label = {0};
                CSecurityPolicy *               p;
                WCHAR                           rgwch[255];
                
                iSel = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCURSEL, 0, 0);
                p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                           CB_GETITEMDATA, iSel, 0);
                iSel = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETCURSEL,
                                          0, 0);
                dw = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETITEMDATA,
                                        iSel, 0);
                rgwch[0] = 0;
                GetDlgItemTextW(hdlg, IDC_SD_PRIVACY_MARK, rgwch, sizeof(rgwch)/2);

                label.pszObjIdSecurityPolicy = p->szPolicyOID;
                if (dw == -1) {
                    label.fHasClassification = FALSE;
                }
                else {
                    label.fHasClassification = TRUE;
                    label.dwClassification = dw;
                }
                if (rgwch[0] != 0) {
                    label.wszPrivacyMark = rgwch;
                }
                else {
                    label.wszPrivacyMark = NULL;
                }
                
                label.cCategories = 0;

                f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                        &label, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                        &pbEncode, &cbEncode);
                Assert(f);

                psd->SetLabel(pbEncode, cbEncode);
                LocalFree(pbEncode);
            }
        }
        
        //  Fill in the dialog
        psd = (CSignData *) lParam;

        if ((psd != NULL) && (psd->m_pccert != NULL)) {
            GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
            SetDlgItemText(hdlg, IDC_SD_CERT_NAME, rgch);
        }
        else {
            SetDlgItemText(hdlg, IDC_SD_CERT_NAME, "");
        }

        SendDlgItemMessage(hdlg, IDC_SD_RECEIPT, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fReceipt)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_USE_SKI, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fUseSKI)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_MLDATA, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fMLHistory)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_AUTHATTRIB, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fAuthAttrib)), 0);

        SendDlgItemMessage(hdlg, IDC_SD_UNAUTHATTRIB, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fUnAuthAttrib)), 0);

        if (psd != NULL) {
            psd->GetLabel(&pbEncode, &cbEncode);
            SendDlgItemMessage(hdlg, IDC_SD_LABEL, BM_SETCHECK, (cbEncode > 0), 0);
            c = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCOUNT, 0, 0);
            if (cbEncode > 0) {
                f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                        pbEncode, cbEncode, CRYPT_ENCODE_ALLOC_FLAG,
                                        NULL, &plabel, &cb);
                Assert(f);

                for (i=0; i<c; i++) {
                    p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                               CB_GETITEMDATA, i, 0);
                    if (strcmp(p->szPolicyOID, plabel->pszObjIdSecurityPolicy) == 0) {
                        break;
                    }
                }

                Assert(i<c);
                if (i<c) {
                    SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_SETCURSEL, i, 0);
                    PolicyFillClassifications(hdlg, IDC_SD_POLICY,
                                              IDC_SD_CLASSIFICATION,
                                              IDC_SD_ADVANCED,
                                              plabel->dwClassification);
                }
            
                LocalFree(plabel);
            }
            else {
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_SD_CERT_CHOOSE:
            if (DoCertDialog(hdlg, "Choose Signing Certificate", psd->GetMyStore(),
                             &psd->m_pccert, FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_SD_CERT_NAME, rgch);
            }
            break;

        case MAKELONG(IDC_SD_RECEIPT, BN_CLICKED):
            psd->m_fReceipt = SendDlgItemMessage(hdlg, IDC_SD_RECEIPT, BM_GETCHECK,
                                                 0, 0);
            return FALSE;

        case MAKELONG(IDC_SD_USE_SKI, BN_CLICKED):
            psd->m_fUseSKI = SendDlgItemMessage(hdlg, IDC_SD_USE_SKI, BM_GETCHECK,
                                                0, 0);
            return FALSE;

        case IDC_SD_DO_RECEIPT:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_RECEIPT_CREATE), hdlg,
                           ReceiptCreateDlgProc, (LPARAM) psd);
            break;

        case IDC_SD_ADVANCED:
            //  Query the list to get the policy module descriptor
            i = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCURSEL, 0, 0);
            p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                       CB_GETITEMDATA, i, 0);

            //  Query the classification within the policy module
            i = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETCURSEL,
                                   0, 0);
            dw = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETITEMDATA,
                                    i, 0);

            //  Query back the privacy mark within the policy mark.
            cch = SendDlgItemMessage(hdlg, IDC_SD_PRIVACY_MARK, WM_GETTEXTLENGTH, 0, 0);
            if (cch > 0) {
                psz = (LPWSTR) LocalAlloc(0, cch);
                *psz = 0;
                SendDlgItemMessageW(hdlg, IDC_SD_PRIVACY_MARK, WM_GETTEXT, cch, (LPARAM) psz);
            }
            else {
                psz = NULL;
            }

            //  If we already have a security label on this object, grab it.
            psd->GetLabel(&pb, &cb);
            if (cb > 0) {
                pbEncode = (LPBYTE) LocalAlloc(0, cb);
                memcpy(pbEncode, pb, cb);
            }
            else {
                pbEncode = NULL;
            }

#if 0
            //  Now call the advanced UI to see what it wants to do.  It will return an
            //  new receipt and we go from there
            if (p->ppolicy->EditUI(hdlg, &dw, &psz, &pbEncode, &cb) == S_OK) {
                
                // Put the label back on our object.
                psd->SetLabel(pbEncode, cb);

                //  Put back the classification
                c = SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_GETCOUNT, 0, 0);
                for (i=0; i<c; i++) {
                    if (dw == (DWORD) SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION,
                                                         CB_GETITEMDATA, i, 0)) {
                        SendDlgItemMessage(hdlg, IDC_SD_CLASSIFICATION, CB_SETCURSEL, i, 0);
                        break;
                    }
                }

                //  Put back the privacy mark
                if (psz != NULL) {
                    SetDlgItemTextW(hdlg, IDC_SD_PRIVACY_MARK, psz);
                    LocalFree(psz);
                }
                else {
                    SetDlgItemTextW(hdlg, IDC_SD_PRIVACY_MARK, L"");
                }
            }
#endif // 0

            //  Free the label as encoded, we have already saved it.
            if (pbEncode != NULL) {
                LocalFree(pbEncode);
            }
            break;

        case MAKELONG(IDC_SD_MLDATA, BN_CLICKED):
            psd->m_fMLHistory = SendDlgItemMessage(hdlg, IDC_SD_MLDATA, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_SD_DO_MLDATA:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_MLDATA_CREATE), hdlg,
                           MLDataCreateDlgProc, (LPARAM) psd);
            break;

        case MAKELONG(IDC_SD_AUTHATTRIB, BN_CLICKED):
            psd->m_fAuthAttrib = SendDlgItemMessage(hdlg, IDC_SD_AUTHATTRIB, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_SD_DO_AUTHATTRIB:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ATTRIB_CREATE), hdlg,
                           AuthAttribCreateDlgProc, (LPARAM) psd);
            break;

        case MAKELONG(IDC_SD_UNAUTHATTRIB, BN_CLICKED):
            psd->m_fUnAuthAttrib = SendDlgItemMessage(hdlg, IDC_SD_UNAUTHATTRIB, BM_GETCHECK,
                                                   0, 0);
            break;
            
        case IDC_SD_DO_UNAUTHATTRIB:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ATTRIB_CREATE), hdlg,
                           UnAuthAttribCreateDlgProc, (LPARAM) psd);
            break;

        default:
            return FALSE;
        }
        break;
        

    case WM_DESTROY:
        c = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCOUNT, 0, 0);
        for (i=0; i <c; i++) {
            p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                       CB_GETITEMDATA, i, 0);
            delete p;
        }
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CALLBACK SignDataReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD                       c;
    DWORD                       cb;
    DWORD                       cbEncode;
    BOOL                        f;
    DWORD                       i;
    CSecurityPolicy *           p;
    LPBYTE                      pbEncode;
    SMIME_SECURITY_LABEL *      plabel;
    static CSignData *          psd = NULL;
    CHAR                        rgch[300];

    switch (msg) {
    case WM_INITDIALOG:
        break;

    case UM_SET_DATA:
        //  Fill in the dialog
        psd = (CSignData *) lParam;

        if ((psd != NULL) && (psd->m_pccert != NULL)) {
            GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
            SetDlgItemText(hdlg, IDC_SDR_CERT_NAME, rgch);
        }
        else {
            SetDlgItemText(hdlg, IDC_SDR_CERT_NAME, "");
        }

        SendDlgItemMessage(hdlg, IDC_SDR_RECEIPT, BM_SETCHECK,
                           ((psd != NULL) && (psd->m_fReceipt)), 0);

        if (psd != NULL) {
            psd->GetLabel(&pbEncode, &cbEncode);
            SendDlgItemMessage(hdlg, IDC_SD_LABEL, BM_SETCHECK, (cbEncode > 0), 0);
            if (cbEncode > 0) {
                f = CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_Security_Label,
                                        pbEncode, cbEncode, CRYPT_ENCODE_ALLOC_FLAG,
                                        NULL, &plabel, &cb);
                Assert(f);

                c = SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_GETCOUNT, 0, 0);
                for (i=0; i<c; i++) {
                    p = (CSecurityPolicy *) SendDlgItemMessage(hdlg, IDC_SD_POLICY,
                                                               CB_GETITEMDATA, i, 0);
                    if (strcmp(p->szPolicyOID, plabel->pszObjIdSecurityPolicy) == 0) {
                        break;
                    }
                }
                if (i<c) {
                    SendDlgItemMessage(hdlg, IDC_SD_POLICY, CB_SETCURSEL, i, 0);
                    PolicyFillClassifications(hdlg, IDC_SD_POLICY,
                                              IDC_SD_CLASSIFICATION,
                                              IDC_SD_ADVANCED,
                                              plabel->dwClassification);
                }
		else {
		    SetDlgItemText(hdlg, IDC_SDR_POLICY, plabel->pszObjIdSecurityPolicy);
                    SetDlgItemInt(hdlg, IDC_SDR_CLASSIFICATION, plabel->dwClassification, TRUE);
		}
            
                LocalFree(plabel);
            }
            else {
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_SD_CERT_CHOOSE:
            if (DoCertDialog(hdlg, "Choose Signing Certificate", psd->GetMyStore(),
                             &psd->m_pccert, FILTER_RSA_SIGN | FILTER_DSA_SIGN)) {
                GetFriendlyNameOfCertA(psd->m_pccert, rgch, sizeof(rgch));
                SetDlgItemText(hdlg, IDC_SD_CERT_NAME, rgch);
            }
            break;

        case MAKELONG(IDC_SD_RECEIPT, BN_CLICKED):
            psd->m_fReceipt = SendDlgItemMessage(hdlg, IDC_SD_RECEIPT, BM_GETCHECK,
                                                 0, 0);
            return FALSE;

        case IDC_SD_DO_RECEIPT:
            // Dialog for button
            break;

        case IDM_VALIDATE:
            if (psd->m_pccert != NULL) {
                DWORD   dw;
                HCERTSTORE      hstore = NULL;
                HrValidateCert(psd->m_pccert, NULL, NULL, &hstore, &dw);
                if (hstore != NULL)
                    if (!CertCloseStore(hstore, CERT_CLOSE_STORE_CHECK_FLAG)) {
                        AssertSz(FALSE, "Store did not close");
                    }
            }
            break;

        default:
            return FALSE;
        }
        break;
        
    default:
        return FALSE;
    }

    return TRUE;
}


////////

HRESULT CSignInfo::AddToMessage(DWORD * pulLayers, IMimeMessage * pmm, HWND hwnd)
{
    HRESULT             hr;
    CSignData *         psd;

    DWORD                       count = 0;
    DWORD                       dwType = 0;
    HCERTSTORE                  hcertstore;
    IMimeBody *                 pmb = NULL;
    IMimeSecurity2 *            psmime2 = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    PROPVARIANT                 rgpvAlgHash[MAX_LAYERS] = {0};
    PROPVARIANT                 rgpvAuthAttr[MAX_LAYERS] = {0};
    PCCERT_CONTEXT              rgpccert[MAX_LAYERS] = {0};
    PROPVARIANT                 var;

    hcertstore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING, NULL,
                               0, NULL);
    if (hcertstore == NULL) {
        hr = E_FAIL;
        goto exit;
    }

    //  Pull out the body interface to set security properties
    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr))             goto exit;

    //  Find out what security already exists
    hr = pmb->GetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;
    dwType = var.ulVal;

    //  if any security, then we need to push on a new layer, all previous security
    //  is now on the "y-security" layer and not on the hbody layer
    
    if (dwType != 0) {
        hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;

        hr = pms2->Encode(hwnd, SEF_SENDERSCERTPROVIDED |
                          SEF_ENCRYPTWITHNOSENDERCERT);
        if (FAILED(hr))             goto exit;

        pms2->Release();            pms2 = NULL;
        dwType = 0;

        pmb->Release();             pmb = NULL;
        
        //  Pull out the body interface to set security properties
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;
    }

    //

    hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &psmime2);
    if (FAILED(hr))             goto exit;

    if (psmime2 != NULL) {
        var.vt = VT_UI4;
        var.ulVal = Count();
        hr = pmb->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var);
        if (FAILED(hr))         goto exit;
    }
    
    for (psd = Head(); psd != NULL; psd = psd->Next()) {
        hr = psd->BuildArrays(&count, &dwType, rgpvAlgHash, rgpccert,
                              rgpvAuthAttr, hcertstore, psmime2);
        if (FAILED(hr))         goto exit;
    }

    if (m_fBlob) {
        dwType |= MST_THIS_BLOBSIGN;
    }
    else {
        dwType |= MST_THIS_SIGN;
    }

    // M00HACK
    //        hr = InsertBody(pmm, HBODY_ROOT);
    //        if (FAILED(hr)) {
    //            goto exit;
    //        }


    //  Security Type
    var.vt = VT_UI4;
    var.ulVal = dwType;
    hr = pmb->SetOption(OID_SECURITY_TYPE, &var);
    if (FAILED(hr))         goto exit;

    var.vt = VT_UI4;
    var.ulVal = (DWORD) hcertstore;
    hr = pmb->SetOption(OID_SECURITY_HCERTSTORE, &var);
    if (FAILED(hr))             goto exit;

    var.vt = VT_UI4;
    var.ulVal = count;
    hr = pmb->SetOption(OID_SECURITY_SIGNATURE_COUNT, &var);
    if (FAILED(hr))         goto exit;
    
    if (count > 1) {
        var.vt = (VT_VECTOR | VT_VARIANT);
        var.capropvar.cElems = count;
        var.capropvar.pElems = rgpvAlgHash;
        hr = pmb->SetOption(OID_SECURITY_ALG_HASH_RG, &var);
        if (FAILED(hr))     goto exit;


        var.vt = (VT_VECTOR | VT_UI4);
        var.caul.cElems = count;
        var.caul.pElems = (DWORD *) rgpccert;
        hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING_RG, &var);
        if (FAILED(hr))     goto exit;

        if (psmime2 == NULL) {
            var.vt = (VT_VECTOR | VT_VARIANT);
            var.capropvar.cElems = count;
            var.capropvar.pElems = rgpvAuthAttr;
            hr = pmb->SetOption(OID_SECURITY_AUTHATTR_RG, &var);
            if (FAILED(hr))         goto exit;
        }
    }
    else {
        var.vt = VT_BLOB;
        memcpy(&var.blob, &rgpvAlgHash[0].blob, sizeof(var.blob));
        hr = pmb->SetOption(OID_SECURITY_ALG_HASH, &var);
        if (FAILED(hr))     goto exit;

        var.vt = VT_UI4;
        var.ulVal = (ULONG) rgpccert[0];
        hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING, &var);
        if (FAILED(hr))     goto exit;

        if (psmime2 == NULL) {
            var.vt = VT_BLOB;
            memcpy(&var.blob, &rgpvAuthAttr[0].blob, sizeof(var.blob));
            hr = pmb->SetOption(OID_SECURITY_AUTHATTR, &var);
            if (FAILED(hr))         goto exit;
        }
    }

    hr = S_OK;
exit:
    CertCloseStore(hcertstore, 0);
    if (pmb != NULL)            pmb->Release();
    if (psmime2 != NULL)        psmime2->Release();
    *pulLayers += 1;
    
    return hr;
}

int CSignInfo::Count() const
{
    int         count = 0;
    CSignData * psd;
    
    for (psd=Head(); psd != NULL; psd = psd->Next()) {
        count += 1;
    }
    
    return count;
}

//////////

CSignData::CSignData(int state) : 
    CItem(TYPE_SIGN_DATA, state)
{
    m_pccert = NULL;
    m_ulValidity = 0;
    m_valLabel.cbData = 0;
    m_valLabel.pbData = NULL;
    m_fReceipt = FALSE;
    m_fMLHistory = FALSE;
    m_fAuthAttrib = FALSE;
    m_fUnAuthAttrib = FALSE;
    m_fLabel = FALSE;
    m_valReceipt.cbData = 0;
    m_valReceipt.pbData = NULL;
    m_valMLHistory.cbData = 0;
    m_valMLHistory.pbData = NULL;
    m_valAuthAttrib.cbData = 0;
    m_valAuthAttrib.pbData = NULL;
    m_szAuthAttribOID = NULL;
    m_valUnAuthAttrib.cbData = 0;
    m_valUnAuthAttrib.pbData = NULL;
    m_szUnAuthAttribOID = NULL;
}

HRESULT CSignData::BuildArrays(DWORD * pCount, DWORD * pdwType,
                               PROPVARIANT * rgvHash, PCCERT_CONTEXT * rgpccert,
                               PROPVARIANT * rgvAuthAttr, HCERTSTORE hcertstore,
                               IMimeSecurity2 * psmime2)
{
    CRYPT_ATTRIBUTES    attrs;
    BOOL                f;
    int                 i = *pCount;
    CRYPT_ATTRIBUTE     rgattrs[4];
    PROPVARIANT         var;



    *pdwType |= MST_THIS_SIGN;
    rgvHash[i].blob.pBlobData = (LPBYTE) RgbSHA1AlgId;
    rgvHash[i].blob.cbSize = CbSHA1AlgId;
    //  Don't add ref the certificate -- we don't free it in the caller.
    rgpccert[i] = m_pccert;
    f = CertAddCertificateContextToStore(hcertstore, m_pccert,
                                         CERT_STORE_ADD_USE_EXISTING, NULL);
    Assert(f);


    //  Setup for encoding authenticated attributes
    attrs.cAttr = 0;
    attrs.rgAttr = rgattrs;
    
    //  Encode in the label
    if (m_valLabel.pbData != NULL) {
        rgattrs[attrs.cAttr].pszObjId = szOID_SMIME_Security_Label;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valLabel;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if (m_valReceipt.pbData != NULL) {
        rgattrs[attrs.cAttr].pszObjId = szOID_SMIME_Receipt_Request;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valReceipt;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if (m_valMLHistory.pbData != NULL) {
        rgattrs[attrs.cAttr].pszObjId = szOID_SMIME_MLExpansion_History;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valMLHistory;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if ((m_szAuthAttribOID != NULL) && (m_valAuthAttrib.pbData != NULL)) {
        rgattrs[attrs.cAttr].pszObjId = m_szAuthAttribOID;
        rgattrs[attrs.cAttr].cValue = 1;
        rgattrs[attrs.cAttr].rgValue = &m_valAuthAttrib;

        if (psmime2 != NULL) {
            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_SIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
        else {
            attrs.cAttr += 1;
        }
    }

    if (psmime2 != NULL) {
        if ((m_szUnAuthAttribOID != NULL) && (m_valUnAuthAttrib.pbData != NULL)) {
            rgattrs[attrs.cAttr].pszObjId = m_szUnAuthAttribOID;
            rgattrs[attrs.cAttr].cValue = 1;
            rgattrs[attrs.cAttr].rgValue = &m_valUnAuthAttrib;

            psmime2->SetAttribute(0, i, SMIME_ATTRIBUTE_SET_UNSIGNED,
                                  &rgattrs[attrs.cAttr]);
        }
    }

    Assert(attrs.cAttr <= sizeof(rgattrs)/sizeof(rgattrs[0]));
    if (attrs.cAttr > 0) {
        f = CryptEncodeObjectEx(X509_ASN_ENCODING, szOID_Microsoft_Attribute_Sequence,
                                &attrs, CRYPT_ENCODE_ALLOC_FLAG, NULL,
                                &rgvAuthAttr[i].blob.pBlobData,
                                &rgvAuthAttr[i].blob.cbSize);
        Assert(f);
    }

    *pCount = i+1;
    return S_OK;
}

void CSignData::SetLabel(LPBYTE pb, DWORD cb)
{
    if (m_valLabel.pbData != NULL) {
        free(m_valLabel.pbData);
        m_valLabel.pbData = NULL;
        m_valLabel.cbData = 0;
    }
    if (cb > 0) {
        m_valLabel.pbData = (LPBYTE) malloc(cb);
        memcpy(m_valLabel.pbData, pb, cb);
        m_valLabel.cbData = cb;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\wabstuff.h ===
extern LPWABOBJECT lpWABObject;
extern LPADRBOOK lpAdrBook;


extern void LoadWAB(void);
extern void UnloadWAB(void);
extern void WABFreePadrlist(LPADRLIST lpAdrList);

#define WABAllocateBuffer(cbSize, lppBuffer) lpWABObject->AllocateBuffer(cbSize, lppBuffer)
#define WABAllocateMore(cbSize, lpObject, lppBuffer) lpWABObject->AllocateMore(cbSize, lpObject, lppBuffer)
#define WABFreeBuffer(lpBuffer) lpWABObject->FreeBuffer(lpBuffer)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\res\inetres.h ===
// INETRES.H

#ifndef __INETRES__H
#define __INETRES__H
#include <windows.h>
#endif // __INETRES__H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\resdummy\makefile.inc ===
INETRES_RC_DEPENDS = inetcomm.rcv		    \
		    ..\res\selfreg.inf \
                    ..\inc\resource.h

$O\inetdum.res : $(INETRES_RC_DEPENDS)

..\res\selfreg.inf : ..\res\selfreg.inx
        $(CLEANINF) $** $@

.SUFFIXES: .htx

frntpage.htm : dlg.sed
        -del *.htm
        sed -f dlg.sed $(@:.htm=.htx) >$@

.htx.htm:
        sed -f dlg.sed $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\res\makefile.inc ===
$(O)\athver.bat : $(R)\res\athver.tmp $(BASEDIR)\public\sdk\inc\ntverp.h $(BASEDIR)\public\sdk\inc\ieverp.h
    cl /EP /I$(BASEDIR)\public\sdk\inc /DNASHVILLE /Tc $(R)\res\athver.tmp > $@

$(O)\inetcomm.rc : $(R)\res\inetcomm.rc 
    copy $** $@

$(O)\inetcomm.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx $(O)\athver.bat
    $(O)\athver.bat $(O)\selfreg.inx $(O)\selfreg.in2
    $(CLEANINF) $(O)\selfreg.in2 $@
    del $(O)\selfreg.in2

$O\*.sbr :
    move $(R)\inc\$O\*.sbr $O
    move $(R)\mimeole\$O\*.sbr $O
    move $(R)\imnxport\$O\*.sbr $O
    move $(R)\dll\$O\*.sbr $O
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\wabstuff.cpp ===
/*
 * WAB stuff for S/Mime Test
 */
#include <windows.h>
#include <wab.h>
#include "smimetst.h"
#include "instring.h"
#include "wabstuff.h"
#include "dbgutil.h"


LPWABOPEN lpfnWABOpen = NULL;
const static TCHAR szWABOpen[] = TEXT("WABOpen");
LPWABOBJECT lpWABObject = NULL;
LPADRBOOK lpAdrBook = NULL;
HINSTANCE hInstWABDll = NULL;


//$$//////////////////////////////////////////////////////////////////////
//
// GetWABDllPath
//
//
//////////////////////////////////////////////////////////////////////////
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    ULONG  cbData;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH + 1];

    if(szPath) {
        *szPath = '\0';

        // open the szWABDllPath key under
        if (ERROR_SUCCESS == RegOpenKeyEx(  HKEY_LOCAL_MACHINE,
                                            WAB_DLL_PATH_KEY,
                                            0,      //reserved
                                            KEY_READ,
                                            &hKey))
        {
            cbData = sizeof(szPathT);
            if (ERROR_SUCCESS == RegQueryValueEx(    hKey,
                                "",
                                NULL,
                                &dwType,
                                (LPBYTE) szPathT,
                                &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        lstrcpy(szPath, szPathT);
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
}


/***************************************************************************

    Name      : WABFreePadrlist

    Purpose   : Free an adrlist and it's property arrays

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
void WABFreePadrlist(LPADRLIST lpAdrList) {
    ULONG           iEntry;

    if (lpAdrList) {
        for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry) {
            if (lpAdrList->aEntries[iEntry].rgPropVals) {
                WABFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
            }
        }
        WABFreeBuffer(lpAdrList);
    }
}


//$$//////////////////////////////////////////////////////////////////////
//
// LoadLibrary_WABDll()
//
//  Since we are moving the WAB directory out of Windows\SYstem, we cant be
//  sure it will be on the path. Hence we need to make sure that WABOpen will
//  work - by loading the wab32.dll upfront
//
///////////////////////////////////////////////////////////////////////////
HINSTANCE LoadLibrary_WABDll(void)
{
    IF_WIN32(LPTSTR lpszWABDll = TEXT("Wab32.dll");)
    TCHAR  szWABDllPath[MAX_PATH + 1];
    HINSTANCE hinst = NULL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    hinst = LoadLibrary((lstrlen(szWABDllPath)) ? szWABDllPath : lpszWABDll);

    return hinst;
}


void LoadWAB(void) {
    LPWABOPEN lpfnWABOpen = NULL;

    if (! hInstWABDll) {
        hInstWABDll = LoadLibrary_WABDll();
        if (hInstWABDll)
            lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWABDll, szWABOpen);
        if (lpfnWABOpen)
            lpfnWABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    }
}


void UnloadWAB(void) {
    if (lpAdrBook) {
        lpAdrBook->Release();
        lpAdrBook = NULL;

        lpWABObject->Release();
        lpWABObject = NULL;
    }
    if (hInstWABDll) {
        FreeLibrary(hInstWABDll);
        hInstWABDll = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smimetst.h ===
#define IDM_NEW                     1
#define IDM_OPEN                    2
#define IDM_SAVE                    3
#define IDM_SAVEAS                  4
#define IDM_EXIT                    5
#define IDM_OPTIONS                 6
#define IDM_F_MAILLIST                  7

#define IDM_HELP                    40
#define IDM_ABOUT                   41
#define IDM_ENCODE                      42

#define IDM_E_INSERT_SIGN               100
#define IDM_E_INSERT_ENCRYPT            101
#define IDM_E_INSERT_SIGNATURE          102
#define IDM_E_DELETE_LAYER              103
#define IDM_E_DELETE_SIGNATURE          104
#define IDM_E_INSERT_TRANSPORT          105
#define IDM_E_INSERT_AGREEMENT          106
#define IDM_E_INSERT_MAILLIST           107

#define IDM_F_OPTIONS                   110

#define IDM_ALLOCATE                1001
#define IDM_WABOPEN                 1003
#define IDM_ADDRESS                 1006
#define IDM_ADDRESS_WELLS0          1014
#define IDM_ADDRESS_WELLS1          1015
#define IDM_ADDRESS_WELLS2          1016
#define IDM_ADDRESS_WELLS3          1017
#define IDM_ADDRESS_DEFAULT         1018


#define IDM_CLEARSIGN               1100
#define IDM_OPAQUESIGN              1101
#define IDM_ENCRYPT                 1102
#define IDM_SIGNANDENCRYPT          1103
#define IDM_CLEARTRIPLEWRAP         1104
#define IDM_OPAQUETRIPLEWRAP        1105
#define IDM_DECODE                  1106
#define IDM_RESET                       1107
#define IDM_VALIDATE                    1108

#define idd_Options                     2000
#define IDD_MSG_DATA                    2001
#define IDD_SIGN_INFO_COMPOSE           2002
// #define IDD_SIGN_INFO_READ              2003
#define IDD_SIGN_DATA_COMPOSE           2004
#define IDD_SIGN_DATA_READ		2005
#define IDD_ENCRYPT_INFO_COMPOSE        2006
#define IDD_ENCRYPT_INFO_READ           2007
#define IDD_ENC_AGREE_COMPOSE           2008
#define IDD_ENC_TRANS_COMPOSE           2010
#define IDD_ENC_ML_COMPOSE              2012
#define IDD_RECEIPT_CREATE              2014
#define IDD_DETAIL                      2015
#define IDD_FILE_MAILLIST               2016
#define IDD_MLDATA_CREATE               2017
#define IDD_FILE_ADD_ML                 2018
#define IDD_ATTRIB_CREATE               2019

#define IDC_RC_FROM_ALL                 100
#define IDC_RC_FROM_TOP                 101
#define IDC_RC_FROM_SOME                102
#define IDC_RC_FROM_TEXT                103
#define IDC_RC_TO_TEXT                  104
#define IDC_RC_CONTENT                  105

#define IDC_O_CERT_CHOOSE               100
#define IDC_O_CERT_NAME                 101
#define IDC_O_MY_NAMES                  102
#define IDC_SENDER_GROUP            6000
#define IDC_RECIPIENT_GROUP         6001
#define IDC_SENDER_EMAIL            6100
#define IDC_RECIPIENT_EMAIL         6200

#define IDC_SI_BLOB_SIGN                100

#define IDC_SD_CERT_CHOOSE              100
#define IDC_SD_CERT_NAME                101
#define IDC_SD_USE_SKI                  102
#define IDC_SD_LABEL                    103
#define IDC_SD_POLICY                   104
#define IDC_SD_CLASSIFICATION           105
#define IDC_SD_PRIVACY_MARK             106
#define IDC_SD_ADVANCED                 107
#define IDC_SD_RECEIPT                  108
#define IDC_SD_DO_RECEIPT               109
#define IDC_SD_MLDATA                   110
#define IDC_SD_DO_MLDATA                111
#define IDC_SD_AUTHATTRIB               112
#define IDC_SD_DO_AUTHATTRIB            113
#define IDC_SD_UNAUTHATTRIB             114
#define IDC_SD_DO_UNAUTHATTRIB          115

#define IDC_SDR_CERT_VIEW                100
#define IDC_SDR_CERT_NAME                101
#define IDC_SDR_LABEL                    103
#define IDC_SDR_POLICY                   104
#define IDC_SDR_CLASSIFICATION           105
#define IDC_SDR_PRIVACY_MARK             106
#define IDC_SDR_ADVANCED                 107
#define IDC_SDR_RECEIPT                  108
#define IDC_SDR_DO_RECEIPT               109

#define IDC_MD_PLAIN_CHOOSE             100
#define IDC_MD_PLAIN_NAME               101
#define IDC_MD_CIPHER_CHOOSE            102
#define IDC_MD_CIPHER_NAME              103
#define IDC_MD_ITERATION                104
#define IDC_MD_TOFILE                   105

#define IDC_ETC_LIST                    100
#define IDC_ETC_ADD_CERT                101
#define IDC_ETC_DEL_CERT                102
#define IDC_ETC_SKI                     103

#define IDC_EIC_AUTO                    100
#define IDC_EIC_FORCE                   101
#define IDC_EIC_ENC_ALG                 102
#define IDC_EIC_ALG_SELECT              103
#define IDC_EIC_ATTRIBUTES              104
#define IDC_EIC_UNPROTATTRIB            105
#define IDC_EIC_DO_UNPROTATTRIB         106

#define IDC_MLC_ID                      100
#define IDC_MLC_KEY                     101
#define IDC_MLC_ALG                     102
#define IDC_MLC_CSPS                    103

#define IDC_FML_LIST                    100
#define IDC_FML_ADD                     101
#define IDC_FML_DELETE                  102

#define IDC_MLC_ABSENT1                 100
#define IDC_MLC_NONE1                   101
#define IDC_MLC_INSTEAD1                102
#define IDC_MLC_ALSO1                   103
#define IDC_MLC_NAMES1                  104
#define IDC_MLC_ABSENT2                 105
#define IDC_MLC_NONE2                   106
#define IDC_MLC_INSTEAD2                107
#define IDC_MLC_ALSO2                   108
#define IDC_MLC_NAMES2                  109
#define IDC_MLC_OTHERS                  110
#define IDC_MLC_INCLUDE2                111
#define IDC_MLC_CERT1                   112
#define IDC_MLC_CERT2                   113
#define IDC_MLC_ID1                     114
#define IDC_MLC_ID2                     115
#define IDC_MLC_SELECT1                 116
#define IDC_MLC_SELECT2                 117

#define IDC_AMLK_ID                     100
#define IDC_AMLK_KEY                    101
#define IDC_AMLK_ALG                    102
#define IDC_AMLK_DATE                   103
#define IDC_AMLK_OTHER                  104

#define IDC_BA_OID_L                    100
#define IDC_BA_OID                      101
#define IDC_BA_ASN_L                    102
#define IDC_BA_ASN                      103

#if 0
#define IDC_SENDER_NAME             6101
#define IDC_SENDER_CHOOSE           6102
#define IDC_RECIPIENT_NAME          6201
#define IDC_RECIPIENT_CHOOSE        6202
#define IDC_OUTPUT_FILE             6300
#define IDC_OUTPUT_FILE_BROWSE      6301
#endif // 0
#define IDC_STATIC                  -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smtpcall.cpp ===
// --------------------------------------------------------------------------------
// Smtpcall.cpp
// --------------------------------------------------------------------------------
#include <windows.h>
#include <stdio.h>
#include "smtpcall.h"

extern DWORD            MsgSMTP;
// --------------------------------------------------------------------------------
// HrCreateSMTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP)
{
    // Locals
    HRESULT             hr;
    CSMTPCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CSMTPCallback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)ppSMTP);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppSMTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::CSMTPCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::~CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::~CSMTPCallback(void)
{
}

// --------------------------------------------------------------------------------
// CSMTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_ISMTPCallback
    else if (IID_ISMTPCallback == riid)
        *ppv = (ISMTPCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSMTPCallback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
    printf("CSMTPCallback::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        printf("Finding '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTING:
        printf("Connecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_SECURING:
        printf("Establishing secure connection to '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTED:
        printf("Connected '%s'\n", rServer.szServerName);
        break;
    case IXP_AUTHORIZING:
        printf("Authorizing '%s'...\n", rServer.szServerName);
        break;
    case IXP_AUTHRETRY:
        printf("Retrying Logon '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTING:
        printf("Disconnecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTED:
        printf("Disconnected '%s'\n", rServer.szServerName);
        PostThreadMessage(GetCurrentThreadId(), MsgSMTP, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
    {
        printf("%s[TX]: %s", rServer.szServerName, pszLine);
    }
    else if (CMD_RESP == cmdtype)
        printf("%s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnResponse(
        LPSMTPRESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case SMTP_NONE:
        break;

    case SMTP_BANNER:
        break;

    case SMTP_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_CONNECTED, 0);
        break;

    case SMTP_SEND_MESSAGE:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_SEND_MESSAGE, 0);
        break;

    case SMTP_EHLO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_EHLO, 0);
        break;

    case SMTP_HELO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_HELO, 0);
        break;

    case SMTP_MAIL:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_MAIL, 0);
        break;

    case SMTP_RCPT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_RCPT, 0);
        break;

    case SMTP_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_RSET, 0);
        break;

    case SMTP_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_QUIT, 0);
        break;

    case SMTP_DATA:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_DATA, 0);
        break;

    case SMTP_DOT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_DOT, 0);
        break;

    case SMTP_SEND_STREAM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_SEND_STREAM, 0);
        break;

    case SMTP_CUSTOM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), MsgSMTP, SMTP_CUSTOM, 0);
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\smimetst\smimetst.cpp ===
/* --- FIXES

--  SMIME TEST

fixed  --- Can't do more than 4 || signers
fixed  --- Can't Sc(Ekt(B))
-  --- Sb(Sb(Sb(B))) only two layers are generated?
-  --- Unauthenticated attributes
*/


///  http:iptdalpha3 - symbols for crypt32.

/*-----------------------------------------
   SMimeTst.C -- Function Test of S/Mime
  -----------------------------------------*/

#define INITGUID
#define DEFINE_STRCONST
#include "item.h"

#include "smtpcall.h"
#include "instring.h"
#include "dbgutil.h"
#include "sign.h"
#include "maillist.h"


#define WinMainT WinMain
long FAR PASCAL WndProc (HWND, UINT, UINT, LONG);

char szAppName [] = "SMimeTst";
static const TCHAR c_szDebug[]      = "mshtmdbg.dll";
static const TCHAR c_szDebugUI[]    = "DoTracePointsDialog";
static const TCHAR c_szRegSpy[]     = "DbgRegisterMallocSpy";
static const TCHAR c_szInvokeUI1[]   = "/d";
static const TCHAR c_szInvokeUI2[]   = "-d";
HINSTANCE hInst;

const int       MAX_LAYERS = 100;
extern const BYTE RgbSHA1AlgId[];
extern const int  CbSHA1AlgId;

const GUID GuidCertValidate = CERT_CERTIFICATE_ACTION_VERIFY;

HWND            HdlgMsg;
HWND            HwndTree;

BOOL CALLBACK DetailDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncDataComposeDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncTransCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncAgreeCompDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EncInfoReadDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK MailListDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

enum {
    Dlg_Message,
    Dlg_Sign_Info_Compose,
    Dlg_Sign_Info_Read,
    Dlg_Sign_Data_Compose,
    Dlg_Sign_Data_Read,
    Dlg_Enc_Info_Compose,
    Dlg_Enc_Info_Read,
    Dlg_Enc_Data_Agree_Compose,
    Dlg_Enc_Data_Trans_Compose,
    Dlg_Enc_Data_MailList_Compose,
    Dlg_Max
};

struct {
    int         id;
    DLGPROC     proc;
    HWND        hwnd;
} RgDlgs[] = {
    {IDD_DETAIL, DetailDlgProc},
    {IDD_SIGN_INFO_COMPOSE, SignInfoDlgProc},
    {IDD_SIGN_INFO_COMPOSE, SignInfoDlgProc},
    {IDD_SIGN_DATA_COMPOSE, SignDataDlgProc},
    {IDD_SIGN_DATA_READ, SignDataReadDlgProc},
    {IDD_ENCRYPT_INFO_COMPOSE, EncDataDlgProc},
    {IDD_ENCRYPT_INFO_READ, EncInfoReadDlgProc},
    {IDD_ENC_AGREE_COMPOSE, EncAgreeCompDlgProc},
    {IDD_ENC_TRANS_COMPOSE, EncTransCompDlgProc},
    {IDD_ENC_ML_COMPOSE, EncMLComposeDlgProc}
};

HWND            HdlgEncData;
HWND            HdlgSignInfo;
HWND            HwndDetail;
CMessage        RootMsg;
BYTE            RgbSignHash[20];

HCERTSTORE              HCertStoreMy = NULL;

IImnAccountManager *    PAcctMan = NULL;
ISMTPTransport *        PSmtp = NULL;
extern DWORD            MsgSMTP = 0;


char    RgchBody[] = "Now is the time for all good men (and women) to come to the aid of their country.\r\n";

char    RgchExample[] = "This is some sample content.";

typedef void (STDAPICALLTYPE *PFNDEBUGUI)(BOOL);
typedef void (STDAPICALLTYPE *PFNREGSPY)(void);

void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        if ((msg.message == uiMsg) && (msg.wParam == wparam) ||
            (msg.wParam == IXP_DISCONNECTED))
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void ShowWindow(int id, LPARAM lparam)
{
    int         i;
    for (i=0; i<Dlg_Max; i++) {
        ShowWindow(RgDlgs[i].hwnd, SW_HIDE);
    }
    
    ShowWindow(RgDlgs[id].hwnd, SW_SHOWNORMAL);
    SendMessage(RgDlgs[id].hwnd, UM_SET_DATA, 0, lparam);
}

BOOL pfnFilter(PCCERT_CONTEXT pccert, long lCustData, DWORD, DWORD)
{
    BOOL        f = FALSE;
    LPCSTR      pszObjId = pccert->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if (lCustData & FILTER_RSA_KEYEX) {
        f |= (strcmp(pszObjId, szOID_RSA_RSA) == 0);
    }
    if (lCustData & FILTER_RSA_SIGN) {
        f |= (strcmp(pszObjId, szOID_RSA_RSA) == 0);
    }
    if (lCustData & FILTER_DSA_SIGN) {
        f |= (strcmp(pszObjId, szOID_X957_DSA) == 0);
    }
    if (lCustData & FILTER_DH_KEYEX) {
        f |= (strcmp(pszObjId, szOID_ANSI_X942_DH) == 0);
    }
    if (lCustData & FILTER_KEA_KEYEX) {
        f |= (strcmp(pszObjId, szOID_INFOSEC_keyExchangeAlgorithm) == 0);
    }
    return f;
}


BOOL DoCertDialog(HWND hwndOwner, LPTSTR szTitle, HCERTSTORE hCertStore, PCCERT_CONTEXT *ppCert, int iFilter)
{
    DWORD               cchEmail;
    CERT_SELECT_STRUCT  css = {0};
    PCCERT_CONTEXT      pCurCert;
    BOOL                fRet = FALSE;

    pCurCert = CertDuplicateCertificateContext(*ppCert);

    css.dwSize = sizeof(CERT_SELECT_STRUCT);
    css.hwndParent = hwndOwner;
    css.hInstance = hInst;
    css.arrayCertStore = &hCertStore;
    css.szTitle = szTitle;
    css.cCertStore = 1;
    css.szPurposeOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    css.arrayCertContext = ppCert;
    css.cCertContext = 1;
    css.lCustData = iFilter;
    css.pfnFilter = pfnFilter;

    if (CertSelectCertificate(&css) && (pCurCert != *ppCert)) {
        fRet = TRUE;
    }
    CertFreeCertificateContext(pCurCert);

    return fRet;
}

BOOL ViewCertDialog(HWND hwndOwner, LPTSTR szTitle, PCCERT_CONTEXT pCert)
{
    CERT_VIEWPROPERTIES_STRUCT         cvs = {0};
    char *                             psz = szOID_PKIX_KP_EMAIL_PROTECTION;

    cvs.dwSize = sizeof(cvs);
    cvs.hwndParent = hwndOwner;
    cvs.szTitle = szTitle;
    cvs.pCertContext = pCert;
    cvs.cArrayPurposes = 1;
    cvs.arrayPurposes = &psz;

    CertViewProperties(&cvs);

    return TRUE;
}


//  HrValidateCert
//
//  Description:
//      This routine is used to check the validity of a certificate, the codes
//      are modified from HrDoTrustWork in cryptdlg.dll, by xzhang
//
//  Parameters:
//      pcert - Point to the certificate we want to validate
//      hstore - Extra store for searching certficates
//      pbd - Point to BinData for returning the certificate chain
//      pcCertsInChain - Point to DWORD for returning the # of certs in chain
//      pdwErrors - Returns the errors encountered in validating the cert
//
//  Return Value:
//      Result code of operation.
//
//  Returned in *pdwErrors;
//
//      The return value consists of a set of flags about why we failed to
//      do the validation.  Current reasons are:
//
//      SIGFAILURE_INVALID_CERT - Certificate is internally inconsistant
//      SIGFAILURE_UNKNOWN_ROOT - Root certificate in chain is either unknown
//                                      or not self sign.
//      SIGFAILURE_CERT_EXPIRED - Certificate has expired
//      SIGFAILURE_CERT_REVOKED - Certificate has been revoked
//      SIGFAILURE_CRL_NOT_FOUND - CRL was not found for some Issuer
//      SIGFAILURE_INVALID_SIGNATURE - Invalid signature, not the above reason
//

HRESULT HrValidateCert(PCCERT_CONTEXT pccert, HCERTSTORE hstore, HCRYPTPROV hprov,
                       HCERTSTORE * phcertstorOut, DWORD * pdwErrors)
{
    WINTRUST_BLOB_INFO              blob = {0};
    DWORD                           cCertsInChain = 0;
    DWORD                           cStores;
    WINTRUST_DATA                   data = {0};
    DWORD                           dwCAs = 0;
    DWORD                           dwErrors = 0;
    DWORD                           dwRet = 0;
    BOOL                            f;
    HCERTSTORE                      hcertstorOut;
    DWORD                           i;
    PCCERT_CONTEXT                  pccertOut = NULL;
    PCCERT_CONTEXT *                rgCerts = NULL;
    DWORD *                         rgdwErrors = NULL;
    HCERTSTORE                      rghstoreCA[2] = {NULL};
    CERT_VERIFY_CERTIFICATE_TRUST   trust = {0};
    HRESULT                         hr;

    Assert(pdwErrors != NULL);

    //
    //  Make sure we have a place to store the output unless we are being
    //    told to ignore it
    //

    if (phcertstorOut != NULL) {
        // Try to open an output store if we have not been given one
        
        if (*phcertstorOut == NULL) {
            hcertstorOut = CertOpenStore(CERT_STORE_PROV_MEMORY, 
                                         X509_ASN_ENCODING, hprov,
                                         CERT_STORE_NO_CRYPT_RELEASE_FLAG, 
                                         NULL);
            if (hcertstorOut == NULL) {
                hr = E_FAIL;
                goto ExitHere;
            }
            *phcertstorOut = hcertstorOut;
        }
        else {
            hcertstorOut = *phcertstorOut;
        }
    }
    else {
        // No output is being requested
        
        hcertstorOut = NULL;
    }        

    //
    //  Fill the WINTRUST_DATA 
    //
    
    data.cbStruct = sizeof(WINTRUST_DATA);
    data.dwUIChoice = WTD_UI_NONE;
    data.fdwRevocationChecks = WTD_REVOKE_NONE;
    data.dwUnionChoice = WTD_CHOICE_BLOB;
    data.pBlob = &blob;

    //
    //  Fill the trust blob information
    //
    
    blob.cbStruct = sizeof(WINTRUST_BLOB_INFO);
    blob.cbMemObject = sizeof(CERT_VERIFY_CERTIFICATE_TRUST);
    blob.pbMemObject = (LPBYTE)&trust;


    //
    //  Fill the certificate trust information
    //
    trust.cbSize = sizeof(trust);
    trust.pccert = pccert;
    trust.dwFlags = (CERT_TRUST_DO_FULL_SEARCH | CERT_TRUST_PERMIT_MISSING_CRLS
                    |CERT_TRUST_DO_FULL_TRUST | CERT_TRUST_ADD_CERT_STORES);
    trust.dwIgnoreErr = CERT_VALIDITY_NO_CRL_FOUND;
    trust.pdwErrors = &dwErrors;
    trust.pszUsageOid = szOID_PKIX_KP_EMAIL_PROTECTION;
    trust.hprov = hprov;

    //
    //  If we have a store of certificates, then pass it in to give us additional
    //  places to look
    //

    rghstoreCA[0] = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                  hprov, (CERT_SYSTEM_STORE_CURRENT_USER |
                                          CERT_STORE_NO_CRYPT_RELEASE_FLAG),
                                  L"CA");
    if (rghstoreCA[0] == NULL) {
        hr = E_FAIL;
        goto ExitHere;
    }

    cStores = 1;
    trust.rghstoreCAs = rghstoreCA;
    
    if (hstore) {
        cStores = 2;
        rghstoreCA[1] = hstore;
    }
    trust.cStores = cStores;

    trust.pcChain = &cCertsInChain;
    trust.prgChain = &rgCerts;
    trust.prgdwErrors = &rgdwErrors;

    //
    //  Call the brain function to verify the trust status of this certificate
    //

    hr = WinVerifyTrust(NULL, (GUID *)&GuidCertValidate, &data);
    if(FAILED(hr) || cCertsInChain == 0) {
        //
        //  We completely failed the verificaiton
        //
        
        *pdwErrors = /*SIGFAILURE_OTHER*/ 1;

        //
        //  But we still need to shove this certificate into the output store
        //  if the user wants one
        //
        
        if (NULL != hcertstorOut) {
            // Add the certificate to the store.  We need to remember the
            //  new context so we can properly add CRLs
            
            f = CertAddCertificateContextToStore(hcertstorOut, pccert,
                                                 CERT_STORE_ADD_NEW, 
                                                 &pccertOut);
            Assert(f || (NULL == pccertOut));
            
            // Look for any CRLs which might apply to the new context
            //  and add them to the store as well

            if (NULL != pccertOut) {
                //                hr = HrAddValidCRLsToStore(hcertstorOut, pccertOut, 
                //                                           rghstoreCA, cStores);
                Assert(S_OK == hr);                        
            }                
        }                                                 
        hr = S_OK;
        goto ExitHere;
    }

    //
    // Now build the certificates chain for SSignature when requested
    //
    
    if (hcertstorOut != NULL) {
        if (cCertsInChain == 0) {
            // Store the certificate in the output store and remember the
            //  new certificate context for checking the CRLs
            
            f = CertAddCertificateContextToStore(hcertstorOut, pccert,
                                                 CERT_STORE_ADD_NEW, 
                                                 &pccertOut);
            Assert(f || (NULL == pccertOut));
                                                 
            // Look for any CRLs which might apply and add them to the store
            //  as well

            if (NULL != pccertOut) {
                //                hr = HrAddValidCRLsToStore(hcertstorOut, pccertOut,
                //                                           rghstoreCA, cStores);
                Assert(S_OK == hr);
            }                
        }

        for (i=0; i<cCertsInChain; i++) {
            // Free any output certificate context we have already

            if (NULL != pccertOut) {
                CertFreeCertificateContext(pccertOut);
                pccertOut = NULL;
            }
            
            // Add the encoded certificate to the store
            
            f = CertAddEncodedCertificateToStore(hcertstorOut, X509_ASN_ENCODING,
                                                 rgCerts[i]->pbCertEncoded,
                                                 rgCerts[i]->cbCertEncoded,
                                                 CERT_STORE_ADD_NEW, &pccertOut);
            Assert(f || (NULL == pccertOut));

            // Add any appropriate CRLs to the store as well

            if (NULL != pccertOut) {
                // hr = HrAddValidCRLsToStore(hcertstorOut, pccertOut,
                //                                           rghstoreCA, cStores);
                Assert(S_OK == hr);                        
            }                
        }
    }

    //
    // Setup the signuare error flags as used in ExSec32.dll
    //
    
    if(rgdwErrors == NULL) {
        *pdwErrors = /*SIGFAILURE_OTHER*/ 1;
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto ExitHere;
    }
    
    // We only care about the trust status of the leaf certificate
    
    dwErrors = rgdwErrors[0];

    if (dwErrors != 0) {
        if(dwErrors & CERT_VALIDITY_SIGNATURE_FAILS) {
            dwRet |= /*SIGFAILURE_INVALID_CERT*/ 2;
            dwErrors &= ~CERT_VALIDITY_SIGNATURE_FAILS;
        }
        if(dwErrors & CERT_VALIDITY_CERTIFICATE_REVOKED) {
            dwRet |= /*SIGFAILURE_CERT_REVOKED*/ 4;
            dwErrors &= ~CERT_VALIDITY_CERTIFICATE_REVOKED;
        }
        if(dwErrors & CERT_VALIDITY_AFTER_END) {
            dwRet |= /*SIGFAILURE_CERT_EXPIRED*/ 8;
            dwErrors &= ~CERT_VALIDITY_AFTER_END;
        }
        if(dwErrors & CERT_VALIDITY_EXPLICITLY_DISTRUSTED) {
            dwRet |= /*SIGFAILURE_CERT_DISTRUSTED*/ 16;
            dwErrors &= ~CERT_VALIDITY_EXPLICITLY_DISTRUSTED;
        }
        if((dwErrors & CERT_VALIDITY_NO_ISSUER_CERT_FOUND) &&
           (cCertsInChain == 1)) {
            dwRet |= /*SIGFAILURE_CERT_DISTRUSTED*/ 128;
            dwErrors &= ~CERT_VALIDITY_NO_ISSUER_CERT_FOUND;
        }
        if((dwErrors & CERT_VALIDITY_NO_TRUST_DATA) &&
           (cCertsInChain == 1)) {
            dwRet |= /*SIGFAILURE_CERT_DISTRUSTED*/ 256;
            dwErrors &= ~CERT_VALIDITY_NO_TRUST_DATA;
        }
        if(dwErrors & CERT_VALIDITY_NO_TRUST_DATA) {
            dwRet |= /*SIGFAILURE_UNKNOWN_ROOT*/ 32;
            dwErrors &= ~CERT_VALIDITY_NO_TRUST_DATA;
        }
        if(dwErrors & CERT_VALIDITY_ISSUER_DISTRUST) {
            dwRet |= /*SIGFAILURE_ISSUER_DISTRUSTED*/ 64;
            dwErrors &= ~CERT_VALIDITY_ISSUER_DISTRUST;
        }
        if(dwErrors) { // catch all other non-specified case
            dwRet |= /*SIGFAILURE_OTHER*/ 1;
        }
    }

    *pdwErrors = dwRet;
    hr = S_OK;
    
ExitHere:
    // 
    //  Clean up any items laying around
    //

    if (NULL != pccertOut) {
        CertFreeCertificateContext(pccertOut);
    }
    
    if (rghstoreCA[0] != NULL) {
        CertCloseStore(rghstoreCA[0], 0);
    }
    
    if(rgdwErrors)
        LocalFree(rgdwErrors);
    
    if(rgCerts != NULL) {
        for(i=0; i < cCertsInChain; ++i) {
            CertFreeCertificateContext(rgCerts[i]);
        }
        LocalFree(rgCerts);
    }
    
    return hr;
}




BOOL GetOpenEmailFileName(HWND hwnd, LPTSTR szInputFile, LPCSTR szTitle) {
    TCHAR szFileName[CCH_OPTION_STRING];
    OPENFILENAME ofn = {0};


    lstrcpy(szFileName, szInputFile);
    if (szInputFile[0] == '<') szInputFile[0] = 0;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = hInst;
    ofn.lpstrFilter = "Email File\0*.eml\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CCH_OPTION_STRING;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = "eml";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (GetOpenFileName(&ofn)) {
        lstrcpy(szInputFile, szFileName);
        return(TRUE);
    }
    return(FALSE);
}


HRESULT InsertBody(IMimeMessage * pmm, HBODY hbody)
{
    HRESULT     hr;
    
    hr = pmm->ToMultipart(hbody, "y-security", NULL);
    if (FAILED(hr))             return hr;

    return S_OK;
}

int PASCAL 
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine,
        int nCmdShow)
{
    BOOL        f;
    HINSTANCE   hInstDebug = NULL;
    HRESULT     hr;
    HWND        hwnd;
    INITCOMMONCONTROLSEX        initCommCtrl = { 8, ICC_TREEVIEW_CLASSES };
    MSG         msg;
    WNDCLASS    wndclass;

    // OLE Init
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        exit(1);
    }

    InitDemandLoadedLibs();
    InitCommonControlsEx(&initCommCtrl);

    //  Load options from the registry
    GetOptions();

    if (!hPrevInstance) {
        hInst = hInstance;

        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInstance ;
        wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION) ;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclass.hbrBackground = CreateSolidBrush(0x00ffff);
        wndclass.lpszMenuName  = szAppName ;
        wndclass.lpszClassName = szAppName ;

        RegisterClass (&wndclass) ;
    }

    MsgSMTP = RegisterWindowMessage("SMTPTransport_Notify");

    if (! hInstDebug) {
        // Load mshtmdbg.dll
        hInstDebug = LoadLibrary(c_szDebug);

        // Did it load ?
        if (NULL != hInstDebug) {
            // Locals
            PFNREGSPY  pfnRegSpy;

            // If the user passed /d on the command line, lets configure mshtmdbg.dll
            if (0 == lstrcmpi(lpszCmdLine, c_szInvokeUI1) || 
                0 == lstrcmpi(lpszCmdLine, c_szInvokeUI2)) {
                // Locals
                PFNDEBUGUI pfnDebugUI;

                // Get the proc address of the UI
                pfnDebugUI = (PFNDEBUGUI)GetProcAddress(hInstDebug, c_szDebugUI);
                if (NULL != pfnDebugUI) {
                    (*pfnDebugUI)(TRUE);
                }
            }

            // Get the process address of the registration
            pfnRegSpy = (PFNREGSPY)GetProcAddress(hInstDebug, c_szRegSpy);
            if (NULL != pfnRegSpy)
                (*pfnRegSpy)();
        }
    }

    hwnd = CreateWindow (szAppName, "S/Mime Test", WS_OVERLAPPEDWINDOW,
                         CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                         CW_USEDEFAULT, NULL, NULL, hInstance, NULL) ;

    ShowWindow (hwnd, nCmdShow) ;
    UpdateWindow (hwnd) ;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }


    f = CertCloseStore(HCertStoreMy, CERT_CLOSE_STORE_CHECK_FLAG);
    if (!f) {
        AssertSz(FALSE, "Global My Cert store did not close completely");
    }

    if (PSmtp)                  PSmtp->Release();
    if (PAcctMan)               PAcctMan->Release();

    if (hInstDebug) {
        FreeLibrary(hInstDebug);
    }

    FreeDemandLoadedLibs();
    CoFreeUnusedLibraries();
    
    return(msg.wParam);
}


BOOL CALLBACK DetailDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_INITDIALOG:
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CALLBACK MsgDataDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR       rgchFileName[CCH_OPTION_STRING];

    
    switch (msg) {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_MD_PLAIN_NAME, RootMsg.GetPlainFile());        
        SetDlgItemText(hdlg, IDC_MD_CIPHER_NAME, RootMsg.GetCipherFile());
        SetDlgItemInt(hdlg, IDC_MD_ITERATION, RootMsg.GetIterationCount(), FALSE);
        SendDlgItemMessage(hdlg, IDC_MD_TOFILE, BM_SETCHECK, FALSE, 0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_MD_PLAIN_CHOOSE:
            if (GetOpenEmailFileName(hdlg, RootMsg.GetPlainFile(),
                                     "Select Plain Text File")) {
                SetDlgItemText(hdlg, IDC_MD_PLAIN_NAME, RootMsg.GetPlainFile());
            }
            break;
            
        case IDC_MD_CIPHER_CHOOSE:
            if (GetOpenEmailFileName(hdlg, RootMsg.GetCipherFile(),
                                     "Select Cipher Text File")) {
                SetDlgItemText(hdlg, IDC_MD_CIPHER_NAME, RootMsg.GetCipherFile());
            }
            break;

        case MAKELONG(IDC_MD_PLAIN_NAME, EN_CHANGE):
            GetDlgItemText(hdlg, IDC_MD_PLAIN_NAME, RootMsg.GetPlainFile(),
                           RootMsg.GetFileNameSize());
            break;
            
        case MAKELONG(IDC_MD_CIPHER_NAME, EN_CHANGE):
            GetDlgItemText(hdlg, IDC_MD_CIPHER_NAME, RootMsg.GetCipherFile(),
                           RootMsg.GetFileNameSize());
            break;

        case MAKELONG(IDC_MD_ITERATION, EN_CHANGE):
            RootMsg.GetIterationCount() = GetDlgItemInt(hdlg, IDC_MD_ITERATION,
                                                        NULL, FALSE);
            break;

        case MAKELONG(IDC_MD_TOFILE, BN_CLICKED):
            RootMsg.SetToFile(!SendDlgItemMessage(hdlg, IDC_MD_TOFILE, BM_GETCHECK, 0, 0));
            break;

        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL InsertNode(LPSTR pszLayerName, int iImage, DWORD iDlg, DWORD dwData)
{
    HTREEITEM           hitem;
    CItem *             pitem;
    TV_INSERTSTRUCT     tvins;
    TV_ITEM             tvitm;

    hitem = TreeView_GetSelection(HwndTree);

    tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvins.hParent = TreeView_GetParent(HwndTree, hitem);
    if (tvins.hParent == NULL) {
        tvins.hParent = hitem;
        tvins.hInsertAfter = TVI_FIRST;
        pitem = NULL;
    }
    else {
        tvins.hInsertAfter = hitem;
        tvitm.mask = TVIF_PARAM;
        tvitm.hItem = hitem;
        TreeView_GetItem(HwndTree, &tvitm);
        pitem = (CItem *) tvitm.lParam;
    }
    tvins.item.pszText = pszLayerName;
    tvins.item.cchTextMax = strlen(pszLayerName);
    tvins.item.iImage = iImage;
    tvins.item.iSelectedImage = tvins.item.iImage;

    tvins.item.lParam = dwData;

    hitem = TreeView_InsertItem(HwndTree, &tvins);
    TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
    TreeView_SelectItem(HwndTree, hitem);
                
    SendMessage(RgDlgs[iDlg].hwnd, UM_SET_DATA, 0, tvins.item.lParam);

    RootMsg.MakeChild((CItem *) tvins.item.lParam, pitem);

    return TRUE;
}

BOOL InsertNode2(int typeParent, LPSTR pszTitle, DWORD iImage, DWORD iDlg,
                 CItem * pItemNew)
{
    HTREEITEM           hitem;
    HTREEITEM           hitemParent;
    CItem *             pitem;
    CItem *             pitemParent;
    TV_ITEM             tvitm;
    TV_INSERTSTRUCT     tvins;

    hitem = TreeView_GetSelection(HwndTree);
    hitemParent = TreeView_GetParent(HwndTree, hitem);
                
    tvitm.mask = TVIF_PARAM;
    tvitm.hItem = hitem;
    TreeView_GetItem(HwndTree, &tvitm);
    pitemParent = (CItem *) tvitm.lParam;
    if (pitemParent->GetType() == typeParent) {
        tvins.hParent = hitemParent;
        tvins.hInsertAfter = hitem;
        pitem = pitemParent;
        pitemParent = ((CSignData *) pitemParent)->GetParent();
    }
    else {
        tvins.hParent = hitem;
        tvins.hInsertAfter = TVI_FIRST;
        pitem = NULL;
    }
                
    tvins.item.lParam = (DWORD) pItemNew;
    pItemNew->SetParent(pitemParent);

    tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
    tvins.hInsertAfter = hitem;
    tvins.item.pszText = pszTitle;
    tvins.item.cchTextMax = strlen(pszTitle);
    tvins.item.iImage = iImage;
    tvins.item.iSelectedImage = tvins.item.iImage;

    hitem = TreeView_InsertItem(HwndTree, &tvins);
    TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
    TreeView_SelectItem(HwndTree, hitem);
    SendMessage(RgDlgs[iDlg].hwnd, UM_SET_DATA, 0, tvins.item.lParam);

    pitemParent->MakeChild((CItem *) tvins.item.lParam, pitem);
    return 0;
}

long FAR PASCAL WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
    HTREEITEM           hitem;
    HTREEITEM           hitemRoot;
    HRESULT             hr;
    int                 i;
    CItem *             pitem;
    CItem *             pitemParent;
    LPNMTREEVIEW        ptv;
    char                rgch[300];
    TV_ITEM             tvitm;
    TV_INSERTSTRUCT     tvins;
    
    switch (message) {
    case WM_CREATE:
        //  Create our child windows -- we only have one top level window so use
        //      some globals

        HdlgMsg = CreateDialog(hInst, MAKEINTRESOURCE(IDD_MSG_DATA), hwnd,
                               MsgDataDlgProc);

        HwndTree = CreateWindow(WC_TREEVIEW, "Tree", 
                                WS_CHILD | WS_CLIPCHILDREN | WS_HSCROLL | 
                                WS_VSCROLL | WS_VISIBLE | TVS_HASBUTTONS |
                                TVS_HASLINES , 0, 0, 0, 0,
                                hwnd, NULL, hInst, NULL);


        for (i=0; i<Dlg_Max; i++) {
            RgDlgs[i].hwnd = CreateDialog(hInst, MAKEINTRESOURCE(RgDlgs[i].id),
                                          hwnd, RgDlgs[i].proc);
            AssertSz(RgDlgs[i].hwnd != NULL, "Missed creating a window");
        }

        //  Initialize Tree with an item

        tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
        tvins.hParent = TVI_ROOT;
        tvins.hInsertAfter = TVI_FIRST;
        tvins.item.pszText = "Message";
        tvins.item.cchTextMax = 7;
        tvins.item.iImage = 0;
        tvins.item.iSelectedImage = tvins.item.iImage;
        tvins.item.lParam = (DWORD) &RootMsg;
            
        hitem = TreeView_InsertItem(HwndTree, &tvins);
        TreeView_SelectItem(HwndTree, hitem);

        TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
        
        //        LoadWAB();

        break;

    case WM_COMMAND :
        switch (wParam) {
        case IDM_EXIT :
            SendMessage (hwnd, WM_CLOSE, 0, 0L) ;
            return 0 ;

        case IDM_E_INSERT_SIGN:
            InsertNode("Signature Layer", 1, Dlg_Sign_Info_Compose,
                       (DWORD) new CSignInfo(STATE_COMPOSE, &RootMsg));
            return 0;

        case IDM_E_INSERT_SIGNATURE:
            pitem = new CSignData(STATE_COMPOSE);
            InsertNode2(TYPE_SIGN_DATA, "Signature", 2, Dlg_Sign_Data_Compose,
                        pitem);
            ((CSignData *) pitem)->SetDefaultCert();
            return 0;

        case IDM_E_INSERT_ENCRYPT:
            InsertNode("Encryption Layer", 3, Dlg_Enc_Info_Compose,
                       (DWORD) new CEnvData(STATE_COMPOSE, &RootMsg));
            return 0;

        case IDM_E_INSERT_TRANSPORT:
            InsertNode2(TYPE_ENV_MAILLIST, "Transport", 3, Dlg_Enc_Data_Trans_Compose, 
                        new CEnvCertTrans(STATE_COMPOSE));
            break;

        case IDM_E_INSERT_AGREEMENT:
            InsertNode2(TYPE_ENV_MAILLIST, "Agree", 3, Dlg_Enc_Data_Agree_Compose, 
                        new CEnvCertAgree(STATE_COMPOSE));
            break;

        case IDM_E_INSERT_MAILLIST:
            InsertNode2(TYPE_ENV_MAILLIST, "Mail List", 3, Dlg_Enc_Data_MailList_Compose, 
                        new CEnvMailList(STATE_COMPOSE));
            break;

        case IDM_ENCODE:
            SendMessage(RgDlgs[Dlg_Sign_Data_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Info_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Data_Agree_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Data_Trans_Compose].hwnd, UM_SET_DATA, 0, NULL);
            SendMessage(RgDlgs[Dlg_Enc_Data_MailList_Compose].hwnd, UM_SET_DATA, 0, NULL);

            for (i=0; i<RootMsg.GetIterationCount(); i++) {
                hr = RootMsg.Encode(hwnd);
                if (FAILED(hr)) {
                    wsprintf(rgch, "Encode failed with 0x%08x on iteration %d",
                             hr, i);
                    MessageBox(hwnd, rgch, szAppName, MB_OK);
                    break;
                }
                CoFreeUnusedLibraries();
            }
            SendMessage(hwnd, UM_RESET, 0, 0);
            RootMsg.ResetMessage();
            return 0;

        case IDM_DECODE:
            for (i=0; i<RootMsg.GetIterationCount(); i++) {
                SendMessage(hwnd, UM_RESET, 0, 0);
                RootMsg.ResetMessage();
                hr = RootMsg.Decode(hwnd);
                if (FAILED(hr)) {
                    wsprintf(rgch, "Decode failed with 0x%08x on iteration %d",
                             hr, i);
                    MessageBox(hwnd, rgch, szAppName, MB_OK);
                    RootMsg.ResetMessage();
                    break;
                }
                CoFreeUnusedLibraries();
            }
            SendMessage(hwnd, UM_FILL, 0, 0);
            return(0);

        case IDM_RESET:
            SendMessage(hwnd, UM_RESET, 0, 0);
            RootMsg.ResetMessage();
            return 0;

        case IDM_VALIDATE:
            for (i=0; i<Dlg_Max; i++) {
                if (IsWindowVisible(RgDlgs[i].hwnd)) {
                    SendMessage(RgDlgs[i].hwnd, message, wParam, lParam);
                    break;
                }
            }
            break;

        case IDM_F_OPTIONS:
            DialogBox(hInst, MAKEINTRESOURCE(idd_Options), hwnd, OptionsDlgProc);
            return(0);

        case IDM_F_MAILLIST:
            DialogBox(hInst, MAKEINTRESOURCE(IDD_FILE_MAILLIST), hwnd, MailListDlgProc);
            return 0;

        case IDM_ABOUT:
            MessageBox (hwnd, "S/Mime Function Test.",
                        szAppName, MB_ICONINFORMATION | MB_OK);
            return(0);
        }
        break ;

    case WM_SIZE:
        {
            int         cx = LOWORD(lParam);
            int         cy = HIWORD(lParam);

            MoveWindow(HdlgMsg, 0, 1, cx, (cy/3)-2, TRUE);
            MoveWindow(HwndTree, 0, (cy/3)+1, (cx/3-1), cy-((cy/3)+1), TRUE);

            for (i=0; i<Dlg_Max; i++) {
                MoveWindow(RgDlgs[i].hwnd, (cx/3)+1, (cy/3+1), cx-(cx/3)+1,
                           cy-((cy/3)+1), TRUE);
            }
        }
        break;

    case WM_SETFOCUS:
        SetFocus(HwndTree);
        return 0;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGEDW:
            ptv = (LPNMTREEVIEW) lParam;
            switch (((CItem *) ptv->itemNew.lParam)->GetType() | 
                    ((CItem *) ptv->itemNew.lParam)->GetState()) {
            case TYPE_SIGN_DATA | STATE_COMPOSE:
                ShowWindow(Dlg_Sign_Data_Compose, ptv->itemNew.lParam);
                break;
                
            case TYPE_SIGN_DATA | STATE_READ:
                ShowWindow(Dlg_Sign_Data_Read, ptv->itemNew.lParam);
                break;
                
            case TYPE_ENV_INFO | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Info_Compose, ptv->itemNew.lParam);
                break;
                
            case TYPE_ENV_INFO | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_ENV_AGREE | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Data_Agree_Compose, ptv->itemNew.lParam);
                break;

            case TYPE_ENV_AGREE | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_ENV_TRANS | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Data_Trans_Compose, ptv->itemNew.lParam);
                break;

            case TYPE_ENV_TRANS | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_ENV_MAILLIST | STATE_COMPOSE:
                ShowWindow(Dlg_Enc_Data_MailList_Compose, ptv->itemNew.lParam);
                break;

            case TYPE_ENV_MAILLIST | STATE_READ:
                Assert(FALSE);
                break;

            case TYPE_MSG | STATE_COMPOSE:
            case TYPE_MSG | STATE_READ:
                ShowWindow(Dlg_Message, NULL);
                break;
                
            case TYPE_SIGN_INFO | STATE_COMPOSE:
            case TYPE_SIGN_INFO | STATE_READ:
                ShowWindow(Dlg_Sign_Info_Compose, ptv->itemNew.lParam);
                break;
            }
        }
        return 0;

    case WM_INITMENU:
        tvitm.mask = TVIF_PARAM | TVIF_CHILDREN;
        tvitm.hItem = TreeView_GetSelection(HwndTree);
        TreeView_GetItem(HwndTree, &tvitm);
        i = ((CItem *) tvitm.lParam)->GetType();
        
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_SIGN, MF_BYCOMMAND |
                       (i == TYPE_SIGN_DATA) ? MF_GRAYED : MF_ENABLED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_ENCRYPT, MF_BYCOMMAND | 
                       (i == TYPE_SIGN_DATA) ? MF_GRAYED : MF_ENABLED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_SIGNATURE, MF_BYCOMMAND |
                       ((i == TYPE_SIGN_DATA) || (i == TYPE_SIGN_INFO)) ?
                       MF_ENABLED : MF_GRAYED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_INSERT_TRANSPORT, MF_BYCOMMAND |
                       ((i == TYPE_ENV_INFO) || (i == TYPE_ENV_AGREE) ||
                        (i == TYPE_ENV_TRANS) || (i == TYPE_ENV_MAILLIST)) ?
                       MF_ENABLED : MF_GRAYED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_DELETE_LAYER, MF_BYCOMMAND |
                       (((i == TYPE_SIGN_INFO) || (i == TYPE_ENV_INFO)) &&
                        (tvitm.cChildren == 0)) ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(GetMenu(hwnd), IDM_E_DELETE_SIGNATURE, MF_BYCOMMAND | 
                       (i == TYPE_SIGN_DATA) ? MF_ENABLED : MF_GRAYED);
        break;

    case WM_DESTROY:
        //      Reset the message object to have no contents
        SendMessage(hwnd, UM_RESET, 0, 0);
        RootMsg.ResetMessage();
        
        SaveOptions();

        CleanupOptions();

        //        UnloadWAB();

        for (i=0; i<Dlg_Max; i++) {
            DestroyWindow(RgDlgs[i].hwnd);
        }
        DestroyWindow(HwndTree);
        DestroyWindow(HdlgMsg);

        PostQuitMessage(0);

        return(0);

    case UM_RESET:
        hitemRoot = TreeView_GetRoot(HwndTree);
        while (TRUE) {
            TVITEM          tvitem;
                
            tvitem.hItem = TreeView_GetChild(HwndTree, hitemRoot);
            if (tvitem.hItem == NULL) {
                break;
            }
                
            tvitem.mask = TVIF_PARAM | TVIF_CHILDREN;
            TreeView_GetItem(HwndTree, &tvitem);
            if (tvitem.cChildren != 0) {
                for (i=0; i<tvitem.cChildren; i++) {
                    TVITEM      tvitem2;
                    tvitem2.hItem = TreeView_GetChild(HwndTree, tvitem.hItem);
                    tvitem2.mask = TVIF_PARAM | TVIF_CHILDREN;
                    TreeView_GetItem(HwndTree, &tvitem2);
                    delete (CItem *) tvitem2.lParam;
                    TreeView_DeleteItem(HwndTree, tvitem2.hItem);
                }
            }
            delete (CItem *) tvitem.lParam;
            TreeView_DeleteItem(HwndTree, tvitem.hItem);
        }
        
    }
    return(DefWindowProc (hwnd, message, wParam, lParam));
}


int _stdcall WinMainCRTStartup (void)
{
        int i;
        STARTUPINFOA si;
        PTSTR pszCmdLine = GetCommandLine();

        SetErrorMode(SEM_FAILCRITICALERRORS);

        if (*pszCmdLine == TEXT ('\"'))
        {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                while (*++pszCmdLine && (*pszCmdLine != TEXT ('\"')));

                // If we stopped on a double-quote (usual case), skip over it.
                if (*pszCmdLine == TEXT ('\"')) pszCmdLine++;
        }
        else
        {
                while (*pszCmdLine > TEXT (' ')) pszCmdLine++;
        }

        // Skip past any white space preceeding the second token.
        while (*pszCmdLine && (*pszCmdLine <= TEXT (' '))) pszCmdLine++;

        si.dwFlags = 0;
        GetStartupInfo (&si);

        i = WinMainT(GetModuleHandle (NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

        ExitProcess(i);

        return i;
}

//////////////////////////////////////////////////////////////////////////

void CItem::MakeChild(CItem * pChild, CItem * pAfter)
{
    if (pAfter == NULL) {
        pChild->m_pSibling = m_pChild;
        m_pChild = pChild;
    }
    else if (m_pChild == pAfter) {
        pChild->m_pSibling = pAfter;
        m_pChild = pChild;
    }
    else {
        CItem *     pItem = m_pChild;
        while (pItem != NULL) {
            if (pItem == pAfter) {
                pChild->m_pSibling = pItem->m_pSibling;
                pItem->m_pSibling = pChild;
                break;
            }
            pItem = pItem->m_pSibling;
        }
    }
}

void CItem::RemoveAsChild(CItem * pChild)
{
    if (m_pChild == pChild) {
        m_pChild = pChild->m_pSibling;
        pChild->m_pSibling = NULL;
    }
    else {
        CItem *     pItem = m_pChild;
        while (pItem != NULL) {
            if (pItem->m_pSibling == pChild) {
                pItem->m_pSibling = pChild->m_pSibling;
                pChild->m_pSibling = NULL;
                break;
            }
            pItem = pItem->m_pSibling;
        }
    }
}

HCERTSTORE CMessage::GetAllStore()
{
    HCERTSTORE  hCertStore;
    
    if (m_hCertStoreAll == NULL) {
        m_hCertStoreAll = CertOpenStore(CERT_STORE_PROV_COLLECTION,
                                        X509_ASN_ENCODING, NULL, 0, NULL);
        AssertSz(m_hCertStoreAll != NULL, "Open Collection Store");
        
        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"MY");
        AssertSz(hCertStore != NULL, "Open My Cert Store failed");
        CertAddStoreToCollection(m_hCertStoreAll, hCertStore, 0, 0);
        CertCloseStore(hCertStore, 0);

        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"AddressBook");
        AssertSz(hCertStore != NULL, "Open Address Book Cert Store failed");
        CertAddStoreToCollection(m_hCertStoreAll, hCertStore, 0, 0);
        CertCloseStore(hCertStore, 0);

        hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                      NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                      L"CA");
        AssertSz(hCertStore != NULL, "Open CA Cert Store failed");
        CertAddStoreToCollection(m_hCertStoreAll, hCertStore, 0, 0);
        CertCloseStore(hCertStore, 0);
    }

    return m_hCertStoreAll;
        
}

HCERTSTORE CMessage::GetMyStore()
{
    if (m_hCertStoreMy == NULL) {
        m_hCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                       NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                       L"MY");
        AssertSz(m_hCertStoreMy != NULL, "Open My Cert Store failed");
    }
    return m_hCertStoreMy;
}

BOOL CMessage::ResetMessage(void)
{
    BOOL        f;
    CItem *     pItem;
    CItem *     pItemNext;

    AssertSz(Head() == NULL, "Failed to release all children");
    AssertSz(Next() == NULL, "Should never have ANY siblings");

    for (pItem = Head(); pItem != NULL; pItem = pItemNext) {
        pItemNext = pItem->Next();
        delete pItem;
    }
    
    if (m_hCertStoreMy != NULL) {
        f = CertCloseStore(m_hCertStoreMy, CERT_CLOSE_STORE_CHECK_FLAG);
        if (!f) {
            AssertSz(FALSE, "My Cert store did not close completely");
        }
        m_hCertStoreMy = NULL;
    }

    return TRUE;
}


HRESULT CMessage::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm, HWND hwnd)
{
    *pulLayer = 0;

    return AddToMessage(pulLayer, pmm, hwnd, Head());
}

HRESULT CMessage::AddToMessage(DWORD * pulLayer, IMimeMessage * pmm,
                               HWND hwnd, CItem * pitem)
{
    HRESULT     hr;
    
    if (pitem == NULL) {
        return S_OK;
    }

    hr = pitem->AddToMessage(pulLayer, pmm, hwnd);
    if (FAILED(hr))     return hr;

    return AddToMessage(pulLayer, pmm, hwnd, pitem->Next());
}

HRESULT CMessage::Decode(HWND hwnd)
{
    DWORD                       cLayers;
    HBODY                       hNode;
    HRESULT                     hr;
    DWORD                       iLayer;
    PCCERT_CONTEXT              pccert = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeBody *                 pmbReceipt = NULL;
    IMimeMessage *              pmm = NULL;
    IMimeMessage *              pmmReceipt = NULL;
    IMimeSecurity *             pms = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    IPersistFile *              pfile = NULL;
    IPersistFile *              pfileOut = NULL;
    WCHAR                       rgchW[MAX_PATH];
    DWORD *                     rgdwSecurityType = NULL;
    DWORD *                     rgdwValidity = NULL;
    PCCERT_CONTEXT *            rgpccert = NULL;
    PROPVARIANT *               rgpvAlgHash = NULL;
    ULONG                       ulType;
    PROPVARIANT                 var;
    
    //  Build the message tree and attach the input file
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER,
                          IID_IMimeMessage, (LPVOID *) &pmm);
    if (FAILED(hr))             goto exit;
    hr = pmm->InitNew();
    if (FAILED(hr))             goto exit;

    //  Load the file
    hr = pmm->QueryInterface(IID_IPersistFile, (LPVOID *) &pfile);
    if (FAILED(hr))             goto exit;

    MultiByteToWideChar(CP_ACP, 0, GetCipherFile(), -1,
                        rgchW, sizeof(rgchW)/sizeof(rgchW[0]));
    
    hr = pfile->Load(rgchW, STGM_READ | STGM_SHARE_EXCLUSIVE);
    if (FAILED(hr))             goto exit;

    //
    //  Try using the IMimeSecurity2 interface if it exists and will work

    hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
    if (FAILED(hr)) {
        if (hr == E_NOINTERFACE)        goto TryOldCode;
        goto exit;
    }

    hr = pms2->Decode(hwnd, 0, this);
    if (FAILED(hr)) {
        if (hr != E_FAIL)               goto exit;

    TryOldCode:
        //  Start up the S/MIME engine
        hr = CoCreateInstance(CLSID_IMimeSecurity, NULL, CLSCTX_INPROC_SERVER,
                              IID_IMimeSecurity, (LPVOID *) &pms);
        if (FAILED(hr))             goto exit;
        hr = pms->InitNew();
        if (FAILED(hr))             goto exit;

        //  Bind in the HWND
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;

        var.vt = VT_UI4;
        var.ulVal = (DWORD) hwnd;
        hr = pmb->SetOption(OID_SECURITY_HWND_OWNER, &var);
        if (FAILED(hr))             goto exit;

        pmb->Release();             pmb = NULL;

        //  Now decode the message
        hr = pms->DecodeMessage(pmm, 0);
        if (FAILED(hr))             goto exit;
    }

    //

    hNode = HBODY_ROOT;


    while (TRUE) {
        hr = pmm->BindToObject(hNode, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;

        //  Create the fun objects from the properties

        hr = pmb->GetOption(OID_SECURITY_TYPE, &var);
        if (FAILED(hr))         goto exit;
        ulType = var.ulVal;

        if (ulType & MST_THIS_SIGN) {
            HTREEITEM           hitem;
            TV_INSERTSTRUCT     tvins;

            CSignInfo *         psi = new CSignInfo(STATE_READ, &RootMsg);
            CSignData *         psd = new CSignData(STATE_READ);
            psd->SetParent(psi);
            tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
            tvins.hParent = TreeView_GetRoot(HwndTree);
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = "Signature Layer";
            tvins.item.cchTextMax = 15;
            tvins.item.iImage = 1;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (DWORD) psi;
            
            if (ulType & MST_BLOB_FLAG) {
                psi->m_fBlob = TRUE;
            }

            hitem = TreeView_InsertItem(HwndTree, &tvins);
            TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);

            tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
            tvins.hParent = hitem;
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = "Signature";
            tvins.item.cchTextMax = 15;
            tvins.item.iImage = 2;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (DWORD) psd;

            TreeView_InsertItem(HwndTree, &tvins);
            TreeView_Expand(HwndTree, tvins.hParent, TVE_EXPAND);
            
            hr = pmb->GetOption(OID_SECURITY_RO_MSG_VALIDITY, &var);
            if (FAILED(hr))     goto exit;
            psd->m_ulValidity = var.ulVal;
            

            //            hr = pmb->GetOption(OID_SECURITY_HCERTSTORE, &var);
            //            if (FAILED(hr))     goto exit;

            hr = pmb->GetOption(OID_SECURITY_CERT_SIGNING, &var);
            if (FAILED(hr))     goto exit;
            psd->m_pccert = (PCCERT_CONTEXT) var.ulVal;

            //            hr = pmb->GetOption(OID_SECURITY_ALG_HASH, &var);
            //            if (FAILED(hr))     goto exit;
        }

        if (ulType & MST_THIS_ENCRYPT) {
            HTREEITEM           hitem;
            TV_INSERTSTRUCT     tvins;

            CEnvData *          ped = new CEnvData(STATE_READ, &RootMsg);
            tvins.item.mask = TVIF_TEXT | TVIF_PARAM;
            tvins.hParent = TreeView_GetRoot(HwndTree);
            tvins.hInsertAfter = TVI_LAST;
            tvins.item.pszText = "Envelope";
            tvins.item.cchTextMax = 15;
            tvins.item.iImage = 1;
            tvins.item.iSelectedImage = tvins.item.iImage;
            tvins.item.lParam = (DWORD) ped;
            
            hitem = TreeView_InsertItem(HwndTree, &tvins);

            hr = pmb->GetOption(OID_SECURITY_CERT_DECRYPTION, &var);
            if (FAILED(hr))     goto exit;
            Assert(FALSE);
            //            ped->m_pccert = (PCCERT_CONTEXT) var.ulVal;
        }

        if (ulType & MST_RECEIPT_REQUEST) {
            CERT_ALT_NAME_ENTRY     rgNames[1];
            CERT_ALT_NAME_INFO      myNames = {1, rgNames};

            rgNames[0].dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
            rgNames[0].pwszRfc822Name = L"jimsch@microsoft.com";
        
            if (HCertStoreMy == NULL) {
                HCertStoreMy = CertOpenStore(CERT_STORE_PROV_SYSTEM, X509_ASN_ENCODING,
                                             NULL, CERT_SYSTEM_STORE_CURRENT_USER,
                                             L"MY");
                if (HCertStoreMy == NULL)   goto exit;
            }
            if (SignHash.cbData != 0) {
                pccert = CertFindCertificateInStore(HCertStoreMy,
                                                    X509_ASN_ENCODING, 0,
                                                    CERT_FIND_SHA1_HASH,
                                                    &SignHash, NULL);
                if (pccert == NULL)         goto exit;
            }
        
            //            hr = MimeOleCreateReceipt(pmm, pccert, hwnd, &pmmReceipt,
            //                                      &myNames);
            if (FAILED(hr))         goto exit;

            //  Get the root body
            hr = pmmReceipt->BindToObject(HBODY_ROOT, IID_IMimeBody,
                                          (LPVOID *) &pmbReceipt);
            if (FAILED(hr))             goto exit;

            //  Set the HWND for CAPI calls
            var.vt = VT_UI4;
            var.ulVal = (ULONG) hwnd;
            hr = pmbReceipt->SetOption(OID_SECURITY_HWND_OWNER, &var);
            if (FAILED(hr))             goto exit;

            var.vt = VT_UI4;
            var.ulVal = MST_THIS_SIGN | MST_THIS_BLOBSIGN;
            hr = pmbReceipt->SetOption(OID_SECURITY_TYPE, &var);
            if (FAILED(hr))             goto exit;

            var.vt = VT_BLOB;
            var.blob.pBlobData = (LPBYTE) RgbSHA1AlgId;
            var.blob.cbSize = CbSHA1AlgId;
            hr = pmbReceipt->SetOption(OID_SECURITY_ALG_HASH, &var);
            if (FAILED(hr))             goto exit;

            var.vt = VT_UI4;
            var.ulVal = (ULONG) pccert;
            hr = pmbReceipt->SetOption(OID_SECURITY_CERT_SIGNING, &var);

            if (hr == S_OK) {
                hr = pmmReceipt->QueryInterface(IID_IPersistFile, (LPVOID *) &pfileOut);
                if (FAILED(hr))         goto exit;

                hr = pfileOut->Save(L"c:\\receipt.eml", FALSE);
                if (FAILED(hr))         goto exit;
            }
            pmbReceipt->Release();
        }

        if (pmb->IsContentType(STR_CNT_MULTIPART, "y-security") != S_OK) {
            break;
        }

        if (hNode == HBODY_ROOT) {
            pmb->GetHandle(&hNode);
        }
        pmb->Release();         pmb = NULL;
        hr = pmm->GetBody(IBL_FIRST, hNode, &hNode);
        if (FAILED(hr))                 goto exit;
    }
            


    hr = S_OK;
exit:
    if (pfileOut != NULL)       pfileOut->Release();
    if (pfile != NULL)          pfile->Release();
    if (pmb != NULL)            pmb->Release();
    if (pms != NULL)            pms->Release();
    if (pmm != NULL)            pmm->Release();
    if (pmmReceipt != NULL)     pmmReceipt->Release();
    if (pccert != NULL)         CertFreeCertificateContext(pccert);

    return hr;
}

HRESULT CMessage::Encode(HWND hwnd)
{
    DWORD                       cLayers;
    HBODY                       hbody;
    HRESULT                     hr;
    HCERTSTORE                  hstore = NULL;
    IImnAccount *               pAccount = NULL;
    PCCERT_CONTEXT              pccertEncrypt = NULL;
    LPSTR                       pchBody;
    IPersistFile *              pfileIn = NULL;
    IPersistFile *              pfileOut = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeMessage *              pmm = NULL;
    IMimeSecurity *             pms = NULL;
    IMimeSecurity2 *            pms2 = NULL;
    LPSTREAM                    pstmBody = NULL;
    LPSTREAM                    pstmFile = NULL;
    WCHAR                       rgchW[CCH_OPTION_STRING];
    DWORD                       ulLayers = 0;
    PROPVARIANT                 var;

    //  Build the message tree and attach the body
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER,
                         IID_IMimeMessage, (LPVOID *) &pmm);
    if (FAILED(hr))     goto exit;

    hr = pmm->InitNew();
    if (FAILED(hr))     goto exit;

    pchBody = GetPlainFile();
    if ((*pchBody == 0) || (_stricmp(pchBody, "<none>") == 0)) {
        //  Create the body stream
        hr = CreateStreamOnHGlobal( NULL, TRUE, &pstmBody);
        if (FAILED(hr))     goto exit;
        hr = pstmBody->Write(RgchBody, lstrlen(RgchBody), NULL);
        if (FAILED(hr))     goto exit;

        //  Attach the body to the message
        hr = pmm->SetTextBody(TXT_PLAIN, IET_8BIT, NULL, pstmBody, &hbody);
        if (FAILED(hr))         goto exit;

        //
    }
    else if (_stricmp(pchBody, "<example>") == 0) {
        //  Create the body stream
        hr = CreateStreamOnHGlobal( NULL, TRUE, &pstmBody);
        if (FAILED(hr))     goto exit;
        hr = pstmBody->Write(RgchExample, lstrlen(RgchExample), NULL);
        if (FAILED(hr))     goto exit;

        //  Get the root body
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;
        
        hr = pmb->SetData(IET_BINARY, "OID", szOID_RSA_data,
                          IID_IStream, pstmBody);
        if (FAILED(hr))         goto exit;

        pmb->Release();         pmb = NULL;
    }
    else {
        MultiByteToWideChar(CP_ACP, 0, pchBody, -1,
                            rgchW, sizeof(rgchW)/sizeof(rgchW[0]));
        //  Load the file
        hr = pmm->QueryInterface(IID_IPersistFile, (LPVOID *) &pfileIn);
        if (FAILED(hr))             goto exit;
        hr = pfileIn->Load(rgchW, STGM_READ | STGM_SHARE_EXCLUSIVE);
        if (FAILED(hr))             goto exit;
    }

    var.vt = VT_BOOL;
    var.boolVal = TRUE;
    hr = pmm->SetOption(OID_SAVEBODY_KEEPBOUNDARY, &var);
    if (hr) goto exit;

    //  Find out what goes where for initialization
    hr = AddToMessage(&cLayers, pmm, hwnd);
    if (FAILED(hr))     goto exit;

    if (1) {
        hr = pmm->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms2);
        if (FAILED(hr))             goto exit;

        hr = pms2->Encode(hwnd, SEF_SENDERSCERTPROVIDED |
                          SEF_ENCRYPTWITHNOSENDERCERT);
        if (FAILED(hr))             goto exit;

        pms2->Release();            pms2 = NULL;
    }
    else {
        //  Get the root body
        hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
        if (FAILED(hr))             goto exit;

        //  Set the HWND for CAPI calls
        var.vt = VT_UI4;
        var.ulVal = (ULONG) hwnd;
        hr = pmb->SetOption(OID_SECURITY_HWND_OWNER, &var);
        if (FAILED(hr))             goto exit;

        pmb->Release();             pmb = NULL;

        //  Sometimes we must force the encode outside of the Save call

        if (1) {
            hr = CoCreateInstance(CLSID_IMimeSecurity, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IMimeSecurity, (LPVOID *) &pms);
            if (FAILED(hr))         goto exit;
            hr = pms->InitNew();
            if (FAILED(hr))         goto exit;

            hr = pms->EncodeBody(pmm, HBODY_ROOT, EBF_RECURSE | 
                                 SEF_SENDERSCERTPROVIDED |
                                 SEF_ENCRYPTWITHNOSENDERCERT |
                                 EBF_COMMITIFDIRTY);
            if (FAILED(hr))         goto exit;

            pms->Release();         pms = NULL;
        }
    }

    //  Set the subject
    var.vt = VT_LPSTR;
    var.pszVal = "Test subject";
    hr = pmm->SetBodyProp(HBODY_ROOT, STR_HDR_SUBJECT, 0, &var);
    if (FAILED(hr))     goto exit;

    //  Deal with either dump to file or send via SMTP

    if (m_fToFile) {
        //  Dump to a file
        hr = pmm->QueryInterface(IID_IPersistFile, (LPVOID *) &pfileOut);
        if (FAILED(hr))             goto exit;

        MultiByteToWideChar(CP_ACP, 0, GetCipherFile(), -1,
                            rgchW, sizeof(rgchW)/sizeof(rgchW[0]));
        hr = pfileOut->Save(rgchW, FALSE);
        if (FAILED(hr))             goto exit;
    }
    else {
        SMTPMESSAGE             rMessage = {0};
        INETSERVER              rServer;
        char                    szAccount[] = "SMimeTst";
        INETADDR                rgAddress[11];

        if (PAcctMan == NULL) {
            hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IImnAccountManager, (LPVOID *) &PAcctMan);
            if (FAILED(hr))     goto exit;
            hr = PAcctMan->Init(NULL);
            if (FAILED(hr))     goto exit;
        }

        if (PSmtp == NULL) {
            // Create smtp transport
            hr = HrCreateSMTPTransport(&PSmtp);
            if (FAILED(hr))     goto exit;
        }

        memset(&rgAddress, 0, sizeof(rgAddress));

        rMessage.rAddressList.prgAddress = rgAddress;
        rMessage.rAddressList.cAddress = 2;
        
        strcpy(rgAddress[0].szEmail, szSenderEmail);
        rgAddress[0].addrtype = ADDR_FROM;

        strcpy(rgAddress[1].szEmail, szRecipientEmail);
        rgAddress[1].addrtype = ADDR_TO;

        pmm->GetMessageSource(&rMessage.pstmMsg, 0);
        pmm->GetMessageSize(&rMessage.cbSize, 0);

        hr = PAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount);
        if (FAILED(hr))         goto exit;

        hr = PSmtp->InetServerFromAccount(pAccount, &rServer);
        if (FAILED(hr))         goto exit;

        hr = PSmtp->Connect(&rServer, TRUE, TRUE);
        if (FAILED(hr))         goto exit;

        WaitForCompletion(MsgSMTP, SMTP_CONNECTED);
        pAccount->Release();    pAccount = NULL;

        hr = PSmtp->SendMessage(&rMessage);
        WaitForCompletion(MsgSMTP, SMTP_SEND_MESSAGE);

        hr = PSmtp->CommandQUIT();
        if (FAILED(hr))         goto exit;
        WaitForCompletion(MsgSMTP, SMTP_QUIT);
    }
    
    hr = NULL;
exit:
    if (pAccount != NULL)       pAccount->Release();
    if (pfileIn != NULL)        pfileIn->Release();
    if (pfileOut != NULL)       pfileOut->Release();
    if (pstmBody != NULL)       pstmBody->Release();
    if (pstmFile != NULL)       pstmFile->Release();
    if (pms2 != NULL)           pms2->Release();
    if (pms != NULL)            pms->Release();
    if (pmb != NULL)            pmb->Release();
    if (pmm != NULL)            pmm->Release();
    return hr;
}

STDMETHODIMP CMessage::QueryInterface(REFIID riid, LPVOID *ppv)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG) CMessage::AddRef(void)
{
    return E_FAIL;
}

STDMETHODIMP_(ULONG) CMessage::Release(void)
{
    return E_FAIL;
}

STDMETHODIMP CMessage::FindKeyFor(HWND hwnd, DWORD dwFlags, DWORD dwRecipIndex,
                                  const CMSG_CMS_RECIPIENT_INFO * pRecipInfo,
                                  DWORD * pdwCtrl, CMS_CTRL_DECRYPT_INFO * pDecryptInfo,
                                  PCCERT_CONTEXT * ppcert)
{
    //  Only support mail list recipients
    if (pRecipInfo->dwRecipientChoice != CMSG_MAIL_LIST_RECIPIENT) {
        return S_FALSE;
    }

    *pdwCtrl = CMSG_CTRL_MAIL_LIST_DECRYPT;
    return CMailListKey::FindKeyFor(hwnd, dwFlags, dwRecipIndex,
                                    pRecipInfo, pDecryptInfo);
}

STDMETHODIMP CMessage::GetParameters(PCCERT_CONTEXT, LPVOID, DWORD *, LPBYTE *)
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\logwatch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LogWatch.rc
//
#define IDD_LOGWATCH                    101
#define IDC_EDIT                        102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\badata.cpp ===
// badata.cpp: implementation of the CAddressBook class.
// WAB & Messenger integration to OE
// Created 04/20/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include <shfusion.h>
#include "bactrl.h"
#include "badata.h"
#include "baui.h"
#include "baprop.h"
#include "ourguid.h"
#include "mapiguid.h"
#include "shlwapip.h" 
#include "ipab.h"
#include "multiusr.h"
#include "demand.h"
#include "secutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// Defines for the various MAPI Tables we request from the WAB
//////////////////////////////////////////////////////////////////////

#define MAX_QUERY_SIZE 1000

// Here are some private properties that the WAB stores.  If WAB ever
// changes any of these we're in trouble.

#define WAB_INTERNAL_BASE       0x6600
#define PR_WAB_LDAP_SERVER      PROP_TAG(PT_TSTRING,    WAB_INTERNAL_BASE + 1)
#define PR_WAB_RESOLVE_FLAG     PROP_TAG(PT_BOOLEAN,    WAB_INTERNAL_BASE + 2)


// This BA's private GUID:
// {2BAD7EE0-36AB-11d1-9BAC-00A0C91F9C8B}
static const GUID WAB_ExtBAGuid = 
{ 0x2bad7ee0, 0x36ab, 0x11d1, { 0x9b, 0xac, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMsgrPropNames[] = 
{   
    "MsgrID"
};

enum _MsgrTags
{
    MsgrID = 0,
    msgrMax
};

ULONG MsgrPropTags[msgrMax];
ULONG PR_MSGR_DEF_ID = 0;


// These two define the table we request from the WAB when showing the
// contents of the local address book.

enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidPR_OBJECT_TYPE,
    ieidPR_MSGR_DEF_ID,
//    ieidPR_BUSINESS_TELEPHONE_NUMBER,
    ieidPR_EMAIL_ADDRESS, 
    ieidPR_USER_X509_CERTIFICATE,
    ieidPR_RECORD_KEY,
    ieidMax
};

static SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_MSGR_DEF_ID,
//        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_EMAIL_ADDRESS, 
        PR_USER_X509_CERTIFICATE,
        PR_RECORD_KEY
    }
};


// These two define the table we request to see which LDAP servers should
// be resolved against.
enum {
    irnPR_OBJECT_TYPE = 0,
    irnPR_WAB_RESOLVE_FLAG,
    irnPR_ENTRYID,
    irnPR_DISPLAY_NAME,
    irnMax
};

static const SizedSPropTagArray(irnMax, irnColumns) =
{
    irnMax,
    {
        PR_OBJECT_TYPE,
        PR_WAB_RESOLVE_FLAG,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};


enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};

const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAddressBookData::CAddressBookData()
{
    m_pWABObject = NULL;
    m_hInstWAB = NULL;
    m_pAdrBook = NULL;
    m_ulConnection = 0;
}


CAddressBookData::~CAddressBookData()
{
    // Release the Address Book pointer
    if (m_pAdrBook)
        m_pAdrBook->Release();

    // Release the WAB object
    if (m_pWABObject)
        m_pWABObject->Release();

    if (m_hInstWAB)
        FreeLibrary(m_hInstWAB);
}



//
//  FUNCTION:   CAddressBookData::OpenWabFile()
//
//  PURPOSE:    Finds the WAB DLL, loads the DLL, and opens the WAB.
//
HRESULT CAddressBookData::OpenWabFile(void)
{
    TCHAR       szDll[MAX_PATH];
    TCHAR       szExpanded[MAX_PATH];
    DWORD       dwType = 0;
    LPTSTR      psz = szDll;
    ULONG       cbData = sizeof(szDll);
    HKEY        hKey = NULL;
    HRESULT     hr = E_FAIL;
    LPWABOPEN   lpfnWABOpen;

    // Initialize the path string
    *szDll = '\0';

    // First look under the default WAB DLL path location in the Registry.
    // WAB_DLL_PATH_KEY is defined in wabapi.h
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, _T(""), NULL, &dwType, (LPBYTE) szDll, &cbData))
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szDll, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }

        RegCloseKey(hKey);
    }

    // If the registry thing came up blank, then do a LoadLibrary on wab32.dll
    m_hInstWAB = LoadLibrary((lstrlen(psz)) ? (LPCTSTR) psz : (LPCTSTR) WAB_DLL_NAME);

    if (m_hInstWAB)
    {
        // If we've got the DLL, then get the entry point
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstWAB, "WABOpen");

        if (lpfnWABOpen)
        {
            WAB_PARAM       wp = {0};
            wp.cbSize = sizeof(WAB_PARAM);
            wp.guidPSExt = CLSID_OEBAControl;
            wp.ulFlags = (g_dwAthenaMode & MODE_NEWSONLY) ? WAB_ENABLE_PROFILES : WAB_ENABLE_PROFILES | WAB_USE_OE_SENDMAIL;
            hr = lpfnWABOpen(&m_pAdrBook, &m_pWABObject, &wp, 0);
        }
    }

    return (hr);
}



//
//  FUNCTION:   CAddressBookData::LoadWabContents()
//
//  PURPOSE:    Loads the contents of the WAB into the provided ListView control.
//
//  PARAMETERS: 
//      [in] ctlList - Pointer to the ListView control to load the WAB into.
//
HRESULT CAddressBookData::LoadWabContents(CContainedWindow& ctlList, CMsgrAb *pSink)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPTSTR     *lppszArray = NULL;
    ULONG       cRows = 0;
    LPSRowSet   lpRow = NULL;
    LPSRowSet   lpRowAB = NULL;
    LPABCONT    lpContainer = NULL;
    int         cNumRows = 0;
    int         nRows = 0;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;
    LPSRowSet   pSRowSet = NULL;

    Assert(m_pAdrBook);
    if (!m_pAdrBook)
        return E_UNEXPECTED;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    if(!PR_MSGR_DEF_ID)
        InitNamedProps();

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
        goto exit;

    if(pSink)
        m_pAB = pSink;

    if (pSink && !m_ulConnection)
        m_pAdrBook->Advise(lpcbEID, lpEID, fnevObjectModified, (IMAPIAdviseSink *) pSink, &m_ulConnection);

    // Get a contents table of all the contents in the WABs root container.
    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS /*0*/, &lpAB);
    if(HR_FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = lpAB->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Reset to the beginning of the table
    hr = lpAB->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
    if(HR_FAILED(hr))
        goto exit;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(lpAB, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;
    
    // Fill the provided ListView with this table
    _FillListFromTable(ctlList, pSRowSet);

exit:
    if (lpEID)
        m_pWABObject->FreeBuffer(lpEID);

    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (lpContainer)
        lpContainer->Release();

    if (lpAB)
        lpAB->Release();

    return hr;
}


HRESULT CAddressBookData::DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList)
{
    // Build a restriction based on the given text
    SRestriction SRes;
    if (SUCCEEDED(_GetLDAPSearchRestriction(pszText, &SRes)))
    {
        // Figure out what the entry ID is for the LDAP container
        ULONG     cbEntryID = 0;
        LPENTRYID pEntryID = 0;

        if (SUCCEEDED(_GetLDAPContainer(&cbEntryID, &pEntryID)))
        {
            // Perform the search
            SORT_INFO si = {0, 0};
            _GetLDAPContentsList(cbEntryID, pEntryID, si, &SRes, ctlList);

            if (pEntryID)
                m_pWABObject->FreeBuffer(pEntryID);

        }

        if (SRes.res.resAnd.lpRes)
            m_pWABObject->FreeBuffer(SRes.res.resAnd.lpRes);
    }

    return (S_OK);
}
    
    
void CAddressBookData::_FreeProws(LPSRowSet prows)
{
    if (prows)
    {
        for (ULONG irow = 0; irow < prows->cRows; ++irow)
            m_pWABObject->FreeBuffer(prows->aRow[irow].lpProps);

        m_pWABObject->FreeBuffer(prows);
    }
}


//
//  FUNCTION:   CAddressBookData::_MergeRowSets()
//
//  PURPOSE:    Merges prows with *pprowsDst, reallocating *pprowsDst if 
//              necessary.  Destroys the container portion of prows (but not 
//              the individual rows it contains).
//
//  PARAMETERS: 
//      [in]       prows     - source set of rows
//      [in, out] *pprowsDst - set of rows to merge the prows into 
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CAddressBookData::_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst)
{
    SCODE       sc = S_OK;
    LPSRowSet   prowsT;
    UINT        crowsSrc;
    UINT        crowsDst;

    _ASSERTE(!IsBadWritePtr(pprowsDst, sizeof(LPSRowSet)));
    _ASSERTE(prows);

    // If the table is completely empty we want to return this.
    if (!*pprowsDst || (*pprowsDst)->cRows == 0)
    {
        m_pWABObject->FreeBuffer(*pprowsDst);
        *pprowsDst = prows;
        prows = NULL;                           // Don't free it!
        goto exit;
    }

    if (prows->cRows == 0)
    {
        goto exit;
    }

    // OK, now we know there are rows in both rowsets, we have to do a real 
    // merge.
    crowsSrc = (UINT) prows->cRows;
    crowsDst = (UINT) (*pprowsDst)->cRows;      //  handle 0

    if (FAILED(sc = m_pWABObject->AllocateBuffer(CbNewSRowSet(crowsSrc + crowsDst), (LPVOID*) &prowsT)))
        goto exit;
    if (crowsDst)
        CopyMemory(prowsT->aRow, (*pprowsDst)->aRow, crowsDst * sizeof(SRow));
    CopyMemory(&prowsT->aRow[crowsDst], prows->aRow, crowsSrc * sizeof(SRow));
    prowsT->cRows = crowsSrc + crowsDst;

    m_pWABObject->FreeBuffer(*pprowsDst);
    *pprowsDst = prowsT;

exit:
    // if (prows)
    //     m_pWABObject->FreeBuffer(&prows);

    return ResultFromScode(sc);
}


/*
 -	HrQueryAllRows
 -	
 *	Purpose:
 *		Retrieves all rows from an IMAPITable interface up to a set
 *		maximum. It will optionally set the column set, sort order,
 *		and restriction on the table before querying.
 *	
 *		If the table is empty, an SRowSet with zero rows is
 *		returned (just like QueryRows).
 *	
 *		The seek position of the table is undefined both before and
 *		after this call.
 *	
 *		If the function fails with an error other than
 *		MAPI_E_NOT_ENOUGH_MEMORY, extended error information is
 *		available through the table interface.
 *	
 *	Arguments:
 *		ptable		in		the table interface to query
 *		ptaga		in		if not NULL, column set for the table
 *		pres		in		if not NULL, restriction to be applied
 *		psos		in		if not NULL, sort order to be applied
 *		crowsMax	in		if nonzero, limits the number of rows
 *							to be returned.
 *		pprows		out		all rows of the table
 *	
 *	Returns:
 *		HRESULT. Extended error information normally is in the
 *		table.
 *	
 *	Side effects:
 *		Seek position of table is undefined.
 *	
 *	Errors:
 *		MAPI_E_TABLE_TOO_BIG if the table contains more than
 *		cRowsMax rows.
 */
HRESULT CAddressBookData::_QueryAllRows(LPMAPITABLE ptable,
	                                LPSPropTagArray ptaga, 
                                    LPSRestriction pres, 
                                    LPSSortOrderSet psos,
	                                LONG crowsMax, 
                                    LPSRowSet FAR *pprows)
{
	HRESULT		hr;
	LPSRowSet	prows = NULL;
	UINT		crows = 0;
	LPSRowSet	prowsT=NULL;
	UINT		crowsT;

	*pprows = NULL;

	// Set up the table, if the corresponding setup parameter is present.
	if (ptaga && FAILED(hr = ptable->SetColumns(ptaga, TBL_BATCH)))
		goto exit;
	if (pres && FAILED(hr = ptable->Restrict(pres, TBL_BATCH)))
		goto exit;
	if (psos && FAILED(hr = ptable->SortTable(psos, TBL_BATCH)))
		goto exit;

	// Set position to beginning of the table.
	if (FAILED(hr = ptable->SeekRow(BOOKMARK_BEGINNING, 0, NULL)))
		goto exit;

	if (crowsMax == 0)
		crowsMax = 0xffffffff;

	for (;;)
	{
		prowsT = NULL;

		// Retrieve some rows. Ask for the limit.
		hr = ptable->QueryRows(crowsMax, 0, &prowsT);
		if (FAILED(hr))
		{
			// Note: the failure may actually have happened during one of the 
            // setup calls, since we set TBL_BATCH.
			goto exit;
		}
		_ASSERTE(prowsT->cRows <= 0xFFFFFFFF);
		crowsT = (UINT) prowsT->cRows;

		// Did we get more rows than caller can handle?
		if ((LONG) (crowsT + (prows ? prows->cRows : 0)) > crowsMax)
		{
			hr = ResultFromScode(MAPI_E_TABLE_TOO_BIG);
			//_FreeProws(prowsT);
			goto exit;
		}

		// Add the rows just retrieved into the set we're building.		
        //
        // NOTE: this handles boundary conditions including either row set is 
        // empty.
        // 
		// NOTE: the merge destroys prowsT.
		if (FAILED(hr = _MergeRowSets(prowsT, &prows)))
			goto exit;

		// Did we hit the end of the table? Unfortunately, we have to ask twice 
        // before we know.
		if (crowsT == 0)
			break;
	}

    if(prows->cRows != 0)
	    *pprows = prows;

exit:
    if (prowsT)
        _FreeProws(prowsT);

	if (FAILED(hr))
		_FreeProws(prows);

	return hr;
}


HRESULT CAddressBookData::_GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID)
{
    ULONG           ulObjectType = 0;
    IABContainer   *pRoot = 0;
    LPMAPITABLE     pRootTable = 0;
    HRESULT         hr = S_OK;

    // Get the root Address Book container
    hr = m_pAdrBook->OpenEntry(0, NULL, NULL, 0, &ulObjectType, (LPUNKNOWN *) &pRoot);
    if (FAILED(hr))
        goto exit;

    // From the address book container, get a table of it's contents
    hr = pRoot->GetContentsTable(0, &pRootTable);
    if (FAILED(hr))
        goto exit;

    // Set the columns
    pRootTable->SetColumns((LPSPropTagArray) &irnColumns, 0);

    // Build a restriction to only display LDAP servers that we're supposed
    // to resolve against.
    SRestriction resAnd[2];         // 0 = LDAP, 1 = ResolveFlag
    SRestriction resLDAPResolve;
    SPropValue   ResolveFlag;

    // Restrict: Only show LDAP containers with Resolve TRUE
    resAnd[0].rt = RES_EXIST;
    resAnd[0].res.resExist.ulReserved1 = 0;
    resAnd[0].res.resExist.ulReserved2 = 0;
    resAnd[0].res.resExist.ulPropTag = PR_WAB_LDAP_SERVER;

    ResolveFlag.ulPropTag = PR_WAB_RESOLVE_FLAG;
    ResolveFlag.Value.b = TRUE;

    resAnd[1].rt = RES_PROPERTY;
    resAnd[1].res.resProperty.relop = RELOP_EQ;
    resAnd[1].res.resProperty.ulPropTag = PR_WAB_RESOLVE_FLAG;
    resAnd[1].res.resProperty.lpProp = &ResolveFlag;

    resLDAPResolve.rt = RES_AND;
    resLDAPResolve.res.resAnd.cRes = 2;
    resLDAPResolve.res.resAnd.lpRes = resAnd;

    // Apply the restruction
    hr = pRootTable->Restrict(&resLDAPResolve, 0);
    if (HR_FAILED(hr))
        goto exit;

    // We're going to just blindly grab the first item in this table as the
    // LDAP container we're going to use.
    LPSRowSet pRowSet;
    hr = pRootTable->QueryRows(1, 0, &pRowSet);
    if (FAILED(hr))
        goto exit;

    // Grab the size of the entry id
    *pcbEntryID = pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.cb;

    // Make a copy of the entry id
    hr = m_pWABObject->AllocateBuffer(*pcbEntryID, (LPVOID *) ppEntryID);
    if (FAILED(hr))
        goto exit;

    CopyMemory(*ppEntryID, pRowSet->aRow[0].lpProps[irnPR_ENTRYID].Value.bin.lpb, 
               *pcbEntryID);

exit:
    if (pRootTable)
        pRootTable->Release();

    if (pRoot)
        pRoot->Release();

    if (pRowSet)
        _FreeProws(pRowSet);

    return (hr);
}


HRESULT CAddressBookData::_GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes)
{
    SRestriction    SRes = { 0 };
    LPSRestriction  lpPropRes = NULL;
    ULONG           ulcPropCount = 0;
    HRESULT         hr = E_FAIL;
    ULONG           i = 0;
    SCODE           sc = ERROR_SUCCESS;
    LPSPropValue    lpPropArray = NULL;


    if (!lstrlen(pszText))
    {
        ATLTRACE(_T("No Search Props"));
        goto exit;
    }

    lpSRes->rt = RES_AND;
    lpSRes->res.resAnd.cRes = 1;

    // Allocate a buffer for the restriction
    lpSRes->res.resAnd.lpRes = NULL;
    sc = m_pWABObject->AllocateBuffer(1 * sizeof(SRestriction), 
                                      (LPVOID *) &(lpSRes->res.resAnd.lpRes));
    if (S_OK != sc || !(lpSRes->res.resAnd.lpRes))
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropRes = lpSRes->res.resAnd.lpRes;

    // Create the first part of the OR clause
    lpPropRes[0].rt = RES_PROPERTY;
    lpPropRes[0].res.resProperty.relop = RELOP_EQ;
    lpPropRes[0].res.resProperty.ulPropTag = PR_EMAIL_ADDRESS;

    lpPropRes[0].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[0].res.resProperty.lpProp));
    lpPropArray = lpPropRes[0].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_EMAIL_ADDRESS;
    lpPropArray->Value.LPSZ = NULL;

    m_pWABObject->AllocateMore(lstrlen(pszText) + 1, lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpy(lpPropArray->Value.LPSZ, pszText);

#if 0
    // Add the second OR clause
    lpPropRes[1].rt = RES_PROPERTY;
    lpPropRes[1].res.resProperty.relop = RELOP_EQ;
    lpPropRes[1].res.resProperty.ulPropTag = PR_DISPLAY_NAME;

    lpPropRes[1].res.resProperty.lpProp = NULL;
    m_pWABObject->AllocateMore(sizeof(SPropValue), lpPropRes, (LPVOID*) &(lpPropRes[1].res.resProperty.lpProp));
    lpPropArray = lpPropRes[1].res.resProperty.lpProp;
    if (!lpPropArray)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpPropArray->ulPropTag = PR_DISPLAY_NAME;
    lpPropArray->Value.LPSZ = NULL;

    m_pWABObject->AllocateMore(lstrlen(pszText) + 1, lpPropRes, (LPVOID *) &(lpPropArray->Value.LPSZ));
    if (!lpPropArray->Value.LPSZ)
    {
        ATLTRACE("MAPIAllocateBuffer Failed");
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpy(lpPropArray->Value.LPSZ, pszText);
#endif

    hr = S_OK;

exit:
    return hr;
}


HRESULT CAddressBookData::_GetLDAPContentsList(ULONG cbContainerEID,
                                           LPENTRYID pContainerEID,
                                           SORT_INFO rSortInfo,
                                           LPSRestriction pPropRes,
                                           CContainedWindow& ctlList)
{
    HRESULT          hr = S_OK;
    HRESULT          hrTemp;
    ULONG            ulObjectType = 0;
    LPMAPICONTAINER  pContainer = NULL;
    LPMAPITABLE      pContentsTable = NULL;
    LPSRowSet        pSRowSet = NULL;

    // Open the container object corresponding to pContainerEID
    hr = m_pAdrBook->OpenEntry(cbContainerEID, pContainerEID, NULL, 0, 
                               &ulObjectType, (LPUNKNOWN *) &pContainer);
    if (FAILED(hr))
        goto exit;

    // Get the contents table from this container
    hr = pContainer->GetContentsTable(0, &pContentsTable);
    if (FAILED(hr))
        goto exit;

    // Order the columns in the ContentsTable to conform to the ones we want
    // - which are mainly DisplayName, EntryID and ObjectType.  The table is 
    // guaranteed to set the columns in the order requested.
    Assert(PR_MSGR_DEF_ID);
    ptaEid.aulPropTag[ieidPR_MSGR_DEF_ID] = PR_MSGR_DEF_ID;
    hr = pContentsTable->SetColumns((LPSPropTagArray) &ptaEid, 0);
    if(HR_FAILED(hr))
        goto exit;

    // Do the find
    hr = pContentsTable->FindRow(pPropRes, BOOKMARK_BEGINNING, 0);
    if (FAILED(hr))
        goto exit;

    // If this was a partial completion error, we want to continue but also
    // return this information to the caller
    if (MAPI_W_PARTIAL_COMPLETION == hr)
        hrTemp = hr;

    // If we got this far, we have a populated table.  We can query the rows
    // now.
    hr = _QueryAllRows(pContentsTable, NULL, NULL, NULL, MAX_QUERY_SIZE, &pSRowSet);
    if (FAILED(hr) || !pSRowSet)
        goto exit;

    // Fill in the ListView from the table
    _FillListFromTable(ctlList, pSRowSet, TRUE);

exit:
    if (pSRowSet)
        _FreeProws(pSRowSet);

    if (pContentsTable)
        pContentsTable->Release();

    if (pContainer)
        pContainer->Release();

    return (hr);
}


HRESULT CAddressBookData::_FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet, BOOL bLDAP)
{
    LPSBinary lpSB;

    // Make sure the caller passed us a rowset
    Assert(pSRowSet);
    Assert(PR_MSGR_DEF_ID);

    // Loop through the rows in the rowset
    for (ULONG i = 0; i < pSRowSet->cRows; i++)
    {
        // Get the information out of the table that we need.  Right now we're 
        // grabbing the entry ID, the display name, and the business phone number.
        LPENTRYID lpEID = (LPENTRYID) pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
        ULONG     cbEID = pSRowSet->aRow[i].lpProps[ieidPR_ENTRYID].Value.bin.cb;
        DWORD     nFlag = (pSRowSet->aRow[i].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_DISTLIST) ? MAB_GROUP : MAB_CONTACT;
        LPTSTR    lpszID = NULL;
        LPTSTR    lpszName = NULL;
        
        if(nFlag == MAB_CONTACT)
        {
            if(pSRowSet->aRow[i].lpProps[ieidPR_USER_X509_CERTIFICATE].ulPropTag == PR_USER_X509_CERTIFICATE)
                nFlag |= MAB_CERT;
        }

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].ulPropTag) == PT_TSTRING )
        {
            nFlag = nFlag | MAB_BUDDY;
            lpszID = pSRowSet->aRow[i].lpProps[ieidPR_MSGR_DEF_ID/*ieidPR_EMAIL_ADDRESS*/].Value.lpszA;
        }
        else if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].ulPropTag) == PT_TSTRING )
            lpszID = pSRowSet->aRow[i].lpProps[ieidPR_EMAIL_ADDRESS].Value.lpszA;
        else
            lpszID = NULL;

        if(PROP_TYPE(pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].ulPropTag) == PT_TSTRING )
            lpszName = pSRowSet->aRow[i].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
        else
            lpszName = lpszID;
        
        // LPTSTR    lpszPhone = pSRowSet->aRow[i].lpProps[ieidPR_BUSINESS_TELEPHONE_NUMBER].Value.lpszA;

        // Allocate an ITEMINFO struct to store this information
        lpSB = NULL;
        m_pWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
        if (lpSB)
        {
            // Save the information we'll need later
            m_pWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));
            if (!lpSB->lpb)
            {
                m_pWABObject->FreeBuffer(lpSB);
                continue;
            }

            CopyMemory(lpSB->lpb, lpEID, cbEID);
            lpSB->cb = cbEID;

            // Create an item to add to the list
            m_pAB->CheckAndAddAbEntry(lpSB, lpszID, lpszName, nFlag);

        }
    }

    // Let's make sure the first item is selected
//    ListView_SetItemState(ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
   
    return (S_OK);
}

HRESULT CAddressBookData::NewContact(HWND hwndParent)
{    
    HRESULT     hr;
    ULONG       cbNewEntry;
    LPENTRYID   pNewEntry;
    ULONG           cbContainerID;
    LPENTRYID       pContainerID = 0;

    if(!m_pAdrBook)
        return E_FAIL;

    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        return(hr);

    hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, /*CREATE_CHECK_DUP_STRICT*/ 0, cbContainerID, pContainerID, 0, NULL,
                              &cbNewEntry, &pNewEntry);

    return (hr);
}

// Add new (Msgr) contact to address book
HRESULT CAddressBookData::AutoAddContact(TCHAR * pchName, TCHAR * pchID)
{
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulcPropCount = 1;
    ULONG           ulIndex = 0;
    LPSPropValue    lpPropArray = NULL;
    SCODE           sc;
    LPWSTR          pwszName = NULL,
                    pwszID = NULL;
    HRESULT         hr = S_OK;

    if(!m_pAdrBook || !m_pWABObject)
        return(S_FALSE);

    // 1. Add entry to Address book
    pwszName = PszToUnicode(CP_ACP, pchName);
    if (!pwszName && (pchName && *pchName))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    pwszID = PszToUnicode(CP_ACP, pchID);
    if (!pwszID && (pchID && *pchID))
    {
        hr = E_OUTOFMEMORY;
        goto out;
    }

    hr = HrWABCreateEntry(m_pAdrBook,
                            m_pWABObject,
                            pwszName,
                            pwszID,
                            CREATE_CHECK_DUP_STRICT,
                            &lpMailUser, KEEP_OPEN_READWRITE);
    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto out;

        int nLen = lstrlen(pchID);
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen+1, lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            lstrcpy(lpPropArray[0].Value.LPSZ, pchID);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

out:
    MemFree(pwszName);
    MemFree(pwszID);
    if(lpPropArray)
        m_pWABObject->FreeBuffer(lpPropArray);

    if(lpMailUser)
        ReleaseObj(lpMailUser);

    return(hr);
}

// Unicode string property version of template array
SizedSPropTagArray(6, ptaAddr_W) =
{
    6,
    {
        PR_ADDRTYPE_W,
        PR_DISPLAY_NAME_W,
        PR_EMAIL_ADDRESS_W,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_W,  //4
        PR_SEARCH_KEY
    }
};

// ANSI string property version of template array
SizedSPropTagArray(6, ptaAddr_A) =
{
    6,
    {
        PR_ADDRTYPE_A,
        PR_DISPLAY_NAME_A,
        PR_EMAIL_ADDRESS_A,
        PR_ENTRYID,
        PR_CONTACT_EMAIL_ADDRESSES_A,
        PR_SEARCH_KEY
    }
};

HRESULT CAddressBookData::AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pSB, BOOL fGroup)
{
    HRESULT     hr;
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    ULONG       ulObjType = 0;
    LPMAPITABLE lpAB =  NULL;
    LPABCONT    lpContainer = NULL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Retrieve the item from the wab
    hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

    // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_W, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // Set those badboys on the address table
    if(pPropArray[2].ulPropTag == PR_EMAIL_ADDRESS_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[2].Value.lpszW, NULL , NULL);
    else if(pPropArray[4].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES_W)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[4].Value.MVszW.lppszW[0], NULL , NULL);
    else if((pPropArray[1].ulPropTag == PR_DISPLAY_NAME_W) && fGroup)
        pAddrTable->AppendW(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszW, NULL , NULL);

    // Bug 34077 - they don't want to have a display name...
    /* else if(pPropArray[1].ulPropTag == PR_DISPLAY_NAME)
        pAddrTable->Append(IAT_TO, IET_DECODED, pPropArray[1].Value.lpszA, NULL , NULL);
    else
        Assert(FALSE); */
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);
}

HRESULT CAddressBookData::SetDefaultMsgrID(LPSBinary pSB, LPTSTR pchID)
{
    ULONG       ulType = 0;
    IMailUser  *lpMailUser = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &lpMailUser);
    if (FAILED(hr))
        goto exit;

    if(SUCCEEDED(hr))
    {
        // 2. Set custom property: default address for buddy
        
        // Create a return prop array to pass back to the WAB
        sc = m_pWABObject->AllocateBuffer(sizeof(SPropValue), 
                                            (LPVOID *)&lpPropArray);
        if (sc!=S_OK)
            goto exit;

        int nLen = lstrlen(pchID);
        if(nLen)
        {
            lpPropArray[0].ulPropTag = MsgrPropTags[0];
            sc = m_pWABObject->AllocateMore(nLen+1, lpPropArray, 
                                    (LPVOID *)&(lpPropArray[0].Value.LPSZ));

            if (sc!=S_OK)
                goto exit;

            lstrcpy(lpPropArray[0].Value.LPSZ, pchID);
        }
        // Set this new data on the object
        //
        if(lpMailUser)
        {
            hr = lpMailUser->SetProps(1, lpPropArray, NULL);
            if(SUCCEEDED(hr))
                hr = lpMailUser->SaveChanges(FORCE_SAVE);
        }
    }

exit:
    if(lpPropArray)
        m_pWABObject->FreeBuffer(lpPropArray);

    SafeRelease(lpMailUser);
    return (hr);
}

HRESULT CAddressBookData::GetDisplayName(LPSBinary pSB, LPTSTR szDisplayName, int nMax)
{

    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_A, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    lstrcpyn(szDisplayName, pPropArray[1].Value.lpszA, nMax);
    szDisplayName[nMax - 1] = _T('\0');

exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (hr);

}

BOOL CAddressBookData::CheckEmailAddr(LPSBinary pSB, LPTSTR szEmail)
{
    ULONG       ulType = 0;
    IMailUser  *pMailUser = 0;
    ULONG       cValues;
    SPropValue *pPropArray = 0;
    LPSPropValue lpPropMVEmail = NULL;
    UINT i = 0;
    BOOL fRet = FALSE;

    HRESULT hr = m_pAdrBook->OpenEntry(pSB->cb, (LPENTRYID) pSB->lpb, NULL,
                               MAPI_BEST_ACCESS, &ulType, (IUnknown **) &pMailUser);
    if (FAILED(hr))
        goto exit;

        // Get the appropriate properties from the object
    hr = pMailUser->GetProps((SPropTagArray *) &ptaAddr_A, 0, &cValues, &pPropArray); 
    if (FAILED(hr))
        goto exit;

    // 4 element is PR_CONTACT_EMAIL_ADDRESSES in ptaAddr
    lpPropMVEmail = &(pPropArray[4]);
    if(lpPropMVEmail && (lpPropMVEmail->ulPropTag == PR_CONTACT_EMAIL_ADDRESSES))
    {
        // we have a multiple emails
        //Assume, if this is present, so is MVAddrType, and defaultindex
        for(i = 0; i < lpPropMVEmail->Value.MVszA.cValues; i++)
        {

            if(!lstrcmpi(lpPropMVEmail->Value.MVszA.lppszA[i], szEmail))
                fRet = TRUE;
        }
    }
exit:
    if (pPropArray)
        m_pWABObject->FreeBuffer(pPropArray);

    SafeRelease(pMailUser);
    return (fRet);
}



HRESULT CAddressBookData::FreeListViewItem(LPSBinary pSB)
{
    if (pSB)
        m_pWABObject->FreeBuffer(pSB);
    return (S_OK);
}

HRESULT CAddressBookData::ShowDetails(HWND hwndParent, LPSBinary pSB)
{
    HRESULT hr;
    ULONG_PTR   ulUIParam = (ULONG_PTR) hwndParent;

    hr = m_pAdrBook->Details(&ulUIParam, NULL, NULL, pSB->cb, (LPENTRYID) pSB->lpb, 
                             NULL, NULL, NULL, 0);

    return (hr);
}

HRESULT CAddressBookData::AddAddress(LPWSTR pwszDisplay, LPSTR pszAddress)
{
    HRESULT         hr;
    LPABCONT        pABContainer = NULL;
    ULONG           cbContainerID,
        ul;
    LPENTRYID       pContainerID = 0;
    LPMAPIPROP      lpProps = 0;
    SPropValue      rgpv[3];
    SPropTagArray   ptaEID = { 1, { PR_ENTRYID } };
    LPSPropValue    ppvDefMailUser=0;
    SizedSPropTagArray(1, ptaDefMailUser) =
    { 1, { PR_DEF_CREATE_MAILUSER } };
    
    DWORD           cUsedValues;
    
    // Get the entry ID for the PAB
    hr = m_pAdrBook->GetPAB(&cbContainerID, &pContainerID);
    if (FAILED(hr))
        goto error;
    
    // Request the container
    hr = m_pAdrBook->OpenEntry(cbContainerID, pContainerID, NULL,
        0, &ul, (LPUNKNOWN *) &pABContainer);
    Assert(ul == MAPI_ABCONT);
    if (FAILED(hr))
        goto error;
    
    // Free the entry ID
    m_pWABObject->FreeBuffer(pContainerID);
    
    // Get the properties for the default mail template
    hr = pABContainer->GetProps((LPSPropTagArray) &ptaDefMailUser, 0, &ul, &ppvDefMailUser);
    if (FAILED(hr) || !ppvDefMailUser || ppvDefMailUser->ulPropTag != PR_DEF_CREATE_MAILUSER)
        goto error;
    
    // Create a new entry
    hr=pABContainer->CreateEntry(ppvDefMailUser->Value.bin.cb, 
        (LPENTRYID) ppvDefMailUser->Value.bin.lpb,
        CREATE_CHECK_DUP_STRICT, &lpProps);
    if (FAILED(hr))
        goto error;
    
    // Fill in the properties for the display name and address
    rgpv[0].ulPropTag   = PR_DISPLAY_NAME_W;
    rgpv[0].Value.lpszW = pwszDisplay;
    rgpv[1].ulPropTag   = PR_EMAIL_ADDRESS;
    rgpv[1].Value.lpszA = pszAddress;
    
    cUsedValues = 2;
    // Set those props on the entry
    hr = lpProps->SetProps(cUsedValues, rgpv, NULL);
    if (FAILED(hr))
        goto error;
    
    // Save 'em
    hr = lpProps->SaveChanges(KEEP_OPEN_READONLY);
    if (FAILED(hr))
        goto error;
    
error:
    ReleaseObj(lpProps);
    ReleaseObj(pABContainer);
    
    if (ppvDefMailUser)
        m_pWABObject->FreeBuffer(ppvDefMailUser);
    
    return hr;
}


HRESULT CAddressBookData::DeleteItems(ENTRYLIST *pList)
{
    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;
    HRESULT     hr = E_FAIL;
    ULONG       lpcbEID;
    LPENTRYID   lpEID = NULL;

    // Get the entryid of the root PAB container
    hr = m_pAdrBook->GetPAB(&lpcbEID, &lpEID);

    // Open the root PAB container.  This is where all the WAB contents reside.
    ulObjType = 0;
    hr = m_pAdrBook->OpenEntry(lpcbEID,
                               (LPENTRYID)lpEID,
                               NULL,
                               0,
                               &ulObjType,
                               (LPUNKNOWN *) &lpContainer);

    m_pWABObject->FreeBuffer(lpEID);
    lpEID = NULL;

    // Delete those items
    lpContainer->DeleteEntries(pList, 0);

    lpContainer->Release();
    return (S_OK);
}

HRESULT CAddressBookData::Find(HWND hwndParent)
{
    m_pWABObject->Find(m_pAdrBook, hwndParent);
    return (S_OK);
}


HRESULT CAddressBookData::NewGroup(HWND hwndParent)
{
    HRESULT     hr;
    ULONG       cbNewEntry = 0;
    LPENTRYID   pNewEntry = 0;
    LPENTRYID   pTplEid;
    ULONG       cbTplEid;

    hr = _GetWABTemplateID(MAPI_DISTLIST, &cbTplEid, &pTplEid);
    if (SUCCEEDED(hr))
    {
        hr = m_pAdrBook->NewEntry((ULONG_PTR) hwndParent, 0, 0, NULL, cbTplEid, pTplEid, &cbNewEntry, &pNewEntry);
        Assert(pTplEid);
        m_pWABObject->FreeBuffer(pTplEid);
    }

    return (hr);
}

HRESULT CAddressBookData::AddressBook(HWND hwndParent)
{
    CWab *pWab = NULL;
    
    if (SUCCEEDED(HrCreateWabObject(&pWab)))
    {
        pWab->HrBrowse(hwndParent);
        pWab->Release();
    }
    else
    {
        AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsGeneralWabError), 
                      NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    return (S_OK);
}


HRESULT CAddressBookData::_GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID)
{
    LPABCONT lpContainer = NULL;
    HRESULT  hr  = S_OK;
    SCODE    sc = ERROR_SUCCESS;
    ULONG    ulObjType = 0;
    ULONG    cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG    cNewProps;
    ULONG    nIndex;

    if ((!m_pAdrBook) || ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID  = NULL;

    if (FAILED(hr = m_pAdrBook->GetPAB(&cbWABEID, &lpWABEID)))
    {
        goto out;
    }

    if (HR_FAILED(hr = m_pAdrBook->OpenEntry(cbWABEID,     // size of EntryID to open
                                              lpWABEID,     // EntryID to open
                                              NULL,         // interface
                                              0,            // flags
                                              &ulObjType,
                                              (LPUNKNOWN *) &lpContainer)))
    {
        goto out;
    }

    // Get us the default creation entryids
    if (FAILED(hr = lpContainer->GetProps((LPSPropTagArray) &ptaCreate,
                                          0, &cNewProps, &lpCreateEIDs)))
    {
        goto out;
    }

    // Validate the properites
    if (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
        lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        goto out;
    }

    if (ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;

    m_pWABObject->AllocateBuffer(*lpcbEID, (LPVOID *) lppEID);
    
    if (sc != S_OK)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        m_pWABObject->FreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->Release();

    if (lpWABEID)
        m_pWABObject->FreeBuffer(lpWABEID);

    return hr;
}

/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT CAddressBookData::InitNamedProps(/*LPWABEXTDISPLAY lpWED*/)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMsgrProps = NULL;
    LPMAPINAMEID * lppMsgrPropNames;
    SCODE sc;
    // LPMAILUSER lpMailUser = NULL;
    WCHAR szBuf[msgrMax][MAX_PATH];

/*    if(!lpWED)
        goto err;

    lpMailUser = (LPMAILUSER) lpWED->lpPropObj;

    if(!lpMailUser)
        goto err; */

    sc = m_pWABObject->AllocateBuffer(sizeof(LPMAPINAMEID) * msgrMax, 
                                            (LPVOID *) &lppMsgrPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<msgrMax;i++)
    {
        sc = m_pWABObject->AllocateMore(sizeof(MAPINAMEID), 
                                                lppMsgrPropNames, 
                                                (LPVOID *)&(lppMsgrPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMsgrPropNames[i]->lpguid = (LPGUID) &WAB_ExtBAGuid;
        lppMsgrPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMsgrPropNames[i], -1, szBuf[i], ARRAYSIZE(szBuf[i]) ))
        {
            continue;
        }

        lppMsgrPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = m_pAdrBook->GetIDsFromNames(   msgrMax, 
                                        lppMsgrPropNames,
                                        MAPI_CREATE, 
                                        &lptaMsgrProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMsgrProps)
    {
        // Set the property types on the returned props
        MsgrPropTags[MsgrID] = PR_MSGR_DEF_ID = CHANGE_PROP_TYPE(lptaMsgrProps->aulPropTag[MsgrID], PT_TSTRING);
    }

err:
    if(lptaMsgrProps)
        m_pWABObject->FreeBuffer( lptaMsgrProps);

    if(lppMsgrPropNames)
        m_pWABObject->FreeBuffer( lppMsgrPropNames);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_MSOEAPI_ -D_WIN32_OE=0x501 -D_WINDLL
WIN32_IE_VERSION=0x0560

!ifndef WIN16
INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\msoeres; \
    $(R)\inc; \
    $(R)\inc\$(O); \
    $(R)\common; \
    $(R)\shell; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\rules; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\view; \
    $(R)\bactrl; \
    $(R)\bactrl\$(O); \
    $(R)\extinc; \
    $(ATHROOT)\directdb\inc; \
    $(ATHROOT)\directdb\inc\$(O); \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\common; \
    $(BASEDIR)\public\sdk\inc\atl21; \
    $(INCLUDES)
!else
INCLUDES=\
    $(R)\inc; \
    $(R)\mime; \
    $(R)\imap; \
    $(R)\proptree; \
    $(R)\common; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\shell; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\extinc; \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\common;           \
    $(INCLUDES)
!endif

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1

!ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
!else
PRECOMPILED_OPTION=/fh=$(O)\pch.pch
!endif

PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch

!ifdef WIN16
C_DEFINES=$(C_DEFINES) -D__IUnknown_INTERFACE_DEFINED__ -D__IClassFactory_INTERFACE_DEFINED__
RCOPTIONS=-DBCC
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\baprop.cpp ===
// baprop.cpp
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#include "pch.hxx"
#include "badata.h"
#include "baprop.h"
#include "bllist.h"
#include "baui.h"
#include "shlwapip.h"
#include "demand.h"
#include "mailnews.h"
#include "menuutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_SUMMARY_ID  13
#define Msgr_Index      0

extern ULONG MsgrPropTags[];
extern ULONG PR_MSGR_DEF_ID;

static TCHAR szDefault[CCHMAX_STRINGRES];  // TEXT(" (default)");
static TCHAR szPending[CCHMAX_STRINGRES];  // TEXT(" (Pending...)");

const LPTSTR szDomainSeparator = TEXT("@");
const LPTSTR szSMTP = TEXT("SMTP");

#define PROP_ERROR(prop) (PROP_TYPE(prop.ulPropTag) == PT_ERROR)
static int nDefault = -1;
static HFONT hBold = NULL;
static HFONT hNormal = NULL;
static CMsgrList *s_pMsgrList = NULL;

static SizedSPropTagArray(1, pTagProp)=
{
    1,
    {
        PR_EMAIL_ADDRESS,
    }
};

///$$/////////////////////////////////////////////////////////////////////////
//
// AddCBEmailItem - Adds an email address to the personal tab list view
//
// lpszAddrType can be NULL in which case a default one of type SMTP will be used
//
//////////////////////////////////////////////////////////////////////////////
void AddCBEmailItem(HWND    hWndCB,
                    LPTSTR  lpszEmailAddress,
                    BOOL    fDefault,
                    LPTSTR lpszPendName)
{
    TCHAR szBuf[CCHMAX_STRINGRES];
    TCHAR szTmp[CCHMAX_STRINGRES];
    LV_ITEM lvi = {0};
    UINT nSim = 0;
    int index = -1;

    if(lstrlen(lpszEmailAddress) < CCHMAX_STRINGRES)
        lstrcpy(szTmp, lpszEmailAddress);
    else
    {
        lstrcpyn(szTmp, lpszEmailAddress, CCHMAX_STRINGRES - 2);
        szTmp[CCHMAX_STRINGRES - 1] = '\0';
    }

    // TCHAR *pch = StrStr(CharUpper(szTmp), szHotMail);
    // if(pch != NULL)
    nSim = lstrlen(szTmp); //(UINT) (pch - szTmp + 1);

    Assert(nSim < CCHMAX_STRINGRES);

    if(nSim > 0)
    {
        if(nSim > (CCHMAX_STRINGRES - strlen(szDefault) - 2))
        {
            nSim = CCHMAX_STRINGRES - strlen(szDefault) - 2;
            lstrcpyn(szBuf, lpszEmailAddress, nSim);
            szBuf[nSim] = '\0';
        }
        else
            lstrcpy(szBuf, lpszEmailAddress);

        if(fDefault)
        {

            if(s_pMsgrList)
            {
                if(s_pMsgrList->FindAndDeleteUser(lpszEmailAddress, FALSE /*fDelete*/) == S_OK)
                    lstrcat(szBuf, szDefault);
                else if(!lstrcmpi(lpszPendName, lpszEmailAddress))
                    lstrcat(szBuf, szPending);
            }

        }

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        lvi.iImage = IMAGE_EMPTY;
        lvi.pszText = szBuf;
        lvi.cchTextMax = 256; //nSim;
        lvi.iItem = ListView_GetItemCount(hWndCB);
        lvi.iSubItem = 0;
        lvi.lParam = fDefault;

        index = ListView_InsertItem(hWndCB, &lvi);
        if(fDefault)
            nDefault = index;
    }
    return;
}

const static HELPMAP g_rgCtxWabExt[] =
{
    {IDC_MSGR_ID_EDIT,              IDH_WAB_ONLINE_ADDNEW},
    {IDC_MSGR_ADD,                  IDH_WAB_ONLINE_ADD},
    {IDC_MSGR_BUTTON_SETDEFAULT,    IDH_WAB_ONLINE_SETAS},
    {IDC_SEND_INSTANT_MESSAGE,      IDH_WAB_ONLINE_SENDIM},
    {IDC_USER_NAME,                 IDH_WAB_ONLINE_LIST},
    {idcStatic1,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6,                    IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7,                    IDH_NEWS_COMM_GROUPBOX},
    {0,                             0}
};

INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwError = 0;
    HIMAGELIST himl = NULL;

    switch (msg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE * pps = (PROPSHEETPAGE *) lParam;
            LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) pps->lParam;
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
                // Add two columns to the listview
            LVCOLUMN lvc;
            RECT rc;
            HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);

            s_pMsgrList = OE_OpenMsgrList();

            // one column
            lvc.mask = LVCF_FMT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            GetWindowRect(ctlList,&rc);
            lvc.cx = rc.right - rc.left - 20; //TBD

            ListView_InsertColumn(ctlList, 0, &lvc);

            if(lppWED)
            {
                SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM)*lppWED);
                lpWED = *lppWED;
            }
            InitFonts();
            AthLoadString(idsBADefault, szDefault, ARRAYSIZE(szDefault));
            AthLoadString(idsBADispStatus, szPending, ARRAYSIZE(szPending));
            // ListView_SetExtendedListViewStyle(ctlList, LVS_EX_FULLROWSELECT);

            himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 18, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

            ListView_SetImageList(ctlList, himl, LVSIL_SMALL);

            AddAccountsToList(hDlg, lpWED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
        }
        break;

    case WM_CONTEXTMENU:
    case WM_HELP:
        return OnContextHelp(hDlg, msg, wParam, lParam, g_rgCtxWabExt);
        break;

    case WM_COMMAND:
        {
            switch(HIWORD(wParam))		// Notification code
            {
            case EN_CHANGE:
                {
                    if(LOWORD(wParam) == IDC_MSGR_ID_EDIT)
                    {
                        if(GetWindowTextLength(GetDlgItem(hDlg, IDC_MSGR_ID_EDIT)) > 0)
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),TRUE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDC_MSGR_ADD, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_ADD),FALSE);
                            SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
                        }
                    }
                    break;
                }
            }

            switch(LOWORD(wParam))		// commands
            {
            case IDC_MSGR_BUTTON_SETDEFAULT:
                SetAsDefault(hDlg, lpWED);
                break;

            case IDC_MSGR_ADD:
                AddMsgrId(hDlg, lpWED);
                break;

            case IDC_SEND_INSTANT_MESSAGE:
                WabSendIMsg(hDlg, lpWED);
                break;

            default:
                break;
            }
        }
        break;

    case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {

            case PSN_APPLY:
                ::SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, TRUE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);

                break;

            case PSN_SETACTIVE:
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
                break;

            case PSN_KILLACTIVE:
                AddMsgrId(hDlg, lpWED);
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                return 1;
                break;

            case PSN_RESET:
                SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
                DeleteFonts();
                if(s_pMsgrList)
                    OE_CloseMsgrList(s_pMsgrList);
                break;

            case LVN_ITEMCHANGED:
                {
                int nItem = ListView_GetNextItem(::GetDlgItem(hDlg, IDC_USER_NAME), -1, LVIS_SELECTED);
                if((nItem != nDefault) && (nItem > -1))
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);

                if(WabIsItemOnline(hDlg, nItem))
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
                else
                    EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);

                }
                break;


            case NM_CUSTOMDRAW:
                switch(wParam)
                {
                case IDC_USER_NAME:
                    {
                        NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                        NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                        if(pnmcd->dwDrawStage==CDDS_PREPAINT)
                        {
                            SetLastError(0);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
                            dwError = GetLastError();
                            return TRUE;
                        }
                        else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
                        {
                            if(pnmcd->lItemlParam)
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hBold);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                            else
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, hNormal);
                                SetLastError(0);
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                dwError = GetLastError();
                                return TRUE;
                            }
                        }
                        SetLastError(0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                        dwError = GetLastError();
                        return TRUE;
                    }
                    break;
                default:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                    break;
                }
                break;
            }
        }
        break;
    }
    return FALSE;	
}

void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPTSTR lpszPendName)
{

    // LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLongPtr(hDlg, DWLP_USER);
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i = 0;
    LPSPropValue lpPropEmail = NULL;
    LPSPropValue lpPropAddrType = NULL;
    LPSPropValue lpPropMVEmail = NULL;
    LPSPropValue lpPropMVAddrType = NULL;
    LPSPropValue lpPropDefaultIndex = NULL;
    LPSPropValue lpMsgrDevId = NULL;
    HWND ctlList = GetDlgItem(hDlg, IDC_USER_NAME);

    Assert(ctlList);

    Assert(PR_MSGR_DEF_ID);
    nDefault = -1;

    if(!lpWED)
    {
        Assert(FALSE);
        return;
    }

    if(!HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i = 0; i < ulcPropCount; i++)
            {
                switch(lpPropArray[i].ulPropTag)
                {
                case PR_EMAIL_ADDRESS:
                    lpPropEmail = &(lpPropArray[i]);
                    break;
                case PR_ADDRTYPE:
                    lpPropAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_EMAIL_ADDRESSES:
                    lpPropMVEmail = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_ADDRTYPES:
                    lpPropMVAddrType = &(lpPropArray[i]);
                    break;
                case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                    lpPropDefaultIndex = &(lpPropArray[i]);
                    break;
                default:
                    if(lpPropArray[i].ulPropTag == PR_MSGR_DEF_ID)
                        lpMsgrDevId = &(lpPropArray[i]);
                    break;
                }
            }
            if(!lpPropEmail && !lpPropMVEmail)
                goto Error;

            if(lpPropMVEmail)
            {
                // we have a multiple emails
                //Assume, if this is present, so is MVAddrType, and defaultindex
                for(i = 0; i < lpPropMVEmail->Value.MVSZ.cValues; i++)
                {
                    AddCBEmailItem(ctlList,
                                    lpPropMVEmail->Value.MVSZ.LPPSZ[i],
                                    (lpMsgrDevId ?
                                    ((!lstrcmpi(lpPropMVEmail->Value.MVSZ.LPPSZ[i], lpMsgrDevId->Value.LPSZ)) ? TRUE : FALSE) : FALSE), lpszPendName);
                }
            }
            else
            {
                // we dont have multi-valued props yet - lets use the
                // single valued ones and tag a change so that the record is
                // updated ...
                AddCBEmailItem(ctlList,
                                    lpPropEmail->Value.LPSZ,
                                    (lpMsgrDevId ?
                                    ((!lstrcmpi(lpPropEmail->Value.LPSZ, lpMsgrDevId->Value.LPSZ)) ? TRUE : FALSE) : FALSE), lpszPendName);
            }
        }
    }

Error:
    if(nDefault == -1)
    {
        if(ListView_GetItemCount(ctlList) > 0)            // We have as min 1 item
        {
            // Select default item
            ListView_SetItemState(ctlList, 0,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),TRUE);
            // Enable "SendInstant Message only when contact is Online
            if(WabIsItemOnline(hDlg, 0))
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
            else
                EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
            EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
        }
    }
    else
    {
        // Select default item
        ListView_SetItemState(ctlList, nDefault,
                        LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg,IDC_MSGR_BUTTON_SETDEFAULT),FALSE);
            // Enable "SendInstant Message only when contact is Online
        if(WabIsItemOnline(hDlg, nDefault))
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),TRUE);
        else
            EnableWindow(GetDlgItem(hDlg,IDC_SEND_INSTANT_MESSAGE),FALSE);
    }

    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);

    return;

}

// Set selected email address as default for Messenger
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    TCHAR szName[CCHMAX_STRINGRES];
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    if(StrStr(szName, szDefault)) // already default
        return;

    SetDefaultID(szName, hDlg, lpWED);
}

// Add Messanger ID  to list
#define NOT_FOUND ((ULONG) -1)

void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    HWND hwndEdit = ::GetDlgItem(hDlg, IDC_MSGR_ID_EDIT);
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0;
    ULONG i = 0;

    ULONG nMVEmailAddress = NOT_FOUND, nMVAddrTypes = NOT_FOUND, nEmailAddress = NOT_FOUND;
    ULONG nAddrType = NOT_FOUND, nDefaultIndex = NOT_FOUND;
    TCHAR szName[CCHMAX_STRINGRES];
    HRESULT hr = S_OK;

    if(!::GetWindowText(hwndEdit, szName, CCHMAX_STRINGRES - 1))
        return;

    TCHAR *pch = NULL;
    if(!AsciiTrimSpaces(szName))
    {
        AthMessageBoxW(hDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsBAErrExtChars),
               NULL, MB_OK | MB_ICONSTOP);
        ::SetWindowText(hwndEdit, "");
        ::SetFocus(hwndEdit);
        return;
    }

    int nLen = lstrlen(szName);
    if(nLen <= 0)
        goto exi;

    nLen = lstrlen(szSMTP);
    if(nLen <= 0)
        goto exi;

    // Create a return prop array to pass back to the WAB
    if(HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0,
        &ulcPropCount,
        &lpPropArray)))
        return;

    if(ulcPropCount && lpPropArray)
    {
        for(i = 0; i < ulcPropCount; i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_EMAIL_ADDRESS:
                nEmailAddress = i;
                break;
            case PR_ADDRTYPE:
                nAddrType = i;
                break;
            case PR_CONTACT_EMAIL_ADDRESSES:
                nMVEmailAddress = i;
                break;
            case PR_CONTACT_ADDRTYPES:
                nMVAddrTypes = i;
                break;
            case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                nDefaultIndex = i;
                break;
            }
        }

        // if no e-mail address, just add the given prop as e-mail address and in mv e-mail addresses
        if(nEmailAddress == NOT_FOUND)
        {
            SPropValue spv[5];

            spv[0].ulPropTag = PR_EMAIL_ADDRESS;
            spv[0].Value.LPSZ = szName;

            spv[1].ulPropTag = PR_ADDRTYPE;
            spv[1].Value.LPSZ = szSMTP;

            spv[2].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[2].Value.MVSZ.cValues = 1;
            spv[2].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[2].Value.MVSZ.LPPSZ)
                spv[2].Value.MVSZ.LPPSZ[0] = szName;

            spv[3].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[3].Value.MVSZ.cValues = 1;
            spv[3].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));

            if(spv[3].Value.MVSZ.LPPSZ)
                spv[3].Value.MVSZ.LPPSZ[0] = szSMTP;

            spv[4].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[4].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(5, (LPSPropValue)&spv, NULL);

            if(spv[2].Value.MVSZ.LPPSZ)
                LocalFree(spv[2].Value.MVSZ.LPPSZ);
            if(spv[3].Value.MVSZ.LPPSZ)
                LocalFree(spv[3].Value.MVSZ.LPPSZ);

        }
        else if(nMVEmailAddress == NOT_FOUND)
        {
            // we have an e-mail address but no contact-email-addresses
            // so we will need to create the contact e-mail addresses
            SPropValue spv[3];

            spv[0].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
            spv[0].Value.MVSZ.cValues = 2;
            spv[0].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[0].Value.MVSZ.LPPSZ)
            {
                spv[0].Value.MVSZ.LPPSZ[0] = lpPropArray[nEmailAddress].Value.LPSZ;
                spv[0].Value.MVSZ.LPPSZ[1] = szName;
            }

            spv[1].ulPropTag = PR_CONTACT_ADDRTYPES;
            spv[1].Value.MVSZ.cValues = 2;
            spv[1].Value.MVSZ.LPPSZ = (char **) LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);

            if(spv[1].Value.MVSZ.LPPSZ)
            {
                spv[1].Value.MVSZ.LPPSZ[0] = (nAddrType == NOT_FOUND) ? (LPTSTR)szSMTP : lpPropArray[nAddrType].Value.LPSZ;
                spv[1].Value.MVSZ.LPPSZ[1] = szSMTP;
            }

            spv[2].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            spv[2].Value.l = 0;

            hr = lpWED->lpPropObj->SetProps(3, (LPSPropValue)&spv, NULL);

            if(spv[0].Value.MVSZ.LPPSZ)
                LocalFree(spv[0].Value.MVSZ.LPPSZ);

            if(spv[1].Value.MVSZ.LPPSZ)
                LocalFree(spv[1].Value.MVSZ.LPPSZ);
        }
        else
        {
            // tag on the new props to the end of the existing contact_address_types
            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray,ulcPropCount, nMVEmailAddress, szName)))
                goto exi;

            if(HR_FAILED(hr = AddPropToMVPString(lpWED, lpPropArray, ulcPropCount, nMVAddrTypes, szSMTP)))
                goto exi;

            hr = lpWED->lpPropObj->SetProps(ulcPropCount, lpPropArray, NULL);
        }

        // Set this new data on the object
        //
        if(SUCCEEDED(hr))
        {
            lpWED->fDataChanged = TRUE;
            if(nDefault == -1)
                SetDefaultID(szName, hDlg, lpWED);
            else
            {
                // just refresh list, which will add buddy.6
                ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
                AddAccountsToList(hDlg, lpWED);
            }
            ::SetWindowText(hwndEdit, "");
        }
    }
exi:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
}

    //Set default ID in WAB
void SetDefaultID(TCHAR *szName, HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc = 0;

    if(s_pMsgrList)
    {
        s_pMsgrList->AddUser(szName); // Always ignore result
    }
    else
        return;

    // Create a return prop array to pass back to the WAB
    int nLen = lstrlen(szName);

    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropValue),
        (LPVOID *)&lpPropArray);
    if (sc!=S_OK)
        goto out;

    if(nLen)
    {
        lpPropArray[Msgr_Index].ulPropTag = MsgrPropTags[Msgr_Index];
        sc = lpWED->lpWABObject->AllocateMore(nLen+1, lpPropArray,
            (LPVOID *)&(lpPropArray[Msgr_Index].Value.LPSZ));

        if (sc!=S_OK)
            goto out;

        lstrcpy(lpPropArray[Msgr_Index].Value.LPSZ, szName);
    }
    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->SetProps( 1, lpPropArray, NULL)))
        goto out;

    lpWED->fDataChanged = TRUE;
    ListView_DeleteAllItems(::GetDlgItem(hDlg, IDC_USER_NAME));
    AddAccountsToList(hDlg, lpWED, szName);

out:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  TrimSpaces - strips a string of leading and trailing blanks
//
//  szBuf - pointer to buffer containing the string we want to strip spaces off.
//  Also, check that characters are ASCII
//
////////////////////////////////////////////////////////////////////////////////
BOOL AsciiTrimSpaces(TCHAR * szBuf)
{
    register LPTSTR lpTemp = szBuf;

    if(!szBuf || !lstrlen(szBuf))
        return FALSE;

    // Trim leading spaces
    while (IsSpace(lpTemp)) {
        lpTemp = CharNext(lpTemp);
    }

    if (lpTemp != szBuf) {
        // Leading spaces to trim
        lstrcpy(szBuf, lpTemp);
        lpTemp = szBuf;
    }

    if (*lpTemp == '\0') {
        // empty string
        return(TRUE);
    }

    // Move to the end
    lpTemp += lstrlen(lpTemp);
    lpTemp--;

    // Walk backwards, triming spaces
    while (IsSpace(lpTemp) && lpTemp > szBuf) {
        *lpTemp = '\0';
        lpTemp = CharPrev(szBuf, lpTemp);
    }

   lpTemp = szBuf;

    while (*lpTemp)
    {
        // Internet addresses only allow pure ASCII.  No high bits!
        if (*lpTemp & 0x80)
           return(FALSE);
        lpTemp++;
    }

    return(TRUE);
}

/***************************************************************************

    Name      : AddPropToMVPString

    Purpose   : Add a property to a multi-valued binary property in a prop array

    Parameters: lpaProps -> array of properties
                cProps = number of props in lpaProps
                uPropTag = property tag for MVP
                index = index in lpaProps of MVP
                lpszNew -> new data string

    Returns   : HRESULT

    Comment   : Find the size of the existing MVP
                Add in the size of the new entry
                allocate new space
                copy old to new
                free old
                copy new entry
                point prop array LPSZ to the new space
                increment cValues


                Note: The new MVP memory is AllocMore'd onto the lpaProps
                allocation.  We will unlink the pointer to the old MVP array,
                but this will be cleaned up when the prop array is freed.

***************************************************************************/
HRESULT AddPropToMVPString(
  LPWABEXTDISPLAY lpWED,
  LPSPropValue lpaProps,
  DWORD cProps,
  DWORD index,
  LPTSTR lpszNew) {

#ifdef UNICODE
    SWStringArray UNALIGNED * lprgszOld = NULL; // old SString array
#else
    SLPSTRArray UNALIGNED * lprgszOld = NULL;   // old SString array
#endif
    LPTSTR  *lppszNew = NULL;           // new prop array
    LPTSTR  *lppszOld = NULL;           // old prop array
    ULONG cbMVP = 0;
    ULONG cExisting = 0;
    LPBYTE lpNewTemp = NULL;
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG i;
    ULONG cbNew;

    if (lpszNew) {
        cbNew = lstrlen(lpszNew) + 1;
    } else {
        cbNew = 0;
    }

    // Find the size of any existing MVP entries
    if (PROP_ERROR(lpaProps[index])) {
        // Un-ERROR the property tag
        lpaProps[index].ulPropTag = PROP_TAG(PT_MV_TSTRING, PROP_ID(lpaProps[index].ulPropTag));
    } else {
        // point to the structure in the prop array.
        lprgszOld = &(lpaProps[index].Value.MVSZ);
        lppszOld = lprgszOld->LPPSZ;

        cExisting = lprgszOld->cValues;
        cbMVP = cExisting * sizeof(LPTSTR);
    }

    // cbMVP now contains the current size of the MVP
    cbMVP += sizeof(LPTSTR);    // room in the MVP for another string pointer


    // Allocate room for new MVP array
    if (sc = lpWED->lpWABObject->AllocateMore(cbMVP, lpaProps, (LPVOID *)&lppszNew)) {
        DebugTrace("AddPropToMVPString allocation (%u) failed %x\n", cbMVP, sc);
        hResult = ResultFromScode(sc);
        return(hResult);
    }

    // If there are properties there already, copy them to our new MVP
    for (i = 0; i < cExisting; i++) {
        // Copy this property value to the MVP
        lppszNew[i] = lppszOld[i];
    }

    // Add the new property value
    // Allocate room for it
    if (cbNew) {
        if (sc = lpWED->lpWABObject->AllocateMore(cbNew, lpaProps, (LPVOID *)&(lppszNew[i]))) {
            DebugTrace("AddPropToMVPBin allocation (%u) failed %x\n", cbNew, sc);
            hResult = ResultFromScode(sc);
            return(hResult);
        }
        lstrcpy(lppszNew[i], lpszNew);

        lpaProps[index].Value.MVSZ.LPPSZ= lppszNew;
        lpaProps[index].Value.MVSZ.cValues = cExisting + 1;

    } else {
        lppszNew[i] = NULL;
    }

    return(hResult);
}

// this function check if selected item is online
BOOL WabIsItemOnline(HWND hDlg, int nItem)
{
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    if(nItem < 0)
        return(FALSE);

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    ListView_GetItemText(ctlList, nItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"
    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        return(s_pMsgrList->IsContactOnline(szName, s_pMsgrList->GetFirstMsgrItem()));
    }
    return(FALSE);
}

// Send instant message to selected item
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    TCHAR szName[CCHMAX_STRINGRES];
    TCHAR *pch = NULL;

    HWND ctlList = ::GetDlgItem(hDlg, IDC_USER_NAME);
    Assert(ctlList);

    int iItem = ListView_GetNextItem(ctlList, -1, LVIS_SELECTED);
    if(iItem == -1)
        return;

    ListView_GetItemText(ctlList, iItem, 0,szName, CCHMAX_STRINGRES - 1);

    // Remove "(default)"

    pch = StrStr(szName, szDefault);
    if(pch != NULL)
        szName[pch - szName] = '\0';

    if(s_pMsgrList)
    {
        s_pMsgrList->SendInstMessage(szName);
    }
}

BOOL InitFonts(void)
{
    LOGFONT lf;

    // Create the font
    if(SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
    {
        if(!hNormal)
            hNormal = CreateFontIndirect(&lf);
        lf.lfWeight = (lf.lfWeight < 700) ? 700 : 1000;
        if(!hBold)
            hBold = CreateFontIndirect(&lf);

    }
    return(TRUE);
}

void DeleteFonts(void)
{
    if(hNormal)
    {
        DeleteObject(hNormal);
        hNormal = NULL;
    }
    if(hBold)
    {
        DeleteObject(hBold);
        hBold = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\logwatch\logwatch.cpp ===
// ----------------------------------------------------------------------------
// LogWatch.cpp
// ----------------------------------------------------------------------------
#include <pch.hxx>
#include <richedit.h>
#include "resource.h"

// ------------------------------------------------------------------------------------
// Prototypes
// ------------------------------------------------------------------------------------
BOOL CALLBACK LogWatchDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// ----------------------------------------------------------------------------
// WinMain
// ----------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    // Locals
    LPTSTR pszCmdLine;

    // Load RichEdit
    HINSTANCE hRichEdit = LoadLibrary("RICHED32.DLL");

    // Get the commandline
    pszCmdLine = GetCommandLine();

    // Fixup Command line
    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    // Launch the Dialog
    DialogBoxParam(GetModuleHandle(NULL), MAKEINTRESOURCE(IDD_LOGWATCH), NULL, (DLGPROC)LogWatchDlgProc, (LPARAM)pszCmdLine);

    // Free RichEdit
    if (hRichEdit)
        FreeLibrary(hRichEdit);

    // Done
    return 1;
}

// ------------------------------------------------------------------------------------
// LogWatchDlgProc
// ------------------------------------------------------------------------------------
BOOL CALLBACK LogWatchDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPSTR               pszFilePath;
    ULONG               cbRead;
    BYTE                rgb[4096];
    static HANDLE       s_hFile=INVALID_HANDLE_VALUE;
    static HWND         s_hwndEdit=NULL;
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the file
        pszFilePath = (LPSTR)lParam;

        // No File
        if (NULL == pszFilePath || '\0' == *pszFilePath)
        {
            MessageBox(hwnd, "You must specify a file name on the command line.\r\n\r\nFor example: LogWatch.exe c:\\test.log", "Microsoft LogWatch", MB_OK | MB_ICONSTOP);
            EndDialog(hwnd, IDOK);
            return FALSE;
        }

        // Open the file
        s_hFile = CreateFile(pszFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        // Failure
        if (INVALID_HANDLE_VALUE == s_hFile)
        {
            wsprintf((LPSTR)rgb, "The file '%s' could not be opened by LogWatch. The file does not exist or is in use by another application.", pszFilePath);
            MessageBox(NULL, (LPSTR)rgb, "Microsoft LogWatch", MB_OK | MB_ICONSTOP);
            EndDialog(hwnd, IDOK);
            return FALSE;
        }

        // Set Title Batr
        wsprintf((LPSTR)rgb, "Microsoft LogWatch - %s", pszFilePath);
        SetWindowText(hwnd, (LPSTR)rgb);

        // Seek to the end of the file - 256 bytes
        SetFilePointer(s_hFile, (256 > GetFileSize(s_hFile, NULL)) ? 0 : - 256, NULL, FILE_END);

        // Create the RichEdit Control
        s_hwndEdit = GetDlgItem(hwnd, IDC_EDIT);

        // Read a Buffer
        ReadFile(s_hFile, rgb, sizeof(rgb) - 1, &cbRead, NULL);

        // Hide Selection
        SendMessage(s_hwndEdit, EM_HIDESELECTION , TRUE, TRUE);

        // Done
        if (cbRead)
        {
            // Append to end of text
            rgb[cbRead] = '\0';
            LPSTR psz = (LPSTR)rgb;
            while(*psz && '\n' != *psz)
                psz++;
            SendMessage(s_hwndEdit, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
            SendMessage(s_hwndEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)psz);
            SendMessage(s_hwndEdit, EM_SCROLLCARET, 0, 0);
        }

        // Kick off the time
        SetTimer(hwnd, WM_USER + 1024, 2000, NULL);
        SetFocus(s_hwndEdit);

        // Done
        return FALSE;

    case WM_TIMER:
        if (wParam == (WM_USER + 1024))
        {
            // Read to end
            while(1)
            {
                // Read a Buffer
                ReadFile(s_hFile, rgb, sizeof(rgb) - 1, &cbRead, NULL);

                // Done
                if (!cbRead)
                    break;

                // Append to end of text
                rgb[cbRead] = '\0';
                SendMessage(s_hwndEdit, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                SendMessage(s_hwndEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)rgb);
                SendMessage(s_hwndEdit, EM_SCROLLCARET, 0, 0);
            }
        }
        break;

    case WM_SIZE:
        SetWindowPos(s_hwndEdit,0,0,0, LOWORD(lParam), HIWORD(lParam),SWP_NOACTIVATE|SWP_NOZORDER);
        break;

#if 0
    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        }
        break;
#endif

    case WM_CLOSE:
        KillTimer(hwnd, WM_USER + 1024);
        EndDialog(hwnd, IDOK);
        break;

    case WM_DESTROY:
        if (INVALID_HANDLE_VALUE != s_hFile)
            CloseHandle(s_hFile);
        return FALSE;
    }

    // Done
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\badata.h ===
// badata.h: interface for the CAddressBookData class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __BADATA_H_
#define __BADATA_H_

// Pull in the WAB header files
#include <wab.h>

class CMsgrAb;

typedef struct tagITEMINFO {
    LONG        lObjectType;
    LPENTRYID   pEntryID;
    ULONG       cbEntryID;
} ITEMINFO, *PITEMINFO;

typedef enum
{
    LPARAM_MENTRY = 1,
    LPARAM_ABENTRY,
    LPARAM_MABENTRY,
    LPARAM_ABGRPENTRY,
    MAX_LPARAM
} MABENUM;

// MAB types masks

#define  MAB_CONTACT    0x001
#define  MAB_GROUP      0x002
#define  MAB_BUDDY      0x004     
#define  MAB_CERT       0x008


class ATL_NO_VTABLE CAddressBookData
{
public:
	/////////////////////////////////////////////////////////////////////////
	// Constructor & Destructor
	//
	CAddressBookData();
	virtual ~CAddressBookData();

	/////////////////////////////////////////////////////////////////////////
	// WAB Functions
	//
	HRESULT OpenWabFile(void);
	HRESULT LoadWabContents(CContainedWindow& ctlList, CMsgrAb *pSink);
    HRESULT DoLDAPSearch(LPTSTR pszText, CContainedWindow& ctlList);
    HRESULT NewContact(HWND hwndParent);
    HRESULT AddRecipient(LPMIMEADDRESSTABLEW pAddrTable, LPSBinary pInfo, BOOL fGroup);
    HRESULT FreeListViewItem(LPSBinary pSB);
    HRESULT ShowDetails(HWND hwndParent, LPSBinary pSB);
    HRESULT AddAddress(LPWSTR pwszDisplay, LPSTR pszAddress);
    HRESULT GetDisplayName(LPSBinary pSB, LPTSTR pszDisplayName, int nMax);
    HRESULT DeleteItems(ENTRYLIST *pList);
    HRESULT Unadvise(void)
    {
        if (m_ulConnection)
           m_pAdrBook->Unadvise(m_ulConnection);
        return (S_OK);
    }
    HRESULT Find(HWND hwndParent);
    HRESULT AddressBook(HWND hwndParent);
    HRESULT NewGroup(HWND hwndParent);
    HRESULT AutoAddContact(TCHAR * pchName, TCHAR * pchID);
    HRESULT InitNamedProps(void);
    HRESULT SetDefaultMsgrID(LPSBinary pSB, LPTSTR pchID);
    BOOL CheckEmailAddr(LPSBinary pSB, LPTSTR szEmail);

    /////////////////////////////////////////////////////////////////////////
    // MAPI Utility Functions
    //
protected:
    void    _FreeProws(LPSRowSet prows);
    HRESULT	_MergeRowSets(LPSRowSet prows, LPSRowSet FAR *pprowsDst);
    HRESULT _QueryAllRows(LPMAPITABLE ptable, LPSPropTagArray ptaga, 
                          LPSRestriction pres, LPSSortOrderSet psos,
	                      LONG crowsMax, LPSRowSet FAR *pprows);
    HRESULT _FillListFromTable(CContainedWindow& ctlList, LPSRowSet pSRowSet,
                               BOOL bLDAP = FALSE);
    HRESULT _GetWABTemplateID(ULONG ulObjectType, ULONG *lpcbEID, LPENTRYID *lppEID);

    /////////////////////////////////////////////////////////////////////////
    // LDAP Routines
    //

    typedef struct _SortInfo
    {
        BOOL bSortAscending;
        BOOL bSortByLastName;
    } SORT_INFO, *LPSORT_INFO;

    HRESULT _GetLDAPContainer(ULONG *pcbEntryID, LPENTRYID *ppEntryID);
    HRESULT _GetLDAPSearchRestriction(LPTSTR pszText, LPSRestriction lpSRes);
    HRESULT _GetLDAPContentsList(ULONG cbContainerEID, LPENTRYID pContainerEID, 
                                 SORT_INFO rSortInfo, LPSRestriction pPropRes, 
                                 CContainedWindow& ctlList);

// Private member data
private:

	// WAB Stuff
	LPWABOBJECT m_pWABObject;
    HINSTANCE	m_hInstWAB;
    LPADRBOOK	m_pAdrBook; 
    ULONG       m_ulConnection;

    CMsgrAb * m_pAB;
};

void AddAccountsToList(HWND hDlg, int id, LPARAM lParam);

#endif  // __BADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\baprop.h ===
// baprop.h
// WAB & Messenger integration to OE
// Created 06/23/98 by YST
//
//////////////////////////////////////////////////////////////////////

#ifndef __BAPROP_H_
#define __BAPROP_H_

#include "pch.hxx"
#include "badata.h"
#include "demand.h"

// Definitions
void AddCBEmailItem(HWND hWndCB, LPTSTR  lpszEmailAddress, BOOL fDefault, LPTSTR lpszPendName);
INT_PTR CALLBACK WabExtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
void AddAccountsToList(HWND hDlg, LPWABEXTDISPLAY lpWED, LPTSTR lpszPendName = NULL);
void SetAsDefault(HWND hDlg, LPWABEXTDISPLAY lpWED);
void AddMsgrId(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDefaultID(TCHAR *szName, HWND hdlg, LPWABEXTDISPLAY lpWED);
BOOL AsciiTrimSpaces(TCHAR * szBuf);
HRESULT AddPropToMVPString(LPWABEXTDISPLAY lpWED, LPSPropValue lpaProps, DWORD cProps, DWORD index, LPTSTR lpszNew);
void WabSendIMsg(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL InitFonts(void);
void DeleteFonts(void);
BOOL WabIsItemOnline(HWND hDlg, int iItem);

#endif // __BAPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\blobevnt.h ===
// File:       BLObEvn.h
// Messenger integration to OE
// Created 04/20/98 by YST
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//

#ifndef BLOBEVNT_H
#define BLOBEVNT_H

//****************************************************************************
//
// INCLUDES
//
//****************************************************************************

#include "clUtil.h"
#include "MDisp.h"

class CMsgrList;

//****************************************************************************
//
// DEFINES
//
//****************************************************************************


//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

class CMsgrObjectEvents :	public DMsgrOEEvents, 
						public RefCount
{

//****************************************************************************
//
// METHODS
//
//****************************************************************************

public:

	// Constructor/Destructor

	CMsgrObjectEvents(); 
	virtual ~CMsgrObjectEvents();


	//****************************************************************************
	//
	// IUnknown methods declaration
	//
	//****************************************************************************

	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObject);


	//****************************************************************************
	//
	// IDispatch methods declaration
	//
	//****************************************************************************

	STDMETHOD (GetTypeInfoCount) (UINT* pCountTypeInfo);
	STDMETHOD (GetTypeInfo) ( UINT iTypeInfo,
							  LCID,          // This object does not support localization.
							  ITypeInfo** ppITypeInfo);
	STDMETHOD (GetIDsOfNames) (  const IID& iid,
								 OLECHAR** arrayNames,
								 UINT countNames,
								 LCID,          // Localization is not supported.
								 DISPID* arrayDispIDs);
	STDMETHOD (Invoke) ( DISPID dispidMember,
    									 const IID& iid,
	    								 LCID,          // Localization is not supported.
		    							 WORD wFlags,
										 DISPPARAMS* pDispParams,
										 VARIANT* pvarResult,
										 EXCEPINFO* pExcepInfo,
										 UINT* pArgErr);

    STDMETHOD (SetListOfBuddies) (CMsgrList *pList);
    STDMETHOD (DelListOfBuddies) (void);

private:
    CMsgrList * m_pMsgrList;
    IMsgrOE   * m_pMsgr;
};


#endif //BLOBEVNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\bllist.h ===
// bllist.h : Declaration of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 
#ifndef __BLLIST_H_
#define __BLLIST_H_

#include "mdisp.h"
#include "blobevnt.h"

#define MAXNAME 256

// message for all Msgr client windows
#define WM_USER_STATUS_CHANGED      (WM_USER + 1)
#define WM_MSGR_LOGOFF              (WM_USER + 2)
#define WM_MSGR_LOGRESULT           (WM_USER + 3)
#define WM_USER_MUSER_REMOVED       (WM_USER + 4)
#define WM_USER_MUSER_ADDED         (WM_USER + 5)
#define WM_USER_NAME_CHANGED        (WM_USER + 6)
#define WM_LOCAL_STATUS_CHANGED     (WM_USER + 7)
#define WM_MSGR_SHUTDOWN            (WM_USER + 8)

typedef struct _tag_OEMsgrInfo
{
    TCHAR   * pchMsgrName;
    TCHAR   * pchID;
    int     nStatus;
    struct _tag_OEMsgrInfo * pPrev;
    struct _tag_OEMsgrInfo * pNext;
} oeMsgrInfo;

typedef oeMsgrInfo * LPMINFO;

typedef struct _tag_MsgrWndList
{
    HWND hWndUI;
    struct _tag_MsgrWndList * pPrev;
    struct _tag_MsgrWndList * pNext;
} MsgrWndList;

typedef MsgrWndList * LPMWNDLIST;

class CMsgrList
{
public:

    CMsgrList();
    ~CMsgrList();

    void        AddWndEntry(HWND hWnd);
    void        FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry=NULL);
    LPMINFO     GetRootMsgrItem(void)    { return(m_pblInfRoot); }
    void        RegisterUIWnd(HWND hWndUI);
    void        UnRegisterUIWnd(HWND hWndUI);
    LPMINFO     GetFirstMsgrItem(void)                { CheckAndInitMsgr(); return (m_pblInfRoot); };
    LPMINFO     GetNextMsgrItem(LPMINFO pEntry)      { return(pEntry ? pEntry->pNext : NULL); }
    int         AddRef(void)                        { return(++m_nRef); }
    void        Release(void);                      /* { return(--m_nRef); } */
    HRESULT     CheckAndInitMsgr(void);
    HRESULT     SendInstMessage(TCHAR *pchID);
    HRESULT     EventUserStateChanged(IMsgrUserOE * pUser);
    HRESULT     EventUserRemoved(IMsgrUserOE * pUser);
    HRESULT     EventUserAdded(IMsgrUserOE * pUser);
    HRESULT     EventUserNameChanged(IMsgrUserOE * pUser);
    HRESULT     UserLogon(void);
    HRESULT     AutoLogon(void);
    HRESULT     GetLocalState(MSTATEOE *pState);
    HRESULT     SetLocalState(MSTATEOE State);
    HRESULT     EventLogoff(void);
    HRESULT     EventAppShutdown(void);
    HRESULT     EventLogonResult(long lResult);
    HRESULT     HrInitMsgr(void);
    HRESULT     FillList(void);
    HRESULT     UserLogoff(void);
    HRESULT     FindAndDeleteUser(TCHAR * pchID, BOOL fDelete);
    HRESULT     NewOnlineContact(void);
    HRESULT     LaunchOptionsUI(void);
    HRESULT     AddUser(TCHAR * pchID);
    void        DelAllEntries(LPMWNDLIST pWndEntry);
    long        GetCount(void);
    BOOL        IsLocalOnline(void);
    BOOL        IsLocalName(TCHAR *pchName);
    BOOL        IsContactOnline(TCHAR *pchID, LPMINFO pEntry);

private:
    void        FreeWndList(LPMWNDLIST pWndEntry);
    void        FreeMsgrInfoList(LPMINFO pEntry);
    void        RemoveMsgrInfoEntry(LPMINFO pEntry);
    void        RemoveWndEntry(LPMWNDLIST pWndEntry);
    void        SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry=NULL);
    void        AddMsgrListEntry(TCHAR *szName, TCHAR *szID, int nState);
    void        FindAndRemoveBlEntry(TCHAR *szID, LPMINFO pEntry=NULL);

private:
    LPMINFO         m_pblInfRoot;
    LPMINFO         m_pblInfLast;
    LPMWNDLIST      m_pWndLRoot;
    LPMWNDLIST      m_pWndLLast;
    int             m_nRef;

    // Smart pointer
    CComPtr<IMsgrOE>            m_spMsgrObject;
    CMsgrObjectEvents*          m_pMsgrObjectEvents;

    long            m_MsgrCookie;
};


// Global functions available for everybody
CMsgrList *   OE_OpenMsgrList(void);
void        OE_CloseMsgrList(CMsgrList *pCMsgrList);
HRESULT     OE_Msgr_Logoff(void);
HRESULT     InstallMessenger(HWND hWnd);

#ifdef NEEDED
HRESULT     OE_Msgr_Logon(void);
#endif // NEEDED

#endif // __BLLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\baui.h ===
// abui.h : Declaration of the CMsgrAb
// Messanger integration to OE
// Created 04/20/98 by YST

#ifndef __BAUI_H_
#define __BAUI_H_

class CFolderBar;
class CPaneFrame;

#include "resource.h"       // main symbols
#include "shfusion.h"
#include "badata.h"
#include "bactrl.h"
#include "instance.h"
#include "ourguid.h"
#include "ddfldbar.h"
#include <wab.h>
#include <mapiguid.h>
#include "bllist.h"
#include "menures.h"
#include <wabapi.h>
#include "util.h"


/////////////////////////////////////////////////////////////////////////////
// Bitmap Indices
//

enum {
    IMAGE_NEW_MESSAGE = 0,
    IMAGE_DISTRIBUTION_LIST,
    IMAGE_ONLINE,
    IMAGE_OFFLINE,
    IMAGE_STOPSIGN,
    IMAGE_CLOCKSIGN,
    IMAGE_CERT,
    IMAGE_EMPTY,
    ABIMAGE_MAX
};

enum {
    BASORT_STATUS_ACSEND = 0,
    BASORT_STATUS_DESCEND,
    BASORT_NAME_ACSEND,
    BASORT_NAME_DESCEND
};

HRESULT CreateMsgrAbCtrl(IMsgrAb **pMsgrAb);

typedef struct _tag_MABEntry
{
    MABENUM     tag;
    TCHAR   *   pchWABName;
    TCHAR   *   pchWABID;
    LPSBinary   lpSB;
    LPMINFO     lpMsgrInfo;
    BOOL        fCertificate;
} mabEntry;

typedef mabEntry * LPMABENTRY;


/////////////////////////////////////////////////////////////////////////////
// CMsgrAb
class ATL_NO_VTABLE CMsgrAb : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMsgrAb, &CLSID_MsgrAb>,
    public CComControl<CMsgrAb>,
    public IDispatchImpl<IMsgrAb, &IID_IMsgrAb, &LIBID_MsgrAbLib>,
    public IProvideClassInfo2Impl<&CLSID_MsgrAb, NULL, &LIBID_MsgrAbLib>,
    public IPersistStreamInitImpl<CMsgrAb>,
    public IPersistStorageImpl<CMsgrAb>,
    public IQuickActivateImpl<CMsgrAb>,
    public IOleControlImpl<CMsgrAb>,
    public IOleObjectImpl<CMsgrAb>,
    public IOleInPlaceActiveObjectImpl<CMsgrAb>,
    public IViewObjectExImpl<CMsgrAb>,
    public IOleInPlaceObjectWindowlessImpl<CMsgrAb>,
    public IDataObjectImpl<CMsgrAb>,
    public IConnectionPointContainerImpl<CMsgrAb>,
    public ISpecifyPropertyPagesImpl<CMsgrAb>,
    public IDropTarget,
    public IOleCommandTarget,
    public IFontCacheNotify,
    public IInputObject,
    public IObjectWithSite,
    public IDropDownFldrBar,
    public IMAPIAdviseSink,
    public IWABExtInit,
    public IShellPropSheetExt
{
public:
    // Declare our own window class that doesn't have the CS_HREDRAW etc set
    static CWndClassInfo& GetWndClassInfo() 
    { 
        static CWndClassInfo wc = 
        { 
            { sizeof(WNDCLASSEX), 0, StartWindowProc, 
              0, 0, 0, 0, 0, 0 /*(HBRUSH) (COLOR_DESKTOP + 1) */, 0, "Outlook Express Address Book Control", 0 }, 
              NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
        }; 
        return wc; 
    }

    CMsgrAb();
    ~CMsgrAb();

    DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CMsgrAb)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMsgrAb)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IDropTarget)
    COM_INTERFACE_ENTRY(IInputObject)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
    COM_INTERFACE_ENTRY(IFontCacheNotify)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY_IID(IID_IDropDownFldrBar, IDropDownFldrBar)
    COM_INTERFACE_ENTRY(IMAPIAdviseSink)
    COM_INTERFACE_ENTRY(IWABExtInit)
    COM_INTERFACE_ENTRY(IShellPropSheetExt)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CMsgrAb)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()


BEGIN_CONNECTION_POINT_MAP(CMsgrAb)
END_CONNECTION_POINT_MAP()


BEGIN_MSG_MAP(CMsgrAb)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_WININICHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_FONTCHANGE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_QUERYNEWPALETTE, OnSysParamsChange)
    MESSAGE_HANDLER(WM_PALETTECHANGED, OnSysParamsChange)
    MESSAGE_HANDLER(WM_USER_STATUS_CHANGED, OnUserStateChanged)
    MESSAGE_HANDLER(WM_USER_MUSER_REMOVED, OnUserRemoved)
    MESSAGE_HANDLER(WM_USER_MUSER_ADDED, OnUserAdded)
    MESSAGE_HANDLER(WM_USER_NAME_CHANGED, OnUserNameChanged)
    MESSAGE_HANDLER(WM_MSGR_LOGOFF, OnUserLogoffEvent)
    MESSAGE_HANDLER(WM_MSGR_SHUTDOWN, OnMsgrShutDown)
    MESSAGE_HANDLER(WM_MSGR_LOGRESULT, OnUserLogResultEvent)

    COMMAND_ID_HANDLER(ID_NEW_CONTACT, CmdNewContact)
    COMMAND_ID_HANDLER(ID_NEW_ONLINE_CONTACT, CmdNewOnlineContact)
    COMMAND_ID_HANDLER(ID_SET_ONLINE_CONTACT, CmdSetOnline)
//    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_PROPERTIES, CmdProperties)
    COMMAND_ID_HANDLER(ID_DELETE_CONTACT, CmdDelete)
    COMMAND_ID_HANDLER(ID_FIND_PEOPLE, CmdFind)
    COMMAND_ID_HANDLER(ID_ADDRESS_BOOK, CmdMsgrAb)
    COMMAND_ID_HANDLER(ID_NEW_GROUP, CmdNewGroup)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE, CmdNewIMsg)
    COMMAND_ID_HANDLER(ID_SEND_INSTANT_MESSAGE2, CmdNewMessage)
    COMMAND_ID_HANDLER(ID_SEND_MESSAGE, CmdNewEmaile)
    COMMAND_ID_HANDLER(ID_NEW_MSG_DEFAULT, CmdNewEmaile)

    NOTIFY_CODE_HANDLER(LVN_GETINFOTIP, NotifyGetInfoTip)
    NOTIFY_CODE_HANDLER(LVN_DELETEITEM, NotifyDeleteItem)
    NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, NotifyItemChanged)
    NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, NotifyItemActivate)
    NOTIFY_CODE_HANDLER(LVN_GETDISPINFO, NotifyGetDisplayInfo)
    NOTIFY_CODE_HANDLER(NM_SETFOCUS, NotifySetFocus)

ALT_MSG_MAP(1)
#ifdef OLDTOOLTIPS
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST,  WM_MOUSELAST, OnListMouseEvent)
    MESSAGE_HANDLER(WM_MOUSEMOVE,           OnListMouseMove)
    MESSAGE_HANDLER(WM_MOUSELEAVE,          OnListMouseLeave)
#endif // OLDTOOLTIPS
ALT_MSG_MAP(2)

END_MSG_MAP()

// CComControlBase
    HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
    {
		return Create(hWndParent, rcPos, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 
                      WS_EX_CONTROLPARENT);
    }

// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

// IQuickActivate
    STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
    {
        // $REVIEW - Someone updated the size of QACONTAINER to add two
        //           new members, pOleControlSite and pServiceProvider.
        //           This causes ATL to assert in a big way, but to 
        //           avoid the assert we tweek the structure size.  This
        //           is a bad thing. -- steveser
        pQACont->cbSize = sizeof(QACONTAINER);
        return (IQuickActivateImpl<CMsgrAb>::QuickActivate(pQACont, pQACtrl));
    }

// IOleInPlaceActiveObjectImpl
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg)
    {
        if (lpmsg->message == WM_CHAR && lpmsg->wParam == VK_DELETE)
        {
            PostMessage(WM_COMMAND, ID_DELETE, 0);
            return (S_OK);
        }

        return (S_FALSE);
    }


// IMsgrAb
public:
    STDMETHOD(get_InstMsg)(/*[out, retval]*/ BOOL *pVal);
//	STDMETHOD(put_InstMsg)(/*[in]*/ BOOL newVal);
    HRESULT OnDraw(ATL_DRAWINFO& di);

// IDropTarget
    STDMETHOD(DragEnter)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                         POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(THIS_ DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(THIS);
    STDMETHOD(Drop)(THIS_ IDataObject *pDataObject, DWORD grfKeyState,
                    POINTL pt, DWORD *pdwEffect);

//IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        rgCmds[], 
                                          OLECMDTEXT    *pCmdText);
    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);


// IInputObject
    STDMETHOD(HasFocusIO)(THIS);
    STDMETHOD(TranslateAcceleratorIO)(THIS_ LPMSG lpMsg);
    STDMETHOD(UIActivateIO)(THIS_ BOOL fActivate, LPMSG lpMsg);

/////////////////////////////////////////////////////////////////////////
// IFontCacheNotify
//
	STDMETHOD(OnPreFontChange)(void);
	STDMETHOD(OnPostFontChange)(void);

//IObjectWithSite
    STDMETHOD(SetSite)(IUnknown  *punksite);
    STDMETHOD(GetSite)(REFIID  riid, LPVOID *ppvSite);

//IDropDownFolderBar
    HRESULT RegisterFlyOut(CFolderBar *pFolderBar);
    HRESULT RevokeFlyOut();

// IMAPIAdviseSink
    STDMETHOD_(ULONG, OnNotify)(ULONG cNotif, LPNOTIFICATION pNotifications);

// IShellPropSheetExt interface
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IWABExtInit interface
    STDMETHOD(Initialize)(LPWABEXTDISPLAY lpWED);


    // STDMETHOD (EventUserStateChanged)(THIS_ IMsgrUserOE * pUser);

    LPMABENTRY AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo = NULL, TCHAR *pchMail = NULL, TCHAR *pchDisplayName = NULL, BOOL fCert = FALSE);
    void CheckAndAddAbEntry(LPSBinary lpSB, TCHAR *pchEmail, TCHAR *pchDisplayName, DWORD nFlag);

// Message Handlers
private:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled );
    LRESULT OnSysParamsChange(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
    {
        m_ctlList.SendMessage(nMsg, wParam, lParam);

        return 0;
    }
    HRESULT OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);
    HRESULT OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled);

    LRESULT CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdMsgrAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//    LRESULT CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
//     LRESULT NotifyColumnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT NewInstantMessage(LPMABENTRY pEntry);
    HRESULT OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
// Utility Functions
    HRESULT _ResizeElements(LPCRECT prcPos = NULL, LPCRECT prcClip = NULL);
    void    _AutosizeColumns(void);
    void    _EnableCommands(void);
    HRESULT _DoDropMessage(LPMIMEMESSAGE pMessage);
    HRESULT _DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage);
    void    _ReloadListview(void);
    LRESULT SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage);
    void AddMsgrListItem(LPMINFO lpMsgrInfo);
    HRESULT FillMsgrList();
    void RemoveBlabEntry(LPMABENTRY lpEntry);
    LPMABENTRY FindUserEmail(TCHAR *pchEmail, int *pIndex = NULL, BOOL fMsgrOnly = TRUE);
    BOOL    _UpdateViewTip(int x, int y);
    BOOL    _IsItemTruncated(int iItem, int iSubItem);
    LPMABENTRY GetSelectedEntry(void);
    LPMABENTRY GetEntryForSendInstMsg(LPMABENTRY pEntry = NULL);
    HRESULT PromptToGoOnline(void);
    void RemoveMsgrInfo(LPMINFO lpMsgrInfo);

// Member Data
private:
    // Address Book Object
    CAddressBookData  m_cAddrBook;

    // Child windows
    CContainedWindow m_ctlList;         // Displays the list of people

    // Trucated listview items Tooltips
    CContainedWindow        m_ctlViewTip;
    BOOL                    m_fViewTip;
    BOOL                    m_fViewTipVisible;
    BOOL                    m_fTrackSet;
    int                     m_iItemTip;
    int                     m_iSubItemTip;
    HIMAGELIST              m_himl;
    DWORD                   m_dwFontCacheCookie;        // For the Advise on the font cache
    POINT                   m_ptToolTip;
    CEmptyList              m_cEmptyList;
    TCHAR *                 m_szOnline;
    // TCHAR *                 m_szInvisible;
    TCHAR *                 m_szBusy;
    TCHAR *                 m_szBack;
    TCHAR *                 m_szAway;
    TCHAR *                 m_szOnPhone;
    TCHAR *                 m_szLunch;
    TCHAR *                 m_szOffline;
    TCHAR *                 m_szIdle;
    TCHAR *                 m_szEmptyList;
    BOOL                    m_fNoRemove;
    int                     m_delItem;

    // Drag & Drop stuff
    IDataObject     *m_pDataObject;
    CLIPFORMAT       m_cf;
    BOOL             m_fRight;
    BOOL             m_fLogged;

    // Properties
    //Site ptr
    IInputObjectSite *m_pObjSite;

    HWND             m_hwndParent;
    CFolderBar       *m_pFolderBar;

    int m_nSortType;
    CMsgrList *m_pCMsgrList;        // pointer to OE Msgr

    int             m_nChCount;

    // WAB extension
    UINT            m_cRefThisDll;     // Reference count for this DLL
    HPROPSHEETPAGE  m_hPage1; // Handle to the property sheet page

    LPWABEXTDISPLAY m_lpWED;

    LPWABEXTDISPLAY m_lpWEDContext;
    LPMAPIPROP      m_lpPropObj; // For context menu extensions, hang onto the prop obj

};

int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
INT_PTR CALLBACK WabExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#endif //__BAUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\bllist.cpp ===
// bllist.cpp : Implementation of the CMsgrList
// Messenger integration to OE
// Created 05/07/98 by YST
// 

#include "pch.hxx"
#include "bllist.h"
#include "mdisp.h"
#include "util.h"
#include "blobevnt.h"
#include "demand.h"
#include <string.h>
#include <instance.h>
#include "menuutil.h"

static CMsgrList * sg_pMsgrList = NULL;     // global for buddy list

CMsgrList::CMsgrList()
{
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    m_pWndLRoot = NULL;
    m_pWndLLast = NULL;
    m_nRef = 1;
    m_spMsgrObject = NULL;
    m_pMsgrObjectEvents = NULL;
    m_MsgrCookie = 0xffffffff;
}


CMsgrList::~CMsgrList()
{
    Assert(m_nRef == 0);

    if(m_pblInfRoot)
    {
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
    }

    if(m_pWndLRoot)
        FreeWndList(m_pWndLRoot);

    if(m_pMsgrObjectEvents)
    {
        m_pMsgrObjectEvents->DelListOfBuddies();
        if (m_MsgrCookie != 0xffffffff && m_spMsgrObject != NULL)
            m_spMsgrObject->UnadviseOE(m_MsgrCookie);
        m_pMsgrObjectEvents->Release();
        m_pMsgrObjectEvents = NULL;
    }
}

void CMsgrList::Release()
{
    Assert(m_nRef > 0);

    m_nRef--;
    if(m_nRef == 0)
    {
        DelAllEntries(NULL);
        delete this;
        sg_pMsgrList = NULL;
    }
}

// Check and Init Msgr
HRESULT CMsgrList::CheckAndInitMsgr()
{
    if(m_pblInfRoot)
        return(S_OK);
    else
    {
        // Do Initialization again
        if(!m_pMsgrObjectEvents)
        {
            if(HrInitMsgr() == S_OK)
                return(FillList());
            else
                return S_FALSE;
        }
        else
            return(FillList());
    }
    return S_FALSE;         //???
}

// Free list of client UI window
void CMsgrList::FreeWndList(LPMWNDLIST pWndEntry)
{
    if(pWndEntry->pNext)
        FreeWndList(pWndEntry->pNext);
    
    MemFree(pWndEntry);
    pWndEntry = NULL;
}

// Free list buddies
void CMsgrList::FreeMsgrInfoList(LPMINFO pEntry)
{
    if(pEntry == NULL)
        return;
    if(pEntry->pNext)
        FreeMsgrInfoList(pEntry->pNext);

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);
    MemFree(pEntry);
    pEntry = NULL;
}

// Remove buddy from list
void CMsgrList::RemoveMsgrInfoEntry(LPMINFO pEntry)
{
    if(m_pblInfLast == pEntry)
        m_pblInfLast = pEntry->pPrev;

    if(m_pblInfRoot == pEntry)
        m_pblInfRoot = pEntry->pNext;

    MemFree(pEntry->pchMsgrName);
    MemFree(pEntry->pchID);

    if(pEntry->pPrev)
        (pEntry->pPrev)->pNext = pEntry->pNext;

    if(pEntry->pNext)
        (pEntry->pNext)->pPrev = pEntry->pPrev;

    MemFree(pEntry);
    pEntry = NULL;
}

// Check that item is Online starting point for search is pEntry
BOOL CMsgrList::IsContactOnline(TCHAR *pchID, LPMINFO pEntry)
{
    if(!pEntry)
        return(FALSE);

    if(!lstrcmpi(pEntry->pchID, pchID))
    {
        if((pEntry->nStatus != MSTATEOE_OFFLINE)  && (pEntry->nStatus != MSTATEOE_INVISIBLE))
            return(TRUE);
        else
            return(FALSE);
    }
    else if(pEntry->pNext)
        return(IsContactOnline(pchID, pEntry->pNext));
    else
        return(FALSE);
}

// Find entry with ID == szID and remove this from list
void CMsgrList::FindAndRemoveBlEntry(TCHAR *szID, LPMINFO pEntry)
{
    if(!pEntry)
        pEntry = m_pblInfRoot;

    if(!pEntry)
        return;

    if(!lstrcmpi(pEntry->pchID, szID))
    {
        RemoveMsgrInfoEntry(pEntry);
    }
    else if(pEntry->pNext)
        FindAndRemoveBlEntry(szID, pEntry->pNext);
}

// Send message to all registred client UI windows
void CMsgrList::SendMsgToAllUIWnd(UINT msg, WPARAM wParam, LPARAM lParam, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->pNext)
        SendMsgToAllUIWnd(msg, wParam, lParam, pWndEntry->pNext);

    ::SendMessage(pWndEntry->hWndUI, msg, wParam, lParam);
}

// Add client Window to list
void CMsgrList::AddWndEntry(HWND hWnd)
{
    if(m_pWndLLast == NULL)
    {
        // Really first entry
        Assert(!m_pWndLRoot);
        if (!MemAlloc((LPVOID *) &m_pWndLLast, sizeof(MsgrWndList)))
            return;
        m_pWndLRoot = m_pWndLLast;
        m_pWndLLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pWndLLast->pNext), sizeof(MsgrWndList)))
            return;
        (m_pWndLLast->pNext)->pPrev = m_pWndLLast;
        m_pWndLLast = m_pWndLLast->pNext;

    }
    
    m_pWndLLast->pNext = NULL;
    m_pWndLLast->hWndUI = hWnd;

}

// remove entry from WND list
void CMsgrList::RemoveWndEntry(LPMWNDLIST pWndEntry)
{
    if(m_pWndLLast == pWndEntry)
        m_pWndLLast = pWndEntry->pPrev;

    if(m_pWndLRoot == pWndEntry)
        m_pWndLRoot = pWndEntry->pNext;

    if(pWndEntry->pPrev)
        (pWndEntry->pPrev)->pNext = pWndEntry->pNext;

    if(pWndEntry->pNext)
        (pWndEntry->pNext)->pPrev = pWndEntry->pPrev;

    MemFree(pWndEntry);
    pWndEntry = NULL;

}

// Find entry and remove it from list
void CMsgrList::FindAndDelEntry(HWND hWnd, LPMWNDLIST pWndEntry)
{
    if(!pWndEntry)
        pWndEntry = m_pWndLRoot;

    if(!pWndEntry)
        return;

    if(pWndEntry->hWndUI == hWnd)
    {
        RemoveWndEntry(pWndEntry);
    }
    else if(pWndEntry->pNext)
        FindAndDelEntry(hWnd, pWndEntry->pNext);
}

void  CMsgrList::DelAllEntries(LPMWNDLIST pWndEntry)
{
    if(pWndEntry == NULL)
        pWndEntry = m_pWndLRoot;                

    if(pWndEntry == NULL)
        return;

    if(pWndEntry->pNext)
        DelAllEntries(pWndEntry->pNext);

    RemoveWndEntry(pWndEntry);
}

HRESULT CMsgrList::HrInitMsgr(void)
{
	//create the COM server and connect to it
	HRESULT hr = S_OK;
    
    Assert(m_pMsgrObjectEvents == NULL);

    m_spMsgrObject = NULL;
	hr = CoCreateInstance(CLSID_MessengerApp, NULL,CLSCTX_LOCAL_SERVER, 
		                IID_IMsgrOE, (LPVOID *)&m_spMsgrObject);
    if(FAILED(hr))
    {
        return(hr);
    }

    m_pMsgrObjectEvents = new CMsgrObjectEvents();
    if (m_pMsgrObjectEvents == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
	    hr = m_spMsgrObject->AdviseOE(m_pMsgrObjectEvents, &m_MsgrCookie);
        //We, of course, have to release m_pMsgrObjectEvents when we are finished with it
        if(FAILED(hr))
        {
            m_pMsgrObjectEvents->Release();
            m_pMsgrObjectEvents = NULL;
        }
        else 
            m_pMsgrObjectEvents->SetListOfBuddies(this);
    }

    return(hr);
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CMsgrList::EventUserStateChanged(IMsgrUserOE * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);
    BOOL fFinded = FALSE;

    if (SUCCEEDED(hr))
    {
        MSTATEOE nState = MSTATEOE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            LPTSTR pszID;
            pszID = LPTSTRfromBstr(bstrID);
            if (pszID != NULL)
            {
                LPMINFO pInf = m_pblInfRoot;
                if(!pInf)
                {
                    MemFree(pszID);    
                    SysFreeString(bstrID);
                    return(hr);
                }

                // Find buddy in our list
                do
                {
                    if(!lstrcmpi(pInf->pchID, pszID))
                    {
                        fFinded = TRUE;
                        break;
                    }
                } while ((pInf = pInf->pNext) != NULL);

                if(fFinded)
                {
                    pInf->nStatus = nState;
                    SendMsgToAllUIWnd(WM_USER_STATUS_CHANGED, (WPARAM) nState, (LPARAM) pszID);
                }
                MemFree(pszID);
            }
        }
 
    }

    SysFreeString(bstrID);
    return(hr);
}

// Baddy was removed
HRESULT CMsgrList::EventUserRemoved(IMsgrUserOE * pUser)
{
    BSTR bstrID;
    HRESULT hr = pUser->get_LogonName(&bstrID);

    if (SUCCEEDED(hr))
    {
        Assert(m_nRef > 0);  
        LPTSTR pszID;

        pszID = LPTSTRfromBstr(bstrID);
        if (pszID != NULL)
        {
            SendMsgToAllUIWnd(WM_USER_MUSER_REMOVED, (WPARAM) 0, (LPARAM) pszID);
            FindAndRemoveBlEntry(pszID);
            MemFree(pszID);
        }
    }

    SysFreeString(bstrID);
    return(hr);
}

// Event: buddy name was changed
// Add buddy to our list and send message to UI windows about this.
HRESULT CMsgrList::EventUserNameChanged(IMsgrUserOE * pUser)
{
    BSTR bstrName;
    BSTR bstrID;
    BOOL fFinded = FALSE;

    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszName;
        LPTSTR pszID;

        pszName = LPTSTRfromBstr(bstrName);
        if (pszName != NULL)
        {
            pszID = LPTSTRfromBstr(bstrID);
            if (pszID != NULL)
            {
                LPMINFO pInf = m_pblInfRoot;

                // Find buddy in our list
                do
                {
                    if(!lstrcmpi(pInf->pchID, pszID))
                    {
                        fFinded = TRUE;
                        break;
                    }
                } while ((pInf = pInf->pNext) != NULL);

                if(fFinded)
                {
                    if(pInf->pchMsgrName)
                        MemFree(pInf->pchMsgrName);       // Free prev name
                    pInf->pchMsgrName = pszName;
                    pszName = NULL;
                    SendMsgToAllUIWnd(WM_USER_NAME_CHANGED, (WPARAM) 0, (LPARAM) pInf);
                }

                MemFree(pszID);
            }

            SafeMemFree(pszName);
        }
    }

    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);

}

// Event: buddy was added
// Add buddy to our list and send message to UI windows about this.

HRESULT CMsgrList::EventUserAdded(IMsgrUserOE * pUser)
{
    BSTR bstrName;
    BSTR bstrID;

    HRESULT hr = pUser->get_LogonName(&bstrID);
    hr = pUser->get_FriendlyName(&bstrName);
    if (SUCCEEDED(hr))
    {
        MSTATEOE nState = MSTATEOE_UNKNOWN;
        if(SUCCEEDED(pUser->get_State(&nState)))
        {
            LPTSTR pszName;
            LPTSTR pszID;

            pszName = LPTSTRfromBstr(bstrName);
            if (pszName != NULL)
            {
                pszID = LPTSTRfromBstr(bstrID);
                if (pszID != NULL)
                {
                    AddMsgrListEntry(pszName, pszID, nState);
                    SendMsgToAllUIWnd(WM_USER_MUSER_ADDED, (WPARAM) 0, (LPARAM) m_pblInfLast);

                    MemFree(pszID);
                }

                MemFree(pszName);
            }
        }
    }
    SysFreeString(bstrName);
    SysFreeString(bstrID);
    return(hr);
}

HRESULT CMsgrList::EventLogoff()
{
    SendMsgToAllUIWnd(WM_MSGR_LOGOFF, (WPARAM) 0, (LPARAM) 0);
    FreeMsgrInfoList(m_pblInfRoot);
    m_pblInfRoot = NULL;
    m_pblInfLast = NULL;
    return(S_OK);
    
}

HRESULT CMsgrList::EventAppShutdown()
{
    SendMsgToAllUIWnd(WM_MSGR_SHUTDOWN, (WPARAM) 0, (LPARAM) 0);
    return(S_OK);
    
}

HRESULT CMsgrList::EventLogonResult(long lResult)
{
    if(!m_pblInfRoot && SUCCEEDED(lResult))
        FillList();
    else if(SUCCEEDED(lResult))
    {
        EnterCriticalSection(&g_csMsgrList);
        FreeMsgrInfoList(m_pblInfRoot);
        m_pblInfRoot = NULL;
        m_pblInfLast = NULL;
        FillList();
        LeaveCriticalSection(&g_csMsgrList);
    }
    SendMsgToAllUIWnd(WM_MSGR_LOGRESULT, (WPARAM) 0, (LPARAM) lResult);
    return(S_OK);
}

// return number of buddies
long CMsgrList::GetCount()
{
    HRESULT hr = E_FAIL;
    long lCount = 0;
    CComPtr<IMsgrUsersOE> spBuddies;

    if (!m_spMsgrObject)
        goto Exit;

    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
Exit:
    return(lCount);
}

HRESULT CMsgrList::FillList()
{
    long lCount = 0;
	IMsgrUserOE* pUser = NULL;

	//process the Buddies list
	IMsgrUsersOE *pBuddies = NULL;

    if(!m_spMsgrObject)
        return S_FALSE;

	HRESULT hr = m_spMsgrObject->get_ContactList(&pBuddies);
    if(FAILED(hr))
    {
FilErr:
        if(m_pMsgrObjectEvents)
        {
            m_pMsgrObjectEvents->DelListOfBuddies();
            if (m_MsgrCookie != 0xffffffff)
            {
                if (m_spMsgrObject)
                    m_spMsgrObject->UnadviseOE(m_MsgrCookie);
                m_MsgrCookie = 0xffffffff;
            }
            m_pMsgrObjectEvents->Release();
            m_pMsgrObjectEvents = NULL;
        }
        return(hr);
    }

    //Check the current state (in case the client was already running and was 
	//not in the logoff state
	MSTATEOE lState = MSTATEOE_OFFLINE;
    if (m_spMsgrObject)
	    hr = m_spMsgrObject->get_LocalState(&lState);

    if(FAILED(hr) /*|| lState == MSTATEOE_OFFLINE  !(lState == MSTATEOE_ONLINE || lState == MSTATEOE_BUSY || lState == MSTATEOE_INVISIBLE)*/)
    {
Err2:
        pBuddies->Release();
        pBuddies = NULL;
        goto FilErr;
    }
    else if(lState == MSTATEOE_OFFLINE)
    {
        if(FAILED(AutoLogon()))
            goto Err2;
    }

    if(!SUCCEEDED(pBuddies->get_Count(&lCount)))
                    goto Err2;

    for (int i = 0; i < lCount; i++)
	{
	    hr = pBuddies->Item(i, &pUser);
		if(SUCCEEDED(hr))
		{
		    // EventUserAdded(pUser);
            BSTR bstrName;
            BSTR bstrID;

            hr = pUser->get_LogonName(&bstrID);
            hr = pUser->get_FriendlyName(&bstrName);
            if (SUCCEEDED(hr))
            {
                MSTATEOE nState = MSTATEOE_UNKNOWN;
                if(SUCCEEDED(pUser->get_State(&nState)))
                {
                    LPTSTR pszName;
                    LPTSTR pszID;

                    pszName = LPTSTRfromBstr(bstrName);
                    if (pszName != NULL)
                    {
                        pszID = LPTSTRfromBstr(bstrID);
                        if (pszID != NULL)
                        {
                            AddMsgrListEntry(pszName, pszID, nState);
                            MemFree(pszID);
                        }

                        MemFree(pszName);
                    }
                }
            }
            SysFreeString(bstrName);
            SysFreeString(bstrID);
            pUser->Release();
        }
    }
    pBuddies->Release();
    return(S_OK);
}

// Add entry to list of buddies
void CMsgrList::AddMsgrListEntry(TCHAR *szName, TCHAR *szID, int nState)
{
    if(m_pblInfLast == NULL)
    {
        // Really first entry
        Assert(!m_pblInfRoot);
        if (!MemAlloc((LPVOID *) &m_pblInfLast, sizeof(oeMsgrInfo)))
            return;
        m_pblInfRoot = m_pblInfLast;
        m_pblInfLast->pPrev = NULL;
    }
    else 
    {
        if (!MemAlloc((LPVOID *) &(m_pblInfLast->pNext), sizeof(oeMsgrInfo)))
            return;
        (m_pblInfLast->pNext)->pPrev = m_pblInfLast;
        m_pblInfLast = m_pblInfLast->pNext;

    }
    
    m_pblInfLast->pNext = NULL;

    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchMsgrName), lstrlen(szName) + 1))
        return;
    lstrcpy(m_pblInfLast->pchMsgrName, szName);

    if (!MemAlloc((LPVOID *) &(m_pblInfLast->pchID), lstrlen(szID) + 1))
        return;
    lstrcpy(m_pblInfLast->pchID, szID);
    m_pblInfLast->nStatus = nState;

}

// register ui window in list
void CMsgrList::RegisterUIWnd(HWND hWndUI)
{
    CheckAndInitMsgr();
    AddWndEntry(hWndUI);
}

// remove UI window from list
void CMsgrList::UnRegisterUIWnd(HWND hWndUI)
{
    if(hWndUI)
        FindAndDelEntry(hWndUI);
}

// This call Messenger UI for instant message.
HRESULT CMsgrList::SendInstMessage(TCHAR *pchID)
{
    Assert(m_spMsgrObject);
    BSTRING bstrName(pchID);
    VARIANT var;
    var.bstrVal = bstrName;
    var.vt = VT_BSTR;

    HRESULT hr = S_OK;
    if(m_spMsgrObject)
        hr = m_spMsgrObject->LaunchIMUI(var);

    return(hr);
}

HRESULT CMsgrList::AutoLogon()
{
    if(m_spMsgrObject)
    {
        if(DwGetOption(OPT_BUDDYLIST_CHECK))
            m_spMsgrObject->AutoLogon();
    }
    else
        return(E_FAIL);

    return S_OK;

}

HRESULT CMsgrList::UserLogon()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject->LaunchLogonUI());
    else
        return(S_FALSE);
}

// Logoff call
HRESULT CMsgrList::UserLogoff()
{
    if(!m_spMsgrObject)
        return E_UNEXPECTED;

    return(m_spMsgrObject->Logoff());
}

// Get/Set local states.
HRESULT CMsgrList::GetLocalState(MSTATEOE *pState)
{
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(pState)))
        return(S_OK);
    else
        return(S_FALSE);
}

// Check name: this is local name?
BOOL CMsgrList::IsLocalName(TCHAR *pchName)
{
    CComBSTR cbstrID;
    HRESULT hr;
    BOOL fRes = FALSE;

    if(m_spMsgrObject)
    {
        hr = m_spMsgrObject->get_LocalLogonName(&cbstrID);
        if(FAILED(hr))
            return FALSE;
        TCHAR *pch = LPTSTRfromBstr(cbstrID);
        if(!lstrcmpi(pchName, pch))
            fRes = TRUE;

        MemFree(pch);
    }

    return(fRes);    
}

// Check current state
BOOL CMsgrList::IsLocalOnline(void)
{
    MSTATEOE State;
    if(m_spMsgrObject && SUCCEEDED(m_spMsgrObject->get_LocalState(&State)))
    {
        switch(State)
        {
            case MSTATEOE_ONLINE:
            case MSTATEOE_INVISIBLE:
            case MSTATEOE_BUSY:
            case MSTATEOE_BE_RIGHT_BACK:
            case MSTATEOE_IDLE:
            case MSTATEOE_AWAY:
            case MSTATEOE_ON_THE_PHONE:
            case MSTATEOE_OUT_TO_LUNCH:
                return(TRUE);

            default:
                return(FALSE);
        }
    }
    return(FALSE);
}

HRESULT CMsgrList::SetLocalState(MSTATEOE State)
{
    if(m_spMsgrObject && State != MSTATEOE_UNKNOWN)
    {
        m_spMsgrObject->put_LocalState(State);
        return S_OK;                        
    }
    else
        return S_FALSE;
}

HRESULT CMsgrList::NewOnlineContact()
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchAddContactUI(NULL));
    else
        return(S_FALSE); 

}

HRESULT CMsgrList::LaunchOptionsUI(void)
{
    if(m_spMsgrObject)
        return(m_spMsgrObject-> LaunchOptionsUI());
    else
        return(S_FALSE); 
}

//****************************************************************************
//
// void CMsgrList::DeleteUser
//
// This function finds
// the buddy to be removed in the MsgrList and then calls the Remove method.
//
//****************************************************************************

HRESULT CMsgrList::FindAndDeleteUser(TCHAR * pchID, BOOL fDelete) 
{
    USES_CONVERSION;

    HRESULT             hr = E_FAIL;
    INT                 i;
    LONG                lCount = 0;
    BOOL                bFound = FALSE;
    CComPtr<IMsgrUserOE>  spUser;
    CComPtr<IMsgrUsersOE> spBuddies;
    // BSTRING             bstrName(pchID);
    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
    {
        hr = E_FAIL;
        goto Exit;
    }
    hr = m_spMsgrObject->get_ContactList(&spBuddies);
    if( FAILED(hr) )
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Buddies() failed, hr = %s"), g_GetErrorString(hr));
        Assert(FALSE);
        goto Exit;
    }

    //Iterate through the MsgrList make sure that the buddy we wish to remove is effectively in the list
    hr = spBuddies->get_Count(&lCount);
    Assert(SUCCEEDED(hr));
    
    for(i = 0; ((i<lCount) && (!bFound)); i++)
    {
        CComBSTR    cbstrID;

        spUser.Release();
        hr = spBuddies->Item(i, &spUser);
        
        if (SUCCEEDED(hr))
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i succeeded"), i);
            
            hr = spUser->get_LogonName(&cbstrID);
            Assert(SUCCEEDED(hr));
            TCHAR *pch = LPTSTRfromBstr(cbstrID);

            // BSTRING bstrName(pchID);
            
            // if (_tcsicmp( W2T((BSTR)cbstrID), W2T(bstrName)) == 0)
            if (lstrcmpi(pch, pchID) == 0)
                bFound = TRUE;

            MemFree(pch);

            if (bFound)
                break;
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("Item : %i failed, hr = %s"), i, g_GetErrorString(hr));
            Assert(FALSE);
        }
    }
    
    // if we found the buddy in the list
    if( bFound )
    {
        if(fDelete)
            //finally, make the request to remove the buddy to the MsgrList
            hr = spBuddies->Remove(spUser);
        else
            // just search
            hr = S_OK;
    }
    else // Not found
    
        hr = DISP_E_MEMBERNOTFOUND;
Exit:
//    SysFreeString(bstrName);
    return(hr);
}

HRESULT CMsgrList::AddUser(TCHAR * pchID) 
{
    CComPtr<IMsgrUserOE>  spUser;
    CComPtr<IMsgrUsersOE> spUsers;
    BSTRING             bstrName(pchID);

    HRESULT hr = FindAndDeleteUser(pchID, FALSE /*fDelete*/);
    if(hr != DISP_E_MEMBERNOTFOUND)
        return(hr);

    // if not found, add buddy

    // get an interface pointer to the MsgrList, so we can call the method Remove after
    if (!m_spMsgrObject)
        return E_FAIL;
    hr = m_spMsgrObject->LaunchAddContactUI(bstrName);

    return(hr);

}


// Global functions available for everybody

// Entrance to MsgrList
CMsgrList *OE_OpenMsgrList(void)
{
    if (g_dwHideMessenger == BL_HIDE)
        return(NULL);

    EnterCriticalSection(&g_csMsgrList);
    if(!sg_pMsgrList)     
    {
        // this first call, create class
        sg_pMsgrList = new(CMsgrList);
        if(sg_pMsgrList)
        {
            // Init of User List
            if(sg_pMsgrList->HrInitMsgr() == S_OK)
            {
                if(sg_pMsgrList->FillList() != S_OK)
                    goto ErrEx;
            }
            else
            {
ErrEx:
                sg_pMsgrList->Release();
                g_dwHideMessenger = g_dwHideMessenger | BL_NOTINST;
            }
        }

    }
    else
        sg_pMsgrList->AddRef();

    LeaveCriticalSection(&g_csMsgrList);

    return(sg_pMsgrList);
}

// Close entrance to MsgrList
void    OE_CloseMsgrList(CMsgrList *pCMsgrList)
{
    Assert(pCMsgrList == sg_pMsgrList);

    EnterCriticalSection(&g_csMsgrList);
    sg_pMsgrList->Release();
    LeaveCriticalSection(&g_csMsgrList);
}

HRESULT OE_Msgr_Logoff(void)
{
    MSTATEOE State;
    HRESULT hr = S_OK;
    
    if(!sg_pMsgrList)
    {
        EnterCriticalSection(&g_csMsgrList);
        sg_pMsgrList = new(CMsgrList);
        LeaveCriticalSection(&g_csMsgrList);

        if(!sg_pMsgrList)
            return(E_UNEXPECTED);

        // Init of User List
        if(FAILED(hr = sg_pMsgrList->HrInitMsgr()))
            goto logoff_end;

        else if(FAILED(hr = sg_pMsgrList->GetLocalState(&State)) || State == MSTATEOE_OFFLINE)
            goto logoff_end;
        else
            hr = sg_pMsgrList->UserLogoff();

    }
    else
    {
        return(sg_pMsgrList->UserLogoff());  // we cannot delete sg_pMsgrList in this case!
    }

logoff_end:
    if(sg_pMsgrList)
    {
        OE_CloseMsgrList(sg_pMsgrList);
    }
    return(hr);
}

HRESULT InstallMessenger(HWND hWnd)
{
    HRESULT         hr  = REGDB_E_CLASSNOTREG;
	uCLSSPEC classpec;
    TCHAR szBuff[CCHMAX_STRINGRES];
		
   	classpec.tyspec=TYSPEC_CLSID;
	classpec.tagged_union.clsid = CLSID_MessengerApp;
	
  	// See below for parameter definitions and return values
	hr = FaultInIEFeature(hWnd, &classpec, NULL, FIEF_FLAG_FORCE_JITUI);

	if (hr != S_OK) {
        if(hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            AthLoadString(idsJITErrDenied, szBuff, ARRAYSIZE(szBuff));
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
        else
        {
            AthLoadString(idsBAErrJITFail, szBuff, ARRAYSIZE(szBuff));
            MenuUtil_BuildMessengerString(szBuff);
            AthMessageBox(hWnd, MAKEINTRESOURCE(idsAthena), szBuff,
                    NULL, MB_OK | MB_ICONSTOP);
        }
		hr = REGDB_E_CLASSNOTREG;
	}

        return hr;
}

#ifdef NEEDED
HRESULT OE_Msgr_Logon(void)
{
    if(!sg_pMsgrList)
        return S_FALSE;
    else
        return(sg_pMsgrList->UserLogon());

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\blobevnt.cpp ===
//****************************************************************************
//
// BLObEvnt.cpp
// Messenger integration to OE
// Created 04/20/98 by YST
//
//  Copyright (c) Microsoft Corporation 1997-1998
//


#include "pch.hxx"
#include "bactrl.h"
#include "MDispid.h"
#include "BLObEvnt.h"
#include "demand.h"
#include "bllist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define ASSERT _ASSERTE

#define STR_MAX     256

//****************************************************************************
//
// CLASS CMsgrObjectEvents
//
//****************************************************************************

//****************************************************************************
//
// Construction/Destruction
//
//****************************************************************************

CMsgrObjectEvents::CMsgrObjectEvents() 
{
    // m_pBlAbCtrl = NULL;
    // lLocalState = MSTATEOE_OFFLINE;
}

CMsgrObjectEvents::~CMsgrObjectEvents()
{

}


//****************************************************************************
//
// Methods from IUnknown
//
//****************************************************************************

//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::AddRef()
//
// Purpose : increment the object's reference count,
// Entry   : None
// Exit    : current count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::AddRef()
{
	return RefCount::AddRef();
}


//****************************************************************************
//
// STDMETHODIMP_(ULONG) CMsgrObjectEvents::Release()
//
// Purpose : decrement the object's reference count
// Entry   : None
// Exit    : returns new count
//
//****************************************************************************

STDMETHODIMP_ (ULONG) CMsgrObjectEvents::Release()
{
	return RefCount::Release();
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::QueryInterface(REFIID iid, LPVOID *ppv)
//
// returns a pointer to the requested interface on the same object
// Purpose: To retrieve a pointer to requested interface
// Entry  : iid -- GUID of requested interface
// Exit   : ppv -- pointer to requested interface (if one exists)
//          return value : HRESULT
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::QueryInterface (REFIID riid, LPVOID *ppv)
{
	*ppv = NULL;
	HRESULT hr = E_NOINTERFACE;

	if (riid == IID_IUnknown)
	 	*ppv = (LPVOID) this;
    else if (riid == DIID_DMsgrOEEvents) 
    	*ppv = (LPVOID) this;
	else if (riid == IID_IDispatch) 
    	*ppv = (LPVOID) this;
              
    if (*ppv) 
    {
	 	((LPUNKNOWN)*ppv)->AddRef();
		hr = S_OK;
	}
	return hr;
}

//****************************************************************************
//
// IDispatch implementation
//
//****************************************************************************


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
//
// Set pcTypeInfo to 0 because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfoCount(UINT* pcTypeInfo)
{
//	g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfoCount call succeeded"));

	*pcTypeInfo = 0 ;
	return NOERROR ;
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetTypeInfo(
	UINT iTypeInfo,
	LCID,          // This object does not support localization.
	ITypeInfo** ppITypeInfo)
{    
	*ppITypeInfo = NULL ;

	if(iTypeInfo != 0)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call failed -- bad iTypeInfo index"));

		return DISP_E_BADINDEX ; 
	}
	else
	{
		 //g_AddToLog(LOG_LEVEL_COM, _T("GetTypeInfo call succeeded"));

		return E_NOTIMPL;
	}
}


//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
//												const IID& iid,
//												OLECHAR** arrayNames,
//												UINT countNames,
//												LCID,          // Localization is not supported.
//												DISPID* arrayDispIDs)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::GetIDsOfNames(  
	const IID& iid,
	OLECHAR** arrayNames,
	UINT countNames,
	LCID,          // Localization is not supported.
	DISPID* arrayDispIDs)
{
	HRESULT hr;
	if (iid != IID_NULL)
	{
		// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call failed -- bad IID"));

		return DISP_E_UNKNOWNINTERFACE ;
	}

	// g_AddToLog(LOG_LEVEL_COM, _T("GetIDsOfNames call succeeded"));

	hr = E_NOTIMPL;

	return hr ;
}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::SetListOfBuddies(CMsgrList *pList)
{
    m_pMsgrList = pList;
    return S_OK;

}

// Set BLAB control for CMsgrObjectEvents
STDMETHODIMP CMsgrObjectEvents::DelListOfBuddies()
{
    m_pMsgrList = NULL;
    return S_OK;

}

//****************************************************************************
//
// STDMETHODIMP CMsgrObjectEvents::Invoke(   
//										  DISPID dispidMember,
//										  const IID& iid,
//										  LCID,          // Localization is not supported.
//										  WORD wFlags,
//										  DISPPARAMS* pDispParams,
//										  VARIANT* pvarResult,
//										  EXCEPINFO* pExcepInfo,
//										  UINT* pArgErr)
//
// Returns E_NOTIMPL because we do not support type library
//
//****************************************************************************

STDMETHODIMP CMsgrObjectEvents::Invoke(   
      DISPID dispidMember,
      const IID& iid,
      LCID,          // Localization is not supported.
      WORD wFlags,
      DISPPARAMS* pDispParams,
      VARIANT* pvarResult,
      EXCEPINFO* pExcepInfo,
      UINT* pArgErr)
{   
	// g_AddToLog(LOG_LEVEL_FUNCTIONS, _T("CMsgrObjectEvents::Invoke entered"));
	// g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Dispid passed : %s"), g_GetStringFromDISPID(dispidMember));
	
	HRESULT hr;
    HRESULT hrRet;

    if (iid != IID_NULL)
    {
        // g_AddToLog(LOG_LEVEL_COM, _T("Invoke call failed -- bad IID"));
        return DISP_E_UNKNOWNINTERFACE ;
    }

    ::SetErrorInfo(0, NULL) ;

    CComPtr<IMsgrUserOE>   spUser;
    CComPtr<IMsgrUsersOE> spBuddies;
        
    switch (dispidMember) 
    {
    case DISPID_ONLOGONRESULT:
        //we should only have one parameter, the result, and that it is a long
        ASSERT(pDispParams->cArgs == 1);
        ASSERT(pDispParams->rgvarg->vt == VT_I4);
        // g_AddToLog(LOG_LEVEL_NOTIFICATIONS, _T("Result passed : %s"), g_GetStringFromLogonResult(pDispParams->rgvarg->lVal));

        if(m_pMsgrList)
            hrRet = m_pMsgrList->EventLogonResult(pDispParams->rgvarg->lVal);
        break;

    case DISPID_ONUSERFRIENDLYNAMECHANGERESULT :
        _ASSERTE(pDispParams->cArgs == 3);
        _ASSERTE(pDispParams->rgvarg[2].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_DISPATCH);

        //if(lLocalState >= MSTATEOE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                hrRet = m_pMsgrList->EventUserNameChanged(spUser);
        }

        break;

    case DISPID_ONLOGOFF:
        if(m_pMsgrList)
            hrRet = m_pMsgrList->EventLogoff();
        break;
        
     case DISPID_ONAPPSHUTDOWN:
        if(m_pMsgrList)
            hrRet = m_pMsgrList->EventAppShutdown();
        break;

   case DISPID_ONLISTADDRESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //

        // WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
        // The parameters are inversed. This means that the las parameter in the
        // prototype of the function is the first one in the array received, and so on

        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was added sucessfully."));

                if(m_pMsgrList)
                    hrRet = m_pMsgrList->EventUserAdded(spUser);
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IMsgrUserOE failed"));
        }

        break;

    case DISPID_ONLISTREMOVERESULT:
        // we should have two parameter, HRESULT, and the pMsgrUser
        //
        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_DISPATCH);

        hrRet = V_I4(&pDispParams->rgvarg[1]);
        hr = pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);

        if (SUCCEEDED(hr))
        {
            if( SUCCEEDED(hrRet) )
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was removed sucessfully."));
                if(m_pMsgrList)
                    hrRet = m_pMsgrList->EventUserRemoved(spUser);
            }
            else
            {
                // g_AddToLog(LOG_LEVEL_COM, _T("User was not removed due to error %s."), g_GetErrorString(hrRet));
            }
        }
        else
        {
            // g_AddToLog(LOG_LEVEL_COM, _T("QueryInterface for IID_IMsgrUserOE failed"));
        }

        break;

    case DISPID_ONUSERSTATECHANGED:
        //we should only have two parameters, the previousState and the pMsgrUser 
        ASSERT(pDispParams->cArgs == 2);
        ASSERT(pDispParams->rgvarg[1].vt == VT_DISPATCH);
        ASSERT(pDispParams->rgvarg[0].vt == VT_I4);

        // if(lLocalState >= MSTATEOE_LOCAL_FINDING_SERVER)
        //    break;

        hr = pDispParams->rgvarg[1].pdispVal->QueryInterface(IID_IMsgrUserOE, (LPVOID *)&spUser);
        if (SUCCEEDED(hr))
        {
            if(m_pMsgrList)
                hrRet = m_pMsgrList->EventUserStateChanged(spUser);
        }

        break;

    case DISPID_ONLOCALSTATECHANGERESULT:
        //we should only have two parameters, hr and the LocalState
#if 0
        _ASSERTE(pDispParams->cArgs >== 2);
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_I4);
#endif // 0
        // lLocalState = pDispParams->rgvarg[0].lVal;
        // hrRet = pBlCLientDlg->EventLocalStateChanged(pDispParams->rgvarg[0].lVal);
        break;
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\mdispid.h ===
#ifndef _MDISPID_H_
#define _MDISPID_H_

//
// Dispatch IDs for DMsgrObjectEvents Dispatch Events.
//
#define DISPID_ONLOGONRESULT                  100
#define DISPID_ONLOGOFF                       101
#define DISPID_ONLISTADDRESULT                102
#define DISPID_ONLISTREMOVERESULT             103
#define DISPID_ONMESSAGEPRIVACYCHANGERESULT   104
#define DISPID_ONPROMPTCHANGERESULT           105
#define DISPID_ONUSERFRIENDLYNAMECHANGERESULT 106
#define DISPID_ONUSERSTATECHANGED             107
#define DISPID_ONTEXTRECEIVED                 108
#define DISPID_ONLOCALFRIENDLYNAMECHANGERESULT 109
#define DISPID_ONLOCALSTATECHANGERESULT       110
#define DISPID_ONAPPINVITERECEIVED            111
#define DISPID_ONAPPINVITEACCEPTED            112
#define DISPID_ONAPPINVITECANCELLED           113
#define DISPID_ONSENDRESULT                   114
#define DISPID_ONNEWERCLIENTAVAILABLE         115
#define DISPID_ONFINDRESULT                   116
#define DISPID_ONINVITEMAILRESULT             117
#define DISPID_ONREQUESTURLRESULT             118
#define DISPID_ONSESSIONSTATECHANGE           119
#define DISPID_ONUSERJOIN                     120
#define DISPID_ONUSERLEAVE                    121
#define DISPID_ONNEWSESSIONREQUEST            122
#define DISPID_ONINVITEUSER                   123
#define DISPID_ONSERVICELOGOFF                124
#define DISPID_ONPRIMARYSERVICECHANGED        125
#define DISPID_ONAPPSHUTDOWN                  126
#define DISPID_ONUNREADEMAILCHANGED           127
#define DISPID_ONUSERDROPPED                  128
#define DISPID_ONREQUESTURLPOSTRESULT         129
#define DISPID_ONNEWERSITESAVAILABLE          130
#define DISPID_ONTRUSTCHANGED                 131
#define DISPID_ONFILETRANSFERINVITERECEIVED   132
#define DISPID_ONFILETRANSFERINVITEACCEPTED   133
#define DISPID_ONFILETRANSFERINVITECANCELLED  134
#define DISPID_ONFILETRANSFERCANCELLED        135
#define DISPID_ONFILETRANSFERSTATUSCHANGE     136
#define DISPID_ONSPMESSAGERECEIVED            137
#define DISPID_ONLOCALPROPERTYCHANGERESULT    141
#define DISPID_ONBUDDYPROPERTYCHANGERESULT    142
#define DISPID_ONNOTIFICATIONRECEIVED         143
	
//
// Dispatch IDs for DMessengerAppEvents Dispatch Events.
// (don't overlap DMsgrObjectEvents ids)
//
#define DISPID_ONBEFORELAUNCHIMUI           20000
#define DISPID_ONSHOWIMUI		            20001
#define DISPID_ONDESTROYIMUI                20002
#define DISPID_ONINDICATEMESSAGERECEIVED	20003
#define DISPID_ONSTATUSTEXT					20004
#define DISPID_ONTITLEBARTEXT				20005
#define DISPID_ONINFOBARTEXT				20006
#define DISPID_ONSENDENABLED				20007
#define DISPID_ONTRANSLATEACCELERATOR		20008
#define DISPID_ONFILETRANSFER				20009
#define DISPID_ONVOICESESSIONSTATE			20010
#define DISPID_ONVOICEVOLUMECHANGED		    20011
#define DISPID_ONMICROPHONEMUTE			    20012

//
// Dispatch IDs for IMsgrObject.
//
#define DISPID_CREATEUSER                     100
#define DISPID_LOGON                          104
#define DISPID_LOGOFF                         105
#define DISPID_GETLIST                        0x60020003
#define DISPID_LOCALLOGONNAME                 0x60020004
#define DISPID_LOCALFRIENDLYNAME              0x60020005
#define DISPID_LOCALSTATE                     0x60020006
#define DISPID_MESSAGEPRIVACY                 0x60020008
#define DISPID_PROMPT                         0x6002000a
#define DISPID_SENDAPPINVITE                  108
#define DISPID_SENDAPPINVITEACCEPT            109
#define DISPID_SENDAPPINVITECANCEL            110
#define DISPID_LOCALOPTION                    0x6002000f
#define DISPID_FINDUSER                       111
#define DISPID_SENDINVITEMAIL                 112
#define DISPID_REQUESTURL                     113
#define DISPID_IMSESSIONS                     0x60020014
#define DISPID_CREATEIMSESSIONS               114
#define DISPID_SESSIONREQUESTACCEPT           115
#define DISPID_SESSIONREQUESTCANCEL           116
#define DISPID_SERVICES                       0x60020018
#define DISPID_UNREADEMAIL                    0x60020019
#define DISPID_SENDFILETRANSFERINVITE         117
#define DISPID_SENDFILETRANSFERINVITEACCEPT   118
#define DISPID_SENDFILETRANSFERINVITECANCEL   119
#define DISPID_CANCELFILETRANSFER             120
#define DISPID_FILETRANSFERSTATUS             121


//
// Dispatch IDs for IMessengerApp.
//
#define DISPID_APPLICATION                    0x60020000
#define DISPID_PARENT                         0x60020001
#define DISPID_QUIT                           100
#define DISPID_NAME                           0x60020003
#define DISPID_FULLNAME                       0x60020004
#define DISPID_PATH                           0x60020005
#define DISPID_LAUNCHLOGONUI                  200
#define DISPID_LAUNCHOPTIONSUI                201
#define DISPID_LAUNCHADDCONTACTUI             202
#define DISPID_LAUNCHFINDCONTACTUI            203
#define DISPID_LAUNCHIMUI                     210
#define DISPID_IMWINDOWS                      0x6002000b
#define DISPID_TOOLBAR                        0x6002000c
#define DISPID_STATUSBAR                      0x6002000e
#define DISPID_STATUSTEXT                     0x60020010
#define DISPID_GETHWND                        0x60020012
#define DISPID_LEFT                           0x60020013
#define DISPID_TOP                            0x60020015
#define DISPID_WIDTH                          0x60020017
#define DISPID_HEIGHT                         0x60020019
#define DISPID_MSGS_VISIBLE                   0x6002001b
#define DISPID_AUTOLOGON                      222
#define DISPID_FIRSTTIMECREDENTIONS           0x6002001e
#define DISPID_CACHEDPASSWORD                 0x6002001f
#define DISPID_REQUESTURLPOST                 223
#define DISPID_MSGS_TASKBARICON               224

//
// Dispatch IDs for IMsgrUser.
//
#define DISPID_USERFRIENDLYNAME               0x60020000
#define DISPID_USEREMAILADDRESS               0x60020002
#define DISPID_USERSTATE                      0x60020003
#define DISPID_USERLOGONNAME                  0x60020004
#define DISPID_USERSENDTEXT                   101
#define DISPID_USERSERVICE                    0x60020006

//
// Dispatch IDs for IMsgrUsers.
//
#define DISPID_USERSCOUNT                     0x60020000
#define DISPID_USERSADD                       100
#define DISPID_USERSREMOVE                    101

//
// Dispatch IDs for IMsgrService.
//
#define DISPID_SERVICESERVICENAME             0x60020000
#define DISPID_SERVICELOGONNAME               0x60020001
#define DISPID_SERVICEFRIENDLYNAME            0x60020002
#define DISPID_SERVICECAPABILITIES            0x60020004
#define DISPID_SERVICESTATUS                  0x60020005
#define DISPID_SERVICELOGOFF                  0x60020006
#define DISPID_SERVICEFINDUSER                0x60020007
#define DISPID_SERVICESENDINVITEMAIL          0x60020008
#define DISPID_SERVICEREQUESTURL              0x60020009
#define DISPID_SERVICEPROFILEFIELD            0x6002000a

//
// Dispatch IDs for IMsgrServices.
//
#define DISPID_SERVICESPRIMARYSERVICE         0x60020000
#define DISPID_SERVICESCOUNT                  0x60020002

#endif // ! _MDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\clutil.cpp ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.cpp
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************


#include "pch.hxx"
#include "clUtil.h"
#include <instance.h>
#include "demand.h"


#define ASSERT _ASSERTE

//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

RefCount::RefCount(void)
{
    m_cRef = 1;
    
    Assert(NULL != g_pInstance);
    CoIncrementInit("RefCount::RefCount", MSOEAPI_START_SHOWERRORS, NULL, NULL);
}

//****************************************************************************
//
// Destructor
//
//****************************************************************************

RefCount::~RefCount(void)
{
    CoDecrementInit("RefCount::RefCount", NULL);    
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
   ASSERT(m_cRef >= 0);

   InterlockedIncrement(&m_cRef);

   return (ULONG) m_cRef;
}


//****************************************************************************
//
// ULONG STDMETHODCALLTYPE RefCount::Release(void)
//
//****************************************************************************

ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
    if (0 == InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    ASSERT(m_cRef > 0);
    return (ULONG) m_cRef;
}


//****************************************************************************
//
// CLASS CNotify
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

CNotify::CNotify() :
    m_pcnpcnt(NULL),
    m_pcnp(NULL),
    m_dwCookie(0),
    m_pUnk(NULL)
{
}


//****************************************************************************
//
// destructor
//
//****************************************************************************

CNotify::~CNotify()
{
    Disconnect(); // Make sure we're disconnected
}


//****************************************************************************
//
// HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
//
// Connects the sink to the container
//
//****************************************************************************

HRESULT CNotify::Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN)
{
    HRESULT hr;

    ASSERT(0 == m_dwCookie);

    // Get the connection container
    hr = pUnk->QueryInterface(IID_IConnectionPointContainer, (void **)&m_pcnpcnt);
    if (SUCCEEDED(hr))
    {
        // Find an appropriate connection point
        hr = m_pcnpcnt->FindConnectionPoint(riid, &m_pcnp);
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != m_pcnp);
            // Connect the sink object
            hr = m_pcnp->Advise((IUnknown *)pUnkN, &m_dwCookie);
        }
    }

    if (FAILED(hr))
    {
        m_dwCookie = 0;
    }
    else
    {
        m_pUnk = pUnk; // keep around for caller
    }

    return hr;
}


//****************************************************************************
//
// HRESULT CNotify::Disconnect (void)
//
// Disconnects the sink from the container
//
//****************************************************************************

HRESULT CNotify::Disconnect (void)
{
    if (0 != m_dwCookie)
    {

        // Disconnect the sink object
        m_pcnp->Unadvise(m_dwCookie);
        m_dwCookie = 0;

        m_pcnp->Release();
        m_pcnp = NULL;

        m_pcnpcnt->Release();
        m_pcnpcnt = NULL;

        m_pUnk = NULL;
    }

    return S_OK;
}


//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

// We don't support construction from an ANSI string in the Unicode build.
#ifndef UNICODE

BSTRING::BSTRING(LPCSTR lpcString)
{
    m_bstr = NULL;

    // Compute the length of the required BSTR, including the null
    int cWC =  MultiByteToWideChar(CP_ACP, 0, lpcString, -1, NULL, 0);
    if (cWC <= 0)
        return;

    // Allocate the BSTR, including the null
    m_bstr = SysAllocStringLen(NULL, cWC - 1); // SysAllocStringLen adds another 1

    ASSERT(NULL != m_bstr);
    if (NULL == m_bstr)
    {
        return;
    }

    // Copy the string
    MultiByteToWideChar(CP_ACP, 0, lpcString, -1, (LPWSTR) m_bstr, cWC);

    // Verify that the string is null terminated
    ASSERT(0 == m_bstr[cWC - 1]);
}

#endif // #ifndef UNICODE


//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

//****************************************************************************
//
// Constructor
//
//****************************************************************************

BTSTR::BTSTR(BSTR bstr)
{
    m_psz = LPTSTRfromBstr(bstr);
}


//****************************************************************************
//
// Destructor
//
//****************************************************************************

BTSTR::~BTSTR()
{
    if (NULL != m_psz)
        MemFree(m_psz);
}


//****************************************************************************
//
// LPTSTR LPTSTRfromBstr(BSTR bstr)
//
// Converts a BSTR to a LPTSTR
//
//****************************************************************************

LPTSTR LPTSTRfromBstr(BSTR bstr)
{
    if (NULL == bstr)
        return NULL;

    int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
    if (cch <= 0)
        return NULL;

    LPTSTR psz;

    if (!MemAlloc((void **)&psz, sizeof(TCHAR) * (cch+1)))
        return NULL;

#ifndef UNICODE
    WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, psz, cch+1, NULL, NULL);
#else
    wcscpy(psz, bstr);
#endif

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\baui.cpp ===
// baui.cpp : Implementation of CMsgrAb
// Messenger integration to OE
// Created 04/20/98 by YST

#include "pch.hxx"
#include "bactrl.h"
#include "baprop.h"
#include "baui.h"
#include "mimeutil.h"
#include "menuutil.h"
#include "fldbar.h"
#include "bllist.h"
#include "inpobj.h"
#include "note.h"
#include "dllmain.h"
#include <wabapi.h>
#include "shlwapip.h"
#include "statnery.h"
#include "secutil.h"
#include "util.h"

// Load resource string once
#define RESSTRMAX   64

static const int BA_SortOrder[] =
{
    MSTATEOE_ONLINE,
    MSTATEOE_BE_RIGHT_BACK,
    MSTATEOE_OUT_TO_LUNCH,
    MSTATEOE_IDLE,
    MSTATEOE_AWAY,
    MSTATEOE_ON_THE_PHONE,
    MSTATEOE_BUSY,
    MSTATEOE_INVISIBLE,
    MSTATEOE_OFFLINE,
    MSTATEOE_UNKNOWN
};


static CAddressBookData  * st_pAddrBook = NULL;

// {BA9EE970-87A0-11d1-9ACF-00A0C91F9C8B}
// IMPLEMENT_OLECREATE(CMfcExt, "WABSamplePropExtSheet", 0xba9ee970, 0x87a0, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);

HRESULT CreateMsgrAbCtrl(IMsgrAb **ppMsgrAb)
{
    HRESULT         hr;
    IUnknown         *pUnknown;

    TraceCall("CreateMessageList");

    // Get the class factory for the MessageList object
    IClassFactory *pFactory = NULL;
    hr = _Module.GetClassObject(CLSID_MsgrAb, IID_IClassFactory,
                                (LPVOID *) &pFactory);

    // If we got the factory, then get an object pointer from it
    if (SUCCEEDED(hr))
    {
        hr = pFactory->CreateInstance(NULL, IID_IUnknown,
                                      (LPVOID *) &pUnknown);
        if (SUCCEEDED(hr))
        {
            hr = pUnknown->QueryInterface(IID_IMsgrAb, (LPVOID *) ppMsgrAb);
            pUnknown->Release();
        }
        pFactory->Release();
    }

    return (hr);
}

/////////////////////////////////////////////////////////////////////////////
// CMsgrAb
CMsgrAb::CMsgrAb():m_ctlList(_T("SysListView32"), this, 1),
               m_ctlViewTip(TOOLTIPS_CLASS, this, 2)
{
    m_bWindowOnly = TRUE;

    m_pDataObject = 0;
    m_cf = 0;

    m_pObjSite      = NULL;
    m_hwndParent    = NULL;
    m_pFolderBar    = NULL;
    m_nSortType = (int) DwGetOption(OPT_BASORT);
    m_pCMsgrList = NULL;

    m_fViewTip = TRUE;
    m_fViewTipVisible = FALSE;
    m_fTrackSet = FALSE;
    m_iItemTip = -1;
    m_iSubItemTip = -1;
    m_himl = NULL;

    m_ptToolTip.x = -1;
    m_ptToolTip.y = -1;
    m_fLogged = FALSE;
    m_dwFontCacheCookie = 0;
    m_nChCount = 0;

    m_lpWED = NULL;
    m_lpWEDContext = NULL;
    m_lpPropObj = NULL;

    m_szOnline = NULL;
    // m_szInvisible = NULL;
    m_szBusy = NULL;
    m_szBack = NULL;
    m_szAway = NULL;
    m_szOnPhone = NULL;
    m_szLunch = NULL;
    m_szOffline = NULL;
    m_szIdle = NULL;
    m_szEmptyList = NULL;
    m_fNoRemove = FALSE;
    m_delItem = 0;

    // Initialize the applicaiton
    g_pInstance->DllAddRef();

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoIncrementInit();
}

CMsgrAb::~CMsgrAb()
{
    // unregister from Msgr list
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
    }

    SafeRelease(m_pObjSite);

    SafeMemFree(m_szOnline);
    // SafeMemFree(m_szInvisible);
    SafeMemFree(m_szBusy);
    SafeMemFree(m_szBack);
    SafeMemFree(m_szAway);
    SafeMemFree(m_szOnPhone);
    SafeMemFree(m_szLunch);
    SafeMemFree(m_szOffline);
    SafeMemFree(m_szIdle);
    SafeMemFree(m_szEmptyList);

    // Raid-32933: OE: MSIMN.EXE doesn't always exit
    // g_pInstance->CoDecrementInit();
    g_pInstance->DllRelease();
}

LRESULT CMsgrAb::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SetDwOption(OPT_BASORT, m_nSortType, 0, 0);
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);

    if (IsWindow(m_ctlViewTip))
    {
        m_ctlViewTip.SendMessage(TTM_POP, 0, 0);
        m_ctlViewTip.DestroyWindow();
    }

    if (m_dwFontCacheCookie && g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Unadvise(m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    m_cAddrBook.Unadvise();
    RevokeDragDrop(m_hWnd);

    if (m_himl != NULL)
        ImageList_Destroy(m_himl);
    return 0;
}

HRESULT CMsgrAb::OnDraw(ATL_DRAWINFO& di)
{
    RECT&   rc = *(RECT*)di.prcBounds;

#if 0
    int     patGray[4];
    HBITMAP hbm;
    HBRUSH  hbr;
    COLORREF cFg;
    COLORREF cBkg;

    // Initialize the pattern
    patGray[0] = 0x005500AA;
    patGray[1] = 0x005500AA;
    patGray[2] = 0x005500AA;
    patGray[3] = 0x005500AA;

    // Create a bitmap from the pattern
    hbm = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);

    if ((HBITMAP) NULL != hbm)
    {
        hbr = CreatePatternBrush(hbm);
        if (hbr)
        {
            // Select the right colors into the DC
            cFg = SetTextColor(di.hdcDraw, GetSysColor(COLOR_3DFACE));
            cBkg = SetBkColor(di.hdcDraw, RGB(255, 255, 255));

            // Fill the rectangle
            FillRect(di.hdcDraw, &rc, hbr);

            SetTextColor(di.hdcDraw, cFg);
            SetBkColor(di.hdcDraw, cBkg);

            DeleteObject(hbr);
        }

        DeleteObject(hbm);
    }
#endif

    // Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
    return S_OK;
}

LRESULT CMsgrAb::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Define a bogus rectangle for the controls.  They will get resized in
    // our size handler.
    RECT rcPos = {0, 0, 100, 100};
    TCHAR        sz[CCHMAX_STRINGRES];

    // Create the various controls
    m_ctlList.Create(m_hWnd, rcPos, _T("Outlook Express Address Book ListView"),
                     WS_TABSTOP | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN |
                     LVS_REPORT | LVS_NOCOLUMNHEADER | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS /* | LVS_SORTASCENDING*/, 0);

    ListView_SetExtendedListViewStyleEx(m_ctlList, LVS_EX_INFOTIP | LVS_EX_LABELTIP, LVS_EX_INFOTIP | LVS_EX_LABELTIP);

    // Image List
    Assert(m_himl == NULL);
    m_himl = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbAddrBookHot), 16, 0,
                               RGB(255, 0, 255), IMAGE_BITMAP,
                               LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION);

    ListView_SetImageList(m_ctlList, m_himl, LVSIL_SMALL);

    LVCOLUMN lvc;

    lvc.mask = LVCF_SUBITEM;
    lvc.iSubItem = 0;

    ListView_InsertColumn(m_ctlList, 0, &lvc);

    m_ctlList.SendMessage(WM_SETFONT, NULL, 0);
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);

    if (g_lpIFontCache)
    {
        IConnectionPoint *pConnection = NULL;
        if (SUCCEEDED(g_lpIFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *) &pConnection)))
        {
            pConnection->Advise((IUnknown *)(IFontCacheNotify *) this, &m_dwFontCacheCookie);
            pConnection->Release();
        }
    }

    // Msgr Initialization
    m_pCMsgrList = OE_OpenMsgrList();
    // Register our control for Msgr list
    if(m_pCMsgrList)
    {
        m_pCMsgrList->RegisterUIWnd(m_hWnd);
        if(m_pCMsgrList->IsLocalOnline())
        {
            m_fLogged = TRUE;
            FillMsgrList();
        }
    }

    // Initialize the address book object too
    HRESULT hr = m_cAddrBook.OpenWabFile();
    if(hr == S_OK)
        m_cAddrBook.LoadWabContents(m_ctlList, this);

    st_pAddrBook = &m_cAddrBook;

    // Sort and Select the first item
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_SetItemState(m_ctlList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    // Add the tooltip
    // Load Tooltip strings

    if(AthLoadString(idsBAOnline, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOnline, lstrlen(sz) + 1))
            lstrcpy(m_szOnline, sz);
    }

    /* if(AthLoadString(idsBAInvisible, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szInvisible, lstrlen(sz) + 1))
            lstrcpy(m_szInvisible, sz);
    }*/

    if(AthLoadString(idsBABusy, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szBusy, lstrlen(sz) + 1))
            lstrcpy(m_szBusy, sz);
    }

    if(AthLoadString(idsBABack, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szBack, lstrlen(sz) + 1))
            lstrcpy(m_szBack, sz);
    }

    if(AthLoadString(idsBAAway, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szAway, lstrlen(sz) + 1))
            lstrcpy(m_szAway, sz);
    }

    if(AthLoadString(idsBAOnPhone, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOnPhone, lstrlen(sz) + 1))
            lstrcpy(m_szOnPhone, sz);
    }

    if(AthLoadString(idsBALunch, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szLunch, lstrlen(sz) + 1))
            lstrcpy(m_szLunch, sz);
    }

    if(AthLoadString(idsBAOffline, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szOffline, lstrlen(sz) + 1))
            lstrcpy(m_szOffline, sz);
    }

    if(AthLoadString(idsBAIdle, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szIdle, lstrlen(sz) + 1))
            lstrcpy(m_szIdle, sz);
    }

    if(AthLoadString(idsMsgrEmptyList, sz, ARRAYSIZE(sz)))
    {
        if(MemAlloc((LPVOID *) &m_szEmptyList, lstrlen(sz) + 1))
            lstrcpy(m_szEmptyList, sz);
    }

    // Create the ListView tooltip
    if (m_fViewTip)
    {
        TOOLINFO ti = {0};
        m_ctlViewTip.Create(m_hWnd, rcPos, NULL, TTS_NOPREFIX);

        // Add the tool
        ti.cbSize   = sizeof(TOOLINFO);
        ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
        ti.hwnd     = m_hWnd;
        ti.uId      = (UINT_PTR)(HWND) m_ctlList;
        ti.lpszText = _TEXT(""); // LPSTR_TEXTCALLBACK;
        ti.lParam   = 0;

        m_ctlViewTip.SendMessage(TTM_ADDTOOL, 0, (LPARAM) &ti);
        m_ctlViewTip.SendMessage(TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM) 500);

        // m_ctlViewTip.SendMessage(TTM_SETTIPBKCOLOR, GetSysColor(COLOR_WINDOW), 0);
        // m_ctlViewTip.SendMessage(TTM_SETTIPTEXTCOLOR, GetSysColor(COLOR_WINDOWTEXT), 0);
    }

    m_ctlList.SetFocus();

    // Register ourselves as a drop target
    RegisterDragDrop(m_hWnd, (IDropTarget *) this);

    // Update the size of the listview columns
    _AutosizeColumns();

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    // Finished
    return (0);
}

LRESULT CMsgrAb::OnSetFocus(UINT  nMsg , WPARAM  wParam , LPARAM  lParam , BOOL&  bHandled )
{
    CComControlBase::OnSetFocus(nMsg, wParam, lParam, bHandled);
    m_ctlList.SetFocus();
    if (m_pObjSite)
    {
        m_pObjSite->OnFocusChangeIS((IInputObject*) this, TRUE);
    }
    return 0;
}

LRESULT CMsgrAb::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT rc;
    DWORD width = LOWORD(lParam);
    DWORD height = HIWORD(lParam);

    // Position the listview to fill the entire area
    RECT rcList;
    rcList.left   = 0;
    rcList.top    = 0;
    rcList.right  = width;
    rcList.bottom = height;

    m_ctlList.SetWindowPos(NULL, &rcList, SWP_NOACTIVATE | SWP_NOZORDER);

    // Update the size of the listview columns
    _AutosizeColumns();

    return (0);
}


void CMsgrAb::_AutosizeColumns(void)
{
    RECT rcList;
    m_ctlList.GetClientRect(&rcList);
    ListView_SetColumnWidth(m_ctlList, 0, rcList.right - 5);
}


//
//  FUNCTION:   CMessageList::OnPreFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache before it changes the fonts we're
//              using.  In response we tell the ListView to dump any custom
//              font's it's using.
//
STDMETHODIMP CMsgrAb::OnPreFontChange(void)
{
    m_ctlList.SendMessage(WM_SETFONT, 0, 0);
    return (S_OK);
}


//
//  FUNCTION:   CMessageList::OnPostFontChange()
//
//  PURPOSE:    Get's hit by the Font Cache after it updates the font's we're
//              using.  In response, we set the new font for the current charset.
//
STDMETHODIMP CMsgrAb::OnPostFontChange(void)
{
    SetListViewFont(m_ctlList, GetListViewCharset(), TRUE);
    return (S_OK);
}

LRESULT CMsgrAb::CmdSetOnline(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(g_dwHideMessenger == BL_NOTINST)
        return(InstallMessenger(m_hWnd));

    LPMABENTRY pEntry = GetSelectedEntry();

    if(!pEntry || (pEntry->tag == LPARAM_MENTRY) || !m_pCMsgrList)
        return S_FALSE;

    // m_cAddrBook.SetDefaultMsgrID(pEntry->lpSB, pEntry->pchWABID);
    if(PromptToGoOnline() == S_OK)
        m_pCMsgrList->AddUser(pEntry->pchWABID);

    return S_OK;
}

LRESULT CMsgrAb::CmdNewOnlineContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(g_dwHideMessenger == BL_NOTINST)
        return(InstallMessenger(m_hWnd));

    else if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            m_pCMsgrList->NewOnlineContact();
    }

    return S_OK;
}

LRESULT CMsgrAb::CmdNewContact(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Tell the WAB to bring up it's new contact UI
    m_cAddrBook.NewContact(m_hWnd);
    return (0);
}

LRESULT CMsgrAb::NewInstantMessage(LPMABENTRY pEntry)
{
    if(((INT_PTR)  pEntry) == -1)
        return(m_pCMsgrList->SendInstMessage(NULL));
    else if(m_pCMsgrList)
    {
        if(PromptToGoOnline() == S_OK)
            return(m_pCMsgrList->SendInstMessage(pEntry->lpMsgrInfo->pchID));
    }

    return(S_OK);
}

LRESULT CMsgrAb::CmdNewEmaile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMIMEMESSAGE           pMessage = 0;
    LVITEM                  lvi;
    LPMIMEADDRESSTABLEW     pAddrTableW = NULL;
    LPMIMEADDRESSTABLE      pAddrTableA = NULL;
    LPMABENTRY              pEntry;
    BOOL                    fModal;
    BOOL                    fMail;
    FOLDERID                folderID;
    IUnknown                *pUnkPump;
    INIT_MSGSITE_STRUCT     initStruct = {0};
    DWORD                   dwCreateFlags = 0;

    // Create a new message
    if (FAILED(HrCreateMessage(&pMessage)))
        return (0);

    // Get the address table from the message
    if (FAILED(pMessage->GetAddressTable(&pAddrTableA)))
        goto exit;

    if (FAILED(pAddrTableA->QueryInterface(IID_IMimeAddressTableW, (LPVOID*)&pAddrTableW)))
        goto exit;

    // Loop through the selected items
    lvi.mask = LVIF_PARAM;
    lvi.iItem = -1;
    lvi.iSubItem = 0;

    while (-1 != (lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVIS_SELECTED)))
    {
        // We need to get the entry ID from the item
        ListView_GetItem(m_ctlList, &lvi);

        // Tell the data source to add this person to the message
        pEntry = (LPMABENTRY) lvi.lParam;
        Assert(pEntry);

        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY)
            m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, FALSE);
        else if(pEntry->tag == LPARAM_ABGRPENTRY)
            m_cAddrBook.AddRecipient(pAddrTableW, pEntry->lpSB, TRUE);
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            pAddrTableA->Append(IAT_TO, IET_DECODED, pEntry->lpMsgrInfo->pchID, NULL , NULL);
        }
        else
            Assert(FALSE);
    }

    fModal      = FALSE;
    fMail       = TRUE;
    folderID    = FOLDERID_INVALID;
    pUnkPump    = NULL;

    if (DwGetOption(OPT_MAIL_USESTATIONERY))
    {
        WCHAR   wszFile[MAX_PATH];
        *wszFile = 0;

        if (SUCCEEDED(GetDefaultStationeryName(TRUE, wszFile)) &&
            SUCCEEDED(HrNewStationery(m_hwndParent, 0, wszFile, fModal, fMail, folderID,
                                       FALSE, NSS_DEFAULT, pUnkPump, pMessage)))
        {
            goto exit;
        }
    }

    // If HrNewStationery fails, go ahead and try opening a blank note without stationery.

     initStruct.dwInitType  = OEMSIT_MSG;
     initStruct.folderID    = FOLDERID_INVALID;
     initStruct.pMsg        = pMessage;

     CreateAndShowNote(OENA_COMPOSE, dwCreateFlags, &initStruct, m_hwndParent, pUnkPump);

exit:
    ReleaseObj(pMessage);
    ReleaseObj(pAddrTableA);
    ReleaseObj(pAddrTableW);
    return (0);

}

LRESULT CMsgrAb::CmdNewIMsg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(CmdNewMessage(wNotifyCode, ID_SEND_INSTANT_MESSAGE, hWndCtl, bHandled));
}

LRESULT CMsgrAb::CmdNewMessage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM                  lvi;
    LPMABENTRY             pEntry;

    pEntry = GetEntryForSendInstMsg();

    if(wID == ID_SEND_INSTANT_MESSAGE)
    {
        if(g_dwHideMessenger == BL_NOTINST)
            return(InstallMessenger(m_hWnd));

        if(pEntry)
            return(NewInstantMessage(pEntry));
        else
        {
            Assert(FALSE);
            return(-1);
        }
    }
    else if((((INT_PTR) pEntry) != -1) && pEntry)
        return(NewInstantMessage(pEntry));
    else
        return(CmdNewEmaile(wNotifyCode, wID, hWndCtl, bHandled));
}

LRESULT CMsgrAb::NotifyDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;
    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;
    lvi.iSubItem = 0;

    ListView_GetItem(m_ctlList, &lvi);
    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

    if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
        m_cAddrBook.FreeListViewItem(pEntry->lpSB);
    RemoveBlabEntry(pEntry);
    if(m_delItem > 0)
        m_delItem--;
    else
        Assert(FALSE);
    return (0);
}


LRESULT CMsgrAb::NotifyItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    ULONG       uChanged;
    NMLISTVIEW *pnmlv = (NMLISTVIEW *) pnmh;

    if (pnmlv->uChanged & LVIF_STATE)
    {
        uChanged = pnmlv->uNewState ^ pnmlv->uOldState;
        if (uChanged & LVIS_SELECTED)
            _EnableCommands();
    }

    return (0);
}

// Sort compare
int CALLBACK BA_Sort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    LPMABENTRY pEntry1 = (LPMABENTRY) lParam1;
    LPMABENTRY pEntry2 = (LPMABENTRY) lParam2;

    TCHAR pchName1[MAXNAME];
    TCHAR pchName2[MAXNAME];

    int nIndex1 = 0;
    int nIndex2 = 0 ;

    if(!(pEntry1->lpMsgrInfo))
    {
        nIndex1 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry1->tag == LPARAM_ABGRPENTRY)
            nIndex1++;
    }
    else
    {
        while((pEntry1->lpMsgrInfo) && (BA_SortOrder[nIndex1] != pEntry1->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex1] != MSTATEOE_UNKNOWN))
            nIndex1++;
    }

    if(!(pEntry2->lpMsgrInfo))
    {
        nIndex2 = sizeof(BA_SortOrder)/sizeof(int);
        if(pEntry2->tag == LPARAM_ABGRPENTRY)
            nIndex2++;
    }
    else
    {
        while((BA_SortOrder[nIndex2] != pEntry2->lpMsgrInfo->nStatus) && (BA_SortOrder[nIndex2] != MSTATEOE_UNKNOWN))
            nIndex2++;
    }

    if(pEntry1->tag == LPARAM_MENTRY)              // if no AB entry
        lstrcpyn(pchName1, pEntry1->lpMsgrInfo->pchMsgrName, MAXNAME);
    else
        lstrcpyn(pchName1, pEntry1->pchWABName, MAXNAME);
        // st_pAddrBook->GetDisplayName(pEntry1->lpSB, pchName1);
    pchName1[MAXNAME - 1] = _T('\0');

    if(pEntry2->tag == LPARAM_MENTRY)              // if no AB entry
        lstrcpyn(pchName2, pEntry2->lpMsgrInfo->pchMsgrName, MAXNAME);
    else
        lstrcpyn(pchName2, pEntry2->pchWABName, MAXNAME);
        // st_pAddrBook->GetDisplayName(pEntry2->lpSB, pchName2);
    pchName2[MAXNAME - 1] = _T('\0');

    switch(lParamSort)
    {
        case BASORT_NAME_ACSEND:
            return(lstrcmpi(pchName1, pchName2));

        case BASORT_NAME_DESCEND:
            return(lstrcmpi(pchName2, pchName1));

        default:
            if((pEntry1->lpMsgrInfo) && (pEntry2->lpMsgrInfo) && (pEntry1->lpMsgrInfo->nStatus == pEntry2->lpMsgrInfo->nStatus))
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(lstrcmpi(pchName1, pchName2));
                else
                    return(lstrcmpi(pchName2, pchName1));
            }
            else
            {
                if(lParamSort == BASORT_STATUS_ACSEND)
                    return(nIndex1 - nIndex2);
                else
                    return(nIndex2 - nIndex1);
            }
    }

    Assert(FALSE);
    return(0);
}

void CMsgrAb::_EnableCommands(void)
{
    if(g_pBrowser)
        g_pBrowser->UpdateToolbar();
}


LRESULT CMsgrAb::NotifyItemActivate(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return (SendMessage(WM_COMMAND, ID_SEND_INSTANT_MESSAGE2, 0));
}


// GETDISPLAYINFO notification message
LRESULT CMsgrAb::NotifyGetDisplayInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LV_DISPINFO * plvdi = (LV_DISPINFO *)pnmh;
    LRESULT hr;

    if(plvdi->item.lParam)
    {
        LPMABENTRY pEntry = (LPMABENTRY) plvdi->item.lParam;
        LPMABENTRY pFindEntry = NULL;

        if (plvdi->item.mask &  LVIF_IMAGE)
        {
            if((hr = SetUserIcon(pEntry, (pEntry->lpMsgrInfo ? pEntry->lpMsgrInfo->nStatus : MSTATEOE_OFFLINE), &(plvdi->item.iImage) ) ) != S_OK)
                return(hr);
        }

        if (plvdi->item.mask &  LVIF_TEXT)
        {

            if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
            {
                // if((hr = m_cAddrBook.GetDisplayName(pEntry->lpSB, plvdi->item.pszText)) != S_OK)
                //    return(hr);
                Assert(pEntry->pchWABName);
                lstrcpyn(plvdi->item.pszText, pEntry->pchWABName, plvdi->item.cchTextMax - 1);
                plvdi->item.pszText[plvdi->item.cchTextMax - 1] = '\0';
            }
            else if(pEntry->tag == LPARAM_MENTRY)
            {
                if((pEntry->lpMsgrInfo->nStatus == MSTATEOE_ONLINE) && lstrcmpi(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID))
                {
                    lstrcpyn(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = '\0';

                    // Don't need redraw now, do it later
                    hr = MAPI_E_COLLISION; // m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                    if(hr == MAPI_E_COLLISION)      // already have a contact in AB
                    {
                        int Index = -1;
                        TCHAR *pchID = NULL;

                        if(MemAlloc((LPVOID *) &pchID, lstrlen(pEntry->lpMsgrInfo->pchID) + 1))
                        {
                            lstrcpy(pchID, pEntry->lpMsgrInfo->pchID);
                            do
                            {
                                pFindEntry = FindUserEmail(pchID, &Index, FALSE);
                            }while((pFindEntry != NULL) && (pFindEntry->tag == LPARAM_MENTRY));

                            if(pFindEntry != NULL)
                            {
                                hr = m_cAddrBook.SetDefaultMsgrID(pFindEntry->lpSB, pchID);
                                if(hr == S_OK)
                                    _ReloadListview();
                            }
                            MemFree(pchID);
                        }
                    }
                    //if we not found...
                    if(hr != S_OK)
                    {
                        hr = m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID);
                        if(hr == S_OK)
                            _ReloadListview();
                    }

                }
                else
                {
                    lstrcpyn(plvdi->item.pszText, pEntry->lpMsgrInfo->pchMsgrName, plvdi->item.cchTextMax - 1);
                    plvdi->item.pszText[plvdi->item.cchTextMax - 1] = '\0';
                    // plvdi->item.pszText = pEntry->lpMsgrInfo->pchMsgrName;
                }
            }
            else    // Unknown tag
                Assert(FALSE);
        }
    }

    return S_OK;
}


LRESULT CMsgrAb::NotifyGetInfoTip(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NMLVGETINFOTIP *plvgit = (NMLVGETINFOTIP *) pnmh;
    TCHAR         szText[CCHMAX_STRINGRES + MAXNAME + 1] = _T("");
    TCHAR         szName[MAXNAME];

    LVITEM lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = plvgit->iItem;
    lvi.iSubItem = plvgit->iSubItem;

    ListView_GetItem(m_ctlList, &lvi);

    LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

#ifdef NEED
    if (pEntry->lpMsgrInfo != NULL)
    {
        StrCpyN(plvgit->pszText, pEntry->lpMsgrInfo->pchMsgrName, plvgit->cchTextMax);
        StrCatBuff(plvgit->pszText, m_szLeftBr, plvgit->cchTextMax);
        StrCatBuff(plvgit->pszText, pEntry->lpMsgrInfo->pchID, plvgit->cchTextMax);
        StrCatBuff(plvgit->pszText, m_szRightBr, plvgit->cchTextMax);

        LPCWSTR szStatus;

        switch(pEntry->lpMsgrInfo->nStatus)
        {
        case BIMSTATE_ONLINE:
            szStatus = m_szOnline;
            break;
        case BIMSTATE_BUSY:
            szStatus = m_szBusy;
            break;
        case BIMSTATE_BE_RIGHT_BACK:
            szStatus = m_szBack;
            break;
        case BIMSTATE_IDLE:
            szStatus = m_szIdle;
            break;
        case BIMSTATE_AWAY:
            szStatus = m_szAway;
            break;
        case BIMSTATE_ON_THE_PHONE:
            szStatus = m_szOnPhone;
            break;
        case BIMSTATE_OUT_TO_LUNCH:
            szStatus = m_szLunch;
            break;

        default:
            szStatus = m_szOffline;
            break;
        }

        StrCatBuff(plvgit->pszText, szStatus, plvgit->cchTextMax);
    }
#endif 
        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
        {
            Assert(pEntry->pchWABName != NULL);
            lstrcpyn(szName, pEntry->pchWABName, MAXNAME);
            szName[MAXNAME - 1] =  _T('\0');
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            lstrcpyn(szName, pEntry->lpMsgrInfo->pchMsgrName, MAXNAME);
            szName[MAXNAME - 1] =  _T('\0');
        }
        else
            Assert(FALSE);

        lstrcpy(szText, szName);

    if(pEntry->lpMsgrInfo)
        {
            switch(pEntry->lpMsgrInfo->nStatus)
            {
            case MSTATEOE_ONLINE:
                lstrcat(szText, m_szOnline);
                break;
            case MSTATEOE_BUSY:
                lstrcat(szText, m_szBusy);
                break;
            case MSTATEOE_BE_RIGHT_BACK:
                lstrcat(szText, m_szBack);
                break;
            case MSTATEOE_IDLE:
                lstrcat(szText, m_szIdle);
                break;
            case MSTATEOE_AWAY:
                lstrcat(szText, m_szAway);
                break;
            case MSTATEOE_ON_THE_PHONE:
                lstrcat(szText, m_szOnPhone);
                break;
            case MSTATEOE_OUT_TO_LUNCH:
                lstrcat(szText, m_szLunch);
                break;

            default:
                lstrcat(szText, m_szOffline);
                break;
            }
            lstrcpyn(plvgit->pszText, szText, plvgit->cchTextMax);
        }


    else if (plvgit->dwFlags & LVGIT_UNFOLDED)
    {
        // If this is not a messenger item and the text
        // isn't truncated do not display a tooltip.

        plvgit->pszText[0] = L'\0';
    }

    return 0;
}

LRESULT CMsgrAb::SetUserIcon(LPMABENTRY pEntry, int nStatus, int * pImage)
{
    switch(pEntry->tag)
    {
    case LPARAM_MENTRY:
    case LPARAM_MABENTRY:
        {
            switch(nStatus)
            {
            case MSTATEOE_ONLINE:
                *pImage = IMAGE_ONLINE;
                break;

            case MSTATEOE_INVISIBLE:
                *pImage = IMAGE_STOPSIGN;
                break;

            case MSTATEOE_BUSY:
                *pImage = IMAGE_STOPSIGN;
                break;

            case MSTATEOE_BE_RIGHT_BACK:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_BE_RIGHT_BACK;
                break;

            case MSTATEOE_IDLE:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_IDLE;
                break;

            case MSTATEOE_AWAY:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_AWAY;
                break;

            case MSTATEOE_ON_THE_PHONE:
                *pImage = IMAGE_STOPSIGN; // IMAGE_ON_THE_PHONE;
                break;

            case MSTATEOE_OUT_TO_LUNCH:
                *pImage = IMAGE_CLOCKSIGN; // IMAGE_OUT_TO_LUNCH;
                break;

            default:
                *pImage = IMAGE_OFFLINE;
                break;

            }
        }
        break;

    case LPARAM_ABGRPENTRY:
        // WAB group
        *pImage = IMAGE_DISTRIBUTION_LIST;
        break;

    default:
        // Not a buddy...
        if(pEntry->fCertificate)
            *pImage = IMAGE_CERT;
        else
            *pImage = IMAGE_NEW_MESSAGE;
        break;
    }
    return(S_OK);

}

// Return MAB entry for first selected item
LPMABENTRY CMsgrAb::GetSelectedEntry()
{
    LVITEM lvi;

    // Get the focused item
    lvi.iItem = ListView_GetNextItem(m_ctlList, -1, LVNI_SELECTED | LVNI_FOCUSED);

    // Get the lParam for that item
    if (lvi.iItem != -1)
    {
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM;

        if(ListView_GetItem(m_ctlList, &lvi))
            return((LPMABENTRY) lvi.lParam);
    }
    return(NULL);   // unscucces
}


/*
LRESULT CMsgrAb::CmdMsgrOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return(m_pCMsgrList->LaunchOptionsUI()); // (MOPTDLG_GENERAL_PAGE);

}
*/

// Exec for Properties command
LRESULT CMsgrAb::CmdProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LPMABENTRY pEntry = GetSelectedEntry();

    if(pEntry)
    {
        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
            m_cAddrBook.ShowDetails(m_hWnd, pEntry->lpSB);
    }
    return (0);
}

// Check entry for possibility to send Instant message
LPMABENTRY CMsgrAb::GetEntryForSendInstMsg(LPMABENTRY pEntry)
{
    if(ListView_GetSelectedCount(m_ctlList) == 1)
    {
        if(!pEntry)     // if we don'y have pEntry yet then get it
            pEntry = GetSelectedEntry();

        if(pEntry && (pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY) &&
                    (pEntry->lpMsgrInfo->nStatus != MSTATEOE_OFFLINE) && (pEntry->lpMsgrInfo->nStatus != MSTATEOE_INVISIBLE) &&
                    !(m_pCMsgrList->IsLocalName(pEntry->lpMsgrInfo->pchID)))
            return(pEntry);
    }

    if(m_pCMsgrList)
    {
        if(m_pCMsgrList->IsLocalOnline() && (m_pCMsgrList->GetCount() > 0))
            return(NULL);   // should be /*return((LPMABENTRY) -1);*/ - temporary disabled (YST)
    }

    return(NULL);
}

// Display right-mouse click (context) menu
LRESULT CMsgrAb::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPMABENTRY pEntry;
    HMENU       hPopup = 0;
    HWND        hwndHeader;
    int         id = 0;
    POINT       pt = { (int)(short) LOWORD(lParam), (int)(short) HIWORD(lParam) };
    int n = -1;
    // Figure out if this came from the keyboard or not
    if (lParam == -1)
    {
        Assert((HWND) wParam == m_ctlList);
        int i = ListView_GetFirstSel(m_ctlList);
        if (i == -1)
            return (0);

        ListView_GetItemPosition(m_ctlList, i, &pt);
        m_ctlList.ClientToScreen(&pt);
    }

    LVHITTESTINFO lvhti;
    lvhti.pt = pt;
    m_ctlList.ScreenToClient(&lvhti.pt);
    ListView_HitTest(m_ctlList, &lvhti);

    if (lvhti.iItem == -1)
        return (0);

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_POPUP);
    if (!hPopup)
        goto exit;

    pEntry = GetSelectedEntry();
    pEntry = GetEntryForSendInstMsg(pEntry);

    if((pEntry == NULL) && (g_dwHideMessenger != BL_NOTINST))
        SetMenuDefaultItem(hPopup, ID_SEND_MESSAGE, FALSE);
    else if((g_dwHideMessenger == BL_NOTINST) || (((INT_PTR) pEntry) == -1))
        SetMenuDefaultItem(hPopup, ID_SEND_MESSAGE, FALSE);
    else
        SetMenuDefaultItem(hPopup, ID_SEND_INSTANT_MESSAGE, FALSE);

    if ((g_dwHideMessenger == BL_HIDE) || (g_dwHideMessenger == BL_DISABLE))
    {
        DeleteMenu(hPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_SET_ONLINE_CONTACT, MF_BYCOMMAND);
        DeleteMenu(hPopup, ID_NEW_ONLINE_CONTACT, MF_BYCOMMAND);
    }

    MenuUtil_EnablePopupMenu(hPopup, this);

    TrackPopupMenuEx(hPopup, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                     pt.x, pt.y, m_hWnd, NULL);

exit:
    if (hPopup)
        DestroyMenu(hPopup);

    return (0);
}


//
//  FUNCTION:   CMsgrAb::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CMsgrAb::DragEnter(IDataObject* pDataObject, DWORD grfKeyState,
                                     POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;

    // Verify we got this
    if (!pDataObject)
        return (S_OK);

    // Init
    ZeroMemory(&fe, sizeof(FORMATETC));

    // Set the default return value to be failure
    *pdwEffect = DROPEFFECT_NONE;

    // Get the FORMATETC enumerator for this data object
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        // Walk through the data types to see if we can find the ones we're
        // interested in.
        pEnum->Reset();

        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            Assert(celtFetched == 1);

            // The only format we care about is CF_INETMSG
            if ((fe.cfFormat == CF_INETMSG) /*|| (fe.cfFormat == CF_OEMESSAGES)*/)
            {
                *pdwEffect = DROPEFFECT_COPY;
                break;
            }
        }

        pEnum->Release();
    }

    // We we're going to allow the drop, then keep a copy of the data object
    if (*pdwEffect != DROPEFFECT_NONE)
    {
        m_pDataObject = pDataObject;
        m_pDataObject->AddRef();
        m_cf = fe.cfFormat;
        m_fRight = (grfKeyState & MK_RBUTTON);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMsgrAb::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
STDMETHODIMP CMsgrAb::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // If we didn't cache a data object in IDropTarget::DragEnter(), we
    // blow this off.
    if (NULL == m_pDataObject)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return (S_OK);
    }

    // We always do a copy
    *pdwEffect = DROPEFFECT_COPY;
    return (S_OK);
}

//
//  FUNCTION:   CMsgrAb::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
STDMETHODIMP CMsgrAb::DragLeave(void)
{
    // Free everything up at this point.
    if (NULL != m_pDataObject)
    {
        m_pDataObject->Release();
        m_pDataObject = 0;
        m_cf = 0;
    }

    return (S_OK);
}


//
//  FUNCTION:   CMsgrAb::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
STDMETHODIMP CMsgrAb::Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                POINTL pt, DWORD* pdwEffect)
{
    HRESULT             hr = S_OK;
    FORMATETC           fe;
    STGMEDIUM           stm;
    IMimeMessage        *pMessage = 0;

    // Get the stream from the DataObject
    ZeroMemory(&stm, sizeof(STGMEDIUM));
    SETDefFormatEtc(fe, CF_INETMSG, TYMED_ISTREAM);

    if (FAILED(hr = pDataObject->GetData(&fe, &stm)))
        goto exit;

    // Create a new message object
    if (FAILED(hr = HrCreateMessage(&pMessage)))
        goto exit;

    // Load the message from the stream
    if (FAILED(hr = pMessage->Load(stm.pstm)))
        goto exit;

    // If this was a right-drag, then we bring up a context menu etc.
    if (m_fRight)
        _DoDropMenu(pt, pMessage);
    else
        _DoDropMessage(pMessage);

exit:
    ReleaseStgMedium(&stm);
    SafeRelease(pMessage);

    m_pDataObject->Release();
    m_pDataObject = 0;
    m_cf = 0;

    return (hr);
}

HRESULT CMsgrAb::_DoDropMessage(LPMIMEMESSAGE pMessage)
{
    HRESULT     hr;
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    // Get the address list from the message
    hr = pMessage->GetAddressTypes(IAT_FROM | IAT_SENDER, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
        m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
#ifdef DEAD
        TCHAR *pch = StrStr(CharUpper(addrList.prgAdr[i].pszEmail), szHotMail);
        if((pch != NULL) && m_pCMsgrList)
            m_pCMsgrList->AddUser(addrList.prgAdr[i].pszEmail);
#endif // DEAD
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }

#ifdef NEEDED
    // Reload the table
    _ReloadListview();
#endif

exit:
    return (S_OK);

}

HRESULT CMsgrAb::_DoDropMenu(POINTL pt, LPMIMEMESSAGE pMessage)
{
    HRESULT     hr;
    ADDRESSLIST addrList = { 0 };
    ULONG       i;
    HMENU       hPopup = 0, hSubMenu = 0;
    UINT        id = 0;
    BOOL        fReload = FALSE;
    SECSTATE    secState = {0};
    BOOL        fSignTrusted = FALSE;

    // Get the address list from the message
    if(FAILED(hr = HandleSecurity(m_hWnd, pMessage)))
        return hr;

    if (IsSecure(pMessage) && SUCCEEDED(HrGetSecurityState(pMessage, &secState, NULL)))
    {
        fSignTrusted = !!IsSignTrusted(&secState);
        CleanupSECSTATE(&secState);
    }

    hr = pMessage->GetAddressTypes(IAT_KNOWN, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList);
    if (FAILED(hr))
        goto exit;

    // Load the context menu
    hPopup = LoadPopupMenu(IDR_BA_DRAGDROP_POPUP);
    if (!hPopup)
        goto exit;

    // Bold the "Save All" item
    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE;
    if (GetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii))
    {
        mii.fState |= MFS_DEFAULT;
        SetMenuItemInfo(hPopup, ID_SAVE_ALL, FALSE, &mii);
    }

    // Create the "Save >" item
    hSubMenu = CreatePopupMenu();

    // Loop through the addresses
    for (i = 0; i < addrList.cAdrs; i++)
    {
        AppendMenuWrapW(hSubMenu, MF_STRING | MF_ENABLED, ID_SAVE_ADDRESS_FIRST + i, addrList.prgAdr[i].pszFriendlyW);
    }

    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hSubMenu;
    SetMenuItemInfo(hPopup, ID_SAVE, FALSE, &mii);

    id = TrackPopupMenuEx(hPopup, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                          pt.x, pt.y, m_hWnd, NULL);

    if (id == ID_SAVE_ALL_ADDRESSES)
    {
        for (i = 0; i < addrList.cAdrs; i++)
        {
            m_cAddrBook.AddAddress(addrList.prgAdr[i].pszFriendlyW, addrList.prgAdr[i].pszEmail);
        }
        fReload = TRUE;
    }
    else if (id >= ID_SAVE_ADDRESS_FIRST && id < ID_SAVE_ADDRESS_LAST)
    {
        m_cAddrBook.AddAddress(addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszFriendlyW,
                               addrList.prgAdr[id - ID_SAVE_ADDRESS_FIRST].pszEmail);
        fReload = TRUE;
    }

    if(fSignTrusted)
    {
        FILETIME ftNull = {0};
        HrAddSenderCertToWab(NULL, pMessage, NULL, NULL, NULL, ftNull, WFF_CREATE);
    }


    if (fReload)
    {
        // Reload the table
        _ReloadListview();
    }

exit:
    if (hSubMenu)
        DestroyMenu(hSubMenu);

    if (hPopup)
        DestroyMenu(hPopup);

    return (S_OK);
}


LRESULT CMsgrAb::CmdDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LVITEM lvi;
    ENTRYLIST rList;
    ULONG cValues;
    SBinary UNALIGNED *pEntryId;
    HRESULT hr = S_OK;
    BOOL fConfirm = TRUE;
    TCHAR szText[CCHMAX_STRINGRES + MAXNAME];
    TCHAR szBuff[CCHMAX_STRINGRES];

    if(m_delItem > 0)
    {
        MessageBeep(MB_OK);
        return(S_OK);
    }

    if(m_fNoRemove)
        m_fNoRemove = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = -1;

    // Figure out how many items are selected
    cValues = ListView_GetSelectedCount(m_ctlList);
    m_delItem = cValues;
    if (cValues != 1)
    {
        // Remove only Msgr entry
        AthLoadString(idsBADelMultiple, szBuff, ARRAYSIZE(szBuff));
        wsprintf(szText, szBuff, cValues);

        if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
            NULL, MB_YESNO | MB_ICONEXCLAMATION))
            return (0);
        else if(m_fNoRemove)
            goto ErrBeep;
        else
            fConfirm = FALSE;

        //        Assert(FALSE);
        //        return (0);
    }
    while(cValues > 0)
    {
        lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_SELECTED);

        if(lvi.iItem < 0)
        {
ErrBeep:
            MessageBeep(MB_OK);
            return(S_OK);
        }

        // Get the item from the ListView
        if(ListView_GetItem(m_ctlList, &lvi) == FALSE)
            goto ErrBeep;

        // Check buddy state
        LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry->tag == LPARAM_MENTRY)
        {
            if(m_pCMsgrList->IsLocalOnline())
            {
                // Remove only Msgr entry
                if(fConfirm)
                {
                    AthLoadString(idsBADelBLEntry, szBuff, ARRAYSIZE(szBuff));
                    wsprintf(szText, szBuff,  pEntry->lpMsgrInfo->pchMsgrName);


                    if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                        NULL, MB_YESNO | MB_ICONEXCLAMATION))
                    {
                        m_delItem = 0;
                        return (0);
                    }
                    else if(m_fNoRemove)
                        goto ErrBeep;

                }
                if(pEntry->lpMsgrInfo)
                {
                    m_delItem--;
                    hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                }
                else
                {
                    m_delItem = 0;
                    return(S_OK);
                }
            }
            else
                goto ErrBeep;
        }
        else if(pEntry->tag == LPARAM_MABENTRY)
        {
            int nID = IDNO;
            if(fConfirm)
            {

                AthLoadString(idsBADelBLABEntry, szBuff, ARRAYSIZE(szBuff));
                wsprintf(szText, szBuff, pEntry->pchWABName);

                nID = AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNOCANCEL | MB_ICONEXCLAMATION);
            }
            if(((nID == IDYES) || !fConfirm) && !m_fNoRemove)
            {
                if(m_pCMsgrList->IsLocalOnline())
                {
                    // Remove only Msgr & AB entry
                    if(pEntry->lpMsgrInfo)
                        hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
                    else
                    {
                        m_delItem = 0;
                        return(S_OK);
                    }

                    // Allocate a structure big enough for all of 'em
                    if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                    {
                        rList.cValues = 0;
                        pEntryId = rList.lpbin;

                        *pEntryId = *(pEntry->lpSB);
                        pEntryId++;
                        rList.cValues = 1;
                        // Tell the WAB to delete 'em
                        m_nChCount++;    // increase count of our notification messages from WAB
                        m_cAddrBook.DeleteItems(&rList);

                        // Free our array
                        MemFree(rList.lpbin);

                    }
                    // m_delItem++;
                    ListView_DeleteItem(m_ctlList, lvi.iItem);
                    lvi.iItem--;
                    ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                }
                else
                    MessageBeep(MB_OK);
            }
            else if((nID == IDNO) && !m_fNoRemove)
            {
                // Remove only Msgr entry
                m_delItem--;
                hr = m_pCMsgrList->FindAndDeleteUser(pEntry->lpMsgrInfo->pchID, TRUE /* fDelete*/);
            }
            else
            {
                // Remove nothing
                m_delItem--;
                hr = S_OK;
            }

        }
        else
        {
            // remove AN entry (group or contact)
            if(fConfirm)
            {
                AthLoadString(idsBADelABEntry, szBuff, ARRAYSIZE(szBuff));
                wsprintf(szText, szBuff, pEntry->pchWABName);

                if(IDNO == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                    NULL, MB_YESNO | MB_ICONEXCLAMATION))
                {
                    m_delItem = 0;
                    return(0);
                }
                else if(m_fNoRemove)
                    goto ErrBeep;

            }
            // Allocate a structure big enough for all of 'em
            if(pEntry->lpSB)
            {
                if (MemAlloc((LPVOID *) &(rList.lpbin), sizeof(SBinary)))
                {
                    rList.cValues = 0;
                    pEntryId = rList.lpbin;

                    *pEntryId = *(pEntry->lpSB);
                    pEntryId++;
                    rList.cValues = 1;
                    // Tell the WAB to delete 'em
                    m_nChCount++;    // increase count of our notification messages from WAB
                    m_cAddrBook.DeleteItems(&rList);

                    // Free our array
                    MemFree(rList.lpbin);
                }
            }
            // m_delItem++;
            ListView_DeleteItem(m_ctlList, lvi.iItem);
            lvi.iItem--;
        }
        cValues--;
    }

    if(ListView_GetItemCount(m_ctlList) > 0)
    {
        m_cEmptyList.Hide();
        ListView_SetItemState(m_ctlList, ((lvi.iItem >= 0) ? lvi.iItem : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);


    return (hr);
}

STDMETHODIMP CMsgrAb::get_InstMsg(BOOL * pVal)
{
    *pVal = (GetEntryForSendInstMsg() != NULL);
    return S_OK;
}

/* STDMETHODIMP CMsgrAb::put_InstMsg(BOOL newVal)
{
    return S_OK;
}  */

STDMETHODIMP CMsgrAb::HasFocusIO()
{
    if (GetFocus() == m_ctlList)
        return S_OK;
    else
        return S_FALSE;
}

STDMETHODIMP CMsgrAb::TranslateAcceleratorIO(LPMSG lpMsg)
{
#if 0
    if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_DELETE)
    {
        SendMessage(WM_COMMAND, ID_DELETE_CONTACT, 0);
        return (S_OK);
    }
#endif
    return (S_FALSE);
}

STDMETHODIMP CMsgrAb::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (!m_pObjSite)
        return E_FAIL;

    if (!IsWindow(m_hWnd))
    {
        IOleWindow  *pOleWnd;

        if (SUCCEEDED(m_pObjSite->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWnd)))
        {
            if(SUCCEEDED(pOleWnd->GetWindow(&m_hwndParent)))
            {
            //Will be resized by parent
            RECT    rect = {0};

            m_hWnd = CreateControlWindow(m_hwndParent, rect);
            if (!m_hWnd)
                return E_FAIL;
            }
        }
        pOleWnd->Release();
    }

    if (fActivate)
    {
        m_ctlList.SetFocus();
    }

    m_pObjSite->OnFocusChangeIS((IInputObject*) this, fActivate);
    return (S_OK);
}

STDMETHODIMP CMsgrAb::SetSite(IUnknown  *punksite)
{
    //If we already have a site, we release it
    SafeRelease(m_pObjSite);

    IInputObjectSite    *pObjSite;
    if ((punksite) && (SUCCEEDED(punksite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pObjSite))))
    {
        m_pObjSite = pObjSite;
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CMsgrAb::GetSite(REFIID  riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

HRESULT CMsgrAb::RegisterFlyOut(CFolderBar *pFolderBar)
{
    Assert(m_pFolderBar == NULL);
    m_pFolderBar = pFolderBar;
    m_pFolderBar->AddRef();

    return S_OK;
}

HRESULT CMsgrAb::RevokeFlyOut(void)
{
    if (m_pFolderBar)
    {
        m_pFolderBar->Release();
        m_pFolderBar = NULL;
    }
    return S_OK;
}


void CMsgrAb::_ReloadListview(void)
{
    // Turn off redrawing
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
    if(index == -1)
        index = 0;

    // Delete everything and reload
    SideAssert(ListView_DeleteAllItems(m_ctlList));
    FillMsgrList();                         // User list reload
    m_cAddrBook.LoadWabContents(m_ctlList, this);
    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    ListView_EnsureVisible(m_ctlList, index, FALSE);
    SetWindowRedraw(m_ctlList, TRUE);
//    Invalidate(TRUE); //

   if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    UpdateWindow(/*m_ctlList*/);
    return;
}


ULONG STDMETHODCALLTYPE CMsgrAb::OnNotify(ULONG cNotif, LPNOTIFICATION pNotifications)
{
    // Well something changed in WAB, but we don't know what.  We should reload.
    // Sometimes these changes from us and we should ignore it.
    if(m_nChCount > 0)
        m_nChCount--;
    else
        _ReloadListview();
    return (0);
}

LRESULT CMsgrAb::CmdFind(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_cAddrBook.Find(m_hWnd);
    return (0);
}

LRESULT CMsgrAb::CmdNewGroup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_cAddrBook.NewGroup(m_hWnd);
    return (0);
}

LRESULT CMsgrAb::CmdMsgrAb(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_cAddrBook.AddressBook(m_hWnd);
    return (0);
}

void CMsgrAb::AddMsgrListItem(LPMINFO lpMsgrInfo)
{
    LV_ITEM lvItem;

    m_cEmptyList.Hide(); // m,ust be sure that empty mesage is hide

    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MENTRY, NULL, lpMsgrInfo, NULL, NULL, FALSE);
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACK;
    lvItem.iImage = I_IMAGECALLBACK;
    // SetUserIcon(LPARAM_MENTRY, lpMsgrInfo->nStatus, &(lvItem.iImage));
    ListView_InsertItem(m_ctlList, &lvItem);

    return;
}

HRESULT CMsgrAb::FillMsgrList()
{
    LPMINFO pEntry = NULL;

    if(!m_pCMsgrList)
    {
        // Assert(FALSE); // Possible situation. See Bug 31262
        return(S_OK);
    }

    pEntry = m_pCMsgrList->GetFirstMsgrItem();

    while(pEntry)
    {
        AddMsgrListItem(pEntry);
        pEntry = m_pCMsgrList->GetNextMsgrItem(pEntry);
    }
    return S_OK;
}

// Add BLAB table entry
LPMABENTRY CMsgrAb::AddBlabEntry(MABENUM tag, LPSBinary lpSB, LPMINFO lpMsgrInfo, TCHAR *pchMail, TCHAR *pchDisplayName, BOOL fCert)
{
    TCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;
    TCHAR *pchName = NULL;
    if (!MemAlloc((LPVOID *) &pEntry, sizeof(mabEntry)))
        return(NULL);
    pEntry->tag = tag;
    pEntry->lpSB = lpSB;
    pEntry->pchWABName = NULL;
    pEntry->pchWABID = NULL;
    pEntry->fCertificate = fCert;

    if(lpSB != NULL)
    {
        if(!pchDisplayName)
        {
            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, MAXNAME);
            pchName = szName;
        }
        else
            pchName = pchDisplayName;

        if (!MemAlloc((LPVOID *) &(pEntry->pchWABName), lstrlen(pchName) + 1 ))
        {
            MemFree(pEntry);
            return(NULL);
        }
        lstrcpy(pEntry->pchWABName, pchName);

        if(pchMail != NULL)
        {
            if (MemAlloc((LPVOID *) &(pEntry->pchWABID), lstrlen(pchMail) + 1 ))
                lstrcpy(pEntry->pchWABID, pchMail);
        }
    }

    if(lpMsgrInfo && MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo), sizeof(struct _tag_OEMsgrInfo)))
    {

        pEntry->lpMsgrInfo->nStatus = lpMsgrInfo->nStatus;
        pEntry->lpMsgrInfo->pPrev = NULL;
        pEntry->lpMsgrInfo->pNext = NULL;

        if(MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchMsgrName), lstrlen(lpMsgrInfo->pchMsgrName) + 1))
            lstrcpy(pEntry->lpMsgrInfo->pchMsgrName, lpMsgrInfo->pchMsgrName);
        else
            pEntry->lpMsgrInfo->pchMsgrName = NULL;

        if(MemAlloc((LPVOID *) &(pEntry->lpMsgrInfo->pchID), lstrlen(lpMsgrInfo->pchID) + 1))
            lstrcpy(pEntry->lpMsgrInfo->pchID, lpMsgrInfo->pchID);
        else
            pEntry->lpMsgrInfo->pchID = NULL;
    }
    else
        pEntry->lpMsgrInfo = NULL;

    return(pEntry);
}

void CMsgrAb::RemoveMsgrInfo(LPMINFO lpMsgrInfo)
{
    SafeMemFree(lpMsgrInfo->pchMsgrName);
    SafeMemFree(lpMsgrInfo->pchID);
    SafeMemFree(lpMsgrInfo);
}

// Remove BLAB table entry
void CMsgrAb::RemoveBlabEntry(LPMABENTRY lpEntry)
{
    if(lpEntry == NULL)
        return;

    if(lpEntry->pchWABName)
        MemFree(lpEntry->pchWABName);

    if(lpEntry->pchWABID)
        MemFree(lpEntry->pchWABID);

    if(lpEntry->lpMsgrInfo)
    {
        RemoveMsgrInfo(lpEntry->lpMsgrInfo);
        lpEntry->lpMsgrInfo = NULL;
    }

    MemFree(lpEntry);
    lpEntry = NULL;

    return;
}

// This function check buddy and if we have AB entry then set LPARAM_MABENTRY tag
void CMsgrAb::CheckAndAddAbEntry(LPSBinary lpSB, TCHAR *pchEmail, TCHAR *pchDisplayName, DWORD nFlag)
{
    TCHAR szName[MAXNAME];
    LPMABENTRY pEntry = NULL;

    LV_ITEM lvItem;

    lvItem.iItem = ListView_GetItemCount(m_ctlList);
    lvItem.mask = LVIF_PARAM  | LVIF_IMAGE | LVIF_TEXT;
    lvItem.iSubItem = 0;
    lvItem.pszText = LPSTR_TEXTCALLBACK;
    lvItem.iImage = I_IMAGECALLBACK;

    m_cEmptyList.Hide(); // m,ust be sure that empty mesage is hide

    if(!(nFlag & MAB_BUDDY))
    {
        lvItem.lParam = (LPARAM) AddBlabEntry((nFlag & MAB_GROUP) ? LPARAM_ABGRPENTRY : LPARAM_ABENTRY, lpSB, NULL, pchEmail,
                                    pchDisplayName, (nFlag & MAB_CERT));
        // SetUserIcon(LPARAM_ABGRPENTRY, 0, &(lvItem.iImage));

        ListView_InsertItem(m_ctlList, &lvItem);
        return;
    }

    if(pchEmail)
        pEntry = FindUserEmail(pchEmail, NULL, TRUE);

    if(pEntry)      // buddy found
    {
        // if we already linked this budyy to AN entry, add new list item)
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_MABENTRY, lpSB, pEntry->lpMsgrInfo, pchEmail, pchDisplayName, (nFlag & MAB_CERT));
            // SetUserIcon(LPARAM_MABENTRY, pEntry->lpMsgrInfo->nStatus, &(lvItem.iImage));
            ListView_InsertItem(m_ctlList, &lvItem);
        }
        else if(pEntry->tag == LPARAM_MENTRY)      // buddy was not linked to AB entry
        {
            pEntry->tag = LPARAM_MABENTRY;
            pEntry->lpSB = lpSB;
            Assert(lpSB);
            m_cAddrBook.GetDisplayName(pEntry->lpSB, szName, MAXNAME);
            pEntry->pchWABName = NULL;
            pEntry->pchWABID = NULL;

            if (MemAlloc((LPVOID *) &(pEntry->pchWABName), lstrlen(szName) + 1 ))
                lstrcpy(pEntry->pchWABName, szName);

            if(MemAlloc((LPVOID *) &(pEntry->pchWABID), lstrlen(pchEmail) + 1 ))
                lstrcpy(pEntry->pchWABID, pchEmail);
        }
        else
            Assert(FALSE);      // something strange
    }
    else        // buddy not found, simple AB entry
    {
        lvItem.lParam = (LPARAM) AddBlabEntry(LPARAM_ABENTRY, lpSB, NULL, pchEmail, pchDisplayName, (nFlag & MAB_CERT));
        // SetUserIcon(LPARAM_ABENTRY, 0, &(lvItem.iImage));
        ListView_InsertItem(m_ctlList, &lvItem);
    }
}

LPMABENTRY CMsgrAb::FindUserEmail(TCHAR *pchEmail, int *pIndex, BOOL fMsgrOnly)
{
    LPMABENTRY pEntry = NULL;
    LVITEM             lvi;

    lvi.mask = LVIF_PARAM;
    if(pIndex != NULL)
        lvi.iItem = *pIndex;
    else
        lvi.iItem = -1;
    lvi.iSubItem = 0;

    while((lvi.iItem = ListView_GetNextItem(m_ctlList, lvi.iItem, LVNI_ALL)) != -1)
    {
        ListView_GetItem(m_ctlList, &lvi);
        pEntry = (LPMABENTRY) lvi.lParam;
        if(pEntry)
        {
            if(fMsgrOnly)
            {
                if(pEntry->lpMsgrInfo)
                {
                    if((pEntry->lpMsgrInfo)->pchID)
                    {
                        // lstrcat(szEmailName, szHotMailSuffix);
                        if(!lstrcmpi((pEntry->lpMsgrInfo)->pchID, pchEmail))
                        {
                            if(pIndex != NULL)
                                *pIndex = lvi.iItem;
                            return(pEntry);
                        }
                    }
                }
            }
            else
            {
                if(pEntry->pchWABID)
                {
                    if(!lstrcmpi(pEntry->pchWABID, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }
                if(pEntry->lpSB)
                {
                    if(m_cAddrBook.CheckEmailAddr(pEntry->lpSB, pchEmail))
                    {
                        if(pIndex != NULL)
                            *pIndex = lvi.iItem;
                        return(pEntry);
                    }
                }

            }
        }
    }

    return(NULL);
}
// messenger want shutown. release messenger object
HRESULT CMsgrAb::OnMsgrShutDown(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(m_pCMsgrList)
    {
        m_pCMsgrList->UnRegisterUIWnd(m_hWnd);
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }  
    _ReloadListview();
    return(S_OK);
    
}

// Set new buddy status (online/ofline/etc. and redraw list view entry)
HRESULT CMsgrAb::OnUserStateChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    LPMABENTRY  pEntry = NULL;
    int index = -1;

    while((pEntry = FindUserEmail((LPSTR) lParam, &index, TRUE)) != NULL)
    {
        pEntry->lpMsgrInfo->nStatus = (int) wParam;

#ifdef NEEDED
        // Check that buddy is in WAB
        if((pEntry->tag == LPARAM_MENTRY) && (pEntry->lpMsgrInfo->nStatus != MSTATEOE_OFFLINE) &&
                    (pEntry->lpMsgrInfo->nStatus != MSTATEOE_UNKNOWN) && (pEntry->lpMsgrInfo->nStatus != MSTATEOE_INVISIBLE))
        {
            // Add new contact to WAB, if we know ID and Display Name
            if(pEntry->lpMsgrInfo->pchID && pEntry->lpMsgrInfo->pchMsgrName && lstrcmpi(pEntry->lpMsgrInfo->pchID, pEntry->lpMsgrInfo->pchMsgrName))
            {
                 hr = m_cAddrBook.AutoAddContact(pEntry->lpMsgrInfo->pchMsgrName, pEntry->lpMsgrInfo->pchID); // Don't need redraw now, do it later
//                _ReloadListview();
                return(hr);
            }
        }
#endif
        ListView_RedrawItems(m_ctlList, index, index+1);
    }
//    if(index < 0)

//    Assert(index > -1);
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    return(hr);
}

// Message: buddy was removed
HRESULT CMsgrAb::OnUserRemoved(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
    int index = -1;
    LPMABENTRY  pEntry = NULL;

    while((pEntry = FindUserEmail((LPSTR) lParam, &index, TRUE)) != NULL)
    {
        // Not removed yet
        if(pEntry->tag == LPARAM_MABENTRY)
        {
            Assert(pEntry->lpMsgrInfo);
            if(pEntry->lpMsgrInfo)
            {
                RemoveMsgrInfo(pEntry->lpMsgrInfo);

                pEntry->lpMsgrInfo = NULL;
            }

            pEntry->tag = LPARAM_ABENTRY;
            ListView_RedrawItems(m_ctlList, index, index+1);
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            int index1 = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);
            m_delItem++;
            ListView_DeleteItem(m_ctlList, index);
            if(index == index1)
            {
                index1--;
                ListView_SetItemState(m_ctlList, ((index1 >= 0) ? index1 : 0), LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
        else
            index++;
    }

    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    return(hr);
}

// Event User was added => add buddy to our list.
HRESULT CMsgrAb::OnUserAdded(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    LPMINFO  pItem =  (LPMINFO) lParam;

    AddMsgrListItem(pItem);

#ifdef NEEDED
    TCHAR szText[CCHMAX_STRINGRES + RESSTRMAX];
    TCHAR szBuff[CCHMAX_STRINGRES];

        AthLoadString(idsBAAddedUser, szBuff, ARRAYSIZE(szBuff));
        wsprintf(szText, szBuff,  pItem->pchMsgrName ? pItem->pchMsgrName : pItem->pchID);

        if(IDYES == AthMessageBox(m_hWnd, MAKEINTRESOURCE(idsAthena), szText,
                      NULL, MB_YESNO | MB_ICONEXCLAMATION))
            m_cAddrBook.AddContact(m_hWnd, pItem->pchMsgrName, pItem->pchID);
        else  // just update list
#endif //NEEDED
    ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);

    return(S_OK);
}

HRESULT CMsgrAb::OnUserNameChanged(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    HRESULT hr = S_OK;
#ifdef NEEDED
    LPMINFO  pItem =  (LPMINFO) lParam;
    LPMABENTRY  pEntry = NULL;
    int index = -1;

    while((pEntry = FindUserEmail(pItem->pchID, &index, TRUE)) != NULL)
    {
        if((pEntry->tag == LPARAM_MENTRY) && lstrcmpi(pItem->pchID, pItem->pchMsgrName))
        {
            hr = m_cAddrBook.AutoAddContact(pItem->pchMsgrName, pItem->pchID);
            // _ReloadListview();
        }
        ListView_RedrawItems(m_ctlList, index, index+1);
    }
#endif
    _ReloadListview();
    return(hr);
}

HRESULT CMsgrAb::OnUserLogoffEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(!m_fLogged)
        return S_OK;
    else
        m_fLogged = FALSE;

    SetWindowRedraw(m_ctlList, FALSE);
    int index = ListView_GetNextItem(m_ctlList, -1, LVIS_SELECTED | LVIS_FOCUSED);

    // Delete everything and reload
    if(m_delItem != 0)
        m_fNoRemove = TRUE;
//    else
//        m_fNoRemove = FALSE;

    m_delItem = ListView_GetItemCount(m_ctlList);
    ListView_DeleteAllItems(m_ctlList);
//     FillMsgrList();                         // User list reload
    m_cAddrBook.LoadWabContents(m_ctlList, this);
    ListView_SetItemState(m_ctlList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
     SetWindowRedraw(m_ctlList, TRUE);

    if(ListView_GetItemCount(m_ctlList) > 0)
        m_cEmptyList.Hide();
    else
        m_cEmptyList.Show(m_ctlList, (LPTSTR) m_szEmptyList);

    UpdateWindow(/*m_ctlList*/);

    return S_OK;

}

HRESULT CMsgrAb::OnUserLogResultEvent(UINT nMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  bHandled)
{
    if(SUCCEEDED(lParam))
    {
        _ReloadListview();
        m_fLogged = TRUE;
    }
    return S_OK;
}

LRESULT CMsgrAb::NotifySetFocus(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    UnkOnFocusChangeIS(m_pObjSite, (IInputObject*) this, TRUE);
    return (0);
}

HRESULT  STDMETHODCALLTYPE CMsgrAb::QueryStatus(const GUID *pguidCmdGroup,
                                                ULONG cCmds, OLECMD *prgCmds,
                                                OLECMDTEXT *pCmdText)
{
    int     nEnable;
    HRESULT hr;
    DWORD   cSelected = ListView_GetSelectedCount(m_ctlList);
    UINT    id;
    MSTATEOE  State;

    // Loop through all the commands in the array
    for ( ; cCmds > 0; cCmds--, prgCmds++)
    {
        // Only look at commands that don't have OLECMDF_SUPPORTED;
        if (prgCmds->cmdf == 0)
        {
            switch (prgCmds->cmdID)
            {
                // These commands are enabled if and only if one item is selected
                case ID_DELETE_CONTACT:
                    if (cSelected > 0)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SEND_MESSAGE:
                case ID_FIND_PEOPLE:
                case ID_ADDRESS_BOOK:
#ifdef GEORGEH
                case ID_NEW_MSG_DEFAULT:
#endif
                    if(HasFocusIO() == S_OK)
                       prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SEND_INSTANT_MESSAGE2:
                {
                    if(g_dwHideMessenger == BL_NOTINST)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else if (cSelected == 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_SORT_BY_STATUS:
                    if((g_dwHideMessenger & BL_NOTINST) || (g_dwHideMessenger & BL_HIDE))
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_STATUS_ACSEND) || (m_nSortType == BASORT_STATUS_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;
                    break;

                case ID_SORT_BY_NAME:
                    if((g_dwHideMessenger & BL_NOTINST) || (g_dwHideMessenger & BL_HIDE))
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }
                    else if(ListView_GetItemCount(m_ctlList) > 1)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    if((m_nSortType == BASORT_NAME_ACSEND) || (m_nSortType == BASORT_NAME_DESCEND))
                        prgCmds->cmdf |= OLECMDF_NINCHED;


                    break;

                // These commands are always enabled
                case ID_POPUP_NEW_ACCOUNT:
                case ID_NEW_HOTMAIL_ACCOUNT:
                case ID_NEW_ATT_ACCOUNT:
                case ID_NEW_CONTACT:
                case ID_POPUP_MESSENGER:
                    prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;

                case ID_SET_ONLINE_CONTACT:
                    {
                        if(cSelected != 1)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        LPMABENTRY pEntry = GetSelectedEntry();
                        if(!pEntry && m_pCMsgrList)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                        else if(pEntry && pEntry->tag != LPARAM_ABENTRY)
                        {
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                            break;
                        }
                    }
                case ID_NEW_ONLINE_CONTACT:
                    if(m_pCMsgrList)
                    {
                        if(m_pCMsgrList->IsLocalOnline())
                            prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        else
                            prgCmds->cmdf = OLECMDF_SUPPORTED;
                    }
                    else if(g_dwHideMessenger == BL_NOTINST)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;

                    break;

                // Properties is only enabled if the input focus is in the
                // list view.  Otherwise, we don't mark it as supported at all.
                case ID_PROPERTIES:
                {
                    LPMABENTRY pEntry = GetSelectedEntry();
                    if(pEntry && pEntry->tag != LPARAM_MENTRY)
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_MESSENGER_OPTIONS:

                    if (!m_pCMsgrList)
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;

                    break;

                // These depend on whether
                case ID_LOGIN_MESSENGER:
                case ID_LOGOFF_MESSENGER:
                case ID_MESSENGER_ONLINE:
                case ID_MESSENGER_INVISIBLE:
                case ID_MESSENGER_BUSY:
                case ID_MESSENGER_BACK:
                case ID_MESSENGER_AWAY:
                case ID_MESSENGER_ON_PHONE:
                case ID_MESSENGER_LUNCH:
                case ID_POPUP_MESSENGER_STATUS:
                {
                    // If messenger isn't installed, then none of these commands will
                    // be enabled.
                    if (!m_pCMsgrList)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        break;
                    }

                    if (FAILED(m_pCMsgrList->GetLocalState(&State)))
                        State = MSTATEOE_UNKNOWN;

                    // Convert the online state to a command ID
                    switch (State)
                    {
                        case MSTATEOE_ONLINE:
                        case MSTATEOE_IDLE:
                            id = ID_MESSENGER_ONLINE;
                            break;
                        case MSTATEOE_INVISIBLE:
                            id = ID_MESSENGER_INVISIBLE;
                            break;
                        case MSTATEOE_BUSY:
                            id = ID_MESSENGER_BUSY;
                            break;
                        case MSTATEOE_BE_RIGHT_BACK:
                            id = ID_MESSENGER_BACK;
                            break;
                        case MSTATEOE_AWAY:
                            id = ID_MESSENGER_AWAY;
                            break;
                        case MSTATEOE_ON_THE_PHONE:
                            id = ID_MESSENGER_ON_PHONE;
                            break;
                        case MSTATEOE_OUT_TO_LUNCH:
                            id = ID_MESSENGER_LUNCH;
                            break;
                        default:
                            id = 0xffff;
                    }

                    // Logon is handled a bit seperatly
                    if (prgCmds->cmdID == ID_LOGIN_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id == 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else if (prgCmds->cmdID == ID_LOGOFF_MESSENGER)
                    {
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf |= OLECMDF_ENABLED;
                    }
                    else
                    {
                        // For all other commands, if we in a known state
                        // then the command is enabled.
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                        if (id != 0xffff)
                            prgCmds->cmdf = OLECMDF_ENABLED;

                        // If the command is the same as our state, it should be checked
                        if (id == prgCmds->cmdID)
                            prgCmds->cmdf |= OLECMDF_NINCHED;
                    }
                }
                break;

                case ID_SEND_INSTANT_MESSAGE:
                {
                    if (GetEntryForSendInstMsg() || (g_dwHideMessenger == BL_NOTINST))
                        prgCmds->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds->cmdf = OLECMDF_SUPPORTED;
                    break;
                }
            }
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CMsgrAb::Exec(const GUID  *pguidCmdGroup,
                                                    DWORD        nCmdID,
                                                    DWORD        nCmdExecOpt,
                                                    VARIANTARG   *pvaIn,
                                                    VARIANTARG   *pvaOut)
{
    HRESULT     hr = OLECMDERR_E_NOTSUPPORTED;
    BOOL        bHandled = 0;
    MSTATEOE      State = MSTATEOE_UNKNOWN;

    switch (nCmdID)
    {
    case ID_SEND_INSTANT_MESSAGE2:
        CmdNewMessage(HIWORD(nCmdID), ID_SEND_INSTANT_MESSAGE2, m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_DELETE_CONTACT:
        hr = (HRESULT) CmdDelete(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_NEW_CONTACT:
//        if(HasFocusIO() == S_OK)
        CmdNewContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_SET_ONLINE_CONTACT:
        CmdSetOnline(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_NEW_ONLINE_CONTACT:
        CmdNewOnlineContact(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_PROPERTIES:
    {
        // Only if we have focus
        if (m_ctlList == GetFocus())
        {
            CmdProperties(0, 0, m_ctlList, bHandled);
            hr = S_OK;
        }
        break;
    }

#ifdef GEORGEH
    case ID_NEW_MSG_DEFAULT:
        if(HasFocusIO() == S_OK)
            hr = CmdNewMessage(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;
#endif // GEORGEH

    case ID_SEND_MESSAGE:
        if(HasFocusIO() == S_OK)
            hr = (HRESULT) CmdNewEmaile(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        break;

    case ID_SEND_INSTANT_MESSAGE:
        // Assert(m_pCMsgrList);
        CmdNewIMsg(HIWORD(nCmdID), LOWORD(nCmdID), m_ctlList, bHandled);
        hr = S_OK;
        break;

    case ID_MESSENGER_OPTIONS:
        hr = m_pCMsgrList->LaunchOptionsUI(); //CmdMsgrOptions();
        break;

    case ID_MESSENGER_ONLINE:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_ONLINE);
        break;

    case ID_MESSENGER_INVISIBLE:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_INVISIBLE);
        break;

    case ID_MESSENGER_BUSY:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_BUSY);
        break;

    case ID_MESSENGER_BACK:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_BE_RIGHT_BACK);
        break;

    case ID_MESSENGER_AWAY:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_AWAY);
        break;

    case ID_MESSENGER_ON_PHONE:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_ON_THE_PHONE);
        break;

    case ID_MESSENGER_LUNCH:
        Assert(m_pCMsgrList);
        hr = m_pCMsgrList->SetLocalState(MSTATEOE_OUT_TO_LUNCH);
        break;

    case ID_LOGIN_MESSENGER:
        Assert(m_pCMsgrList);
        if(!m_pCMsgrList->IsLocalOnline())
        {
            if(PromptToGoOnline() == S_OK)
                m_pCMsgrList->UserLogon();
        }
        hr = S_OK;
        break;

    case ID_LOGOFF_MESSENGER:
        Assert(m_pCMsgrList);
        if(m_pCMsgrList->IsLocalOnline())
        {
            m_pCMsgrList->UserLogoff();
        }
        hr = S_OK;
        break;

    case ID_SORT_BY_NAME:
        m_nSortType = BASORT_NAME_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    case ID_SORT_BY_STATUS:
        m_nSortType = BASORT_STATUS_ACSEND;
        ListView_SortItems(m_ctlList, BA_Sort, m_nSortType);
        break;

    default:
        break;
    }

    return hr;
}

#ifdef OLDTIPS
//
//  FUNCTION:   CMsgrAb::OnListMouseEvent()
//
//  PURPOSE:    Whenever we get our first mouse event in a series, we call
//              TrackMouseEvent() so we know when the mouse leaves the ListView.
//
HRESULT CMsgrAb::OnListMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // If we have the view tooltip, then we track all mouse events
    if (!m_fTrackSet && m_fViewTip && (uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST))
    {
        TRACKMOUSEEVENT tme;

        tme.cbSize = sizeof(tme);
        tme.hwndTrack = m_ctlList;
        tme.dwFlags = TME_LEAVE;
        tme.dwHoverTime = 1000;

        if (_TrackMouseEvent(&tme))
            m_fTrackSet = TRUE;
    }

    bHandled = FALSE;
    return (0);
}


//
//  FUNCTION:   CMsgrAb::OnListMouseMove()
//
//  PURPOSE:    If the ListView tooltips are turned on, we need to relay mouse
//              move messages to the tooltip control and update our cached
//              information about what the mouse is over.
//
HRESULT CMsgrAb::OnListMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LVHITTESTINFO lvhti;

    // If we're displaying view tips, then we need to figure out if the mouse is
    // over the same item or not.
    if (m_fViewTip && m_ctlViewTip)
        _UpdateViewTip(LOWORD(lParam), HIWORD(lParam));

    bHandled = FALSE;
    return (0);
}

//
//  FUNCTION:   HRESULT CMsgrAb::OnListMouseLeave()
//
//  PURPOSE:    When the mouse leaves the ListView window, we need to make
//              sure we hide the tooltip.
//
HRESULT CMsgrAb::OnListMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TOOLINFO ti = {0};
    if (m_fViewTip && m_ctlViewTip)
    {
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hWnd;
        ti.uId = (UINT_PTR)(HWND) m_ctlList;

        // Hide the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
        m_fViewTipVisible = FALSE;

        // Reset our item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        // Tracking is no longer set
        m_fTrackSet = FALSE;
    }
    bHandled = FALSE;
    return (0);
}

// UpdateViewTip - update expand string in list view
// ported from msglist.cpp
BOOL CMsgrAb::_UpdateViewTip(int x, int y)
{
    LVHITTESTINFO lvhti = {0};
    TOOLINFO      ti = {0};
    FNTSYSTYPE    fntType;
    RECT          rc;
    MESSAGEINFO       rInfo;
    COLUMN_ID     idColumn;
    TCHAR         szText[CCHMAX_STRINGRES + MAXNAME + 1] = _T("");
    TCHAR         szName[MAXNAME];
    POINT         pt;
    LVITEM        lvi;

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd   = m_hWnd;
    ti.uId    = (UINT_PTR)(HWND) m_ctlList;

    // Get the item and subitem the mouse is currently over
    lvhti.pt.x = x;
    lvhti.pt.y = y;
    ListView_SubItemHitTest(m_ctlList, &lvhti);

    // If the item doesn't exist, then the above call returns the item -1.  If
    // we encounter -1, we break the loop and return FALSE.
    if (-1 == lvhti.iItem || !_IsItemTruncated(lvhti.iItem, lvhti.iSubItem) || !::IsChild(GetForegroundWindow(), m_ctlList))
    {
        // Hide the tip
        if (m_fViewTipVisible)
        {
            m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
            m_fViewTipVisible = FALSE;
        }

        // Reset the item / subitem
        m_iItemTip = -1;
        m_iSubItemTip = -1;

        return (FALSE);
    }

    // If the newly found item & subitem is different from what we're already
    // set up to show, then update the tooltip
    if (m_iItemTip != lvhti.iItem || m_iSubItemTip != lvhti.iSubItem)
    {
        // Update our cached item / subitem
        m_iItemTip = lvhti.iItem;
        m_iSubItemTip = lvhti.iSubItem;

        // Figure out if this column has an image
        lvi.mask = LVIF_PARAM;
        lvi.iItem = m_iItemTip;
        lvi.iSubItem = 0;
        ListView_GetItem(m_ctlList, &lvi);

        LPMABENTRY pEntry = (LPMABENTRY) lvi.lParam;

        if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_ABENTRY || pEntry->tag == LPARAM_ABGRPENTRY)
        {
            Assert(pEntry->pchWABName != NULL);
            lstrcpyn(szName, pEntry->pchWABName, MAXNAME);
            szName[MAXNAME - 1] =  _T('\0');
        }
        else if(pEntry->tag == LPARAM_MENTRY)
        {
            lstrcpyn(szName, pEntry->lpMsgrInfo->pchMsgrName, MAXNAME);
            szName[MAXNAME - 1] =  _T('\0');
        }
        else
            Assert(FALSE);

        lstrcpy(szText, szName);

        if(pEntry->lpMsgrInfo)
        {
            switch(pEntry->lpMsgrInfo->nStatus)
            {
            case MSTATEOE_ONLINE:
                lstrcat(szText, m_szOnline);
                break;
            case MSTATEOE_BUSY:
                lstrcat(szText, m_szBusy);
                break;
            case MSTATEOE_BE_RIGHT_BACK:
                lstrcat(szText, m_szBack);
                break;
            case MSTATEOE_IDLE:
                lstrcat(szText, m_szIdle);
                break;
            case MSTATEOE_AWAY:
                lstrcat(szText, m_szAway);
                break;
            case MSTATEOE_ON_THE_PHONE:
                lstrcat(szText, m_szOnPhone);
                break;
            case MSTATEOE_OUT_TO_LUNCH:
                lstrcat(szText, m_szLunch);
                break;

            default:
                lstrcat(szText, m_szOffline);
                break;
            }
        }

        ti.lpszText = szText;
        m_ctlViewTip.SendMessage(TTM_UPDATETIPTEXT, 0, (LPARAM) &ti);

        // Figure out where to place the tip
        ListView_GetSubItemRect(m_ctlList, m_iItemTip, m_iSubItemTip, LVIR_LABEL, &rc);
        m_ctlList.ClientToScreen(&rc);

        // Update the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
        m_fViewTipVisible = TRUE;

        // Do some voodoo to line up the tooltip
        pt.x = rc.left;
        pt.y = rc.top;

        // Update the tooltip position
        m_ctlViewTip.SendMessage(TTM_TRACKPOSITION, 0, MAKELPARAM(pt.x, pt.y));

        // Update the tooltip
        m_ctlViewTip.SendMessage(TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
        m_fViewTipVisible = TRUE;

        return (TRUE);
    }

    return (FALSE);
}

BOOL CMsgrAb::_IsItemTruncated(int iItem, int iSubItem)
{
    HDC     hdc = NULL;
    SIZE    size={0};
    BOOL    bRet = TRUE;
    LVITEM  lvi;
    TCHAR   szText[256] = _T("");
    int     cxEdge;
    BOOL    fBold;
    RECT    rcText;
    int     cxWidth;
    LPMABENTRY pEntry = NULL;
    HFONT   hf = NULL;;

    // Get the text of the specified item
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = iSubItem;
    lvi.pszText = szText;
    lvi.cchTextMax = ARRAYSIZE(szText);
    ListView_GetItem(m_ctlList, &lvi);

    // If there's no text, it's not truncated, eh?
    if (0 == *szText)
        return (FALSE);

    // if Msgr entry then always expend
    pEntry = (LPMABENTRY) lvi.lParam;
    if(pEntry->tag == LPARAM_MABENTRY || pEntry->tag == LPARAM_MENTRY)
        return(TRUE);

    // ListView uses this for padding
    cxEdge = GetSystemMetrics(SM_CXEDGE);

    // Get the sub item rect from the ListView
    ListView_GetSubItemRect(m_ctlList, iItem, iSubItem, LVIR_LABEL, &rcText);

    // Figure out the width
    cxWidth = rcText.right - rcText.left;
    cxWidth -= (6 * cxEdge);

    // Figure out the width of the string
    hdc = m_ctlList.GetDC();

    if(hdc)
    {
        hf = SelectFont(hdc, HGetCharSetFont(FNT_SYS_ICON, GetListViewCharset()));

        if(hf)
        {
            GetTextExtentPoint(hdc, szText, lstrlen(szText), &size);

            SelectFont(hdc, hf);
        }
        m_ctlList.ReleaseDC(hdc);
    }

    return (cxWidth < size.cx);
}

#endif // OLDTIPS
STDMETHODIMP CMsgrAb::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    TCHAR sz[CCHMAX_STRINGRES];
    if(m_lpWED->fReadOnly)
        return NOERROR;

    PROPSHEETPAGE psp;

    // hinstApp        = g_hInst;
    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE ;
    psp.hInstance   = g_hLocRes;
    psp.lParam      = (LPARAM) &(m_lpWED);
    psp.pcRefParent = (UINT *)&(m_cRefThisDll);

    psp.pszTemplate = MAKEINTRESOURCE(iddWabExt);

    psp.pfnDlgProc  = (DLGPROC) WabExtDlgProc;
    psp.pszTitle    = AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz)); // Title for your tab AthLoadString(idsWABExtTitle, sz, ARRAYSIZE(sz))

    m_hPage1 = ::CreatePropertySheetPage(&psp);
    if (m_hPage1)
    {
        if (!lpfnAddPage(m_hPage1, lParam))
            ::DestroyPropertySheetPage(m_hPage1);
    }

    return NOERROR;
}


STDMETHODIMP CMsgrAb::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    Assert(FALSE);
    return E_NOTIMPL;
}

STDMETHODIMP CMsgrAb::Initialize(LPWABEXTDISPLAY lpWABExtDisplay)
{

    if (lpWABExtDisplay == NULL)
    {
	    TRACE("CMsgrAb::Initialize() no data object");
	    return E_FAIL;
    }

    if(st_pAddrBook == NULL)
    {
	    TRACE("CMsgrAb::Initialize() - run from not OE - no st_pAddrbook");
	    return E_FAIL;
    }

    if(!m_pCMsgrList)
    {
        m_pCMsgrList = OE_OpenMsgrList();
        if(!m_pCMsgrList)
        {
    	    TRACE("CMsgrAb::Initialize() - Messeneger not installed");
	        return E_FAIL;
        }
        OE_CloseMsgrList(m_pCMsgrList);
        m_pCMsgrList = NULL;
    }

    // However if this is a context menu extension, we need to hang
    // onto the propobj till such time as InvokeCommand is called ..
    // At this point just AddRef the propobj - this will ensure that the
    // data in the lpAdrList remains valid till we release the propobj..
    // When we get another ContextMenu initiation, we can release the
    // older cached propobj - if we dont get another initiation, we
    // release the cached object at shutdown time
    if(lpWABExtDisplay->ulFlags & WAB_CONTEXT_ADRLIST) // this means a IContextMenu operation is occuring
    {
        if(m_lpPropObj)
        {
            m_lpPropObj->Release();
            m_lpPropObj = NULL;
        }

        m_lpPropObj = lpWABExtDisplay->lpPropObj;
        m_lpPropObj->AddRef();

        m_lpWEDContext = lpWABExtDisplay;
    }
    else
    {
        // For property sheet extensions, the lpWABExtDisplay will
        // exist for the life of the property sheets ..
        m_lpWED = lpWABExtDisplay;
    }

    return S_OK;
}

HRESULT CMsgrAb::PromptToGoOnline()
{
    HRESULT     hr;

    if (g_pConMan->IsGlobalOffline())
    {
        if (IDYES == AthMessageBoxW(m_hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                  0, MB_YESNO | MB_ICONEXCLAMATION ))
        {
            g_pConMan->SetGlobalOffline(FALSE);
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
        hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\bactrl\clutil.h ===
//****************************************************************************
//
//  BLClient sample for Microsoft Messenger SDK
//
//  Module:     BLClient.exe
//  File:       clUtil.h
//  Content:    Usefull clases for COM and Connection points
//              
//
//  Copyright (c) Microsoft Corporation 1997-1998
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _CL_UTIL_H_
#define _CL_UTIL_H_


//****************************************************************************
//
// CLASS RefCount
//
//****************************************************************************

class RefCount
{
private:
   LONG m_cRef;

public:
   RefCount();
   // Virtual destructor defers destruction to destructor of derived class.
   virtual ~RefCount();

   ULONG STDMETHODCALLTYPE AddRef(void);
   ULONG STDMETHODCALLTYPE Release(void);
};



//****************************************************************************
//
// CLASS CNotify
//
// Notification sink
//
//****************************************************************************

class CNotify
{
private:
    DWORD  m_dwCookie;
	IUnknown * m_pUnk;
    IConnectionPoint           * m_pcnp;
    IConnectionPointContainer  * m_pcnpcnt;
public:
    CNotify(void);
    ~CNotify();

    HRESULT Connect(IUnknown *pUnk, REFIID riid, IUnknown *pUnkN);
    HRESULT Disconnect(void);

    IUnknown * GetPunk() {return m_pUnk;}
};



//****************************************************************************
//
// CLASS BSTRING
//
//****************************************************************************

class BSTRING
{
private:
	BSTR   m_bstr;

public:
	// Constructors
	BSTRING() {m_bstr = NULL;}

	inline BSTRING(LPCWSTR lpcwString);

#ifndef UNICODE
	// We don't support construction from an ANSI string in the Unicode build.
	BSTRING(LPCSTR lpcString);
#endif // #ifndef UNICODE

	// Destructor
	inline ~BSTRING();

	// Cast to BSTR
	operator BSTR() {return m_bstr;}
	inline LPBSTR GetLPBSTR(void);
};

BSTRING::BSTRING(LPCWSTR lpcwString)
{
	if (NULL != lpcwString)
	{
		m_bstr = SysAllocString(lpcwString);
		// ASSERT(NULL != m_bstr);
	}
	else
	{
		m_bstr = NULL;
	}
}

BSTRING::~BSTRING()
{
	if (NULL != m_bstr)
	{
		SysFreeString(m_bstr);
	}
}

inline LPBSTR BSTRING::GetLPBSTR(void)
{
	// This function is intended to be used to set the BSTR value for
	// objects that are initialized to NULL.  It should not be called
	// on objects which already have a non-NULL BSTR.
	// ASSERT(NULL == m_bstr);

	return &m_bstr;
}



//****************************************************************************
//
// CLASS BTSTR
//
//****************************************************************************

class BTSTR
{
private:
	LPTSTR m_psz;

public:
	BTSTR(BSTR bstr);
	~BTSTR();

	// Cast to BSTR
	operator LPTSTR() {return (NULL == m_psz) ? TEXT("<null>") : m_psz;}
};

LPTSTR LPTSTRfromBstr(BSTR bstr);

#endif  // _CL_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\acctcach.h ===
/*
 *  a c c t c a c h . h
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Runtime store for cached account properties.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#ifndef _ACCTCACH_H
#define _ACCTCACH_H

typedef enum tagCACHEDACCOUNTPROP
{
    CAP_HTTPMAILMSGFOLDERROOT,
    CAP_HTTPMAILSENDMSG,
    CAP_HTTPNOMESSAGEDELETES,
    CAP_PASSWORD,
    CAP_HTTPAUTOSYNCEDFOLDERS,
    CAP_LAST
} CACHEDACCOUNTPROP;

void FreeAccountPropCache(void);

HRESULT HrCacheAccountPropStrA(LPSTR pszAccountId, CACHEDACCOUNTPROP cap, LPCSTR pszProp);
BOOL GetAccountPropStrA(LPSTR pszAccountId, CACHEDACCOUNTPROP cap, LPSTR *ppszProp);

void AccountCache_AccountChanged(LPSTR pszAccountId);
void AccountCache_AccountDeleted(LPSTR pszAccountId); 

#endif // _ACCTCACH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\build\browse.inc ===
mailnews.rc : $(R)\res\mailnews.rc
    copy $** $@

mailnews.bsc: objd\i386\mailnews.bsc
    move objd\i386\mailnews.bsc .

objd\i386\*.sbr :
    move $(R)\inc\objd\i386\*.sbr objd\i386
    move $(R)\common\objd\i386\*.sbr objd\i386
    move $(R)\imap\objd\i386\*.sbr objd\i386
    move $(R)\mail\objd\i386\*.sbr objd\i386
    move $(R)\mime\objd\i386\*.sbr objd\i386
    move $(R)\news\objd\i386\*.sbr objd\i386
    move $(R)\proptree\objd\i386\*.sbr objd\i386
    move $(R)\shell\objd\i386\*.sbr objd\i386
    move $(R)\store\objd\i386\*.sbr objd\i386
    move $(R)\fechrcnv\objd\i386\*.sbr objd\i386
	move $(R)\http\objd\i386\*.sbr objd\i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\build\dummy16.cpp ===
// bogus file for 16bit

void aaa()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\build\makefile.inc ===
mailnews.bsc: $O\mailnews.bsc
    move $O\mailnews.bsc .

$O\*.sbr :
    move $(R)\inc\$O\*.sbr $O
    move $(R)\store\$O\*.sbr $O
    move $(R)\rules\$O\*.sbr $O
    move $(R)\common\$O\*.sbr $O
    move $(R)\om\$O\*.sbr $O
    move $(R)\bactrl\$O\*.sbr $O
    move $(R)\mail\$O\*.sbr $O
    move $(R)\news\$O\*.sbr $O
    move $(R)\shell\$O\*.sbr $O
    move $(R)\view\$O\*.sbr $O
    move $(R)\spooler\$O\*.sbr $O
    move $(R)\imap\$O\*.sbr $O
    move $(R)\http\$O\*.sbr $O


ATHENA_RC_DEPENDS = $(O)\selfreg.inf 	    \
                    ..\inc\$(O)\msoeobj.tlb

$(O)\msoe.res : $(ATHENA_RC_DEPENDS)

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\acctcach.cpp ===
/*
 *  a c c t c a c h . c p p
 *  
 *  Author: Greg Friedman
 *
 *  Purpose: Runtime store for cached account properties.
 *  
 *  Copyright (C) Microsoft Corp. 1998.
 */

#include "pch.hxx"
#include "acctcach.h"
#include "tmap.h"
#include "simpstr.h"

// explicit template instantiations
template class TMap<CACHEDACCOUNTPROP, CSimpleString>;
template class TPair<CACHEDACCOUNTPROP, CSimpleString>;

typedef TMap<CACHEDACCOUNTPROP, CSimpleString>  CAccountPropMap;
typedef TPair<CACHEDACCOUNTPROP, CSimpleString> CAccountPropPair;

template class TMap<CSimpleString, CAccountPropMap*>;
template class TPair<CSimpleString, CAccountPropMap*>;

typedef TMap<CSimpleString, CAccountPropMap*>  CAccountCacheMap;
typedef TPair<CSimpleString, CAccountPropMap*>  CAccountCachePair;

static CAccountCacheMap     *g_pAccountCache;

// REVIEW!!! We are leaking the prop arrays right now!!!
// the map template needs to be able to take a pair free func

//----------------------------------------------------------------------
// Internal Functions
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// _FreeAccountCachePair
//----------------------------------------------------------------------
static void __cdecl _FreeAccountCachePair(CAccountCachePair *pPair)
{
    if (NULL != pPair)
    {
        delete pPair->m_value;
        delete pPair;
    }
}

//----------------------------------------------------------------------
// _HrInitAccountPropCache
//----------------------------------------------------------------------
static HRESULT _HrInitAccountPropCache(void)
{
    HRESULT hr = S_OK;

    Assert(NULL == g_pAccountCache);

    if (NULL != g_pAccountCache)
        return E_FAIL;
    
    g_pAccountCache = new CAccountCacheMap();
    if (NULL == g_pAccountCache)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    g_pAccountCache->SetPairFreeFunction(_FreeAccountCachePair);

exit:
    return S_OK;
}

//----------------------------------------------------------------------
// _HrFindAccountPropertyMap
//----------------------------------------------------------------------
static HRESULT _HrFindAccountPropertyMap(LPSTR pszAccountId, 
                                         CAccountPropMap **ppm,
                                         BOOL fCreate)
{
    HRESULT             hr = S_OK;
    CSimpleString       ss;
    CAccountCachePair   *pPair = NULL;
    CAccountPropMap     *pMap = NULL;

    Assert(NULL != ppm);

    *ppm = NULL;

    if (NULL == g_pAccountCache)
    {
        if (fCreate)
            hr = _HrInitAccountPropCache();

        if (NULL == g_pAccountCache)
            goto exit;
    }

    if (FAILED(hr = ss.SetString(pszAccountId)))
        goto exit;

    pPair = g_pAccountCache->Find(ss);
    if (NULL != pPair)
        *ppm = pPair->m_value;
    else if (fCreate)
    {
        pMap = new CAccountPropMap();
        if (NULL == pMap)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (FAILED(hr = g_pAccountCache->Add(ss, pMap)))
        {
            delete pMap;
            goto exit;
        }

        *ppm = pMap;
    }

exit:
    return hr;
}

//----------------------------------------------------------------------
// FreeAccountPropCache
//----------------------------------------------------------------------
void FreeAccountPropCache(void)
{
    EnterCriticalSection(&g_csAccountPropCache);
    
    if (NULL != g_pAccountCache)
    {
        delete g_pAccountCache;
        g_pAccountCache = NULL;
    }
    
    LeaveCriticalSection(&g_csAccountPropCache);
}

//----------------------------------------------------------------------
// HrCacheAccountPropStrA
//----------------------------------------------------------------------
HRESULT HrCacheAccountPropStrA(LPSTR pszAccountId, 
                               CACHEDACCOUNTPROP cap, 
                               LPCSTR pszProp)
{
    HRESULT             hr = S_OK;
    CAccountPropMap     *pMap = NULL;
    CAccountPropPair    *pPair = NULL;
    CSimpleString       ssProp;

    if (NULL == pszAccountId || NULL == pszProp)
        return E_INVALIDARG;

    EnterCriticalSection(&g_csAccountPropCache);
    
    // find the account property map. create one if it doesn't exist
    if (FAILED(hr = _HrFindAccountPropertyMap(pszAccountId, &pMap, TRUE)))
        goto exit;

    if (FAILED(hr = ssProp.SetString(pszProp)))
        goto exit;

    // look for the property in the map
    pPair = pMap->Find(cap);
    if (NULL == pPair)
        hr = pMap->Add(cap, ssProp);
    else
        pPair->m_value = ssProp;

exit:
    LeaveCriticalSection(&g_csAccountPropCache);

    return hr;
}

//----------------------------------------------------------------------
// CacheAccountPropStrA
//----------------------------------------------------------------------
BOOL GetAccountPropStrA(LPSTR pszAccountId, 
                             CACHEDACCOUNTPROP cap, 
                             LPSTR *ppszProp)
{
    HRESULT             hr = S_OK;
    CAccountPropMap     *pMap = NULL;
    CAccountPropPair    *pPair = NULL;
    BOOL                fResult = FALSE;

    Assert(NULL != pszAccountId && NULL != ppszProp);

    if (NULL == g_pAccountCache)
        return FALSE;

    if (NULL == pszAccountId || NULL == ppszProp)
        return FALSE;

    *ppszProp = NULL;

    EnterCriticalSection(&g_csAccountPropCache);

    // find the account property map. don't create one if it doesn't exist
    if (FAILED(hr = _HrFindAccountPropertyMap(pszAccountId, &pMap, FALSE)))
        goto exit;

    if (NULL == pMap)
        goto exit;

    pPair = pMap->Find(cap);
    if (NULL != pPair)
    {
        Assert(!pPair->m_value.IsNull());
        if (!pPair->m_value.IsNull())
        {
            *ppszProp = PszDupA(pPair->m_value.GetString());
            if (NULL != *ppszProp)
                fResult = TRUE;
        }
    }

exit:
    LeaveCriticalSection(&g_csAccountPropCache);

    return fResult;
}

//----------------------------------------------------------------------
// AccountCache_AccountChanged
//----------------------------------------------------------------------
void AccountCache_AccountChanged(LPSTR pszAccountId)
{
    // delete the data associated with the account that was changed
    EnterCriticalSection(&g_csAccountPropCache);

    if (NULL != g_pAccountCache)
    {
        CSimpleString ss;
        if (SUCCEEDED(ss.SetString(pszAccountId)))
            g_pAccountCache->Remove(ss);
    }
    
    LeaveCriticalSection(&g_csAccountPropCache);
}

//----------------------------------------------------------------------
// AccountCache_AccountDeleted
//----------------------------------------------------------------------
void AccountCache_AccountDeleted(LPSTR pszAccountId)
{
    AccountCache_AccountChanged(pszAccountId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\about.cpp ===
//
// about.cpp
//
// About dialog box
//

#include "pch.hxx"
#include "resource.h"
#include "strconst.h"
#include <demand.h>     // must be last!

// Please keep this list in alphabetical order
static const TCHAR *rgszDll[] = 
{
    "acctres.dll",
    "comctl32.dll",
    "csapi3t1.dll",
    "directdb.dll",
    "inetcomm.dll",
    "inetres.dll",
    "mapi32.dll",
    "mshtml.dll",
    "msident.dll",
    "msoe.dll",
    "msoeacct.dll",
    "msoeres.dll",
    "msoert2.dll",
    "oeimport.dll",
    "ole32.dll",
    "riched20.dll",
    "riched32.dll",
    "wab32.dll",
    "wab32res.dll",
    "wldap32.dll",
};

static const TCHAR *rgszVer[] = {
//     "FileDescription",
    "FileVersion",
    "LegalCopyright",
};


#define NUM_DLLS (sizeof(rgszDll)/sizeof(char *))         

LRESULT CALLBACK AboutAthena(HWND hdlg, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
        {
        case WM_INITDIALOG:
            {
            RECT        rcOwner, rc;
            char        szGet[MAX_PATH];
            TCHAR       szPath[MAX_PATH], szRes[CCHMAX_STRINGRES], szRes2[CCHMAX_STRINGRES];
            DWORD       dwVerInfoSize, dwVerHnd;
            LPSTR       lpInfo, lpVersion, lpszT;
            LPWORD      lpwTrans;
            UINT        uLen;
            int         i,j, cItems = 0;
            LV_ITEM     lvi;
            LV_COLUMN   lvc;
            HWND        hwndList;
            HMODULE     hDll;
            LPTSTR      pszFileName;

            // If the caller passed an icon id in the LPARAM, use it
            // SendDlgItemMessage(hdlg, idcStatic1, STM_SETICON, 
            //                   (WPARAM) LoadIcon(g_hLocRes, MAKEINTRESOURCE(lp)), 0);

            // center dialog
            GetWindowRect(GetWindowOwner(hdlg), &rcOwner);
            GetWindowRect(hdlg, &rc);
            SetWindowPos(hdlg, 
                         NULL, 
                         (rcOwner.left+rcOwner.right-(rc.right-rc.left))/2, 
                         (rcOwner.top+rcOwner.bottom-(rc.bottom-rc.top))/2,
                         0, 
                         0, 
                         SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);

            // Do some groovy color things
            COLORMAP cm[] = 
            {
                { RGB(255, 0, 255), GetSysColor(COLOR_BTNFACE) }
            };

            HBITMAP hbm;
            hbm = CreateMappedBitmap(g_hLocRes, idbOELogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_OE_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);

            hbm = CreateMappedBitmap(g_hLocRes, idbWindowsLogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_WINDOWS_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);


            // Load some descriptive text for the build (Beta X)
            //AthLoadString(idsBeta2BuildStr, szRes, ARRAYSIZE(szRes));

            // Get version information from our .exe stub
            if (GetExePath(c_szMainExe, szPath, sizeof(szPath), FALSE))
                {
                if (dwVerInfoSize = GetFileVersionInfoSize(szPath, &dwVerHnd))
                    {
                    if (lpInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
                        {
                        if (GetFileVersionInfo(szPath, dwVerHnd, dwVerInfoSize, lpInfo))
                            {
                            if (VerQueryValue(lpInfo, "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) &&
                                uLen >= (2 * sizeof(WORD)))
                                {
                                // set up buffer for calls to VerQueryValue()
                                wsprintf(szGet, "\\StringFileInfo\\%04X%04X\\", lpwTrans[0], lpwTrans[1]);
                                lpszT = szGet + lstrlen(szGet);    
                                // Walk through the dialog items that we want to replace:
                                for (i = IDC_VERSION_STAMP; i <= IDC_MICROSOFT_COPYRIGHT; i++) 
                                    {
                                    j = i - IDC_VERSION_STAMP;
                                    lstrcpy(lpszT, rgszVer[j]);
                                    if (VerQueryValue(lpInfo, szGet, (LPVOID *)&lpVersion, &uLen) && uLen)
                                        {
                                        // DON'T overwrite their lpVersion buffer
                                        lstrcpyn(szRes2, lpVersion, ARRAYSIZE(szRes2));

                                        // Special case, append string explaining build number
#ifdef DEBUG
                                        if (0 == j)
                                            lstrcat(szRes2, " [DEBUG]");
#endif
#if defined(RELEASE_BETA)
                                        if (1 == j)
                                            lstrcat(szRes2, szRes);
#endif
                                        SetDlgItemText(hdlg, i, szRes2);

                                        }
                                    }
                                }
                            }
                        GlobalFree((HGLOBAL)lpInfo);
                        }
                    }
                }
            else
                AssertSz(FALSE, "Probable setup issue: Couldn't find our App Path");

            hwndList = GetDlgItem(hdlg, IDC_COMPONENT_LIST);

            // setup columns
            lvc.mask = LVCF_TEXT;
            lvc.pszText = szRes;
            lvc.iSubItem = 0;
            AthLoadString(idsFile, szRes, ARRAYSIZE(szRes));
            ListView_InsertColumn(hwndList, 0, &lvc);
            lvc.iSubItem = 1;
            AthLoadString(idsVersion, szRes, ARRAYSIZE(szRes));
            ListView_InsertColumn(hwndList, 1, &lvc);
            lvc.iSubItem = 2;
            AthLoadString(idsFullPath, szRes, ARRAYSIZE(szRes));
            ListView_InsertColumn(hwndList, 2, &lvc);
            
            lvi.mask = LVIF_TEXT;

            // Process each dll
            for (i=0; i<NUM_DLLS; i++)
                {

                // Always display the name
                lvi.iItem = cItems;
                lvi.iSubItem = 0;
                lvi.pszText = (LPTSTR)rgszDll[i];
                ListView_InsertItem(hwndList, &lvi);

                // Path Info
                if ((hDll = GetModuleHandle(rgszDll[i])) && (GetModuleFileName(hDll, szPath, MAX_PATH)))
                    pszFileName = lvi.pszText = szPath;
                else
                    {
                    pszFileName = lvi.pszText = (LPTSTR)rgszDll[i];
                    }
                lvi.iSubItem = 2;
                ListView_SetItem(hwndList, &lvi);                

                // Version Info
                szRes[0] = NULL;

                if (dwVerInfoSize = GetFileVersionInfoSize(pszFileName, &dwVerHnd))
                    {
                    if (lpInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
                        {
                        if (GetFileVersionInfo((LPTSTR)pszFileName, dwVerHnd, dwVerInfoSize, lpInfo))
                            {
                            if (VerQueryValue(lpInfo, "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) && 
                                uLen >= (2 * sizeof(WORD)))
                                {
                                // set up buffer for calls to VerQueryValue()
                                wsprintf(szGet, "\\StringFileInfo\\%04X%04X\\FileVersion", lpwTrans[0], lpwTrans[1]);
                                if (VerQueryValue(lpInfo, szGet, (LPVOID *)&lpVersion, &uLen) && uLen)
                                    {
                                    lstrcpyn(szRes, lpVersion, ARRAYSIZE(szRes));
                                    }
                                }
                            }
                        GlobalFree((HGLOBAL)lpInfo);
                        }
                    }

                // Version Info
                lvi.iSubItem = 1;
                if (NULL == szRes[0])
                    {
                    AthLoadString(idsUnknown, szRes, ARRAYSIZE(szRes));
                    }
                lvi.pszText = szRes;
                ListView_SetItem(hwndList, &lvi);
                
                cItems++;
                }

            if (cItems)
                {
                ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE);
                ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE);
                ListView_SetColumnWidth(hwndList, 2, LVSCW_AUTOSIZE);
                }            
            }
            break;

        case WM_COMMAND:
            if (GET_WM_COMMAND_ID(wp,lp) == IDOK || GET_WM_COMMAND_ID(wp,lp) == IDCANCEL)
                {
                EndDialog(hdlg, TRUE);
                return TRUE;
                }
            break;

        case WM_SYSCOLORCHANGE:
            {
            // Do some groovy color things
            COLORMAP cm[] = 
            {
                { RGB(255, 0, 255), GetSysColor(COLOR_BTNFACE) }
            };

            HBITMAP hbm;
            hbm = CreateMappedBitmap(g_hLocRes, idbOELogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_OE_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);

            hbm = CreateMappedBitmap(g_hLocRes, idbWindowsLogo, 0, cm, ARRAYSIZE(cm));
            if (hbm)
                SendDlgItemMessage(hdlg, IDC_WINDOWS_LOGO, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM) hbm);
            break;
            }
            
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\acctutil.h ===
// --------------------------------------------------------------------------------
// Acctutil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __ACCTUTIL_H
#define __ACCTUTIL_H

interface INotify;

// --------------------------------------------------------------------------------
// Depends On
// --------------------------------------------------------------------------------
#include "imnact.h"

// --------------------------------------------------------------------------------
// IImnAdviseAccount
// --------------------------------------------------------------------------------
class CImnAdviseAccount : public IImnAdviseAccount
{
private:
    ULONG               m_cRef;
    ULONG               m_cNNTP;

    INotify             *m_pNotify;

public:
    CImnAdviseAccount(void);
    ~CImnAdviseAccount(void);

    HRESULT Initialize(void);

    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP AdviseAccount(DWORD dwAdviseType, ACTX *pactx);

    void HandleAccountChange(ACCTTYPE AcctType, DWORD dwAN, LPTSTR pszAccount, LPTSTR pszOldName, DWORD dwServerTypes);
};

// -----------------------------------------------------------------------------
// Account Menu
// -----------------------------------------------------------------------------
typedef struct tagACCTMENU
{
    BOOL        fDefault,
                fThisAccount;
    UINT        uidm;
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME];

} ACCTMENU, *LPACCTMENU;

typedef enum tagACCOUNTMENUTYPE {
    ACCTMENU_SEND,
    ACCTMENU_SENDRECV,
    ACCTMENU_SENDLATER
} ACCOUNTMENUTYPE;

HRESULT AcctUtil_HrCreateAccountMenu(ACCOUNTMENUTYPE type, HMENU hPopup, UINT uidmPopup, 
    HMENU *phAccounts, LPACCTMENU *pprgMenu, ULONG *pcMenu, LPSTR pszThisAccount, BOOL fMail);

HRESULT HrConnectAccount(HWND hwnd, IImnAccount *pAccount);
HRESULT HrDisconnectAccount(HWND hwnd, BOOL fShutdown);
HRESULT AcctUtil_GetServerCount(DWORD dwSrvTypes, DWORD *pcSrv);

typedef struct tagNEWACCTINFO
{
    FOLDERTYPE type;
    LPSTR pszAcctId;
} NEWACCTINFO;

class CNewAcctMonitor 
    {
public:
    CNewAcctMonitor();
    ~CNewAcctMonitor();

    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    void OnAdvise(ACCTTYPE atType, DWORD dwNotify, LPCSTR pszAcctId);
    void StartMonitor(void);
    void StopMonitor(HWND hwndParent);

private:
    ULONG    m_cRef;
    BOOL     m_fMonitor;

    NEWACCTINFO *m_rgAccounts;
    ULONG    m_cAlloc;
    ULONG    m_cAccounts;
    };

extern CNewAcctMonitor *g_pNewAcctMonitor;


void CheckIMAPDirty(LPSTR pszAccountID, HWND hwndParent, FOLDERID idServer, DWORD dwFlags);
const DWORD CID_NOPROMPT    = 0x00000001; // For CheckIMAPDirty dwFlags: do not prompt to reset list
const DWORD CID_RESETLISTOK = 0x00000002; // For CheckIMAPDirty dwFlags: user gave permission to reset list

void DoAccountListDialog(HWND hwnd, ACCTTYPE type);
HRESULT AcctUtil_CreateSendReceieveMenu(HMENU hMenu, DWORD *pcItems);
HRESULT AcctUtil_FreeSendReceieveMenu(HMENU hMenu, DWORD cItems);
HRESULT AcctUtil_CreateAccountManagerForIdentity(GUID *puidIdentity, IImnAccountManager2 **ppAccountManager);
void InitNewAcctMenu(HMENU hmenu);
void FreeNewAcctMenu(HMENU hmenu);
HRESULT HandleNewAcctMenu(HWND hwnd, HMENU hmenu, int id);

#endif // __ACCTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\acctutil.cpp ===
// --------------------------------------------------------------------------------
// Acctutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "goptions.h"
#include "imnact.h"
#include "acctutil.h"
#include "strconst.h"
#include "error.h"
#include "resource.h"
#include <storfldr.h>
#include <notify.h>
#include "conman.h"
#include "shlwapip.h" 
#include "browser.h"
#include "instance.h"
#include "menures.h"
#include "subscr.h"
#include "msident.h"
#include "acctcach.h"
#include <demand.h>     // must be last!

CNewAcctMonitor *g_pNewAcctMonitor = NULL;

HRESULT IsValidSendAccount(LPSTR pszAccount);

CImnAdviseAccount::CImnAdviseAccount(void)
{
    m_cRef = 1;
    m_pNotify = NULL;
}

CImnAdviseAccount::~CImnAdviseAccount(void)
{
    if (m_pNotify != NULL)
        m_pNotify->Release();
}

HRESULT CImnAdviseAccount::Initialize()
    {
    HRESULT hr;

    hr = CreateNotify(&m_pNotify);
    if (SUCCEEDED(hr))
        hr = m_pNotify->Initialize((TCHAR *)c_szMailFolderNotify);

    return(hr);
    }

STDMETHODIMP CImnAdviseAccount::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TRAPHR(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

	// IID_IImnAccountManager
	if (IID_IImnAdviseAccount == riid)
		*ppv = (IImnAdviseAccount *)this;

    // IID_IUnknown
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;

    // If not null, addref it and return
    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TRAPHR(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

STDMETHODIMP_(ULONG) CImnAdviseAccount::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CImnAdviseAccount::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

STDMETHODIMP CImnAdviseAccount::AdviseAccount(DWORD dwAdviseType, ACTX *pactx)
{
    Assert(pactx != NULL);

    if (pactx->AcctType == ACCT_DIR_SERV)
        return(S_OK);

    if (g_pBrowser)
        g_pBrowser->AccountsChanged();

    if (dwAdviseType == AN_DEFAULT_CHANGED)
        return(S_OK);

    HandleAccountChange(pactx->AcctType, dwAdviseType, pactx->pszAccountID, pactx->pszOldName, pactx->dwServerType);
    if (g_pNewAcctMonitor != NULL)
        g_pNewAcctMonitor->OnAdvise(pactx->AcctType, dwAdviseType, pactx->pszAccountID);

    // No matter what the notification, we need to tell the connection manager
    if (g_pConMan)
        g_pConMan->AdviseAccount(dwAdviseType, pactx);

    return S_OK;
}

void CImnAdviseAccount::HandleAccountChange(ACCTTYPE AcctType, DWORD dwAN, LPTSTR pszID, LPTSTR pszOldName, DWORD dwSrvTypesOld)
    {
    HRESULT      hr;
    IImnAccount  *pAccount;
    char         szName[CCHMAX_ACCOUNT_NAME];
    FOLDERID     id;

    Assert(pszID != NULL);

    switch (dwAN)
    {
        case AN_ACCOUNT_DELETED:
            AccountCache_AccountDeleted(pszID);
            if (!!(dwSrvTypesOld & (SRV_IMAP | SRV_NNTP | SRV_HTTPMAIL)))
            {
                hr = g_pStore->FindServerId(pszID, &id);
                if (SUCCEEDED(hr))
                {
                    HCURSOR hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    hr = g_pStore->DeleteFolder(id, DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_NOTRASHCAN, (IStoreCallback *)g_pBrowser);
                    Assert(SUCCEEDED(hr));
                    SetCursor(hCursor);
                }
            }

            if (g_pBrowser != NULL)
                g_pBrowser->UpdateToolbar();
            break;

        case AN_ACCOUNT_ADDED:
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszID, &pAccount)))
            {
                hr = g_pStore->CreateServer(pAccount, NOFLAGS, &id);
                Assert(SUCCEEDED(hr));

                if (g_pBrowser != NULL)
                    g_pBrowser->UpdateToolbar();

                pAccount->Release();
            }
            break;

        case AN_ACCOUNT_CHANGED:
            AccountCache_AccountChanged(pszID);
            if (pszOldName != NULL)
            {
                hr = g_pStore->FindServerId(pszID, &id);
                if (SUCCEEDED(hr))
                {
                    if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszID, &pAccount)))
                    {
                        hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szName, ARRAYSIZE(szName));
                        Assert(SUCCEEDED(hr));

                        hr = g_pStore->RenameFolder(id, szName, NOFLAGS, NOSTORECALLBACK);
                        Assert(SUCCEEDED(hr));

                        pAccount->Release();
                    }
                }
            }
            break;
    }
}

// -----------------------------------------------------------------------------
// AcctUtil_HrCreateAccountMenu
// -----------------------------------------------------------------------------
#define CCHMAX_RES 255
HRESULT AcctUtil_HrCreateAccountMenu(ACCOUNTMENUTYPE type, HMENU hPopup, UINT uidmPopup, 
    HMENU *phAccounts, LPACCTMENU *pprgAccount, ULONG *pcAccounts, LPSTR pszThisAccount, BOOL fMail)
{
    // Locals
    HRESULT             hr=S_OK;
    ULONG               cAccounts=0;
    IImnEnumAccounts   *pEnum=NULL;
    IImnAccount        *pAccount=NULL;
    CHAR                szDefault[CCHMAX_ACCOUNT_NAME];
    CHAR                szAccount[CCHMAX_ACCOUNT_NAME];
    CHAR                szQuoted[CCHMAX_ACCOUNT_NAME + CCHMAX_ACCOUNT_NAME + CCHMAX_RES];
    LPACCTMENU          prgAccount=NULL;
    HMENU               hAccounts=NULL;
    MENUITEMINFO        mii;
    UINT                uPos=0;
    ULONG               iAccount=0;
    CHAR                szRes[CCHMAX_RES];
    CHAR                szRes1[CCHMAX_RES];
    CHAR                szRes2[CCHMAX_RES];
    UINT                idmFirst;
    CHAR                szTitle[CCHMAX_RES + CCHMAX_RES + CCHMAX_ACCOUNT_NAME];
    BOOL                fNeedUsingMenu = FALSE;

    // Check Parameters
    Assert(g_pAcctMan && phAccounts && pprgAccount && pcAccounts);

    // Init
    *szDefault = '\0';
    *pprgAccount = NULL;
    *pcAccounts = 0;
    *phAccounts = NULL;

    if (type == ACCTMENU_SENDLATER)
        idmFirst = ID_SEND_LATER_ACCOUNT_FIRST;
    else
        idmFirst = ID_SEND_NOW_ACCOUNT_FIRST;

    // Verify Default SMTP Account
    CHECKHR(hr = g_pAcctMan->ValidateDefaultSendAccount());

    // Get the default
    CHECKHR(hr = hr = g_pAcctMan->GetDefaultAccountName(ACCT_MAIL, szDefault, ARRAYSIZE(szDefault)));

    // Enumerate through the server types
    CHECKHR(hr = g_pAcctMan->Enumerate(((ACCTMENU_SEND == type || ACCTMENU_SENDLATER == type) ? SRV_SMTP : SRV_SMTP | SRV_POP3), &pEnum));

    // sort the accoutns
    CHECKHR(hr = pEnum->SortByAccountName());

    // Get Count
    CHECKHR(hr = pEnum->GetCount(&cAccounts));

    // No Accounts
    if (cAccounts == 0)
        goto exit;

    // Exceeded menu ids...
    Assert(cAccounts <= 50);

    // Add one if ACCTMENU_SENDRECV
    if (ACCTMENU_SENDRECV == type)
        cAccounts++;

    // Allocate prgAccount
    CHECKALLOC(prgAccount = (LPACCTMENU)g_pMalloc->Alloc(cAccounts * sizeof(ACCTMENU)));

    // Zero Init
    ZeroMemory(prgAccount, cAccounts * sizeof(ACCTMENU));

    // Only one account
    if (((ACCTMENU_SENDRECV == type) && (cAccounts == 2)) ||
        (cAccounts == 1) || !fMail)
    {
        // Return default Account
        prgAccount[iAccount].fDefault = TRUE;
        prgAccount[iAccount].fThisAccount = TRUE;
        lstrcpy(prgAccount[iAccount].szAccount, szDefault);

        // Return Everything
        *pprgAccount = prgAccount;
        prgAccount = NULL;
        *pcAccounts = cAccounts;

        // Done
        goto exit;
    }

    // Create a Menu
    CHECKALLOC(hAccounts = CreatePopupMenu());

    // if not using a specific account or the account is illegal, then let's default to the default-account
    if (pszThisAccount==NULL || *pszThisAccount == NULL || IsValidSendAccount(pszThisAccount)!=S_OK)
        pszThisAccount = szDefault;

    // Lets insert the default item
    if ((ACCTMENU_SENDLATER == type || ACCTMENU_SEND == type) && !FIsEmptyA(szDefault))
    {
        lstrcpy(szTitle, pszThisAccount);

        prgAccount[iAccount].fDefault = lstrcmpi(pszThisAccount, szDefault)==0;

        // if this is the default, flag it.
        if (prgAccount[iAccount].fDefault)
            {
            AthLoadString(idsDefaultAccount, szRes1, ARRAYSIZE(szRes1));
            lstrcat(szTitle, " ");
            lstrcat(szTitle, szRes1);
            }

        if (((ACCTMENU_SEND == type && DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline()) ||
           (ACCTMENU_SENDLATER == type && (!DwGetOption(OPT_SENDIMMEDIATE) || g_pConMan->IsGlobalOffline()))))
            {
            // if this menu is the default action add the 'Alt+S' accelerator string
            AthLoadString(idsSendMsgAccelTip, szRes, ARRAYSIZE(szRes));
            lstrcat(szTitle, "\t");
            lstrcat(szTitle, szRes);
            }

        // Get mii ready
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_DEFAULT;       // first item is the default verb
        mii.dwTypeData = PszEscapeMenuStringA(szTitle, szQuoted, sizeof(szQuoted) / sizeof(char));
        mii.cch = lstrlen(szQuoted);
        mii.wID = idmFirst + uPos;

        // Set acctmenu item
        prgAccount[iAccount].fThisAccount= TRUE;
        prgAccount[iAccount].uidm = mii.wID;
        lstrcpyn(prgAccount[iAccount].szAccount, pszThisAccount, CCHMAX_ACCOUNT_NAME);
        iAccount++;

        // Insert the item
        if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
        {
            uPos++;
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;
            if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
                uPos++;
        }
    }

    // Otherwise Send & Receive
    else if (ACCTMENU_SENDRECV == type)
    {
        // Setup Menu
        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_DEFAULT;
        AthLoadString(idsPollAllAccounts, szRes, ARRAYSIZE(szRes));
        mii.dwTypeData = szRes;
        mii.cch = lstrlen(szRes);
        mii.wID = idmFirst + uPos;

        // Set acctmenu item
        prgAccount[iAccount].fDefault = TRUE;
        prgAccount[iAccount].uidm = mii.wID;
        *prgAccount[iAccount].szAccount = '\0';
        iAccount++;

        // Insert the item
        if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
        {
            uPos++;
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;
            if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
                uPos++;
        }
    }

    // Standard
    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID;
    mii.fType = MFT_STRING;

    // Loop accounts
    while(SUCCEEDED(pEnum->GetNext(&pAccount)))
    {
        // Get Account Name
        CHECKHR(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, ARRAYSIZE(szAccount)));

        // Skip the 'This' account. Note for the send & receive menu this will always be the default
        if (lstrcmpi(pszThisAccount, szAccount) == 0)
        {
            // We've already added this account
            if (ACCTMENU_SEND == type || ACCTMENU_SENDLATER == type)
            {
                SafeRelease(pAccount);
                continue;
            }

            // Otherwise, Account (Default)
            else
            {
                // for send a recieve menu pszThisAccount should == szDefault
                Assert (pszThisAccount == szDefault);
                // Load String
                AthLoadString(idsDefaultAccount, szRes, ARRAYSIZE(szRes));

                // Make String - Saranac (Default)
                wsprintf(szTitle, "%s %s", szAccount, szRes);

                // Setup the menu item name
                mii.dwTypeData = PszEscapeMenuStringA(szTitle, szQuoted, sizeof(szQuoted) / sizeof(char));
                mii.cch = lstrlen(szQuoted);
                prgAccount[iAccount].fDefault = TRUE;
            }
        }

        else
        {
            *szTitle=0;

            // this might be the default
            prgAccount[iAccount].fDefault = lstrcmpi(szAccount, szDefault)==0;

            // build the string on the fly as any one of these accounts might be the 'default'
            PszEscapeMenuStringA(szAccount, szTitle, sizeof(szTitle) / sizeof(char));

            // if this is the default, flag it.
            if (prgAccount[iAccount].fDefault)
                {
                AthLoadString(idsDefaultAccount, szRes1, ARRAYSIZE(szRes1));
                lstrcat(szTitle, " ");
                lstrcat(szTitle, szRes1);
                }


            // Setup the menu item name
            mii.dwTypeData = szTitle;
            mii.cch = lstrlen(szTitle);
        }

        // Insert into menu
        mii.wID = idmFirst + uPos;
        if (InsertMenuItem(hAccounts, uPos, TRUE, &mii))
            uPos++;

        // Set acctmenu item
        Assert(iAccount < cAccounts);
        prgAccount[iAccount].uidm = mii.wID;
        lstrcpy(prgAccount[iAccount].szAccount, szAccount);
        iAccount++;

        // Release Account
        SafeRelease(pAccount);
    }

    // Return Everything
    *phAccounts = hAccounts;
    hAccounts = NULL;
    *pprgAccount = prgAccount;
    prgAccount = NULL;
    *pcAccounts = cAccounts;

exit:
    // Lets Setup the Accounts Menu
    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(MENUITEMINFO);
    fNeedUsingMenu = (cAccounts <= 1) || !fMail;
    if (ACCTMENU_SEND == type)
    {
        mii.fMask = MIIM_SUBMENU | MIIM_TYPE;

        if (fNeedUsingMenu)
            {
            AthLoadString(idsSendMsgOneAccount, szRes, ARRAYSIZE(szRes));
            AthLoadString(idsSendMsgAccelTip, szRes1, ARRAYSIZE(szRes1));
        
            // If send now is default, add the Alt + S at the end
            if (DwGetOption(OPT_SENDIMMEDIATE) && !g_pConMan->IsGlobalOffline())
                wsprintf(szTitle, "%s\t%s", szRes, szRes1);
            else
                lstrcpy(szTitle, szRes);
            }
        else
            AthLoadString(idsSendMsgUsing, szTitle, ARRAYSIZE(szTitle));

        mii.fType = MFT_STRING;
        mii.dwTypeData = szTitle;
        mii.cch = lstrlen(szTitle);
        mii.hSubMenu = fNeedUsingMenu ? NULL : *phAccounts;
    }
    else if (ACCTMENU_SENDLATER == type)
    {
        if (fNeedUsingMenu)
            {
            AthLoadString(idsSendLaterOneAccount, szRes, ARRAYSIZE(szRes));
            AthLoadString(idsSendMsgAccelTip, szRes1, ARRAYSIZE(szRes1));
        
            // If send now is default, add the Alt + S at the end
            if (!DwGetOption(OPT_SENDIMMEDIATE) || g_pConMan->IsGlobalOffline())
                wsprintf(szTitle, "%s\t%s", szRes, szRes1);
            else
                lstrcpy(szTitle, szRes);
            }
        else
            AthLoadString(idsSendLaterUsing, szTitle, ARRAYSIZE(szTitle));

        mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szTitle;
        mii.cch = lstrlen(szTitle);
        mii.hSubMenu = fNeedUsingMenu ? NULL : *phAccounts;
    }
    else
    {
        mii.fMask = MIIM_SUBMENU | MIIM_TYPE;
        AthLoadString(fNeedUsingMenu ? idsSendRecvOneAccount : idsSendRecvUsing, szRes, ARRAYSIZE(szRes));
        mii.fType = MFT_STRING;
        mii.dwTypeData = szRes;
        mii.cch = lstrlen(szRes);
        mii.hSubMenu = fNeedUsingMenu ? NULL : *phAccounts;
    }

    // Set the menu item
    SideAssert(SetMenuItemInfo(hPopup, uidmPopup, FALSE, &mii));

    // Cleanup
    SafeRelease(pEnum);
    SafeRelease(pAccount);
    SafeMemFree(prgAccount);
    if (hAccounts)
        DestroyMenu(hAccounts);

    // Done
    return hr;
}

HRESULT AcctUtil_GetServerCount(DWORD dwSrvTypes, DWORD *pcSrv)
{
    HRESULT hr;
    IImnEnumAccounts *pEnum;

    Assert(dwSrvTypes != 0);
    Assert(pcSrv != NULL);

    hr = g_pAcctMan->Enumerate(dwSrvTypes, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->GetCount(pcSrv);
        Assert(SUCCEEDED(hr));

        pEnum->Release();
    }

    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
// CNewAcctMonitor
//

CNewAcctMonitor::CNewAcctMonitor()
    {
    m_cRef = 1;
    m_rgAccounts = NULL;
    m_cAlloc = 0;
    m_cAccounts = 0;
    m_fMonitor = FALSE;
    }

CNewAcctMonitor::~CNewAcctMonitor()
    {
    Assert(m_rgAccounts == NULL);
    }

ULONG CNewAcctMonitor::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CNewAcctMonitor::Release(void)
    {
    ULONG cRefT = --m_cRef;

    if (0 == m_cRef)
        delete this;

    return (cRefT);
    }

void CNewAcctMonitor::OnAdvise(ACCTTYPE atType, DWORD dwNotify, LPCSTR pszAcctId)
    {
    UINT i;
    IImnAccount *pAccount;
    DWORD dwSrvTypes;
    HRESULT hr;
    FOLDERTYPE type;

    if (atType == ACCT_DIR_SERV)
        return;

    switch (dwNotify)
        {
        case AN_ACCOUNT_ADDED:
            if (atType == ACCT_MAIL)
            {
                if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAcctId, &pAccount)))
                    break;

                hr = pAccount->GetServerTypes(&dwSrvTypes);
                Assert(SUCCEEDED(hr));

                pAccount->Release();

                if (!!(dwSrvTypes & SRV_IMAP))
                    type = FOLDER_IMAP;
                else if (!!(dwSrvTypes & SRV_HTTPMAIL))
                    type = FOLDER_HTTPMAIL;
                else
                    break;
            }
            else
            {
                Assert(atType == ACCT_NEWS);
                type = FOLDER_NEWS;
            }

            // Check to see if we need to grow our array
            if ((1 + m_cAccounts) >= m_cAlloc)
                {                
                if (!MemRealloc((LPVOID *)&m_rgAccounts, sizeof(NEWACCTINFO) * (10 + m_cAlloc)))
                    break;

                m_cAlloc += 10;
                }

            m_rgAccounts[m_cAccounts].pszAcctId = PszDupA(pszAcctId);
            m_rgAccounts[m_cAccounts].type = type;
            m_cAccounts++;
            break; 

        case AN_ACCOUNT_DELETED:
            // Check to see if we've already added this to our list.
            for (i = 0; i < m_cAccounts; i++)
                {
                if (0 == lstrcmpi(pszAcctId, m_rgAccounts[i].pszAcctId))
                    {
                    // We found it.  We need to remove it, and adjust our array
                    MemFree(m_rgAccounts[i].pszAcctId);
                    m_cAccounts--;
                    for (; i < m_cAccounts; i++)
                        m_rgAccounts[i] = m_rgAccounts[i + 1];
                    break;
                    }
                }
            break;
        }
    }

void CNewAcctMonitor::StartMonitor(void)
    {
    Assert(m_rgAccounts == NULL);
    Assert(m_cAccounts == NULL);
    Assert(m_fMonitor == FALSE);

    m_fMonitor = TRUE;
    }

void CNewAcctMonitor::StopMonitor(HWND hwndParent)
    {
    FOLDERID id;
    HRESULT hr;
    UINT i;

    Assert(m_fMonitor == TRUE);

    // If we have any new newsgroups left, ask if the user want's to display
    // the subscription dialog.
    if (m_cAccounts != 0)
    {
        int     ResId;
        BOOL    fOffline = (g_pConMan  && g_pConMan->IsGlobalOffline());

        if (m_rgAccounts[0].type == FOLDER_NEWS)
        {
            ResId = fOffline ? idsDisplayNewsSubDlgOffline : idsDisplayNewsSubDlg;
        }
        else
        {
            ResId = fOffline ? idsDisplayImapSubDlgOffline : idsDisplayImapSubDlg;
        }

        if (IDYES == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(ResId), 0, MB_ICONEXCLAMATION  | MB_YESNO))
        {
            hr = g_pStore->FindServerId(m_rgAccounts[0].pszAcctId, &id);
            if (SUCCEEDED(hr))
            {
                if (fOffline)
                    g_pConMan->SetGlobalOffline(FALSE);

                if (FOLDER_HTTPMAIL == m_rgAccounts[0].type)
                    DownloadNewsgroupList(hwndParent, id);
                else
                    DoSubscriptionDialog(hwndParent, m_rgAccounts[0].type == FOLDER_NEWS, id);
            }
        }
    }   

    for (i = 0; i < m_cAccounts; i++)
    {
        if (m_rgAccounts[i].pszAcctId != NULL)
            MemFree(m_rgAccounts[i].pszAcctId);
    }
    m_cAccounts = 0;
    m_cAlloc = 0;

    SafeMemFree(m_rgAccounts);
    m_fMonitor = FALSE;
    }


void CheckIMAPDirty(LPSTR pszAccountID, HWND hwndParent, FOLDERID idServer,
                    DWORD dwFlags)
{
    HRESULT         hr;
    IImnAccount    *pAcct = NULL;
    DWORD           dw;

    TraceCall("CheckIMAPDirty");

    hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccountID, &pAcct);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    hr = pAcct->GetPropDw(AP_IMAP_DIRTY, &dw);
    if (FAILED(hr) || 0 == dw)
    {
        TraceError(hr);
        goto exit;
    }

    // IMAP is dirty, deal with each dirty flag
    if ((dw & IMAP_OE4MIGRATE_DIRTY) && FOLDERID_INVALID != idServer && NULL != g_pStore)
    {
        IEnumerateFolders  *pEnum;
        BOOL                fSentItems = FALSE;
        BOOL                fDrafts = FALSE;
        BOOL                fInbox = FALSE;

        Assert(0 == (dw & IMAP_OE4MIGRATE_DIRTY) || (dw & IMAP_FLDRLIST_DIRTY));

        // We may or may not be dirty. Check if all IMAP special fldrs already present
        hr = g_pStore->EnumChildren(idServer, FALSE, &pEnum);
        TraceError(hr);
        if (SUCCEEDED(hr))
        {
            FOLDERINFO  fiFolderInfo;

            while (S_OK == pEnum->Next(1, &fiFolderInfo, NULL))
            {
                switch (fiFolderInfo.tySpecial)
                {
                    case FOLDER_INBOX:
                        fInbox = TRUE;
                        break;

                    case FOLDER_SENT:
                        fSentItems = TRUE;
                        break;

                    case FOLDER_DRAFT:
                        fDrafts = TRUE;
                        break;
                }

                g_pStore->FreeRecord(&fiFolderInfo);
            }

            pEnum->Release();
        }

        if (fInbox && fSentItems && fDrafts)
        {
            // All special folders present: remove dirty flags
            dw &= ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY);
        }
    }


    if (dw & IMAP_FLDRLIST_DIRTY)
    {
        int     iResult;

        // Ask user if he would like to reset his folderlist
        if (0 == (dwFlags & CID_NOPROMPT))
        {
            UINT    uiReasonStrID;

            AssertSz(0 == (dwFlags & CID_RESETLISTOK), "If I have permission to reset, why prompt?");

            // Figure out why we are asking to refresh the folderlist
            if (dw & IMAP_OE4MIGRATE_DIRTY)
                uiReasonStrID = idsOE5IMAPSpecialFldrs;
            else
                uiReasonStrID = idsYouMadeChanges;

            iResult = AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena),
                MAKEINTRESOURCEW(uiReasonStrID), MAKEINTRESOURCEW(idsRefreshFolderListPrompt),
                MB_ICONEXCLAMATION  | MB_YESNO);
        }
        else
            iResult = (dwFlags & CID_RESETLISTOK) ? IDYES : IDNO;

        if (IDYES == iResult)
        {
            if (FOLDERID_INVALID == idServer)
            {
                hr = g_pStore->FindServerId(pszAccountID, &idServer);
                TraceError(hr);
            }

            if (FOLDERID_INVALID != idServer)
            {
                //The user wants to download the list of newsgroups, so if we are offline, go online
                if (g_pConMan)
                    g_pConMan->SetGlobalOffline(FALSE);

                hr = DownloadNewsgroupList(hwndParent, idServer);
                TraceError(hr);
                if (SUCCEEDED(hr))
                {
                    // The sent items and drafts folders should not be dirty any longer
                    dw &= ~(IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);
                }
            }
        }

        // Regardless of yes or no, reset dirty flag
        dw &= ~(IMAP_FLDRLIST_DIRTY | IMAP_OE4MIGRATE_DIRTY);
    }


    if (dw & (IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY))
    {
        IEnumerateFolders  *pEnum;
        char                szSentItems[MAX_PATH];
        char                szDrafts[MAX_PATH];
        DWORD               dwIMAPSpecial = 0;
        BOOL                fSetSentItems = FALSE;
        BOOL                fSetDrafts = FALSE;

        // Remove all affected special folder types from cache. If new path is
        // found in folderlist, set its special folder type
        szSentItems[0] = '\0';
        szDrafts[0] = '\0';
        hr = pAcct->GetPropDw(AP_IMAP_SVRSPECIALFLDRS, &dwIMAPSpecial);
        if (SUCCEEDED(hr) && dwIMAPSpecial)
        {
            if (dw & IMAP_SENTITEMS_DIRTY)
            {
                hr = pAcct->GetPropSz(AP_IMAP_SENTITEMSFLDR, szSentItems, ARRAYSIZE(szSentItems));
                TraceError(hr);
            }

            if (dw & IMAP_DRAFTS_DIRTY)
            {
                hr = pAcct->GetPropSz(AP_IMAP_DRAFTSFLDR, szDrafts, ARRAYSIZE(szDrafts));
                TraceError(hr);
            }
        }

        hr = g_pStore->EnumChildren(idServer, FALSE, &pEnum);
        TraceError(hr);
        if (SUCCEEDED(hr))
        {
            FOLDERINFO  fiFolderInfo;

            while (S_OK == pEnum->Next(1, &fiFolderInfo, NULL))
            {
                BOOL    fUpdate = FALSE;

                if (dw & IMAP_SENTITEMS_DIRTY)
                {
                    if (0 == lstrcmp(szSentItems, fiFolderInfo.pszName))
                    {
                        fiFolderInfo.tySpecial = FOLDER_SENT;
                        fUpdate = TRUE;
                        fSetSentItems = TRUE;

                        // IE5 Bug #62765: if new special folder is unsubscribed, we need to subscribe it
                        if (0 == (fiFolderInfo.dwFlags & FOLDER_SUBSCRIBED))
                            fiFolderInfo.dwFlags |= FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
                    }
                    else if (FOLDER_SENT == fiFolderInfo.tySpecial)
                    {
                        // Ignore FOLDER_HIDDEN. I'm assuming it's no big deal to leave a tombstone
                        fiFolderInfo.tySpecial = FOLDER_NOTSPECIAL;
                        fUpdate = TRUE;
                    }
                }

                if (dw & IMAP_DRAFTS_DIRTY)
                {
                    if (0 == lstrcmp(szDrafts, fiFolderInfo.pszName))
                    {
                        fiFolderInfo.tySpecial = FOLDER_DRAFT;
                        fUpdate = TRUE;
                        fSetDrafts = TRUE;

                        // IE5 Bug #62765: if new special folder exists and is unsubscribed, we must subscribe it
                        if (0 == (fiFolderInfo.dwFlags & FOLDER_SUBSCRIBED))
                            fiFolderInfo.dwFlags |= FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
                    }
                    else if (FOLDER_DRAFT == fiFolderInfo.tySpecial)
                    {
                        // Ignore FOLDER_HIDDEN. I'm assuming it's no big deal to leave a tombstone
                        fiFolderInfo.tySpecial = FOLDER_NOTSPECIAL;
                        fUpdate = TRUE;
                    }
                }

                if (fUpdate)
                {
                    hr = g_pStore->UpdateRecord(&fiFolderInfo);
                    TraceError(hr);
                }

                g_pStore->FreeRecord(&fiFolderInfo);
            } // while

            pEnum->Release();
        } // if (SUCCEEDED(EnumChildren))

        // If the new special folder path(s) not found in folderlist, need to create placeholder folder
        if (dwIMAPSpecial && (dw & IMAP_SENTITEMS_DIRTY) && FALSE == fSetSentItems && '\0' != szSentItems[0])
        {
            FOLDERINFO fiFolderInfo;
            BOOL       bHierarchy = 0xFF; // Invalid hierarchy char

            hr = g_pStore->GetFolderInfo(idServer, &fiFolderInfo);
            if (SUCCEEDED(hr))
            {
                bHierarchy = fiFolderInfo.bHierarchy;
                g_pStore->FreeRecord(&fiFolderInfo);
            }

            ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));
            fiFolderInfo.idParent = idServer;
            fiFolderInfo.pszName = szSentItems;
            fiFolderInfo.dwFlags = FOLDER_HIDDEN | FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
            fiFolderInfo.tySpecial = FOLDER_SENT;
            fiFolderInfo.tyFolder = FOLDER_IMAP;
            fiFolderInfo.bHierarchy = (BYTE)bHierarchy;

            hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &fiFolderInfo, NULL);
            TraceError(hr);
        }

        if (dwIMAPSpecial && (dw & IMAP_DRAFTS_DIRTY) && FALSE == fSetDrafts && '\0' != szDrafts[0])
        {
            FOLDERINFO fiFolderInfo;
            BOOL       bHierarchy = 0xFF; // Invalid hierarchy char

            hr = g_pStore->GetFolderInfo(idServer, &fiFolderInfo);
            if (SUCCEEDED(hr))
            {
                bHierarchy = fiFolderInfo.bHierarchy;
                g_pStore->FreeRecord(&fiFolderInfo);
            }

            ZeroMemory(&fiFolderInfo, sizeof(fiFolderInfo));
            fiFolderInfo.idParent = idServer;
            fiFolderInfo.pszName = szDrafts;
            fiFolderInfo.dwFlags = FOLDER_HIDDEN | FOLDER_SUBSCRIBED | FOLDER_CREATEONDEMAND;
            fiFolderInfo.tySpecial = FOLDER_DRAFT;
            fiFolderInfo.tyFolder = FOLDER_IMAP;
            fiFolderInfo.bHierarchy = (BYTE)bHierarchy;

            hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &fiFolderInfo, NULL);
            TraceError(hr);
        }

        // Regardless of error, reset dirty flag
        dw &= ~(IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY);

    } // if (dw & (IMAP_SENTITEMS_DIRTY | IMAP_DRAFTS_DIRTY))

    AssertSz(0 == dw, "Unhandled IMAP dirty flag");

    // Reset IMAP dirty property
    hr = pAcct->SetPropDw(AP_IMAP_DIRTY, dw);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

    // Save changes
    hr = pAcct->SaveChanges();
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto exit;
    }

exit:
    if (NULL != pAcct)
        pAcct->Release();
}


void CheckAllIMAPDirty(HWND hwndParent)
{
    HRESULT             hrResult;
    IImnEnumAccounts   *pAcctEnum = NULL;
    IImnAccount        *pAcct = NULL;
    BOOL                fPromptedUser = FALSE;
    BOOL                fPermissionToReset = FALSE;

    TraceCall("CheckAllIMAPDirty");

    if (NULL == g_pAcctMan)
        return;

    hrResult = g_pAcctMan->Enumerate(SRV_IMAP, &pAcctEnum);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Enumerate through ALL IMAP accounts (even if user denied permission to reset list)
    hrResult = pAcctEnum->GetNext(&pAcct);
    while(SUCCEEDED(hrResult))
    {
        DWORD       dwIMAPDirty;

        // Is this IMAP account dirty?
        hrResult = pAcct->GetPropDw(AP_IMAP_DIRTY, &dwIMAPDirty);
        if (FAILED(hrResult))
            dwIMAPDirty = 0;

        if (dwIMAPDirty & IMAP_FLDRLIST_DIRTY)
        {
            // Prompt user only once to see if he would like to refresh folder list
            if (FALSE == fPromptedUser)
            {
                int iResult;

                iResult = AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsYouMadeChangesOneOrMore),
                    MAKEINTRESOURCEW(idsRefreshFolderListPrompt),
                    MB_ICONEXCLAMATION | MB_YESNO);
                if (IDYES == iResult)
                    fPermissionToReset = TRUE;

                fPromptedUser = TRUE;
            } // if (FALSE == fPromptedUser)

        }

        if (dwIMAPDirty)
        {
            FOLDERID    idServer;
            char        szAccountID[CCHMAX_ACCOUNT_NAME];

            hrResult = pAcct->GetPropSz(AP_ACCOUNT_ID, szAccountID, ARRAYSIZE(szAccountID));
            TraceError(hrResult);
            if (SUCCEEDED(hrResult))
            {
                hrResult = g_pStore->FindServerId(szAccountID, &idServer);
                TraceError(hrResult);
                if (SUCCEEDED(hrResult))
                {
                    CheckIMAPDirty(szAccountID, hwndParent, idServer,
                        CID_NOPROMPT | (fPermissionToReset ? CID_RESETLISTOK : 0));
                }
            }
        }

        // Load in the next IMAP account
        SafeRelease(pAcct);
        hrResult = pAcctEnum->GetNext(&pAcct);

    } // while

exit:
    SafeRelease(pAcctEnum);
    SafeRelease(pAcct);
}



void DoAccountListDialog(HWND hwnd, ACCTTYPE type)
    {
    ACCTLISTINFO ali;

    // Create the monitor
    if (NULL == g_pNewAcctMonitor)
        g_pNewAcctMonitor = new CNewAcctMonitor();

    if (g_pNewAcctMonitor)
        g_pNewAcctMonitor->StartMonitor();

    Assert(g_pAcctMan != NULL);

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = type;

    if (g_dwAthenaMode & MODE_NEWSONLY)
        ali.dwAcctFlags = ACCT_FLAG_NEWS | ACCT_FLAG_DIR_SERV;
    else if (g_dwAthenaMode & MODE_MAILONLY)
        ali.dwAcctFlags = ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV;
    else
        ali.dwAcctFlags = ACCT_FLAG_ALL;

    ali.dwFlags = ACCTDLG_SHOWIMAPSPECIAL | ACCTDLG_OE;

    //Account wizard uses this flag to distinguish between OE and outlook.
    ali.dwFlags |= (ACCTDLG_INTERNETCONNECTION | ACCTDLG_HTTPMAIL);

    // Revocation checking flag
    if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline())
        ali.dwFlags |= ACCTDLG_REVOCATION;

    g_pAcctMan->AccountListDialog(hwnd, &ali);

    if (g_pNewAcctMonitor)
        {
        g_pNewAcctMonitor->StopMonitor(hwnd);
        g_pNewAcctMonitor->Release();
        g_pNewAcctMonitor = 0;
        }

    // Look for any dirty IMAP accounts
    CheckAllIMAPDirty(hwnd);
    }

HRESULT IsValidSendAccount(LPSTR pszAccount)
{
    IImnAccount  *pAccount;
    DWORD        dwSrvTypes=0;

    if (g_pAcctMan &&
        g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszAccount, &pAccount)==S_OK)
        {
        pAccount->GetServerTypes(&dwSrvTypes);
        pAccount->Release();
        return dwSrvTypes & SRV_SMTP ? S_OK : S_FALSE;
        }

    return S_FALSE;
}


HRESULT AcctUtil_CreateSendReceieveMenu(HMENU hMenu, DWORD *pcItems)
{
    IImnAccount        *pAccount;
    TCHAR               szDefaultAccount[CCHMAX_ACCOUNT_NAME];
    HRESULT             hr;
    IImnEnumAccounts   *pEnum;
    DWORD               cAccounts = 0;
    TCHAR               szTitle[CCHMAX_ACCOUNT_NAME + 30];
    TCHAR               szAccountQuoted[CCHMAX_ACCOUNT_NAME + 60];
    TCHAR               szDefaultString[CCHMAX_STRINGRES];
    TCHAR               szAccount[CCHMAX_ACCOUNT_NAME];
    TCHAR               szTruncAcct[128];
    MENUITEMINFO        mii;
    DWORD               iAccount = 0;
    LPTSTR              pszAccount;
    LPSTR               pszAcctID;
    
    // Get the default account's ID.  If this fails we just go on.
    if (SUCCEEDED(hr = g_pAcctMan->GetDefaultAccount(ACCT_MAIL, &pAccount)))
    {
        // Get the account ID from the default account
        pAccount->GetPropSz(AP_ACCOUNT_NAME, szDefaultAccount, ARRAYSIZE(szDefaultAccount));
        pAccount->Release();
    }

    if (!(g_dwAthenaMode & MODE_NEWSONLY))
    {
        // Enumerate through the servers
        if (SUCCEEDED(hr = g_pAcctMan->Enumerate(SRV_SMTP | SRV_POP3 | SRV_HTTPMAIL, &pEnum)))
        {
            // Sort the accounts.  If this fails, we just go on.
            pEnum->SortByAccountName();

            // Get the number of accounts we'll be enumerating
            if (SUCCEEDED(hr = pEnum->GetCount(&cAccounts)))
            {
                // If there are zero accounts, there's nothing to do.
                if (0 != cAccounts)
                {
                    // Make sure we have enough ID's reserved for this
                    Assert(cAccounts < ID_ACCOUNT_LAST - ID_ACCOUNT_FIRST);

                    // Set this struct up before we start
                    ZeroMemory(&mii, sizeof(MENUITEMINFO));
                    mii.cbSize = sizeof(MENUITEMINFO);
                    mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;

                    // Loop through the accounts
                    while (SUCCEEDED(pEnum->GetNext(&pAccount)))
                    {
                        if (MemAlloc((LPVOID *) &pszAcctID, sizeof(TCHAR) * CCHMAX_ACCOUNT_NAME))
                        {
                            // Get the name of the account
                            pAccount->GetPropSz(AP_ACCOUNT_NAME, szAccount, CCHMAX_ACCOUNT_NAME);
                            pAccount->GetPropSz(AP_ACCOUNT_ID, pszAcctID, CCHMAX_ACCOUNT_NAME);

                            // If this account is the default account, we need to append
                            // "(Default)" to the end.  Limit the string to 80 since Win95 seems 
                            // to have some problems with really really long menus.
                            if (0 == lstrcmp(szAccount, szDefaultAccount))
                            {
                                AthLoadString(idsDefaultAccount, szDefaultString, ARRAYSIZE(szDefaultString));
                                lstrcpyn(szTruncAcct, szAccount, 80);
                                wsprintf(szTitle, "%s %s", szTruncAcct, szDefaultString);
                            }
                            else
                            {
                                lstrcpyn(szTitle, szAccount, 80);
                            }

                            // For account names with "&" characters like AT&T, we need to 
                            // quote the "&".
                            PszEscapeMenuStringA(szTitle, szAccountQuoted, ARRAYSIZE(szAccountQuoted));

                            // Fill in the struct
                            mii.wID = ID_ACCOUNT_FIRST + iAccount; 
                            mii.dwItemData = (DWORD_PTR) pszAcctID;
                            mii.dwTypeData = szAccountQuoted;

                            // Append the item
                            InsertMenuItem(hMenu, -1, TRUE, &mii);

                            // Increment the count
                            iAccount++;
                        }
                        // Release the account pointer
                        pAccount->Release();
                    }
                }
            }

            // Release the enumerator
            pEnum->Release();

            Assert(iAccount == cAccounts);
        }
    }
    else
    {
        //Remove Seperator in NEWSONLY mode.
        int     ItemCount;

        ItemCount = GetMenuItemCount(hMenu);
        if (ItemCount != -1)
        {
            DeleteMenu(hMenu, ItemCount - 1, MF_BYPOSITION);
        }
    }

    //iAccount could be less than cAccounts if we are in news only mode.
    if (pcItems)
        *pcItems = cAccounts;

    return (S_OK);
}


HRESULT AcctUtil_FreeSendReceieveMenu(HMENU hMenu, DWORD cItems)
{
    DWORD i;
    MENUITEMINFO mii;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA;

    for (i = 0; i < cItems; i++)
    {
        mii.dwItemData = 0;
        if (GetMenuItemInfo(hMenu, ID_ACCOUNT_FIRST + i, FALSE, &mii))
        {
            if (mii.dwItemData)
                MemFree((LPTSTR) mii.dwItemData);

            DeleteMenu(hMenu, ID_ACCOUNT_FIRST + i, MF_BYCOMMAND);
        }
    }

    return (S_OK);
}

HRESULT AcctUtil_CreateAccountManagerForIdentity(GUID *puidIdentity, IImnAccountManager2 **ppAccountManager)
{
    HRESULT hr;
    IImnAccountManager *pAccountManager = NULL;
    IImnAccountManager2 *pAccountManager2 = NULL;

    *ppAccountManager = NULL;

    if (FAILED(hr = HrCreateAccountManager(&pAccountManager)))
        goto exit;
    
    if (FAILED(hr = pAccountManager->QueryInterface(IID_IImnAccountManager2, (LPVOID *)&pAccountManager2)))
        goto exit;

    // The *puidIdentity does not result in a new GUID object being created (formal param is by reference)
    if (FAILED(hr = pAccountManager2->InitUser(NULL, *puidIdentity, 0)))
        goto exit;

    *ppAccountManager = pAccountManager2;
    pAccountManager2 = NULL;
    
exit:
    SafeRelease(pAccountManager);
    SafeRelease(pAccountManager2);

    return hr;
}

void InitNewAcctMenu(HMENU hmenu)
{
    HKEY    hkey, hkeyT;
    LONG    lResult;
    DWORD   cServices, cb, i, type, cItem, dwMsn;
    char    szKey[MAX_PATH], sz[512], szQuoted[512];
    HMENU   hsubmenu;
    MENUITEMINFO mii;
    LPSTR   pszKey;
    BOOL    fHideHotmail = HideHotmail();

    cItem = 0;
    hsubmenu = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szHTTPMailServiceRoot, 0, KEY_READ, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cServices, NULL, NULL, NULL, NULL, NULL, NULL, NULL) &&
            cServices > 0)
        {
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
            mii.fType = MFT_STRING;
            
            hsubmenu = CreatePopupMenu();
            if (hsubmenu != NULL)
            {
                // Start Enumerating the keys
                for (i = 0; i < cServices; i++)
                {
                    // Enumerate Friendly Names
                    cb = sizeof(szKey);
                    lResult = RegEnumKeyEx(hkey, i, szKey, &cb, 0, NULL, NULL, NULL);
    
                    // No more items
                    if (lResult == ERROR_NO_MORE_ITEMS)
                        break;
    
                    // Error, lets move onto the next account
                    if (lResult != ERROR_SUCCESS)
                    {
                        Assert(FALSE);
                        continue;
                    }
    
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szKey, 0, KEY_QUERY_VALUE, &hkeyT))
                    {

                        cb = sizeof(dwMsn);
                        if (!fHideHotmail ||
                            ERROR_SUCCESS != RegQueryValueEx(hkeyT, c_szHTTPMailDomainMSN, 0, NULL, (LPBYTE)&dwMsn, &cb) ||
                            dwMsn == 0)

                        {
                            cb = sizeof(sz);
                            if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szHTTPMailSignUp, NULL, &type, (LPBYTE)sz, &cb) &&
                                *sz != 0)
                            {
                                cb = sizeof(sz);
                                if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szHTTPMailServiceName, NULL, &type, (LPBYTE)sz, &cb) &&
                                    *sz != 0)
                                {
                                    pszKey = PszDup(szKey);
                                    if (pszKey != NULL)
                                    {
                                        PszEscapeMenuStringA(sz, szQuoted, ARRAYSIZE(szQuoted));

                                        // Fill in the struct
                                        mii.wID = ID_NEW_ACCT_FIRST + cItem; 
                                        mii.dwItemData = (DWORD_PTR)pszKey;
                                        mii.dwTypeData = szQuoted;
                                    
                                        // Append the item
                                        InsertMenuItem(hsubmenu, -1, TRUE, &mii);

                                        cItem++;
                                    }
                                }
                            }
                        }

                        RegCloseKey(hkeyT);
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    if (cItem == 0)
    {
        if (hsubmenu != NULL)
            DestroyMenu(hsubmenu);

        DeleteMenu(hmenu, ID_POPUP_NEW_ACCT, MF_BYCOMMAND);
    }
    else
    {
        Assert(hsubmenu != NULL);
        mii.fMask = MIIM_SUBMENU;
        mii.hSubMenu = hsubmenu;
        SetMenuItemInfo(hmenu, ID_POPUP_NEW_ACCT, FALSE, &mii);
    }
}

void FreeNewAcctMenu(HMENU hmenu)
{
    int i, cItem;
    MENUITEMINFO mii;
    HMENU hsubmenu;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = NULL;

    if (GetMenuItemInfo(hmenu, ID_POPUP_NEW_ACCT, FALSE, &mii) &&
        mii.hSubMenu != NULL)
    {
        hsubmenu = mii.hSubMenu;
        cItem = GetMenuItemCount(hsubmenu);

        mii.fMask = MIIM_DATA;

        for (i = 0; i < cItem; i++)
        {
            mii.dwItemData = 0;
            if (GetMenuItemInfo(hsubmenu, ID_NEW_ACCT_FIRST + i, FALSE, &mii))
            {
                if (mii.dwItemData)
                    MemFree((LPSTR)mii.dwItemData);
            }
        }

        DestroyMenu(hsubmenu);
    }
}

HRESULT HandleNewAcctMenu(HWND hwnd, HMENU hmenu, int id)
{
    MENUITEMINFO mii;
    char    szKey[MAX_PATH], szUrl[512];
    HKEY    hkey;
    DWORD   type, cb, dwUseWizard;
    TCHAR   rgch[MAX_PATH];
    BOOL    bFoundUrl = TRUE;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA|MIIM_TYPE;
    mii.dwItemData = 0;
    mii.dwTypeData = rgch;
    mii.cch = ARRAYSIZE(rgch);

    if (GetMenuItemInfo(hmenu, id, FALSE, &mii) && mii.dwItemData != 0)
    {
        wsprintf(szKey, c_szPathFileFmt, c_szHTTPMailServiceRoot, (LPSTR)mii.dwItemData);
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hkey))
        {
            // look for a config url
            cb = sizeof(szUrl);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szHTTPMailConfig, NULL, &type, (LPBYTE)szUrl, &cb))
            {
                // config url wasn't found. fall back to sign up url
                cb = sizeof(szUrl);
                if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szHTTPMailSignUp, NULL, &type, (LPBYTE)szUrl, &cb))
                    bFoundUrl = FALSE;
            }

            if (bFoundUrl)
            {
                cb = sizeof(DWORD);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szHTTPMailUseWizard, NULL, &type, (LPBYTE)&dwUseWizard, &cb) && 
                    dwUseWizard != 0)
                    DoHotMailWizard(GetTopMostParent(hwnd), szUrl, rgch, NULL, NULL);
                else
                    ShellExecute(hwnd, "open", szUrl, NULL, NULL, SW_SHOWNORMAL);
            }
            RegCloseKey(hkey);
        }
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\columns.h ===
#ifndef __COLUMNS_H_
#define __COLUMNS_H_

#include "ourguid.h"
#include "resource.h"

// 
// This defines all the available columns in Athena.  It maps the column ID,
// the name of the column, the default width, and the format (alignment).
//

#define IICON_TEXTHDR       -1

typedef struct tagCOLUMN_DATA {
    UINT        idsColumnName;      // Name of the column
    UINT        cxWidth;            // Default width for this column
    UINT        format;             // Format for the column (LVCFMT enum)
    int         iIcon;              // Icon for the column header
} COLUMN_DATA, *PCOLUMN_DATA;

// 
// This structure is used to define the column set for a particular 
// folder type.  
//

#define COLFLAG_VISIBLE         0x00000001  // This column is on by default
#define COLFLAG_SORT_ASCENDING  0x00000002  // This column is the sort column, and it's sorted ascending
#define COLFLAG_SORT_DESCENDING 0x00000004  // This column is the sort column, and it's sorted descending
#define COLFLAG_FIXED_WIDTH     0x00000008  // This column is a fixed width, it won't resize dynamically


typedef struct tagCOLUMN_SET {
    COLUMN_ID           id;         // Id of the column
    DWORD               flags;      // Combination of the COLUMN_ flags above
    DWORD               cxWidth;    // Width of the column.  If -1, then use the default.  
} COLUMN_SET, *PCOLUMN_SET;

// 
// This enumeration lists all the different column sets we currently have
// defined.
//
typedef enum tagCOLUMN_SET_TYPE
{
    COLUMN_SET_MAIL = 0,
    COLUMN_SET_OUTBOX,
    COLUMN_SET_NEWS,
    COLUMN_SET_IMAP,
    COLUMN_SET_IMAP_OUTBOX,
    COLUMN_SET_FIND,
    COLUMN_SET_NEWS_ACCOUNT,
    COLUMN_SET_IMAP_ACCOUNT,
    COLUMN_SET_LOCAL_STORE,
    COLUMN_SET_NEWS_SUB,
    COLUMN_SET_IMAP_SUB,
    COLUMN_SET_OFFLINE,
    COLUMN_SET_PICKGRP,
    COLUMN_SET_HTTPMAIL,
    COLUMN_SET_HTTPMAIL_ACCOUNT,
    COLUMN_SET_HTTPMAIL_OUTBOX,
    COLUMN_SET_MAX
} COLUMN_SET_TYPE;

//
// This struct maps the different column set types to the default column set
// and the place where this information is persisted.
//
typedef struct tagCOLUMN_SET_INFO {
    COLUMN_SET_TYPE     type;
    DWORD               cColumns;
    const COLUMN_SET   *rgColumns;
    LPCTSTR             pszRegValue;
    BOOL                fSort;
} COLUMN_SET_INFO;

//
// This structure defines what is saved when we persist the columns
//

#define COLUMN_PERSIST_VERSION 0x00000010

typedef struct tagCOLUMN_PERSIST_INFO {
    DWORD       dwVersion;              // Version stamp for this structure
    DWORD       cColumns;               // Number of entries in rgColumns
    COLUMN_SET  rgColumns[1];           // Actual array of visible columns
} COLUMN_PERSIST_INFO, *PCOLUMN_PERSIST_INFO;


/////////////////////////////////////////////////////////////////////////////
// Defines for the control ID's in the dialog
//

#define IDC_COLUMN_LIST                 20000
#define IDC_MOVEUP                      20001
#define IDC_MOVEDOWN                    20002
#define IDC_SHOW                        20003
#define IDC_HIDE                        20004
#define IDC_RESET_COLUMNS               20005
#define IDC_WIDTH                       20006

/////////////////////////////////////////////////////////////////////////////
// IColumnsInfo
//

typedef enum 
{
    COLUMN_LOAD_DEFAULT = 0,
    COLUMN_LOAD_BUFFER,
    COLUMN_LOAD_REGISTRY,
    COLUMN_LOAD_MAX
} COLUMN_LOAD_TYPE;

interface IColumnInfo : public IUnknown 
{
    // Initializes the object and tells it which ListView it will be using
    // and which column set should be applied.
    STDMETHOD(Initialize)(/*[in]*/ HWND hwndList, 
                          /*[in]*/ COLUMN_SET_TYPE type) PURE;

    // Tells the class to configure the columns in the ListView.  The user
    // can either tell the class to use the default columns or use a set
    // that was persisted by the caller.
    STDMETHOD(ApplyColumns)(/*[in]*/ COLUMN_LOAD_TYPE type,
                            /*[in, optional]*/ LPBYTE pBuffer,
                            /*[in]*/ DWORD cb) PURE;

    // Saves the current column configuration into the buffer provided by the
    // caller.  pcb should have the size of pBuffer when the function is called,
    // and will be updated to contain the number of bytes written into the 
    // buffer if the function succeeds.
    // if both params are null, it saves to registry
    STDMETHOD(Save)(/*[in, out]*/ LPBYTE pBuffer,
                    /*[in, out]*/ DWORD *pcb) PURE;

    // Returns the total number of columns in the ListView.
    STDMETHOD_(DWORD, GetCount)(void) PURE;

    // Returns the column ID for the specified column index.
    STDMETHOD_(COLUMN_ID, GetId)(/*[in]*/ DWORD iColumn) PURE;

    // Returns the index for the specified column ID.
    STDMETHOD_(DWORD, GetColumn)(/*[in]*/ COLUMN_ID id) PURE;

    // Set's the width of the specified column index.
    STDMETHOD(SetColumnWidth)(/*[in]*/ DWORD iColumn, 
                              /*[in]*/ DWORD cxWidth) PURE;

    // Allows the caller to ask for the column that we're sorted by and/or
    // the direction of the sort.  If the caller doesn't care about one of
    // those pieces of information, they can pass in NULL for that 
    // parameter.
    STDMETHOD(GetSortInfo)(/*[out, optional]*/ COLUMN_ID *pidColumn, 
                           /*[out, optional]*/ BOOL *pfAscending) PURE;

    // Allows the caller to update the column and direction of the current
    // sort.
    STDMETHOD(SetSortInfo)(/*[in]*/ COLUMN_ID idColumn,
                           /*[in]*/ BOOL fAscending) PURE;

    STDMETHOD(GetColumnInfo)(COLUMN_SET_TYPE* pType, COLUMN_SET** prgColumns, DWORD *pcColumns) PURE;
    STDMETHOD(SetColumnInfo)(COLUMN_SET* rgColumns, DWORD cColumns) PURE;

    // Displays a dialog that allows users to configure the columns.
    STDMETHOD(ColumnsDialog)(/*[in]*/ HWND hwndParent) PURE;

    // Fills the provided menu with the columns visible and the sort info.
    STDMETHOD(FillSortMenu)(/*[in]*/  HMENU  hMenu,
                            /*[in]*/  DWORD  idBase,
                            /*[out]*/ DWORD *pcItems,
                            /*[out]*/ DWORD *pidCurrent) PURE;

    // Inserts a column into the current column array
    STDMETHOD(InsertColumn)(/*[in]*/ COLUMN_ID id,
                            /*[in]*/ DWORD     iInsertBefore) PURE;

    // Checks to see if the specified column is visible
    STDMETHOD(IsColumnVisible)(/*[in]*/ COLUMN_ID id,
                               /*[out]*/ BOOL *pfVisible) PURE;
};

/////////////////////////////////////////////////////////////////////////////
// CColumns
//
class CColumns : public IColumnInfo
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction, Initialization, and Destruction
    //
    CColumns();
    ~CColumns();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHOD_(ULONG, AddRef)(void)
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHOD_(ULONG, Release)(void)
    {
        InterlockedDecrement(&m_cRef);
        if (0 == m_cRef)
        {
            delete this;
            return (0);
        }
        return (m_cRef);
    }

    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj)
    {
        *ppvObj = NULL;
        if (IsEqualIID(riid, IID_IUnknown))
            *ppvObj = (LPVOID) (IUnknown *) this;
        if (IsEqualIID(riid, IID_IColumnInfo))
            *ppvObj = (LPVOID) this;

        if (*ppvObj)
        {
            AddRef();
            return (S_OK);
        }

        return (E_NOINTERFACE);
    }        
    
    /////////////////////////////////////////////////////////////////////////
    // IColumnInfo
    //
    STDMETHODIMP Initialize(HWND hwndList, COLUMN_SET_TYPE type);
    STDMETHODIMP ApplyColumns(COLUMN_LOAD_TYPE type, LPBYTE pBuffer, DWORD cb);
    STDMETHODIMP Save(LPBYTE pBuffer, DWORD *pcb);
    DWORD STDMETHODCALLTYPE GetCount(void);
    COLUMN_ID STDMETHODCALLTYPE GetId(DWORD iColumn);
    DWORD STDMETHODCALLTYPE GetColumn(COLUMN_ID id);
    STDMETHODIMP SetColumnWidth(DWORD iColumn, DWORD cxWidth);
    STDMETHODIMP GetSortInfo(COLUMN_ID *pidColumn, BOOL *pfAscending);
    STDMETHODIMP SetSortInfo(COLUMN_ID idColumn, BOOL fAscending);
    STDMETHODIMP GetColumnInfo(COLUMN_SET_TYPE* pType, COLUMN_SET** prgColumns, DWORD *pcColumns);
    STDMETHODIMP SetColumnInfo(COLUMN_SET* rgColumns, DWORD cColumns);
    STDMETHODIMP ColumnsDialog(HWND hwndParent);
    STDMETHODIMP FillSortMenu(HMENU hMenu, DWORD idBase, DWORD *pcItems, DWORD *pidCurrent);
    STDMETHODIMP InsertColumn(COLUMN_ID id, DWORD iInsertBefore);
    STDMETHODIMP IsColumnVisible(COLUMN_ID id, BOOL *pfVisible);

    /////////////////////////////////////////////////////////////////////////
    // Utility functions
    //
protected:
    HRESULT _GetListViewColumns(COLUMN_SET* rgColumns, DWORD *pcColumns);
    HRESULT _SetListViewColumns(const COLUMN_SET *rgColumns, DWORD cColumns);

private:
    /////////////////////////////////////////////////////////////////////////
    // Class data
    //
    LONG                    m_cRef;
    BOOL                    m_fInitialized;
    CWindow                 m_wndList;
    HWND                    m_hwndHdr;
    COLUMN_SET_TYPE         m_type;
    COLUMN_SET             *m_pColumnSet;
    DWORD                   m_cColumns;
    COLUMN_ID               m_idColumnSort;
    BOOL                    m_fAscending;
    };


/////////////////////////////////////////////////////////////////////////////
// CColumnsDlg
//
class CColumnsDlg : public CDialogImpl<CColumnsDlg>
{
public:

	enum {IDD = iddColumns};

BEGIN_MSG_MAP(CColumnsDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnHelp)

    COMMAND_ID_HANDLER(IDC_SHOW, OnShowHide)
    COMMAND_ID_HANDLER(IDC_HIDE, OnShowHide)
    COMMAND_ID_HANDLER(IDC_RESET_COLUMNS, OnReset)
    COMMAND_ID_HANDLER(IDC_MOVEUP, OnMove)
    COMMAND_ID_HANDLER(IDC_MOVEDOWN, OnMove)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

    NOTIFY_HANDLER(IDC_COLUMN_LIST, NM_CLICK, OnClick)
    NOTIFY_HANDLER(IDC_COLUMN_LIST, NM_DBLCLK, OnClick)
    NOTIFY_HANDLER(IDC_COLUMN_LIST, LVN_ITEMCHANGED, OnItemChanged)

ALT_MSG_MAP(1)
    // Here's our edit control subclass
    MESSAGE_HANDLER(WM_CHAR, OnChar)

END_MSG_MAP()

    /////////////////////////////////////////////////////////////////////////
    // Construction, Initialization, and Destruction
    //
    CColumnsDlg();
    ~CColumnsDlg();
    HRESULT Init(IColumnInfo *pColumnInfo)
    {
        m_pColumnInfo = pColumnInfo;
        m_pColumnInfo->AddRef();
        return (S_OK);
    }

    /////////////////////////////////////////////////////////////////////////
    // Overrides of the standard interface implementations
    //
	STDMETHOD(Apply)(void);

    /////////////////////////////////////////////////////////////////////////
    // Message Handlers
    // 
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SetDirty(TRUE);
        bHandled = FALSE;
        return (0);
    }

    LRESULT OnShowHide(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnReset(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (SUCCEEDED(Apply()))
            EndDialog(0);

        return (0);
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(0);

        return (0);
    }

    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void _FillList(const COLUMN_SET *rgColumns, DWORD cColumns);
    BOOL _IsChecked(DWORD iItem);
    void _SetCheck(DWORD iItem, BOOL fChecked);
    void _UpdateButtonState(DWORD iItemSel);

    void SetDirty(BOOL fDirty)
    {
        ::SendMessage(GetParent(), fDirty ? PSM_CHANGED : PSM_UNCHANGED, 
                      (WPARAM) m_hWnd, 0);
    }

private:
    CContainedWindow    m_ctlEdit;
    COLUMN_SET_TYPE     m_type;
    COLUMN_SET         *m_rgColumns;
    DWORD               m_cColumns;
    HWND                m_hwndList;
    UINT                m_iItemWidth;
    IColumnInfo        *m_pColumnInfo;
};








#endif //__COLUMNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\attman.cpp ===
// ==============================================================================
// 3/2/96 - Attachment Manager Class Implementation (sbailey & brents)
// ==============================================================================
#include "pch.hxx"
#include "strconst.h"
#include <mimeole.h>
#include "mimeutil.h"
#include "mimeolep.h"
#include "attman.h"
#include <error.h>
#include <resource.h>
#include "header.h"
#include "note.h"
#include <thormsgs.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include "fonts.h"
#include "secutil.h"
#include <mailnews.h>
#include <menures.h>
#include <menuutil.h>
#include <demand.h>     // must be last!
#include "mirror.h"

// for dialog idc's
#include "fexist.h"


/*
 *  c o n s t a n t s
 */
#define CNUMICONSDEFAULT        10
#define CACHE_GROW_SIZE         10
#define MAX_ATTACH_PIXEL_HEIGHT 100

/*
 *  m a c r o s
 */

/*
 *  t y p e s
 *
 */

/*
 *  c o n s t a n t s
 *
 */

/*
 *  g l o b a l s
 *
 */

/*
 *  p r o t o t y p e s
 *
 */

// ==============================================================================
// CAttMan::CAttMan
// ==============================================================================
CAttMan::CAttMan ()
{
    DOUT ("CAttMan::CAttMan");
    m_pMsg = NULL;
    m_himlSmall = NULL;
    m_himlLarge = NULL;
    m_cRef = 1;
    m_hwndList = NULL;
    m_hwndParent=NULL;
    m_cfAccept = CF_NULL;
    m_dwDragType = 0;
    m_grfKeyState = 0;
    m_dwEffect = 0;
    m_cxMaxText = 0;
    m_cyHeight = 0;
    m_fReadOnly = 0;
    m_fDirty = FALSE;
    m_fDragSource = FALSE;
    m_fDropTargetRegister=FALSE;
    m_fShowingContext = 0;
    m_fRightClick = 0;
    m_fWarning = 1;
    m_fSafeOnly = TRUE;
    m_rgpAttach=NULL;
    m_cAttach=0;
    m_cAlloc=0;
    m_iVCard = -1;
    m_fDeleteVCards = FALSE;
    m_szUnsafeAttachList = NULL;
    m_cUnsafeAttach = 0;
}

// ==============================================================================
// CAttMan::~CAttMan
// ==============================================================================
CAttMan::~CAttMan ()
{
    DOUT ("CAttMan::~CAttMan");

    if (m_himlSmall)
        ImageList_Destroy (m_himlSmall);

    if (m_himlLarge)
        ImageList_Destroy (m_himlLarge);

    if (m_szUnsafeAttachList != NULL)
        SafeMemFree(m_szUnsafeAttachList);

    SafeRelease (m_pMsg);
}

// ==============================================================================
// CAttMan::AddRef
// ==============================================================================
ULONG CAttMan::AddRef()
{
    DOUT ("CAttMan::AddRef () Ref Count=%d", m_cRef);
    return ++m_cRef;
}

// ==============================================================================
// CAttMan::Release
// ==============================================================================
ULONG CAttMan::Release()
{
    ULONG ulCount = --m_cRef;
    DOUT ("CAttMan::Release () Ref Count=%d", ulCount);
    if (!ulCount)
        delete this;
    return ulCount;
}

HRESULT STDMETHODCALLTYPE CAttMan::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*)this;
//    else if (IsEqualIID(riid, IID_IDropTarget))
//        *ppvObj = (void*)(IDropTarget*)this;
    else if (IsEqualIID(riid, IID_IDropSource))
        *ppvObj = (void*)(IDropSource*)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CAttMan::HrGetAttachCount(ULONG *pcAttach)
{
    Assert(pcAttach);
    //*pcAttach = m_cAttach;
    *pcAttach = ListView_GetItemCount(m_hwndList);

    return S_OK;
}

ULONG CAttMan::GetUnsafeAttachCount()
{
    return m_cUnsafeAttach;
}

LPTSTR CAttMan::GetUnsafeAttachList()
{
    return m_szUnsafeAttachList;
}

HRESULT CAttMan::HrUnload()
{
    HRESULT     hr;

    SafeRelease (m_pMsg);

    if (m_hwndList)
        ListView_DeleteAllItems(m_hwndList);

    hr=HrFreeAllData();
    if (FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CAttMan::HrInit(HWND hwnd, BOOL fReadOnly, BOOL fDeleteVCards, BOOL fAllowUnsafe)
{
    m_fReadOnly = !!fReadOnly;
    m_hwndParent = hwnd;
    m_fDeleteVCards = !!fDeleteVCards;
    m_fSafeOnly = !fAllowUnsafe;

    return HrCreateListView(hwnd);
}

HRESULT CAttMan::HrClearDirtyFlag()
{
    m_fDirty=FALSE;
    return S_OK;
}

HRESULT CAttMan::HrIsDirty()
{
    return m_fDirty?S_OK:S_FALSE;
}

HRESULT CAttMan::GetTabStopArray(HWND *rgTSArray, int *pcArrayCount)
{
    Assert(rgTSArray);
    Assert(pcArrayCount);
    Assert(*pcArrayCount > 0);

    *rgTSArray = m_hwndList;
    *pcArrayCount = 1;
    return S_OK;
}

HRESULT CAttMan::HrCreateListView(HWND hwnd)
{
    HRESULT     hr;
    DWORD       dwFlags;

    dwFlags = 0;//DwGetOption(OPT_ATTACH_VIEW_STYLE);
    dwFlags |= WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|LVS_AUTOARRANGE|
               LVS_SMALLICON|LVS_NOSCROLL|LVS_SHAREIMAGELISTS;

    m_hwndList = CreateWindowExWrapW(WS_EX_CLIENTEDGE,
                                     WC_LISTVIEWW,
                                     L"",
                                     dwFlags,
                                     0,0,0,0,
                                     hwnd,
                                     (HMENU)idwAttachWell,
                                     g_hInst,
                                     NULL);

    if(!m_hwndList)
        return E_OUTOFMEMORY;
 
    // Init image list
    hr=HrInitImageLists();
    if(FAILED(hr))
        goto error;


#if 0
    // if we're not readonly, register ourselves as a drop target...
    if(!m_fReadOnly)
        {
        hr=CoLockObjectExternal((LPDROPTARGET)this, TRUE, FALSE);
        if (FAILED(hr))
            goto error;

        hr=RegisterDragDrop(m_hwndList, (LPDROPTARGET)this);
        if (FAILED(hr))
            goto error;

        m_fDropTargetRegister=TRUE;
        }
#endif

error:
    return hr;
}

HRESULT CAttMan::HrBuildAttachList()
{
    HRESULT     hr = S_OK;
    ULONG       cAttach=0,
                uAttach;
    LPHBODY     rghAttach=0;

    Assert(m_pMsg != NULL);

    // secure receipt is not attachment and we don't need to show .DAT file as attachment.
    if(CheckSecReceipt(m_pMsg) == S_OK)
        return hr;

    //GetAttachmentCount(m_pMsg, &cAttach);
    hr=m_pMsg->GetAttachments(&cAttach, &rghAttach);
    if (FAILED(hr))
        goto error;

    for(uAttach=0; uAttach<cAttach; uAttach++)
    {
        hr=HrAddData(rghAttach[uAttach]);
        if (FAILED(hr))
            goto error;
    }
    
error:
    SafeMimeOleFree(rghAttach);
    return hr;
}


// Only expected to be used during initialization with original m_pMsg
HRESULT CAttMan::HrFillListView()
{
    HRESULT     hr;
    ULONG       uAttach;
    CComBSTR    bstrUnsafeAttach;

    Assert (m_hwndList && IsWindow(m_hwndList) && m_pMsg);

    hr = HrCheckVCard();
    if (FAILED(hr))
        goto error;

    if (m_cAttach==0)         // nothing to do
        return NOERROR;

    if(m_iVCard >= 0)
        ListView_SetItemCount(m_hwndList, m_cAttach - 1);
    else
        ListView_SetItemCount(m_hwndList, m_cAttach);

    if (m_szUnsafeAttachList != NULL)
        SafeMemFree(m_szUnsafeAttachList);
    m_cUnsafeAttach = 0;

    // walk the attachment data list and add them to the listview
    for(uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        // if there is one and only one vcare in the read note, don't add it to list view,
        // header will show it as a stamp.
        if (m_rgpAttach[uAttach] && uAttach!=(ULONG)m_iVCard)
        {
            hr=HrAddToList(m_rgpAttach[uAttach], TRUE);
            if (hr == S_FALSE)
            {
                if (bstrUnsafeAttach.Length() > 0)
                    bstrUnsafeAttach.Append(L",");
                bstrUnsafeAttach.Append(m_rgpAttach[uAttach]->szFileName);
                m_cUnsafeAttach++;
            }
            if (FAILED(hr))
                goto error;
        }
    }

error:
    if (m_cUnsafeAttach)
        m_szUnsafeAttachList = PszToANSI(CP_ACP, bstrUnsafeAttach.m_str);

#ifdef DEBUG
    if(m_iVCard >= 0)
        AssertSz(m_cAttach-1==(ULONG)ListView_GetItemCount(m_hwndList)+m_cUnsafeAttach, "Something failed creating the attachmentlist");
    else
        AssertSz(m_cAttach==(ULONG)ListView_GetItemCount(m_hwndList)+m_cUnsafeAttach, "Something failed creating the attachmentlist");
#endif
    return hr;
}


// tells the note header if there is a vcard it wants.
HRESULT CAttMan::HrFVCard()
{
    return (m_iVCard >= 0) ? S_OK : S_FALSE;
}

// note header needs this function to show the property of the vcard 
// which is shown as a stamp on the header.
HRESULT CAttMan::HrShowVCardProp()
{
    Assert(m_iVCard >= 0);

    return HrDoVerb(m_rgpAttach[m_iVCard], ID_OPEN);
}


// checks if we have one and only one vcard in the attachment.
HRESULT CAttMan::HrCheckVCard()
{
    HRESULT     hr = NOERROR;
    ULONG       uAttach;

    m_iVCard = -1;

    // this is only for read note. Since preview doesn't call this function,
    // we can check m_fReadOnly to see if it's a read note.
    if(!m_fReadOnly)
        return hr;

    for(uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        if (m_rgpAttach[uAttach])
        {
            if(StrStrIW(PathFindExtensionW((m_rgpAttach[uAttach])->szFileName), L".vcf"))
            {
                if(m_iVCard >= 0)
                {
                    // there are more than one vcards, we quit.
                    m_iVCard = -1;
                    break;
                }
                else
                    m_iVCard = uAttach;
            }
        }
    }

    return hr;
}


HRESULT CAttMan::HrCheckVCardExists(BOOL fMail)
{
    HRESULT     hr = S_FALSE;
    ULONG       uAttach;
    TCHAR       szVCardName[MAX_PATH];
    LPWSTR      szVCardNameW = NULL;

    if(m_fReadOnly)
        return hr;

    *szVCardName = 0;

    if(fMail)
        GetOption(OPT_MAIL_VCARDNAME, szVCardName, MAX_PATH);
    else
        GetOption(OPT_NEWS_VCARDNAME, szVCardName, MAX_PATH);

    if (*szVCardName != '\0')
    {
        szVCardNameW = PszToUnicode(CP_ACP, szVCardName);
        if (szVCardNameW)
        {
            for(uAttach=0; uAttach<m_cAlloc; uAttach++)
            {
                if (m_rgpAttach[uAttach])
                {    
                    if(0 == StrCmpNIW((m_rgpAttach[uAttach])->szFileName, szVCardNameW, lstrlenW(szVCardNameW)))
                    {
                        hr = S_OK;
                        break;
                    }
                }
            }
            MemFree(szVCardNameW);
        }
        else
            TraceResult(hr = E_OUTOFMEMORY);
    }

    return hr;
}

/*
 *
 *  HrInitImageLists
 *
 *  Create an image list and assign it to our listview.
 *  to contain iicons number of icons
 *
 */
HRESULT CAttMan::HrInitImageLists()
{
    UINT flags = ILC_MASK;
    Assert(m_hwndList && IsWindow(m_hwndList));
    Assert(!m_himlLarge);
    Assert(!m_himlSmall);

    if(IS_WINDOW_RTL_MIRRORED(m_hwndList))
    {
        flags |= ILC_MIRROR ;
    }
    m_himlLarge = ImageList_Create( GetSystemMetrics(SM_CXICON),     
                                    GetSystemMetrics(SM_CYICON), 
                                    flags, CNUMICONSDEFAULT, 0);
    if(!m_himlLarge)
        return E_OUTOFMEMORY;
    
    m_himlSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON), 
                                    GetSystemMetrics(SM_CYSMICON),
                                    flags, CNUMICONSDEFAULT, 0);
    if(!m_himlSmall)
        return E_OUTOFMEMORY;
    
    ListView_SetImageList(m_hwndList, m_himlSmall, LVSIL_SMALL);
    ListView_SetImageList(m_hwndList, m_himlLarge, LVSIL_NORMAL);
    return NOERROR;
}

//
// HrAddToList
//
// adds an attachment to the LV, 
// if count was 0 then send a message to parent
// to redraw.
//
HRESULT CAttMan::HrAddToList(LPATTACHDATA pAttach, BOOL fIniting)
{
    LV_ITEMW        lvi ={0}; 
    INT             iPos;    
    HICON           hIcon=0;
    RECT            rc;

    Assert(m_hwndList != NULL);
    Assert(pAttach != NULL);
    Assert(m_himlSmall != NULL);
    Assert(m_himlLarge != NULL);

    // don't show attachments which are deemed unsafe
    if (m_fReadOnly && m_fSafeOnly && !(pAttach->fSafe))
        return S_FALSE;

    // if this is the first item
    // we need to send a message to parent
    lvi.mask        = LVIF_PARAM|LVIF_TEXT|LVIF_IMAGE|LVIF_STATE;
    lvi.stateMask   = 0;
    lvi.pszText     = L"";
    lvi.lParam      = (LPARAM)pAttach;

    // get icons for image list
    if (fIniting)
    {
        SideAssert(HrGetAttachIcon(m_pMsg, pAttach->hAttach, FALSE, &hIcon)==S_OK);
        lvi.iImage = ImageList_AddIcon(m_himlSmall, hIcon);
        DestroyIcon(hIcon);
        SideAssert(HrGetAttachIcon(m_pMsg, pAttach->hAttach, TRUE, &hIcon)==S_OK);
        ImageList_AddIcon(m_himlLarge, hIcon);
        DestroyIcon(hIcon);
    }
    else
    {
        SideAssert(HrGetAttachIconByFile(pAttach->szFileName, FALSE, &hIcon)==S_OK);
        lvi.iImage = ImageList_AddIcon(m_himlSmall, hIcon);
        DestroyIcon(hIcon);
        SideAssert(HrGetAttachIconByFile(pAttach->szFileName, TRUE, &hIcon)==S_OK);
        ImageList_AddIcon(m_himlLarge, hIcon);
        DestroyIcon(hIcon);
    }
    
    lvi.pszText     = pAttach->szDisplay;

    iPos = (INT) SendMessage(m_hwndList, LVM_INSERTITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi));
    if (-1 == iPos)
        return E_FAIL;

    // Must set to LVS_ICON then reset to LVS_SMALLICON
    // to get SMALLICONs to come up arranged.
    DWORD dwStyle = GetWindowStyle(m_hwndList);
    if ((dwStyle & LVS_TYPEMASK) == LVS_SMALLICON)
    {
        SetWindowLong(m_hwndList, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|LVS_ICON);
        SetWindowLong(m_hwndList, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|LVS_SMALLICON);
    }

    return S_OK;
}

BOOL CAttMan::WMNotify(int idFrom, NMHDR *pnmhdr)
{
    DOUTLL( DOUTL_ATTMAN, 2, "CAttMan :: WMNotify( ), %d", idFrom );

    if (idFrom!=idwAttachWell)
        return FALSE;

    switch (pnmhdr->code)
    {
        case LVN_KEYDOWN:
        {                                               
            LV_KEYDOWN *pnkd = ((LV_KEYDOWN *)pnmhdr); 
            switch (pnkd->wVKey)
            {
                case VK_DELETE:
                    if (!m_fReadOnly)
                        HrRemoveAttachments();
                    break;
                
                case VK_INSERT:
                    if (!m_fReadOnly)
                        HrInsertFile();
                    break;
                
                case VK_RETURN:
                case VK_EXECUTE:
                    HrExecFile(ID_OPEN);
                    break;
                
            }
            break;
        }

        case LVN_BEGINDRAG:
        case LVN_BEGINRDRAG:
            m_dwDragType = (pnmhdr->code==LVN_BEGINDRAG?MK_LBUTTON:MK_RBUTTON);
            HrBeginDrag();
            return TRUE;

        case NM_DBLCLK:
            HrDblClick(idFrom, pnmhdr);
            return TRUE;
    }   

    return FALSE;
}

//================================================================
//
//  BOOL CAttMan :: OnBeginDrag( )
//
//  Purpose: We have received a message that a drag has begun.
//================================================================
HRESULT CAttMan::HrBeginDrag()
{
    DWORD           dwEffect;
    IDataObject    *pDataObj=0;
    PDATAOBJINFO    pdoi = 0;
    HRESULT         hr;

    Assert(m_hwndList);
    
    // BROKEN: this is busted. Creating the tempfile on a dragstart is broken, we should package these better.
    hr=HrBuildHDrop(&pdoi);
    if (FAILED(hr))
        goto error;

    hr = CreateDataObject(pdoi, 1, (PFNFREEDATAOBJ)FreeAthenaDataObj, &pDataObj);
    if (FAILED(hr))
    {
        SafeMemFree(pdoi);
        goto error;
    }

    if (m_fReadOnly)
        dwEffect = DROPEFFECT_COPY;
    else
        dwEffect = DROPEFFECT_MOVE|DROPEFFECT_COPY;

    // prevent source drags in the body...

    m_fDragSource = TRUE;

    hr=DoDragDrop((LPDATAOBJECT)pDataObj, (LPDROPSOURCE)this, dwEffect, &dwEffect);

    m_fDragSource = FALSE;

    if (FAILED(hr))
        goto error;
    
    
    // ok, now lets see if the operation was a move, if so we need to
    // delete the source.
    if( !m_fReadOnly && (dwEffect & DROPEFFECT_MOVE))
        hr=HrRemoveAttachments();

error:
    ReleaseObj(pDataObj);
    return hr;
}

//================================================================
//
//  BOOL CAttMan :: WMContextMenu( )
//
//  Displays one of two menus for the lisview.
//  Menu is selected depending if items are highlighted.
//
//  returns: TRUE => success.
//
//================================================================

BOOL CAttMan::WMContextMenu( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    HMENU       hMenu=NULL;
    INT         cSel;
    BOOL        fEnable,
                fRet = FALSE;
    LV_ITEMW    lvi;
    WCHAR       szCommand[MAX_PATH];
    DWORD       dwPos;

    // was it for us?
    if ((HWND)wParam != m_hwndList)
        goto cleanup;

    Assert(m_hwndList);

    cSel = ListView_GetSelectedCount(m_hwndList);

    hMenu = LoadPopupMenu(IDR_ATTACHMENT_POPUP);
    if(!hMenu)
        goto cleanup;

    // commands that are enabled if only one attachment is selected
    fEnable = (cSel == 1);

    EnableMenuItem(hMenu, ID_PRINT, MF_BYCOMMAND | (fEnable? MF_ENABLED:MF_GRAYED));
    EnableMenuItem(hMenu, ID_QUICK_VIEW, MF_BYCOMMAND | (fEnable? MF_ENABLED:MF_GRAYED));

    // enabled in readonly mode and if there is only one attach selected
    EnableMenuItem(hMenu, ID_SAVE_ATTACH_AS, MF_BYCOMMAND | ((fEnable && m_fReadOnly)? MF_ENABLED:MF_GRAYED));

    // enabled if any attachments selected
    EnableMenuItem(hMenu, ID_OPEN, MF_BYCOMMAND | (cSel > 0? MF_ENABLED:MF_GRAYED));

    // enabled only in readonly mode
    EnableMenuItem(hMenu, ID_SAVE_ATTACHMENTS, MF_BYCOMMAND | (m_fReadOnly? MF_ENABLED:MF_GRAYED));

    // enabled only in compose mode
    EnableMenuItem(hMenu, ID_ADD, MF_BYCOMMAND | (!m_fReadOnly? MF_ENABLED:MF_GRAYED));

    // enabled only in compose mode if there is a valid selection
    EnableMenuItem(hMenu, ID_REMOVE, MF_BYCOMMAND | (!m_fReadOnly && cSel > 0? MF_ENABLED:MF_GRAYED));

    if ((fIsNT5()) || (IsOS(OS_MILLENNIUM)))
    {
        // On Both these platforms, Quick View is not supported.
        DeleteMenu(hMenu, ID_QUICK_VIEW, MF_BYCOMMAND);
    }
    else
    {
        // Disable Quick View if QVIEW.EXE does not exist
        GetSystemDirectoryWrapW(szCommand, ARRAYSIZE(szCommand));
        StrCatW(szCommand, L"\\VIEWERS\\QUIKVIEW.EXE");

        if ((UINT)GetFileAttributesWrapW(szCommand) == (UINT)-1)
        {
            EnableMenuItem (hMenu, ID_QUICK_VIEW, MF_GRAYED);
        }
    }

    // bold the first non-grey item
    MenuUtil_SetPopupDefault(hMenu, ID_OPEN);

    // RAID $2129: disable print verb for .eml files
    // $49436 - also disable for .lnks
    if (cSel==1)
    {
        LPWSTR pszExt;
        
        lvi.iItem = ListView_GetSelFocused(m_hwndList);
        lvi.mask = LVIF_PARAM;
        if (SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
        {
            pszExt = PathFindExtensionW(((LPATTACHDATA)lvi.lParam)->szFileName);
            if (pszExt && (StrCmpIW(pszExt, c_wszEmlExt)==0 ||
                           StrCmpIW(pszExt, c_wszNwsExt)==0 ||
                           StrCmpIW(pszExt, L".lnk")==0))
                EnableMenuItem( hMenu, ID_PRINT, MF_GRAYED);
        }
    }
    

    dwPos=GetMessagePos();
    
    fRet = TrackPopupMenuEx( 
                    hMenu,
                    TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                    LOWORD(dwPos),
                    HIWORD(dwPos),
                    hwnd,
                    NULL);
cleanup:
    if(hMenu)
        DestroyMenu(hMenu);

    return fRet;
}

HRESULT CAttMan::HrDblClick(int idFrom, NMHDR *pnmhdr)
{
    DWORD           dwPos;
    POINT           pt;
    LV_HITTESTINFO  lvhti;
    LV_ITEMW        lvi;
        
    Assert(m_hwndList);

    // Find out where the cursor was
    dwPos = GetMessagePos();
    pt.x  = LOWORD(dwPos);
    pt.y  = HIWORD(dwPos);
    ScreenToClient( m_hwndList, &pt);
           
    lvhti.pt = pt;            
    if(ListView_HitTest(m_hwndList, &lvhti) != -1)
    {
        // return 1 here, we passed the HitTest
        lvi.iItem = lvhti.iItem;
        lvi.mask = LVIF_PARAM;
        if (SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
            return HrDoVerb((LPATTACHDATA)lvi.lParam, ID_OPEN);
    }
    return S_OK;
}

HRESULT CAttMan::HrGetHeight(INT cxWidth, ULONG *pcy)
{
    DWORD   dwDims;
    LONG    cCount;

    if (!pcy || cxWidth<=0)
        return E_INVALIDARG;

    *pcy=0;

    cCount = ListView_GetItemCount(m_hwndList);
    if (0 == cCount)
        *pcy = 0;
    else
    {
        dwDims = ListView_ApproximateViewRect(m_hwndList, cxWidth, 0, cCount);
        *pcy = HIWORD(dwDims);
    }
    
    return S_OK;
}

HRESULT CAttMan::HrSwitchView(DWORD dwView)
{
    DWORD       dwStyle = GetWindowStyle(m_hwndList);
    WORD        ToolbarStyleLookup[]= { LVS_ICON, 
                                        LVS_REPORT,
                                        LVS_SMALLICON, 
                                        LVS_LIST };

    Assert(m_hwndList);
    
    // convert index into lisview style
    dwView = ToolbarStyleLookup[dwView];

    if ((LVS_ICON != dwView) && (LVS_SMALLICON != dwView))
        dwView = LVS_ICON;

    // don't change to the same view
    if ((dwStyle & LVS_TYPEMASK) != dwView)
    {
        SetWindowLong(m_hwndList, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK)|dwView);
        HrResizeParent();
        SetDwOption(OPT_ATTACH_VIEW_STYLE, dwView, NULL, 0); 
    }
    
    return S_OK;
}

HRESULT CAttMan::HrSetSize(RECT *prc)
{
    Assert(IsWindow( m_hwndList ));
    Assert(prc);
    
    DWORD   dwStyle = GetWindowStyle(m_hwndList),
            dwPosFlags;
    ULONG   cAttMan = 0;

    HrGetAttachCount(&cAttMan);
    if (cAttMan == 1)
        SetWindowLong(m_hwndList, GWL_STYLE, dwStyle | LVS_NOSCROLL);
    else
        SetWindowLong(m_hwndList, GWL_STYLE, dwStyle & ~LVS_NOSCROLL);

    dwPosFlags = (cAttMan > 0) ? SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOCOPYBITS|SWP_SHOWWINDOW:
                                 SWP_HIDEWINDOW;

    SetWindowPos(m_hwndList, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, dwPosFlags);

    return S_OK;
}

BOOL CAttMan::WMCommand(HWND hwndCmd, INT id, WORD wCmd)
{
    // verbs depending on listview mode
    if (m_hwndList)
    {
        switch(id)
        {
            case ID_SELECT_ALL:
                if(GetFocus()!=m_hwndList)
                    return FALSE;
            
                ListView_SelectAll(m_hwndList);
                return TRUE;
            
            case ID_ADD:
                HrInsertFile();
                return TRUE;
            
            case ID_REMOVE:
                HrRemoveAttachments();
                return TRUE;
            
            case ID_OPEN:
            case ID_QUICK_VIEW:
            case ID_PRINT:
            case ID_SAVE_ATTACH_AS:
                HrExecFile(id);
                return TRUE;
            
            case ID_INSERT_ATTACHMENT:
                HrInsertFile();
                return TRUE;
        }
    }
    return FALSE;
}

//===================================================
//
//    HrRemoveAttachment
//
//    Purpose:
//        Removes an attachment from the ListView
//
//    Arguments:
//      ili            - index of attachment in listview to remove
//      fDelete        - should we remove it from list
//
//    Returns:
///
//===================================================
HRESULT CAttMan::HrRemoveAttachment(int ili)
{
    LV_ITEMW        lvi;
    LPATTACHDATA    lpAttach=0;    
    HRESULT         hr=S_OK;
    ULONG           uAttach;

    Assert( m_hwndList );

    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem    = ili;

    if (!SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
    {
        AssertSz(0, "Attempting to remove an item that is not there");
        return E_FAIL;    // item does not exist!!!!
    }
    
    lpAttach = (LPATTACHDATA)lvi.lParam;
    if(!lpAttach)
        return E_FAIL;

    // find it and kill it from the list
    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        if (m_rgpAttach[uAttach]==lpAttach)
        {
            HrFreeAttachData(m_rgpAttach[uAttach]);
            m_rgpAttach[uAttach] = NULL;
            break;
        }
    }

    // if we actually removed the attachment, make sure we're dirty
    m_fDirty = TRUE;

    ListView_DeleteItem(m_hwndList, ili);

    return hr;
}

/*
 *  CAttMan::HrDeleteAttachments
 *
 *  Purpose:
 *      Prompts user to confirm deletion, if IDYES -> blow them away
 *
 */

HRESULT CAttMan::HrDeleteAttachments()
{
    if (AthMessageBoxW( m_hwndParent,
                        MAKEINTRESOURCEW(idsAthena),
                        MAKEINTRESOURCEW(idsAttConfirmDeletion),
                        NULL, MB_YESNO|MB_ICONEXCLAMATION )==IDNO)

        return NOERROR;


    return HrRemoveAttachments();
}

/*
 *  CAttMan ::  HrRemoveAttachments
 *
 *  Purpose:
 *      Removes all selected attachments from the Well.
 *
 *  Arguments:
 *
 */

HRESULT CAttMan::HrRemoveAttachments()
{
    HRESULT     hr=NOERROR;
    HWND        hwnd;
    int         ili,
                iNext,
                nPos,
                nCount;
    
    Assert(m_hwndList);
    
    while ((ili=ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED|LVNI_ALL))!=-1)
    {
        iNext = ili;
        hr=HrRemoveAttachment(ili);
        if (FAILED(hr))
            goto error;
    }
    
    if ((nCount=ListView_GetItemCount(m_hwndList))==0)
    {
        // if there are no attachments left, we need to size the well to 0. and setfocus
        // to someother control
        m_cyHeight = 0;
        HrResizeParent();
        
        if (hwnd = GetNextDlgTabItem(m_hwndParent, m_hwndList, TRUE))
            SetFocus(hwnd);
    }
    else
    {
        HrResizeParent();
        if (iNext<nCount)
            nPos = (iNext?iNext-1:iNext);
        else
            nPos = nCount - 1;
        
        ListView_SelectItem(m_hwndList, nPos);
    }
error:
    return hr;
}


HRESULT CAttMan::HrResizeParent()
{
    RECT    rc;
    NMHDR   nmhdr;

    Assert(m_hwndList);
    nmhdr.hwndFrom=m_hwndList;
    nmhdr.idFrom=GetDlgCtrlID(m_hwndList);
    nmhdr.code=ATTN_RESIZEPARENT;
    SendMessage(GetParent(m_hwndList), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
    return S_OK;
}

#define CCH_INSERTFILE  4096

typedef struct tagATTMANCUSTOM {
    BOOL    fShortcut;
    WCHAR   szFiles[CCH_INSERTFILE];
    WORD    nFileOffset;
} ATTMANCUSTOM;

HRESULT CAttMan::HrInsertFile()
{
    OPENFILENAMEW   ofn;
    HRESULT         hr;
    WCHAR           rgch[MAX_PATH],
                    pszOpenFileName[CCH_INSERTFILE];
    ATTMANCUSTOM    rCustom;

    Assert(m_hwndList);

    *pszOpenFileName = 0;

    ZeroMemory(&ofn, sizeof(ofn));
    AthLoadStringW(idsAllFilesFilter, rgch, MAX_PATH);
    ReplaceCharsW(rgch, _T('|'), _T('\0'));

    ofn.lStructSize     = sizeof(OPENFILENAME);
    ofn.hwndOwner       = m_hwndParent;
    ofn.hInstance       = g_hLocRes;
    ofn.lpstrFilter     = rgch;
    ofn.nFilterIndex    = 1;
    ofn.lpstrFile       = pszOpenFileName;
    ofn.nMaxFile        = CCH_INSERTFILE;
    ofn.lpstrInitialDir = NULL; //current dir
    ofn.Flags           = OFN_HIDEREADONLY |
                          OFN_EXPLORER |
                          OFN_ALLOWMULTISELECT |
                          OFN_FILEMUSTEXIST |
                          OFN_NOCHANGEDIR |
                          OFN_ENABLEHOOK |
                          OFN_ENABLETEMPLATE |
                          OFN_NODEREFERENCELINKS;
    ofn.lpTemplateName  = MAKEINTRESOURCEW(iddInsertFile);
    ofn.lpfnHook        = (LPOFNHOOKPROC)InsertFileDlgHookProc;
    ofn.lCustData       = (LONG_PTR)&rCustom;

    rCustom.szFiles[0] = 0;
    rCustom.fShortcut = FALSE;
    rCustom.nFileOffset = 0;

    // NB: OK button in dialog hook take's care of inserting the attachment.
    hr = HrAthGetFileNameW(&ofn, TRUE);
    if (SUCCEEDED(hr))
    {
        WCHAR   sz[MAX_PATH];
        LPWSTR  pszT;
        BOOL    fShortCut = rCustom.fShortcut,
                fUseCustom = (rCustom.szFiles[0]),
                fSingleAttach;

        // We only generate custom stuff if we have more than one file
        fSingleAttach = fUseCustom ? FALSE : (ofn.nFileOffset < lstrlenW(pszOpenFileName));
        if (fSingleAttach)
        {
            // in single-file case, no null between path and filename
            hr = HrAddAttachment(pszOpenFileName, NULL, fShortCut);
        }
        else
        {
            LPWSTR pszPath;
            if (fUseCustom)
            {
                pszPath = rCustom.szFiles;
                pszT = pszPath + rCustom.nFileOffset;
            }
            else
            {
                pszPath = pszOpenFileName;
                pszT = pszPath + ofn.nFileOffset;
            }

            while (TRUE)
            {
                PathCombineW(sz, pszPath, pszT);
        
                hr = HrAddAttachment(sz, NULL, fShortCut);
                if (hr != S_OK)
                    break;
        
                pszT = pszT + lstrlenW(pszT) + 1;
                if (*pszT == 0)
                    break;
            }
        }
    }

    return(hr);
}

/*
 * HrAddAttachment
 *
 * adds a file attachment to the list from a stream or filename
 *
 *
 */

HRESULT CAttMan::HrAddAttachment(LPWSTR lpszPathName, LPSTREAM pstm, BOOL fShortCut)
{
    ULONG           cbSize=0;
    HRESULT         hr = S_OK;
    HBODY           hAttach=0;
    LPATTACHDATA    pAttach;
    WCHAR           szLinkPath[MAX_PATH];
    LPWSTR          pszFileNameToUse;

    *szLinkPath = 0;

    if(fShortCut)
    {
        hr = CreateNewShortCut(lpszPathName, szLinkPath, ARRAYSIZE(szLinkPath));
        if (FAILED(hr))
            return hr;    
    }

    pszFileNameToUse = *szLinkPath ? szLinkPath : lpszPathName;

    hr=HrAddData(pszFileNameToUse, pstm, &pAttach);

    if (FAILED(hr))
        return hr;

    hr=HrAddToList(pAttach, FALSE);
    if (FAILED(hr))
        goto error;           

    if (ListView_GetItemCount(m_hwndList) == 1)
    {
        // if we went from 0->1 then select the first item
        ListView_SelectItem(m_hwndList, 0);
    }
    // Adding a new attachment makes us dirty
    m_fDirty = TRUE;

    HrResizeParent();
error:
    return hr;
}

/*
 *
 *  HRESULT CAttMan::HrExecFile
 *
 *  handles one of these verbs against an attachment:
 *  
 *      ID_OPEN:          - Launch use m_lpMsg
 *      ID_QUICK_VIEW:     - NYI
 *      ID_PRINT:         - NYI
 *      ID_SAVE_AS:          - NYI
 *
 *  returns 1 if handled.
 *
 */

HRESULT CAttMan::HrExecFile(int iVerb)
{
    LV_ITEMW    lvi;
    HRESULT     hr=E_FAIL;

    if (!ListView_GetSelectedCount(m_hwndList))
        return NOERROR; // nothing to do...

    lvi.mask     = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem    = -1;
 
    // cycle through all the selected attachments
    while ((lvi.iItem = ListView_GetNextItem(m_hwndList, lvi.iItem, LVNI_SELECTED | LVNI_ALL)) != -1)
    {
        SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi));
        
        switch(iVerb)
        {
            case ID_SAVE_ATTACH_AS:
            case ID_OPEN:
            case ID_PRINT:
            case ID_QUICK_VIEW:
                return HrDoVerb((LPATTACHDATA)lvi.lParam, iVerb);
            
            default:
                AssertSz(0, "Verb not supported");
        }
    }

    return hr;
}

// ==============================================================================
//
//  FUNCTION:   CAttMan :: FDropFiles()
//
//  Purpose:    this method is called with a HDROP, the files
//              have been droped. This method assumes
//
// ==============================================================================

HRESULT CAttMan::HrDropFiles(HDROP hDrop, BOOL fMakeLinks)
{
    WCHAR   wszFile[_MAX_PATH];
    UINT    cFiles;
    UINT    iFile;
    HCURSOR hcursor;
    BOOL    fFirstDirectory = TRUE,
            fLinkDirectories = FALSE;
    HRESULT hr = S_OK;
        
    hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Let's work through the files given to us
    cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
    for (iFile = 0; iFile < cFiles; ++iFile)
    {
        DragQueryFileWrapW(hDrop, iFile, wszFile, _MAX_PATH);
        if (!fMakeLinks && PathIsDirectoryW(wszFile))
        {
            // can link to a directory, but not drop one.
            if (fFirstDirectory)
            {
                int id;
                // Tell the user that he's been a bad user
                id = AthMessageBoxW(m_hwndParent,
                                    MAKEINTRESOURCEW(idsAthena),                                      
                                    MAKEINTRESOURCEW(idsDropLinkDirs), 
                                    NULL,
                                    MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_YESNOCANCEL);
                if (id==IDCANCEL)
                    return E_FAIL;

                if (id == IDYES)
                    fLinkDirectories = TRUE;

                fFirstDirectory = FALSE;
            }
            if (fLinkDirectories)
                hr = HrAddAttachment(wszFile, NULL, TRUE);
        }
        else
            hr = HrAddAttachment(wszFile, NULL, fMakeLinks);
    }

    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwndParent,
                       MAKEINTRESOURCEW(idsAthena),                                      
                       MAKEINTRESOURCEW(idsErrDDFileNotFound), 
                       NULL, MB_ICONEXCLAMATION|MB_SETFOREGROUND|MB_OK);
    }

    SetCursor(hcursor);
    return S_OK;
}

HRESULT CAttMan::HrDropFileDescriptor(LPDATAOBJECT pDataObj, BOOL fLink)
{
    HCURSOR                 hcursor;
    BOOL                    fFirstDirectory = TRUE,
                            fLinkDirectories = FALSE,
                            fUnicode = TRUE,
                            fIsDirectory;
    SCODE                   sc = S_OK;
    LPWSTR                  pwszFileName = NULL;
    HRESULT                 hr = S_OK;
    STGMEDIUM               stgmedDesc;
    FILEGROUPDESCRIPTORA   *pfgdA = NULL;
    FILEDESCRIPTORA        *pfdA = NULL;
    FILEGROUPDESCRIPTORW   *pfgdW = NULL;
    FILEDESCRIPTORW        *pfdW = NULL;
    UINT                    uiNumFiles,
                            uiCurrFile;
    FORMATETC               fetcFileDescA =
                                {(CLIPFORMAT)(CF_FILEDESCRIPTORA), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC               fetcFileDescW =
                                {(CLIPFORMAT)(CF_FILEDESCRIPTORW), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC               fetcFileContents =
                                {(CLIPFORMAT)(CF_FILECONTENTS), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM|
                                                                                TYMED_HGLOBAL};
    hcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    ZeroMemory(&stgmedDesc, sizeof(STGMEDIUM));

    hr = pDataObj->GetData(&fetcFileDescW, &stgmedDesc);
    if (SUCCEEDED(hr))
    {
        pfgdW = (LPFILEGROUPDESCRIPTORW)GlobalLock(stgmedDesc.hGlobal);
        uiNumFiles = pfgdW->cItems;
        pfdW = &pfgdW->fgd[0];
    }
    else
    {
        IF_FAILEXIT(hr = pDataObj->GetData(&fetcFileDescA, &stgmedDesc));

        fUnicode = FALSE;
        pfgdA = (LPFILEGROUPDESCRIPTORA)GlobalLock(stgmedDesc.hGlobal);
        uiNumFiles = pfgdA->cItems;
        pfdA = &pfgdA->fgd[0];
    }

    // Loop through the contents
    for (uiCurrFile = 0; uiCurrFile < uiNumFiles; ++uiCurrFile)
    {
        if (fUnicode)
        {
            fIsDirectory = (pfdW->dwFlags & FD_ATTRIBUTES) && 
                           (pfdW->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
            IF_NULLEXIT(pwszFileName = PszDupW(pfdW->cFileName));

            ++pfdW;
        }
        else
        {
            fIsDirectory = (pfdA->dwFlags & FD_ATTRIBUTES) && 
                           (pfdA->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
            IF_NULLEXIT(pwszFileName = PszToUnicode(CP_ACP, pfdA->cFileName));

            ++pfdA;
        }

        // if we have a directory, there's no contents for it, just filename, so let's
        // see if the user wants us to make a link...
        if (!fLink && fIsDirectory)
        {
            if(fFirstDirectory)
            {
                int id;
                // Tell the user that he's been a bad user
                id=AthMessageBoxW(m_hwndParent,
                                  MAKEINTRESOURCEW(idsAthena), 
                                  MAKEINTRESOURCEW(idsDropLinkDirs), 
                                  NULL, 
                                  MB_ICONEXCLAMATION|MB_SETFOREGROUND|MB_YESNOCANCEL);
                
                if(id==IDCANCEL)
                {
                    hr=NOERROR;
                    goto exit;
                }
                fLinkDirectories = (id == IDYES);
                fFirstDirectory = FALSE;
            }
            if(fLinkDirectories)
                hr=HrInsertFileFromStgMed(pwszFileName, NULL, TRUE);
        }
        else
        {
            // Since we have the UNICODE filename with pwszFileName, we don't
            // need to worry about making sure stgmedContents is UNICODE.
            STGMEDIUM stgmedContents;
            ZeroMemory(&stgmedContents, sizeof(STGMEDIUM));
        
            fetcFileContents.lindex = uiCurrFile;
            IF_FAILEXIT(hr = pDataObj->GetData(&fetcFileContents, &stgmedContents));
        
            switch (stgmedContents.tymed)
            {
                case TYMED_HGLOBAL:
                case TYMED_ISTREAM:
                    hr=HrInsertFileFromStgMed(pwszFileName, &stgmedContents, fLink);
                    break;
            
                default:
                    AssertSz(FALSE, "Unexpected TYMED");
                    break;
            }
            ReleaseStgMedium(&stgmedContents);
        }
        SafeMemFree(pwszFileName);
    }


exit:
    SetCursor(hcursor);

    if (pfgdA || pfgdW)
        GlobalUnlock(stgmedDesc.hGlobal);

    MemFree(pwszFileName);
    ReleaseStgMedium(&stgmedDesc);

    return hr;
}

static const HELPMAP g_rgCtxMapMailGeneral[] = {
    {chx2, IDH_INSERT_ATTACHMENT_MAKE_SHORTCUT},
    {0,0}};

BOOL CALLBACK CAttMan::InsertFileDlgHookProc(HWND hwnd, UINT msg, WPARAM wParam,LPARAM lParam)
{
    char szTemp[MAX_PATH];
    HRESULT hr;
    
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            HWND hwndParent = GetParent(hwnd);
            
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)(((LPOPENFILENAME)lParam)->lCustData)); 
            
            // Bug 1073: Replace the "Open" button with "Attach"
            if (AthLoadString(idsAttach, szTemp, ARRAYSIZE(szTemp)))
                SetDlgItemText(hwndParent, IDOK, szTemp);
            
            if (AthLoadString(idsInsertAttachment, szTemp, ARRAYSIZE(szTemp)))
                SetWindowText(hwndParent, szTemp);
        
            CenterDialog( hwnd );
            return TRUE;
        }
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgCtxMapMailGeneral);

        case WM_NOTIFY:
            {
                if (CDN_FILEOK == ((LPNMHDR)lParam)->code)
                {
                    AssertSz(sizeof(OPENFILENAMEW) == sizeof(OPENFILENAMEA), "Win9x will give us OPENFILENAMEA");
                    OPENFILENAMEW  *pofn = ((OFNOTIFYW*)lParam)->lpOFN;
                    AssertSz(pofn, "Why didn't we get a OPENFILENAMEA struct???");
                    ATTMANCUSTOM   *pCustom = (ATTMANCUSTOM*)(pofn->lCustData);

                    pCustom->fShortcut = IsDlgButtonChecked(hwnd, chx2);

                    // If we are ANSI and we have mutiple files, then we need to 
                    // convert the entire filepath and pass it back up to our 
                    // caller since shlwapi doesn't handle multiple files during conversion
                    if (!IsWindowUnicode(hwnd))
                    {
                        LPSTR   pszSrc = (LPSTR)pofn->lpstrFile;
                        LPWSTR  pszDest = pCustom->szFiles;
                        WORD    nFilePathLen = (WORD) lstrlen(pszSrc);
                        if (pofn->nFileOffset > nFilePathLen)
                        {
                            pCustom->nFileOffset = nFilePathLen + 1;
                            while (*pszSrc)
                            {
                                DWORD cLenAndNull = lstrlen(pszSrc) + 1;
                                DWORD cchWideAndNull = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, 
                                                                            pszSrc, cLenAndNull, 
                                                                            pszDest, cLenAndNull);
                                // Since the original buffers (custom and lpstrFile) were both static
                                // sized arrays of the same length, we know that pszDest will never be
                                // accessed beyond its end.
                                pszSrc += cLenAndNull;
                                pszDest += cchWideAndNull;
                            }

                            //bobn: 75453 not copying second null
                            *pszDest=0;
                        }
                    }

                    return TRUE;
                }
            }        
    }
    return FALSE;
}

HRESULT CAttMan::HrUpdateToolbar(HWND hwndToolbar)
{
    if (GetFocus() == m_hwndList)
    {
        // if we have focus, kill the edit cut|copy paste btns
        EnableDisableEditToolbar(hwndToolbar, 0);
    }
    return S_OK;
}


HRESULT CAttMan::HrInsertFileFromStgMed(LPWSTR pwszFileName, LPSTGMEDIUM pstgmed, BOOL fMakeLinks)
{
    HRESULT     hr=NOERROR;
    LPSTREAM    pStmToFree = NULL,
                pAttachStm = NULL;
    
    if(!pstgmed)
    {
        AssertSz(fMakeLinks, "this should always be true if there is no stgmedium!");
        fMakeLinks = TRUE;
    }
    else
        switch (pstgmed->tymed)
        {
            case TYMED_HGLOBAL:
                hr=CreateStreamOnHGlobal(pstgmed->hGlobal, TRUE, &pStmToFree);
                if(SUCCEEDED(hr))
                {
                    // NULL out the hglobal do it doesn't get free'd
                    pstgmed->hGlobal=NULL;
                    pAttachStm = pStmToFree;
                }
                break;
        
            case TYMED_ISTREAM:
                pAttachStm = pstgmed->pstm;
                break;
        
            default:
                AssertSz(FALSE, "unexpected tymed");
                hr =  E_UNEXPECTED;
                break;
        }

    if (SUCCEEDED(hr))
        hr = HrAddAttachment(pwszFileName, pAttachStm, fMakeLinks);

    ReleaseObj(pStmToFree);

    return hr;
}
    
    

HRESULT CAttMan::HrBuildHDrop(PDATAOBJINFO *ppdoi)
{
    LPDROPFILES     lpDrop=0;
    LPWSTR         *rgpwszTemp=NULL,
                    pwszPath;
    LPSTR          *rgpszTemp=NULL,
                    pszPath;
    int             cFiles,
                    i;
    LV_ITEMW        lvi;
    ULONG           cb;
    HRESULT         hr = S_OK;
    LPATTACHDATA    lpAttach;

    // Since win9x can't handle unicode names, the fWide parameter in the 
    // DROPFILES struct is ignored. So in the win9x case, we need to do
    // special conversions here when building the HDROP. One thing to note,
    // the temp files that are generated on win9x will already be safe for 
    // the system code page. The temp file names might differ from the actual
    // file name, but the temp file name will be ok.
    BOOL            fWinNT = (VER_PLATFORM_WIN32_NT == g_OSInfo.dwPlatformId);
        
    if(!ppdoi)
        return TraceResult(E_INVALIDARG);

    *ppdoi=NULL;

    cFiles=ListView_GetSelectedCount(m_hwndList);
    if(!cFiles)
        return TraceResult(E_FAIL);    // nothing to build

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem=-1;
    
    // Walk the list and find out how much space we need.
    if (fWinNT)
    {
        IF_NULLEXIT(MemAlloc((LPVOID *)&rgpwszTemp, sizeof(LPWSTR)*cFiles));
        ZeroMemory(rgpwszTemp, sizeof(LPWSTR)*cFiles);
    }
    else
    {
        IF_NULLEXIT(MemAlloc((LPVOID *)&rgpszTemp, sizeof(LPSTR)*cFiles));
        ZeroMemory(rgpszTemp, sizeof(LPSTR)*cFiles);
    }
     
    cFiles = 0;
    cb = sizeof(DROPFILES);

    while(((lvi.iItem=ListView_GetNextItem(m_hwndList, lvi.iItem, 
                                                LVNI_SELECTED|LVNI_ALL))!=-1))
    {
        if (!SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
        {
            hr=E_FAIL;
            goto exit;
        }
                    
        if (!(lpAttach=(LPATTACHDATA)lvi.lParam))
        {
            hr=E_FAIL;
            goto exit;
        }

        IF_FAILEXIT(hr = HrGetTempFile(lpAttach));

        if (fWinNT)
        {
            rgpwszTemp[cFiles] = lpAttach->szTempFile;
            cb+=(lstrlenW(rgpwszTemp[cFiles++]) + 1)*sizeof(WCHAR);
        }
        else
        {
            rgpszTemp[cFiles] = PszToANSI(CP_ACP, lpAttach->szTempFile);
            cb+=(lstrlen(rgpszTemp[cFiles++]) + 1)*sizeof(CHAR);
        }
    }

    //double-null term at end.
    if (fWinNT)
        cb+=sizeof(WCHAR);
    else
        cb+=sizeof(CHAR);
    
    // Allocate the buffer and fill it in.
    IF_NULLEXIT(MemAlloc((LPVOID*) &lpDrop, cb));
    ZeroMemory(lpDrop, cb);

    lpDrop->pFiles = sizeof(DROPFILES);
    lpDrop->fWide = fWinNT;

    // Fill in the path names.
    if (fWinNT)
    {
        pwszPath = (LPWSTR)((BYTE *)lpDrop + sizeof(DROPFILES));
        for(i=0; i<cFiles; i++)
        {
            StrCpyW(pwszPath, rgpwszTemp[i]);
            pwszPath += lstrlenW(rgpwszTemp[i])+1;
        }
    }
    else
    {
        pszPath = (LPSTR)((BYTE *)lpDrop + sizeof(DROPFILES));
        for(i=0; i<cFiles; i++)
        {
            StrCpy(pszPath, rgpszTemp[i]);
            pszPath += lstrlen(rgpszTemp[i])+1;
        }
    }


    // Now allocate the DATAOBJECTINFO struct 
    IF_NULLEXIT(MemAlloc((LPVOID*) ppdoi, sizeof(DATAOBJINFO)));
    
    SETDefFormatEtc((*ppdoi)->fe, CF_HDROP, TYMED_HGLOBAL);
    (*ppdoi)->pData = (LPVOID) lpDrop;
    (*ppdoi)->cbData = cb;
    
    // Don't free the dropfiles struct
    lpDrop = NULL;

exit:
    MemFree(lpDrop);
    MemFree(rgpwszTemp);
    if (rgpszTemp)
    {
        for(i=0; i<cFiles; i++)
            MemFree(rgpszTemp[i]);
        MemFree(rgpszTemp);
    }
    return TraceResult(hr);
}

/*
 * IDropSource::
 */
HRESULT CAttMan::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    DOUTL(8, "IDS::QueryContDrag()");
    if(fEscapePressed)
        return ResultFromScode(DRAGDROP_S_CANCEL);

    if(!(grfKeyState & m_dwDragType))
        return ResultFromScode(DRAGDROP_S_DROP);
    
    return NOERROR;
}

HRESULT CAttMan::GiveFeedback(DWORD dwEffect)
{
    DOUTL(8, "IDS::GiveFeedback()");
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
}


/*
 * HrGetRequiredAction()
 * 
 * Purpose:    this method is called in response to a
 *             drag with the right mouse clicked rather 
 *             than the left.  A context menu is displayed
 */

HRESULT CAttMan::HrGetRequiredAction(DWORD *pdwEffect, POINTL pt)
{
    // Pop up the context menu.
    //
    HMENU       hMenu;
    UINT        idCmd;
    HRESULT     hr = E_FAIL;
    
    *pdwEffect = DROPEFFECT_NONE;

    Assert(m_hwndList);

    hMenu = LoadPopupMenu(IDR_ATTACHMENT_DRAGDROP_POPUP);
    if (!hMenu)
        goto cleanup;

    MenuUtil_SetPopupDefault(hMenu, ID_MOVE);

    idCmd = TrackPopupMenuEx(hMenu, TPM_RETURNCMD|TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                                pt.x, pt.y, m_hwndList, NULL);

    switch(idCmd)
    {
        case ID_MOVE:
            *pdwEffect = DROPEFFECT_MOVE;
            break;
        case ID_COPY:
            *pdwEffect = DROPEFFECT_COPY;
            break;
        case ID_CREATE_SHORTCUT:
            *pdwEffect = DROPEFFECT_LINK;
            break;
        default:
            // cancelled
            goto cleanup;
    }

    hr = S_OK;

cleanup:
    if(hMenu)
        DestroyMenu(hMenu);

    return hr;
}

/*
 * It is critical that any client of the Attman calls HrClose to drop it's refcounts.
 *
 */
HRESULT CAttMan::HrClose()
{
    HrUnload();

#if 0
    if(m_fDropTargetRegister)
        {
        Assert(m_hwndList && IsWindow(m_hwndList));
        RevokeDragDrop(m_hwndList);
        CoLockObjectExternal((LPUNKNOWN)(LPDROPTARGET)this, FALSE, TRUE);
        }
#endif

    return S_OK;
}

//Adds a new attach to m_rgpAttach and places the new attach in a proper hole
HRESULT CAttMan::HrAllocNewEntry(LPATTACHDATA pAttach)
{
    ULONG           uAttach;

    if (m_cAlloc==m_cAttach)
    {
        DOUTL(4, "HrGrowAttachStruct:: Growing Table");

        // grow time!!
        m_cAlloc+=CACHE_GROW_SIZE;

        if (!MemRealloc((LPVOID *)&m_rgpAttach, sizeof(LPATTACHDATA)*m_cAlloc))
            return E_OUTOFMEMORY;

        // zeroinit new memory
        ZeroMemory(&m_rgpAttach[m_cAttach], sizeof(LPATTACHDATA)*CACHE_GROW_SIZE);
    }

    // find a hole to put the new data into
    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
        if (m_rgpAttach[uAttach]==NULL)
        {
            m_rgpAttach[uAttach]=pAttach;
            break;
        }

    AssertSz(uAttach!=m_cAlloc, "Woah! we went off the end!");
    m_cAttach++;
    return S_OK;
}

// Only used when the function is adding attachs from a IMimeMessage
HRESULT CAttMan::HrAddData(HBODY hAttach)
{
    LPATTACHDATA    pAttach=0;
    LPMIMEBODY      pBody=0;
    HRESULT         hr;

    Assert(hAttach);
    Assert(m_pMsg);

    hr = HrAttachDataFromBodyPart(m_pMsg, hAttach, &pAttach);
    if (!FAILED(hr))
    {
        if (m_fDeleteVCards && StrStrIW(PathFindExtensionW(pAttach->szFileName), L".vcf"))
            return S_OK;

        hr = HrAllocNewEntry(pAttach);
        if (!FAILED(hr))
            return S_OK;        // don't free pAttach as it's owned by the table now
        MemFree(pAttach);
    }
    return S_OK;
}

// Only used when the function is adding attachs from outside of an IMimeMessage
HRESULT CAttMan::HrAddData(LPWSTR lpszPathName, LPSTREAM pstm, LPATTACHDATA *ppAttach)
{
    LPATTACHDATA    pAttach;
    HRESULT         hr;

    hr = HrAttachDataFromFile(pstm, lpszPathName, &pAttach);
    if (!FAILED(hr))
    {
        hr = HrAllocNewEntry(pAttach);    
        if (!FAILED(hr))
        {
            if (ppAttach)
                *ppAttach=pAttach;
            return S_OK;                // don't free pAttach as it's owned by the table now
        }
        MemFree(pAttach);
    }
    return hr;
}

HRESULT CAttMan::HrFreeAllData()
{
    ULONG   uAttach;

    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
        if (m_rgpAttach[uAttach])
        {
            HrFreeAttachData(m_rgpAttach[uAttach]);
            m_rgpAttach[uAttach] = NULL;
        }

    SafeMemFree(m_rgpAttach);
    m_cAlloc=0;
    m_cAttach=0;
    m_iVCard = -1;
    return NOERROR;
}



HRESULT CAttMan::HrDoVerb(LPATTACHDATA lpAttach, INT nVerb)
{
    HRESULT     hr;
    ULONG       uVerb = AV_MAX;

    if (!lpAttach)
        return E_INVALIDARG;

    switch (nVerb)
    {
        case ID_SAVE_ATTACH_AS:
            uVerb = AV_SAVEAS;
            break;

        case ID_OPEN:
            uVerb = AV_OPEN;
            break;

        case ID_PRINT:
            uVerb = AV_PRINT;
            break;

        case ID_QUICK_VIEW:
            uVerb = AV_QUICKVIEW;
            break;
        
        default:
            AssertSz(0, "BAD ARGUMENT");
            return E_INVALIDARG;
    }

    hr = HrDoAttachmentVerb(m_hwndParent, uVerb, m_pMsg, lpAttach);
    
    if (FAILED(hr) && hr!=hrUserCancel)
        AthMessageBoxW(m_hwndParent,  
                       MAKEINTRESOURCEW(idsAthena),  
                       MAKEINTRESOURCEW(idsErrCmdFailed), 
                       NULL, MB_OK|MB_ICONEXCLAMATION);

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistMime::Load
HRESULT CAttMan::Load(LPMIMEMESSAGE pMsg)
{
    HRESULT hr;

    if(!pMsg)
        return E_INVALIDARG;

    HrUnload();

    ReplaceInterface(m_pMsg, pMsg);

    hr=HrBuildAttachList();
    if (FAILED(hr))
        goto error;


    hr=HrFillListView();
    if (ListView_GetItemCount(m_hwndList) > 0)
    {
        // if we went from 0->1 then select the first item
        ListView_SelectItem(m_hwndList, 0);
    }

    HrResizeParent();

    m_fDirty = FALSE;
error:
    return hr;
}

HRESULT CAttMan::CheckAttachNameSafeWithCP(CODEPAGEID cpID)
{
    LPATTACHDATA *currAttach = m_rgpAttach;
    HRESULT hr = S_OK;

    for (ULONG uAttach = 0; uAttach<m_cAlloc; uAttach++, currAttach++)
    {
        if (*currAttach)
        {
            IF_FAILEXIT(hr = HrSafeToEncodeToCP((*currAttach)->szFileName, cpID));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }
    }

exit:
    return hr;
}

// IPersistMime::Save
HRESULT CAttMan::Save(LPMIMEMESSAGE pMsg, DWORD dwFlags)
{
    ULONG   uAttach;
    LPATTACHDATA *currAttach = m_rgpAttach;
    HRESULT hr = S_OK;

    for (uAttach=0; uAttach<m_cAlloc; uAttach++)
    {
        if (*currAttach)
        {
            HBODY           currHAttach = (*currAttach)->hAttach;
            LPMIMEMESSAGEW  pMsgW = NULL;
            LPWSTR          pszFileName = (*currAttach)->szFileName;
            LPSTREAM        lpStrmPlaceHolder = (*currAttach)->pstm,
                            lpstrm = NULL;
            BOOL            fAttachFile = TRUE;

            if (SUCCEEDED(pMsg->QueryInterface(IID_IMimeMessageW, (LPVOID*)&pMsgW)))
            {
                //If attachment at load time (i.e. from m_pMsg)
                if (currHAttach)
                {
                    LPMIMEBODY pBody = NULL;
                    if (S_OK == m_pMsg->BindToObject(currHAttach, IID_IMimeBody, (LPVOID *)&pBody))
                    {
                        if (pBody->GetData(IET_INETCSET, &lpstrm)==S_OK)
                            lpStrmPlaceHolder = lpstrm;
                        else
                            fAttachFile = FALSE;

                        ReleaseObj(pBody);
                    }
                }

                //If attachment was added after load time
                if (!fAttachFile || FAILED(pMsgW->AttachFileW(pszFileName, lpStrmPlaceHolder, NULL)))
                    hr = E_FAIL;

                ReleaseObj(lpstrm);
                ReleaseObj(pMsgW);
            }
            else
                hr = E_FAIL;
        }
        currAttach++;
    }

    if (FAILED(hr))
    {
        if (AthMessageBoxW( m_hwndParent,
                            MAKEINTRESOURCEW(idsAthena),
                            MAKEINTRESOURCEW(idsSendWithoutAttach),
                            NULL, MB_YESNO|MB_ICONEXCLAMATION )==IDYES)
            hr = S_OK;
        else
            hr = MAPI_E_USER_CANCEL;
    }
    return hr;
}


// IPersist::GetClassID
HRESULT CAttMan::GetClassID(CLSID *pClsID)
{
    //TODO: If ever expose, should return a valid ID
	return E_NOTIMPL;
}


HRESULT CAttMan::HrSaveAs(LPATTACHDATA lpAttach)
{
    HRESULT         hr = S_OK;
    OPENFILENAMEW   ofn;
    WCHAR           szTitle[CCHMAX_STRINGRES],
                    szFilter[CCHMAX_STRINGRES],
                    szFile[MAX_PATH];

    *szFile=0;
    *szFilter=0;
    *szTitle=0;

    Assert (*lpAttach->szFileName);
    StrCpyNW(szFile, lpAttach->szFileName, MAX_PATH);

    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwndParent;
    AthLoadStringW(idsFilterAttSave, szFilter, ARRAYSIZE(szFilter));
    ReplaceCharsW(szFilter, _T('|'), _T('\0'));
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    AthLoadStringW(idsSaveAttachmentAs, szTitle, ARRAYSIZE(szTitle));
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    // Show SaveAs Dialog
    if (HrAthGetFileNameW(&ofn, FALSE) != S_OK)
    {
        hr = hrUserCancel;
        goto error;
    }

    // Verify the Attachment's Stream
    hr=HrSave(lpAttach->hAttach, szFile);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}


HRESULT CAttMan::HrGetTempFile(LPATTACHDATA lpAttach)
{
    HRESULT         hr;

    if (*lpAttach->szTempFile)
        return S_OK;

    // Since win9x can't handle filenames very well, let's try to handle this
    // by converting the temp names to something workable in win9x.
    if (VER_PLATFORM_WIN32_NT == g_OSInfo.dwPlatformId)
    {
        if (!FBuildTempPathW(lpAttach->szFileName, lpAttach->szTempFile, ARRAYSIZE(lpAttach->szTempFile), FALSE))
        {
            hr = E_FAIL;
            goto error;
        }
    }
    else
    {
        // Since we are on win95, the temp path will never be bad ANSI. Don't need to bother
        // converting to ANSI and back to UNICODE 
        BOOL fSucceeded = FBuildTempPathW(lpAttach->szFileName, lpAttach->szTempFile, ARRAYSIZE(lpAttach->szTempFile), FALSE);
        if (!fSucceeded)
        {
            hr = E_FAIL;
            goto error;
        }
    }

    if (lpAttach->hAttach == NULL && lpAttach->pstm)
    {
        // if no attachment, but just stream data
        hr = WriteStreamToFileW(lpAttach->pstm, lpAttach->szTempFile, CREATE_NEW, GENERIC_WRITE);
    }
    else
    {
        hr=HrSave(lpAttach->hAttach, lpAttach->szTempFile);
    }

    if (FAILED(hr))
        goto error;

error:
    if (FAILED(hr))
    {
        // Null out temp file as we didn't really create it
        *(lpAttach->szTempFile)=0;
    }
    return hr;
}


HRESULT CAttMan::HrCleanTempFile(LPATTACHDATA lpAttach)
{

    if ((lpAttach->szTempFile) && ('\0' != lpAttach->szTempFile[0]))
    {
        // If the file was launched, don't delete the temp file if the process still has it open
        if (lpAttach->hProcess)
        {
            DWORD dwState = WaitForSingleObject (lpAttach->hProcess, 0);
            if (dwState == WAIT_OBJECT_0)
                DeleteFileWrapW(lpAttach->szTempFile);
        }
        else
            DeleteFileWrapW(lpAttach->szTempFile);
    }

    *lpAttach->szTempFile = NULL;
    lpAttach->hProcess=NULL;
    return NOERROR;
}


HRESULT CAttMan::HrSave(HBODY hAttach, LPWSTR lpszFileName)
{
    IMimeBodyW     *pBody = NULL;
    HRESULT         hr;

    hr = m_pMsg->BindToObject(hAttach, IID_IMimeBodyW, (LPVOID *)&pBody);

    if (SUCCEEDED(hr))
        hr = pBody->SaveToFileW(IET_INETCSET, lpszFileName);

    ReleaseObj(pBody);
    return hr;
}


HRESULT CAttMan::HrCmdEnabled(UINT idm, LPBOOL pbEnable)
{
    Assert (pbEnable);
    return S_FALSE;
}


HRESULT CAttMan::HrIsDragSource()
{
    return (m_fDragSource ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\attman.h ===
// ==============================================================================
// MIMEOLE'd Attachment Manger v2. - brettm
// ==============================================================================
#ifndef __ATTMAN_H
#define __ATTMAN_H

// ==============================================================================
// Depends On
// ==============================================================================
#include "mimeolep.h"

#define ATTN_RESIZEPARENT        10000

// from common\dragdrop.h
typedef struct tagDATAOBJINFO *PDATAOBJINFO;

// ==============================================================================
// Defines
// ==============================================================================
//#define BASE_ATTACH_CMD_ID       (ULONG)(WM_USER + 1)

// ==============================================================================
// CAttMan Definition
// ==============================================================================
class CAttMan :
    public IDropSource,
    public IPersistMime
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // *** IDropSource methods ***
    HRESULT STDMETHODCALLTYPE QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);
    HRESULT STDMETHODCALLTYPE GiveFeedback(DWORD dwEffect);

    // IPersistMime
    HRESULT STDMETHODCALLTYPE Load(LPMIMEMESSAGE pMsg);
    HRESULT STDMETHODCALLTYPE Save(LPMIMEMESSAGE pMsg, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClsID);

    CAttMan ();
    ~CAttMan ();

    // Load function, unload and close
    HRESULT HrInit (HWND hwnd, BOOL fReadOnly, BOOL fDeleteVCards, BOOL fAllowUnsafe);
    HRESULT HrUnload();
    HRESULT HrClose();

    HRESULT HrIsDragSource();

    HRESULT HrGetAttachCount(ULONG *pcAttach);
    HRESULT HrIsDirty();
    HRESULT HrClearDirtyFlag();

    LPTSTR GetUnsafeAttachList();
    ULONG GetUnsafeAttachCount();

    // handling of windows messages
    BOOL WMCommand(HWND hwndCmd, INT id, WORD wCmd);
    BOOL WMNotify(int idFrom, NMHDR *pnmhdr);
    BOOL WMContextMenu (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    static BOOL CALLBACK InsertFileDlgHookProc(HWND, UINT, WPARAM, LPARAM);

    // handlign of WM_DROPFILE
    HRESULT HrDropFiles(HDROP hDrop, BOOL fMakeLinks);

    // toobar and menu update
    HRESULT HrUpdateToolbar(HWND);

    // external sizing
    HRESULT HrGetHeight(INT cxWidth, ULONG *pcy);
    HRESULT HrSetSize (RECT *prc);

    HWND Hwnd() {return m_hwndList;};

    // enable flags for the browser menus
    HRESULT HrCmdEnabled(UINT idm, LPBOOL pbEnable);
    HRESULT HrFVCard();
    HRESULT HrShowVCardProp();
    HRESULT HrCheckVCardExists(BOOL fMail);
    HRESULT GetTabStopArray(HWND *rgTSArray, int *pcArrayCount);
    HRESULT HrAddAttachment (LPWSTR lpszPathName, LPSTREAM pstm, BOOL fShortCut);
    HRESULT HrSwitchView(DWORD dwView);
    HRESULT HrGetRequiredAction(DWORD *pdwEffect, POINTL pt);
    HRESULT HrDropFileDescriptor(LPDATAOBJECT pDataObj, BOOL fLink);
    HRESULT CheckAttachNameSafeWithCP(CODEPAGEID cpID);

private:
    LPMIMEMESSAGE   m_pMsg;
    HIMAGELIST      m_himlSmall;
    HIMAGELIST      m_himlLarge;
    ULONG           m_cRef;
    HWND            m_hwndList,
                    m_hwndParent;   // we stuff this for UI when there's no m_hwndList
    CLIPFORMAT      m_cfAccept;
    DWORD           m_dwDragType,
                    m_grfKeyState,
                    m_dwEffect;
    int             m_cxMaxText,
                    m_cyHeight;
    BOOL            m_fReadOnly             :1,
                    m_fDirty                :1,
                    m_fDragSource           :1,
                    m_fDropTargetRegister   :1,
                    m_fShowingContext       :1,
                    m_fRightClick           :1,
                    m_fModal                :1,
                    m_fDeleteVCards         :1,
                    m_fWarning              :1,
                    m_fSafeOnly             :1;
    LPATTACHDATA    *m_rgpAttach;
    ULONG           m_cAttach,
                    m_cAlloc,
                    m_cUnsafeAttach;
    HMENU           m_hMenuSaveAttach;
    INT             m_iVCard;
    LPTSTR          m_szUnsafeAttachList;


    // Listview stuff
    HRESULT HrInitImageLists();
    HRESULT HrFillListView();
    HRESULT HrCreateListView(HWND hwnd);
    HRESULT HrAddToList(LPATTACHDATA pAttach, BOOL fIniting);
    HRESULT HrBuildAttachList();

    // menu stuff
    HRESULT HrGetAttMenu(HMENU *phMenu, BOOL fContextMenu);
    HRESULT HrCleanMenu(HMENU hMenu);
    HRESULT HrGetAttachmentById(HMENU hMenu, ULONG id, HBODY *phBody);
    HRESULT HrGetItemTextExtent(HWND hwnd, LPSTR szDisp, LPSIZE pSize);
    HRESULT HrAttachFromMenuID(int idm, LPATTACHDATA *ppAttach);

    HRESULT HrInsertFile();
    HRESULT HrRemoveAttachments();
    HRESULT HrRemoveAttachment(int ili);
    HRESULT HrDeleteAttachments();

    HRESULT HrExecFile(int iVerb);

    HRESULT HrInsertFileFromStgMed(LPWSTR pwszFileName, LPSTGMEDIUM pstgmed, BOOL fLink);
    
    HRESULT HrBeginDrag();
    HRESULT HrBuildHDrop(PDATAOBJINFO *ppdoi);

    HRESULT HrResizeParent();
    HRESULT HrDblClick(int idFrom, NMHDR *pnmhdr);

    HRESULT HrCheckVCard();

    // data table
    HRESULT HrFreeAllData();
    HRESULT HrAddData(HBODY hAttach);
    HRESULT HrAddData(LPWSTR lpszPathName, LPSTREAM pstm, LPATTACHDATA *ppAttach);
    HRESULT HrAllocNewEntry(LPATTACHDATA pAttach);

    // Attachment commands
    HRESULT HrDoVerb(LPATTACHDATA pAttach, INT nVerb);
    HRESULT HrSaveAs(LPATTACHDATA lpAttach);
    HRESULT HrGetTempFile(LPATTACHDATA lpAttach);
    HRESULT HrCleanTempFile(LPATTACHDATA lpAttach);
    HRESULT HrSave(HBODY hAttach, LPWSTR lpszFileName);

};

typedef CAttMan *LPATTMAN;

#endif __ATTMAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\columns.cpp ===
#include "pch.hxx"
#include <shlwapi.h>
#include "resource.h"
#include "msoeobj.h"
#include "strconst.h"
#include "columns.h"
#include "error.h"
#include "imagelst.h"
#include "msgview.h"
#include "shlwapip.h" 
#include "goptions.h"
#include "demand.h"
#include "menures.h"

const COLUMN_DATA c_rgColumnData[COLUMN_MAX] =
{
    /*  COLUMN_TO           */  { idsTo,            155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_FROM         */  { idsFrom,          155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_SUBJECT      */  { idsSubject,       280, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_RECEIVED     */  { idsReceived,      110, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_SENT         */  { idsSent,          110, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_SIZE         */  { idsSize,           75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_FOLDER       */  { idsFolder,        155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_TOTAL        */  { idsTotal,          75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_UNREAD       */  { idsUnread,         75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_NEW          */  { idsNew,            75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_DESCRIPTION  */  { idsDescription,   250, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_LAST_UPDATED */  { idsLastUpdated,   155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_WASTED_SPACE */  { idsWastedSpace,    75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_ACCOUNT      */  { idsAccount,       155, LVCFMT_LEFT,  0 },                 
    /*  COLUMN_LINES        */  { idsColLines,       75, LVCFMT_RIGHT, 0 },                 
    /*  COLUMN_PRIORITY     */  { idsColPriority,    19, LVCFMT_LEFT,  iiconHeaderPri },    
    /*  COLUMN_ATTACHMENT   */  { idsColAttach,      22, LVCFMT_LEFT,  iiconHeaderAttach }, 
    /*  COLUMN_SHOW         */  { idsShow,           39, LVCFMT_LEFT,  IICON_TEXTHDR },
    /*  COLUMN_DOWNLOAD     */  { idsColDownload,   155, LVCFMT_LEFT,  0 }, 
    /*  COLUMN_NEWSGROUP    */  { idsNewsgroup,     155, LVCFMT_LEFT,  0 }, 
    /*  COLUMN_FLAG         */  { idsFlag,           25, LVCFMT_LEFT,  iiconHeaderFlag },
    /*  COLUMN_SUBSCRIBE    */  { idsSubscribe,      59, LVCFMT_LEFT,  IICON_TEXTHDR },
    /*  COLUMN_DOWNLOADMSG  */  { idsColDownloadMsg, 23, LVCFMT_LEFT,  iiconHeaderDownload },
    /*  COLUMN_THREADSTATE  */  { idsColThreadState, 29, LVCFMT_LEFT,  iiconHeaderThreadState }
};


const COLUMN_SET c_rgColDefaultMail[] =
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FLAG,          COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_SENT,          0, -1 },
    { COLUMN_TO,            0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultOutbox[] = 
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_TO,            COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_RECEIVED,      0, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultNews[] =
{
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_SIZE,          COLFLAG_VISIBLE, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_LINES,         0, -1 }
};


const COLUMN_SET c_rgColDefaultIMAP[] =
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FLAG,          COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_SENT,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_TO,            0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultIMAPOutbox[] = 
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_TO,            COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_RECEIVED,      0, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_FIXED_WIDTH, -1 }
};


const COLUMN_SET c_rgColDefaultFind[] =
{
    { COLUMN_PRIORITY,      COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FLAG,          COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE, -1 },
    { COLUMN_FOLDER,        COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       0, -1 },
    { COLUMN_SENT,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_TO,            0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_LINES,         0, -1 }
};


const COLUMN_SET c_rgColDefaultNewsAccount[] =
{
    { COLUMN_NEWSGROUP,     COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultIMAPAccount[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultLocalStore[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultNewsSub[] =
{
    { COLUMN_NEWSGROUP,     COLFLAG_VISIBLE, -1 },
    { COLUMN_DESCRIPTION,   COLFLAG_VISIBLE, -1 },
};


const COLUMN_SET c_rgColDefaultImapSub[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultOffline[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultPickGrp[] =
{
    { COLUMN_NEWSGROUP,     COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultHTTPMail[] =
{
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_FROM,          COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_RECEIVED,      COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 }
};

const COLUMN_SET c_rgColDefaultHTTPMailAccount[] =
{
    { COLUMN_FOLDER,        COLFLAG_VISIBLE, -1 },
    { COLUMN_UNREAD,        COLFLAG_VISIBLE, -1 },
    { COLUMN_TOTAL,         COLFLAG_VISIBLE, -1 },
    { COLUMN_DOWNLOAD,      COLFLAG_VISIBLE, -1 },
};

const COLUMN_SET c_rgColDefaultHTTPMailOutbox[] =
{
    { COLUMN_ATTACHMENT,    COLFLAG_VISIBLE | COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_TO,            COLFLAG_VISIBLE, -1 },
    { COLUMN_SUBJECT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_SENT,          COLFLAG_VISIBLE | COLFLAG_SORT_ASCENDING, -1 },
    { COLUMN_ACCOUNT,       COLFLAG_VISIBLE, -1 },
    { COLUMN_FROM,          0, -1 },
    { COLUMN_SIZE,          0, -1 },
    { COLUMN_RECEIVED,      0, -1 },
    { COLUMN_FLAG,          COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_THREADSTATE,   COLFLAG_FIXED_WIDTH, -1 },
    { COLUMN_DOWNLOADMSG,   COLFLAG_FIXED_WIDTH, -1 }
};

// NOTE - Keep this in the same order as COLUMN_SET_TYPE enumeration. 
const COLUMN_SET_INFO c_rgColumnSetInfo[COLUMN_SET_MAX] =
{
    { COLUMN_SET_MAIL,              ARRAYSIZE(c_rgColDefaultMail),              c_rgColDefaultMail,             c_szRegMailColsIn,          TRUE },
    { COLUMN_SET_OUTBOX,            ARRAYSIZE(c_rgColDefaultOutbox),            c_rgColDefaultOutbox,           c_szRegMailColsOut,         TRUE },
    { COLUMN_SET_NEWS,              ARRAYSIZE(c_rgColDefaultNews),              c_rgColDefaultNews,             c_szRegNewsCols,            TRUE },
    { COLUMN_SET_IMAP,              ARRAYSIZE(c_rgColDefaultIMAP),              c_rgColDefaultIMAP,             c_szRegIMAPCols,            TRUE },
    { COLUMN_SET_IMAP_OUTBOX,       ARRAYSIZE(c_rgColDefaultIMAPOutbox),        c_rgColDefaultIMAPOutbox,       c_szRegIMAPColsOut,         TRUE },
    { COLUMN_SET_FIND,              ARRAYSIZE(c_rgColDefaultFind),              c_rgColDefaultFind,             c_szRegFindPopCols,         TRUE },
    { COLUMN_SET_NEWS_ACCOUNT,      ARRAYSIZE(c_rgColDefaultNewsAccount),       c_rgColDefaultNewsAccount,      c_szRegAccountNewsCols,     FALSE },
    { COLUMN_SET_IMAP_ACCOUNT,      ARRAYSIZE(c_rgColDefaultIMAPAccount),       c_rgColDefaultIMAPAccount,      c_szRegAccountIMAPCols,     FALSE },
    { COLUMN_SET_LOCAL_STORE,       ARRAYSIZE(c_rgColDefaultLocalStore),        c_rgColDefaultLocalStore,       c_szRegLocalStoreCols,      FALSE },
    { COLUMN_SET_NEWS_SUB,          ARRAYSIZE(c_rgColDefaultNewsSub),           c_rgColDefaultNewsSub,          c_szRegNewsSubCols,         FALSE },
    { COLUMN_SET_IMAP_SUB,          ARRAYSIZE(c_rgColDefaultImapSub),           c_rgColDefaultImapSub,          c_szRegImapSubCols,         FALSE },
    { COLUMN_SET_OFFLINE,           ARRAYSIZE(c_rgColDefaultOffline),           c_rgColDefaultOffline,          c_szRegOfflineCols,         FALSE },
    { COLUMN_SET_PICKGRP,           ARRAYSIZE(c_rgColDefaultPickGrp),           c_rgColDefaultPickGrp,          NULL,                       FALSE },
    { COLUMN_SET_HTTPMAIL,          ARRAYSIZE(c_rgColDefaultHTTPMail),          c_rgColDefaultHTTPMail,         c_szRegHTTPMailCols,        TRUE },
    { COLUMN_SET_HTTPMAIL_ACCOUNT,  ARRAYSIZE(c_rgColDefaultHTTPMailAccount),   c_rgColDefaultHTTPMailAccount,  c_szRegHTTPMailAccountCols, FALSE },
    { COLUMN_SET_HTTPMAIL_OUTBOX,   ARRAYSIZE(c_rgColDefaultHTTPMailOutbox),    c_rgColDefaultHTTPMailOutbox,   c_szRegHTTPMailColsOut,     TRUE },
};


/////////////////////////////////////////////////////////////////////////////
// CColumns
//

CColumns::CColumns() 
{
    m_cRef = 1;
    m_fInitialized = FALSE;
    m_pColumnSet = NULL;
    m_cColumns = 0;
    m_idColumnSort = COLUMN_SUBJECT;
    m_fAscending = TRUE;
}

CColumns::~CColumns()
{
    SafeMemFree(m_pColumnSet);
}


//
//  FUNCTION:   CColumns::Init()
//
//  PURPOSE:    Initializes the class with the listview and column set type
//              that will be used later.
//
//  PARAMETERS: 
//      [in] hwndList - Handle of the ListView window that we will manage 
//                      columns for.
//      [in] type     - Type of column set to apply to this window.
//
//  RETURN VALUE:
//      S_OK - The data was groovy
//      E_INVALIDARG - The data was heinous
//
HRESULT CColumns::Initialize(HWND hwndList, COLUMN_SET_TYPE type)
{
    // Verify what was given to us
    if (!IsWindow(hwndList))
    {
        AssertSz(!IsWindow(hwndList), "CColumns::Init() - Called with an invalid window handle.");
        return (E_INVALIDARG);
    }

    if (type >= COLUMN_SET_MAX)
    {
        AssertSz(type >= COLUMN_SET_MAX, "CColumns::Init() - Called with an invalid column set type.");
        return (E_INVALIDARG);
    }

    // Save the information for later
    m_wndList.Attach(hwndList);
    m_type = type;
    m_hwndHdr = ListView_GetHeader(m_wndList);
    m_fInitialized = TRUE;

    return (S_OK);
}


//
//  FUNCTION:   CColumns::ApplyColumns()
//
//  PURPOSE:    Takes the current column set and applies it to the ListView
//              that was provided in the call to Init().
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CColumns::ApplyColumns(COLUMN_LOAD_TYPE type, LPBYTE pb, DWORD cb)
{   
    HKEY hkey;
    DWORD cbSize, dwType;
    LPBYTE pbT = NULL;
    COLUMN_PERSIST_INFO *pInfo = (COLUMN_PERSIST_INFO *) pb;
    const COLUMN_SET *rgColumns = NULL;
    DWORD             cColumns = 0;

    // Verify that we have been initialized first
    if (!m_fInitialized)
    {
        AssertSz(m_fInitialized, "CColumns::ApplyColumns() - Class has not yet been initialized.");
        return (E_UNEXPECTED);
    }

    // Double check the listview didn't go away
    Assert(IsWindow(m_wndList));

    // Check to see what we're supposed to do
    if (type == COLUMN_LOAD_REGISTRY)
    {
        Assert(pInfo == NULL);

        if (ERROR_SUCCESS == AthUserOpenKey(c_szRegPathColumns, KEY_READ, &hkey))
        {
            cbSize = 0;
            if (c_rgColumnSetInfo[m_type].pszRegValue != NULL &&
                ERROR_SUCCESS == RegQueryValueEx(hkey, c_rgColumnSetInfo[m_type].pszRegValue, NULL, &dwType, NULL, &cbSize) &&
                dwType == REG_BINARY &&
                cbSize > 0)
            {
                if (MemAlloc((void **)&pbT, cbSize))
                {
                    if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_rgColumnSetInfo[m_type].pszRegValue, NULL, &dwType, pbT, &cbSize))
                        pInfo = (COLUMN_PERSIST_INFO *) pbT;
                }
            }

            RegCloseKey(hkey);
        }

        if (pInfo != NULL)
            type = COLUMN_LOAD_BUFFER;
        else
            type = COLUMN_LOAD_DEFAULT;
    }

    if (type == COLUMN_LOAD_BUFFER)
    {
        Assert(pInfo);
        if (pInfo->dwVersion == COLUMN_PERSIST_VERSION)
        {
            rgColumns = pInfo->rgColumns;
            cColumns = pInfo->cColumns;
        }
        else
        {
            // Do the default
            type = COLUMN_LOAD_DEFAULT;
        }
    }

    if (type == COLUMN_LOAD_DEFAULT)
    {
        // Verify some person didn't mess up the c_rgColumnSetInfo array.
        Assert(c_rgColumnSetInfo[m_type].type == m_type);

        // We couldn't load from the registry, so instead use the defaults.
        rgColumns = c_rgColumnSetInfo[m_type].rgColumns;
        cColumns = c_rgColumnSetInfo[m_type].cColumns;
    }

    // Update the listview to use these new columns
    _SetListViewColumns(rgColumns, cColumns);

    if (pbT != NULL)
        MemFree(pbT);

    return (S_OK);
}


HRESULT CColumns::Save(LPBYTE pBuffer, DWORD *pcb)
{
    COLUMN_PERSIST_INFO *pInfo;
    DWORD dwSize;
    BYTE rgBuffer[256];

    pInfo = (COLUMN_PERSIST_INFO *) rgBuffer;

    // Collect the information needed to get a COLUMN_PERSIST_INFO struct put
    // together.  First allocate a struct big enough.
    dwSize = sizeof(COLUMN_PERSIST_INFO) + (sizeof(COLUMN_SET) * (m_cColumns - 1));

    // Set the basic information
    pInfo->dwVersion = COLUMN_PERSIST_VERSION;
    pInfo->cColumns = m_cColumns;

    // We want to save the _ordered_ version of the columns
    DWORD rgOrder[COLUMN_MAX];

    // Get the count of columns in the header.  Make sure that matches
    // what we think we have.
#ifdef DEBUG
    DWORD cOrder;
    cOrder = Header_GetItemCount(m_hwndHdr);
    Assert(m_cColumns == cOrder);
#endif

    // The columns might have been reordered by the user, so get the order 
    // arrray from the ListView
    if (0 == (Header_GetOrderArray(m_hwndHdr, m_cColumns, rgOrder)))
        return (E_FAIL);

    // Now loop through out current column set and copy it to the structure
    COLUMN_SET *pColumnDst;
    DWORD       iColumn;
    for (iColumn = 0, pColumnDst = pInfo->rgColumns; iColumn < m_cColumns; iColumn++, pColumnDst++)
    {
        *pColumnDst = m_pColumnSet[rgOrder[iColumn]];
        if (pColumnDst->id == m_idColumnSort)
        {
            // Clear out any old flags
            pColumnDst->flags &= ~(COLFLAG_SORT_ASCENDING | COLFLAG_SORT_DESCENDING);

            // Add the new one
            pColumnDst->flags |= (m_fAscending ? COLFLAG_SORT_ASCENDING : COLFLAG_SORT_DESCENDING);
        }
        else
        {
            pColumnDst->flags &= ~(COLFLAG_SORT_ASCENDING | COLFLAG_SORT_DESCENDING);
        }
    }

    if (pBuffer == NULL)
    {
        Assert(pcb == NULL);

        AthUserSetValue(c_szRegPathColumns, c_rgColumnSetInfo[m_type].pszRegValue, REG_BINARY, (LPBYTE) pInfo, dwSize);
        return(S_OK);
    }
    else if (dwSize <= *pcb)
    {
        CopyMemory(pBuffer, (LPBYTE) pInfo, dwSize);
        *pcb = dwSize;
        return (S_OK);
    }
    else
    {
        return E_INVALIDARG;
    }
}


//
//  FUNCTION:   CColumns::_SetListViewColumns()
//
//  PURPOSE:    Takes the column set provided and inserts those columns into
//              the ListView.
//
//  PARAMETERS: 
//      [in] rgColumns - Array of columns to insert into the ListView
//      [in] cColumns  - Number of columns in rgColumns
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CColumns::_SetListViewColumns(const COLUMN_SET *rgColumns, DWORD cColumns)
{
    LV_COLUMN lvc;
    TCHAR     sz[CCHMAX_STRINGRES];

    // Set up the LV_COLUMN structure
    lvc.pszText = sz;

    // Remove any existing columns
    while (ListView_DeleteColumn(m_wndList, 0))
        ;

    // Reset this
    m_idColumnSort = COLUMN_MAX;

    // Loop through all of the columns in the provided rgColumns looking for
    // any that have an icon and is visible.  
    //
    // We have to do this because the listview requires that column zero have
    // text.  If the user doesn't want column zero to have text, ie attachment
    // column, then we insert that column as column 1, and use  
    // ListView_SetColumnOrderArray later to make it appear as if column zero
    // was the image-only column. -- steveser

    DWORD iColumn;
    DWORD iColumnSkip = cColumns;
    DWORD iInsertPos = 0;
    const COLUMN_SET *pColumn;

    for (iColumn = 0, pColumn = rgColumns; iColumn < cColumns; iColumn++, pColumn++)
    {
        if ((0 == c_rgColumnData[pColumn->id].iIcon) && (pColumn->flags & COLFLAG_VISIBLE))
        {
            iColumnSkip = iColumn;            

            // Insert this column into the ListView as column zero
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.iSubItem = 0;
            lvc.fmt = c_rgColumnData[pColumn->id].format;

            LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName, 
                       sz, ARRAYSIZE(sz));

            // If the column width provided is -1, then it hasn't been 
            // customized yet so use the default.
            if (pColumn->cxWidth == -1)
                lvc.cx = c_rgColumnData[pColumn->id].cxWidth;
            else
                lvc.cx = pColumn->cxWidth;

            // Insert the column
            ListView_InsertColumn(m_wndList, 0, &lvc);

            // Up the count for the next column position
            iInsertPos++;

            // Check to see if this is the sort column
            if ((pColumn->flags & COLFLAG_SORT_ASCENDING) || 
                (pColumn->flags & COLFLAG_SORT_DESCENDING))
            {
                m_idColumnSort = pColumn->id;
                m_fAscending = COLFLAG_SORT_ASCENDING == (pColumn->flags & COLFLAG_SORT_ASCENDING); 
            }

            // Bail out of this loop
            break;
        }
    }

    // Now insert the rest of the columns, skipping over the column we inserted
    // previously (stored in iColumnSkip).
    for (iColumn = 0, pColumn = rgColumns; iColumn < cColumns; iColumn++, pColumn++)
    {
        // If this column is visible and it's not the one we skipped over
        if ((pColumn->flags & COLFLAG_VISIBLE) && (iColumn != iColumnSkip))
        {
            // Figure out what the mask is and load the icon or string
            if (c_rgColumnData[pColumn->id].iIcon <= 0)
            {
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName, 
                           sz, ARRAYSIZE(sz));                
            }
            else
            {
                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_IMAGE | LVCF_SUBITEM;
                lvc.iImage = c_rgColumnData[pColumn->id].iIcon;
            }

            lvc.iSubItem = iInsertPos;
            lvc.fmt = c_rgColumnData[pColumn->id].format;
            
            // If the column width provided is -1, then it hasn't been 
            // customized yet so use the default.
            if (pColumn->cxWidth == -1)
                lvc.cx = c_rgColumnData[pColumn->id].cxWidth;
            else
                lvc.cx = pColumn->cxWidth;

            // Check to see if this is the sort column
            if ((pColumn->flags & COLFLAG_SORT_ASCENDING) || 
                (pColumn->flags & COLFLAG_SORT_DESCENDING))
            {
                // Save the info
                m_idColumnSort = pColumn->id;
                m_fAscending = COLFLAG_SORT_ASCENDING == (pColumn->flags & COLFLAG_SORT_ASCENDING); 
            }

            // Insert this column
            ListView_InsertColumn(m_wndList, iInsertPos, &lvc);
      
            iInsertPos++;
        }
    }

    // If we had to skip over a column, the we need to set the column order
    // array so it appears correctly to the user.
    if (iColumnSkip > 0 && iColumnSkip < cColumns)
    {
        DWORD cColumnOrder = 0;
        int rgOrder[COLUMN_MAX];

        // Add all of the columns to the order array in order up to iColumnSkip
        for (iColumn = 1; iColumn <= iColumnSkip; iColumn++)
        {
            if (rgColumns[iColumn].flags & COLFLAG_VISIBLE)
                rgOrder[cColumnOrder++] = iColumn;
        }

        // Add the skipped column
        rgOrder[cColumnOrder++] = 0;

        // Add the rest of the columns
        for (iColumn = iColumnSkip + 1; iColumn < cColumns; iColumn++)
        {
            if (rgColumns[iColumn].flags & COLFLAG_VISIBLE)
                rgOrder[cColumnOrder++] = iColumn;
        }

        // Update the ListView
        ListView_SetColumnOrderArray(m_wndList, cColumnOrder, rgOrder);

        // Reorder the rgColumns passed in to match the order in the ListView
        // and keep a copy of it.
        if (m_pColumnSet)
            g_pMalloc->Free(m_pColumnSet);
        m_pColumnSet = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cColumns);
        for (iColumn = 0; iColumn < cColumnOrder; iColumn++)
            m_pColumnSet[rgOrder[iColumn]] = rgColumns[iColumn];
        m_cColumns = cColumnOrder;
    }
    else
    {
        // We still need to keep a copy of the column array ordering for 
        // filling in the virtual ListView later.
        if (m_pColumnSet)
            g_pMalloc->Free(m_pColumnSet);
        m_pColumnSet = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cColumns);
        CopyMemory(m_pColumnSet, rgColumns, sizeof(COLUMN_SET) * cColumns);
        m_cColumns = iInsertPos;
    }

    // If we _still_ don't have sort information, then we pick the first sortable
    // column.
    if (m_idColumnSort == COLUMN_MAX)
    {
        m_idColumnSort = m_pColumnSet[0].id;
        m_fAscending = TRUE;
    }

    // Make sure the arrow is drawn correctly
    SetSortInfo(m_idColumnSort, m_fAscending);

    return (S_OK);
}


HRESULT CColumns::GetColumnInfo(COLUMN_SET_TYPE* pType, COLUMN_SET** prgColumns, DWORD *pcColumns)
{
    COLUMN_SET  rgColumns[COLUMN_MAX];
    DWORD       cColumns = COLUMN_MAX;
    HRESULT     hr;

    // This one is easy
    if (pType)
        *pType = m_type;

    // Update our list of columns from the ListView
    if (FAILED(hr = _GetListViewColumns(rgColumns, &cColumns)))
    {
        // If we failed, we should return the default information
        cColumns = c_rgColumnSetInfo[m_type].cColumns;
        CopyMemory(rgColumns, c_rgColumnSetInfo[m_type].rgColumns, sizeof(COLUMN_SET) * cColumns);
    }

    if (prgColumns)
    {
        // Need to allocate an array for this
        *prgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cColumns);
        CopyMemory(*prgColumns, rgColumns, sizeof(COLUMN_SET) * cColumns);
    }

    if (pcColumns)
        *pcColumns = cColumns;

    return (S_OK);
}


HRESULT CColumns::_GetListViewColumns(COLUMN_SET* rgColumns, DWORD* pcColumns)
{
    DWORD rgOrder[COLUMN_MAX];
    DWORD iColumn;

    *pcColumns = m_cColumns;

    // The columns might have been reordered by the user, so get the order 
    // arrray from the ListView
    if (!Header_GetOrderArray(m_hwndHdr, m_cColumns, rgOrder))
    {
        // If this fails, we're pretty much out of luck.
        return (E_UNEXPECTED);
    }

    // Duplicate the stored column set
    COLUMN_SET rgColumnsTemp[COLUMN_MAX];
    CopyMemory(rgColumnsTemp, m_pColumnSet, sizeof(COLUMN_SET) * m_cColumns);

    // Reorder the array
    for (iColumn = 0; iColumn < m_cColumns; iColumn++)
    {
        rgColumns[iColumn] = rgColumnsTemp[rgOrder[iColumn]];
        rgColumns[iColumn].flags &= ~(COLFLAG_SORT_ASCENDING | COLFLAG_SORT_DESCENDING);
        if (m_idColumnSort == rgColumns[iColumn].id)
            rgColumns[iColumn].flags |= (m_fAscending ? COLFLAG_SORT_ASCENDING : COLFLAG_SORT_DESCENDING);
    }

#ifdef DEBUG
    // Dump the array to make sure it's in the right order
    COLUMN_SET* pColumn;
    for (iColumn = 0, pColumn = rgColumns; iColumn < m_cColumns; iColumn++, pColumn++)
    {
        TCHAR sz[CCHMAX_STRINGRES];
        LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                   sz, ARRAYSIZE(sz));                                           
        TRACE("Column %d: %s", iColumn, sz);
    }
#endif

    // Return 'em
    return (S_OK);
}


HRESULT CColumns::SetColumnInfo(COLUMN_SET* rgColumns, DWORD cColumns)
{
    Assert(rgColumns != NULL);
    Assert(cColumns > 0);

    // Update the ListView
    _SetListViewColumns(rgColumns, cColumns);

    return (S_OK);
}



//
//  FUNCTION:   CColumns::FillSortMenu()
//
//  PURPOSE:    Fills the provided menu with the list of columns in the ListView
//              and checks the item that is already sorted on.
//
//  PARAMETERS: 
//      [in]  hMenu   - Handle of the menu to insert items into
//      [in]  idBase  - Base ID for the command IDs
//      [out] pcItems - Number of items that were inserted by this function 
//
//  RETURN VALUE:
//      S_OK - Everything succeeded
//
HRESULT CColumns::FillSortMenu(HMENU hMenu, DWORD idBase, DWORD *pcItems, DWORD *pidCurrent)
{
    TCHAR sz[CCHMAX_STRINGRES];
    int   ids;
    DWORD iItemChecked = -1;
    BOOL  fAscending = TRUE;
    COLUMN_SET rgColumns[COLUMN_MAX];
    DWORD cColumns;

    // Update our snapshot of the columns in the ListView
    _GetListViewColumns(rgColumns, &cColumns);

    // If there aren't any columns yet, bail
    if (cColumns == 0)
        return (E_UNEXPECTED);

    // Clear any items that were already on the menu
    while ((WORD) -1 != (WORD) GetMenuItemID(hMenu, 0))
        DeleteMenu(hMenu, 0, MF_BYPOSITION);

    // Loop through and insert a menu item for each column 
    COLUMN_SET *pColumn = rgColumns;
    DWORD       iColumn;
    for (iColumn = 0; iColumn < cColumns; iColumn++, pColumn++)
    {
        // Load the string resource for this column
        LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                   sz, ARRAYSIZE(sz));

        // Insert the menu
        InsertMenu(hMenu, iColumn, MF_BYPOSITION | MF_STRING | MF_ENABLED,
                   idBase + iColumn, sz);

        // Check to see if this is the column we're currently sorted on
        if (pColumn->id == m_idColumnSort)
        {
            if (pidCurrent)
                *pidCurrent = idBase + iColumn;

            iItemChecked = iColumn;
            fAscending = m_fAscending;
        }
    }

    // Check the item that is sorted on
    CheckMenuRadioItem(hMenu, 0, iColumn - 1, iItemChecked, MF_BYPOSITION);

    // Check ascending or descending
    CheckMenuRadioItem(hMenu, ID_SORT_ASCENDING, ID_SORT_DESCENDING, 
                       fAscending ? ID_SORT_ASCENDING : ID_SORT_DESCENDING, MF_BYCOMMAND);

    // If the caller cares, return the number of items we've added
    if (pcItems)
        *pcItems = iColumn;

    return (S_OK);
}


HRESULT CColumns::ColumnsDialog(HWND hwndParent)
{
    CColumnsDlg cDialog;
    cDialog.Init(this);
    cDialog.DoModal(hwndParent);
    return (S_OK);
}


DWORD CColumns::GetCount(void)
{
    return (m_cColumns);
}


HRESULT CColumns::GetSortInfo(COLUMN_ID *pidColumn, BOOL *pfAscending)
{
    if (pidColumn)
        *pidColumn = m_idColumnSort;
    if (pfAscending)
        *pfAscending = m_fAscending;

    return (S_OK);
}


HRESULT CColumns::SetSortInfo(COLUMN_ID idColumn, BOOL fAscending)
{
    LV_COLUMN   lvc;
    COLUMN_SET *pColumn;
    DWORD       iColumn;

    // Loop through the column array and verify this column is visible
    for (iColumn = 0, pColumn = m_pColumnSet; iColumn < m_cColumns; iColumn++, pColumn++)
    {
        if (pColumn->id == idColumn)
        {
            // Remove the sort arrow from the previously sorted column
            if (c_rgColumnSetInfo[m_type].fSort && c_rgColumnData[m_idColumnSort].iIcon == 0)
            {
                lvc.mask = LVCF_FMT;
                lvc.fmt = c_rgColumnData[m_idColumnSort].format;
                lvc.fmt &= ~(LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);
                ListView_SetColumn(m_wndList, GetColumn(m_idColumnSort), &lvc);
            }            

            // Update our cached information
            m_idColumnSort = idColumn;
            m_fAscending = fAscending;

            // Update the ListView with a new sort column unless the sort column
            // already has an image
            if (c_rgColumnSetInfo[m_type].fSort && c_rgColumnData[idColumn].iIcon <= 0)
            {
                lvc.fmt = LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT | c_rgColumnData[idColumn].format;
                lvc.mask = LVCF_IMAGE | LVCF_FMT;
                lvc.iImage = fAscending ? iiconSortAsc : iiconSortDesc;
                ListView_SetColumn(m_wndList, iColumn, &lvc);
            }

            return (S_OK);
        }
    }

    return (E_INVALIDARG);
}


COLUMN_ID CColumns::GetId(DWORD iColumn)
{
    DWORD rgOrder[COLUMN_MAX];

    if (iColumn > m_cColumns)
        return COLUMN_MAX;

    // The columns might have been reordered by the user, so get the order 
    // arrray from the ListView
    if (0 == Header_GetOrderArray(m_hwndHdr, m_cColumns, rgOrder))
        return (COLUMN_MAX);

    return (m_pColumnSet[iColumn].id);
}


DWORD CColumns::GetColumn(COLUMN_ID id)
{
    COLUMN_SET *pColumn;
    DWORD       iColumn;

    for (iColumn = 0, pColumn = m_pColumnSet; iColumn < m_cColumns; iColumn++, pColumn++)
    {
        if (pColumn->id == id)
            return (iColumn);
    }
    return (-1);
}

HRESULT CColumns::SetColumnWidth(DWORD iColumn, DWORD cxWidth)
{
    if (iColumn > m_cColumns)
        return (E_INVALIDARG);

    m_pColumnSet[iColumn].cxWidth = cxWidth;
    return (S_OK);
}


HRESULT CColumns::InsertColumn(COLUMN_ID id, DWORD iInsertBefore)
{
    COLUMN_SET  rgOld[COLUMN_MAX];
    DWORD       cColumns = COLUMN_MAX;

    // Update our list of columns from the ListView
    _GetListViewColumns(rgOld, &cColumns);

    // Allocate an array big enough for all of the possible columns
    COLUMN_SET *rgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * (cColumns + 1));
    if (!rgColumns)
        return (E_OUTOFMEMORY);

    // Insert the requested flag first
    rgColumns->id = id;
    rgColumns->flags = COLFLAG_VISIBLE;
    rgColumns->cxWidth = -1;

    // Now copy the rest
    CopyMemory(&(rgColumns[1]), rgOld, sizeof(COLUMN_SET) * cColumns);

    // Set the updated column structure into the ListView
    SetColumnInfo(rgColumns, cColumns + 1);
    g_pMalloc->Free(rgColumns);

    return (S_OK);
}


HRESULT CColumns::IsColumnVisible(COLUMN_ID id, BOOL *pfVisible)
{
    if (0 == pfVisible)
        return E_INVALIDARG;

    // Just do a quick run through the column array to see if the requested 
    // column is visible
    COLUMN_SET *pColumn = m_pColumnSet;

    for (DWORD i = 0; i < m_cColumns; i++, pColumn++)
    {
        if (pColumn->id == id)
        {
            *pfVisible = !!(pColumn->flags & COLFLAG_VISIBLE);
            return (S_OK);
        }
    }

    *pfVisible = FALSE;
    return (E_UNEXPECTED);
}


/////////////////////////////////////////////////////////////////////////////
// CColumnsDlg
//

CColumnsDlg::CColumnsDlg() : m_ctlEdit(NULL, this, 1)
{
    /*
	m_dwTitleID = idsColumnDlgTitle;
	m_dwHelpFileID = 0;
	m_dwDocStringID = idsColumnDlgTitle;
    */
    m_type = COLUMN_SET_MAIL;
    m_iItemWidth = -1;
    m_pColumnInfo = 0;
    m_rgColumns = 0;
}

CColumnsDlg::~CColumnsDlg()
{
    SafeRelease(m_pColumnInfo);
    if (m_rgColumns)
        g_pMalloc->Free(m_rgColumns);
}

#undef SubclassWindow
LRESULT CColumnsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    m_hwndList = GetDlgItem(IDC_COLUMN_LIST);
    m_ctlEdit.SubclassWindow(GetDlgItem(IDC_WIDTH));

    // Set the extended styles on the ListView
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);

    // Retrieve some information about the column set we're supposed to be 
    // displaying.
    COLUMN_SET* pColumns;
    DWORD       cColumns;
    m_pColumnInfo->GetColumnInfo(&m_type, &pColumns, &cColumns);

    // Allocate an array to hold our column info
    DWORD foo = c_rgColumnSetInfo[m_type].cColumns;

    Assert(m_rgColumns == NULL);
    m_rgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * c_rgColumnSetInfo[m_type].cColumns);
    CopyMemory(m_rgColumns, pColumns, sizeof(COLUMN_SET) * cColumns);

    g_pMalloc->Free(pColumns);
    m_cColumns = cColumns;

    // Add a single column to the ListView
    RECT rcClient;
    ::GetClientRect(m_hwndList, &rcClient);

    LV_COLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.cx = rcClient.right - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;

    ListView_InsertColumn(m_hwndList, 0, &lvc);

    // Load the state image bitmap
    HIMAGELIST himlState = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idb16x16st),
                                                16, 0, RGB(255, 0, 255));
    ListView_SetImageList(m_hwndList, himlState, LVSIL_STATE);

    // Fill the ListView
    _FillList(m_rgColumns, m_cColumns);

    // Set the first item to be focused
    ListView_SetItemState(m_hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    // Everything is clean
    SetDirty(FALSE);

	return 1;  // Let the system set the focus
}

static const HELPMAP g_rgCtxMapColumns[] = {
    {IDC_COLUMN_LIST, 50400},
    {IDC_MOVEUP, 50405},
    {IDC_MOVEDOWN, 50410},
    {IDC_SHOW, 50415},
    {IDC_HIDE, 50420},
    {IDC_WIDTH, 50425},
    {IDC_RESET_COLUMNS, 353507},
    {0, 0}
};

LRESULT CColumnsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    return(OnContextHelp(m_hWnd, uMsg, wParam, lParam, g_rgCtxMapColumns));
}

HRESULT CColumnsDlg::Apply(void)
{
    HRESULT hr = S_OK;

	TRACE(_T("CColumnsDlg::Apply\n"));

    // Build a column set array from the data in the ListView.  Only include 
    // visible columns.
    int cItems = ListView_GetItemCount(m_hwndList);

    // Allocate an array big enough for all of the possible columns
    COLUMN_SET *rgColumns = (COLUMN_SET *) g_pMalloc->Alloc(sizeof(COLUMN_SET) * cItems);
    DWORD       cColumns = 0;
    if (!rgColumns)
        return (E_OUTOFMEMORY);

    LV_ITEM lvi;
    
    lvi.mask = LVIF_PARAM | LVIF_STATE;
    lvi.stateMask = LVIS_SELECTED;
    lvi.iSubItem = 0;

    // Loop through the listview
    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
    {
        // Check to see if this one is visible
        if (_IsChecked(lvi.iItem))
        {
            // If so, then retrieve the cached column info pointer
            ListView_GetItem(m_hwndList, &lvi);

            // And copy the structure into our new array
            rgColumns[cColumns] = *((COLUMN_SET *) lvi.lParam);

            // If this item was selected, then we should grab the column width
            // from the edit box.
            if (lvi.state & LVIS_SELECTED)
                rgColumns[cColumns].cxWidth = GetDlgItemInt(IDC_WIDTH, NULL, FALSE);

            // Make sure the flag sayz visible
            rgColumns[cColumns++].flags |= COLFLAG_VISIBLE;
        }
    }

    // Make sure there's at least one column
    if (!cColumns)
    {
        AthMessageBoxW(m_hWnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrSelectOneColumn),
                      0, MB_ICONEXCLAMATION | MB_OK);
        hr = E_UNEXPECTED;
    }
    else
    {
        // Set the updated column structure into the ListView
        if (SUCCEEDED(m_pColumnInfo->SetColumnInfo(rgColumns, cColumns)))
        {
	        SetDirty(FALSE);
	        hr = S_OK;
        }
        else
            hr = E_UNEXPECTED;
    }

    g_pMalloc->Free(rgColumns);
    return (hr);
}


LRESULT CColumnsDlg::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    DWORD dwPos;
    LV_HITTESTINFO lvhti;

    // Double check this
    Assert(idCtrl == IDC_COLUMN_LIST);

    // Figure out where the cursor was
    dwPos = GetMessagePos();
    lvhti.pt.x = (int)(short) LOWORD(dwPos);
    lvhti.pt.y = (int)(short) HIWORD(dwPos);
    ::ScreenToClient(m_hwndList, &(lvhti.pt));

    // Ask the ListView where this is
    if (-1 == ListView_HitTest(m_hwndList, &lvhti))
        return 0;

    // If this was on a state image area, toggle the check
    if (lvhti.flags == LVHT_ONITEMSTATEICON || pnmh->code == NM_DBLCLK)
    {
        _SetCheck(lvhti.iItem, !_IsChecked(lvhti.iItem));
    }

    return (0);
}


LRESULT CColumnsDlg::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    Assert(idCtrl == IDC_COLUMN_LIST);

    // The only change we're looking for is when a new item is selected.
    NMLISTVIEW* pnmlv = (NMLISTVIEW *) pnmh;
    COLUMN_SET* pColumn = ((COLUMN_SET *) pnmlv->lParam);    
    DWORD cxWidth = pColumn->cxWidth == -1 ? c_rgColumnData[pColumn->id].cxWidth : pColumn->cxWidth;

    // Narrow it down to state changes
    if (pnmlv->uChanged & LVIF_STATE)
    {
        _UpdateButtonState(pnmlv->iItem);

        // If the new state contains selected, and the old state does not, then 
        // we have a new selected item.
        if ((pnmlv->uNewState & LVIS_SELECTED) && (pnmlv->uNewState & LVIS_FOCUSED) 
             && (0 == (pnmlv->uOldState & LVIS_SELECTED)))
        {
            LV_ITEM lvi;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;

            // If there was a previously selected item
            if (m_iItemWidth != -1)
            {
                lvi.iItem = m_iItemWidth;
                ListView_GetItem(m_hwndList, &lvi);

                // Save the width
                ((COLUMN_SET *) lvi.lParam)->cxWidth = GetDlgItemInt(IDC_WIDTH, NULL, FALSE);
            }

            // Set the column width edit box
            SetDlgItemInt(IDC_WIDTH, cxWidth, FALSE);
            m_iItemWidth = pnmlv->iItem;
        }
    }

    return (0);
}


BOOL CColumnsDlg::_IsChecked(DWORD iItem)
{
    DWORD state;

    // Get the state from the selected item
    state = ListView_GetItemState(m_hwndList, iItem, LVIS_STATEIMAGEMASK);

    return (state & INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1));
}


void CColumnsDlg::_SetCheck(DWORD iItem, BOOL fChecked)
{
    ListView_SetItemState(m_hwndList, iItem, 
                          INDEXTOSTATEIMAGEMASK(1 + iiconStateUnchecked + fChecked),
                          LVIS_STATEIMAGEMASK);
    SetDirty(TRUE);
}


void CColumnsDlg::_FillList(const COLUMN_SET *rgColumns, DWORD cColumns)
{
    LV_ITEM           lvi;
    TCHAR             sz[CCHMAX_STRINGRES];
    COLUMN_SET       *pColumn;
    BOOL              fChecked;

    // Set the basic fields in the item struct
    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.pszText = sz;
    lvi.stateMask = LVIS_STATEIMAGEMASK;

    // Loop through the columns in rgColumns, adding each in order to the 
    // ListView.
    for (lvi.iItem = 0, pColumn = (COLUMN_SET *) rgColumns; lvi.iItem < (int) cColumns; lvi.iItem++, pColumn++)
    {
        // Load the string for the column
        LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                   sz, ARRAYSIZE(sz));

        // Set the checkbox state
        fChecked = !!(pColumn->flags & COLFLAG_VISIBLE);
        lvi.state = INDEXTOSTATEIMAGEMASK(1 + iiconStateUnchecked + fChecked);

        // Save the width in the lParam
        if (pColumn->cxWidth == -1)
            pColumn->cxWidth = c_rgColumnData[pColumn->id].cxWidth;
        lvi.lParam = (LPARAM) pColumn;

        // Insert this item into the list
        ListView_InsertItem(m_hwndList, &lvi);
    }

    // Check to see if the columns we just added were the default columns
    if (lvi.iItem != (int) c_rgColumnSetInfo[m_type].cColumns)
    {
        // Now we need to go through and add the columns that are not currently in 
        // the column set, but could be.    
        DWORD i, j;
        BOOL fInsert;
        for (i = 0, pColumn = (COLUMN_SET *) c_rgColumnSetInfo[m_type].rgColumns; 
             i < c_rgColumnSetInfo[m_type].cColumns; 
             i++, pColumn++)
        {
            fInsert = TRUE;
            for (j = 0; j < cColumns; j++)
            {
                if (pColumn->id == m_rgColumns[j].id)
                {
                    fInsert = FALSE;
                    break;
                }
            }

            // If it wasn't found in m_rgColumns, then insert it
            if (fInsert)
            {
                // Copy the struct
                m_rgColumns[lvi.iItem] = *pColumn;
                m_rgColumns[lvi.iItem].cxWidth = c_rgColumnData[pColumn->id].cxWidth;
                m_rgColumns[lvi.iItem].flags &= ~COLFLAG_VISIBLE;

                // Load the string for the column
                LoadString(g_hLocRes, c_rgColumnData[pColumn->id].idsColumnName,
                           sz, ARRAYSIZE(sz));

                // Set the checkbox state.  These are _always_ unchecked.
                lvi.state = INDEXTOSTATEIMAGEMASK(1 + iiconStateUnchecked);

                // Save the width in the lParam
                lvi.lParam = (LPARAM) &m_rgColumns[lvi.iItem]; 

                // Insert this item into the list
                ListView_InsertItem(m_hwndList, &lvi);

                // Increment the position
                lvi.iItem++;                
            }
        }
    }

    m_cColumns = ListView_GetItemCount(m_hwndList);
}


LRESULT CColumnsDlg::OnShowHide(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int iItem = -1;

    // Loop through the selected items and make them checked
    while (-1 != (iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED)))
    {
        _SetCheck(iItem, wID == IDC_SHOW);
    }

    return (0);
}


LRESULT CColumnsDlg::OnReset(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // Remove all of the columns from the ListView
    ListView_DeleteAllItems(m_hwndList);

    // Fill the array of columns with the default column information
    CopyMemory(m_rgColumns, c_rgColumnSetInfo[m_type].rgColumns, sizeof(COLUMN_SET) * c_rgColumnSetInfo[m_type].cColumns);

    // Reset the list to contain the default column information
    _FillList(m_rgColumns, m_cColumns);

    // Set the first item to be focused
    ListView_SetItemState(m_hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);

    SetDirty(TRUE);
    return (0);
}


void CColumnsDlg::_UpdateButtonState(DWORD iItemSel)
{
    HWND hwnd;
    BOOL fChecked = _IsChecked(iItemSel);
    DWORD dwItems = ListView_GetItemCount(m_hwndList);
    DWORD dwSel = ListView_GetSelectedCount(m_hwndList);

    hwnd = GetFocus();

    ::EnableWindow(GetDlgItem(IDC_MOVEUP), (iItemSel != 0) && dwSel);
    ::EnableWindow(GetDlgItem(IDC_MOVEDOWN), (iItemSel != (dwItems - 1)) && dwSel);
    ::EnableWindow(GetDlgItem(IDC_SHOW), (!fChecked && dwSel));
    ::EnableWindow(GetDlgItem(IDC_HIDE), fChecked && dwSel);    

    // don't disable button that has the focus
    if (!::IsWindowEnabled(hwnd))
    {
        hwnd = GetNextDlgTabItem(hwnd, FALSE);
        ::SetFocus(hwnd);
    }
}


LRESULT CColumnsDlg::OnMove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    COLUMN_SET *pColumn = 0;

    // Make sure this is reset
    m_iItemWidth = -1;

    // Figure out which one is selected
    DWORD iItem = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);

    // Get the item from the ListView
    LV_ITEM lvi;
    TCHAR   sz[CCHMAX_STRINGRES];

    lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED | LVIS_STATEIMAGEMASK;
    lvi.pszText = sz;
    lvi.cchTextMax = ARRAYSIZE(sz);
    
    ListView_GetItem(m_hwndList, &lvi);

    // Insert this item to the position one up or down from where it is
    lvi.iItem += (wID == IDC_MOVEUP) ? -1 : 2;
    
    // Update the column width
    pColumn = (COLUMN_SET *) lvi.lParam;
    pColumn->cxWidth = GetDlgItemInt(IDC_WIDTH, NULL, FALSE);    

    ListView_InsertItem(m_hwndList, &lvi);

    // Force a redraw of the new item and make sure it's visible
    ListView_EnsureVisible(m_hwndList, lvi.iItem, FALSE);
    ListView_RedrawItems(m_hwndList, lvi.iItem, lvi.iItem);

    // Delete the old item
    m_iItemWidth = -1;
    ListView_DeleteItem(m_hwndList, iItem + (wID == IDC_MOVEUP));

    SetDirty(TRUE);
    return (0);
}


LRESULT CColumnsDlg::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    if (SUCCEEDED(Apply()))
        SetWindowLong(DWLP_MSGRESULT, PSNRET_NOERROR);
    else
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\conman.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     conman.h
//
//  PURPOSE:    Defines the CConnectionManager object for Athena.
//
                                                    
#ifndef __CONMAN_H__
#define __CONMAN_H__

#ifndef WIN16   // No RAS support in Win16

#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>
#include <sensapi.h>

#include "imnact.h"

// Forward Reference
class CConnectionManager;

typedef enum {
    CONNNOTIFY_CONNECTED = 0,
    CONNNOTIFY_DISCONNECTING,           // pvData is the name of the connection comming down
    CONNNOTIFY_DISCONNECTED,
    CONNNOTIFY_RASACCOUNTSCHANGED,
    CONNNOTIFY_WORKOFFLINE,
    CONNNOTIFY_USER_CANCELLED
} CONNNOTIFY;

typedef enum CONNINFOSTATE {
    CIS_REFRESH,
    CIS_CLEAN
} CONNINFOSTATE;

typedef struct CONNINFO {
    CONNINFOSTATE       state;
    HRASCONN            hRasConn;
    TCHAR               szCurrentConnectionName[RAS_MaxEntryName + 1];
    BOOL                fConnected;
    BOOL                fIStartedRas;
    BOOL                fAutoDial;
} CONNINFO, *LPCONNINFO;

typedef struct TagConnListNode
{
    TagConnListNode  *pNext;
    TCHAR            pszRasConn[RAS_MaxEntryName + 1];
}ConnListNode;

// This interface is implemented by clients of the connection manager that 
// care when a new RAS connection is established or an existing connection
// is destroyed.
DECLARE_INTERFACE_(IConnectionNotify, IUnknown)
    {
    // *** IUnknown Methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // *** IConnectionNotify ***

    // OnConnectionNotify
    //
    // <in> nCode   - Tells the function which event happened
    // <in> pvData  - Pointer to extra data for the notification
    // <in> pConMan - Pointer to the CConnectionManager object that sent the
    //                notification.  The recipient can use this to find out
    //                if they can connect to a server based on the new state
    //                of the RAS connection.
    STDMETHOD(OnConnectionNotify) (THIS_ 
                                   CONNNOTIFY nCode, 
                                   LPVOID pvData, 
                                   CConnectionManager *pConMan) PURE;
    };


/////////////////////////////////////////////////////////////////////////////
// API Typedefs
// 
typedef DWORD (APIENTRY *RASDIALPROC)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASENUMENTRIESPROC)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROC)(UINT, LPTSTR, DWORD);
typedef DWORD (APIENTRY *RASHANGUPPROC)(HRASCONN);
typedef DWORD (APIENTRY *RASSETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD (APIENTRY *RASGETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL*);
typedef DWORD (APIENTRY *RASEDITPHONEBOOKENTRYPROC)(HWND, LPTSTR, LPTSTR);                                                    
typedef BOOL  (APIENTRY *RASDIALDLGPROC)(LPSTR, LPSTR, LPSTR, LPRASDIALDLG);
typedef BOOL  (APIENTRY *RASENTRYDLGPROC)(LPSTR, LPSTR, LPRASENTRYDLG);
typedef DWORD (APIENTRY *RASGETENTRYPROPERTIES)(LPTSTR, LPTSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);


//Mobility Pack
typedef BOOLEAN (APIENTRY *ISDESTINATIONREACHABLE)(LPCSTR  lpwstrDestination, LPQOCINFO lpqocinfo);
typedef BOOLEAN (APIENTRY *ISNETWORKALIVE)(LPDWORD  lpdwflags);

#define CONNECTION_RAS          0x00000001
#define CONNECTION_LAN          0x00000002
#define CONNECTION_MANUAL       0x00000004
#define MAX_RAS_ERROR           256
#define NOTIFY_PROP             _T("NotifyInfoProp")
#define NOTIFY_HWND             _T("ConnectionNotify")

// This is the name of our mutex that we use to make sure just one 
// instance of this object ever get's created.
const TCHAR c_szConManMutex[] = _T("ConnectionManager");

typedef struct tagNOTIFYHWND
    {
    DWORD               dwThreadId;
    HWND                hwnd;
    struct tagNOTIFYHWND  *pNext;
    } NOTIFYHWND;

typedef struct tagNOTIFYLIST 
    {
    IConnectionNotify  *pNotify;
    struct tagNOTIFYLIST  *pNext;
    } NOTIFYLIST;


class CConnectionManager : public IImnAdviseAccount
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor, Destructor
    // 
    CConnectionManager();
    ~CConnectionManager();
    
    /////////////////////////////////////////////////////////////////////////
    // Initialization
    //
    HRESULT HrInit(IImnAccountManager *pAcctMan);
    
    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);
    
    /////////////////////////////////////////////////////////////////////////
    // IImnAdviseAccount
    //
    HRESULT STDMETHODCALLTYPE AdviseAccount(DWORD dwAdviseType, 
                                            ACTX *pactx);
    
    /////////////////////////////////////////////////////////////////////////
    // Connection APIs
    
    // CanConnect
    // 
    // Allows the caller to determine if they can talk to the specified
    // account using the current connection.
    //
    // Return Values:
    //   S_OK    - The caller can connect using the existing connection
    //   S_FALSE - There is no existing connection.  The caller must first
    //             connect.
    //   E_FAIL  - There is a connection that is active, but it is not the 
    //             connection for this account.  
    //
    HRESULT CanConnect(IImnAccount *pAccount);
    HRESULT CanConnect(LPTSTR pszAccount);
    
	BOOL IsAccountDisabled(LPTSTR pszAccount);

    // Connect
    //
    // If the specified account requires a RAS connection, then connect 
    // attempts to establish that connection.  Otherwise, we simply
    // return success for manual or LAN connections.
    //
    // <in> pAccount / pszAccount - Name or pointer to the account to connect
    // <in> fShowUI - TRUE if the connection manager is allowed to display
    //                UI while trying to connect.
    //    
    HRESULT Connect(IImnAccount *pAccount, HWND hwnd, BOOL fShowUI);
    HRESULT Connect(LPTSTR pszAccount, HWND hwnd, BOOL fShowUI);
    HRESULT Connect(HMENU hMenu, DWORD cmd, HWND hwnd);

    HRESULT ConnectDefault(HWND hwnd, BOOL fShowUI);
    
    // Disconnect
    //
    // If there is a RAS connection in effect and we established that
    // connection, then we bring the connection down without asking any
    // questions.  If we didn't establish the connection, then we explain
    // the conundrum to the user and ask if they still want to.  If it's
    // a LAN connection, then we just return success.
    //
    HRESULT Disconnect(HWND hwnd, BOOL fShowUI, BOOL fForce, BOOL fShutdown);
    
    // IsConnected
    //
    // The client can call this to determine if there is currently an active
    // connection.  
    //
    BOOL IsConnected(void); 

    // IsRasLoaded
    //
    // In our shutdown code we call this before calling IsConnected since
    // IsConnected causes RAS to be loaded. We don't want to load RAS on
    // shutdown.
    //
    BOOL IsRasLoaded(void) {
        EnterCriticalSection(&m_cs);
        BOOL f = (NULL == m_hInstRas) ? FALSE : TRUE;
        LeaveCriticalSection(&m_cs);
        return f;
    }

    // IsGlobalOffline
    //
    // Checks the state of the global WININET offline option
    //
    BOOL IsGlobalOffline(void);

    // SetGlobalOffline
    //
    // Sets the global offline state for Athena and IE
    //
    void SetGlobalOffline(BOOL fOffline, HWND   hwndParent = NULL);
    
    // Notifications
    // 
    // A client can call Advise() to register itself to receive
    // notifications of connection changes.
    //    
    HRESULT Advise(IConnectionNotify *pNotify);
    HRESULT Unadvise(IConnectionNotify *pNotify);
    
    /////////////////////////////////////////////////////////////////////////
    // UI Related APIs
    //
    
    // RasAccountsExist
    //
    // A client can call this to determine if there are any configured 
    // accounts that exist that require a RAS connection.
    //
    // Returns:
    //   S_OK    - At least one account exists that uses RAS
    //   S_FALSE - No accounts exist that use RAS
    //
    HRESULT RasAccountsExist(void);
    
    // GetConnectMenu
    // 
    // A client can call this to retrieve the current list of items that
    // we can currently connect to.  The client must call DestroyMenu() to
    // free the menu when the client is done.
    //
    HRESULT GetConnectMenu(HMENU *phMenu);

    // FreeConnectMenu
    //
    // After the client is done with the menu returned from GetConnectMenu(),
    // they need to call FreeConnectMenu() to free item data stored in the 
    // menu and to destroy the menu resource.
    void FreeConnectMenu(HMENU hMenu);

    // OnActivate
    //
    // This should be called by the browser whenever our window receives an
    // WM_ACTIVATE message.  When we receive the message, we check to see
    // what the current state of the RAS Connection is.
    void OnActivate(BOOL fActive);

    // FillRasCombo
    //
    // This function takes a handle to a combo box and inserts the list of
    // RAS connections used by accounts in Athena.
    BOOL FillRasCombo(HWND hwndCombo, BOOL fIncludeNone);

    // DoStartupDial
    // 
    // This function checks to see what the user's startup options are with
    // respect to RAS and performs the actions required (dial, dialog, nada)
    void DoStartupDial(HWND hwndParent);

    // RefreshConnInfo - Defer checking of current connection information
    HRESULT RefreshConnInfo(BOOL fSendAdvise = TRUE);

//    HRESULT HandleConnStuff(BOOLEAN  fShowUI, LPSTR  pszAccountName, HWND hwnd);

    void    DoOfflineTransactions(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // These are private.  Stop looking at them you pervert.
    //
    HRESULT VerifyRasLoaded(void);
    HRESULT EnumerateConnections(LPRASCONN *ppRasConn, ULONG *pcConnections);
    HRESULT StartRasDial(HWND hwndParent, LPTSTR pszConnection);
    HRESULT RasLogon(HWND hwnd, LPTSTR pszConnection, BOOL fForcePrompt);
    HRESULT GetDefaultConnection(IImnAccount *pAccout, IImnAccount **ppDefault);
    HRESULT ConnectActual(LPTSTR pszRasConn, HWND hwnd, BOOL fShowUI);
    HRESULT CanConnectActual(LPTSTR pszRasConn);

    void DisplayRasError(HWND hwnd, HRESULT hrRasError, DWORD dwRasError);
    void CombinedRasError(HWND hwnd, UINT unids, LPTSTR pszRasError, 
                          DWORD dwRasError);
    UINT    PromptCloseConnection(HWND hwnd);
    HRESULT PromptCloseConnection(LPTSTR    pszRasConn, BOOL fShowUI, HWND hwndParent);

    static INT_PTR CALLBACK RasCloseConnDlgProc(HWND hwnd, UINT uMsg, 
                                             WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RasLogonDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                         LPARAM lParam);
    static INT_PTR CALLBACK RasProgressDlgProc(HWND hwnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RasStartupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                           LPARAM lParam);

                                             
                                             
    BOOL  RasHangupAndWait(HRASCONN hRasConn, DWORD dwMaxWaitSeconds);
    DWORD InternetHangUpAndWait(DWORD_PTR hRasConn, DWORD dwMaxWaitSeconds);
    BOOL  LogonRetry(HWND hwnd, LPTSTR pszCancel);
    void  FailedRasDial(HWND hwnd, HRESULT hrRasError, DWORD dwRasError);
    DWORD EditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName);


    void SendAdvise(CONNNOTIFY nCode, LPVOID pvData);
    void FreeNotifyList(void);
    static LRESULT CALLBACK NotifyWndProc(HWND, UINT, WPARAM, LPARAM);
    BOOL IsConnectionUsed(LPTSTR pszConn);

    // Autodialer functions
    HRESULT DoAutoDial(HWND hwndParent, LPTSTR pszConnectoid, BOOL fDial);
    HRESULT LookupAutoDialHandler(LPTSTR pszConnectoid, LPTSTR pszAutodialDllName,
                                  LPTSTR pszAutodialFcnName);
    BOOL ConnectionManagerVoodoo(LPTSTR pszConnection);
    
    
    HRESULT AddToConnList(LPTSTR  pszRasConn);
    void    RemoveFromConnList(LPTSTR  pszRasConn);
    void    EmptyConnList();
    HRESULT SearchConnList(LPTSTR pszRasConn);
    HRESULT OEIsDestinationReachable(IImnAccount  *pAccount, DWORD dwConnType);
    BOOLEAN IsSameDestination(LPSTR  pszConnectionName, LPSTR pszServerName);
    HRESULT GetServerName(IImnAccount *pAcct, LPSTR  pServerName, DWORD size);
    HRESULT IsInternetReachable(IImnAccount*, DWORD);
    HRESULT IsInternetReachable(LPTSTR pszRasConn);
    HRESULT VerifyMobilityPackLoaded();

    HRESULT ConnectUsingIESettings(HWND     hwndParent, BOOL fShowUI);
    void    SetTryAgain(BOOL   bval);
    static  BOOL   CALLBACK  OfferOfflineDlgProc(HWND   hwnd, UINT  uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT GetDefConnectoid(LPTSTR szConn, DWORD   dwSize);

private:
    /////////////////////////////////////////////////////////////////////////
    // Private Class Data
    ULONG               m_cRef;             // Ref count
    
    CRITICAL_SECTION    m_cs;
    HANDLE              m_hMutexDial;

    IImnAccountManager *m_pAcctMan;
    
    /////////////////////////////////////////////////////////////////////////////
    // State
    BOOL                m_fSavePassword;
    BOOL                m_fRASLoadFailed;
    BOOL                m_fOffline;
    
    /////////////////////////////////////////////////////////////////////////////
    // Current Connection Information
    DWORD_PTR           m_dwConnId;
    CONNINFO            m_rConnInfo;
    TCHAR               m_szConnectName[RAS_MaxEntryName + 1];
    RASDIALPARAMS       m_rdp;

    /////////////////////////////////////////////////////////////////////////////
    // RAS DLL Handles
    //
    HINSTANCE           m_hInstRas;
    HINSTANCE           m_hInstRasDlg;

    //For Mobility Pack
    HINSTANCE           m_hInstSensDll;
    BOOL                m_fMobilityPackFailed;

    /////////////////////////////////////////////////////////////////////////////
    // Notifications
    NOTIFYHWND         *m_pNotifyList;

    /////////////////////////////////////////////////////////////////////////////
    // Ras Dial Function Pointers
    //
    RASDIALPROC                 m_pRasDial;
    RASENUMCONNECTIONSPROC      m_pRasEnumConnections;
    RASENUMENTRIESPROC          m_pRasEnumEntries;
    RASGETCONNECTSTATUSPROC     m_pRasGetConnectStatus;
    RASGETERRORSTRINGPROC       m_pRasGetErrorString;
    RASHANGUPPROC               m_pRasHangup;
    RASSETENTRYDIALPARAMSPROC   m_pRasSetEntryDialParams;
    RASGETENTRYDIALPARAMSPROC   m_pRasGetEntryDialParams;
    RASEDITPHONEBOOKENTRYPROC   m_pRasEditPhonebookEntry;
    RASDIALDLGPROC              m_pRasDialDlg;
    RASENTRYDLGPROC             m_pRasEntryDlg;
    RASGETENTRYPROPERTIES       m_pRasGetEntryProperties;

    //Mobility Pack
    ISDESTINATIONREACHABLE          m_pIsDestinationReachable;
    ISNETWORKALIVE              m_pIsNetworkAlive;

    ConnListNode                *m_pConnListHead;
    BOOL                        m_fTryAgain;
    BOOL                        m_fDialerUI;
    };


    
/////////////////////////////////////////////////////////////////////////////
// Make our code look prettier
//
#undef RasDial
#undef RasEnumConnections
#undef RasEnumEntries
#undef RasGetConnectStatus
#undef RasGetErrorString
#undef RasHangup
#undef RasSetEntryDialParams
#undef RasGetEntryDialParams
#undef RasEditPhonebookEntry
#undef RasDialDlg
#undef RasGetEntryProperties

#define RasDial                    (*m_pRasDial)
#define RasEnumConnections         (*m_pRasEnumConnections)
#define RasEnumEntries             (*m_pRasEnumEntries)
#define RasGetConnectStatus        (*m_pRasGetConnectStatus)
#define RasGetErrorString          (*m_pRasGetErrorString)
#define RasHangup                  (*m_pRasHangup)
#define RasSetEntryDialParams      (*m_pRasSetEntryDialParams)
#define RasGetEntryDialParams      (*m_pRasGetEntryDialParams)
#define RasEditPhonebookEntry      (*m_pRasEditPhonebookEntry)
#define RasDialDlg                 (*m_pRasDialDlg)
#define RasGetEntryProperties      (*m_pRasGetEntryProperties)

//Mobility Pack
#undef IsDestinationReachable
#define IsDestinationReachable  (*m_pIsDestinationReachable)

#undef IsNetworkAlive
#define IsNetworkAlive          (*m_pIsNetworkAlive)

// Dialog Control IDs
#define idbDet                          1000
#define idlbDetails                     1001
#define ideProgress                     1002
#define idcSplitter                     1003
#define idchSavePassword                1004
#define ideUserName                     1005
#define idePassword                     1006
#define idePhone                        1007
#define idbEditConnection               1009
#define idrgUseCurrent                  1010
#define idrgDialNew                     1011
#define idcCurrentMsg                   1012
#define idcDialupCombo                  1013
#define idcDefaultCheck                 1014
#define idcDontWarnCheck                1015

#endif  // !WIN16
    
#endif // __CONMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\cererdlg.cpp ===
/*
**  c e r e r d l g . c p p
**   
**  Purpose:
**      Handles the certificate error dialog box
**
**  History
**      2/17/97: (t-erikne) Created.
**   
**    Copyright (C) Microsoft Corp. 1997.
*/

///////////////////////////////////////////////////////////////////////////
// 
// Depends on
//

#include "pch.hxx"
#include <resource.h>
#include <mimeole.h>
#include "demand.h"
#include "secutil.h"

// from globals.h
//N why didn't this work?
//extern IMimeAllocator  *g_pMoleAlloc;

///////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

INT_PTR CALLBACK CertErrorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
static void FillListView(HWND hwndList, IMimeAddressTable *pAdrTable);
static void InitListView(HWND hwndList);

///////////////////////////////////////////////////////////////////////////
// 
// Functions
//

INT_PTR CALLBACK CertErrorDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    CERTERRPARAM   * pCertErrParam = NULL;
    IMimeAddressTable *pAdrTable = NULL;
    TCHAR szText[CCHMAX_STRINGRES];

    switch (message)
        {
        case WM_INITDIALOG:
            HWND hwndList;

            CenterDialog(hwnd);

            // save our cookie pointer
            Assert(pAdrTable == NULL);
            pCertErrParam = (CERTERRPARAM *) lParam;
            pAdrTable = pCertErrParam->pAdrTable;
            Assert(pAdrTable != NULL);
            //N not needed right now
            //SetWindowLong(hwnd, DWL_USER, (LONG)pAdrTable);

            // set initial state of controls
            hwndList = GetDlgItem(hwnd, idcCertList);
            if (hwndList)
                {
                InitListView(hwndList);
                FillListView(hwndList, pAdrTable);
                }

            // Force Encryption change static text and disable OK button)
            if(pCertErrParam->fForceEncryption)
            {   
                szText[0] = _T('\0');
                AthLoadString(idsSecPolicyForceEncr,
                            szText, ARRAYSIZE(szText));
                SetDlgItemText(hwnd, idcErrStat, szText);
                EnableWindow(GetDlgItem(hwnd, IDOK), FALSE);
            }
            return(TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            //return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailRead);
            return FALSE;  // BUGBUG: should no doubt do something else here

        case WM_COMMAND:
            // remember to bail if the cookie is null

            switch (LOWORD(wParam))
                {
                case IDOK:
                    {
                    }
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);

                    break;
                }

            break; // wm_command

        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);

        } // message switch
    return(FALSE);
}


void InitListView(HWND hwndList)
{
    LV_COLUMN   lvc;
    RECT        rc;

    // Set up the columns.  The first column will be for the person's
    // name and the second for the certificate error

    GetClientRect(hwndList, &rc);

    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right / 2;

    ListView_InsertColumn(hwndList, 0, &lvc);
    ListView_InsertColumn(hwndList, 1, &lvc);
}

void FillListView(HWND hwndList, IMimeAddressTable *pAdrTable)
{
    IMimeEnumAddressTypes   *pEnum;
    const ULONG             numToGet = 1;
    ADDRESSPROPS            rAddress;
    LV_ITEM                 lvi;
    TCHAR                   szText[CCHMAX_STRINGRES];

    Assert(g_pMoleAlloc && hwndList && pAdrTable);

    if (FAILED(pAdrTable->EnumTypes(IAT_ALL, IAP_ADRTYPE | IAP_CERTSTATE | IAP_FRIENDLY, &pEnum)))
        return;

    lvi.mask = LVIF_TEXT;
    lvi.iItem = 0;
    lvi.stateMask = 0;

    while(S_OK == pEnum->Next(numToGet, &rAddress, NULL))
        {
        if (CERTIFICATE_OK != rAddress.certstate)
            {
            // if this is the sender and the problem is that the cert
            // is missing, ignore it.  We handle that elsewhere
            if (IAT_FROM == rAddress.dwAdrType &&
                FMissingCert(rAddress.certstate))
                {
                continue;
                }

            // we have a body worthy of viewing
            if (NULL != rAddress.pszFriendly)
                {
                lvi.iSubItem = 0;
                lvi.pszText = rAddress.pszFriendly;
                if (-1 == ListView_InsertItem(hwndList, &lvi))
                    goto freecont;

                // now compute the actual certificate error text
                // subtract one becuse the enum is zero-based
                AthLoadString(idsSecurityCertMissing+(UINT)rAddress.certstate-1,
                    szText, ARRAYSIZE(szText));

                lvi.iSubItem = 1;
                lvi.pszText = szText;
                ListView_SetItem(hwndList, &lvi);
                }
            }
freecont:
        g_pMoleAlloc->FreeAddressProps(&rAddress);
        }

    ReleaseObj(pEnum);
    return;
}


INT_PTR CALLBACK CertWarnDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    ERRIDS *pErrIds = NULL;
    TCHAR szRes[CCHMAX_STRINGRES];

    switch (message)
        {
        case WM_INITDIALOG:

            CenterDialog(hwnd);

            // save our cookie pointer
            Assert(pErrIds == NULL);
            pErrIds = (ERRIDS *)lParam;

            Assert(pErrIds != NULL);
            //N not needed right now
            //SetWindowLong(hwnd, DWL_USER, (LONG)pAdrTable);

            // set initial state of controls
            AthLoadString(pErrIds->idsText1, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic1, szRes);
            
            AthLoadString(pErrIds->idsText2, szRes, sizeof(szRes));
            SetDlgItemText(hwnd, idcStatic2, szRes);

            return(TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            //return OnContextHelp(hwnd, message, wParam, lParam, g_rgCtxMapMailRead);
            return FALSE;  // BUGBUG: should no doubt do something else here

        case WM_COMMAND:
            // remember to bail if the cookie is null

            switch (LOWORD(wParam))
                {
                case IDOK:
                    // fall through...
                case IDC_DONTSIGN:
                    // fall through...
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return(TRUE);

                    break;
                }

            break; // wm_command

        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
            return (TRUE);

        } // message switch
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\conman.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     conman.cpp
//
//  PURPOSE:    Defines the CConnectionManager object for Athena.
//

#include "pch.hxx"
#include "conman.h"
#include "error.h"
#include "strconst.h"
#include "rasdlgsp.h"
#include "resource.h"
#include "xpcomm.h"
#include "goptions.h"
#include "thormsgs.h"
#include "wininet.h"
#include "shlwapip.h" 
#include "demand.h"
#include "dllmain.h"
#include "browser.h"
#include <urlmon.h>
#include "menures.h"
#include "workoff.h" 
#include <sync.h>

ASSERTDATA

#define DEF_HANGUP_WAIT            10 // Seconds

static const TCHAR s_szRasDlgDll[] = "RASDLG.DLL";
#ifdef UNICODE
static const TCHAR s_szRasDialDlg[] = "RasDialDlgW";
static const TCHAR s_szRasEntryDlg[] = "RasEntryDlgW";
#else
static const TCHAR s_szRasDialDlg[] = "RasDialDlgA";
static const TCHAR s_szRasEntryDlg[] = "RasEntryDlgA";
#endif

BOOL FIsPlatformWinNT();

//
//  FUNCTION:   CConnectionManager::CConnectionManager()
//
//  PURPOSE:    Constructor
//
CConnectionManager::CConnectionManager()
    {
    m_cRef = 1;
    
    // Synchronization Objects
    InitializeCriticalSection(&m_cs);
    m_hMutexDial = INVALID_HANDLE_VALUE;
    
    m_pAcctMan = 0;
    
    m_fSavePassword = 0;
    m_fRASLoadFailed = 0;
    m_fOffline = 0;

    m_dwConnId = 0;
    ZeroMemory(&m_rConnInfo, sizeof(CONNINFO));
    m_rConnInfo.state = CIS_REFRESH;

    *m_szConnectName = 0;
    ZeroMemory(&m_rdp, sizeof(RASDIALPARAMS));
    
    m_hInstRas = NULL;
    m_hInstRasDlg = NULL;

    m_pNotifyList = NULL;
    m_pConnListHead = NULL;

    m_hInstSensDll = NULL;
    m_fMobilityPackFailed = FALSE;
    m_pIsDestinationReachable = NULL;
    m_pIsNetworkAlive   = NULL;
    
    m_fTryAgain = FALSE;
    m_fDialerUI = FALSE;
    }

//
//  FUNCTION:   CConnectionManager::~CConnectionManager()
//
//  PURPOSE:    Destructor
//
CConnectionManager::~CConnectionManager()
    {
    SafeRelease(m_pAcctMan);

    FreeNotifyList();

    EnterCriticalSection(&m_cs);

    if (m_hInstRas)
        FreeLibrary(m_hInstRas);

    if (m_hInstRasDlg)
        FreeLibrary(m_hInstRasDlg);

    if (m_hInstSensDll)
        FreeLibrary(m_hInstSensDll);

    CloseHandle(m_hMutexDial);


    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);

    EmptyConnList();

    }
    

//
//  FUNCTION:   CConnectionManager::HrInit()
//
//  PURPOSE:    Initalizes the connection manager by attempting to load RAS
//              and storing a pointer to the Account Manager object that is 
//              passed in.
//
//  PARAMETERS:
//      <in> pAcctMan - Pointer to the account manager object that we will 
//                      use to retrieve account information and register for
//                      account changes.
//
//  RETURN VALUE:
//      S_OK                Everything is hunky-dorie
//      HR_E_ALREADYEXISTS  We already exist, can't do it twice.
//      HR_S_RASNOTLOADED   The system doesn't have RAS installed.
//
HRESULT CConnectionManager::HrInit(IImnAccountManager *pAcctMan)
    {
    HRESULT hr = S_OK;

    // Make a copy of the account manager pointer
    if (NULL == pAcctMan)
        {
        AssertSz(pAcctMan, _T("CConnectionManager::HrInit() - Requires an IAccountManager pointer."));
        return (E_INVALIDARG);
        }

    m_pAcctMan = pAcctMan;
    m_pAcctMan->AddRef();
    
    // Register a window class for our advise handling
    WNDCLASS wc;
    wc.style = 0;
    wc.lpfnWndProc = NotifyWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_hInst;
    wc.hIcon = 0;
    wc.hCursor = 0;
    wc.hbrBackground = 0;
    wc.lpszMenuName = 0;
    wc.lpszClassName = NOTIFY_HWND;

    RegisterClass(&wc);

    m_hMutexDial = CreateMutex(NULL, FALSE, NULL);
    if (NULL == m_hMutexDial)
        return (E_FAIL);

    return (S_OK);
    }
    

HRESULT STDMETHODCALLTYPE CConnectionManager::QueryInterface(REFIID riid, LPVOID *ppvObject)
    {
    if (!ppvObject)
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = (LPVOID) (IUnknown*) this;
    else if (IsEqualIID(riid, IID_IImnAdviseAccount))
        *ppvObject = (LPVOID) (IImnAdviseAccount*) this;
    else
        *ppvObject = NULL;

    if (*ppvObject)
        {
        AddRef();
        return (S_OK);
        }
    else
        return (E_NOINTERFACE); 
    }

ULONG STDMETHODCALLTYPE CConnectionManager::AddRef(void)
    {
    return (++m_cRef);
    }


ULONG STDMETHODCALLTYPE CConnectionManager::Release(void)
    {
    ULONG cRef = --m_cRef;
    
    if (m_cRef == 0)
        {
        delete this;
        return (0);
        }

    return (cRef);
    }

HRESULT STDMETHODCALLTYPE CConnectionManager::AdviseAccount(DWORD dwAdviseType, 
                                                            ACTX *pactx)
{
    IImnAccount *pAccount;
    DWORD       dwConnection;

    // SendAdvise(CONNNOTIFY_RASACCOUNTSCHANGED, 0);
    switch (dwAdviseType)
    {
        case AN_ACCOUNT_DELETED:
        {   
            if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pactx->pszAccountID, &pAccount)))
            {
                if (SUCCEEDED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
                {
                    if (dwConnection == CONNECTION_TYPE_RAS)
                    {
                        TCHAR szConnection[CCHMAX_CONNECTOID];
                        *szConnection = '\0';
                        if (SUCCEEDED(pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnection, 
                                                            ARRAYSIZE(szConnection))) && *szConnection)
                        {
                            RemoveFromConnList(szConnection);
                        }
                    }
                }
            }
            break;
        }
    }

    return (S_OK);
}


void CConnectionManager::EmptyConnList()
{
    ConnListNode    *pCur;

    //Delete all the nodes
    while (m_pConnListHead != NULL)
    {
        pCur = m_pConnListHead;
        m_pConnListHead = m_pConnListHead->pNext;
        delete pCur;
    }
    m_pConnListHead = NULL;
}

void CConnectionManager::RemoveFromConnList(LPTSTR  pszRasConn)
{    
    ConnListNode    *prev = NULL,
                    *Cur  = m_pConnListHead;
    LPTSTR          pRasConn;


    while (Cur != NULL)
    {
        if (0 == lstrcmpi(pszRasConn, Cur->pszRasConn))
        {
            if (prev == NULL)
            {
                m_pConnListHead = Cur->pNext;
            }
            else
            {
                prev->pNext = Cur->pNext;
            }
            delete Cur;
        }
        else
        {
            prev = Cur;
            Cur  = Cur->pNext;
        }
    }
    
}

HRESULT CConnectionManager::AddToConnList(LPTSTR  pszRasConn)
{
    //We don't have to make sure that this is not already in the list because once 
    //it is in the list, that means its already connected and so we don't land up in this 
    //situation after that
    ConnListNode    *pnext;
    HRESULT         hres;
    IImnAccount     *pAccount;

    pnext = m_pConnListHead;
    m_pConnListHead = new ConnListNode;
    if (m_pConnListHead != NULL)
    {
        m_pConnListHead->pNext = pnext;
        strcpy(m_pConnListHead->pszRasConn, pszRasConn);
        hres = S_OK;
    }
    else
        hres = E_FAIL;

    return hres;
}

HRESULT CConnectionManager::SearchConnList(LPTSTR  pszRasConn)
{
    ConnListNode    *pCur = m_pConnListHead;
    
    while (pCur != NULL)
    {
        if (0 == lstrcmpi(pszRasConn, pCur->pszRasConn))
            return S_OK;
        pCur = pCur->pNext;
    }
    return E_FAIL;
}

//
//  FUNCTION:   CConnectionManager::CanConnect()
//
//  PURPOSE:    Determines if the caller can connect to the given account
//              using the existing connection.
//
//  PARAMETERS:
//      <in> pAccount - Pointer to the account object the caller wants to 
//                      connect to.
//
//  RETURN VALUE:
//      S_OK    - The caller can connect using the existing connection
//      S_FALSE - There is no existing connection, so there is no reason the
//                caller can't connect.
//      E_FAIL  - The existing connection is different from the account's 
//                connection.  The user must hang up and dial again to connect
//
HRESULT CConnectionManager::CanConnect(IImnAccount *pAccount)
    {
    HRESULT hr;
    DWORD   dwConnection;
    IImnAccount *pDefault = 0;
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    BOOL        fFound = 0;

    // Check to see if we're working offline
    if (IsGlobalOffline())
        return (HR_E_OFFLINE);
    
    // If the connection the user is looking for is not RAS, then we just 
    // return success.
    if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
    {
        // If we didn't get the connection information, then we look for the
        // connection from the default server of this type
        if (FAILED(hr = GetDefaultConnection(pAccount, &pDefault)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            return (S_OK);
        }
        
        // We're going to use the default from now on
        pAccount = pDefault;
        if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            return (S_OK);
        }
    }

    hr = OEIsDestinationReachable(pAccount, dwConnection);

    //I don't think we should be doing this here. Review again
    /*
    if ((hr == S_OK) && (dwConnection == CONNECTION_TYPE_RAS || dwConnection == CONNECTION_TYPE_INETSETTINGS))
    {
        m_rConnInfo.fConnected = TRUE;
    }
    */

//exit:
    SafeRelease(pDefault);
    return (hr);    
    }    


//
//  FUNCTION:   CConnectionManager::CanConnect()
//
//  PURPOSE:    Determines if the caller can connect to the given account
//              using the existing connection.
//
//  PARAMETERS:
//      <in> pszAccount - Pointer to the name of the account the caller wants 
//                        to connect to.
//
//  RETURN VALUE:
//      S_OK    - The caller can connect using the existing connection
//      S_FALSE - There is no existing connection, so there is no reason the
//                caller can't connect.
//      E_FAIL  - The existing connection is different from the account's 
//                connection.  The user must hang up and dial again to connect
//      E_INVALIDARG - The account doesn't exist
//
HRESULT CConnectionManager::CanConnect(LPTSTR pszAccount)
{
    IImnAccount *pAccount = NULL;
    HRESULT      hr;
    
    // Check to see if we're working offline
    if (IsGlobalOffline())
        return (HR_E_OFFLINE);

    // Look up the account name in the account manager to get the account 
    // object.
    Assert(m_pAcctMan);

    if (lstrcmpi(pszAccount, STR_LOCALSTORE) == 0)
        return(S_OK);
    
    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccount, &pAccount)))
        {
        // Call through to the polymorphic version of us
        hr = CanConnect(pAccount);
        pAccount->Release();
        }
    else
        {
        // Bug #36071 - If we haven't set up any accounts of this type yet,
        //              we'd fail.  As a result, if you fire a URL to a server
        //              we'd never try to connect and download.  I'm going
        //              to change this to succeed and we'll see what type
        //              of bugs that creates.
        hr = S_OK;
        }
    
    return (hr);    
}


BOOL CConnectionManager::IsAccountDisabled(LPTSTR pszAccount)
{
    IImnAccount *pAccount = NULL;
	DWORD dw;
    // Look up the account name in the account manager to get the account 
    // object.
    Assert(m_pAcctMan);

    if (lstrcmpi(pszAccount, STR_LOCALSTORE) == 0)
        return(FALSE);
    
    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccount, &pAccount)))
	{
		if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
		{
			if(HideHotmail())
				return(TRUE);
		}
		return(FALSE);
	}
	return(TRUE);
}


//
//  FUNCTION:   CConnectionManager::Connect()
//
//  PURPOSE:    Attempts to establish a connection for the account specified.
//
//  PARAMETERS:
//      <in> pAccount - Pointer to the account object to connect to.
//      <in> hwnd     - Handle of the window to show UI over.  Only needed if 
//                      fShowUI is TRUE.
//      <in> fShowUI  - TRUE if the functions are allowed to display UI.
//
//  RETURN VALUE:
//      S_OK         - We're connected
//      E_UNEXPECTED - There wasn't enough information in pAccount to figure
//                     figure out which connection to use.
//
HRESULT CConnectionManager::Connect(IImnAccount *pAccount, HWND hwnd, BOOL fShowUI)
{
    HRESULT     hr = S_OK;
    DWORD       dwConnection;
    IImnAccount *pDefault = 0;

    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;
        // Check to see if we're working offline
        if (IsGlobalOffline())
        {
            if (fShowUI)
            {
                if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                          0, MB_YESNO | MB_ICONEXCLAMATION ))
                {
                    m_fDialerUI = FALSE;
                    return (HR_E_OFFLINE);
                }
                else
                    g_pConMan->SetGlobalOffline(FALSE);
            }
            else
            {
                m_fDialerUI = FALSE;
                return (HR_E_OFFLINE);
            }
        }
        m_fDialerUI = FALSE;
    }

    if (CanConnect(pAccount) == S_OK)
    {
        return S_OK;
    }

    // If the connection the user is looking for is not RAS, then we just 
    // return success.
    if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
    {
        // If we didn't get the connection information, then we look for the
        // connection from the default server of this type
        if (FAILED(hr = GetDefaultConnection(pAccount, &pDefault)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            return (S_OK);
        }
        
        // We're going to use the default from now on
        pAccount = pDefault;
        if (FAILED(hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection)))
        {
            // Bug #36071 - If we haven't set up any accounts of this type yet,
            //              we'd fail.  As a result, if you fire a URL to a server
            //              we'd never try to connect and download.  I'm going
            //              to change this to succeed and we'll see what type
            //              of bugs that creates.
            hr = S_OK;
            goto exit;
        }
    }


    if (dwConnection == CONNECTION_TYPE_INETSETTINGS)
    {
        hr = ConnectUsingIESettings(hwnd, fShowUI);
        goto exit;
    }

    if (dwConnection == CONNECTION_TYPE_LAN)
    {
        //CanConnect already told us that Lan is not present
        hr = E_FAIL;
        goto exit;
    }

    if (dwConnection != CONNECTION_TYPE_RAS)
    {
        hr = S_OK;
        goto exit;
    }

    // Get the name of the connection while we're at it.
    TCHAR szConnection[CCHMAX_CONNECTOID];
    if (FAILED(hr = pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnection, 
                                        ARRAYSIZE(szConnection))))
    {
        AssertSz(FALSE, _T("CConnectionManager::Connect() - No connection name."));
        hr = E_UNEXPECTED;
        goto exit;
    }

    hr = ConnectActual(szConnection, hwnd, fShowUI);

exit:
    SafeRelease(pDefault);

    return (hr);
}    


//
//  FUNCTION:   CConnectionManager::Connect()
//
//  PURPOSE:    Attempts to establish a connection for the account specified.
//
//  PARAMETERS:
//      <in> pszAccount - Name of the account to connect to.
//      <in> hwnd     - Handle of the window to show UI over.  Only needed if 
//                      fShowUI is TRUE.
//      <in> fShowUI  - TRUE if the functions are allowed to display UI.
//
//  RETURN VALUE:
//      <???>
//
HRESULT CConnectionManager::Connect(LPTSTR pszAccount, HWND hwnd, BOOL fShowUI)
{
    IImnAccount *pAccount = NULL;
    HRESULT      hr;
    
    // Check to see if we're working offline

    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;
        // Check to see if we're working offline
        if (IsGlobalOffline())
        {
            if (fShowUI)
            {
                if (IDNO == AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                          0, MB_YESNO | MB_ICONEXCLAMATION ))
                {
                    m_fDialerUI = FALSE;
                    return (HR_E_OFFLINE);
                }
                else
                    g_pConMan->SetGlobalOffline(FALSE);
            }
            else
            {
                m_fDialerUI = FALSE;
                return (HR_E_OFFLINE);
            }
        }

        m_fDialerUI = FALSE;
    }


    // Look up the account name in the account manager to get the account 
    // object.
    Assert(m_pAcctMan);
    
//    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszAccount, &pAccount)))
    if (SUCCEEDED(m_pAcctMan->FindAccount(AP_ACCOUNT_ID, pszAccount, &pAccount)))
    {
        // Call through to the polymorphic version of us
        hr = Connect(pAccount, hwnd, fShowUI);
        pAccount->Release();
    }
    else
    {
        // Bug #36071 - If we haven't set up any accounts of this type yet,
        //              we'd fail.  As a result, if you fire a URL to a server
        //              we'd never try to connect and download.  I'm going
        //              to change this to succeed and we'll see what type
        //              of bugs that creates.
        hr = S_OK;
    }
    
    return (hr);    
}    


//
//  FUNCTION:   CConnectionManager::Connect()
//
//  PURPOSE:    Attempts to establish a connection for the account specified.
//
//  PARAMETERS:
//      <in> hMenu - Handle of the menu that was used to select the account
//                   to connect to.
//      <in> cmd   - Cmd ID from the menu that says which account to use.
//      <in> hwnd  - Handle to display UI over.
//
//  RETURN VALUE:
//      <???>
//
HRESULT CConnectionManager::Connect(HMENU hMenu, DWORD cmd, HWND hwnd)
{
    MENUITEMINFO mii;

    Assert(hMenu && cmd);
    Assert(cmd >= (DWORD) ID_CONNECT_FIRST && cmd < ((DWORD) ID_CONNECT_FIRST + GetMenuItemCount(hMenu)));

    // Get the account pointer from the menu item
    mii.cbSize     = sizeof(MENUITEMINFO);
    mii.fMask      = MIIM_DATA;
    mii.dwItemData = 0;

    if (GetMenuItemInfo(hMenu, cmd, FALSE, &mii))
    {
        Assert(mii.dwItemData);
        if (mii.dwItemData)
        {
            return (Connect((IImnAccount *) mii.dwItemData, hwnd, TRUE));
        }
    }

    return (E_UNEXPECTED);
}


HRESULT CConnectionManager::ConnectDefault(HWND hwnd, BOOL fShowUI)
{
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
    TCHAR               szConn[CCHMAX_CONNECTOID];
    HRESULT             hr = E_UNEXPECTED;

    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
    {
        pEnum->Reset();

        // Walk through all the accounts
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
        {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
            {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS || dwConn == CONNECTION_TYPE_INETSETTINGS)
                {
                    break;
                }
            }
            SafeRelease(pAcct);
        }
        SafeRelease(pEnum);
    }

    if (pAcct)
    {
        hr = Connect(pAcct, hwnd, fShowUI);
        SafeRelease(pAcct);
    }

    return (hr);
}

//
//  FUNCTION:   CConnectionManager::Disconnect()
//
//  PURPOSE:    Brings down the current RAS connection.
//
//  PARAMETERS:
//      <in> hwnd      - Handle of the window to display UI over.
//      <in> fShowUI   - Allows to caller to determine if UI will be displayed 
//                       while disconnecting.
//      <in> fForce    - Forces the connection down even if we didn't create it.
//      <in> fShutdown - TRUE if we're dropping because we're shutting down.
//
//  RETURN VALUE:
//      S_OK - Everything worked.
//      E_FAIL - We didn't create it
//
HRESULT CConnectionManager::Disconnect(HWND hwnd, BOOL fShowUI, BOOL fForce,
                                       BOOL fShutdown)
{
    HRESULT hr;
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szBuf[CCHMAX_STRINGRES];
    int   idAnswer = IDYES;

    // RefreshConnInfo
    hr = RefreshConnInfo(FALSE);
    if (FAILED(hr))
        return hr;
    
    // See if we even have a RAS connection active
    if (!m_rConnInfo.hRasConn)
        return (S_OK);
    
    /*
    if (!(*m_rConnInfo.szCurrentConnectionName))
        return S_OK;
    */

    // The autodialer has it's own shutdown prompt.  
    if (fShutdown && m_rConnInfo.fAutoDial)
        return (S_OK);

    if (fShutdown && !m_rConnInfo.fIStartedRas)
        return (S_OK);

    if (fShutdown)
    {
        AthLoadString(idsRasPromptDisconnect, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, m_rConnInfo.szCurrentConnectionName);
        
        idAnswer = AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szBuf, 
                                 0, MB_YESNO | MB_ICONEXCLAMATION );
    }
    
    // Hang up
    if (idAnswer == IDYES)
    {
        SendAdvise(CONNNOTIFY_DISCONNECTING, NULL);

        if (S_FALSE == DoAutoDial(hwnd, m_rConnInfo.szCurrentConnectionName, FALSE))
        {
            InternetHangUpAndWait(m_dwConnId, DEF_HANGUP_WAIT);
            /*
            RasHangupAndWait(m_rConnInfo.hRasConn, DEF_HANGUP_WAIT);
            */
        }

        EnterCriticalSection(&m_cs);

        ZeroMemory(&m_rConnInfo, sizeof(CONNINFO));
        m_rConnInfo.state = CIS_CLEAN;
        m_dwConnId = 0;

        LeaveCriticalSection(&m_cs);
        
        EmptyConnList();

        SendAdvise(CONNNOTIFY_DISCONNECTED, NULL);
        return (S_OK);
    }
        
    return (E_FAIL);    
}

//
//  FUNCTION:   CConnectionManager::IsConnected()
//
//  PURPOSE:    Allows the client to query whether or not there is an active
//              RAS connection that we established.
//
//  RETURN VALUE:
//      TRUE - We're connected, FALSE - we're not.
//
BOOL CConnectionManager::IsConnected(void)
{
    BOOL f=FALSE;

    EnterCriticalSection(&m_cs);

    RefreshConnInfo();

    if (m_rConnInfo.hRasConn)
    {
        f = (NULL == m_rConnInfo.hRasConn) ? FALSE : TRUE;
    }

    LeaveCriticalSection(&m_cs);
    return f;
}
    

//
//  FUNCTION:   CConnectionManager::Advise()
//
//  PURPOSE:    Allows the user to register to be notified whenever connection
//              status changes.
//
//  PARAMETERS:
//      <in> pNotify - Pointer to the IConnectionNotify interface the client 
//                     would like called when events happen.
//
//  RETURN VALUE:
//      S_OK          - Added ok.
//      E_OUTOFMEMORY - Couldn't realloc the array
//
HRESULT CConnectionManager::Advise(IConnectionNotify *pNotify)
{
    HRESULT hr = S_OK; 

    if (!pNotify)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);

    // Check to see if we already have a notify window for this thread
    NOTIFYHWND *pTemp = m_pNotifyList;
    DWORD dwThread = GetCurrentThreadId();

    while (pTemp)
    {
        if (pTemp->dwThreadId == dwThread)
            break;

        pTemp = pTemp->pNext;
    }

    // If we didn't find a notify window for this thread, create one
    if (NULL == pTemp)
    {
        HWND hwndTemp = CreateWindow(NOTIFY_HWND, NULL, WS_OVERLAPPED, 10, 10, 10, 10,
                                     NULL, (HMENU) 0, g_hInst, (LPVOID) this);
        if (!hwndTemp)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (!MemAlloc((LPVOID*) &pTemp, sizeof(NOTIFYHWND)))
        {
            RemoveProp(hwndTemp, NOTIFY_HWND);
            DestroyWindow(hwndTemp);
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pTemp->dwThreadId = dwThread;
        pTemp->hwnd = hwndTemp;
        pTemp->pNext = m_pNotifyList;
        m_pNotifyList = pTemp;        
    }

    // Allocate a NOTIFYLIST node for this caller
    NOTIFYLIST *pListTemp;
    if (!MemAlloc((LPVOID*) &pListTemp, sizeof(NOTIFYLIST)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    pListTemp->pNotify = pNotify;

    // Get the current list for this thread and insert this node at the 
    // beginning
    pListTemp->pNext = (NOTIFYLIST *) GetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA);

    // Set this new list to the window
    SetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA, (LONG_PTR)pListTemp);

exit:
    LeaveCriticalSection(&m_cs);
    return (hr);
}    

    
//
//  FUNCTION:   CConnectionManager::Unadvise()
//
//  PURPOSE:    Allows a client that has previously registered for notifications
//              to unregister itself.
//
//  PARAMETERS:
//      <in> pNotify - Pointer to the interface that is being called upon 
//                     notifications.
//
//  RETURN VALUE:
//      E_INVALIDARG - pNotify was not found in the list
//      S_OK         - Everything's OK
//
HRESULT CConnectionManager::Unadvise(IConnectionNotify *pNotify)
{
    DWORD index = 0;
    HRESULT hr = S_OK;
  
    EnterCriticalSection(&m_cs);    

    // Loop through the notify windows we own
    NOTIFYHWND *pTemp = m_pNotifyList;
    NOTIFYHWND *pHwndPrev = NULL;
    while (pTemp)
    {
        // Get the list of notify callbacks for this window
          NOTIFYLIST *pList = (NOTIFYLIST *)GetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA);
        if (pList)
        {
            // Loop through the callbacks looking for this one
            NOTIFYLIST *pListT = pList;
            NOTIFYLIST *pPrev;
    
            // Check to see if it's the first one
            if (pListT->pNotify == pNotify)
            {
                pList = pListT->pNext;
                if (pList)
                {
                    SetWindowLongPtr(pTemp->hwnd, GWLP_USERDATA, (LONG_PTR)pList);
                }
                else
                {
                    Assert(GetCurrentThreadId() == GetWindowThreadProcessId(pTemp->hwnd, NULL));
                    RemoveProp(pTemp->hwnd, NOTIFY_HWND);
                    DestroyWindow(pTemp->hwnd);
                    if (pHwndPrev)
                        pHwndPrev->pNext = pTemp->pNext;
                    else
                        m_pNotifyList = pTemp->pNext;
                    MemFree(pTemp);
                }
                SafeMemFree(pListT);
                hr = S_OK;
                goto exit;
            }
            else
            {
                pPrev = pList;
                pListT = pList->pNext;

                while (pListT)
                {
                    if (pListT->pNotify == pNotify)
                    {
                        pPrev->pNext = pListT->pNext;
                        SafeMemFree(pListT);
                        hr = S_OK;
                        goto exit;
                    }

                    pListT = pListT->pNext;
                    pPrev = pPrev->pNext;
                }
            }
        }

        pHwndPrev = pTemp;
        pTemp = pTemp->pNext;
    }

exit:
    LeaveCriticalSection(&m_cs);
    return (hr);    
}    
    
    
//
//  FUNCTION:   CConnectionManager::RasAccountsExist()
//
//  PURPOSE:    Allows the client to ask whether or not we have any accounts
//              configured that require a RAS connection.
//
//  RETURN VALUE:
//      S_OK    - Accounts exist that require RAS
//      S_FALSE - No accounts exist that require RAS
//
HRESULT CConnectionManager::RasAccountsExist(void)
    {
    IImnEnumAccounts    *pEnum = NULL;
    IImnAccount         *pAcct = NULL;
    DWORD                dwConn;
    BOOL                 fFound = FALSE;

    // If no RAS, no accounts
#ifdef SLOWDOWN_STARTUP_TIME
    if (FAILED(VerifyRasLoaded()))
        return (S_FALSE);
#endif

    // We need to walk through the accounts in the Account Manager to see if
    // any of them have a connect type of RAS.  As soon as we find one, we can
    // return success.
    Assert(m_pAcctMan);

    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        while (!fFound && SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    fFound = TRUE;
                    }
                }
            SafeRelease(pAcct);
            }

        SafeRelease(pEnum);
        }

    return (fFound ? S_OK : S_FALSE);
    }


//
//  FUNCTION:   CConnectionManager::GetConnectMenu()
//
//  PURPOSE:    Returns a menu that has all the accounts that require RAS
//              connections listed.  A pointer to the IImnAccount for each
//              account is stored in the menu item's dwItemData parameter.
//              As a result, the client MUST call FreeConnectMenu() when then
//              menu is no longer being used.
//
//  PARAMETERS:
//      <out> phMenu - Returns the menu handle
//
//  RETURN VALUE:
//      S_OK - phMenu contains the menu
//      E_FAIL - Something unfortunate happend.  
//
HRESULT CConnectionManager::GetConnectMenu(HMENU *phMenu)
    {
    HMENU               hMenu = NULL;
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    TCHAR               szAcct[CCHMAX_ACCOUNT_NAME];
    TCHAR               szConn[CCHMAX_CONNECTOID];
    TCHAR               szConnQuoted[CCHMAX_CONNECTOID + 2], szBuf[CCHMAX_CONNECTOID + 2];
    TCHAR               szMenu[CCHMAX_ACCOUNT_NAME + CCHMAX_CONNECTOID];
    MENUITEMINFO        mii;
    DWORD               cAcct = 0;
    
    // Create a menu and add all the RAS based accounts to it
    Assert(m_pAcctMan);
    hMenu = CreatePopupMenu();
    
    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        // Walk through all the accounts
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, szConn, ARRAYSIZE(szConn));
                    pAcct->GetPropSz(AP_ACCOUNT_NAME, szAcct, ARRAYSIZE(szAcct));
                    wsprintf(szMenu, _T("%s (%s)"), PszEscapeMenuStringA(szAcct, szBuf, sizeof(szBuf) / sizeof(TCHAR)), PszEscapeMenuStringA(szConn, szConnQuoted, sizeof(szConnQuoted) / sizeof(TCHAR)));
                    
                    // Insert the menu item into the menu
                    ZeroMemory(&mii, sizeof(MENUITEMINFO));
                    mii.cbSize     = sizeof(MENUITEMINFO);
                    mii.fMask      = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_TYPE;
                    mii.fType      = MFT_STRING | MFT_RADIOCHECK;
                    mii.fState     = MFS_ENABLED;
                    mii.wID        = ID_CONNECT_FIRST + cAcct;
                    mii.dwItemData = (DWORD_PTR) pAcct;
                    mii.dwTypeData = szMenu;
                    pAcct->AddRef();                    

                    SideAssert(InsertMenuItem(hMenu, cAcct, TRUE, &mii));
                    cAcct++;
                    }
                }
            SafeRelease(pAcct);
            }

        SafeRelease(pEnum);
        }

    if (hMenu)
        if(GetMenuItemCount(hMenu))
            {
            *phMenu = hMenu;
            return (S_OK);
            }
        else
            {
            DestroyMenu(hMenu);
            return (E_FAIL);
            }
    else
        return (E_FAIL);
    }


//
//  FUNCTION:   CConnectionManager::FreeConnectMenu()
//
//  PURPOSE:    Frees the item data stored with the menu returned from 
//              GetConnectMenu().
//
//  PARAMETERS:
//      <in> hMenu - Handle of the menu to free.
//
void CConnectionManager::FreeConnectMenu(HMENU hMenu)
    {
    // Walk through the items on this menu and free the pointers stored in
    // the item data.
    MENUITEMINFO mii;
    int          cItems = 0;

    Assert(hMenu);

    cItems = GetMenuItemCount(hMenu);
    for (int i = 0; i < cItems; i++)
        {
        mii.cbSize      = sizeof(MENUITEMINFO);
        mii.fMask       = MIIM_DATA;
        mii.dwItemData  = 0;

        if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
            {
            Assert(mii.dwItemData);

            if (mii.dwItemData)
                ((IImnAccount *) mii.dwItemData)->Release();
            }
        }

    DestroyMenu(hMenu);
    }


//
//  FUNCTION:   CConnectionManager::OnActivate()
//
//  PURPOSE:    Called whenever the browser receives a WM_ACTIVATE message.
//              In response, we check the current state of our RAS connection
//              to see if we are still connected / disconnected.
void CConnectionManager::OnActivate(BOOL fActive)
    {
    BOOL fOfflineChanged = FALSE;
    BOOL fOffline = FALSE;

    if (fActive)
        {
        EnterCriticalSection(&m_cs);
        m_rConnInfo.state = CIS_REFRESH;

        // Check to see if we've gone offline
        if (m_fOffline != IsGlobalOffline())
            {
            fOffline = m_fOffline = (!m_fOffline);
            fOfflineChanged = TRUE;
            }

        LeaveCriticalSection(&m_cs);

        // Do this outside of the critsec
        if (fOfflineChanged)
            SendAdvise(CONNNOTIFY_WORKOFFLINE, (LPVOID) IntToPtr(fOffline));
        }
    }

//
//  FUNCTION:   CConnectionManager::FillRasCombo()
//
//  PURPOSE:    This function enumerates the accounts in the account manager
//              and builds a list of the RAS connections those accounts use.
//              The function then inserts those connections in to the provided
//              combobox.
//
//  PARAMETERS:
//      <in> hwndCombo - Handle of the combobox to fill
//      <in> fIncludeNone - Inserts a string at the top "Don't dial a connection"
//
//  RETURN VALUE:
//      BOOL
//
BOOL CConnectionManager::FillRasCombo(HWND hwndCombo, BOOL fIncludeNone)
    {
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    LPTSTR             *rgszConn = NULL;
    TCHAR               szConn[CCHMAX_CONNECTOID];
    ULONG               cAcct = 0;
    ULONG               cConn = 0;
    BOOL                fSucceeded = FALSE;
    ULONG               ul;

    LPRASENTRYNAME      pEntry=NULL;
    DWORD               dwSize,
                        cEntries,
                        dwError;

    HRESULT             hr = S_OK;
    int                 i;

    EnterCriticalSection(&m_cs);
#ifdef NEVER

    // Find out how many accounts exist
    m_pAcctMan->GetAccountCount(ACCT_NEWS, &cAcct);
    m_pAcctMan->GetAccountCount(ACCT_MAIL, &ul);
    cAcct += ul;
    m_pAcctMan->GetAccountCount(ACCT_DIR_SERV, &ul);
    cAcct += ul;
        
    if (cAcct == 0)
        {
        fSucceeded = TRUE;
        goto exit;
        }

    // Allocate an array to hold the connection list
    if (!MemAlloc((LPVOID*) &rgszConn, cAcct * sizeof(LPTSTR)))
        goto exit;
    ZeroMemory(rgszConn, cAcct * sizeof(LPTSTR));
    
    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        // Walk through all the accounts
        while (SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, szConn, ARRAYSIZE(szConn));

                    // Check to see if this connection has already been inserted into
                    // our list
                    for (ULONG k = 0; k < cConn; k++)
                        {
                        if (0 == lstrcmpi(szConn, rgszConn[k]))
                            break;
                        }

                    // If we didn't find it, we insert it
                    if (k >= cConn)
                        {
                        rgszConn[cConn] = StringDup(szConn);
                        cConn++;
                        }
                    }
                }
            SafeRelease(pAcct);
            }

        SafeRelease(pEnum);
        }

        // Sort the list
    int i, j, min;
    LPTSTR pszT;
    for (i = 0; i < (int) cConn; i++)
        {
        min = i;
        for (j = i + 1; j < (int) cConn; j++)
            if (0 > lstrcmpi(rgszConn[j], rgszConn[min]))
                min = j;

        pszT = rgszConn[min];
        rgszConn[min] = rgszConn[i];
        rgszConn[i] = pszT;
        }

    // Insert the items into the combo box
    if (fIncludeNone)
        {
        AthLoadString(idsConnNoDial, szConn, ARRAYSIZE(szConn));
        ComboBox_AddString(hwndCombo, szConn);
        }

    for (i = 0; i < (int) cConn; i++)
        ComboBox_AddString(hwndCombo, rgszConn[i]);

#endif NEVER

    // Make sure the RAS DLL is loaded before we try this
    CHECKHR(hr = VerifyRasLoaded());

    // Allocate RASENTRYNAME
    dwSize = sizeof(RASENTRYNAME);
    CHECKHR(hr = HrAlloc((LPVOID*)&pEntry, dwSize));
    
    // Ver stamp the entry
    pEntry->dwSize = sizeof(RASENTRYNAME);
    cEntries = 0;
    dwError = RasEnumEntries(NULL, NULL, pEntry, &dwSize, &cEntries);
    if (dwError == ERROR_BUFFER_TOO_SMALL)
    {
        SafeMemFree(pEntry);
        CHECKHR(hr = HrAlloc((LPVOID *)&pEntry, dwSize));
        pEntry->dwSize = sizeof(RASENTRYNAME);
        cEntries = 0;
        dwError = RasEnumEntries(NULL, NULL, pEntry, &dwSize, &cEntries);        
    }

    // Error ?
    if (dwError)
    {
        hr = TrapError(IXP_E_RAS_ERROR);
        goto exit;
    }

    // Insert the items into the combo box
    if (fIncludeNone)
        {
        AthLoadString(idsConnNoDial, szConn, ARRAYSIZE(szConn));
        ComboBox_AddString(hwndCombo, szConn);
        }

    for (i = 0; i < (int) cEntries; i++)
        ComboBox_AddString(hwndCombo, pEntry[i].szEntryName);

    fSucceeded = TRUE;

exit:
    if (rgszConn)
        {
        for (i = 0; i < (int) cConn; i++)
            SafeMemFree(rgszConn[i]);
        MemFree(rgszConn);
        }

    SafeMemFree(pEntry);

    LeaveCriticalSection(&m_cs);
    return (fSucceeded);
    }


//
//  FUNCTION:   CConnectionManager::DoStartupDial()
//
//  PURPOSE:    This function checks to see what the user's startup options 
//              are with respect to RAS and performs the actions required 
//              (dial, dialog, nada)
//  PARAMETERS:
//      <in> hwndParent - Handle to parent a dialog to
//
void CConnectionManager::DoStartupDial(HWND hwndParent)
{
    DWORD       dwStart;
    DWORD       dw;
    DWORD       dwReturn;
    TCHAR       szConn[CCHMAX_CONNECTOID];
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    DWORD       dwDialFlags = 0;
    DWORD       dwLanFlags = 0;

    // The first thing to do is figure out what the user's startup option if
    dw = DwGetOption(OPT_DIALUP_START);

    // If the user want's to do nothing, we're done
    if (dw == START_NO_CONNECT)
        return;

    //ConnectUsingIESettings(hwndParent, TRUE);
    
    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;
        // Check to see if we're working offline
        if (IsGlobalOffline())
        {
            if (IDYES == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                      0, MB_YESNO | MB_ICONEXCLAMATION ))
            {
                g_pConMan->SetGlobalOffline(FALSE);
            }
            else
            {
                goto DialerExit;
            }
        }

        //We do not dial if there is an active connection already existing. Even if it is not the connection
        //InternetDial would have dialed, if we had called. Heres why:
        //1)We don't want to look into the registry to get the default connectoid.
        //Thats why we call InternetDial with NULL and it dials the def connectoid if there is one set
        //Otherwise it dials the first connectoid in the list.
        //Since InternetDial figures out which connectoid to dial, we don't want to do all the work of figuring
        //out if we are already connected to the connectoid we are going to dial.
        //So we just do not dial even if there is one active connection.

        if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
        {
            if (cConnections > 0)
                goto DialerExit;
        }

        dwDialFlags = INTERNET_AUTODIAL_FORCE_ONLINE;

        if (VerifyMobilityPackLoaded() == S_OK)
        {
            if (!IsNetworkAlive(&dwLanFlags) || (!(dwLanFlags & NETWORK_ALIVE_LAN)))
                dwDialFlags |= INTERNET_DIAL_SHOW_OFFLINE;
        }

        // Only one caller can be dialing the phone at a time.
        if (WAIT_TIMEOUT == WaitForSingleObject(m_hMutexDial, 0))
        {
            goto DialerExit;
        }

        dwReturn = InternetDialA(hwndParent, NULL, dwDialFlags, &m_dwConnId, 0);
        if (dwReturn == 0)
        {
           m_rConnInfo.fConnected = TRUE;
           m_rConnInfo.fIStartedRas = TRUE;
           m_rConnInfo.fAutoDial = FALSE;
           m_rConnInfo.hRasConn  = (HRASCONN)m_dwConnId;
           SendAdvise(CONNNOTIFY_CONNECTED, NULL);
        }
        else
        {
            if (dwReturn == ERROR_USER_DISCONNECTION)
            {
                SendAdvise(CONNNOTIFY_USER_CANCELLED, NULL);
                
                if (!!(dwDialFlags & INTERNET_DIAL_SHOW_OFFLINE))
                    SetGlobalOffline(TRUE);
            }
            else
            {
                DebugTrace("Error dialing: %d\n", GetLastError());
                DebugTrace("InternetDial returned: %d\n", dwReturn);
            }
        }

DialerExit:
        m_fDialerUI = FALSE;
        SafeMemFree(pConnections);
    }

    ReleaseMutex(m_hMutexDial);
}

HRESULT CConnectionManager::GetDefConnectoid(LPTSTR  szConn, DWORD  dwSize)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwType;
    DWORD       dwerr;

    *szConn = '\0';

    if ((dwerr = SHGetValue(HKEY_CURRENT_USER, c_szDefConnPath, c_szRegDefaultConnection, &dwType, szConn, &dwSize)) 
        == ERROR_SUCCESS)
    {
        hr = S_OK;
    }
    return hr;
}

//
//  FUNCTION:   CConnectionManager::VerifyRasLoaded()
//
//  PURPOSE:    Checks to see if this object has already loaded the RAS DLL.  
//              If not, then the DLL is loaded and the function pointers are
//              fixed up.
//
//  RETURN VALUE:
//      S_OK             - Loaded and ready, sir.
//      hrRasInitFailure - Failed to load.
//
HRESULT CConnectionManager::VerifyRasLoaded(void)
    {
    // Locals
    UINT uOldErrorMode;

    // Protected
    EnterCriticalSection(&m_cs);

    // Check to see if we've tried this before
    if (m_fRASLoadFailed)
        goto failure;

    // Bug #20573 - Let's do a little voodoo here.  On NT, it appears that they
    //              have a key in the registry to show which protocols are 
    //              supported by RAS service.  AKA - if this key doesn't exist,
    //              then RAS isn't installed.  This may enable us to avoid some
    //              special bugs when RAS get's uninstalled on NT.
    if (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
        HKEY hKey;
        const TCHAR c_szRegKeyRAS[] = _T("SOFTWARE\\Microsoft\\RAS");

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyRAS, 0, KEY_READ, &hKey))
            {
            goto failure;
            }

        RegCloseKey(hKey);
        }

    // If dll is loaded, lets verify all of my function pointers
    if (!m_hInstRas)
        {
        // Try loading Ras.        
        uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        m_hInstRas = LoadLibrary(szRasDll);
        SetErrorMode(uOldErrorMode);

        // Failure ?
        if (!m_hInstRas)
            goto failure;

        // Did we load it
        m_pRasDial = (RASDIALPROC)GetProcAddress(m_hInstRas, szRasDial);
        m_pRasEnumConnections = (RASENUMCONNECTIONSPROC)GetProcAddress(m_hInstRas, szRasEnumConnections);                    
        m_pRasEnumEntries = (RASENUMENTRIESPROC)GetProcAddress(m_hInstRas, szRasEnumEntries);                    
        m_pRasGetConnectStatus = (RASGETCONNECTSTATUSPROC)GetProcAddress(m_hInstRas, szRasGetConnectStatus);                    
        m_pRasGetErrorString = (RASGETERRORSTRINGPROC)GetProcAddress(m_hInstRas, szRasGetErrorString);                    
        m_pRasHangup = (RASHANGUPPROC)GetProcAddress(m_hInstRas, szRasHangup);                    
        m_pRasSetEntryDialParams = (RASSETENTRYDIALPARAMSPROC)GetProcAddress(m_hInstRas, szRasSetEntryDialParams);                    
        m_pRasGetEntryDialParams = (RASGETENTRYDIALPARAMSPROC)GetProcAddress(m_hInstRas, szRasGetEntryDialParams);
        m_pRasEditPhonebookEntry = (RASEDITPHONEBOOKENTRYPROC)GetProcAddress(m_hInstRas, szRasEditPhonebookEntry);    
        m_pRasGetEntryProperties = (RASGETENTRYPROPERTIES) GetProcAddress(m_hInstRas, szRasGetEntryProperties);
        }

    if (!m_hInstRasDlg && FIsPlatformWinNT())
        {
        // Try loading Ras.        
        uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        m_hInstRasDlg = LoadLibrary(s_szRasDlgDll);
        SetErrorMode(uOldErrorMode);

        // Failure ?
        if (!m_hInstRasDlg)
            goto failure;

        m_pRasDialDlg = (RASDIALDLGPROC)GetProcAddress(m_hInstRasDlg, s_szRasDialDlg);
        m_pRasEntryDlg = (RASENTRYDLGPROC)GetProcAddress(m_hInstRasDlg, s_szRasEntryDlg);

        if (!m_pRasDialDlg || !m_pRasEntryDlg)
            goto failure;
        }

    // Make sure all functions have been loaded
    if (m_pRasDial                      &&
        m_pRasEnumConnections           &&
        m_pRasEnumEntries               &&
        m_pRasGetConnectStatus          &&
        m_pRasGetErrorString            &&
        m_pRasHangup                    &&
        m_pRasSetEntryDialParams        &&
        m_pRasGetEntryDialParams        &&
        m_pRasEditPhonebookEntry)
        {
        // Protected
        LeaveCriticalSection(&m_cs);

        // Success
        return S_OK;
        }

failure:
    m_fRASLoadFailed = TRUE;

    // Protected
    LeaveCriticalSection(&m_cs);

    // Otherwise, were hosed
    return (hrRasInitFailure);
    }


//
//  FUNCTION:   CConnectionManager::EnumerateConnections()
//
//  PURPOSE:    Asks RAS for the list of active RAS connections.
//
//  PARAMETERS:
//      <out> ppRasConn     - Returns an array of RASCONN structures for the
//                            list of active connections.
//      <out> pcConnections - Number of structures in ppRasCon.
//
//  RETURN VALUE:
//      S_OK - The data in ppRasConn and pcConnections is valid
//
HRESULT CConnectionManager::EnumerateConnections(LPRASCONN *ppRasConn, 
                                                 ULONG *pcConnections)
    {
    // Locals
    DWORD       dw, 
                dwSize;
    BOOL        fResult=FALSE;
    HRESULT     hr;

    // Check Params
    Assert(ppRasConn && pcConnections);

    // Make sure RAS is loaded
    if (FAILED(hr = VerifyRasLoaded()))
        return (hr);

    // Init
    *ppRasConn = NULL;
    *pcConnections = 0;

    // Sizeof my buffer
    dwSize = sizeof(RASCONN) * 2;

    // Allocate enough for 1 ras connection info object
    if (!MemAlloc((LPVOID *)ppRasConn, dwSize))
        {
        TRAPHR(hrMemory);
        return (E_OUTOFMEMORY);
        }

    ZeroMemory(*ppRasConn, dwSize);

    // Buffer size
    //(*ppRasConn)->dwSize = dwSize;
    (*ppRasConn)->dwSize = sizeof(RASCONN);

    // Enumerate ras connections
    dw = RasEnumConnections(*ppRasConn, &dwSize, pcConnections);

    // Not enough memory ?
    if ((dw == ERROR_BUFFER_TOO_SMALL) || (dw == ERROR_NOT_ENOUGH_MEMORY))
        {
        // Reallocate
        if (!MemRealloc((LPVOID *)ppRasConn, dwSize))
            {
            TRAPHR(hrMemory);
            goto exit;
            }

        // Call enumerate again
        *pcConnections = 0;
        (*ppRasConn)->dwSize = sizeof(RASCONN);
        dw = RasEnumConnections(*ppRasConn, &dwSize, pcConnections);
        }

    // If still failed
    if (dw)
        {
        AssertSz(FALSE, "RasEnumConnections failed");
        return E_FAIL;
        }   
    // Success
    hr = S_OK;
exit:
    // Done
    return S_OK;
    }


//
//  FUNCTION:   CConnectionManager::StartRasDial()
//
//  PURPOSE:    Called when the client actually wants to establish a RAS 
//              connection.
//
//  PARAMETERS:
//      <in> hwndParent    - Handle of the window to parent any UI
//      <in> pszConnection - Name of the connection to establish
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CConnectionManager::StartRasDial(HWND hwndParent, LPTSTR pszConnection)
    {
    HRESULT       hr = S_OK;

    // Refresh ConnInfo
    CHECKHR(hr = RefreshConnInfo());
    
    // Check to see if we need to ask the user for information or credentials
    // before we attempt to dial
    CHECKHR (hr = RasLogon(hwndParent, pszConnection, FALSE));

    // If we can use a system dialog for this, do so.
    if (m_pRasDialDlg)
        {
        RASDIALDLG rdd = {0};
        BOOL       fRet;

        rdd.dwSize     = sizeof(rdd);
        rdd.hwndOwner  = hwndParent;

#if (WINVER >= 0x401)
        rdd.dwSubEntry = m_rdp.dwSubEntry;
#else
        rdd.dwSubEntry = 0;
#endif

        fRet = RasDialDlg(NULL, m_rdp.szEntryName, 
                          lstrlen(m_rdp.szPhoneNumber) ? m_rdp.szPhoneNumber : NULL, 
                          &rdd);
        if (fRet)
            {
            // Need to get the current connection handle
            LPRASCONN   pConnections = NULL;
            ULONG       cConnections = 0;

            if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
                {
                for (UINT i = 0; i < cConnections; i++)
                    {
                    if (0 == lstrcmpi(pConnections[i].szEntryName, m_rdp.szEntryName))
                        {
                        EnterCriticalSection(&m_cs);
                        m_rConnInfo.hRasConn = pConnections[i].hrasconn;
                        LeaveCriticalSection(&m_cs);
                        break;
                        }
                    }

                SafeMemFree(pConnections);
                }

            hr = S_OK;
            }
        else
            hr = E_FAIL;
        }
    else
        {
        // We need to use our own RAS UI.
        hr = (HRESULT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRasProgress), 
                            hwndParent, (DLGPROC) RasProgressDlgProc, 
                            (LPARAM) this);
        }

exit:
    // Done
    return hr;
    }
    

//
//  FUNCTION:   CConnectionManager::RasLogon()
//
//  PURPOSE:    Attempts to load the RAS phonebook entry for the requested
//              connection.  If it doesn't exist or there isn't enough info,
//              we present UI to the user to request that information.
//
//  PARAMETERS:
//      <in>  hwnd          - Handle to display UI over.
//      <in>  pszConnection - Name of the connection to load info for.
//      <in>  fForcePrompt  - Forces the UI to be displayed.
//
//  RETURN VALUE:
//      S_OK                  - prdp contains the requested information
//      hrGetDialParmasFailed - Couldn't get the phonebook entry from RAS
//      hrUserCancel          - User canceled
//
//
HRESULT CConnectionManager::RasLogon(HWND hwnd, LPTSTR pszConnection, 
                                     BOOL fForcePrompt)
    {
    // Locals
    HRESULT         hr = S_OK;
    DWORD           dwRasError;

    // Do we need to prompt for logon information first ?
    ZeroMemory(&m_rdp, sizeof(RASDIALPARAMS));
    m_rdp.dwSize = sizeof(RASDIALPARAMS);
    lstrcpy(m_rdp.szEntryName, pszConnection);

    // See if we can get the information from RAS
    dwRasError = RasGetEntryDialParams(NULL, &m_rdp, &m_fSavePassword);
    if (dwRasError)
        {
        TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
        AthLoadString(idshrGetDialParamsFailed, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, pszConnection);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), szBuf, 0, MB_OK | MB_ICONSTOP);
        hr = TRAPHR(hrGetDialParamsFailed);
        goto exit;
        }

    // NT Supports the UI we need to display.  If this exists, then
    // RasDialDlg will take it from here
    if (m_pRasDialDlg)
        {         
        goto exit;
        }

    // Do we need to get password / account information?
    if (fForcePrompt || m_fSavePassword == FALSE || 
        FIsStringEmpty(m_rdp.szUserName) || FIsStringEmpty(m_rdp.szPassword))
        {
        // RAS Logon
        hr = (HRESULT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRasLogon), hwnd, 
                            (DLGPROC) RasLogonDlgProc, (LPARAM) this);
        if (hr == hrUserCancel)
            {
            DisplayRasError(hwnd, hrUserCancel, 0);
            hr = hrUserCancel;
            goto exit;
            }
        }

exit:
    // Done
    return hr;
    }


//
//  FUNCTION:   CConnectionManager::DisplayRasError()
//
//  PURPOSE:    Displays a message box describing the error that occured while
//              dealing with connections etc.
//
//  PARAMETERS:
//      <in> hwnd       - Handle of the window to display UI over
//      <in> hrRasError - HRESULT to display the error for
//      <in> dwRasError - Error code returned from RAS to display the error for
//
void CConnectionManager::DisplayRasError(HWND hwnd, HRESULT hrRasError,
                                         DWORD dwRasError)
    {
    // Locals
    TCHAR       szRasError[256];
    BOOL        fRasError = FALSE;

    // No Error
    if (SUCCEEDED(hrRasError))
        return;

    // Look up RAS error
    if (dwRasError)
        {
        if (RasGetErrorString(dwRasError, szRasError, sizeof(szRasError)) == 0)
            fRasError = TRUE;
        else
            *szRasError = _T('\0');
        }

    // General Error
    switch (hrRasError)
        {
        case hrUserCancel:
            break;

        case hrMemory:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(idsMemory), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrRasInitFailure:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasInitFailure), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrRasDialFailure:
            if (fRasError)
                CombinedRasError(hwnd, HR_CODE(hrRasDialFailure), szRasError, dwRasError);
            else
                AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasDialFailure), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrRasServerNotFound:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrRasServerNotFound), 0, MB_OK | MB_ICONSTOP);
            break;

        case hrGetDialParamsFailed:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(hrGetDialParamsFailed), 0, MB_OK | MB_ICONSTOP);
            break;

        case E_FAIL:
        default:
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsRasError), MAKEINTRESOURCEW(idsRasErrorGeneral), 0, MB_OK | MB_ICONSTOP);
            break;
        }

    }
        

//
//  FUNCTION:   CConnectionManager::PromptCloseConn()
//
//  PURPOSE:    Asks the user if they want to close the current connection or
//              try to use it.
//
//  PARAMETERS:
//      <in> hwnd - Parent for the dialog
//
//  RETURN VALUE:
//      Returns the button that closed the dialog
//
UINT CConnectionManager::PromptCloseConnection(HWND hwnd)
    {
    RefreshConnInfo();

    if (DwGetOption(OPT_DIALUP_WARN_SWITCH))
        {
        if (0 == lstrcmpi(m_rConnInfo.szCurrentConnectionName, m_szConnectName))
            return (idrgUseCurrent);
        else
            return (UINT) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddRasCloseConn), hwnd, 
                                  (DLGPROC) RasCloseConnDlgProc, (LPARAM) this);
        }
    else
        return (idrgDialNew);
    }
    
INT_PTR CALLBACK CConnectionManager::RasCloseConnDlgProc(HWND hwnd, UINT uMsg, 
                                                      WPARAM wParam, LPARAM lParam)
    {
    // Locals
    CConnectionManager *pThis = NULL;
    TCHAR szRes[255],
          szMsg[255+RAS_MaxEntryName+1];
    TCHAR szConn[CCHMAX_CONNECTOID + 2];

    switch(uMsg)
        {
        case WM_INITDIALOG:
            // The LPARAM contains our this pointer
            pThis = (CConnectionManager*) lParam;
            if (!pThis)
                {
                Assert(pThis);
                EndDialog(hwnd, E_FAIL);
                return (TRUE);
                }

            // Center
            CenterDialog(hwnd);

            // Refresh Connection Info
            pThis->RefreshConnInfo();

            // Set Text
            GetWindowText(GetDlgItem(hwnd, idcCurrentMsg), szRes, sizeof(szRes)/sizeof(TCHAR));
            wsprintf(szMsg, szRes, PszEscapeMenuStringA(pThis->m_rConnInfo.szCurrentConnectionName, szConn, sizeof(szConn) / sizeof(TCHAR)));
            SetWindowText(GetDlgItem(hwnd, idcCurrentMsg), szMsg);

            // Set control
            GetWindowText(GetDlgItem(hwnd, idrgDialNew), szRes, sizeof(szRes)/sizeof(TCHAR));
            wsprintf(szMsg, szRes, PszEscapeMenuStringA(pThis->m_szConnectName, szConn, sizeof(szConn) / sizeof(TCHAR)));
            SetWindowText(GetDlgItem(hwnd, idrgDialNew), szMsg);

            // Set Default
            CheckDlgButton(hwnd, idrgDialNew, TRUE);
            return (TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDOK:
                    {
                    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, idcDontWarnCheck)))
                        {
                        // If the user has this checked, we reset the "Warn before..." option
                        SetDwOption(OPT_DIALUP_WARN_SWITCH, 0, NULL, 0);
                        }
                    EndDialog(hwnd, IsDlgButtonChecked(hwnd, idrgDialNew) ? idrgDialNew : idrgUseCurrent);
                    return (TRUE);    
                    }

                case IDCANCEL:
                    EndDialog(hwnd, IDCANCEL);
                    return (TRUE);    
                }
            return (TRUE);    
        }
        
    return (FALSE);
    }


//
//  FUNCTION:   CConnectionMAanger::CombinedRasError()
//
//  PURPOSE:    <???>
//
//  PARAMETERS:
//      <???>
//
void CConnectionManager::CombinedRasError(HWND hwnd, UINT unids, 
                                          LPTSTR pszRasError, DWORD dwRasError)
    {
    // Locals
    TCHAR           szRes[255],
                    sz[30];
    LPTSTR          pszError=NULL;

    // Load string
    AthLoadString(unids, szRes, sizeof(szRes));

    // Allocate memory for errors
    pszError = SzStrAlloc(lstrlen(szRes) + lstrlen(pszRasError) + 100);

    // Out of Memory ?
    if (!pszError)
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), szRes, 0, MB_OK | MB_ICONSTOP);

    // Build Error message
    else
        {
        AthLoadString(idsErrorText, sz, sizeof(sz));
        wsprintf(pszError, "%s\n\n%s %d: %s", szRes, sz, dwRasError, pszRasError);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsRasError), pszError, 0, MB_OK | MB_ICONSTOP);
        MemFree(pszError);
        }
    }    
    

//
//  FUNCTION:   CConnectionManager::RasHangupAndWait()
//
//  PURPOSE:    Hangs up on a RAS connection and waits for it to finish before
//              returning.
//
//  PARAMETERS:
//      <in> hRasConn         - Handle of the connection to hang up.
//      <in> dwMaxWaitSeconds - Amount of time to wait.
//
//  RETURN VALUE:
//      TRUE if we disconnected, FALSE otherwise.
//
BOOL CConnectionManager::RasHangupAndWait(HRASCONN hRasConn, DWORD dwMaxWaitSeconds)
    {
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();

    // Check Params
    if (!hRasConn)
        return 0;

    // Make sure RAS is loaded
    if (FAILED (VerifyRasLoaded()))
        return FALSE;

    // Call Ras hangup
    if (RasHangup(hRasConn))
        return FALSE;

    // Wait for connection to really close
    ZeroMemory(&rcs, sizeof(RASCONNSTATUS));
    rcs.dwSize = sizeof(RASCONNSTATUS);
    while (RasGetConnectStatus(hRasConn, &rcs) != ERROR_INVALID_HANDLE && rcs.rasconnstate != RASCS_Disconnected)
        {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
        }

    // Wait 2 seconds for modem to reset
    Sleep(2000);

    // Done
    return TRUE;
    }
    
DWORD CConnectionManager::InternetHangUpAndWait(DWORD_PTR   hRasConn, DWORD dwMaxWaitSeconds)
{
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();
    DWORD           dwret;

    // Check Params
    if (!hRasConn)
        return 0;

    // Make sure RAS is loaded
    if (FAILED (VerifyRasLoaded()))
        return FALSE;

    dwret = InternetHangUp(m_dwConnId, 0);
    if (dwret)
    {
        DebugTrace("InternetHangup failed: %d\n", dwret);
        goto exit;
    }

    // Wait for connection to really close
    ZeroMemory(&rcs, sizeof(RASCONNSTATUS));
    rcs.dwSize = sizeof(RASCONNSTATUS);
    while (RasGetConnectStatus((HRASCONN)hRasConn, &rcs) != ERROR_INVALID_HANDLE && rcs.rasconnstate != RASCS_Disconnected)
        {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
        }

    // Wait 2 seconds for modem to reset
    Sleep(2000);

exit:
    return dwret;
}

INT_PTR CALLBACK CConnectionManager::RasLogonDlgProc(HWND hwnd, UINT uMsg, 
                                                  WPARAM wParam, LPARAM lParam)
    {
    // Locals
    TCHAR           sz[255],
                    szText[255 + RAS_MaxEntryName + 1];
    DWORD           dwRasError;
    CConnectionManager *pThis = (CConnectionManager *)GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get lparam
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
                {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                return (TRUE);
                }

            // Center the window
            CenterDialog(hwnd);

            // Get Window Title
            GetWindowText(hwnd, sz, sizeof(sz));
            wsprintf(szText, sz, pThis->m_szConnectName);
            SetWindowText(hwnd, szText);

            // Word Default
            AthLoadString(idsDefault, sz, sizeof(sz));
            
            // Set Fields
            Edit_LimitText(GetDlgItem(hwnd, ideUserName), UNLEN);
            Edit_LimitText(GetDlgItem(hwnd, idePassword), PWLEN);
            Edit_LimitText(GetDlgItem(hwnd, idePhone), RAS_MaxPhoneNumber);
            
            SetDlgItemText(hwnd, ideUserName, pThis->m_rdp.szUserName);
            SetDlgItemText(hwnd, idePassword, pThis->m_rdp.szPassword);

            if (FIsStringEmpty(pThis->m_rdp.szPhoneNumber))
                SetDlgItemText(hwnd, idePhone, sz);
            else
                SetDlgItemText(hwnd, idePhone, pThis->m_rdp.szPhoneNumber);

            CheckDlgButton(hwnd, idchSavePassword, pThis->m_fSavePassword);

            // Save pRas
            SetWndThisPtr(hwnd, pThis);
            return 1;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
                {
                case idbEditConnection:
                    pThis->EditPhonebookEntry(hwnd, (pThis->m_szConnectName));
                    return 1;

                case IDCANCEL:
                    EndDialog(hwnd, hrUserCancel);
                    return 1;

                case IDOK:
                    AthLoadString(idsDefault, sz, sizeof(sz));

                    // Set Fields
                    GetDlgItemText(hwnd, ideUserName, pThis->m_rdp.szUserName, UNLEN+1);
                    GetDlgItemText(hwnd, idePassword, pThis->m_rdp.szPassword, PWLEN+1);

                    GetDlgItemText(hwnd, idePhone, pThis->m_rdp.szPhoneNumber, RAS_MaxPhoneNumber+1);
                    if (lstrcmp(pThis->m_rdp.szPhoneNumber, sz) == 0)
                        *pThis->m_rdp.szPhoneNumber = _T('\0');
                    
                    pThis->m_fSavePassword = IsDlgButtonChecked(hwnd, idchSavePassword);

                    // Save Dial Parameters
                    dwRasError = (pThis->m_pRasSetEntryDialParams)(NULL, &(pThis->m_rdp), !(pThis->m_fSavePassword));
                    if (dwRasError)
                    {
                        pThis->DisplayRasError(hwnd, hrSetDialParamsFailed, dwRasError);
                        return 1;
                    }
                    EndDialog(hwnd, S_OK);
                    return 1;
                }
            break;

        case WM_DESTROY:
            SetWndThisPtr (hwnd, NULL);
            break;
        }
    return 0;
    }
    

INT_PTR CALLBACK CConnectionManager::RasProgressDlgProc(HWND hwnd, UINT uMsg, 
                                                     WPARAM wParam, LPARAM lParam)
    {
    // Locals
    CConnectionManager *pThis = (CConnectionManager *) GetWndThisPtr(hwnd);
    TCHAR           szText[255+RAS_MaxEntryName+1],
                    sz[255];
    static TCHAR    s_szCancel[40];
    static UINT     s_unRasEventMsg=0;
    static BOOL     s_fDetails=FALSE;
    static RECT     s_rcDialog;
    static BOOL     s_fAuthStarted=FALSE;
    DWORD           dwRasError,
                    cyDetails;
    RASCONNSTATUS   rcs;
    RECT            rcDetails,
                    rcDlg;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Get lparam
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
            {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                return 1;
            }

            // Save this pointer
            SetWndThisPtr (hwnd, pThis);

            // Save Original Size of the dialog
            GetWindowRect (hwnd, &s_rcDialog);

            // Refresh Connection Info
            pThis->RefreshConnInfo();

            // Details enabled
            s_fDetails = DwGetOption(OPT_RASCONNDETAILS);

            // Hide details drop down
            if (s_fDetails == FALSE)
            {
                // Hid
                GetWindowRect (GetDlgItem (hwnd, idcSplitter), &rcDetails);

                // Height of details
                cyDetails = s_rcDialog.bottom - rcDetails.top;
        
                // Re-size
                MoveWindow (hwnd, s_rcDialog.left, 
                                  s_rcDialog.top, 
                                  s_rcDialog.right - s_rcDialog.left, 
                                  s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1,
                                  FALSE);
            }
            else
            {
                AthLoadString (idsHideDetails, sz, sizeof (sz));
                SetWindowText (GetDlgItem (hwnd, idbDet), sz);
            }

            // Get registered RAS event message id
            s_unRasEventMsg = RegisterWindowMessageA(RASDIALEVENT);
            if (s_unRasEventMsg == 0)
                s_unRasEventMsg = WM_RASDIALEVENT;

            // Center the window
            CenterDialog (hwnd);
            SetForegroundWindow(hwnd);

            // Get Window Title
            GetWindowText(hwnd, sz, sizeof(sz));
            wsprintf(szText, sz, pThis->m_szConnectName);
            SetWindowText(hwnd, szText);

            // Dialog Xxxxxxx.....
            if (pThis->m_rdp.szPhoneNumber[0])
                {
                AthLoadString(idsRas_Dialing_Param, sz, sizeof(sz)/sizeof(TCHAR));
                wsprintf(szText, sz, pThis->m_rdp.szPhoneNumber);
                }
            else
                AthLoadString(idsRas_Dialing, szText, ARRAYSIZE(szText));

            SetWindowText(GetDlgItem(hwnd, ideProgress), szText);

            // Get Cancel Text
            GetWindowText(GetDlgItem(hwnd, IDCANCEL), s_szCancel, sizeof(s_szCancel));

            // Give the list box and hscroll
            SendMessage(GetDlgItem(hwnd, idlbDetails), LB_SETHORIZONTALEXTENT, 600, 0);

            // Dial the connection
            pThis->m_rConnInfo.hRasConn = NULL;
            dwRasError = (pThis->m_pRasDial)(NULL, NULL, &(pThis->m_rdp), 0xFFFFFFFF, hwnd, &(pThis->m_rConnInfo.hRasConn));
            if (dwRasError)
            {
                pThis->FailedRasDial(hwnd, hrRasDialFailure, dwRasError);
                if (!pThis->LogonRetry(hwnd, s_szCancel))
                {
                    SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                    return 1;
                }
            }
            return 1;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam,lParam))
            {
            case IDCANCEL:
                SetDwOption(OPT_RASCONNDETAILS, s_fDetails, NULL, 0);
                EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
                if (pThis)
                    pThis->FailedRasDial(hwnd, hrUserCancel, 0);
                EndDialog(hwnd, hrUserCancel);
                return 1;

            case idbDet:
                // Get current location of the dialog
                GetWindowRect (hwnd, &rcDlg);

                // If currently hidden
                if (s_fDetails == FALSE)
                {
                    // Re-size
                    MoveWindow (hwnd, rcDlg.left, 
                                      rcDlg.top, 
                                      s_rcDialog.right - s_rcDialog.left, 
                                      s_rcDialog.bottom - s_rcDialog.top,
                                      TRUE);

                    AthLoadString (idsHideDetails, sz, sizeof (sz));
                    SetWindowText (GetDlgItem (hwnd, idbDet), sz);
                    s_fDetails = TRUE;
                }

                else
                {
                    // Size of details
                    GetWindowRect (GetDlgItem (hwnd, idcSplitter), &rcDetails);
                    cyDetails = rcDlg.bottom - rcDetails.top;
                    MoveWindow (hwnd, rcDlg.left, 
                                      rcDlg.top, 
                                      s_rcDialog.right - s_rcDialog.left, 
                                      s_rcDialog.bottom - s_rcDialog.top - cyDetails - 1,
                                      TRUE);

                    AthLoadString (idsShowDetails, sz, sizeof (sz));
                    SetWindowText (GetDlgItem (hwnd, idbDet), sz);
                    s_fDetails = FALSE;
                }
                break;
            }
            break;

        case WM_DESTROY:
            SetWndThisPtr (hwnd, NULL);
            break;

        case CM_INTERNALRECONNECT:
            if (!pThis->LogonRetry(hwnd, s_szCancel))
                {
                SendMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDCANCEL,IDCANCEL), NULL);
                return 1;
                }
            break;
    

        default:
            if (!pThis)
                break;

            pThis->RefreshConnInfo();

            if (uMsg == s_unRasEventMsg)
            {
                HWND hwndLB = GetDlgItem(hwnd, idlbDetails);

                // Error ?
                if (lParam)
                {
                    // Disconnected
                    AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
                    ListBox_AddString(hwndLB, sz);

                    // Log Error
                    TCHAR szRasError[512];
                    if ((pThis->m_pRasGetErrorString)((UINT) lParam, szRasError, sizeof(szRasError)) == 0)
                    {
                        TCHAR szError[512 + 255];
                        AthLoadString(idsErrorText, sz, sizeof(sz));
                        wsprintf(szError, "%s %d: %s", sz, lParam, szRasError);
                        ListBox_AddString(hwndLB, szError);
                    }

                    // Select last item
                    SendMessage(hwndLB, LB_SETCURSEL, ListBox_GetCount(hwndLB)-1, 0);

                    // Show Error
                    pThis->FailedRasDial(hwnd, hrRasDialFailure, (DWORD) lParam);

                    // Re logon
                    PostMessage(hwnd, CM_INTERNALRECONNECT, 0, 0);

                }

                // Otherwise, process RAS event
                else
                {
                    switch(wParam)
                    {
                    case RASCS_OpenPort:
                        AthLoadString(idsRASCS_OpenPort, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_PortOpened:
                        AthLoadString(idsRASCS_PortOpened, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_ConnectDevice:
                        rcs.dwSize = sizeof(RASCONNSTATUS);                    
                        if (pThis->m_rConnInfo.hRasConn && (pThis->m_pRasGetConnectStatus)(pThis->m_rConnInfo.hRasConn, &rcs) == 0)
                        {
                            AthLoadString(idsRASCS_ConnectDevice, sz, sizeof(sz)/sizeof(TCHAR));
                            wsprintf(szText, sz, rcs.szDeviceName, rcs.szDeviceType);
                            ListBox_AddString(hwndLB, szText);
                        }
                        break;

                    case RASCS_DeviceConnected:
                        rcs.dwSize = sizeof(RASCONNSTATUS);                    
                        if (pThis->m_rConnInfo.hRasConn && (pThis->m_pRasGetConnectStatus)(pThis->m_rConnInfo.hRasConn, &rcs) == 0)
                        {
                            AthLoadString(idsRASCS_DeviceConnected, sz, sizeof(sz)/sizeof(TCHAR));
                            wsprintf(szText, sz, rcs.szDeviceName, rcs.szDeviceType);
                            ListBox_AddString(hwndLB, szText);
                        }
                        break;

                    case RASCS_AllDevicesConnected:
                        AthLoadString(idsRASCS_AllDevicesConnected, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_Authenticate:
                        if (s_fAuthStarted == FALSE)
                        {
                            AthLoadString(idsRas_Authentication, sz, sizeof(sz)/sizeof(TCHAR));
                            SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                            ListBox_AddString(hwndLB, sz);
                            s_fAuthStarted = TRUE;
                        }
                        break;

                    case RASCS_AuthNotify:
                        rcs.dwSize = sizeof(RASCONNSTATUS);                    
                        if (pThis->m_rConnInfo.hRasConn && (pThis->m_pRasGetConnectStatus)(pThis->m_rConnInfo.hRasConn, &rcs) == 0)
                        {
                            AthLoadString(idsRASCS_AuthNotify, sz, sizeof(sz)/sizeof(TCHAR));
                            wsprintf(szText, sz, rcs.dwError);
                            ListBox_AddString(hwndLB, szText);
                            if (rcs.dwError)
                            {
                                pThis->FailedRasDial(hwnd, hrRasDialFailure, rcs.dwError);
                                PostMessage(hwnd, CM_INTERNALRECONNECT, 0, 0);
                            }
                        }
                        break;

                    case RASCS_AuthRetry:
                        AthLoadString(idsRASCS_AuthRetry, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthCallback:
                        AthLoadString(idsRASCS_AuthCallback, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthChangePassword:
                        AthLoadString(idsRASCS_AuthChangePassword, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthProject:
                        AthLoadString(idsRASCS_AuthProject, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthLinkSpeed:
                        AthLoadString(idsRASCS_AuthLinkSpeed, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_AuthAck:
                        AthLoadString(idsRASCS_AuthAck, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_ReAuthenticate:
                        AthLoadString(idsRas_Authenticated, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        AthLoadString(idsRASCS_Authenticated, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_PrepareForCallback:
                        AthLoadString(idsRASCS_PrepareForCallback, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_WaitForModemReset:
                        AthLoadString(idsRASCS_WaitForModemReset, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_WaitForCallback:
                        AthLoadString(idsRASCS_WaitForCallback, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_Projected:
                        AthLoadString(idsRASCS_Projected, sz, sizeof(sz)/sizeof(TCHAR));
                        ListBox_AddString(hwndLB, sz);
                        break;

                    case RASCS_Disconnected:
                        AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        ListBox_AddString(hwndLB, sz);
                        pThis->FailedRasDial(hwnd, hrRasDialFailure, 0);
                        PostMessage(hwnd, CM_INTERNALRECONNECT, 0, 0);
                        break;

                    case RASCS_Connected:
                        SetDwOption(OPT_RASCONNDETAILS, s_fDetails, NULL, 0);
                        AthLoadString(idsRASCS_Connected, sz, sizeof(sz)/sizeof(TCHAR));
                        SetWindowText(GetDlgItem(hwnd, ideProgress), sz);
                        ListBox_AddString(hwndLB, sz);
                        EndDialog(hwnd, S_OK);
                        break;
                    }

                    // Select last lb item
                    SendMessage(hwndLB, LB_SETCURSEL, ListBox_GetCount(hwndLB)-1, 0);
                }
                return 1;
            }
            break;
        }

    // Done
    return 0;
    }


BOOL CConnectionManager::LogonRetry(HWND hwnd, LPTSTR pszCancel)
    {
    // Locals
    DWORD       dwRasError;

    // Refresh
    RefreshConnInfo();

    // Reset Cancel button
    SetWindowText(GetDlgItem(hwnd, IDCANCEL), pszCancel);

    // Empty the listbox
    ListBox_ResetContent(GetDlgItem(hwnd, idlbDetails));

    while(1)
        {
        // If failed...
        if (FAILED(RasLogon(hwnd, m_szConnectName, TRUE)))
            return FALSE;

        // Dial the connection
        m_rConnInfo.hRasConn = NULL;
        dwRasError = RasDial(NULL, NULL, &m_rdp, 0xFFFFFFFF, hwnd, &m_rConnInfo.hRasConn);
        if (dwRasError)
            {
            FailedRasDial(hwnd, hrRasDialFailure, dwRasError);
            continue;
            }

        // Success
        break;
        }

    // Done
    return TRUE;
    }

// =====================================================================================
// CConnectionManager::FailedRasDial
// =====================================================================================
VOID CConnectionManager::FailedRasDial(HWND hwnd, HRESULT hrRasError, DWORD dwRasError)
    {
    // Locals
    TCHAR           sz[255];

    // Refresh
    RefreshConnInfo();

    // Hangup the connection
    if (m_rConnInfo.hRasConn)
        RasHangupAndWait(m_rConnInfo.hRasConn, DEF_HANGUP_WAIT);

    // Disconnected
    AthLoadString(idsRASCS_Disconnected, sz, sizeof(sz)/sizeof(TCHAR));
    SetWindowText(GetDlgItem(hwnd, ideProgress), sz);

    // Save dwRasError
    DisplayRasError(hwnd, hrRasError, dwRasError);

    // NULL it
    m_rConnInfo.hRasConn = NULL;

    // Change dialog button to OK
    AthLoadString(idsOK, sz, sizeof(sz)/sizeof(TCHAR));
    SetWindowText(GetDlgItem(hwnd, IDCANCEL), sz);
    }

DWORD CConnectionManager::EditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName)
    {
    if (FAILED(VerifyRasLoaded()))
        return (DWORD)E_FAIL;

    if (FIsPlatformWinNT() && m_hInstRasDlg && m_pRasEntryDlg)
    {
        RASENTRYDLG info;

        ZeroMemory(&info, sizeof(RASENTRYDLG));
        info.dwSize = sizeof(RASENTRYDLG);
        info.hwndOwner = hwnd;

        m_pRasEntryDlg(NULL, pszEntryName, &info);
        return info.dwError;
    }
    else
    {
        return RasEditPhonebookEntry(hwnd, NULL, pszEntryName);
    }
    }


//
//  FUNCTION:   CConnectionNotify::SendAdvise()
//
//  PURPOSE:    Sends the specified notification to all the clients that have
//              requested notifications.
//
//  PARAMETERS:
//      <in> nCode - Notification code to send.
//      <in> pvData - Data to send with the notificaiton.  Can be NULL.
//
void CConnectionManager::SendAdvise(CONNNOTIFY nCode, LPVOID pvData)
    {
    if (nCode == CONNNOTIFY_CONNECTED)
        DoOfflineTransactions();

    // Loop through each interface and send the notification

    EnterCriticalSection(&m_cs);

    NOTIFYHWND *pTemp = m_pNotifyList;
    while (pTemp)
        {
        Assert(IsWindow(pTemp->hwnd));
        DWORD dwThread = GetCurrentThreadId();
        PostMessage(pTemp->hwnd, CM_NOTIFY, (WPARAM) nCode, (LPARAM) pvData);
        pTemp = pTemp->pNext;
        }

    LeaveCriticalSection(&m_cs);
    }


void CConnectionManager::FreeNotifyList(void)
    {
    // Loop through the notify windows we own
    NOTIFYHWND *pTemp;

    while (m_pNotifyList)
        {
        // Get the list of notify callbacks for this window
        if (IsWindow(m_pNotifyList->hwnd))
            {
            NOTIFYLIST *pList = (NOTIFYLIST *) GetWindowLongPtr(m_pNotifyList->hwnd, GWLP_USERDATA);
            NOTIFYLIST *pListT;

            // Loop through the callbacks freeing each one

            while (pList)
                {
                pListT = pList->pNext;
                SafeMemFree(pList);
                pList = pListT;
                }

            SetWindowLong(m_pNotifyList->hwnd, GWLP_USERDATA, NULL);

            RemoveProp(m_pNotifyList->hwnd, NOTIFY_HWND);
                
            if (GetCurrentThreadId() == GetWindowThreadProcessId(m_pNotifyList->hwnd, NULL))
            {
                DestroyWindow(m_pNotifyList->hwnd);
            }
            else
                PostMessage(m_pNotifyList->hwnd, WM_CLOSE, 0, 0L);
            }

        pTemp = m_pNotifyList;
        m_pNotifyList = m_pNotifyList->pNext;
        SafeMemFree(pTemp);
        }
    }


LRESULT CALLBACK CConnectionManager::NotifyWndProc(HWND hwnd, UINT uMsg, 
                                                   WPARAM wParam, LPARAM lParam)
{
    //CConnectionManager *pThis = (CConnectionManager *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    CConnectionManager  *pThis = (CConnectionManager *)GetProp(hwnd, NOTIFY_HWND);

    // If we're idle, then we should not process any notifications
    if (uMsg != WM_NCCREATE && !pThis)
        return (DefWindowProc(hwnd, uMsg, wParam, lParam));

    switch (uMsg)
        {
        case WM_NCCREATE:            
            pThis = (CConnectionManager *) ((LPCREATESTRUCT) lParam)->lpCreateParams;

            //SetWindowLong(hwnd, GWLP_USERDATA, (LONG) pThis);
            SetProp(hwnd, NOTIFY_HWND, (HANDLE)pThis);
            return (TRUE);
        
        case CM_NOTIFY:
            // This doesn't need to be critsec'd since the message is sent from
            // within a critsec.
            NOTIFYLIST *pList = (NOTIFYLIST *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            while (pList)
                {
                pList->pNotify->OnConnectionNotify((CONNNOTIFY) wParam, (LPVOID) lParam, pThis);
                pList = pList->pNext;
                }

            return (0);
        }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


HRESULT CConnectionManager::GetDefaultConnection(IImnAccount *pAccount,
                                                 IImnAccount **ppDefault)
    {
    TCHAR szDefault[CCHMAX_ACCOUNT_NAME];
    ACCTTYPE acctType;
    HRESULT hr = S_OK;

    // Get the type of account from the original account
    if (FAILED(hr = pAccount->GetAccountType(&acctType)))
        {
        // How can an account have no account type?
        Assert(FALSE);
        return (hr);
        }

    // Ask the account manager for the default account of this type
    if (FAILED(hr = g_pAcctMan->GetDefaultAccount(acctType, ppDefault)))
        {
        // No default account of this type?
        Assert(FALSE);
        return (hr);
        }

    return (S_OK);
    }

BOOL CConnectionManager::IsConnectionUsed(LPTSTR pszConn)
    {
    IImnEnumAccounts   *pEnum = NULL;
    IImnAccount        *pAcct = NULL;
    DWORD               dwConn = 0;
    TCHAR               szConn[CCHMAX_CONNECTOID];
    BOOL                fFound = FALSE;

    // Get the enumerator from the account manager
    if (SUCCEEDED(m_pAcctMan->Enumerate(SRV_ALL, &pEnum)))
        {
        pEnum->Reset();

        // Walk through all the accounts
        while (!fFound && SUCCEEDED(pEnum->GetNext(&pAcct)))
            {
            // Get the connection type for this account
            if (SUCCEEDED(pAcct->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConn)))
                {
                // If the account is a RAS account, ask for the connectoid name
                // and the account name.
                if (dwConn == CONNECTION_TYPE_RAS)
                    {
                    pAcct->GetPropSz(AP_RAS_CONNECTOID, szConn, ARRAYSIZE(szConn));

                    // Check to see if this connection matches
                    if (0 == lstrcmpi(szConn, pszConn))
                        {
                        fFound = TRUE;
                        }
                    }
                }
            SafeRelease(pAcct);
            }
        SafeRelease(pEnum);
        }

    return (fFound);
    }


HRESULT CConnectionManager::ConnectActual(LPTSTR pszRasConn, HWND hwndParent, BOOL fShowUI)
{
    HRESULT hr;

    lstrcpyn(m_szConnectName, pszRasConn, ARRAYSIZE(m_szConnectName));

    // RefreshConnInfo
    CHECKHR(hr = RefreshConnInfo());
    
    // Make sure the RAS DLL is loaded before we try this
    if (FAILED(VerifyRasLoaded()))    
    {
        hr = HR_E_UNINITIALIZED;
        goto exit;
    }
    
    // Check to see if we even can connect
    hr = CanConnectActual(pszRasConn);
        
    // If we can connect using the current connection, return success
    if (S_OK == hr)
    {
        m_rConnInfo.fConnected = TRUE;
        hr = S_OK;
        goto exit;
    }

    // There is another connection already established ask the user if they 
    // want to change.
    if (!m_fDialerUI)
    {
        m_fDialerUI = TRUE;

        if (E_FAIL == hr)
        {        
            UINT        uAnswer;

            uAnswer = idrgUseCurrent;

            // Check to see if this a voodoo Connection Manager autodialer thing
            if (!ConnectionManagerVoodoo(pszRasConn))
            {
                if (fShowUI)
                    uAnswer = PromptCloseConnection(hwndParent);
        
                // The user canceled from the dialog.  Therefore we give up.
                if (IDCANCEL == uAnswer || IDNO == uAnswer)
                {
                    hr = hrUserCancel;
                    goto exit;
                }
        
                // The user said they wanted to hang up and dial a new connection.
                else if (idrgDialNew == uAnswer || IDYES == uAnswer)
                {
                    Disconnect(hwndParent, fShowUI, TRUE, FALSE);
                }
        
                // The user said to try to use the current connection.
                else if (idrgUseCurrent == uAnswer)    
                {
                    // Who are we to tell the user what to do...

                    //Save the conn info so we can return true for this connection in CanConnectActual
                    AddToConnList(pszRasConn);

                    // Send a connect notification since we are getting connected and then return
                    hr = S_OK;
                    goto NotifyAndExit;
                }
            }
        }
        else
        {
            //I don't see any reason as to why this is there.
            // If we started RAS, then we can close it on a whim.
            Disconnect(hwndParent, fShowUI, FALSE, FALSE);
        }

        // Only one caller can be dialing the phone at a time.
        if (WAIT_TIMEOUT == WaitForSingleObject(m_hMutexDial, 0))
        {
            hr  = HR_E_DIALING_INPROGRESS;
            goto exit;
        }

        if (S_FALSE == (hr = DoAutoDial(hwndParent, pszRasConn, TRUE)))
        {
            DWORD   dwReturn;
            DWORD   dwLanFlags = 0;
            DWORD   dwDialFlags = 0;

            dwDialFlags = INTERNET_AUTODIAL_FORCE_ONLINE;

            if (VerifyMobilityPackLoaded() == S_OK)
            {
                if (!IsNetworkAlive(&dwLanFlags) || (!(dwLanFlags & NETWORK_ALIVE_LAN)))
                    dwDialFlags |= INTERNET_DIAL_SHOW_OFFLINE;
            }

            dwReturn = InternetDialA(hwndParent, pszRasConn, dwDialFlags,
                                        &m_dwConnId, 0);
            /*
            // Dial the new connection
            if (SUCCEEDED(hr = StartRasDial(hwndParent, pszRasConn)))
            */
            if (dwReturn == 0)
            {
                m_rConnInfo.fConnected = TRUE;
                m_rConnInfo.fIStartedRas = TRUE;
                m_rConnInfo.fAutoDial = FALSE;
                m_rConnInfo.hRasConn = (HRASCONN)m_dwConnId;
                lstrcpyn(m_rConnInfo.szCurrentConnectionName, pszRasConn, ARRAYSIZE(m_rConnInfo.szCurrentConnectionName));
                hr = S_OK;
            }
            else
            {
                if (dwReturn == ERROR_USER_DISCONNECTION)
                {
                    hr = HR_E_USER_CANCEL_CONNECT;
                    if (!!(dwDialFlags & INTERNET_DIAL_SHOW_OFFLINE))
                        SetGlobalOffline(TRUE);
                }
                else
                {
                    DebugTrace("Error dialing: %d\n", GetLastError());
                    hr = E_FAIL;
                }
            }
        }

        ReleaseMutex(m_hMutexDial);

NotifyAndExit:
        // Send the advise after we leave the critsec to make sure we don't deadlock
        if (hr == S_OK)
        {
            SendAdvise(CONNNOTIFY_CONNECTED, NULL);
        }
exit:
        m_fDialerUI = FALSE;
    }

    return (hr);
}

HRESULT CConnectionManager::CanConnectActual(LPTSTR pszRasConn)
{
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    BOOL        fFound = 0;
    HRESULT     hr = E_FAIL;
    TCHAR       pszCurConn[CCHMAX_CONNECTOID];
    DWORD       dwFlags;    
    
    //Look in our Conection list first
    hr = SearchConnList(pszRasConn);
    if (hr == S_OK)
        return hr;
    
    // Make sure the RAS DLL is loaded before we try this
    if (FAILED(VerifyRasLoaded()))    
    {
        hr = HR_E_UNINITIALIZED;
        goto exit;
    }


    // Find out what we're currently connected to
    if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
    {
        // If no connections exist, then just exit
        if (0 == cConnections)
        {
            SafeMemFree(pConnections);
            hr = S_FALSE;
            goto exit;
        }
        
        // Walk through the existing connections and see if we can find the
        // one we're looking for.
        for (ULONG i = 0; i < cConnections; i++)
        {
            if (0 == lstrcmpi(pszRasConn, pConnections[i].szEntryName))
            {
                // Found it.  Return success.
                fFound = TRUE;
                break;
            }
        }
        
        // Free the list of connections returned from the enumerator
        SafeMemFree(pConnections);
        
        hr = (fFound ? S_OK : E_FAIL);
        goto exit;
    }
        
exit:

        if ((hr != S_OK) && (m_fDialerUI))
            hr = HR_E_DIALING_INPROGRESS;

    return (hr);    
}


INT_PTR CALLBACK CConnectionManager::RasStartupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    // Locals
    CConnectionManager *pThis = (CConnectionManager *) GetWndThisPtr(hwnd);
    TCHAR  szConn[CCHMAX_CONNECTOID];
    DWORD  dwOpt = OPT_DIALUP_LAST_START;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
                {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                return 1;
                }

            // Save this pointer
            SetWndThisPtr (hwnd, pThis);

            // Fill in the combo box
            pThis->FillRasCombo(GetDlgItem(hwnd, idcDialupCombo), TRUE);

            // If there are no RAS connections, then don't show the dialog
            if (ComboBox_GetCount(GetDlgItem(hwnd, idcDialupCombo)) <= 1)
                {
                EndDialog(hwnd, 0);
                return (TRUE);
                }

            // If the reason that we're in this dialog is because the user usually autodial's 
            // on startup but is now offline, then we should display the normal autodial 
            // connectoid
            if (START_CONNECT == DwGetOption(OPT_DIALUP_START))
                dwOpt = OPT_DIALUP_CONNECTION;

            // Initialize the combo box to the last connection
            *szConn = 0;
            GetOption(dwOpt, szConn, ARRAYSIZE(szConn));
            if (0 != *szConn)
                {
                // If we can't find it any longer, then according to the spec, we're
                // supposed to default to the "Ask me" option
                if (CB_ERR == ComboBox_SelectString(GetDlgItem(hwnd, idcDialupCombo), -1, szConn))
                    {
                    ComboBox_SetCurSel(GetDlgItem(hwnd, idcDialupCombo), 0);
                    }
                }
            else
                ComboBox_SetCurSel(GetDlgItem(hwnd, idcDialupCombo), 0);
            
            CenterDialog(hwnd);
            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    // Get the connection name from the combo box
                    ComboBox_GetText(GetDlgItem(hwnd, idcDialupCombo), szConn, ARRAYSIZE(szConn));
                    
                    // Check to see if it's the "Don't dial..." string
                    TCHAR szRes[CCHMAX_STRINGRES];
                    AthLoadString(idsConnNoDial, szRes, ARRAYSIZE(szRes));

                    if (0 == lstrcmp(szRes, szConn))
                        {
                        // It's the don't dial string, so clear the history in the registry
                        SetOption(OPT_DIALUP_LAST_START, _T(""), sizeof(TCHAR), NULL, 0);

                        // See if the user checked the "Set as default..."
                        if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, idcDefaultCheck)))
                            {
                            // If don't dial is set as default, we clear the startup prompt option
                            SetDwOption(OPT_DIALUP_START, START_NO_CONNECT, NULL, 0);
                            }
                        }
                    else
                        {
                        // Save this connection in the history
                        SetOption(OPT_DIALUP_LAST_START, szConn, lstrlen(szConn) + 1, NULL, 0);
                        if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, idcDefaultCheck)))
                            {
                            // If the user want's this as default, then we change the startup
                            // option to auto connect to this connection.
                            SetDwOption(OPT_DIALUP_START, START_CONNECT, NULL, 0);
                            SetOption(OPT_DIALUP_CONNECTION, szConn, lstrlen(szConn) + 1, NULL, 0);
                            }

                        // Dial the phone
                        pThis->ConnectActual(szConn, hwnd, FALSE);
                        }

                    EndDialog(hwnd, 0);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    return (TRUE);
                }
            break;
            
        case WM_CLOSE:
            SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            return (TRUE);
        }

    return (FALSE);
    }


//-------------------------------------------------------------------------------------------
// Function:  FIsPlatformWinNT() - checks if we are running on NT or Win95
//-------------------------------------------------------------------------------------------
BOOL FIsPlatformWinNT()
{
    return (g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
}


HRESULT CConnectionManager::RefreshConnInfo(BOOL fSendAdvise)
{
    // Locals
    HRESULT     hr=S_OK;
    LPRASCONN   pConnections=NULL;
    ULONG       cConnections=0;
    BOOL        fFound=FALSE;
    ULONG       i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Refresh needed
    if (CIS_REFRESH != m_rConnInfo.state)
        goto exit;

    // Set this here to prevent an infinite loop and thus a stack fault.
    m_rConnInfo.state = CIS_CLEAN;

    // Make sure the RAS DLL is loaded before we try this
    CHECKHR(hr = VerifyRasLoaded());

    // Find out what we're currently connected to
    CHECKHR(hr = EnumerateConnections(&pConnections, &cConnections));

    // Walk through the existing connections and see if we can find the
    // one we're looking for.
    for (i = 0; i < cConnections; i++)
    {
//        if (m_rConnInfo.hRasConn == pConnections[i].hrasconn)
        //To get around a problem in ConnectActual when we dial using InternetDial
          if (lstrcmp(m_rConnInfo.szCurrentConnectionName, pConnections[i].szEntryName) == 0)
            {
            // Found it.  Return success.
            fFound = TRUE;
            m_rConnInfo.fConnected = TRUE;
            m_rConnInfo.fIStartedRas = TRUE;
            m_rConnInfo.hRasConn = pConnections[0].hrasconn;
            m_dwConnId = (DWORD_PTR) m_rConnInfo.hRasConn;

            break;
            }
    }

    // If we didn't find our connection
    if (!fFound)
    {
        // The user hung up.  We need to put ourselves in a disconnected
        // state.
        if (cConnections == 0)
        {
            Disconnect(NULL, FALSE, TRUE, FALSE);
        }
        else
        {
            lstrcpyn(m_rConnInfo.szCurrentConnectionName, pConnections[0].szEntryName, ARRAYSIZE(m_rConnInfo.szCurrentConnectionName));
            m_rConnInfo.fConnected = TRUE;
            m_rConnInfo.fIStartedRas = FALSE;
            m_rConnInfo.hRasConn = pConnections[0].hrasconn;
            m_dwConnId = (DWORD_PTR) m_rConnInfo.hRasConn;

            if (fSendAdvise)
                SendAdvise(CONNNOTIFY_CONNECTED, NULL);
        }            
    }
   
exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Free the list of connections returned from the enumerator
    SafeMemFree(pConnections);

    // Done
    return hr;
}



//
//  FUNCTION:   CConnectionManager::IsGlobalOffline()
//
//  PURPOSE:    Checks the state of the WININET global offline setting.  
//              Note - this is copied from shdocvw
//
//  PARAMETERS: 
//      void
//
//  RETURN VALUE:
//      BOOL 
//
BOOL CConnectionManager::IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
                             &dwSize))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }
    
    return (fRet);
}


//
//  FUNCTION:   CConnectionManager::SetGlobalOffline()
//
//  PURPOSE:    Sets the global offline state for Athena and IE.  Note - this
//              function is copied from shdocvw.
//
//  PARAMETERS: 
//      <in> fOffline - TRUE to disconnect, FALSE to allow connections.
//
//  RETURN VALUE:
//      void 
//
void CConnectionManager::SetGlobalOffline(BOOL fOffline, HWND hwndParent)
{
    DWORD dwReturn;

    if (fOffline)
    {
        if (hwndParent)
        {
            //Offer to hangup
            RefreshConnInfo(FALSE);
            if (m_rConnInfo.hRasConn)
            {
                dwReturn = AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), 
                                         MAKEINTRESOURCEW(idsWorkOfflineHangup), 0, 
                                         MB_YESNOCANCEL);

                if (dwReturn == IDCANCEL)
                    return;

                if (dwReturn == IDYES)
                {
                    Disconnect(hwndParent, FALSE, TRUE, FALSE);
                }
            }
        }
    }
    
    SetShellOfflineState(fOffline);

    m_fOffline = fOffline;

    if (!m_fOffline)
        DoOfflineTransactions();

    SendAdvise(CONNNOTIFY_WORKOFFLINE, (LPVOID) IntToPtr(fOffline));
}


typedef BOOL (WINAPI *PFNINETDIALHANDLER)(HWND,LPCSTR, DWORD, LPDWORD);

HRESULT CConnectionManager::DoAutoDial(HWND hwndParent, LPTSTR pszConnectoid, BOOL fDial)
    {
    TCHAR   szAutodialDllName[MAX_PATH];
    TCHAR   szAutodialFcnName[MAX_PATH];
    HRESULT hr = S_FALSE;
    UINT    uError;
    HINSTANCE hInstDialer = 0;
    PFNINETDIALHANDLER pfnDialHandler = NULL;
    DWORD   dwRasError = 0;
    BOOL    f = 0;
    TCHAR   szRegPath[MAX_PATH];
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
    DWORD   dwDialFlags = fDial ? INTERNET_CUSTOMDIAL_CONNECT : INTERNET_CUSTOMDIAL_DISCONNECT;


    // Check to see if this connectoid has the autodial values
    if (FAILED(LookupAutoDialHandler(pszConnectoid, szAutodialDllName, szAutodialFcnName)))
        goto exit;

    // If we were able to load those two values, then we're going to let the 
    // autodialer take care of dialing the phone.
    uError = SetErrorMode(SEM_NOOPENFILEERRORBOX);

    // Try to load the library that contains the autodialer
    hInstDialer = LoadLibrary(szAutodialDllName);
    SetErrorMode(uError);

    if (!hInstDialer)
        {
        goto exit;
        }

    // Try to load the function address
    pfnDialHandler = (PFNINETDIALHANDLER) GetProcAddress(hInstDialer, 
                                                         szAutodialFcnName);
    if (!pfnDialHandler)
        goto exit;

    // Call the dialer
    f = (*pfnDialHandler)(hwndParent, pszConnectoid, dwDialFlags, 
                          &dwRasError);

    hr = f ? S_OK : E_FAIL;
    m_rConnInfo.fConnected = fDial && f;
    m_rConnInfo.fIStartedRas = TRUE;
    m_rConnInfo.fAutoDial = TRUE;

    if (f && fDial)
        {
        // Need to get the current connection handle
        if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)))
            {
            for (UINT i = 0; i < cConnections; i++)
                {
                if (0 == lstrcmpi(pConnections[i].szEntryName, pszConnectoid))
                    {
                    EnterCriticalSection(&m_cs);
                    m_rConnInfo.hRasConn = pConnections[i].hrasconn;
                    m_rConnInfo.state = CIS_REFRESH;    // new connection, must refresh conn info
                    LeaveCriticalSection(&m_cs);
                    break;
                    }
                }

            SafeMemFree(pConnections);
            }
        }

exit:
    if (hInstDialer)
        FreeLibrary(hInstDialer);

    return (hr);
    }


HRESULT CConnectionManager::LookupAutoDialHandler(LPTSTR pszConnectoid, LPTSTR pszAutodialDllName,
                                                  LPTSTR pszAutodialFcnName)
    {
    HRESULT     hr = E_FAIL;
    DWORD       dwEntryInfoSize = 0;
    LPRASENTRY  pRasEntry = NULL;

    *pszAutodialDllName = 0;
    *pszAutodialFcnName = 0;

    if (m_pRasGetEntryProperties)
    {
        // Find out how big the struct we need to pass in should be
        RasGetEntryProperties(NULL, pszConnectoid, NULL, &dwEntryInfoSize, NULL, NULL);
        if (dwEntryInfoSize)
        {
            // Allocate a buffer big enough for this structure
            if (!MemAlloc((LPVOID*) &pRasEntry, dwEntryInfoSize))
                return (E_OUTOFMEMORY);

            // Request the RASENTRY properties
            pRasEntry->dwSize = sizeof(RASENTRY);
            if (0 != RasGetEntryProperties(NULL, pszConnectoid, pRasEntry, &dwEntryInfoSize, NULL, NULL))
                goto exit;

            // Copy the autodial info to the provided buffers
            if (pRasEntry->szAutodialDll[0])
                lstrcpyn(pszAutodialDllName, pRasEntry->szAutodialDll, MAX_PATH);

            if (pRasEntry->szAutodialFunc[0])
                lstrcpyn(pszAutodialFcnName, pRasEntry->szAutodialFunc, MAX_PATH);

            // If we got here, we have all the data we need
            if (*pszAutodialDllName && *pszAutodialFcnName)
                hr = S_OK;
        }
    }
exit:
    SafeMemFree(pRasEntry);
    return (hr);
    }


// If the current connection is a CM connection, and the target connection is
// a CM connection, then we let the CM do whatever it is that they do.
BOOL CConnectionManager::ConnectionManagerVoodoo(LPTSTR pszConnection)
    {
    TCHAR   szAutodialDllName[MAX_PATH];
    TCHAR   szAutodialFcnName[MAX_PATH];

    // Check to see if the target is a CM connectoid
    if (FAILED(LookupAutoDialHandler(pszConnection, szAutodialDllName, szAutodialFcnName)))
        return (FALSE);

    // Find out if the current connection is a CM connectoid
    if (FAILED(LookupAutoDialHandler(m_rConnInfo.szCurrentConnectionName, szAutodialDllName, 
                                     szAutodialFcnName)))
        return (FALSE);

    return (TRUE);
    }

HRESULT CConnectionManager::OEIsDestinationReachable(IImnAccount *pAccount, DWORD dwConnType)
{
    char        szServerName[256];
    HRESULT     hr = S_FALSE;

    /*
    if ((VerifyMobilityPackLoaded() == S_OK) &&
        (GetServerName(pAccount, szServerName, ARRAYSIZE(szServerName)) == S_OK))
    {
        if (IsDestinationReachable(szServerName, NULL) &&
            (GetLastError() == 0))
        {
            hr = S_OK;
        }
    }
    else
    {
    */
	DWORD dw;
	if (SUCCEEDED(pAccount->GetPropDw(AP_HTTPMAIL_DOMAIN_MSN, &dw)) && dw)
	{
		if(HideHotmail())
			return(hr);
	}
	

        hr = IsInternetReachable(pAccount, dwConnType);
    /*
    }
    */
    return hr;
}

HRESULT CConnectionManager::IsInternetReachable(IImnAccount *pAccount, DWORD dwConnType)
{

    TCHAR    szConnectionName[CCHMAX_CONNECTOID];
    HRESULT  hr = S_FALSE;
    DWORD    dwFlags;

    switch (dwConnType)
    {
        case CONNECTION_TYPE_RAS:
        {
            if (FAILED(hr = pAccount->GetPropSz(AP_RAS_CONNECTOID, szConnectionName, ARRAYSIZE(szConnectionName))))
            {
                AssertSz(FALSE, _T("CConnectionManager::Connect() - No connection name."));
                break;
            }

            hr = CanConnectActual(szConnectionName);
            break;
        }

        case CONNECTION_TYPE_LAN:
        {
             if (VerifyMobilityPackLoaded() == S_OK)
             {
                if (IsNetworkAlive(&dwFlags) && (!!(dwFlags & NETWORK_ALIVE_LAN)))
                {
                     hr = S_OK;
                }
             }
             else
             {
                  //If Mobility pack is not loaded we can't figure out if lan indeed present, so like
                 //everywhere else we just assume that lan is present
                 hr = S_OK;
             }
             break;
        }

        case CONNECTION_TYPE_INETSETTINGS:
        default:
        {
            if (InternetGetConnectedStateExA(&dwFlags, szConnectionName, ARRAYSIZE(szConnectionName), 0))
                hr = S_OK;

            break;
        }
    }

    return hr;
}

HRESULT CConnectionManager::GetServerName(IImnAccount *pAcct, LPSTR  pServerName, DWORD size)
{
    HRESULT     hr = E_FAIL;
    DWORD       dwSrvrType;
    ACCTTYPE    accttype;

    //This function will be called only for LAN accounts to avoid confusion with POP accounts having two servers
    // an incoming and an outgoing.
    if (SUCCEEDED(pAcct->GetAccountType(&accttype)))
    {
        switch (accttype)
        {
            case ACCT_MAIL:
                dwSrvrType = AP_IMAP_SERVER;
                break;

            case ACCT_NEWS:
                dwSrvrType = AP_NNTP_SERVER;
                break;

            case ACCT_DIR_SERV:
                dwSrvrType = AP_LDAP_SERVER;
                break;

            default:
                Assert(FALSE);
                goto exit;
        }

        if ((hr = pAcct->GetPropSz(dwSrvrType, pServerName, size)) != S_OK)
        {
            //If the account type is MAIL, we try to get the name of POP server
            //For POP accounts we just try to ping the POP3 server as in most of the cases
            //POP server and SMTP servers are the same. Even if they are not, we assume that if 
            //one is reachable the connection is dialed and ISPs network is reachable and hence the other 
            //server is reachable too.
            if (accttype == ACCT_MAIL)
            {
                hr = pAcct->GetPropSz(AP_POP3_SERVER, pServerName, size);
                
                // look for an httpmail server
                if (FAILED(hr))
                    hr = pAcct->GetPropSz(AP_HTTPMAIL_SERVER, pServerName, size);
            }
        }
    }

exit:
    return hr;
}

BOOLEAN CConnectionManager::IsSameDestination(LPSTR  pszConnectionName, LPSTR pszServerName)
{
    //We need to find an account with pszConnectionName as the connectoid and pszServerName
    //Return TRUE if we find one FALSE otherwise
    IImnAccount     *pAcct;
    BOOLEAN         fret = FALSE;

    if (g_pAcctMan && (g_pAcctMan->FindAccount(AP_RAS_CONNECTOID, pszConnectionName, &pAcct) == S_OK))
    {
        //Now check if its server name is what we want.
        //Althoug findAccount finds first account that satisfies the searchdata, this should work fine for a 
        //typical OE user. Even if there are two accounts with same connectoids and different servers and if 
        //we miss to find the one we want,at the most we will be putting up a connect dialog.

        char    myServerName[MAX_PATH];
        if (SUCCEEDED(GetServerName(pAcct, myServerName, sizeof(myServerName))))
        {
            if (lstrcmp(myServerName, pszServerName) == 0)
            {
                fret = TRUE;
            }
        }
    }

    return fret;
}


HRESULT  CConnectionManager::VerifyMobilityPackLoaded()
{
    HRESULT     hr  = REGDB_E_CLASSNOTREG; 
    uCLSSPEC    classpec; 

    if (!m_fMobilityPackFailed)
    {
        HWND    hwnd;
        if (!m_hInstSensDll)
        {
            // figure out struct and flags 
            classpec.tyspec = TYSPEC_CLSID; 
            classpec.tagged_union.clsid = CLSID_MobilityFeature; 
    
            // call jit code 
            if (!g_pBrowser)
            {
                goto exit;
            }
            IOleWindow  *pOleWnd;
            if (FAILED(g_pBrowser->QueryInterface(IID_IAthenaBrowser, (LPVOID*)&pOleWnd)))
            {
                goto exit;
            }
            pOleWnd->GetWindow(&hwnd);

            hr = FaultInIEFeature(hwnd, &classpec, NULL, FIEF_FLAG_PEEK); 
            pOleWnd->Release();

            if(S_OK == hr) 
            { 
                // Mobile pack is installed 
                m_hInstSensDll = LoadLibrary(szSensApiDll);
                if (m_hInstSensDll)
                {
                    m_pIsDestinationReachable = (ISDESTINATIONREACHABLE)GetProcAddress(m_hInstSensDll, szIsDestinationReachable);
                    m_pIsNetworkAlive         = (ISNETWORKALIVE)GetProcAddress(m_hInstSensDll, szIsNetworkAlive);
                }

                if (!m_hInstSensDll || !m_pIsDestinationReachable || !m_pIsNetworkAlive)
                {
                    m_fMobilityPackFailed = TRUE;
                }
                else
                {
                    m_fMobilityPackFailed = FALSE;
                    hr = S_OK;
                }
            } 
        }
        else
            hr = S_OK;
    }
    return hr;
exit:
    m_fMobilityPackFailed = TRUE;
    return hr;
}


void CConnectionManager::DoOfflineTransactions()
{
    char szId[CCHMAX_ACCOUNT_NAME];
    IImnEnumAccounts *pEnum;
    HRESULT hr;
    FOLDERID id, *pid;
    ULONG iAcct, cAcct;
    IImnAccount *pAccount;
    DWORD dwConnection;
    HWND hwnd;
    DWORD cRecords;

    pid = NULL;
    iAcct = 0;

    // If this is getting hit through a news article URL, we won't have a browser and
    // should not play back.
    if (!g_pBrowser || !g_pSync)
        return;

    // Get Record Count
    g_pSync->GetRecordCount(&cRecords);

    // sbailey: perf. fix. - prevent doing that expensive stuff below if there are no transactions.
    if (0 == cRecords)
        return;

    hr = g_pAcctMan->Enumerate(SRV_NNTP | SRV_IMAP | SRV_HTTPMAIL, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->GetCount(&cAcct);
        if (SUCCEEDED(hr) &&
            cAcct > 0 &&
            MemAlloc((void **)&pid, cAcct * sizeof(FOLDERID)))
        {
            while (SUCCEEDED(pEnum->GetNext(&pAccount)))
            {
                hr = pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, &dwConnection);
                if (SUCCEEDED(hr))
                {
                    hr = OEIsDestinationReachable(pAccount, dwConnection);
                    if (hr == S_OK)
                    {
                        hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szId, ARRAYSIZE(szId));
                        if (SUCCEEDED(hr))
                        {
                            hr = g_pStore->FindServerId(szId, &id);
                            if (SUCCEEDED(hr))
                            {
                                pid[iAcct] = id;
                                iAcct++;
                            }
                        }
                    }
                }

                pAccount->Release();
            }
        }

        pEnum->Release();
    }

    if (iAcct > 0)
    {
        g_pBrowser->GetWindow(&hwnd);
        g_pBrowser->GetCurrentFolder(&id);
        g_pSync->DoPlayback(hwnd, pid, iAcct, id);
    }

    if (pid != NULL)
        MemFree(pid);
}

HRESULT     CConnectionManager::ConnectUsingIESettings(HWND     hwndParent, BOOL fShowUI)
{
    TCHAR           lpConnection[CCHMAX_CONNECTOID];
    DWORD           dwFlags = 0;
    DWORD           dwReturn;
    HRESULT         hr = E_FAIL;

    if (InternetGetConnectedStateExA(&dwFlags, lpConnection, ARRAYSIZE(lpConnection), 0))
    {
        m_fTryAgain = FALSE;
        return S_OK;
    }

    // Only one caller can be dialing the phone at a time.
    if (WAIT_TIMEOUT == WaitForSingleObject(m_hMutexDial, 0))
    {
        return (HR_E_DIALING_INPROGRESS);
    }

    if (!!(dwFlags & INTERNET_CONNECTION_MODEM) && (*lpConnection))
    {
        if (!m_fDialerUI)
        {
            m_fDialerUI = TRUE;
            //A DEF CONNECTOID IS SET. Dial that one
            if (IsGlobalOffline())
            {
                if (fShowUI)
                {
                    if (IDNO == AthMessageBoxW(hwndParent, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrWorkingOffline),
                                              0, MB_YESNO | MB_ICONEXCLAMATION ))
                    {
                        hr = HR_E_OFFLINE;
                        goto DialExit;
                    }
                    else
                        g_pConMan->SetGlobalOffline(FALSE);
                }
                else
                {
                    hr = HR_E_OFFLINE;
                    //m_fDialerUI = FALSE;
                    goto DialExit;
                }
            }

            if ((hr = PromptCloseConnection(lpConnection, fShowUI, hwndParent)) != S_FALSE)
                goto DialExit;

            {
                DWORD           dwDialFlags = 0;
                DWORD           dwLanFlags = 0;

                dwDialFlags = INTERNET_AUTODIAL_FORCE_ONLINE;

                if (VerifyMobilityPackLoaded() == S_OK)
                {
                    if (!IsNetworkAlive(&dwLanFlags) || (!(dwLanFlags & NETWORK_ALIVE_LAN)))
                        dwDialFlags |= INTERNET_DIAL_SHOW_OFFLINE;
                }

                dwReturn = InternetDialA(hwndParent, lpConnection, dwDialFlags,
                                    &m_dwConnId, 0);
                if (dwReturn == 0)
                {
                    m_rConnInfo.fConnected = TRUE;
                    m_rConnInfo.fIStartedRas = TRUE;
                    m_rConnInfo.fAutoDial = FALSE;
                    m_rConnInfo.hRasConn = (HRASCONN)m_dwConnId;
                    lstrcpyn(m_rConnInfo.szCurrentConnectionName, lpConnection, ARRAYSIZE(m_rConnInfo.szCurrentConnectionName));
                    SendAdvise(CONNNOTIFY_CONNECTED, NULL);
                    hr = S_OK;
                }
                else
                {
                    if (dwReturn == ERROR_USER_DISCONNECTION)
                    {
                        hr = HR_E_USER_CANCEL_CONNECT;
                        if (!!(dwDialFlags & INTERNET_DIAL_SHOW_OFFLINE))
                        {
                            SetGlobalOffline(TRUE);
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                        DebugTrace("Error dialing: %d\n", GetLastError());
                    }
                }
            }
DialExit:
            m_fDialerUI = FALSE;
        }
        else
        {
            hr = HR_E_USER_CANCEL_CONNECT;
        }
    }
    else
    {
        if (!m_fTryAgain)
        {
            int err = (int) DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddOfferOffline), hwndParent, 
                                      (DLGPROC)OfferOfflineDlgProc, (LPARAM)this); 
            
            if (err == -1)
            {
                DWORD   dwerr = GetLastError();
                hr = S_OK;
            }
            if (!IsGlobalOffline())
                hr = S_OK;
            else
                hr = HR_E_OFFLINE;
        }
        else
            hr = S_OK;
    }
    
    ReleaseMutex(m_hMutexDial);

    return hr;
}


void CConnectionManager::SetTryAgain(BOOL   bval)
{
    m_fTryAgain = bval;
}

BOOL   CALLBACK  CConnectionManager::OfferOfflineDlgProc(HWND   hwnd, UINT  uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL                    retval = 1;
    CConnectionManager      *pThis = (CConnectionManager*)GetWndThisPtr(hwnd);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // Get lparam
            pThis = (CConnectionManager *)lParam;
            if (!pThis)
            {
                Assert (FALSE);
                EndDialog(hwnd, E_FAIL);
                goto exit;
            }
        
            // Save this pointer
            SetWndThisPtr (hwnd, pThis);
            break;
        }

        case WM_COMMAND:
        {
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDWorkOffline:
                pThis->SetGlobalOffline(TRUE, NULL);
            break;

            case IDTryAgain:
                pThis->SetGlobalOffline(FALSE);
                pThis->SetTryAgain(TRUE);
            break;
            }
            EndDialog(hwnd, S_OK);
            break;
        }

        case WM_CLOSE:
            pThis->SetGlobalOffline(TRUE, NULL);
            EndDialog(hwnd, S_OK);
            break;

        case WM_DESTROY:
            SetWndThisPtr(hwnd, NULL);
            break;

        default:
            retval = 0;
            break;
    }

exit:
    return retval;
}

HRESULT CConnectionManager::PromptCloseConnection(LPTSTR    pszRasConn, BOOL fShowUI, HWND hwndParent)
{
    HRESULT     hr = S_FALSE;
    UINT        uAnswer;
    LPRASCONN   pConnections = NULL;
    ULONG       cConnections = 0;
        
    uAnswer = idrgDialNew;

    // Make sure the RAS DLL is loaded before we try this
    if (FAILED(VerifyRasLoaded()))    
        {
        hr = HR_E_UNINITIALIZED;
        goto exit;
        }

    lstrcpyn(m_szConnectName, pszRasConn, ARRAYSIZE(m_szConnectName));

    // RefreshConnInfo
    CHECKHR(hr = RefreshConnInfo());

    if (SUCCEEDED(EnumerateConnections(&pConnections, &cConnections)) && (cConnections > 0))
    {
    
        if (fShowUI)
            uAnswer = PromptCloseConnection(hwndParent);

        // The user canceled from the dialog.  Therefore we give up.
        if (IDCANCEL == uAnswer || IDNO == uAnswer)
        {
            hr = HR_E_USER_CANCEL_CONNECT;
            goto exit;
        }

        // The user said they wanted to hang up and dial a new connection.
        else if (idrgDialNew == uAnswer || IDYES == uAnswer)
        {
            Disconnect(hwndParent, fShowUI, TRUE, FALSE);
            hr = S_FALSE;
            goto exit;
        }

        // The user said to try to use the current connection.
        else if (idrgUseCurrent == uAnswer)    
        {
            //Save the conn info so we can return true for this connection in CanConnectActual
            AddToConnList(pszRasConn);

            hr = S_OK;
            SendAdvise(CONNNOTIFY_CONNECTED, NULL);
            goto exit;
        }
    }
    else
    {
        Disconnect(NULL, FALSE, TRUE, FALSE);
        hr = S_FALSE;
    }
exit:
    SafeMemFree(pConnections);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\envfact.h ===
#ifndef _ENVFACT_H
#define _ENVFACT_H

HRESULT Envelope_WMCommand(HWND hwndCmd, INT id, WORD wCmd);
HRESULT Envelope_AddHostMenu(HMENU hMenuPopup, int iPos);
HRESULT Envelope_FreeGlobals();

#endif //_ENVFACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\ddfldbar.h ===
#ifndef __DDFLDBAR_H__
#define __DDFLDBAR_H__

/*
This file defines the interface for communication between InfoColumn and its bands when the InfoColumn is 
shown as a drop down window from the Folder Bar. Add any functions that the InfoColumn needs to call when its in 
the drop down mode, here.
*/

/*
interface IDropDownFldrBar
{
    STDMETHOD(RegisterFlyOut) (THIS_ CFolderBar *pFolderBar) PURE;
    STDMETHOD(RevokeFlyOut) (THIS) PURE;
};
*/

class IDropDownFldrBar : public IUnknown
{
public:
    virtual HRESULT   RegisterFlyOut(CFolderBar *pFolderBar) = 0;
    virtual HRESULT   RevokeFlyOut() = 0;
};


#endif //__DDFLDBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\envfact.cpp ===
/*
 *    e n v f a c t . c p p
 *    
 *    Purpose:
 *        Office-Envelope Host factory
 *    
 *    Owner:
 *        brettm.
 *
 *  History:
 *      July '95: Created
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */
#include <pch.hxx>
#include <mimeole.h>
#include <envelope.h>
#include <mso.h>
#include <envguid.h>
#include "envfact.h"
#include "regutil.h"
#include "demand.h"
#include "menures.h"

class CEnvFactory
{
public:

    CEnvFactory();
    virtual ~CEnvFactory();

    ULONG AddRef();
    ULONG Release();

    HRESULT Init();
    HRESULT OnWMCommand(HWND hwndCmd, INT id, WORD wCmd);
    HRESULT AddEnvHostMenu(HMENU hMenuPopup, int iPos);

private:
    ULONG   m_cRef;
    HMENU   m_hMenu;

    HRESULT BuildPopupMenu();
    HRESULT CreateEnvHost(HWND hwnd, LPSTR pszCLSID);
    HRESULT DestroyMenu(HMENU hMenu);
};


static CEnvFactory *g_pEnvFactory=0;

HRESULT EnsureEnvFactory();

CEnvFactory::CEnvFactory()
{
    m_cRef = 1;
    m_hMenu = NULL;
}

CEnvFactory::~CEnvFactory()
{
    if (m_hMenu)
        {
        Assert(IsMenu(m_hMenu));
        DestroyMenu(m_hMenu);
        }
}


ULONG CEnvFactory::AddRef()
{
    return ++m_cRef;
}

ULONG CEnvFactory::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


HRESULT CEnvFactory::Init()
{
    return S_OK;
}


HRESULT CEnvFactory::BuildPopupMenu()
{
    HKEY            hKey,
                    hKeyHost;
    int             i;
    ULONG           cb;
    TCHAR           rgch[MAX_PATH];
    TCHAR           rgchCLSID[MAX_PATH];
    LONG            lResult;
    HMENU           hMenu;
    MENUITEMINFO    mii;
    HRESULT         hr=E_FAIL;
    int             idm = ID_ENVELOPE_HOST_FIRST;
    DWORD           dwType;

    hMenu = CreatePopupMenu();
    if (!hMenu)
        return E_OUTOFMEMORY;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA|MIIM_TYPE|MIIM_ID;
    mii.fType = MFT_STRING;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szEnvHostClientPath, 0, KEY_READ, &hKey))
        {
        cb = sizeof(rgch);

        // Enumerate through the keys
        for (i = 0; ; i++)
            {
            // Enumerate Friendly Names
            cb = sizeof(rgch);
            lResult = RegEnumKeyEx(hKey, i, rgch, &cb, 0, NULL, NULL, NULL);

            // No more items
            if (lResult == ERROR_NO_MORE_ITEMS)
                break;

            // Error, lets move onto the next account
            if (lResult != ERROR_SUCCESS)
                break;

            // Lets open they server key
            if (RegOpenKeyEx(hKey, rgch, 0, KEY_READ, &hKeyHost) != ERROR_SUCCESS)
                continue;

            cb = sizeof(rgch);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyHost, NULL, 0, &dwType, (LPBYTE)rgch, &cb) && cb)
                {
                cb = sizeof(rgchCLSID);
                if (GetCLSIDFromSubKey(hKeyHost, rgchCLSID, &cb)==S_OK)
                    {
                    mii.dwTypeData = rgch;
                    mii.cch = lstrlen(rgch);
                    mii.dwItemData = (DWORD_PTR)PszDupA(rgchCLSID);
                    mii.wID = idm++;
                    if (InsertMenuItem(hMenu, 0, TRUE, &mii))
                        hr = S_OK;
                    }
                }
            RegCloseKey(hKeyHost);
            }
        RegCloseKey(hKey);
        }

    if (!FAILED(hr))
        m_hMenu = hMenu;
    else
        DestroyMenu(hMenu);

    return hr;
}

HRESULT CEnvFactory::OnWMCommand(HWND hwndCmd, INT id, WORD wCmd)
{
    MENUITEMINFO    mii;

    if (id >= ID_ENVELOPE_HOST_FIRST && id <= ID_ENVELOPE_HOST_LAST)
        {
        Assert (m_hMenu && IsMenu(m_hMenu));
        mii.fMask = MIIM_DATA;
        mii.cbSize = sizeof(MENUITEMINFO);
        SideAssert(GetMenuItemInfo(m_hMenu, id, FALSE, &mii));
        CreateEnvHost(hwndCmd, (LPSTR)mii.dwItemData);
        return S_OK;
        }

    return S_FALSE;
}

HRESULT CEnvFactory::DestroyMenu(HMENU hMenu)
{
    ULONG           uItem,
                    cItems;
    MENUITEMINFO    mii;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_DATA;
    cItems = GetMenuItemCount(hMenu);
    
    for (uItem = 0; uItem < cItems; uItem++)
        {
        if (GetMenuItemInfo(hMenu, uItem, TRUE, &mii) && mii.dwItemData)
            MemFree((LPVOID)mii.dwItemData);
        }

    ::DestroyMenu(hMenu);
    return S_OK;
}


HRESULT CEnvFactory::CreateEnvHost(HWND hwnd, LPSTR pszCLSID)
{
    IMsoEnvelopeHost   *pHost = NULL;
    HRESULT             hr = S_OK;
    TCHAR               rgch[CCHMAX_STRINGRES];
    TCHAR               rgchErr[CCHMAX_STRINGRES+50];
    CLSID               clsid;
    UINT                idsErr = idsErrEnvHostCreateNote;
    LPWSTR              pwszCLSID;
    

    IF_NULLEXIT(pwszCLSID = PszToUnicode(CP_ACP, pszCLSID));

    IF_FAILEXIT(hr = CLSIDFromString(pwszCLSID, &clsid));

    IF_FAILEXIT(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER|CLSCTX_LOCAL_SERVER, 
                                      IID_IMsoEnvelopeHost, (LPVOID *)&pHost));

    idsErr = idsErrEnvHostCoCreate;

    IF_FAILEXIT(hr = pHost->CreateNote(NULL, CLSID_OEEnvelope, NULL, NULL, NULL, 0));
    
exit:
    if (FAILED(hr))
    {
        LoadString(g_hLocRes, idsErr, rgch, ARRAYSIZE(rgch));
        wsprintf(rgchErr, "%s\nhr=0x%x", rgch, hr);
        AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), rgchErr, NULL, MB_OK);
    }

    ReleaseObj(pHost);
    MemFree(pwszCLSID);
    return hr;
}




HRESULT CEnvFactory::AddEnvHostMenu(HMENU hMenuPopup, int iPos)
{
    MENUITEMINFO    mii;
    TCHAR           rgch[CCHMAX_STRINGRES];

    if (!m_hMenu)
        BuildPopupMenu();

    if (m_hMenu)
        {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE|MIIM_SUBMENU|MIIM_ID;
        mii.fType = MFT_STRING;
        mii.wID = ID_POPUP_ENVELOPE_HOST;
        LoadString(g_hLocRes, idsCreateEnvHostPoupMenu, rgch, ARRAYSIZE(rgch));
        mii.dwTypeData = rgch;
        mii.cch = lstrlen(rgch);
        mii.hSubMenu = m_hMenu;
        InsertMenuItem(hMenuPopup, iPos, TRUE, &mii);
        }
    return S_OK;
}




HRESULT Envelope_WMCommand(HWND hwndCmd, INT id, WORD wCmd)
{
    if (EnsureEnvFactory() != S_OK)
        return E_FAIL;

    return g_pEnvFactory->OnWMCommand(hwndCmd, id, wCmd);
}

HRESULT Envelope_AddHostMenu(HMENU hMenuPopup, int iPos)
{
    if (EnsureEnvFactory() != S_OK)
        return E_FAIL;

    return g_pEnvFactory->AddEnvHostMenu(hMenuPopup, iPos);
}


HRESULT EnsureEnvFactory()
{
    HRESULT hr = S_OK;

    if (!g_pEnvFactory)
        {
        g_pEnvFactory = new CEnvFactory();
        if (!g_pEnvFactory)
            return E_OUTOFMEMORY;

        hr = g_pEnvFactory->Init();
        }
    return hr;
}

HRESULT Envelope_FreeGlobals()
{
    SafeRelease(g_pEnvFactory);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\dragdrop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     dragdrop.h
//
//  PURPOSE:    Contains the definitions for all of Outlook Express's 
//              Drag Drop code.
//

#pragma once

class CStoreDlgCB;

/////////////////////////////////////////////////////////////////////////////
// Data Formats, Types, and Clipboard Formats
//

typedef struct tagOEMESSAGES {
    FOLDERID        idSource;
    MESSAGEIDLIST   rMsgIDList;
} OEMESSAGES;

/////////////////////////////////////////////////////////////////////////////
// Drop Target Class
//

class CDropTarget : public IDropTarget
{
    /////////////////////////////////////////////////////////////////////////
    // Constructors and Destructor
    //
public:
    CDropTarget();
    ~CDropTarget();

    /////////////////////////////////////////////////////////////////////////
    // Initialization
    //
    HRESULT Initialize(HWND hwndOwner, FOLDERID idFolder);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // IDropTarget
    //
    STDMETHODIMP DragEnter(IDataObject *pDataObject, DWORD grfKeyState,
                           POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pDataObject, DWORD grfKeyState,
                      POINTL pt, DWORD *pdwEffect);

private:
    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    BOOL    _CheckRoundtrip(IDataObject *pDataObject);
    BOOL    _ValidateDropType(CLIPFORMAT cf, IDataObject *pDataObject);
    DWORD   _DragEffectFromFormat(IDataObject *pDataObject, DWORD dwEffectOk, CLIPFORMAT cf, DWORD grfKeyState);
    HRESULT _HandleDrop(IDataObject *pDataObject, DWORD dwEffect, CLIPFORMAT cf, DWORD grfKeyState);
    HRESULT _HandleFolderDrop(IDataObject *pDataObject);
    HRESULT _HandleMessageDrop(IDataObject *pDataObject, BOOL fMove);
    HRESULT _HandleHDrop(IDataObject *pDataObject, CLIPFORMAT cf, DWORD grfKeyState);
    HRESULT _InsertMessagesInStore(HDROP hDrop);
    HRESULT _CreateMessageFromDrop(HWND hwnd, IDataObject *pDataObject, DWORD grfKeyState);

    BOOL    _IsValidOEFolder(IDataObject *pDataObject);
    BOOL    _IsValidOEMessages(IDataObject *pDataObject);

    /////////////////////////////////////////////////////////////////////////
    // Progress Dialog
    static INT_PTR CALLBACK _ProgDlgProcExt(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK _ProgDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL _OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void _OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void _SaveNextMessage(void);

private:
    /////////////////////////////////////////////////////////////////////////
    // Object Data
    //
    ULONG           m_cRef;

    HWND            m_hwndOwner;
    FOLDERID        m_idFolder;

    IDataObject    *m_pDataObject;
    CLIPFORMAT      m_cf;

    BOOL            m_fOutbox;

    // Progress Dialog Stuff
    HWND            m_hwndDlg;
    HDROP           m_hDrop;
    DWORD           m_cFiles;
    DWORD           m_iFileCur;
    IMessageFolder *m_pFolder;
    CStoreDlgCB    *m_pStoreCB;
};


/////////////////////////////////////////////////////////////////////////////
// Data Object Classes
//

class CBaseDataObject : public IDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CBaseDataObject();
    virtual ~CBaseDataObject();
    
    /////////////////////////////////////////////////////////////////////////
    // IUnknown Interface
    //
    STDMETHODIMP         QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    /////////////////////////////////////////////////////////////////////////
    // IDataObject Interface members
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium) = 0;
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE) = 0;
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium,   
                         BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC** ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD advf, 
                         IAdviseSink* ppAdviseSink, LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA** ppEnumAdvise);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
protected:
    virtual HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt) = 0;
    
    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    ULONG           m_cRef;             // Object reference count    

protected:
    FORMATETC       m_rgFormatEtc[10];  // Array of FORMATETC's we support
    ULONG           m_cFormatEtc;       // Number of elements in m_rgFormatEtc
};



class CFolderDataObject : public CBaseDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CFolderDataObject(FOLDERID idFolder) : m_idFolder(idFolder), m_fBuildFE(0) {};
    ~CFolderDataObject() {};

    /////////////////////////////////////////////////////////////////////////
    // IDataObject - Overridden from CBaseDataObject2
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
protected:
    HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt);
    HRESULT _RenderOEFolder(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    HRESULT _RenderTextOrShellURL(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    
    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    FOLDERID    m_idFolder;
    BOOL        m_fBuildFE;
};


class CMessageDataObject : public CBaseDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CMessageDataObject();
    ~CMessageDataObject();

    HRESULT Initialize(LPMESSAGEIDLIST pMsgs, FOLDERID idSource);

    /////////////////////////////////////////////////////////////////////////
    // IDataObject - Overridden from CBaseDataObject2
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
protected:
    HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt);
    HRESULT _LoadMessage(DWORD iMsg, IMimeMessage **ppMsg, LPWSTR pwszFileExt);
    HRESULT _RenderOEMessages(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    HRESULT _RenderFileContents(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    HRESULT _RenderFileGroupDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);

    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    LPMESSAGEIDLIST     m_pMsgIDList;
    FOLDERID            m_idSource;
    BOOL                m_fBuildFE;
    BOOL                m_fDownloaded;
};

class CShortcutDataObject : public CBaseDataObject
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Constructor and Destructor
    //
    CShortcutDataObject(UINT iPos) : m_iPos(iPos), m_fBuildFE(0) {};
    ~CShortcutDataObject() {};

    /////////////////////////////////////////////////////////////////////////
    // IDataObject - Overridden from CBaseDataObject2
    //
    STDMETHODIMP GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
private:
    HRESULT _BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt);
    HRESULT _RenderOEShortcut(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
    
    /////////////////////////////////////////////////////////////////////////
    // Object Attributes
    //
private:
    UINT        m_iPos;
    BOOL        m_fBuildFE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\find.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.h
//
//  PURPOSE:    
//

#pragma once

#include "mru.h"

#define CCHMAX_FIND 128

class CMessageView;

/////////////////////////////////////////////////////////////////////////////
// Call this to create a finder
//
HRESULT DoFind(HWND hwnd, FOLDERID idFolder);

/////////////////////////////////////////////////////////////////////////////
// Thread entry point for the finder
//

typedef struct tagFINDPARAMS 
{
    FOLDERID idFolder;
} FINDPARAMS, *PFINDPARAMS;

unsigned int __stdcall FindThreadProc2(LPVOID lpvUnused);

/////////////////////////////////////////////////////////////////////////////
// Types used by the class
//

enum 
{
    PAGE_GENERAL = 0,
    PAGE_DATESIZE,
    PAGE_ADVANCED,
    PAGE_MAX
};

typedef struct tagPAGEINFO 
{
    LPTSTR  pszTemplate;
    DLGPROC pfn;            // Pointer to the callback for this page
    int     idsTitle;       // Title for this page
} PAGEINFO, *PPAGEINFO;


/////////////////////////////////////////////////////////////////////////////
// Class CFinder
//

class CFinder : public IOleCommandTarget                
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CFinder();
    ~CFinder();

    HRESULT Show(FINDPARAMS *pFindParams);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
    
    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText); 
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // Dialog & message handling stuff
    //
    static BOOL CALLBACK GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK DateSizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK AdvancedDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    static INT_PTR CALLBACK FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnNotify(HWND hwnd, int id, NMHDR *pnmhdr);
    void OnPaint(HWND hwnd);
    void OnClose(HWND hwnd);
    void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    UINT OnNCHitTest(HWND hwnd, int x, int y);

//    void OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu);

    HRESULT CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdClose(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    /////////////////////////////////////////////////////////////////////////
    // Individual pages
    //
    BOOL CALLBACK _GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL General_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void General_OnSize(HWND hwnd, UINT state, int cx, int cy);
    void General_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    HRESULT _InitMainResizingInfo(HWND hwnd);
    HRESULT _SelectPage(DWORD dwPage);

    /////////////////////////////////////////////////////////////////////////
    // Private class information
    //
private:
    // General Info
    ULONG           m_cRef;                 // Object reference count
    HWND            m_hwnd;                 // Handle of the main finder window
    HWND            m_rgPages[PAGE_MAX];    // Array of handles to the various pages in the dialog
    DWORD           m_dwPageCurrent;        // Currently visible page

    HACCEL          m_hAccel;               // Handle of the accelerator table used for the finder
    HICON           m_hIconTitle;           // Icon for the title bar of the dialog

    CMessageView   *m_pMsgView;

    // State
    BOOL            m_fInProgress;          // TRUE if there is currently a find happening
    BOOL            m_fShowResults;         // TRUE if the dialog is expanded to show results

    // These will be handy to keep around
    HWND            m_hwndTabs;             // Handle of the tab control
    HWND            m_hwndFindNow;          // Handle of the Find Now button
    HWND            m_hwndNewSearch;        // Handle of the New Search button
    HWND            m_hwndFindAni;          // Handle of the Find animation

    // Resizing Info
    RECT            m_rcTabs;               // Position and size of the tab control
    RECT            m_rcFindNow;            // Position and size of the Find Now button
    RECT            m_rcNewSearch;          // Position and size of the New Search button
    RECT            m_rcFindAni;            // Position and size of the Find Animation
    POINT           m_ptDragMin;            // Minimum size of the dialog
    POINT           m_ptWndDefault;         // Default size of the dialog
    DWORD           m_cyDlgFull;            // Full height of the dialog
};


/////////////////////////////////////////////////////////////////////////////
// Find / Find Next utility
//

interface IFindNext : public IUnknown 
{
    STDMETHOD(Show)(THIS_ HWND hwndParent, HWND *pHwnd) PURE;
    STDMETHOD(Close)(THIS) PURE;
    STDMETHOD(TranslateAccelerator)(THIS_ LPMSG pMsg) PURE;
    STDMETHOD(GetFindString)(THIS_ LPTSTR psz, DWORD cchMax, BOOL *pfBodies) PURE;
};


class CFindNext : public IFindNext
{
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
public:
    CFindNext();
    ~CFindNext();

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IFindNext
    //
    STDMETHODIMP Show(HWND hwndParent, HWND *phWnd);
    STDMETHODIMP Close(void);
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);
    STDMETHODIMP GetFindString(LPTSTR psz, DWORD cchMax, BOOL *pfBodies); 

    /////////////////////////////////////////////////////////////////////////
    // Dialog Callback goo
    //
    static INT_PTR CALLBACK FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR CALLBACK DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    void OnFindNow(void);

    /////////////////////////////////////////////////////////////////////////
    // Private class information
    //
private:
    ULONG           m_cRef;                 // Object reference count
    HWND            m_hwnd;                 // Handle of the find dialog
    HWND            m_hwndParent;           // Handle of the window that should get notifications
    CMRUList        m_cMRUList;             // MRU List
    BOOL            m_fBodies;              // Body Search
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\find.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include "find.h"
#include "findres.h"
#include "menures.h"
#include "instance.h"
#include "msgview.h"
#include "menuutil.h"
#include "finder.h"
#include "shlwapip.h"

// These will be handy
inline _width(RECT rc) { return (rc.right - rc.left); }
inline _height(RECT rc) { return (rc.bottom - rc.top); }
inline UINT _GetTextLength(HWND hwnd, DWORD id) { return (UINT) SendDlgItemMessage(hwnd, id, WM_GETTEXTLENGTH, 0, 0); }

/////////////////////////////////////////////////////////////////////////////
// CFindNext
//

CFindNext::CFindNext()
{
    m_cRef = 1;
    m_hwnd = NULL;
    m_hwndParent = NULL;
}


CFindNext::~CFindNext()
{
    Assert(!IsWindow(m_hwnd));
    SetDwOption(OPT_SEARCH_BODIES, m_fBodies, 0, 0);
}


//
//  FUNCTION:   CFindNext::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CFindNext::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CFindNext::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CFindNext::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CFindNext::AddRef(void)
{
    TraceCall("CFindNext::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CFindNext::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CFindNext::Release(void)
{
    TraceCall("CFindNext::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


//
//  FUNCTION:   CFindNext::Show()
//
//  PURPOSE:    Causes the dialog to be created and displayed
//
//  PARAMETERS: 
//      [in]  hwndParent - Handle of the parent for the dialog 
//      [out] phWnd - Returns the handle of the new dialog window
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindNext::Show(HWND hwndParent, HWND *phWnd)
{
    int iReturn;

    TraceCall("CFindNext::Show");

    if (!IsWindow(hwndParent))
        return (E_INVALIDARG);

    // Create the dialog box
    iReturn = (int) DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(IDD_FIND_NEXT), hwndParent,
                             FindDlgProc, (LPARAM) this);
    return (iReturn ? S_OK : E_FAIL);
}


//
//  FUNCTION:   CFindNext::Close()
//
//  PURPOSE:    Causes the find dialog to be closed.
//
HRESULT CFindNext::Close(void)
{
    TraceCall("CFindNext::Close");

    if (IsWindow(m_hwnd))
    {
        EndDialog(m_hwnd, 0);
        m_hwnd = NULL;
    }

    return (S_OK);
}


//
//  FUNCTION:   CFindNext::TranslateAccelerator()
//
//  PURPOSE:    Called by the parent to allow us to translate our own 
//              messages.
//
//  PARAMETERS: 
//      LPMSG pMsg
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindNext::TranslateAccelerator(LPMSG pMsg)
{
    if ((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_F3))
        OnFindNow();
    else if (IsDialogMessageWrapW(m_hwnd, pMsg))
        return (S_OK);

    return (S_FALSE);
}


//
//  FUNCTION:   CFindNext::GetFindString()
//
//  PURPOSE:    Get's the current search string from the dialog
//
//  PARAMETERS: 
//      [in, out] psz - Buffer to copy the string into
//      [in] cchMax - Size of psz.
//
HRESULT CFindNext::GetFindString(LPTSTR psz, DWORD cchMax, BOOL *pfBodies)
{
    TraceCall("CFindNext::GetFindString");

    if (!psz || !cchMax || !pfBodies)
        return (E_INVALIDARG);

    // Get the current contents of the combo box
    m_cMRUList.EnumList(0, psz, cchMax);
    if (pfBodies)
        *pfBodies = m_fBodies;

    return (S_OK);
}


//
//  FUNCTION:   CFindNext::FindDlgProc()
//
//  PURPOSE:    Static callback for the dialog proc.  Does the work of finding
//              the correct this pointer and sending the messages to that 
//              callback.
//
INT_PTR CALLBACK CFindNext::FindDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CFindNext *pThis;

    if (uMsg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CFindNext *) lParam;
    }
    else
        pThis = (CFindNext *) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return (pThis->DlgProc(hwnd, uMsg, wParam, lParam));

    return (FALSE);
}

static const HELPMAP g_rgCtxMapFindNext[] = {
    {IDC_FIND_HISTORY, 50300},
    {IDC_ALL_TEXT, 50310},
    {IDC_FIND_NOW, 50305},
    {IDC_ADVANCED, 50315},
    {0, 0}
};

INT_PTR CALLBACK CFindNext::DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, OnInitDialog);

        case WM_COMMAND:
            return (BOOL) HANDLE_WM_COMMAND(hwnd, wParam, lParam, OnCommand);     

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapFindNext);
    }

    return (FALSE);
}


//
//  FUNCTION:   CFindNext::OnInitDialog()
//
//  PURPOSE:    Initializes the UI for the dialog.
//
//  PARAMETERS: 
//      [in] hwnd - Handle of the dialog being created
//      [in] hwndFocus - Handle of the control that should have focus
//      [in] lParam - Initialization data.
//
//  RETURN VALUE:
//      Returns TRUE to let windows set the focus
//
BOOL CFindNext::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR sz[256];
    UINT  nItem = 0;

    TraceCall("CFindNext::OnInitDialog");
    
    m_hwnd = hwnd;
    SendDlgItemMessage(hwnd, IDC_FIND_HISTORY, CB_LIMITTEXT, CCHMAX_FIND, 0);
    SetIntlFont(GetDlgItem(hwnd, IDC_FIND_HISTORY));

    m_fBodies = DwGetOption(OPT_SEARCH_BODIES);
    if (m_fBodies)
        SendDlgItemMessage(hwnd, IDC_ALL_TEXT, BM_SETCHECK, 1, 0);

    // Got's to load the find history
    m_cMRUList.CreateList(10, 0, c_szRegFindHistory);    

    while (-1 != m_cMRUList.EnumList(nItem++, sz, ARRAYSIZE(sz)))
    {
        SendDlgItemMessage(hwnd, IDC_FIND_HISTORY, CB_ADDSTRING, 0, (LPARAM) sz);
    }

    // Disable the Find button
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), FALSE);
    CenterDialog(m_hwnd);

    return (TRUE);
}


//
//  FUNCTION:   CFindNext::OnCommand()
//
//  PURPOSE:    Handles command messages that are sent from the various 
//              controls in the dialog.
//
void CFindNext::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    TraceCall("CFindNext::OnCommand");

    switch (id)
    {
        case IDC_FIND_HISTORY:
        {
            switch (codeNotify)
            {
                case CBN_EDITCHANGE:
                    EnableWindow(GetDlgItem(m_hwnd, IDC_FIND_NOW),
                                 _GetTextLength(m_hwnd, IDC_FIND_HISTORY));
                    break;

                case CBN_SELCHANGE:
                    EnableWindow(GetDlgItem(m_hwnd, IDC_FIND_NOW), TRUE);
                    break;
            }

            break;
        }

        case IDC_ALL_TEXT:
        {
            m_fBodies = (BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_ALL_TEXT));
            break;
        }

        case IDC_FIND_NOW:
        {
            if (codeNotify == BN_CLICKED)
            {
                OnFindNow();
            }

            break;
        }

        case IDC_ADVANCED:
        {
            if (codeNotify == BN_CLICKED)
            {
                DoFindMsg(FOLDERID_ROOT, 0);
            }

            break;
        }

        case IDCANCEL:
        case IDCLOSE:
            EndDialog(hwnd, 0);
            break;
    }
}


void CFindNext::OnFindNow(void)
{
    TCHAR sz[CCHMAX_STRINGRES];
    int   i;

    // Get the current string
    GetWindowText(GetDlgItem(m_hwnd, IDC_FIND_HISTORY), sz, ARRAYSIZE(sz));

    // Add this string to our history 
    i = m_cMRUList.AddString(sz);

    // Reload the combo box
    UINT  nItem = 0;
    HWND hwndCombo = GetDlgItem(m_hwnd, IDC_FIND_HISTORY);
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    while (-1 != m_cMRUList.EnumList(nItem++, sz, ARRAYSIZE(sz)))
    {
        SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM) sz);
    }
    SendMessage(hwndCombo, CB_SETCURSEL, 0, 0);

    EndDialog(m_hwnd, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\dragdrop.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     DragDrop.cpp
//
//  PURPOSE:    Implements some common IDropTarget derived interfaces
//

#include "pch.hxx"
#include "dragdrop.h"
#include "dllmain.h"
#include "shlobj.h"
#include <storutil.h>
#include <storecb.h>
#include "instance.h"
#include "demand.h"
#include "mimeutil.h"
#include "storecb.h"
#include "bodyutil.h"
#include "imsgsite.h"
#include "note.h"
#include "shlwapip.h"
#include "secutil.h"

BOOL FIsFileInsertable(HDROP hDrop, LPSTREAM *ppStream, BOOL* fHTML);
HRESULT HrAttachHDrop(HWND hwnd, IMimeMessage *pMessage, HDROP hDrop, BOOL fMakeLinks);
HRESULT HrAddAttachment(IMimeMessage *pMessage, LPWSTR pszName, LPSTREAM pStream, BOOL fLink);


//
//  FUNCTION:   CDropTarget::CDropTarget
//
//  PURPOSE:    Simple constructor, initializes everything to NULL or zero.
//
CDropTarget::CDropTarget()
{
    m_cRef = 1;

    m_hwndOwner = NULL;
    m_idFolder = FOLDERID_INVALID;
    m_fOutbox = FALSE;

    m_pDataObject = NULL;
    m_cf = 0;

    m_hwndDlg = 0;
    m_hDrop = 0;
    m_cFiles = 0;
    m_iFileCur = 0;
    m_pFolder = 0;
    m_pStoreCB = 0;
}


//
//  FUNCTION:   CDropTarget::~CDropTarget
//
//  PURPOSE:    Cleans up any leftover data.
//
CDropTarget::~CDropTarget()
{
    SafeRelease(m_pDataObject);
}


//
//  FUNCTION:   CDropTarget::Initialize()
//
//  PURPOSE:    Initializes the drop target with the ID of the folder that will
//              be the target and a window handle that can parent any UI we
//              need to display.
//
//  PARAMETERS: 
//      [in] hwndOwner - Handle of a window we can parent UI to.
//      [in] idFolder  - ID of the folder that will be the target.
//
//  RETURN VALUE:
//      E_INVALIDARG - Bogus parameter passed in
//      S_OK         - Happiness abounds 
//
HRESULT CDropTarget::Initialize(HWND hwndOwner, FOLDERID idFolder)
{
    TraceCall("CDropTarget::Initialize");

    if (!IsWindow(hwndOwner) || idFolder == FOLDERID_INVALID)
        return (E_INVALIDARG);

    m_hwndOwner = hwndOwner;
    m_idFolder = idFolder;

    FOLDERINFO fi;

    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &fi)))
    {
        m_fOutbox = (fi.tySpecial == FOLDER_OUTBOX);
        g_pStore->FreeRecord(&fi);
    }

    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::QueryInterface()
//
//  PURPOSE:    Returns a the requested interface if supported.
//
HRESULT CDropTarget::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown*)(IDropTarget*) this;
    else if (IsEqualIID(riid, IID_IDropTarget))
        *ppvObj = (LPVOID) (IDropTarget*) this;
    else
        *ppvObj = NULL;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CBaseDropTarget::AddRef()
//
//  PURPOSE:    Increments the object reference count.
//
ULONG CDropTarget::AddRef(void)
{
    return (++m_cRef);
}


//
//  FUNCTION:   CDropTarget::Release()
//
//  PURPOSE:    Decrements the object's ref count. If the ref count hit's zero
//              the object is freed.
//
ULONG CDropTarget::Release(void)
{
    m_cRef--;

    if (m_cRef == 0)
    {
        delete this;
        return (0);
    }

    return (m_cRef);
}

//
//  FUNCTION:   CDropTarget::DragEnter()
//
//  PURPOSE:    This get's called when the user starts dragging an object
//              over our target area.
//
//  PARAMETERS:
//      [in]  pDataObject - Pointer to the data object being dragged
//      [in]  grfKeyState - Pointer to the current key states
//      [in]  pt          - Point in screen coordinates of the mouse
//      [out] pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT CDropTarget::DragEnter(IDataObject* pDataObject, DWORD grfKeyState, 
                               POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;
    DWORD           dwEffectOut = DROPEFFECT_NONE;
    
    Assert(m_pDataObject == NULL);
    
    // Get the FORMATETC enumerator for this object
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        // Walk through the data types available to see if there is one we
        // understand
        pEnum->Reset();
        
        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            Assert(celtFetched == 1);
            if (_ValidateDropType(fe.cfFormat, pDataObject))
            {
                // Figure out what the right drag effect is
                dwEffectOut = _DragEffectFromFormat(pDataObject, *pdwEffect, fe.cfFormat, grfKeyState);
                break;
            }
        }
        
        pEnum->Release();
    }
    
    // If we allow this to be dropped on us, then keep a copy of the data object
    if (dwEffectOut != DROPEFFECT_NONE)
    {
        m_pDataObject = pDataObject;
        m_pDataObject->AddRef();
        m_cf = fe.cfFormat;
    }

    *pdwEffect = dwEffectOut;
    
    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      [in]  grfKeyState - Pointer to the current key states
//      [in]  pt          - Point in screen coordinates of the mouse
//      [out] pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT CDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    // If we don't have a stored data object from CMDT::DragEnter(), then this
    // isn't a data object we have any interest in.
    if (NULL == m_pDataObject)
    {
        *pdwEffect = DROPEFFECT_NONE;
        return (S_OK);
    }
    
    // We don't care about _where_ the drop happens, just what type of effect
    // should be displayed.
    *pdwEffect = _DragEffectFromFormat(m_pDataObject, *pdwEffect, m_cf, grfKeyState);
    
    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
HRESULT CDropTarget::DragLeave(void)
{
    // Free everything up at this point.
    if (NULL != m_pDataObject)
    {
        m_pDataObject->Release();
        m_pDataObject = 0;
        m_cf = 0;
    }
    
    return (S_OK);
}


//
//  FUNCTION:   CDropTarget::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.
//
//  PARAMETERS:
//      [in]  pDataObject - Pointer to the data object being dragged
//      [in]  grfKeyState - Pointer to the current key states
//      [in]  pt          - Point in screen coordinates of the mouse
//      [out] pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
HRESULT CDropTarget::Drop(IDataObject* pDataObject, DWORD grfKeyState, 
                          POINTL pt, DWORD* pdwEffect)
{
    IEnumFORMATETC *pEnum;
    FORMATETC       fe;
    ULONG           celtFetched;
    HRESULT         hr;
    
    if (!pDataObject)
        return (E_INVALIDARG);
    
    *pdwEffect = _DragEffectFromFormat(pDataObject, *pdwEffect, m_cf, grfKeyState);
    hr = _HandleDrop(m_pDataObject, *pdwEffect, m_cf, grfKeyState);
    
    SafeRelease(m_pDataObject);
    return (hr);
}


//
//  FUNCTION:  CDropTarget::_CheckRoundtrip()
//
//  PURPOSE:   Checks to see if the source and the target are the same.
//
//  PARAMETERS:
//      [in] pDataObject - Object being dragged over us
//
//  RETURNS:
//      TRUE if the source and destination are the same, FALSE otherwise.
//
BOOL CDropTarget::_CheckRoundtrip(IDataObject *pDataObject)
{
    AssertSz(FALSE, "CDropTarget::_CheckRoundtrip() - NYI");
    return (FALSE);
}


//
//  FUNCTION:   CDropTarget::_ValidateDropType()
//
//  PURPOSE:    Examines the the specified clipboard format to see if we can
//              accept this data type.
//
//  PARAMETERS:
//      <in> cf - Clipboard format
//
//  RETURN VALUE:
//      TRUE if we understand, FALSE otherwise.
//
BOOL CDropTarget::_ValidateDropType(CLIPFORMAT cf, IDataObject *pDataObject)
{
    if (!pDataObject)
        return (FALSE);

    // OE Folders
    if (cf == CF_OEFOLDER)
        return (_IsValidOEFolder(pDataObject));

    // Messages
    if (cf == CF_OEMESSAGES)
        return (_IsValidOEMessages(pDataObject));

    // Files
    if (cf == CF_HDROP && !m_fOutbox)
        return (TRUE);

    // Text
    if ((cf == CF_TEXT || cf == CF_HTML || cf == CF_UNICODETEXT) && !m_fOutbox)
        return (TRUE);

    return (FALSE);
}



//
//  FUNCTION:   CDropTarget::_IsValidOEFolder()
//
//  PURPOSE:    Checks to see if the data object contains valid OE Folder 
//              information for this target.
//
//  PARAMETERS: 
//      [in] pDataObject - Data Object to check
//
//  RETURN VALUE:
//      Returns TRUE if it's OK to drop this here, FALSE otherwise.
//
BOOL CDropTarget::_IsValidOEFolder(IDataObject *pDataObject)
{
    FORMATETC  fe;
    STGMEDIUM  stm = {0};
    FOLDERID  *pidFolder;
    FOLDERINFO rInfoSrc = {0};
    FOLDERINFO rInfoDest = {0};
    BOOL       fReturn = FALSE;

    TraceCall("CDropTarget::_IsValidOEFolder");

    // Get the folder information from the object
    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    if (FAILED(pDataObject->GetData(&fe, &stm)))
        return (FALSE);
    pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);

    // Moving a folder onto itself would be bad
    if (*pidFolder == m_idFolder)
        goto exit;

    // Figure out the store type of the folder
    if (FAILED(g_pStore->GetFolderInfo(*pidFolder, &rInfoSrc)))
        goto exit;

    // You simply cannot move news or special folders
    if (rInfoSrc.tyFolder == FOLDER_NEWS || rInfoSrc.tySpecial != FOLDER_NOTSPECIAL)
        goto exit;

    // If it's not news, we need information about the destination
    if (FAILED(g_pStore->GetFolderInfo(m_idFolder, &rInfoDest)))
        goto exit;

    // Local to Local OK
    if (rInfoSrc.tyFolder == FOLDER_LOCAL && rInfoDest.tyFolder == FOLDER_LOCAL)
    {
        fReturn = TRUE;
        goto exit;
    }

    // According to Ray, IMAP folders can't be moved.  I don't know about HTTP.
    if (rInfoSrc.tyFolder == FOLDER_IMAP || rInfoSrc.tyFolder == FOLDER_HTTPMAIL)
        goto exit;

exit:
    if (rInfoDest.pAllocated)
        g_pStore->FreeRecord(&rInfoDest);
    if (rInfoSrc.pAllocated)
        g_pStore->FreeRecord(&rInfoSrc);

    GlobalUnlock(stm.hGlobal);
    ReleaseStgMedium(&stm);
   
    return (fReturn);
}


//
//  FUNCTION:   CDropTarget::_IsValidOEMessages()
//
//  PURPOSE:    Checks to see if the data object contains OE Messages that can
//              be dropped here.
//
//  PARAMETERS: 
//      [in] pDataObject - Data object to verify.
//
//  RETURN VALUE:
//      Returns TRUE if the object contains data that can be dropped here.
//
BOOL CDropTarget::_IsValidOEMessages(IDataObject *pDataObject)
{
    FORMATETC  fe;
    STGMEDIUM  stm;
    FOLDERID  *pidFolder;
    FOLDERINFO rInfoDest = {0};
    BOOL       fReturn = FALSE;

    TraceCall("CDropTarget::_IsValidOEMessages");

    // We don't allow dropping messages on the outbox, on server nodes,
    // or on the root.
    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rInfoDest)))
    {
        fReturn = (0 == (rInfoDest.dwFlags & FOLDER_SERVER)) &&
                  (FOLDERID_ROOT != m_idFolder) &&
                  (FOLDER_OUTBOX != rInfoDest.tySpecial) &&
                  (FOLDER_NEWS != GetFolderType(m_idFolder));

        g_pStore->FreeRecord(&rInfoDest);
    }

    return (fReturn);
}


//
//  FUNCTION:   CDropTarget::_DragEffectFromFormat()
//
//  PURPOSE:    Examines the keyboard state and the specified clipboard format
//              and determines what the right drag effect would be.
//
//  PARAMETERS:
//      <in> cf          - Clipboard format
//      <in> grfKeyState - State of the keyboard
//
//  RETURN VALUE:
//      Returns one of the drag effects defined by OLE, ie DRAGEFFECT_COPY, etc.
//
DWORD CDropTarget::_DragEffectFromFormat(IDataObject *pDataObject, DWORD dwEffectOk, 
                                         CLIPFORMAT cf, DWORD grfKeyState)
{
    FORMATETC  fe;
    STGMEDIUM  stm;
    BOOL       fRoundTrip = FALSE;
    FOLDERID  *pidFolder;

    // Folders are always a move
    if (cf == CF_OEFOLDER)
        return (DROPEFFECT_MOVE);

    // Messages move or copy
    if (cf == CF_OEMESSAGES)
    {
        SETDefFormatEtc(fe, CF_OEMESSAGES, TYMED_HGLOBAL);
        if (SUCCEEDED(pDataObject->GetData(&fe, &stm)))
        {
            pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);
        
            fRoundTrip =  (*pidFolder == m_idFolder);

            GlobalUnlock(stm.hGlobal);
            ReleaseStgMedium(&stm);
        }

        if (fRoundTrip)
            return (DROPEFFECT_NONE);
        else if ((dwEffectOk & DROPEFFECT_MOVE) && !(grfKeyState & MK_CONTROL))
            return (DROPEFFECT_MOVE);
        else
            return (DROPEFFECT_COPY);
    }

    // Files
    if (cf == CF_HDROP)
    {
        if (grfKeyState & MK_SHIFT && grfKeyState & MK_CONTROL)
            return (DROPEFFECT_LINK);
        else
            return (DROPEFFECT_COPY);
    }

    // If it's text or HTML, create a new note with the body filled with the
    // contents
    if (CF_TEXT == cf || CF_HTML == cf || CF_UNICODETEXT == cf)
        return (DROPEFFECT_COPY);

    return (DROPEFFECT_NONE);
}


//
//  FUNCTION:   CDropTarget::_HandleDrop()
//
//  PURPOSE:    Takes the dropped object and get's the data out of it that
//              we care about.
//
//  PARAMETERS:
//      <in> pDataObject - Object being dropped on us.
//      <in> cf          - Format to render
//      <in> grfKeyState - Keyboard state when the object was dropped.
//
//  RETURN VALUE:
//      S_OK if we jam on it.
//
HRESULT CDropTarget::_HandleDrop(IDataObject *pDataObject, DWORD dwEffectOk,
                                 CLIPFORMAT cf, DWORD grfKeyState)
{
    DWORD dw;

    if (cf == CF_OEFOLDER)
        return (_HandleFolderDrop(pDataObject));

    if (cf == CF_OEMESSAGES)
    {
        dw = _DragEffectFromFormat(pDataObject, dwEffectOk, cf, grfKeyState);
        Assert(dw == DROPEFFECT_MOVE || dw == DROPEFFECT_COPY);

        return (_HandleMessageDrop(pDataObject, dw == DROPEFFECT_MOVE));
    }

    if (cf == CF_HDROP)
        return (_HandleHDrop(pDataObject, cf, grfKeyState));

    if (cf == CF_TEXT || cf == CF_HTML || cf == CF_UNICODETEXT)
        return (_CreateMessageFromDrop(m_hwndOwner, pDataObject, grfKeyState));

    return (DV_E_FORMATETC);
}


HRESULT CDropTarget::_HandleFolderDrop(IDataObject *pDataObject)
{
    FORMATETC  fe;
    STGMEDIUM  stm;
    FOLDERID  *pidFolder;
    HRESULT    hr = E_UNEXPECTED;

    if (!pDataObject)
        return (E_INVALIDARG);

    // Get the data from the data object
    SETDefFormatEtc(fe, CF_OEFOLDER, TYMED_HGLOBAL);
    if (SUCCEEDED(pDataObject->GetData(&fe, &stm)))
    {
        pidFolder = (FOLDERID *) GlobalLock(stm.hGlobal);

        // Tell the store to move
        hr = MoveFolderProgress(m_hwndOwner, *pidFolder, m_idFolder);
        
        GlobalUnlock(stm.hGlobal);
        ReleaseStgMedium(&stm);
    }

    return (hr);
}

HRESULT CDropTarget::_HandleMessageDrop(IDataObject *pDataObject, BOOL fMove)
{
    FORMATETC fe;
    STGMEDIUM stm;
    OEMESSAGES *pMsgs = 0;
    HRESULT hr = E_UNEXPECTED;

    // Get the data from the data object
    SETDefFormatEtc(fe, CF_OEMESSAGES, TYMED_HGLOBAL);
    if (SUCCEEDED(hr = pDataObject->GetData(&fe, &stm)))
    {
        pMsgs = (OEMESSAGES *) GlobalLock(stm.hGlobal);

        hr = CopyMoveMessages(m_hwndOwner, pMsgs->idSource, m_idFolder, &pMsgs->rMsgIDList, fMove ? COPY_MESSAGE_MOVE : 0);
        if (FAILED(hr))
            AthErrorMessageW(m_hwndOwner, MAKEINTRESOURCEW(idsAthena), fMove ? MAKEINTRESOURCEW(idsErrMoveMsgs) : MAKEINTRESOURCEW(idsErrCopyMsgs), hr); 

        if (NULL != g_pInstance)
        {
            HRESULT     hrTemp;
            FOLDERINFO  fiFolderInfo;

            hrTemp = g_pStore->GetFolderInfo(pMsgs->idSource, &fiFolderInfo);
            if (SUCCEEDED(hrTemp))
            {
                if (FOLDER_INBOX == fiFolderInfo.tySpecial)
                    g_pInstance->UpdateTrayIcon(TRAYICONACTION_REMOVE);

                g_pStore->FreeRecord(&fiFolderInfo);
            }
        }

        GlobalUnlock(stm.hGlobal);
        ReleaseStgMedium(&stm);
    }

    return (hr);
}


//
//  FUNCTION:   CDropTarget::_HandleHDrop()
//
//  PURPOSE:    Examines the contents of the drop to see if these are just files
//              or are they .eml or .nws files.
//
//  PARAMETERS: 
//      [in] pDataObject
//      [in] cf
//      [in] grfKeyState
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CDropTarget::_HandleHDrop(IDataObject *pDataObject, CLIPFORMAT cf, DWORD grfKeyState)
{
    FORMATETC   fe;
    STGMEDIUM   stg = {0};
    HDROP       hDrop;
    HRESULT     hr;
    BOOL        fRelease = FALSE;
    UINT        cFiles;
    BOOL        fMessages = TRUE;
    UINT        i;

    TraceCall("CDropTarget::_HandleHDrop");

    // Get the data from the object
    SETDefFormatEtc(fe, CF_HDROP, TYMED_HGLOBAL);

    if (FAILED(hr = pDataObject->GetData(&fe, &stg)))
    {
        AssertSz(SUCCEEDED(hr), "CDropTarget::_HandleHDrop() - GetData() failed.");
        goto exit;
    }

    fRelease = TRUE;
    hDrop = (HDROP) GlobalLock(stg.hGlobal);

    if (FOLDER_NEWS != GetFolderType(m_idFolder) && (FOLDERID_ROOT != m_idFolder) && 
        (FOLDERID_LOCAL_STORE != m_idFolder) && !(FOLDER_IMAP == GetFolderType(m_idFolder) && FFolderIsServer(m_idFolder)))
    {
        // Look inside the data to see if any of the files are .eml or .nws
        cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
        for (i = 0; i < cFiles; i++)
        {
            WCHAR       wszFile[MAX_PATH];
            LPWSTR      pwszExt;
            // Get the name of the i'th file in the drop
            DragQueryFileWrapW(hDrop, i, wszFile, ARRAYSIZE(wszFile));

            // Get the extension for the file
            pwszExt = PathFindExtensionW(wszFile);
            if (*pwszExt)
            {
                // Once we find the first file that isn't one of our messages, we
                // can give up.
                if (0 != StrCmpIW(pwszExt, c_wszEmlExt) && 0 != StrCmpIW(pwszExt, c_wszNwsExt))
                {
                    fMessages = FALSE;
                    break;
                }
            }
        }
    }
    else
    {
        fMessages = FALSE;
    }

    // If all of the messages were news or mail messages, we can just copy them
    // into our store.  If even one were normal files, then we create a new message
    // with everything attached.
    if (fMessages)
        hr = _InsertMessagesInStore(hDrop);
    else
        hr = _CreateMessageFromDrop(m_hwndOwner, pDataObject, grfKeyState);

exit:
    if (fRelease)
        ReleaseStgMedium(&stg);

    return (hr);
}


//
//  FUNCTION:   CDropTarget::_InsertMessagesInStore()
//
//  PURPOSE:    When the user drops messages that are stored as .nws or .eml files
//              onto us, we need to integrate those files into our store.
//
//  PARAMETERS: 
//      [in] hDrop - Contains the information needed to get the files
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CDropTarget::_InsertMessagesInStore(HDROP hDrop)
{
    HRESULT hr;

    TraceCall("CDropTarget::_InsertMessagesInStore");

    // Open the folder we're saving into
    if (FAILED(hr = g_pStore->OpenFolder(m_idFolder, NULL, 0, &m_pFolder)))
        return (hr);

    if (0 == (m_pStoreCB = new CStoreDlgCB()))
    {
        m_pFolder->Release();
        return (E_OUTOFMEMORY);
    }

    // Get the count of files
    m_cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
    m_hDrop = hDrop;
    m_iFileCur = 0;

    // Do the dialog
    DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddCopyMoveMessages), m_hwndOwner,
                   _ProgDlgProcExt, (LPARAM) this);

    // Free some stuff up
    m_cFiles = 0;
    m_hDrop = 0;
    m_pFolder->Release();
    m_pStoreCB->Release();

    return (S_OK);
}

INT_PTR CALLBACK CDropTarget::_ProgDlgProcExt(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDropTarget *pThis;

    if (msg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CDropTarget*) lParam;
    }
    else
        pThis = (CDropTarget*) GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return pThis->_ProgDlgProc(hwnd, msg, wParam, lParam);

    return FALSE;
}


//
//  FUNCTION:   CDropTarget::DlgProc()
//
//  PURPOSE:    Groovy dialog proc.
//
INT_PTR CDropTarget::_ProgDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;

    switch (msg)
    {
        case WM_INITDIALOG:
            return (BOOL)HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, _OnInitDialog);
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, _OnCommand);
            return TRUE;

        case WM_STORE_COMPLETE:
            m_iFileCur++;
            _SaveNextMessage();
            return (TRUE);

        case WM_STORE_PROGRESS:
            return (TRUE);
        
    }
    return FALSE;
}



//
//  FUNCTION:   CDropTarget::_OnInitDialog()
//
//  PURPOSE:    Initializes the progress dialog
//
BOOL CDropTarget::_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Assert(m_pStoreCB);

    m_hwndDlg = hwnd;
    m_pStoreCB->Initialize(hwnd);
    m_pStoreCB->Reset();

    // Open and save the first message
    _SaveNextMessage();

    return (TRUE);
}


//
//  FUNCTION:   CDropTarget::_OnCommand()
//
//  PURPOSE:    Handle the cancel button
//
void CDropTarget::_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    // User's have been known to press cancel once in a while
    if (id == IDCANCEL)
    {
        m_pStoreCB->Cancel();
    }
}


//
//  FUNCTION:   CDropTarget::_SaveNextMessage()
//
//  PURPOSE:    Opens the next message in the drop and saves it.
//
void CDropTarget::_SaveNextMessage()
{
    WCHAR           wszFile[MAX_PATH],
                    wszRes[CCHMAX_STRINGRES], 
                    wszBuf[CCHMAX_STRINGRES + MAX_PATH];
    HRESULT         hr;
    IMimeMessage   *pMsg = 0;

    TraceCall("CDropTarget::_SaveNextMessage");

    // See if we're done
    if (m_iFileCur >= m_cFiles)
    {
        EndDialog(m_hwndDlg, 0);
        return;
    }

    // Get the name of the i'th file in the drop
    DragQueryFileWrapW(m_hDrop, m_iFileCur, wszFile, ARRAYSIZE(wszFile));

    // Create a new, empty message.
    if (FAILED(hr = HrCreateMessage(&pMsg)))
    {
        AthErrorMessageW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMemory), E_OUTOFMEMORY);
        EndDialog(m_hwndDlg, 0);
    }

    // Load the message from the file
    hr = HrLoadMsgFromFileW(pMsg, wszFile);
    if (FAILED(hr))
    {
        AthLoadStringW(IDS_ERROR_FILE_NOEXIST, wszRes, ARRAYSIZE(wszRes));
        AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), wszRes, wszFile);

        AthErrorMessageW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), wszBuf, hr);
        PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);
        goto exit;
    }

    // Progress
    AthLoadStringW(idsSavingFmt, wszRes, ARRAYSIZE(wszRes));
    AthwsprintfW(wszBuf, ARRAYSIZE(wszBuf), wszRes, wszFile);
    SetDlgItemTextWrapW(m_hwndDlg, idcStatic1, wszBuf);

    // Tell the store to save it
    hr = m_pFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, ARF_READ, 0, pMsg, m_pStoreCB);
    if (SUCCEEDED(hr))
    {
        PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);
        goto exit;
    }

    if (FAILED(hr) && E_PENDING != hr)
    {
        AthErrorMessageW(m_hwndDlg, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsUnableToSaveMessage), hr);
        PostMessage(m_hwndDlg, WM_STORE_COMPLETE, 0, 0);
    }

exit:
    SafeRelease(pMsg);
}



//
//  FUNCTION:   CDropTarget::_CreateMessageFromDrop()
//
//  PURPOSE:    This function takes an IDataObject which was dropped on Athena
//              and creates a new mail message from that dropped object.  If
//              the dropped object supports either CF_TEXT or CF_HTML, then
//              that will be streamed into the body of the message.  Otherwise,
//              if it supports CF_HDROP we'll add it as an attachment.
//
//  PARAMETERS:
//      <in> pDataObject -
//      <in> pStore      -
//      <in> grfKeyState -
//      <in> pidl        -
//
//  RETURN VALUE:
//      E_INVALIDARG -
//
//  COMMENTS:
//      <???>
//
HRESULT CDropTarget::_CreateMessageFromDrop(HWND hwnd, IDataObject *pDataObject, 
                                            DWORD grfKeyState)
{
    IEnumFORMATETC *pEnum = NULL;
    FORMATETC       fe;
    DWORD           celtFetched;
    CLIPFORMAT      cf = 0;
    DWORD           tymed = 0;
    IMimeMessage   *pMessage = NULL;
    HRESULT         hr = S_OK;
    STGMEDIUM       stg;
    IStream        *pStream = NULL;
    BOOL            fRelease = TRUE;
    BOOL            fIsRealCFHTML=FALSE;
    
    ZeroMemory(&stg, sizeof(STGMEDIUM));
    
    if (!pDataObject)
    {
        Assert(pDataObject);
        return (E_INVALIDARG);
    }
    
    // Enumerate the formats this object supports to decide which if any we
    // are going to use.
    if (SUCCEEDED(pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
    {
        pEnum->Reset();
        while (S_OK == pEnum->Next(1, &fe, &celtFetched))
        {
            // HTML is the richest format we understand.  If we find that, then
            // we can stop looking.
            if (fe.cfFormat == CF_HTML &&
                (fe.tymed & TYMED_HGLOBAL || fe.tymed & TYMED_ISTREAM))
            {
                DOUTL(32, _T("HrNewMailFromDrop() - Accepting CF_HTML."));
                cf = (CLIPFORMAT) CF_HTML;
                tymed = fe.tymed;
                break;
            }

            // UNICODETEXT is great, but only if we can't find anything richer.  So we
            // accept this, but keep looking.
            else if (fe.cfFormat == CF_UNICODETEXT &&
                (fe.tymed & TYMED_HGLOBAL || fe.tymed & TYMED_ISTREAM))
            {
                DOUTL(32,_T("HrNewMailFromDrop() - Accepting CF_UNICODETEXT."));
                cf = CF_UNICODETEXT;
                tymed = fe.tymed;
            }

            // TEXT is cool, but only if we can't find anything richer.  So we
            // accept this, but keep looking.
            else if (fe.cfFormat == CF_TEXT && cf != CF_UNICODETEXT &&
                (fe.tymed & TYMED_HGLOBAL || fe.tymed & TYMED_ISTREAM))
            {
                DOUTL(32,_T("HrNewMailFromDrop() - Accepting CF_TEXT."));
                cf = CF_TEXT;
                tymed = fe.tymed;
            }

            // If we find HDROP, then we can create an attachment.  However, we
            // want to find something richer so we only accept this if we haven't
            // found anything else we like.
            else if (fe.cfFormat == CF_HDROP && cf == 0 && fe.tymed & TYMED_HGLOBAL)
            {
                cf = CF_HDROP;
                tymed = fe.tymed;
            }
        }
        
        pEnum->Release();
    }
    
    // Make sure we found something useful
    if (0 == cf)
    {
        AssertSz(cf, _T("HrNewMailFromDrop() - Did not find an acceptable data")
            _T(" format to create a message from."));
        hr = E_UNEXPECTED;
        goto exit;
    }
    
    // Set the preferred TYMED to ISTREAM and set the FORMATETC struct up to
    // retrieve the data type we determined above.
    if (tymed & TYMED_ISTREAM)
        tymed = TYMED_ISTREAM;
    else
        tymed = TYMED_HGLOBAL;
    SETDefFormatEtc(fe, cf, tymed);
    
    // Get the data from the object
    if (FAILED(hr = pDataObject->GetData(&fe, &stg)))
    {
        AssertSz(SUCCEEDED(hr), _T("HrNewMailFromDrop() - pDataObject->GetData() failed."));
        goto exit;
    }
    
    // Create the Message Object
    hr = HrCreateMessage(&pMessage);
    if (FAILED(hr))
    {
        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsMemory),
            0, MB_ICONSTOP | MB_OK);
        goto exit;
    }
    
    // Set the body appropriately
    if (cf == CF_HTML || cf == CF_TEXT || cf == CF_UNICODETEXT)
    {
        if (fe.tymed == TYMED_HGLOBAL)
        {
            if (FAILED(hr = CreateStreamOnHGlobal(stg.hGlobal, TRUE, &pStream)))
            {
                AssertSz(FALSE, _T("HrNewMailFromDrop() - Failed CreateStreamOnHGlobal()"));
                goto exit;
            }
            
            // Bug #24846 - Need to find the actual size of the stream instead of the size
            //              of the HGLOBAL.
            LPBYTE pb = (LPBYTE) GlobalLock(stg.hGlobal);
            ULARGE_INTEGER uliSize;
            uliSize.QuadPart = 0;

            // Raid 77624: OE mishandles CF_UNICODETEXT / TYMED_GLOBAL
            if (cf == CF_TEXT || cf == CF_HTML)
                uliSize.QuadPart = lstrlen((LPSTR)pb);
            else if (cf == CF_UNICODETEXT)
                uliSize.QuadPart = (lstrlenW((LPWSTR)pb) * sizeof(WCHAR));

            GlobalUnlock(stg.hGlobal);
            pStream->SetSize(uliSize);
            
            fRelease = FALSE;
        }
        else
            pStream = stg.pstm;
        
        if (cf == CF_HTML && FAILED(hr = HrStripHTMLClipboardHeader(pStream, &fIsRealCFHTML)))
            goto exit;
        
        // Set Unicode Text Body
        if (cf == CF_UNICODETEXT)
        {
            HCHARSET hCharset;

            if (SUCCEEDED(MimeOleFindCharset("UTF-8", &hCharset)))
            {
                pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
            }

            pMessage->SetTextBody(TXT_PLAIN, IET_UNICODE, NULL, pStream, NULL);
        }

        // Set HTML Text Body
        else if (cf == CF_HTML)
        {
            // Real CF_HTML, or OE's version of CF_HTML?
            if (fIsRealCFHTML)
            {
                // Locals
                HCHARSET hCharset;

                // Map to HCHARSET - Real CF_HTML is always UTF-8
                if (SUCCEEDED(MimeOleFindCharset("utf-8", &hCharset)))
                {
                    // Set It
                    pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
                }
            }

            // Otherwise...
            else
            {
                // Locals
                LPSTR pszCharset=NULL;

                // Sniff the charset
                if (SUCCEEDED(GetHtmlCharset(pStream, &pszCharset)))
                {
                    // Locals
                    HCHARSET hCharset;

                    // Map to HCHARSET
                    if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
                    {
                        // Set It
                        pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
                    }

                    // Cleanup
                    SafeMemFree(pszCharset);
                }
            }

            // We should sniff the charset from the html document and call pMessage->SetCharset
            pMessage->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pStream, NULL);
        }

        // Set plain text, non-unicode text body
        else
            pMessage->SetTextBody(TXT_PLAIN, IET_BINARY, NULL, pStream, NULL);
    }
    
    // If there is a single file and the content is text/plain or text/html, then
    // we insert the contents of the message as the body.  Otherwise, we add each
    // file as an attachment.
    if (cf == CF_HDROP)
    {
        HDROP    hDrop = (HDROP) GlobalLock(stg.hGlobal);
        BOOL     fHTML = FALSE,
                 fSetCharset = FALSE,
                 fUnicode = FALSE,
                 fLittleEndian;
        
        if (FIsFileInsertable(hDrop, &pStream, &fHTML))
        {
            if(fHTML)
            {
                LPSTR pszCharset = NULL;                

                // Sniff the charset
                if (FAILED(GetHtmlCharset(pStream, &pszCharset)) && (S_OK == HrIsStreamUnicode(pStream, &fLittleEndian)))
                    pszCharset = StrDupA("utf-8");

                if(pszCharset)
                {
                    HCHARSET hCharset = NULL;

                    // Map to HCHARSET
                    if (SUCCEEDED(MimeOleFindCharset(pszCharset, &hCharset)))
                    {
                        // Set It
                        if(SUCCEEDED(pMessage->SetCharset(hCharset, CSET_APPLY_ALL)))
                            fSetCharset = TRUE;
                    }

                    // Cleanup
                    SafeMemFree(pszCharset);
                }

            }
            else if(S_OK == HrIsStreamUnicode(pStream, &fLittleEndian))
            {
                HCHARSET hCharset;

                if (SUCCEEDED(MimeOleFindCharset("UTF-8", &hCharset)))
                {
                    pMessage->SetCharset(hCharset, CSET_APPLY_ALL);
                }
                
                fUnicode = TRUE;                
            }

            pMessage->SetTextBody((fHTML ? TXT_HTML : TXT_PLAIN),
                (fSetCharset ? IET_INETCSET : (fUnicode ? IET_UNICODE : IET_DECODED)),
                NULL, pStream, NULL);
            SafeRelease(pStream);
        }
        else
        {
            // Get the drop handle and add it's contents to the message
            hr = HrAttachHDrop(hwnd, pMessage, hDrop, grfKeyState & MK_CONTROL && grfKeyState & MK_SHIFT);
        }
        
        GlobalUnlock(stg.hGlobal);
    }
    
    // Last step is to instantiate the send note
    INIT_MSGSITE_STRUCT initStruct;
    BOOL fNews;
    fNews = FALSE;
    
    initStruct.dwInitType = OEMSIT_MSG;
    initStruct.folderID = 0;
    initStruct.pMsg = pMessage;
    
    if (FOLDER_NEWS == GetFolderType(m_idFolder))
    {
        FOLDERINFO fi = {0};
        TCHAR      sz[1024];

        fNews = TRUE;

        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &fi)))
        {
            // Set some news-specific fields on the message
            if ((FOLDER_SERVER & fi.dwFlags) == 0)
                MimeOleSetBodyPropA(pMessage, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, fi.pszName);

            FOLDERINFO fiServer = {0};

            if (SUCCEEDED(GetFolderServer(m_idFolder, &fiServer)))
            {
                HrSetAccount(pMessage, fiServer.pszName);
                g_pStore->FreeRecord(&fiServer);
            }

            g_pStore->FreeRecord(&fi);
        }
    }
    
    CreateAndShowNote(OENA_COMPOSE, fNews ? OENCF_NEWSFIRST : 0, &initStruct, m_hwndOwner);
    
exit:
    SafeRelease(pMessage);
    
    if (fRelease)
        ReleaseStgMedium(&stg);
    
    return (hr);
}
    



//
//  FUNCTION:   CBaseDataObject::CBaseDataObject
//
//  PURPOSE:    Simple constructor, initializes everything to NULL or zero.
//
CBaseDataObject::CBaseDataObject()
{    
    m_cRef = 1;

    ZeroMemory(m_rgFormatEtc, sizeof(m_rgFormatEtc));
    m_cFormatEtc = 0;
}


//
//  FUNCTION:   CBaseDataObject::~CBaseDataObject
//
//  PURPOSE:    Cleans up any leftover data.
//
CBaseDataObject::~CBaseDataObject()
{
    Assert(m_cRef == 0);    
}


//
//  FUNCTION:   CBaseDataObject::QueryInterface()
//
//  PURPOSE:    Returns a the requested interface if supported.
//
STDMETHODIMP CBaseDataObject::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (LPVOID)(IUnknown*) this;
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = (LPVOID)(IDataObject*) this;

    if (NULL == *ppv)
        return (E_NOINTERFACE);

    AddRef();
    return (S_OK);
}


//
//  FUNCTION:   CBaseDataObject::AddRef()
//
//  PURPOSE:    Increments the object reference count.
//
STDMETHODIMP_(ULONG) CBaseDataObject::AddRef(void)
{
    return (++m_cRef);
}


//
//  FUNCTION:   CBaseDataObject::Release()
//
//  PURPOSE:    Decrements the object's ref count. If the ref count hit's zero 
//              the object is freed.
//
STDMETHODIMP_(ULONG) CBaseDataObject::Release(void)
{
    m_cRef--;

    if (0 == m_cRef)
    {
        delete this;
        return (0);
    }

    return (m_cRef);
}


//
//  FUNCTION:   CBaseDataObject::GetDataHere
//
//  PURPOSE:    Returns the object's data in a requested format on the storage
//              the caller allocated.
//
//  PARAMETERS:
//      pFE        - Pointer to the FORMATETC structure that specifies the
//                   format the data is requested in.
//      pStgMedium - Pointer to the STGMEDIUM structure that contains the
//                   medium the caller allocated and the object provides the
//                   data on.
//
//  RETURN VALUE:
//      Returns an HRESULT indicating success or failure.
//
STDMETHODIMP CBaseDataObject::GetDataHere (LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    return E_NOTIMPL;
}


//
//  FUNCTION:   CBaseDataObject::GetCanonicalFormatEtc
//
//  PURPOSE:    Communicates to the caller which FORMATETC data structures
//              produce the same output data.
//
//  PARAMETERS:
//      pFEIn  - Points to the FORMATETC in which the caller wants the returned
//               data.
//      pFEOut - Points to the FORMATETC which is the canonical equivalent of
//               pFEIn.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
STDMETHODIMP CBaseDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn,
                                                    LPFORMATETC pFEOut)
{
    if (NULL == pFEOut)
        return (E_INVALIDARG);

    pFEOut->ptd = NULL;
    return (DATA_S_SAMEFORMATETC);
}


//
//  FUNCTION:   CBaseDataObject::EnumFormatEtc
//
//  PURPOSE:    Provides an interface the caller can use to enumerate the
//              FORMATETC's that the data object supports.
//
//  PARAMETERS:
//      dwDirection - DATADIR_GET if the caller wants to enumerate the formats
//                    he can get, or DATADIR_SET if he wants to enumerate the
//                    formats he can set.
//      ppEnum      - Points to the enumerator the caller can use to enumerate.
//
//  RETURN VALUE:
//      Returns S_OK if ppEnum contains the enumerator, or E_NOTIMPL if the
//      direction dwDirection is not supported.
//
STDMETHODIMP CBaseDataObject::EnumFormatEtc(DWORD dwDirection,
                                            IEnumFORMATETC** ppEnum)
{
    LPFORMATETC pFE = 0;
    ULONG       cFE = 0;
    
    if (DATADIR_GET == dwDirection)
    {
        // Create the enumerator and give it our list of formats      
        if (SUCCEEDED(_BuildFormatEtc(NULL, NULL)))
        {
            if (SUCCEEDED(CreateEnumFormatEtc(this, m_cFormatEtc, NULL, m_rgFormatEtc, ppEnum)))
                return (S_OK);
        }
        
        *ppEnum = NULL;
        return (E_FAIL);    
    }
    else
    {
        *ppEnum = NULL;
        return (E_NOTIMPL);
    }
}


//
//  FUNCTION:   CBaseDataObject::SetData
//
//  PURPOSE:    pStgMedium contains data that the caller wants us to store.
//              This data object does not support a caller changing our data.
//
STDMETHODIMP CBaseDataObject::SetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium,
                                      BOOL fRelease)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CBaseDataObject::DAdvise
//
//  PURPOSE:    Creates a connection between the data-transfer object and an
//              advisory sink through which the sink can be informed when the
//              object's data changes.  This object does not support advises.
STDMETHODIMP CBaseDataObject::DAdvise(LPFORMATETC pFE, DWORD advf,
                                      IAdviseSink* ppAdviseSink,
                                      LPDWORD pdwConnection)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CBaseDataObject::DUnadvise
//
//  PURPOSE:    Deletes an advisory connect previously established via DAdvise.
//              This object doesn't support advises.
//
STDMETHODIMP CBaseDataObject::DUnadvise(DWORD dwConnection)
{
    return (E_NOTIMPL);
}

//
//  FUNCTION:   CBaseDataObject::EnumDAdvise
//
//  PURPOSE:    Enumerates the advisory connections previously established via
//              DAdvise.  This object doesn't support advises.
//
STDMETHODIMP CBaseDataObject::EnumDAdvise(IEnumSTATDATA** ppEnumAdvise)
{
    return (E_NOTIMPL);
}


//
//  FUNCTION:   CFolderDataObject::GetData
//
//  PURPOSE:    Returns the object's data in a requested format in the
//              specified storage medium which the object allocates.
//
//  PARAMETERS:
//      pFE        - Pointer to the FORMATETC structure that specifies the
//                   format the data is requested in.
//      pStgMedium - Pointer to the STGMEDIUM structure that contains the
//                   medium the object allocates and provides the data on.
//
//  RETURN VALUE:
//      Returns an HRESULT indicating success or failure.
//
STDMETHODIMP CFolderDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr;

    // Initialize this
    ZeroMemory(pStgMedium, sizeof(STGMEDIUM));

    if (CF_OEFOLDER == pFE->cfFormat)
        return (_RenderOEFolder(pFE, pStgMedium));
    else if ((CF_TEXT == pFE->cfFormat) || (CF_SHELLURL == pFE->cfFormat))
        return (_RenderTextOrShellURL(pFE, pStgMedium));
    else if ((CF_FILEDESCRIPTORW == pFE->cfFormat) || 
             (CF_FILECONTENTS == pFE->cfFormat) || 
             (CF_FILEDESCRIPTORA == pFE->cfFormat))
    {
        AssertSz(FALSE, "These cases not implemented");
        return (E_NOTIMPL);
    }
    else
        return (DV_E_FORMATETC);   
}


//
//  FUNCTION:   CFolderDataObject::QueryGetData
//
//  PURPOSE:    Determines if a call to GetData() would succeed if it were
//              passed pFE.
//
//  PARAMETERS:
//      pFE - Pointer to the FORMATETC structure to check to see if the data
//            object supports a particular format.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
STDMETHODIMP CFolderDataObject::QueryGetData(LPFORMATETC pFE)
{
    // Make sure this is already built
    _BuildFormatEtc(NULL, NULL);

    // Loop through our formats until we find a match
    for (UINT i = 0; i < m_cFormatEtc; i++)
    {
        if (pFE->cfFormat == m_rgFormatEtc[i].cfFormat && 
            pFE->tymed & m_rgFormatEtc[i].tymed)
        {
            return (S_OK);
        }
    }

    return (DV_E_FORMATETC);
}


//
//  FUNCTION:   CFolderDataObject::_RenderOEFolder()
//
//  PURPOSE:    Renders the data into the CF_OEFOLDER format
//
HRESULT CFolderDataObject::_RenderOEFolder(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CFolderDataObject::_RenderOEFolder");

    HGLOBAL   hGlobal;
    FOLDERID *pFolderID;

    // We only support HGLOBALs
    if (pFE->tymed & TYMED_HGLOBAL)
    {
        // I just love allocating 4 bytes
        hGlobal = GlobalAlloc(GHND, sizeof(FOLDERID));
        if (NULL == hGlobal)
            return (E_OUTOFMEMORY);

        // Local the memory
        pFolderID = (FOLDERID *) GlobalLock(hGlobal);

        // Set the value
        *pFolderID = m_idFolder;

        // Unlock
        GlobalUnlock(hGlobal);

        // Set up the return value
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = 0;
        pStgMedium->tymed = TYMED_HGLOBAL;

        return (S_OK);
    }

    return (DV_E_TYMED);
}


//
//  FUNCTION:   CFolderDataObject::_RenderShellURL()
//
//  PURPOSE:    Renders the data into the CF_SHELLURL format
//
HRESULT CFolderDataObject::_RenderTextOrShellURL(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CFolderDataObject::_RenderOEFolder");

    HGLOBAL     hGlobal;
    FOLDERID   *pFolderID;
    FOLDERINFO  rInfo = { 0 };
    TCHAR       szNewsPrefix[] = _T("news://");
    LPTSTR      pszURL;
    DWORD       cch;
    HRESULT     hr;

    // We only support HGLOBALs
    if (!(pFE->tymed & TYMED_HGLOBAL))
    {
        hr = DV_E_TYMED;
        goto exit;
    }

    // Get information about the source folder
    Assert(g_pStore);
    if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rInfo)))
    {
        cch = lstrlen(rInfo.pszName) + lstrlen(szNewsPrefix) + 2;

        // Allocate a buffer for the generated URL
        hGlobal = GlobalAlloc(GHND, sizeof(TCHAR) * cch);
        if (!hGlobal)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        // Double check that our source file is indeed a newsgroup
        if (pFE->cfFormat == CF_SHELLURL)
        {
            if (!(rInfo.tyFolder == FOLDER_NEWS && !(rInfo.dwFlags & FOLDER_SERVER)))
            {
                hr = E_UNEXPECTED;
                goto exit;
            }

            // Generate a URL from the newsgroup name
            pszURL = (LPTSTR) GlobalLock(hGlobal);
            wsprintf(pszURL, _T("%s%s"), szNewsPrefix, rInfo.pszName);
            GlobalUnlock(hGlobal);
        }
        else if (pFE->cfFormat == CF_TEXT)
        {
            // Copy the folder name to the buffer
            pszURL = (LPTSTR) GlobalLock(hGlobal);
            StrCpyN(pszURL, rInfo.pszName, cch);
            GlobalUnlock(hGlobal);
        }
        else
        {
            AssertSz(FALSE, "CFolderDataObject::_RenderTextOrShellURL() - How did we get here?");
            hr = DV_E_FORMATETC;
            goto exit;
        }

        // Set up the return value
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = 0;
        pStgMedium->tymed = TYMED_HGLOBAL;

        hr = S_OK;
    }

exit:
    if (rInfo.pAllocated)
        g_pStore->FreeRecord(&rInfo);

    return (hr);
}


//
//  FUNCTION:   CMsgDataObject::HrBuildFormatEtc()
//
//  PURPOSE:    Builds the list of FORMATETC structs that this object will 
//              support.  This list is stored in m_rgFormatEtc[].
//
//  PARAMTERS:
//      [out] ppFE  - Returns the arrray of FORMATETC structures
//      [out] pcElt - Returns the size of ppFE
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CFolderDataObject::_BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt)
{
    BOOL        fNews = FALSE;
    FOLDERINFO  rInfo = { 0 };

    // If we haven't built our format list yet, do so first.
    if (FALSE == m_fBuildFE)
    {
        ZeroMemory(&m_rgFormatEtc, sizeof(m_rgFormatEtc));
        m_cFormatEtc = 0;

        // Figure out if this is a news group first
        if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolder, &rInfo)))
        {
            fNews = rInfo.tyFolder == FOLDER_NEWS && !(rInfo.dwFlags & FOLDER_SERVER);
            g_pStore->FreeRecord(&rInfo);
        }

        if (fNews)
        {
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_SHELLURL, TYMED_HGLOBAL);
            m_cFormatEtc++;
        }

        // Since you can't move a newsgroup, we don't support this format
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_OEFOLDER, TYMED_HGLOBAL);
        m_cFormatEtc++;

        /*
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILEDESCRIPTOR, TYMED_HGLOBAL);
        m_cFormatEtc++;
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILECONTENTS, TYMED_HGLOBAL);
        m_cFormatEtc++;
        */

        m_fBuildFE = TRUE;
    }

    // Return what we have if the caller cares
    if (ppFE && pcElt)
    {
        *ppFE = m_rgFormatEtc;
        *pcElt = m_cFormatEtc;
    }

    return (S_OK);
}


CMessageDataObject::CMessageDataObject()
{
    m_pMsgIDList = NULL;
    m_idSource = FOLDERID_INVALID;
    m_fBuildFE = FALSE;
    m_fDownloaded = FALSE;
}

CMessageDataObject::~CMessageDataObject()
{
}


HRESULT CMessageDataObject::Initialize(LPMESSAGEIDLIST pMsgs, FOLDERID idSource)
{
    IMessageFolder *pFolder = 0;
    HRESULT         hr;
    DWORD           i;
    MESSAGEINFO     rInfo;
    DWORD           cDownloaded = 0;

    m_pMsgIDList = pMsgs;
    m_idSource = idSource;
 
    // Open the folder that contains the message
    if (SUCCEEDED(hr = g_pStore->OpenFolder(m_idSource, NULL, NOFLAGS, &pFolder)))
    {
        // See if they have bodies or not.  All must.
        for (i = 0; i < m_pMsgIDList->cMsgs; i++)
        {
            if (SUCCEEDED(GetMessageInfo(pFolder, m_pMsgIDList->prgidMsg[i], &rInfo)))
            {
                if (rInfo.dwFlags & ARF_HASBODY)
                    cDownloaded++;

                pFolder->FreeRecord(&rInfo);
            }
        }

        pFolder->Release();
    }

    m_fDownloaded = (cDownloaded == m_pMsgIDList->cMsgs);

    return (S_OK);
}



//
//  FUNCTION:   CMessageDataObject::GetData()
//
//  PURPOSE:    Called by the drop target to get the data from the data object.
//
//  PARAMETERS: 
//      LPFORMATETC pFE
//      LPSTGMEDIUM pStgMedium
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr = DV_E_FORMATETC;

    TraceCall("CMessageDataObject::GetData");

    if (pFE->cfFormat == CF_OEMESSAGES)
        return (_RenderOEMessages(pFE, pStgMedium));

    if (m_fDownloaded)
    {
        IMimeMessage *pMsg = NULL;

        if ((CF_FILEDESCRIPTORW == pFE->cfFormat) ||
            (CF_FILEDESCRIPTORA == pFE->cfFormat))
            return (_RenderFileGroupDescriptor(pFE, pStgMedium));

        if (CF_FILECONTENTS == pFE->cfFormat)
            return (_RenderFileContents(pFE, pStgMedium));

        // Otherwise, do the default action
        if (m_pMsgIDList->cMsgs == 1)
        {
            if (SUCCEEDED(_LoadMessage(0, &pMsg, NULL)))
            {
                IDataObject  *pDataObject = NULL;
                if (SUCCEEDED(pMsg->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObject)))
                {
                    hr = pDataObject->GetData(pFE, pStgMedium);
                    pDataObject->Release();
                }

                pMsg->Release();
            }
        }
    }

    return (hr);
}


//
//  FUNCTION:   CMessageDataObject::QueryGetData
//
//  PURPOSE:    Determines if a call to GetData() would succeed if it were
//              passed pFE.
//
//  PARAMETERS:
//      pFE - Pointer to the FORMATETC structure to check to see if the data
//            object supports a particular format.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
HRESULT CMessageDataObject::QueryGetData(LPFORMATETC pFE)
{
    IMimeMessage *pMsg = 0;
    IDataObject  *pDataObject = 0;
    HRESULT       hr = DV_E_FORMATETC;

    // Walk through the formats we support to see if any match
    if (SUCCEEDED(_BuildFormatEtc(NULL, NULL)))
    {
        for (UINT i = 0; i < m_cFormatEtc; i++)
        {
            if (pFE->cfFormat == m_rgFormatEtc[i].cfFormat &&
                pFE->tymed == m_rgFormatEtc[i].tymed)
            {
                hr = S_OK;
                goto exit;
            }
        }

        // If we have a message object, then ask it for it's formats as well.
        if (m_pMsgIDList->cMsgs == 1)
        {
            if (SUCCEEDED(_LoadMessage(0, &pMsg, NULL)))
            {
                if (SUCCEEDED(pMsg->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObject)))
                {
                    hr = pDataObject->QueryGetData(pFE);
                    pDataObject->Release();
                }

                pMsg->Release();
            }
        }
    }

exit:
    return (hr);
}


HRESULT CMessageDataObject::_BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt)
{
    IEnumFORMATETC *pEnum = 0;
    FORMATETC       fe;
    ULONG           celtFetched;
    IMimeMessage   *pMessage = 0;
    HRESULT         hr = S_OK;

    // Only build our internal list of formats once
    if (FALSE == m_fBuildFE)
    {
        m_cFormatEtc = 0;

        // We always support these formats
        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_OEMESSAGES, TYMED_HGLOBAL);
        m_cFormatEtc++;

        // We support these if the messages are downloaded
        if (m_fDownloaded)
        {
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILEDESCRIPTORA, TYMED_HGLOBAL);
            m_cFormatEtc++;
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILEDESCRIPTORW, TYMED_HGLOBAL);
            m_cFormatEtc++;
            SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_FILECONTENTS, TYMED_ISTREAM);
            m_cFormatEtc++;
        }

        // If we're holding just one message, then have the message add it's
        // own formats too.
        if (m_fDownloaded && m_pMsgIDList->cMsgs == 1 && SUCCEEDED(_LoadMessage(0, &pMessage, NULL)))
        {
            IDataObject *pDataObject = 0;

            // Get the data object interface from the message
            if (SUCCEEDED(hr = pMessage->QueryInterface(IID_IDataObject, (LPVOID *) &pDataObject)))
            {
                if (SUCCEEDED(hr = pDataObject->EnumFormatEtc(DATADIR_GET, &pEnum)))
                {
                    pEnum->Reset();
                    while (S_OK == pEnum->Next(1, &fe, &celtFetched))
                    {
                        m_rgFormatEtc[m_cFormatEtc] = fe;
                        m_cFormatEtc++;
                    }

                    pEnum->Release();
                }

                pDataObject->Release();
            }

            pMessage->Release();
        }
    }

    // Return what we have
    if (ppFE && pcElt)
    {
        *ppFE = m_rgFormatEtc;
        *pcElt = m_cFormatEtc;
    }

    return (hr);
}



//
//  FUNCTION:   CMessageDataObject::_LoadMessage()
//
//  PURPOSE:    This function loads the specified message from the store.
//
//  PARAMETERS: 
//      iMsg       - Index into m_rgMsgs of the message desired
//      ppMsg      - Returns a pointer to the message
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageDataObject::_LoadMessage(DWORD iMsg, IMimeMessage **ppMsg, LPWSTR pwszFileExt)
{
    TraceCall("CMessageDataObject::_LoadMessage");

    IMessageFolder    *pFolder = NULL;
    IDataObject       *pDataObj = NULL;
    HRESULT            hr;
    
    // Open the folder that contains the message
    *ppMsg = NULL;
    hr = g_pStore->OpenFolder(m_idSource, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
        goto exit;

    // Open the message from the folder
    hr = pFolder->OpenMessage(m_pMsgIDList->prgidMsg[iMsg], 
                              OPEN_MESSAGE_SECURE | OPEN_MESSAGE_CACHEDONLY, 
                              ppMsg, NOSTORECALLBACK);
    if (FAILED(hr))
        goto exit;
                 
    if (pwszFileExt)
    {
        LPTSTR pszNewsgroups = NULL;

        if (SUCCEEDED(MimeOleGetBodyPropA(*ppMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &pszNewsgroups)))
        {
            MemFree(pszNewsgroups);
            AthLoadStringW(idsDefNewsExt, pwszFileExt, 32);
        }
        else
            AthLoadStringW(idsDefMailExt, pwszFileExt, 32);

    }

exit:
    SafeRelease(pFolder);

    if (FAILED(hr))
        SafeRelease((*ppMsg));
        
    return (hr);
}


//
//  FUNCTION:   CMessageDataObject::_RenderOEMessages()
//
//  PURPOSE:    Renders the data from our object into the CF_OEMESSAGES format.
//
//  PARAMETERS: 
//      pFE
//      pStgMedium
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CMessageDataObject::_RenderOEMessages(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CMessageDataObject::_RenderOEMessages");

    // Make sure the caller want's an HGLOBAL
    if (pFE->tymed != TYMED_HGLOBAL)
        return (DV_E_TYMED);

    // Figure out how much memory to allocate for our returned information
    DWORD cb = sizeof(OEMESSAGES) + (sizeof(MESSAGEID) * m_pMsgIDList->cMsgs);
    
    // Allocate the memory
    HGLOBAL hGlobal = GlobalAlloc(GHND | GMEM_SHARE, cb);
    if (NULL == hGlobal)
        return (E_OUTOFMEMORY);

    OEMESSAGES *pOEMessages = (OEMESSAGES *) GlobalLock(hGlobal);

    // Fill in the basic fields
    pOEMessages->idSource = m_idSource;
    pOEMessages->rMsgIDList = *m_pMsgIDList;
    pOEMessages->rMsgIDList.prgidMsg = (MESSAGEID *) ((LPBYTE) pOEMessages + sizeof(OEMESSAGES));

    // Copy the message ID's
    CopyMemory(pOEMessages->rMsgIDList.prgidMsg, m_pMsgIDList->prgidMsg, sizeof(MESSAGEID) * m_pMsgIDList->cMsgs);
    GlobalUnlock(hGlobal);

    // Fill out the return value info
    pStgMedium->tymed = TYMED_HGLOBAL;
    pStgMedium->hGlobal = hGlobal;
    pStgMedium->pUnkForRelease = 0;

    return (S_OK);
}


//
//  FUNCTION:   CMessageDataObject::_RenderFileContents()
//
//  PURPOSE:    Takes the data that this object contains and renders it into an
//              IStream.
//
//  PARAMETERS:
//      <in>  pFE        - Pointer to the FORMATETC struct that describes the 
//                         type of data requested.
//      <out> pStgMedium - Pointer to where we should return the rendered data.
//
//  RETURN VALUE:
//      DV_E_TYMED - A tymed was requested that we don't support
//      E_OUTOFMEMORY - not enough memory
//      S_OK - Everything succeeded
//
HRESULT CMessageDataObject::_RenderFileContents(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    IMimeMessage *pMsg = 0;
    IDataObject  *pDataObject = 0;
    FORMATETC     feMsg;    
    HRESULT       hr = E_FAIL;
    DWORD               dwFlags = 0;
    
    Assert(pFE->lindex < (int) m_pMsgIDList->cMsgs);
    
    // Get the IDataObject for the specific message
    if (SUCCEEDED(_LoadMessage(pFE->lindex, &pMsg, NULL)))
    {
        // prevent save to file message with label
        pMsg->GetFlags(&dwFlags);
    
        if (IMF_SECURE & dwFlags)
        {
            hr = HandleSecurity(NULL, pMsg);
            if(FAILED(hr))
                goto exit;

            SafeRelease(pMsg);
            if (FAILED(_LoadMessage(pFE->lindex, &pMsg, NULL)))
                goto exit;
        }

        if (SUCCEEDED(pMsg->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObject)))
        {
            SETDefFormatEtc(feMsg, CF_INETMSG, TYMED_ISTREAM);
            hr = pDataObject->GetData(&feMsg, pStgMedium);
        }
    }

exit:
    // Cleanup
    SafeRelease(pMsg);
    SafeRelease(pDataObject);
    
    return (hr);    
}


//
//  FUNCTION:   CMessageDataObject::_RenderFileGroupDescriptor()
//
//  PURPOSE:    Takes the data that this object contains and renders it into a
//              FILEGROUPDESCRIPTOR struct.
//
//  PARAMETERS:
//      <in>  pFE        - Pointer to the FORMATETC struct that describes the 
//                         type of data requested.
//      <out> pStgMedium - Pointer to where we should return the rendered data.
//
//  RETURN VALUE:
//      DV_E_TYMED    - A tymed was requested that we don't support
//      E_OUTOFMEMORY - not enough memory
//      S_OK          - Everything succeeded
//
HRESULT CMessageDataObject::_RenderFileGroupDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HGLOBAL                 hGlobal = 0;
    FILEGROUPDESCRIPTORA   *pFileGDA = NULL;
    FILEGROUPDESCRIPTORW   *pFileGDW = NULL;
    IMimeMessage           *pMsg = 0;
    PROPVARIANT             pv;
    DWORD                   cMsgs = m_pMsgIDList->cMsgs;
    BOOL                    fWide = (CF_FILEDESCRIPTORW == pFE->cfFormat);
    WCHAR                   wszFileExt[32];
    UINT                    cbDescSize = 0;
    LPWSTR                  pwszSubject = NULL;
    LPSTR                   pszSubject = NULL,
                            pszFileExt = NULL;
    HRESULT                 hr = S_OK;
    UINT                    i = 0;
    
    // Allocate a FILEGROUPDESCRIPTOR struct large enough to contain the names
    // of all the messages we contain.

    cbDescSize = (fWide ? (sizeof(FILEGROUPDESCRIPTORW) + (sizeof(FILEDESCRIPTORW) * (cMsgs - 1))) :
                          (sizeof(FILEGROUPDESCRIPTORA) + (sizeof(FILEDESCRIPTORA) * (cMsgs - 1))));
    IF_NULLEXIT(hGlobal = GlobalAlloc(GHND, cbDescSize));

    pFileGDA = (FILEGROUPDESCRIPTORA *) GlobalLock(hGlobal);
    pFileGDA->cItems = cMsgs;
    pFileGDW = (FILEGROUPDESCRIPTORW *)pFileGDA;
    
    // Copy the file names one at a time into the pFileGDA struct
    for (; i < cMsgs; i++)
    {
        if (SUCCEEDED(_LoadMessage(i, &pMsg, wszFileExt)))
        {
            if (fWide)
            {
                if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwszSubject)) && pwszSubject && *pwszSubject)
                {
                    AthwsprintfW(pFileGDW->fgd[i].cFileName, ARRAYSIZE(pFileGDW->fgd[i].cFileName), L"%.180s.%s", pwszSubject, wszFileExt);
                }
                else
                {
                    WCHAR wszBuf[CCHMAX_STRINGRES];
                    AthLoadStringW(idsMessageFileName, wszBuf, ARRAYSIZE(wszBuf));
                    AthwsprintfW(pFileGDW->fgd[i].cFileName, ARRAYSIZE(pFileGDW->fgd[i].cFileName), wszBuf, i + 1, wszFileExt);
                }
            }
            else
            {
                IF_NULLEXIT(pszFileExt = PszToANSI(CP_ACP, wszFileExt));
            
                if (SUCCEEDED(MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwszSubject)) && pwszSubject && *pwszSubject)
                {
                    IF_NULLEXIT(pszSubject = PszToANSI(CP_ACP, pwszSubject));
                    wsprintf(pFileGDA->fgd[i].cFileName, _T("%.180s.%s"), pszSubject, pszFileExt);
                }
                else
                {
                    TCHAR szBuf[CCHMAX_STRINGRES];
                    AthLoadString(idsMessageFileName, szBuf, ARRAYSIZE(szBuf));
                    wsprintf(pFileGDA->fgd[i].cFileName, szBuf, i + 1, pszFileExt);
                }
            }
            SafeMemFree(pszSubject);
            SafeMemFree(pwszSubject);
            SafeMemFree(pszFileExt);
            
            if (fWide)
            {
                pFileGDW->fgd[i].dwFlags = FD_FILESIZE | FD_WRITESTIME;
                pFileGDW->fgd[i].nFileSizeHigh = 0;
                pMsg->GetMessageSize(&pFileGDW->fgd[i].nFileSizeLow, 0);
                pv.vt = VT_FILETIME;
                pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);
                pFileGDW->fgd[i].ftLastWriteTime = pv.filetime;

                CleanupFileNameInPlaceW(pFileGDW->fgd[i].cFileName);
            }
            else
            {
                pFileGDA->fgd[i].dwFlags = FD_FILESIZE | FD_WRITESTIME;
                pFileGDA->fgd[i].nFileSizeHigh = 0;
                pMsg->GetMessageSize(&pFileGDA->fgd[i].nFileSizeLow, 0);
                pv.vt = VT_FILETIME;
                pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv);
                pFileGDA->fgd[i].ftLastWriteTime = pv.filetime;

                CleanupFileNameInPlaceA(CP_ACP, pFileGDA->fgd[i].cFileName);    
            }
            SafeRelease(pMsg);
        }
    }
    
exit:
    // Put the structure into the STGMEDIUM
    if (hGlobal)
        GlobalUnlock(hGlobal);

    if (SUCCEEDED(hr))
    {
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = NULL;
        pStgMedium->tymed = TYMED_HGLOBAL;
    }

    MemFree(pszSubject);
    MemFree(pwszSubject);
    MemFree(pszFileExt);

    return hr;
}



//
//  FUNCTION:   CShortcutDataObject::GetData
//
//  PURPOSE:    Returns the object's data in a requested format in the
//              specified storage medium which the object allocates.
//
//  PARAMETERS:
//      pFE        - Pointer to the FORMATETC structure that specifies the
//                   format the data is requested in.
//      pStgMedium - Pointer to the STGMEDIUM structure that contains the
//                   medium the object allocates and provides the data on.
//
//  RETURN VALUE:
//      Returns an HRESULT indicating success or failure.
//
STDMETHODIMP CShortcutDataObject::GetData(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    HRESULT hr;

    // Initialize this
    ZeroMemory(pStgMedium, sizeof(STGMEDIUM));

    // Loop through the format array to see if any of the elements are the
    // same as pFE.
    if (pFE->cfFormat == CF_OESHORTCUT)
        return (_RenderOEShortcut(pFE, pStgMedium));

    else
        return (DV_E_FORMATETC);   
        
}


//
//  FUNCTION:   CShortcutDataObject::QueryGetData
//
//  PURPOSE:    Determines if a call to GetData() would succeed if it were
//              passed pFE.
//
//  PARAMETERS:
//      pFE - Pointer to the FORMATETC structure to check to see if the data
//            object supports a particular format.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
STDMETHODIMP CShortcutDataObject::QueryGetData(LPFORMATETC pFE)
{
    // Make sure this is already built
    _BuildFormatEtc(NULL, NULL);

    // Loop through our formats until we find a match
    for (UINT i = 0; i < m_cFormatEtc; i++)
    {
        if (pFE->cfFormat == m_rgFormatEtc[i].cfFormat && 
            pFE->tymed & m_rgFormatEtc[i].tymed)
        {
            return (S_OK);
        }
    }

    return (DV_E_FORMATETC);
}


//
//  FUNCTION:   CShortcutDataObject::_RenderOEFolder()
//
//  PURPOSE:    Renders the data into the CF_OESHORTCUT format
//
HRESULT CShortcutDataObject::_RenderOEShortcut(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium)
{
    TraceCall("CShortcutDataObject::_RenderOEShortcut");

    HGLOBAL   hGlobal;
    UINT     *piPos;

    // We only support HGLOBALs
    if (pFE->tymed & TYMED_HGLOBAL)
    {
        // I just love allocating 4 bytes
        hGlobal = GlobalAlloc(GHND, sizeof(FOLDERID));
        if (NULL == hGlobal)
            return (E_OUTOFMEMORY);

        // Local the memory
        piPos = (UINT *) GlobalLock(hGlobal);

        // Set the value
        *piPos = m_iPos;

        // Unlock
        GlobalUnlock(hGlobal);

        // Set up the return value
        pStgMedium->hGlobal = hGlobal;
        pStgMedium->pUnkForRelease = 0;
        pStgMedium->tymed = TYMED_HGLOBAL;

        return (S_OK);
    }

    return (DV_E_TYMED);
}

//
//  FUNCTION:   CShortcutDataObject::HrBuildFormatEtc()
//
//  PURPOSE:    Builds the list of FORMATETC structs that this object will 
//              support.  This list is stored in m_rgFormatEtc[].
//
//  PARAMTERS:
//      [out] ppFE  - Returns the arrray of FORMATETC structures
//      [out] pcElt - Returns the size of ppFE
//
//  RETURN VALUE:
//      S_OK
//
HRESULT CShortcutDataObject::_BuildFormatEtc(LPFORMATETC *ppFE, ULONG *pcElt)
{
    BOOL        fNews = FALSE;
    FOLDERINFO  rInfo = { 0 };

    // If we haven't built our format list yet, do so first.
    if (FALSE == m_fBuildFE)
    {
        ZeroMemory(&m_rgFormatEtc, sizeof(m_rgFormatEtc));
        m_cFormatEtc = 0;

        SETDefFormatEtc(m_rgFormatEtc[m_cFormatEtc], CF_OESHORTCUT, TYMED_HGLOBAL);
        m_cFormatEtc++;

        m_fBuildFE = TRUE;
    }

    // Return what we have if the caller cares
    if (ppFE && pcElt)
    {
        *ppFE = m_rgFormatEtc;
        *pcElt = m_cFormatEtc;
    }

    return (S_OK);
}


//
//  FUNCTION:   FIsFileInsertable()
//
//  PURPOSE:    If there is a single file in the specified HDROP, then we check
//              the mime content type of the file to see if it's text/html or
//              text/plain.  If so, we open the file and return an IStream on
//              that file.
//
//  PARAMETERS:
//      <in>  hDrop    - HDROP handle to check.
//      <out> ppStream - If not NULL and the checks listed above succeed, then
//                       this returns a stream pointer on the file.
//
//  RETURN VALUE:
//      TRUE if the file is insertable as the body of a message
//      FALSE otherwise.
//
BOOL FIsFileInsertable(HDROP hDrop, LPSTREAM *ppStream, BOOL* fHTML)
{
    WCHAR   wszFile[MAX_PATH];
    LPWSTR  pwszCntType = 0,
            pwszCntSubType = 0,
            pwszCntDesc = 0,
            pwszFName = 0;
    BOOL   fReturn = FALSE;
    
    // If there is more than one file then we attach instead
    if (1 == DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0))
    {
        // Get the file name
        DragQueryFileWrapW(hDrop, 0, wszFile, ARRAYSIZE(wszFile));
        
        // Find out it's content type
        MimeOleGetFileInfoW(wszFile, &pwszCntType, &pwszCntSubType, &pwszCntDesc,
            &pwszFName, NULL);
        
        // See if the content is text/plain or text/html
        if ((0 == StrCmpIW(pwszCntType, L"text")) &&
            ((0 == StrCmpIW(pwszCntSubType, L"plain")) ||
             (0 == StrCmpIW(pwszCntSubType, L"html"))))
        {
            if (ppStream)
            {
                // Get a stream on that file
                if (SUCCEEDED(CreateStreamOnHFileW(wszFile, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                    0, ppStream)))
                {
                    fReturn = TRUE;
                    *fHTML = !StrCmpIW(pwszCntSubType, L"html");
                }
            }
        }
    }
    
    MemFree(pwszCntType);
    MemFree(pwszCntSubType);
    MemFree(pwszCntDesc);
    MemFree(pwszFName);
    
    return (fReturn);
}

//
//  FUNCTION:   HrAttachHDrop()
//
//  PURPOSE:    Takes an HDROP handle and attaches the files specified by the
//              HDROP to the specified message object.
//
//  PARAMETERS:
//      <in> pAttList   - Pointer to the attachment list of the object we want
//                        to attach to.
//      <in> hDrop      - HDROP handle with the file information.
//      <in> fMakeLinks - TRUE if the caller wants us to create shortcuts.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT HrAttachHDrop(HWND hwnd, IMimeMessage *pMessage, HDROP hDrop, BOOL fMakeLinks)
{
    HRESULT     hr = S_OK;
    WCHAR       szFile[MAX_PATH];
    UINT        cFiles;
    BOOL        fFirstDirectory = TRUE;
    HCURSOR     hCursor;
    int         id;
    
    // This might take a bit of time
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // Walk through the drop information
    cFiles = DragQueryFileWrapW(hDrop, (UINT) -1, NULL, 0);
    for (UINT i = 0; i < cFiles; i++)
    {
        // Get the name of the i'th file in the drop
        DragQueryFileWrapW(hDrop, i, szFile, ARRAYSIZE(szFile));
        
        // We don't allow the user to attach an entire directory, only link.
        if (!fMakeLinks && PathIsDirectoryW(szFile))
        {
            // Only show this error once
            if (fFirstDirectory)
            {
                id = AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
                    MAKEINTRESOURCEW(idsDropLinkDirs), 0,
                    MB_ICONEXCLAMATION | MB_YESNOCANCEL);
                if (id == IDCANCEL)
                {
                    hr = E_FAIL;
                    goto exit;
                }
                
                // If we can create a link to directories, then add one now.
                if (id == IDYES)
                    HrAddAttachment(pMessage, szFile, NULL, TRUE);
                fFirstDirectory = FALSE;
            }
            
        }
        else
            HrAddAttachment(pMessage, szFile, NULL, fMakeLinks);

    }
    
exit:
    SetCursor(hCursor);
    return (hr);
}


//
//  FUNCTION:   HrAddAttachment()
//
//  PURPOSE:    Adds a file or stream as an attachment to a message object.
//
//  PARAMETERS:
//      <in> pAttList - Attachment list for the message to add to.
//      <in> pszName  - Name of the file to attach.  This is used if pStream
//                      is NULL.
//      <in> pStream  - Stream to add to the message as an attachment.
//      <in> fLink    - TRUE if the caller wants to attach the file as a
//                      shortcut.
//
//  RETURN VALUE:
//      S_OK - The file/stream was attached OK.
//
HRESULT HrAddAttachment(IMimeMessage *pMessage, LPWSTR pszName, LPSTREAM pStream, BOOL fLink)
{
    HRESULT     hr;
    HBODY       hBody;
    IMimeBodyW *pBody = NULL;
    ULONG       cbSize = 0;
    WCHAR       szLinkPath[MAX_PATH];
    LPWSTR      pszFileNameToUse;

    *szLinkPath = 0;

    // If we need to create a link, then call off and do that
    if(fLink)
        CreateNewShortCut(pszName, szLinkPath, ARRAYSIZE(szLinkPath));

    pszFileNameToUse = *szLinkPath ? szLinkPath : pszName;
    
    // Add the attachment based on whether it's a stream or file
    if (pStream)
    {
        hr = pMessage->AttachObject(IID_IStream, (LPVOID)pStream, &hBody);
        if (FAILED(hr))
            return hr;
    }
    else
    {
        LPMIMEMESSAGEW pMsgW = NULL;
        hr = pMessage->QueryInterface(IID_IMimeMessageW, (LPVOID*)&pMsgW);

        if (SUCCEEDED(hr))
            hr = pMsgW->AttachFileW(pszFileNameToUse, NULL, &hBody);

        ReleaseObj(pMsgW);
        if (FAILED(hr))
            return hr;
    }
    
    // Set the display name...
    Assert(hBody);
    hr = pMessage->BindToObject(hBody, IID_IMimeBodyW, (LPVOID *)&pBody);
    if (FAILED(hr))
        return hr;
    
    pBody->SetDisplayNameW(pszFileNameToUse);
    pBody->Release();
    
    // Done
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\finder.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     finder.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include <process.h>
#include "resource.h"
#include "error.h"
#include "finder.h"
#include "goptions.h"
#include "menuutil.h"
#include "statbar.h"
#include "imnact.h"
#include "note.h"
#include "mailutil.h"
#include "statnery.h"
#include "instance.h"
#include "msoeobj.h"
#include "msglist.h"
#include "storutil.h"
#include "menures.h"
#include "findres.h"
#include "multiusr.h"
#include "newsutil.h"
#include "ruleutil.h"
#include "instance.h"
#include "shlwapip.h"
#include "demand.h"
#include "dllmain.h"
#include "order.h"

ASSERTDATA

#define MF_ENABLEFLAGS(b)   (MF_BYCOMMAND|(b ? MF_ENABLED : MF_GRAYED | MF_DISABLED))


typedef struct _ThreadList
{
    DWORD                   dwThreadID;
    struct _ThreadList   *  pPrev;
    struct _ThreadList   *  pNext;
} OETHREADLIST;

OETHREADLIST * g_pOEThrList = NULL;

// Add thread to list
OETHREADLIST * AddThreadToList(DWORD uiThreadId, OETHREADLIST * pThrList)
{
    if(!pThrList)
    {
        if(MemAlloc((LPVOID *) &pThrList, sizeof(OETHREADLIST)))
        {

            pThrList->pPrev = NULL;
            pThrList->pNext = NULL;
            pThrList->dwThreadID = uiThreadId;
        }
    }    
    else 
        pThrList->pNext = AddThreadToList(uiThreadId, pThrList->pNext);

    return(pThrList);
}

// Remove thread from list
OETHREADLIST * DelThreadToList(DWORD uiThreadId, OETHREADLIST * pThrList)
{
    OETHREADLIST * pLst = NULL;

    if(!pThrList)
        return(NULL);
    else if(pThrList->dwThreadID == uiThreadId)
    {
        if(pThrList->pPrev)
        {
            pThrList->pPrev->pNext = pThrList->pNext;
            pLst = pThrList->pPrev; 
        }
        if(pThrList->pNext)
        {
            pThrList->pNext->pPrev = pThrList->pPrev;
            if(!pLst)
                pLst = pThrList->pNext;
        }

        MemFree(pThrList);
        pThrList = NULL;
    }
    else 
        pThrList->pNext = DelThreadToList(uiThreadId, pThrList->pNext);

    return pLst;
}

// Close all Finder windows
void CloseAllFindWnds(HWND hwnd, OETHREADLIST * pThrList)
{
    while(pThrList)
    {
        CloseThreadWindows(hwnd, pThrList->dwThreadID);
        pThrList = pThrList->pNext;
    }
}


void CloseFinderTreads()
{
    CloseAllFindWnds(NULL, g_pOEThrList);
}

/////////////////////////////////////////////////////////////////////////////
// Thread entry point for the finder
//
unsigned int __stdcall FindThreadProc(LPVOID lpvUnused);


HRESULT CPumpRefCount::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CPumpRefCount::QueryInterface");
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *)this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


ULONG CPumpRefCount::AddRef(void)
{
    TraceCall("CPumpRefCount::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


ULONG CPumpRefCount::Release(void)
{
    TraceCall("CPumpRefCount::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}


//
//  FUNCTION:   FreeFindInfo
//
void FreeFindInfo(FINDINFO *pFindInfo)
{
    SafeMemFree(pFindInfo->pszFrom);
    SafeMemFree(pFindInfo->pszSubject);
    SafeMemFree(pFindInfo->pszTo);
    SafeMemFree(pFindInfo->pszBody);
    ZeroMemory(pFindInfo, sizeof(FINDINFO));
}

//
//  FUNCTION:   CopyFindInfo
//
HRESULT CopyFindInfo(FINDINFO *pFindSrc, FINDINFO *pFindDst)
{
    // Locals
    HRESULT     hr=S_OK;

    // Zero
    ZeroMemory(pFindDst, sizeof(FINDINFO));

    // Duplicate
    pFindDst->mask = pFindSrc->mask;
    pFindDst->ftDateFrom = pFindSrc->ftDateFrom;
    pFindDst->ftDateTo = pFindSrc->ftDateTo;
    pFindDst->fSubFolders = pFindSrc->fSubFolders;

    // pszFrom
    if (pFindSrc->pszFrom)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszFrom = PszDupA(pFindSrc->pszFrom));
    }

    // pszTo
    if (pFindSrc->pszTo)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszTo = PszDupA(pFindSrc->pszTo));
    }

    // pszSubject
    if (pFindSrc->pszSubject)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszSubject = PszDupA(pFindSrc->pszSubject));
    }

    // pszBody
    if (pFindSrc->pszBody)
    {
        // Duplicate the String
        IF_NULLEXIT(pFindDst->pszBody = PszDupA(pFindSrc->pszBody));
    }

exit:
    // Done
    return hr;
}


//
//  FUNCTION:   DoFindMsg()
//
//  PURPOSE:    Instantiates the finder object on a separate thread.
//
//  PARAMETERS: 
//      [in] pidl - Folder to default the search in
//      [in] ftType - Type of folders being searched
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT DoFindMsg(FOLDERID idFolder, FOLDERTYPE ftType)
{
    HRESULT         hr = S_OK;
    HTHREAD         hThread = NULL;
    DWORD           uiThreadId = 0;
    FINDERPARAMS *  pFindParams = NULL;
    
    // Allocate a structure to hold the initialization information that we can
    // pass to the other thread.

    IF_NULLEXIT(pFindParams = new FINDERPARAMS);

    // Initialzie the find
    pFindParams->idFolder = idFolder;
    pFindParams->ftType = ftType;
    
    // Create another thread to do the search on
    hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)FindThreadProc, (LPVOID) pFindParams, 0, &uiThreadId);
    if (NULL == hThread)
        IF_FAILEXIT(hr = E_FAIL);

    // NULL this out so we don't free it later.  The other thread owns freeing 
    // this.
    pFindParams = NULL;        
    hr = S_OK;
    
exit:
    // Close the thread handle
    if (NULL != hThread)
        CloseHandle(hThread);

    // Free the find parameters if we still have a pointer to them.
    if (NULL != pFindParams)
        delete pFindParams;
    return hr;
}


unsigned int __stdcall LOADDS_16 FindThreadProc(LPVOID lpv)
{
    CFindDlg       *pFindDlg = NULL;
    MSG             msg;
    FINDERPARAMS   *pFindParams = (FINDERPARAMS *) lpv;
    DWORD uiThreadId = 0;

    // Make sure this new thread has all the initialization performed 
    // correctly.
    OleInitialize(0);
    CoIncrementInit("FindThreadProc", MSOEAPI_START_SHOWERRORS, NULL, NULL);

    EnterCriticalSection(&g_csThreadList);

    uiThreadId = GetCurrentThreadId();
    g_pOEThrList = AddThreadToList(uiThreadId, g_pOEThrList );

    LeaveCriticalSection(&g_csThreadList);

    // Create the finder
    pFindDlg = new CFindDlg();
    if (pFindDlg)
    {
        // Show the find dialog.  This function will return when the user is
        // done.
        pFindDlg->Show(pFindParams);

        // Message Loop 
        while (GetMessageWrapW(&msg, NULL, 0, 0))
            pFindDlg->HandleMessage(&msg);

        pFindDlg->Release();
    }    

    // Free this information
    if (NULL != pFindParams)
        delete pFindParams;

    // Uninitialize the thread
    EnterCriticalSection(&g_csThreadList);

    g_pOEThrList = DelThreadToList(uiThreadId, g_pOEThrList);

    LeaveCriticalSection(&g_csThreadList);

    CoDecrementInit("FindThreadProc", NULL);
    OleUninitialize();
    return 0;
}


CFindDlg::CFindDlg()
{    
    m_cRef = 1;
    m_hwnd = NULL;
    ZeroMemory(&m_rFindInfo, sizeof(m_rFindInfo));
    m_hwndList = NULL;
    m_hTimeout = NULL;
    m_hAccel = NULL;

    m_pStatusBar = NULL;
    m_pMsgList = NULL;
    m_pMsgListCT = NULL;
    m_pCancel = NULL;
    m_pPumpRefCount = NULL;
    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));

    m_fShowResults = FALSE;
    m_fAbort = FALSE;
    m_fClose = FALSE;
    m_fInProgress = FALSE;
    m_ulPct = 0;
    m_fFindComplete = FALSE;

    m_hIcon = NULL;
    m_hIconSm = NULL;

    m_dwCookie = 0;
    m_fProgressBar = FALSE;
    m_fInternal = 0;
    m_dwIdentCookie = 0;

    m_pViewMenu = NULL;
}


CFindDlg::~CFindDlg()
{
    SafeRelease(m_pViewMenu);
    _FreeFindInfo(&m_rFindInfo);
    SafeRelease(m_pStatusBar);
    SafeRelease(m_pMsgList);
    SafeRelease(m_pMsgListCT);
    SafeRelease(m_pCancel);
    AssertSz(!m_pPumpRefCount, "This should have been freed");

    if (m_hIcon)
        SideAssert(DestroyIcon(m_hIcon));

    if (m_hIconSm)
        SideAssert(DestroyIcon(m_hIconSm));

    CallbackCloseTimeout(&m_hTimeout);
}


//
//  FUNCTION:   CFindDlg::QueryInterface()
//
//  PURPOSE:    Allows caller to retrieve the various interfaces supported by 
//              this class.
//
HRESULT CFindDlg::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    TraceCall("CFindDlg::QueryInterface");
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (LPVOID) (IUnknown *) (IDispatch *) this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, DIID__MessageListEvents))
        *ppvObj = (LPVOID) (IDispatch *) this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (LPVOID) (IStoreCallback *) this;
    else if (IsEqualIID(riid, IID_ITimeoutCallback))
        *ppvObj = (LPVOID) (ITimeoutCallback *) this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *ppvObj = (LPVOID) (IIdentityChangeNotify *) this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (LPVOID) (IOleCommandTarget *) this;

    if (*ppvObj)
    {
        AddRef();
        return (S_OK);
    }

    return (E_NOINTERFACE);
}


//
//  FUNCTION:   CFindDlg::AddRef()
//
//  PURPOSE:    Adds a reference count to this object.
//
ULONG CFindDlg::AddRef(void)
{
    TraceCall("CFindDlg::AddRef");
    return ((ULONG) InterlockedIncrement((LONG *) &m_cRef));
}


//
//  FUNCTION:   CFindDlg::Release()
//
//  PURPOSE:    Releases a reference on this object.
//
ULONG CFindDlg::Release(void)
{
    TraceCall("CFindDlg::Release");

    if (0 == InterlockedDecrement((LONG *) &m_cRef))
    {
        delete this;
        return 0;
    }

    return (m_cRef);
}



//
//  FUNCTION:   CFindDlg::Show()
//
//  PURPOSE:    Shows the finder dialog and provides a message pump for this
//              new thread.
//
void CFindDlg::Show(PFINDERPARAMS pFindParams)
{
    // Validate this
    if (NULL == pFindParams)
        return;

    // Load the acclereator table for the finder
    if (NULL == m_hAccel)
        m_hAccel = LoadAcceleratorsWrapW(g_hLocRes, MAKEINTRESOURCEW(IDA_FIND_ACCEL));

    // Create the finder dialog
    m_hwnd = CreateDialogParamWrapW(g_hLocRes, MAKEINTRESOURCEW(IDD_FIND),
                               NULL, ExtFindMsgDlgProc, (LPARAM) this);
    if (NULL == m_hwnd)
        return;

    // Create the message list
    HRESULT hr = CreateMessageList(NULL, &m_pMsgList);
    if (FAILED(hr))
        return;

    // Get some interfaces pointers from the message list that we'll need
    // later
    m_pMsgList->QueryInterface(IID_IOleCommandTarget, (LPVOID *) &m_pMsgListCT);
    AtlAdvise(m_pMsgList, (IUnknown *) (IDispatch *) this, DIID__MessageListEvents, &m_dwCookie);

    // Display the message list
    if (FAILED(m_pMsgList->CreateList(m_hwnd, (IDispatch *) this, &m_hwndList)))
        return;
    ShowWindow(m_hwndList, SW_HIDE);

    // Have the dialog redraw once or twice
    UpdateWindow(m_hwnd);

    // Fill in the folder list
    if (FAILED(InitFolderPickerEdit(GetDlgItem(m_hwnd, IDC_FOLDER), pFindParams->idFolder)))
        return;

    // Will be released in the WM_NCDESTROY message
    m_pPumpRefCount = new CPumpRefCount;
    if (!m_pPumpRefCount)
        return;
}


void CFindDlg::HandleMessage(LPMSG lpmsg)
{
    HWND hwndTimeout;

    CNote *pNote = GetTlsGlobalActiveNote();

    // Give it to the active note if a note has focus, call it's XLateAccelerator...
    if (pNote && pNote->TranslateAccelerator(lpmsg) == S_OK)
        return;

    if (pNote && (pNote->IsMenuMessage(lpmsg) == S_OK))
        return;

    // Get Timeout Window for this thread
    hwndTimeout = (HWND)TlsGetValue(g_dwTlsTimeout);

    // Check for Is modeless timeout dialog window message
    if (hwndTimeout && TRUE == IsDialogMessageWrapW(hwndTimeout, lpmsg))
        return;

    if (m_hwnd)
    {
        // We have to do a little voodoo to get some keystrokes down to the 
        // message list before IsDialogMessage() get's 'em
        if (lpmsg->message == WM_KEYDOWN)
        {
            if ((lpmsg->wParam == VK_DELETE) && m_pMsgList && (S_OK != m_pMsgList->HasFocus()))
            {
                if (!IsDialogMessageWrapW(m_hwnd, lpmsg))
                {
                    TranslateMessage(lpmsg);
                    DispatchMessageWrapW(lpmsg);
                }
                return;
            }
            if ((lpmsg->wParam == VK_RETURN) && m_pMsgList && (S_OK == m_pMsgList->HasFocus()))
            {
                if (!TranslateAcceleratorWrapW(m_hwnd, m_hAccel, lpmsg))
                {
                    TranslateMessage(lpmsg);
                    DispatchMessageWrapW(lpmsg);
                }
        
                return;
            }
        }

        if (m_hAccel && TranslateAcceleratorWrapW(m_hwnd, m_hAccel, lpmsg))
            return; 
        
        if (IsDialogMessageWrapW(m_hwnd, lpmsg))
            return;
    }

    TranslateMessage(lpmsg);
    DispatchMessageWrapW(lpmsg);
}



//
//  FUNCTION:   CFindDlg::Invoke()
//
//  PURPOSE:    Called by the message list to pass us progress and other 
//              status / error messages.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                         WORD wFlags, DISPPARAMS* pDispParams, 
                         VARIANT* pVarResult, EXCEPINFO* pExcepInfo, 
                         unsigned int* puArgErr)
{
    switch (dispIdMember)
    {
        // Fired whenever the selection in the ListView changes
        case DISPID_LISTEVENT_SELECTIONCHANGED:
        {
            break;
        }

        // Fired when the number of messages or unread messages changes
        case DISPID_LISTEVENT_COUNTCHANGED:
        {
            if (!m_fProgressBar && m_pStatusBar)
            {
                TCHAR szStatus[CCHMAX_STRINGRES + 20];
                TCHAR szFmt[CCHMAX_STRINGRES];
                DWORD ids;

                if (m_fFindComplete)
                {
                    AthLoadString(idsXMsgsYUnreadFind, szFmt, ARRAYSIZE(szFmt));
                    wsprintf(szStatus, szFmt, pDispParams->rgvarg[0].lVal, pDispParams->rgvarg[1].lVal);
                }
                else
                {
                    AthLoadString(idsXMsgsYUnread, szFmt, ARRAYSIZE(szFmt));
                    wsprintf(szStatus, szFmt, pDispParams->rgvarg[0].lVal, pDispParams->rgvarg[1].lVal);
                }

                m_pStatusBar->SetStatusText(szStatus);
            }
            break;
        }

        // Fired when the user double clicks an item in the ListView
        case DISPID_LISTEVENT_ITEMACTIVATE:
        {
            CmdOpen(ID_OPEN, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            break;
        }
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::QueryStatus()
//
//  PURPOSE:    Called by the browser to determine if a list of commands should
//              should be enabled or disabled.
//
//  PARAMETERS: 
//      [in] pguidCmdGroup - Group the commands are part of (unused)
//      [in] cCmds - Number of commands to be evaluated
//      [in] prgCmds - List of commands
//      [out] pCmdText - Description text for a command
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                              OLECMDTEXT *pCmdText) 
{
    DWORD   cSel;
    HRESULT hr;
    DWORD  *rgSelected = 0;
    DWORD   cFocus;

    MenuUtil_NewMessageIDsQueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText, TRUE);

    // Up front some work
    m_pMsgList->GetSelected(&cFocus, &cSel, &rgSelected);

    // Now loop through the commands in the prgCmds array looking for ones the 
    // sub objects didn't handle.
    for (UINT i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            // If this command is from the language menu
            if (prgCmds[i].cmdID >= ID_LANG_FIRST && prgCmds[i].cmdID <= ID_LANG_LAST)
            {
                // Enable only the supported languages
                if (prgCmds[i].cmdID < (UINT) (ID_LANG_FIRST + GetIntlCharsetLanguageCount()))
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                else
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                continue;
            }

            // if the command id from the View.Current View menu
            if ((ID_VIEW_FILTER_FIRST <= prgCmds[i].cmdID) && (ID_VIEW_FILTER_LAST >= prgCmds[i].cmdID))
            {
                if (NULL == m_pViewMenu)
                {
                    // Create the view menu
                    HrCreateViewMenu(VMF_FINDER, &m_pViewMenu);
                }
            
                if (NULL != m_pViewMenu)
                {
                    m_pViewMenu->QueryStatus(m_pMsgList, &(prgCmds[i]));
                }

                continue;
            }
            
            // Look to see if it's a command we provide
            switch (prgCmds[i].cmdID)
            {
                case ID_OPEN:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    m_pMsgList->GetSelectedCount(&cSel);
                    if (cSel)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_OPEN_CONTAINING_FOLDER:
                {
                    if (cSel == 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_REPLY:
                case ID_REPLY_ALL:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (pInfo->dwFlags & ARF_HASBODY)
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }

                    break;
                }

                case ID_FORWARD:
                case ID_FORWARD_AS_ATTACH:
                {
                    // Enabled only if the focus is in the ListView and there
                    // is only one item selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel > 0)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        // Default to success
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                        for (DWORD iItem = 0; iItem < cSel && (prgCmds[i].cmdf & OLECMDF_ENABLED); iItem++)
                        {
                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[iItem], &pInfo)))
                            {
                                if (0 == (pInfo->dwFlags & ARF_HASBODY))
                                {
                                    prgCmds[i].cmdf &= ~OLECMDF_ENABLED;
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }

                    break;
                }

                case ID_REPLY_GROUP:
                {
                    // Enabled only if there is one news message selected
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if ((pInfo->dwFlags & ARF_HASBODY) && (pInfo->dwFlags & ARF_NEWSMSG))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }

                case ID_POPUP_FILTER:
                case ID_COLUMNS:
                case ID_POPUP_NEXT:
                case ID_POPUP_SORT:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | (m_fShowResults ? OLECMDF_ENABLED : 0);
                    break;
                }

                case ID_POPUP_NEW:
                case ID_CLOSE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
                }

                case ID_REFRESH:
                {
                    if (m_fShowResults && IsWindowEnabled(GetDlgItem(m_hwnd, IDC_FIND_NOW)))
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_BLOCK_SENDER:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected and
                    // we have access to the from address
                    if (cSel == 1)
                    {
                        // The message's body must also be downloaded
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            if (((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0])) || (0 != pInfo->faStream))
                                prgCmds[i].cmdf |= OLECMDF_ENABLED;

                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                } 
                
                case ID_CREATE_RULE_FROM_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    // Enabled only if there is only one item selected
                    if (cSel == 1)
                    {
                        // Make sure we have a message info
                        LPMESSAGEINFO pInfo;

                        if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                        {
                            prgCmds[i].cmdf |= OLECMDF_ENABLED;
                            
                            m_pMsgList->FreeMessageInfo(pInfo);
                        }
                    }
                    break;
                }

                case ID_COMBINE_AND_DECODE:
                {
                    // Enabled only if the focus is in the ListView and there 
                    // is at least one item selected.
                    if (cSel > 1)
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;
                }

                case ID_CANCEL_MESSAGE:
                {
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED;

                    if (DwGetOption(OPT_CANCEL_ALL_NEWS))
                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                    else
                    {
                        if (cSel == 1)
                        {
                            FOLDERID idFolder;
                            LPMESSAGEINFO pInfo;

                            if (SUCCEEDED(m_pMsgList->GetMessageInfo(rgSelected[0], &pInfo)))
                            {
                                if (SUCCEEDED(m_pMsgList->GetRowFolderId(rgSelected[0], &idFolder)))
                                {
                                    if (NewsUtil_FCanCancel(idFolder, pInfo))
                                    {
                                        prgCmds[i].cmdf |= OLECMDF_ENABLED;
                                    }
                                }

                                m_pMsgList->FreeMessageInfo(pInfo);
                            }
                        }
                    }
                    break;
                }
            }
        }
    }

    MemFree(rgSelected);

    // Let the sub objects look last, so we can get ID_REFRESH before them
    if (m_pMsgListCT)
    {
        hr = m_pMsgListCT->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }

    return (S_OK);
}


//
//  FUNCTION:   CMessageView::Exec()
//
//  PURPOSE:    Called to execute a verb that this view supports
//
//  PARAMETERS: 
//      [in]  pguidCmdGroup - unused
//      [in]  nCmdID - ID of the command to execute
//      [in]  nCmdExecOpt - Options that define how the command should execute
//      [in]  pvaIn - Any arguments for the command
//      [out] pvaOut - Any return values for the command
//
//  RETURN VALUE:
//       
//
HRESULT CFindDlg::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                       VARIANTARG *pvaIn, VARIANTARG *pvaOut) 
{
    // If the sub objects didn't support the command, then we should see if
    // it's one of ours

    // Language menu first
    if (nCmdID >= ID_LANG_FIRST && nCmdID <= ID_LANG_LAST)
    {
        // $REVIEW - Not implemented
        // SwitchLanguage(nCmdID, TRUE);
        return (S_OK);
    }

    // Handle the View.Current View menu
    if ((ID_VIEW_FILTER_FIRST <= nCmdID) && (ID_VIEW_FILTER_LAST >= nCmdID))
    {
        if (NULL == m_pViewMenu)
        {
            // Create the view menu
            HrCreateViewMenu(VMF_FINDER, &m_pViewMenu);
        }
        
        if (NULL != m_pViewMenu)
        {
            if (SUCCEEDED(m_pViewMenu->Exec(m_hwnd, nCmdID, m_pMsgList, pvaIn, pvaOut)))
            {
                return (S_OK);
            }
        }
    }
    
    if (MenuUtil_HandleNewMessageIDs(nCmdID, m_hwnd, FOLDERID_INVALID, TRUE, FALSE, (IUnknown *) (IDispatch *) this))
        return S_OK;


    // Go through the rest of the commands
    switch (nCmdID)
    {
        case ID_OPEN:
            return CmdOpen(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_OPEN_CONTAINING_FOLDER:
            return CmdOpenFolder(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_REPLY:
        case ID_REPLY_ALL:
        case ID_FORWARD:
        case ID_FORWARD_AS_ATTACH:
        case ID_REPLY_GROUP:
            return CmdReplyForward(nCmdID, nCmdExecOpt, pvaIn, pvaOut);    
            
        case ID_REFRESH:
        case IDC_FIND_NOW:
            return CmdFindNow(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case IDC_STOP:
            return CmdStop(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case IDC_BROWSE_FOLDER:
            return CmdBrowseForFolder(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case IDC_RESET:
            return CmdReset(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_BLOCK_SENDER:
            return CmdBlockSender(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_CREATE_RULE_FROM_MESSAGE:
            return CmdCreateRule(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_COMBINE_AND_DECODE:
            return CmdCombineAndDecode(nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        case ID_CLOSE:
        case IDCANCEL:
        {
            if (m_fInProgress)
            {
                CmdStop(ID_STOP, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                m_fClose = TRUE;
            }
            else
            {
                DestroyWindow(m_hwnd);
            }
            return (S_OK);
        }

        case ID_CANCEL_MESSAGE:
            return CmdCancelMessage(nCmdID, nCmdExecOpt, pvaIn, pvaOut);
    }

    // See if our message list wants the command
    if (m_pMsgListCT)
    {
        if (OLECMDERR_E_NOTSUPPORTED != m_pMsgListCT->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut))
            return (S_OK);
    }
    
    return (OLECMDERR_E_NOTSUPPORTED);
}


//
//  FUNCTION:   CFindDlg::OnBegin()
//
//  PURPOSE:    Called whenever the store is about to start some operation.
//
HRESULT CFindDlg::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, 
                          IOperationCancel *pCancel)
{
    TraceCall("CFindDlg::OnBegin");

    Assert(pCancel != NULL);
    Assert(m_pCancel == NULL);
    
    m_pCancel = pCancel;
    m_pCancel->AddRef();

    if (m_fAbort)
        m_pCancel->Cancel(CT_CANCEL);

    return(S_OK);
}


//
//  FUNCTION:   CFindDlg::OnProgress()
//
//  PURPOSE:    Called during the find, download, etc.
//
HRESULT CFindDlg::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, 
                             DWORD dwMax, LPCSTR pszStatus)
{
    MSG msg;

    TraceCall("CFindDlg::OnProgress");

    // If we had a timeout dialog up, we can close it since data just became
    // available.
    CallbackCloseTimeout(&m_hTimeout);

    // If it's find, show progress
    if (SOT_SEARCHING == tyOperation)
    {
        if (m_pStatusBar && pszStatus)
        {
            TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
            AthLoadString(idsSearching, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, pszStatus);
            m_pStatusBar->SetStatusText((LPTSTR) szBuf);
        }

        if (!m_fProgressBar && m_pStatusBar)
        {
            m_pStatusBar->ShowProgress(dwMax);
            m_fProgressBar = TRUE;
        }

        if (m_pStatusBar && dwMax)
        {
            m_pStatusBar->SetProgress(dwCurrent);
        }
    }

    // Pump messages a bit so the UI is responsive.
    while (PeekMessageWrapW(&msg, NULL, 0, 0, PM_REMOVE))
        HandleMessage(&msg);

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::OnComplete()
//
//  PURPOSE:    Called when the store operation is complete
//
HRESULT CFindDlg::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo) 
{
    TraceCall("CFindDlg::OnComplete");

    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Display an Error on Failures
    if (FAILED(hrComplete))
    {
        // Call into my swanky utility
        CallbackDisplayError(m_hwnd, hrComplete, pErrorInfo);
    }

    if (SOT_SEARCHING == tyOperation)
    {
        // Hide the status bar
        if (m_fProgressBar && m_pStatusBar)
        {
            m_pStatusBar->HideProgress();
            m_fProgressBar = FALSE;
            m_fFindComplete = TRUE;
        }

        Assert(m_pCancel != NULL);
        m_pCancel->Release();
        m_pCancel = NULL;
    }

    // Update the status text
    IOEMessageList *pList;
    if (SUCCEEDED(m_pMsgList->QueryInterface(IID_IOEMessageList, (LPVOID *) &pList)))
    {
        long  lCount, lUnread;
        TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];

        pList->get_Count(&lCount);
        pList->get_UnreadCount(&lUnread);
        AthLoadString(idsXMsgsYUnreadFind, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuf, szRes, lCount, lUnread);
        m_pStatusBar->SetStatusText(szBuf);

        pList->Release();
    }

    // Select the first row
    IListSelector *pSelect;
    if (SUCCEEDED(m_pMsgList->GetListSelector(&pSelect)))
    {
        pSelect->SetActiveRow(0);
        pSelect->Release();
    }

    return(S_OK); 
}


STDMETHODIMP CFindDlg::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{ 
    // Display a timeout dialog
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

STDMETHODIMP CFindDlg::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{ 
    // Call into general CanConnect Utility
    return CallbackCanConnect(pszAccountId, m_hwnd, FALSE);
}

STDMETHODIMP CFindDlg::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType) 
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into general OnLogonPrompt Utility
    return CallbackOnLogonPrompt(m_hwnd, pServer, ixpServerType);
}

STDMETHODIMP CFindDlg::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{ 
    // Close any timeout dialog, if present
    CallbackCloseTimeout(&m_hTimeout);

    // Call into my swanky utility
    return CallbackOnPrompt(m_hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

STDMETHODIMP CFindDlg::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{ 
    *phwndParent = m_hwnd;
    return(S_OK);
}

STDMETHODIMP CFindDlg::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Call into general timeout response utility
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}


INT_PTR CALLBACK CFindDlg::ExtFindMsgDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CFindDlg *pThis;

    if (msg == WM_INITDIALOG)
        {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pThis = (CFindDlg*)lParam;
        }
    else
        pThis = (CFindDlg*)GetWindowLongPtr(hwnd, DWLP_USER);

    if (pThis)
        return pThis->DlgProc(hwnd, msg, wParam, lParam);
    return FALSE;
}


//
//  FUNCTION:   CFindDlg::DlgProc()
//
//  PURPOSE:    Groovy dialog proc.
//
INT_PTR CFindDlg::DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndActive;

    switch (msg)
    {
        case WM_INITDIALOG:
            return (BOOL)HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, OnInitDialog);
        
        case WM_PAINT:
            HANDLE_WM_PAINT(hwnd, wParam, lParam, OnPaint);
            return TRUE;

        case WM_SIZE:
            HANDLE_WM_SIZE(hwnd, wParam, lParam, OnSize);
            return TRUE;
        
        case WM_GETMINMAXINFO:
            HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, OnGetMinMaxInfo);
            return TRUE;
        
        case WM_INITMENUPOPUP:
            HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, OnInitMenuPopup);
            return TRUE;

        case WM_MENUSELECT:
            // HANDLE_WM_MENUSELECT() has a bug in it, don't use it.
            if (LOWORD(wParam) >= ID_STATIONERY_RECENT_0 && LOWORD(wParam) <= ID_STATIONERY_RECENT_9)
                m_pStatusBar->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
            else
                HandleMenuSelect(m_pStatusBar, wParam, lParam);
            return TRUE;
        
        case WM_WININICHANGE:
            HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, OnWinIniChange);
            return TRUE;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, OnCommand);
            return TRUE;
        
        case WM_NOTIFY:
            HANDLE_WM_NOTIFY(hwnd, wParam, lParam, OnNotify);
            return TRUE;

        case WM_DESTROY:
        // case WM_CLOSE:
            HANDLE_WM_DESTROY(hwnd, wParam, lParam, OnDestroy);
            return TRUE;
        
        case WM_NCDESTROY:
            m_pPumpRefCount->Release();
            m_pPumpRefCount = NULL;
            m_hwnd = 0;
            break;

        case WM_ENABLE:
            if (!m_fInternal)
            {
                Assert (wParam || (m_hlDisabled.cHwnd == NULL && m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&m_hlDisabled, (NULL != wParam), ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd && 
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case WM_OE_ENABLETHREADWINDOW:
            m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            m_fInternal = 0;
            break;

    }
    return FALSE;
}


//
//  FUNCTION:   CFindDlg::OnInitDialog()
//
//  PURPOSE:    Initializes the UI in the dialog box.  Also prep's the sizing 
//              info so the dialog can be resized.
//
BOOL CFindDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    RECT            rc, rcClient;
    RECT            rcEdit;
    WINDOWPLACEMENT wp;
    HMENU           hMenu;

    TraceCall("CFindDlg::OnInitDialog");

    // We do this so we can enable and disable correctly when modal windows
    // are visible
    SetProp(hwnd, c_szOETopLevel, (HANDLE)TRUE);

    // Get some sizing info
    _InitSizingInfo(hwnd);

    // Hide the status bar until we've been expanded
    ShowWindow(GetDlgItem(hwnd, IDC_STATUS_BAR), SW_HIDE);

    // Set the title bar icon
    Assert (m_hIconSm == NULL && m_hIcon == NULL);
    m_hIcon = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiFind), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)m_hIcon);
    m_hIconSm = (HICON)LoadImage(g_hLocRes, MAKEINTRESOURCE(idiFind), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)m_hIconSm);

    // Set the dialog template fonts correctly
    _SetFindIntlFont(hwnd);

    // Initialize the find information
    _SetFindValues(hwnd, &m_rFindInfo);

    // Disable the find and stop buttons 
    EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), _IsFindEnabled(hwnd));
    EnableWindow(GetDlgItem(hwnd, IDC_STOP), FALSE);
    CheckDlgButton(hwnd, IDC_INCLUDE_SUB, BST_CHECKED);

    // Create a status bar object for our status bar
    m_pStatusBar = new CStatusBar();
    if (m_pStatusBar)
        m_pStatusBar->Initialize(hwnd, SBI_HIDE_SPOOLER | SBI_HIDE_CONNECTED | SBI_HIDE_FILTERED);

    // We have menus on this window
    hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_FIND_MENU));
    MenuUtil_ReplaceNewMsgMenus(hMenu);
    SetMenu(hwnd, hMenu);

    // Register with identity manager
    if (m_dwIdentCookie == 0)
        SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(IAthenaBrowser *)this, &m_dwIdentCookie)));

    SetForegroundWindow(hwnd);

    return TRUE;
}


//
//  FUNCTION:   CFindDlg::OnSize()
//
//  PURPOSE:    When the dialog get's sized, we have to move a whole bunch 
//              of stuff around.  Don't try this at home.
//
void CFindDlg::OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    HDWP hdwp;
    HWND hwndStatus;
    HWND hwndTo;
    int  dx;

    // If we're minimized, don't do anything
    if (state == SIZE_MINIMIZED)
        return;

    // This is the delta for our horizontal size.
    dx = cx - m_cxDlgDef;

    // Make sure the status bar get's updated 
    hwndStatus = GetDlgItem(hwnd, IDC_STATUS_BAR);
    SendMessage(hwndStatus, WM_SIZE, 0, 0L);

    if (m_pStatusBar)
        m_pStatusBar->OnSize(cx, cy);    

    // Do all the sizing updates at once to make everything smoother
    hdwp = BeginDeferWindowPos(15);
    if (hdwp)
    {
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_FOLDER),        NULL, 0, 0, (dx + m_cxFolder), m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_INCLUDE_SUB),   NULL, m_xIncSub + dx, m_yIncSub, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_BROWSE_FOLDER), NULL, m_xBtn + dx, m_yBrowse, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, idcStatic1),        NULL, 0, 0, m_cxStatic + dx, 2, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_FIND_NOW),      NULL, m_xBtn + dx, m_yBtn, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_STOP),          NULL, m_xBtn + dx, m_yBtn + m_dyBtn, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_RESET),         NULL, m_xBtn + dx, m_yBtn + 2 * m_dyBtn, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_FROM),          NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_TO),            NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_SUBJECT),       NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        DeferWindowPos(hdwp, GetDlgItem(hwnd, IDC_BODY),          NULL, 0, 0, m_cxEdit + dx, m_cyEdit, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
        // ALERT:
        // if you add more controls here be sure to UP the value passed
        // to BeginDeferWindowPos otherwise user will REALLOC and passback
        // a new value to hdwp
        EndDeferWindowPos(hdwp);
    }
    // If the bottom is exposed (oh my) resize the message list to fit between the 
    // bottom of the dialog and the top of the status bar.
    if (m_fShowResults)
    {
        RECT rcStatus;
        GetClientRect(hwndStatus, &rcStatus);
        MapWindowRect(hwndStatus, hwnd, &rcStatus);

        rcStatus.bottom = rcStatus.top - m_yView;
        rcStatus.top = m_yView;
        rcStatus.right -= rcStatus.left;
        m_pMsgList->SetRect(rcStatus);
    }
}


//
//  FUNCTION:   CFindDlg::OnPaint()
//
//  PURPOSE:    All this just to paint a separator line between the menu bar
//              and the rest of the menu.
//
void CFindDlg::OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;
    RECT        rc;

    // If we're not minimized
    if (!IsIconic(hwnd))
    {
        // Draw that lovely line
        BeginPaint(hwnd, &ps);
        GetClientRect(hwnd, &rc);
        DrawEdge(ps.hdc, &rc, EDGE_ETCHED, BF_TOP);
        EndPaint(hwnd, &ps);
    }
}


//
//  FUNCTION:   CFindDlg::OnGetMinMaxInfo()
//
//  PURPOSE:    Called by Windows when we're resizing to see what our minimum 
//              and maximum sizes are.
//
void CFindDlg::OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi)
{
    TraceCall("CFindDlg::OnGetMinMaxInfo");

    // Let Window's do most of the work
    DefWindowProcWrapW(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)lpmmi);

    // Override the minimum track size to be the size or our template
    lpmmi->ptMinTrackSize = m_ptDragMin;

    // Make sure to adjust for the height of the message list
    if (!m_fShowResults)
        lpmmi->ptMaxTrackSize.y = m_ptDragMin.y;
}


//
//  FUNCTION:   CFindDlg::OnInitMenuPopup()
//
//  PURPOSE:    Called before the menus are displayed.
//
void CFindDlg::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu)
{
    MENUITEMINFO    mii;
    UINT            uIDPopup;
    HMENU           hMenu = GetMenu(hwnd);

    TraceCall("CFindDlg::OnInitMenuPopup");

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;

    // make sure we recognize the popup as one of ours
    if (hMenu == NULL || !GetMenuItemInfo(hMenu, uPos, TRUE, &mii) || (hmenuPopup != mii.hSubMenu))
    {
        HMENU   hMenuDrop = NULL;
        int     ulIndex = 0;
        int     cMenus = 0;

        cMenus = GetMenuItemCount(hMenu);
        
        // Try to fix up the top level popups
        for (ulIndex = 0; ulIndex < cMenus; ulIndex++)
        {
            // Get the drop down menu
            hMenuDrop = GetSubMenu(hMenu, ulIndex);
            if (NULL == hMenuDrop)
            {
                continue;
            }
            
            // Initialize the menu info
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID | MIIM_SUBMENU;

            if (FALSE == GetMenuItemInfo(hMenuDrop, uPos, TRUE, &mii))
            {
                continue;
            }

            if (hmenuPopup == mii.hSubMenu)
            {
                break;
            }
        }

        // Did we find anything?
        if (ulIndex >= cMenus)
        {
            goto exit;
        }
    }

    uIDPopup = mii.wID;

    // Must have stationery
    switch (uIDPopup)
    {
        case ID_POPUP_MESSAGE:
            AddStationeryMenu(hmenuPopup, ID_POPUP_NEW_MSG, ID_STATIONERY_RECENT_0, ID_STATIONERY_MORE);
            break;
            
        case ID_POPUP_FILE:
            DeleteMenu(hmenuPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND);
            break;

        case ID_POPUP_VIEW:
            if (NULL == m_pViewMenu)
            {
                // Create the view menu
                HrCreateViewMenu(VMF_FINDER, &m_pViewMenu);
            }
            
            if (NULL != m_pViewMenu)
            {
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU;
                
                if (FALSE == GetMenuItemInfo(hmenuPopup, ID_POPUP_FILTER, FALSE, &mii))
                {
                    break;
                }
                
                // Remove the old filter submenu
                if(IsMenu(mii.hSubMenu))
                    DestroyMenu(mii.hSubMenu);

                // Replace the view menu
                if (FAILED(m_pViewMenu->HrReplaceMenu(0, hmenuPopup)))
                {
                    break;
                }
            }
            break;
        
        case ID_POPUP_FILTER:
            if (NULL != m_pViewMenu)
            {
                m_pViewMenu->UpdateViewMenu(0, hmenuPopup, m_pMsgList);
            }
            break;
    }
    
    // Let the message list initialize it
    if (m_pMsgList)
        m_pMsgList->OnPopupMenu(hmenuPopup, uIDPopup);

    // now enable/disable the items
    MenuUtil_EnablePopupMenu(hmenuPopup, this);
    
exit:
    return;
}


//
//  FUNCTION:   CFindDlg::OnMenuSelect()
//
//  PURPOSE:    Puts the menu help text on the status bar.
//
void CFindDlg::OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags)
{
    if (m_pStatusBar)
    {
        // If this is the stationery menu, special case it
        if (item >= ID_STATIONERY_RECENT_0 && item <= ID_STATIONERY_RECENT_9)
            m_pStatusBar->ShowSimpleText(MAKEINTRESOURCE(idsRSListGeneralHelp));
        else
            HandleMenuSelect(m_pStatusBar, MAKEWPARAM(item, flags), hmenu ? (LPARAM) hmenu : (LPARAM) hmenuPopup);
    }
}


//
//  FUNCTION:   CFindDlg::OnWinIniChange()
//
//  PURPOSE:    Handles updates of fonts, colors, etc.
//
void CFindDlg::OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName)
{
    // Forward this off to our date picker controls
    FORWARD_WM_WININICHANGE(GetDlgItem(hwnd, IDC_DATE_FROM), lpszSectionName, SendMessage);
    FORWARD_WM_WININICHANGE(GetDlgItem(hwnd, IDC_DATE_TO), lpszSectionName, SendMessage);
}
       

//
//  FUNCTION:   CFindDlg::OnCommand()
//
//  PURPOSE:    Handles commands generated by the finder.
//
void CFindDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    HRESULT         hr = S_OK;

    // We need to grab some of the notifications sent to us first
    if ((codeNotify == EN_CHANGE) || 
        (codeNotify == BN_CLICKED && (id == IDC_HAS_FLAG || id == IDC_HAS_ATTACH)))
    {
        EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), _IsFindEnabled(hwnd) && !m_fInProgress);
        return;
    }

    // If this is from a menu, then first see if the message list wants
    // to handle it.
    if (NULL == hwndCtl)
    {
        // Check to see if the command is even enabled
        if (id >= ID_FIRST)
        {
            OLECMD cmd;
            cmd.cmdID = id;
            cmd.cmdf = 0;

            hr = QueryStatus(&CMDSETID_OutlookExpress, 1, &cmd, NULL);
            if (FAILED(hr) || (0 == (cmd.cmdf & OLECMDF_ENABLED)))
                return;
        }

        if (m_pMsgListCT)
        {
            hr = m_pMsgListCT->Exec(&CMDSETID_OEMessageList, id, OLECMDEXECOPT_DODEFAULT,
                                    NULL, NULL);
            if (S_OK == hr)
                return;
        }
    }

    // Otherwise, it goes to the command target
    VARIANTARG va;

    va.vt = VT_I4;
    va.lVal = codeNotify;

    hr = Exec(NULL, id, OLECMDEXECOPT_DODEFAULT, &va, NULL);
    return;
}


//
//  FUNCTION:   CFindDlg::OnNotify()
//
//  PURPOSE:    Handles notifications from the date pickers
//
LRESULT CFindDlg::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
{
    if (DTN_DATETIMECHANGE == pnmhdr->code)
        EnableWindow(GetDlgItem(hwnd, IDC_FIND_NOW), _IsFindEnabled(hwnd));

    return (0);
}


//
//  FUNCTION:   CFindDlg::OnDestroy()
//
//  PURPOSE:    Clean up the message list now that we're being shut down and
//              also save our size etc.
//
void CFindDlg::OnDestroy(HWND hwnd)
{
    WINDOWPLACEMENT wp;

    // Save the sizing information
    wp.length = sizeof(wp);
    GetWindowPlacement(hwnd, &wp);
    SetOption(OPT_FINDER_POS, (LPBYTE)&wp, sizeof(wp), NULL, 0);
    
    // Unregister with Identity manager
    if (m_dwIdentCookie != 0)
    {
        MU_UnregisterIdentityNotifier(m_dwIdentCookie);
        m_dwIdentCookie = 0;
    }

    // Clean up the property
    RemoveProp(hwnd, c_szOETopLevel);

    // Stop receieving notifications
    AtlUnadvise(m_pMsgList, DIID__MessageListEvents, m_dwCookie);

    // Tell the message list to release it's folder
    m_pMsgList->SetFolder(FOLDERID_INVALID, NULL, FALSE, NULL, NOSTORECALLBACK);

    // Close the message list
    m_pMsgList->OnClose();
}



//
//  FUNCTION:   CFindDlg::CmdOpen()
//
//  PURPOSE:    Called when the user want's to open a message that they've found.
//
HRESULT CFindDlg::CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                          VARIANTARG *pvaOut)
{
    HRESULT hr;

    TraceCall("CMessageView::CmdOpen");

    // If more than 10 messages are selected, warn the user with a "Don't show
    // me again" dialog that this could be bad.
    DWORD dwSel = 0;
    
    m_pMsgList->GetSelectedCount(&dwSel);
    if (dwSel > 10)
    {
        TCHAR szBuffer[CCHMAX_STRINGRES];
        LRESULT lResult;

        AthLoadString(idsErrOpenManyMessages, szBuffer, ARRAYSIZE(szBuffer));
        lResult = DoDontShowMeAgainDlg(m_hwnd, c_szRegManyMsgWarning, 
                                       MAKEINTRESOURCE(idsAthena), szBuffer, 
                                       MB_OKCANCEL);
        if (IDCANCEL == lResult)
            return (S_OK);
    }

    // Get the array of selected rows from the message list
    DWORD *rgRows = NULL;
    DWORD cRows = 0;

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    LPMESSAGEINFO  pInfo;
    IMessageTable *pTable = NULL;

    hr = m_pMsgList->GetMessageTable(&pTable);
    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; (i < cRows && m_pMsgList != NULL); i++)
        {
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[i], &pInfo)))
            {
                INIT_MSGSITE_STRUCT initStruct;
                DWORD dwCreateFlags;
                initStruct.initTable.pListSelect = NULL;
                m_pMsgList->GetListSelector(&initStruct.initTable.pListSelect);

                // Initialize note struct
                initStruct.dwInitType = OEMSIT_MSG_TABLE;
                initStruct.initTable.pMsgTable = pTable;
                if (FAILED(GetFolderIdFromMsgTable(pTable, &initStruct.folderID)))
                    initStruct.folderID = FOLDERID_INVALID;
                initStruct.initTable.rowIndex = rgRows[i];

                // Decide whether it is news or mail
                if (pInfo->dwFlags & ARF_NEWSMSG)
                    dwCreateFlags = OENCF_NEWSFIRST;
                else
                    dwCreateFlags = 0;

                m_pMsgList->FreeMessageInfo(pInfo);

                // Create and Open Note
                hr = CreateAndShowNote(OENA_READ, dwCreateFlags, &initStruct, m_hwnd, (IUnknown *)m_pPumpRefCount);
                ReleaseObj(initStruct.initTable.pListSelect);
                if (FAILED(hr))
                    break;
            }
        }
        pTable->Release();
    }
    MemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdOpenFolder()
//
//  PURPOSE:    Called when the user want's to open the folder that contains the
//              selected message.
//
HRESULT CFindDlg::CmdOpenFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                                VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            FOLDERID idFolder;

            // Get some information about the message
            if (g_pInstance && SUCCEEDED(hr = m_pMsgList->GetRowFolderId(dwFocused, &idFolder)))
            {
                g_pInstance->BrowseToObject(SW_SHOWNORMAL, idFolder);
            }
        }
    }

    MemFree(rgRows);
    return (S_OK);
}

//
//  FUNCTION:   CFindDlg::CmdReply()
//
//  PURPOSE:    Replies or Reply-All's to the selected message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;
    IMessageTable  *pTable = NULL;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            INIT_MSGSITE_STRUCT rInitSite;
            DWORD               dwCreateFlags;
            DWORD               dwAction = 0;

            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            if ((1 < cRows) && ((ID_FORWARD == nCmdID) || (ID_FORWARD_AS_ATTACH == nCmdID)))
            {
                IMimeMessage   *pMsgFwd = NULL;
                BOOL            fErrorsOccured = FALSE,
                                fCreateNote = TRUE;

                hr = HrCreateMessage(&pMsgFwd);
                if (FAILED(hr))
                    goto exit;
                
                rInitSite.dwInitType = OEMSIT_MSG;
                rInitSite.pMsg = pMsgFwd;
                if (FAILED(GetFolderIdFromMsgTable(pTable, &rInitSite.folderID)))
                    rInitSite.folderID = FOLDERID_INVALID;

                dwCreateFlags = 0;
                dwAction = OENA_COMPOSE;

                for (DWORD i = 0; i < cRows; i++)
                {
                    DWORD           iRow = rgRows[i];
                    IMimeMessage   *pMsg = NULL;

                    // Since this command is 
                    hr = pTable->OpenMessage(iRow, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK);
                    if (SUCCEEDED(hr))
                    {
                        if (FAILED(pMsgFwd->AttachObject(IID_IMimeMessage, (LPVOID)pMsg, NULL)))
                            fErrorsOccured = TRUE;
                        pMsg->Release();
                    }
                    else
                        fErrorsOccured = TRUE;
                }

                if (fErrorsOccured)
                {
                    if(AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthenaMail), 
                            MAKEINTRESOURCEW(idsErrorAttachingMsgsToNote), NULL, MB_OKCANCEL) == IDCANCEL)
                        fCreateNote = FALSE;
                }

                if (fCreateNote)
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd, (IUnknown *)m_pPumpRefCount);                
                pMsgFwd->Release();
            }
            else
            {
                LPMESSAGEINFO   pInfo;

                // Get some information about the message
                if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
                {
                    // Determine if this is a news or mail message.
                    if (pInfo->dwFlags & ARF_NEWSMSG)
                        dwCreateFlags = OENCF_NEWSFIRST;
                    else
                        dwCreateFlags = 0;

                    // Reply or forward
                    if (nCmdID == ID_FORWARD)
                        dwAction = OENA_FORWARD;
                    else if (nCmdID == ID_FORWARD_AS_ATTACH)
                        dwAction = OENA_FORWARDBYATTACH;
                    else if (nCmdID == ID_REPLY)
                        dwAction = OENA_REPLYTOAUTHOR;
                    else if (nCmdID == ID_REPLY_ALL)
                        dwAction = OENA_REPLYALL;
                    else if (nCmdID == ID_REPLY_GROUP)
                        dwAction = OENA_REPLYTONEWSGROUP;
                    else
                        AssertSz(FALSE, "Didn't ask for a valid action");

                    // Fill out the initialization information
                    rInitSite.dwInitType = OEMSIT_MSG_TABLE;
                    rInitSite.initTable.pMsgTable = pTable;
                    rInitSite.initTable.pListSelect = NULL;
                    if (FAILED(GetFolderIdFromMsgTable(pTable, &rInitSite.folderID)))
                        rInitSite.folderID = FOLDERID_INVALID;
                    rInitSite.initTable.rowIndex  = dwFocused;

                    m_pMsgList->FreeMessageInfo(pInfo);

                    // Create the note object
                    hr = CreateAndShowNote(dwAction, dwCreateFlags, &rInitSite, m_hwnd, (IUnknown *)m_pPumpRefCount);
                }
            }
        }
    }

exit:
    ReleaseObj(pTable);
    MemFree(rgRows);
    return (S_OK);
}

HRESULT CFindDlg::CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    FOLDERID        idFolder;
    DWORD           dwFocused;
    DWORD          *rgRows = NULL;
    DWORD           cRows = 0;

    if (m_pMsgList)
    {
        // Figure out which message is focused
        if (SUCCEEDED(m_pMsgList->GetSelected(&dwFocused, &cRows, &rgRows)))
        {
            IMessageTable  *pTable = NULL;
            LPMESSAGEINFO   pInfo;
            // Get the message table from the message list.  The note will need
            // this to deal with next / prev commands
            hr = m_pMsgList->GetMessageTable(&pTable);
            if (FAILED(hr))
                goto exit;

            // Get some information about the message
            if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(dwFocused, &pInfo)))
            {
                if (SUCCEEDED(hr = m_pMsgList->GetRowFolderId(dwFocused, &idFolder)))
                    hr = NewsUtil_HrCancelPost(m_hwnd, idFolder, pInfo);

                m_pMsgList->FreeMessageInfo(pInfo);
            }
            pTable->Release();
        }
    }

exit:
    MemFree(rgRows);
    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdFindNow()
//
//  PURPOSE:    Start's a new find.
//
HRESULT CFindDlg::CmdFindNow(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                             VARIANTARG *pvaOut)
{
    // Start by freeing our current find information if we have any
    _FreeFindInfo(&m_rFindInfo);

    // Retrieve the find values from the dialog and store them in the
    // m_rFindInfo struct.
    if (_GetFindValues(m_hwnd, &m_rFindInfo))
    {
        // Validate the data.  If the user has Date From && Date To set, make 
        // sure that to is after from.
        if ((m_rFindInfo.mask & (FIM_DATEFROM | FIM_DATETO)) == (FIM_DATEFROM | FIM_DATETO) &&
            CompareFileTime(&m_rFindInfo.ftDateTo, &m_rFindInfo.ftDateFrom) < 0)
        {
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrBadFindParams), NULL, MB_OK | MB_ICONINFORMATION);
            return (E_INVALIDARG);
        }
        
        // Case insensitive search
        if (m_rFindInfo.pszFrom)
            CharUpper(m_rFindInfo.pszFrom);
        if (m_rFindInfo.pszSubject)
            CharUpper(m_rFindInfo.pszSubject);
        if (m_rFindInfo.pszTo)
            CharUpper(m_rFindInfo.pszTo);
        if (m_rFindInfo.pszBody)
            CharUpper(m_rFindInfo.pszBody);
        
        // Show the bottom portion of the dialog
        _ShowResults(m_hwnd);

        // Start the find.
        _OnFindNow(m_hwnd);
    }
    else
    {
        // If we couldn't store the information, assume it's becuase
        // their isn't enough memory to 
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsMemory), NULL, MB_OK | MB_ICONINFORMATION);    
        DestroyWindow(m_hwnd);    
    }                    

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdBrowseForFolder()
//
//  PURPOSE:    Bring's up the folder picker dialog
//
HRESULT CFindDlg::CmdBrowseForFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, 
                                     VARIANTARG *pvaOut)
{
    FOLDERID idFolder;
    return PickFolderInEdit(m_hwnd, GetDlgItem(m_hwnd, IDC_FOLDER), 0, NULL, NULL, &idFolder);
}


//
//  FUNCTION:   CFindDlg::CmdStop()
//
//  PURPOSE:    Called when the user want's to stop a find in progress.
//
HRESULT CFindDlg::CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HWND hwndBtn;

    m_fAbort = TRUE;

    hwndBtn = GetDlgItem(m_hwnd, IDC_STOP);
    EnableWindow(hwndBtn, FALSE);
    Button_SetStyle(hwndBtn, BS_PUSHBUTTON, TRUE);

    hwndBtn = GetDlgItem(m_hwnd, IDC_FIND_NOW);
    EnableWindow(hwndBtn, _IsFindEnabled(m_hwnd));
    Button_SetStyle(hwndBtn, BS_DEFPUSHBUTTON, TRUE);

    EnableWindow(GetDlgItem(m_hwnd, IDC_RESET), TRUE);

    UpdateWindow(m_hwnd);

    if (m_pCancel != NULL)
        m_pCancel->Cancel(CT_CANCEL);

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdReset()
//
//  PURPOSE:    Called when the user want's to reset the find criteria
//
HRESULT CFindDlg::CmdReset(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    _FreeFindInfo(&m_rFindInfo);
    m_rFindInfo.mask = FIM_FROM | FIM_TO | FIM_SUBJECT | FIM_BODYTEXT;
    _SetFindValues(m_hwnd, &m_rFindInfo);
    EnableWindow(GetDlgItem(m_hwnd, IDC_FIND_NOW), _IsFindEnabled(m_hwnd));
    ((CMessageList *) m_pMsgList)->SetFolder(FOLDERID_INVALID, NULL, FALSE, NULL, NOSTORECALLBACK);
    m_fFindComplete = FALSE;
    m_pStatusBar->SetStatusText((LPTSTR) c_szEmpty);

    return (S_OK);
}


//
//  FUNCTION:   CFindDlg::CmdBlockSender()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr = S_OK;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;
    LPSTR           pszEmailFrom = NULL;
    ADDRESSPROPS    rSender = {0};
    CHAR            szRes[CCHMAX_STRINGRES];
    LPSTR           pszResult = NULL;

    TraceCall("CFindDlg::CmdBlockSender");

    IF_FAILEXIT(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows));

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    IF_FAILEXIT(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo));
    
    // Do we already have the address?
    if ((NULL != pInfo->pszEmailFrom) && ('\0' != pInfo->pszEmailFrom[0]))
    {
        pszEmailFrom = pInfo->pszEmailFrom;
    }
    else
    {
        // Load that message from the store
        IF_FAILEXIT(hr = m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage));

        if (NULL == pUnkMessage)
            IF_FAILEXIT(hr = E_FAIL);
        
        // Get the IMimeMessage interface from the message
        IF_FAILEXIT(hr = pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage));

        rSender.dwProps = IAP_EMAIL;
        IF_FAILEXIT(hr = pMessage->GetSender(&rSender));
        
        Assert(rSender.pszEmail && ISFLAGSET(rSender.dwProps, IAP_EMAIL));
        pszEmailFrom = rSender.pszEmail;
    }
    
    // Bring up the rule editor for this message
    IF_FAILEXIT(hr = RuleUtil_HrAddBlockSender((0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? RULE_TYPE_NEWS : RULE_TYPE_MAIL, pszEmailFrom));
    
    // Load the template string
    AthLoadString(idsSenderAdded, szRes, sizeof(szRes));

    // Allocate the space to hold the final string
    IF_FAILEXIT(hr = HrAlloc((VOID **) &pszResult, sizeof(*pszResult) * (lstrlen(szRes) + lstrlen(pszEmailFrom) + 1)));

    // Build up the warning string
    wsprintf(pszResult, szRes, pszEmailFrom);

    // Show the success dialog
    AthMessageBox(m_hwnd, MAKEINTRESOURCE(idsAthena), pszResult, NULL, MB_OK | MB_ICONINFORMATION);

exit:
    MemFree(pszResult);
    g_pMoleAlloc->FreeAddressProps(&rSender);
    ReleaseObj(pMessage);
    ReleaseObj(pUnkMessage);
    m_pMsgList->FreeMessageInfo(pInfo);
    MemFree(rgRows);
    if (FAILED(hr))
    {
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsAthena), 
                      MAKEINTRESOURCEW(idsSenderError), NULL, MB_OK | MB_ICONERROR);
    }
    return (hr);
}


//
//  FUNCTION:   CFindDlg::CmdCreateRule()
//
//  PURPOSE:    Add the sender of the selected messages to the block senders list
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT         hr;
    DWORD *         rgRows = NULL;
    DWORD           cRows = 0;
    LPMESSAGEINFO   pInfo = NULL;
    IUnknown *      pUnkMessage = NULL;
    IMimeMessage *  pMessage = 0;

    TraceCall("CFindDlg::CmdCreateRule");

    // Get the array of selected rows from the message list

    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
        return (hr);

    // It's possible for the message list to go away while we're doing this.  
    // To keep us from crashing, make sure you verify it still exists during 
    // the loop.

    if (SUCCEEDED(hr = m_pMsgList->GetMessageInfo(rgRows[0], &pInfo)))
    {
        // Load that message from the store
        if (S_OK == m_pMsgList->GetMessage(rgRows[0], FALSE, FALSE, &pUnkMessage))
        {
            // Get the IMimeMessage interface from the message
            if (NULL != pUnkMessage)
            {
                pUnkMessage->QueryInterface(IID_IMimeMessage, (LPVOID *) &pMessage);
            }
        }
        
        // Bring up the rule editor for this message
        hr = HrCreateRuleFromMessage(m_hwnd, (0 != (pInfo->dwFlags & ARF_NEWSMSG)) ? 
                    CRFMF_NEWS : CRFMF_MAIL, pInfo, pMessage);
    }

    ReleaseObj(pMessage);
    ReleaseObj(pUnkMessage);
    m_pMsgList->FreeMessageInfo(pInfo);
    MemFree(rgRows);

    return (S_OK);
}

//
//  FUNCTION:   CFindDlg::CmdCombineAndDecode()
//
//  PURPOSE:    Combines the selected messages into a single message.
//
//  RETURN VALUE:
//      HRESULT 
//
HRESULT CFindDlg::CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    FOLDERID           idFolder;
    DWORD             *rgRows = NULL;
    DWORD              cRows = 0;
    CCombineAndDecode *pDecode = NULL;
    HRESULT            hr;

    // Create the decoder object
    pDecode = new CCombineAndDecode();
    if (!pDecode)
        return (S_OK);

    // Get the array of selected rows from the message list
    if (FAILED(hr = m_pMsgList->GetSelected(NULL, &cRows, &rgRows)))
    {
        pDecode->Release();
        return (hr);
    }

    // Get a pointer to the message table
    IMessageTable *pTable = NULL;
    if (SUCCEEDED(m_pMsgList->GetMessageTable(&pTable)))
    {
        // Initialize the decoder
        if (SUCCEEDED(GetFolderIdFromMsgTable(pTable, &idFolder)))
            pDecode->Start(m_hwnd, pTable, rgRows, cRows, idFolder);

    }

    MemFree(rgRows);
    pDecode->Release();
    pTable->Release();

    return (S_OK);
}


void CFindDlg::_ShowResults(HWND hwnd)
{
    if (!m_fShowResults)
    {
        RECT rc;

        m_fShowResults = TRUE;

        GetWindowRect(hwnd, &rc);
        m_ptDragMin.y = (3 * m_ptDragMin.y) / 2;
 
        ShowWindow(GetDlgItem(hwnd, IDC_STATUS_BAR), SW_SHOW);
        ShowWindow(m_hwndList, SW_SHOW);

        SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left, m_cyDlgFull, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
    }
}


void CFindDlg::_OnFindNow(HWND hwnd)
{
    HWND hwndBtn;

    m_fInProgress = TRUE;

    hwndBtn = GetDlgItem(hwnd, IDC_FIND_NOW);
    EnableWindow(hwndBtn, FALSE);
    Button_SetStyle(hwndBtn, BS_PUSHBUTTON, TRUE);

    EnableWindow(GetDlgItem(hwnd, IDC_RESET), FALSE);

    hwndBtn = GetDlgItem(hwnd, IDC_STOP);
    EnableWindow(hwndBtn, TRUE);
    Button_SetStyle(hwndBtn, BS_DEFPUSHBUTTON, TRUE);

    ShowWindow(m_hwndList, SW_SHOW);
    SetFocus(m_hwndList);

    UpdateWindow(hwnd);

    m_fAbort = m_fClose = FALSE;

    _StartFind(_GetCurSel(hwnd), IsDlgButtonChecked(hwnd, IDC_INCLUDE_SUB));

    CmdStop(ID_STOP, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

    if (m_fClose)
        DestroyWindow(m_hwnd);

    m_fInProgress = FALSE;
}

FOLDERID CFindDlg::_GetCurSel(HWND hwnd)
{
    return GetFolderIdFromEdit(GetDlgItem(hwnd, IDC_FOLDER));
}

void CFindDlg::_StartFind(FOLDERID idFolder, BOOL fSubFolders)
{
    // If we're searching subfolders, then set that flag too
    m_rFindInfo.fSubFolders = fSubFolders;

    // Initialize the Message List
    ((CMessageList *)m_pMsgList)->SetFolder(idFolder, NULL, fSubFolders, &m_rFindInfo, (IStoreCallback *)this);
}


void CFindDlg::_FreeFindInfo(FINDINFO *pfi)
{
    FreeFindInfo(pfi);
}

void CFindDlg::_SetFindValues(HWND hwnd, FINDINFO *pfi)
{
    SYSTEMTIME  st;
    HWND        hwndTo;
    
    if (pfi->mask & FIM_FROM)
    {
        Assert(GetDlgItem(hwnd, IDC_FROM));
        Edit_SetText(GetDlgItem(hwnd, IDC_FROM), pfi->pszFrom);
    }
    if (pfi->mask & FIM_TO)
    {
        hwndTo = GetDlgItem(hwnd, IDC_TO);
        if (NULL != hwndTo)
        {
            Edit_SetText(hwndTo, pfi->pszTo);
        }
    }
    if (pfi->mask & FIM_SUBJECT)
    {
        Assert(GetDlgItem(hwnd, IDC_SUBJECT));
        Edit_SetText(GetDlgItem(hwnd, IDC_SUBJECT), pfi->pszSubject);
    }
    if (pfi->mask & FIM_BODYTEXT)
    {
        Assert(GetDlgItem(hwnd, IDC_BODY));
        Edit_SetText(GetDlgItem(hwnd, IDC_BODY), pfi->pszBody);
    }
    
    if (GetDlgItem(hwnd, IDC_HAS_ATTACH))
        CheckDlgButton(hwnd, IDC_HAS_ATTACH, (pfi->mask & FIM_ATTACHMENT) ? BST_CHECKED : BST_UNCHECKED);

    if (GetDlgItem(hwnd, IDC_HAS_FLAG))
        CheckDlgButton(hwnd, IDC_HAS_FLAG, (pfi->mask & FIM_FLAGGED) ? BST_CHECKED : BST_UNCHECKED);
    
    FileTimeToSystemTime(&pfi->ftDateFrom, &st);
    DateTime_SetSystemtime(GetDlgItem(hwnd, IDC_DATE_FROM), (pfi->mask & FIM_DATEFROM) ? GDT_VALID : GDT_NONE, &st);
    
    FileTimeToSystemTime(&pfi->ftDateTo, &st);
    DateTime_SetSystemtime(GetDlgItem(hwnd, IDC_DATE_TO), (pfi->mask & FIM_DATETO) ? GDT_VALID : GDT_NONE, &st);
}


BOOL CFindDlg::_GetFindValues(HWND hwnd, FINDINFO *pfi)
{
    SYSTEMTIME  st;
    
    pfi->mask = 0;
    
    if (!AllocStringFromDlg(hwnd, IDC_FROM, &pfi->pszFrom) ||
        !AllocStringFromDlg(hwnd, IDC_SUBJECT, &pfi->pszSubject) ||
        !AllocStringFromDlg(hwnd, IDC_TO, &pfi->pszTo) ||
        !AllocStringFromDlg(hwnd, IDC_BODY, &pfi->pszBody))
    {
        return FALSE;
    }
    
    if (pfi->pszFrom)
        pfi->mask |= FIM_FROM;
    if (pfi->pszSubject)
        pfi->mask |= FIM_SUBJECT;
    if (pfi->pszTo)
        pfi->mask |= FIM_TO;
    if (pfi->pszBody)
        pfi->mask |= FIM_BODYTEXT;
    
    if (IsDlgButtonChecked(hwnd, IDC_HAS_ATTACH))
        pfi->mask |= FIM_ATTACHMENT;
    
    if (IsDlgButtonChecked(hwnd, IDC_HAS_FLAG))
        pfi->mask |= FIM_FLAGGED;

    if (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_FROM), &st) != GDT_NONE)
    {
        pfi->mask |= FIM_DATEFROM;
        st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;  // start of the day
        SystemTimeToFileTime(&st, &pfi->ftDateFrom);
    }
    
    if (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_TO), &st) != GDT_NONE)
    {
        pfi->mask |= FIM_DATETO;

        // end of day
        st.wHour = 23;
        st.wMinute = 59;
        st.wSecond = 59;
        st.wMilliseconds = 999;
        SystemTimeToFileTime(&st, &pfi->ftDateTo);
    }
    
    return TRUE;
}


//
//  FUNCTION:   CFindDlg::_IsFindEnabled()
//
//  PURPOSE:    Checks to see if the "Find Now" button should be enabled.
//
BOOL CFindDlg::_IsFindEnabled(HWND hwnd)
{
    BOOL fEnable;
    SYSTEMTIME st;
    HWND hwndBody, hwndAttach, hwndTo;

    hwndBody   = GetDlgItem(hwnd, IDC_BODY);
    hwndAttach = GetDlgItem(hwnd, IDC_HAS_ATTACH);
    hwndTo     = GetDlgItem(hwnd, IDC_TO);

    // If we have content in any of these fields, we can search.
    fEnable = Edit_GetTextLength(GetDlgItem(hwnd, IDC_FROM)) ||
              Edit_GetTextLength(hwndTo) || 
              Edit_GetTextLength(GetDlgItem(hwnd, IDC_SUBJECT)) || 
              Edit_GetTextLength(hwndBody) || 
              IsDlgButtonChecked(hwnd, IDC_HAS_ATTACH) ||
              IsDlgButtonChecked(hwnd, IDC_HAS_FLAG) ||
              (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_FROM), &st) != GDT_NONE) ||
              (DateTime_GetSystemtime(GetDlgItem(hwnd, IDC_DATE_TO), &st) != GDT_NONE);

    return fEnable;
}


//
//  FUNCTION:   CFindDlg::_SetFindIntlFont()
//
//  PURPOSE:    Set's the correct international font for all edit boxes.
//
void CFindDlg::_SetFindIntlFont(HWND hwnd)
{
    HWND hwndT;

    hwndT = GetDlgItem(hwnd, IDC_FROM);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
    hwndT = GetDlgItem(hwnd, IDC_TO);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
    hwndT = GetDlgItem(hwnd, IDC_SUBJECT);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
    hwndT = GetDlgItem(hwnd, IDC_BODY);
    if (hwndT != NULL)
        SetIntlFont(hwndT);
}


//
//  FUNCTION:   CFindDlg::_InitSizingInfo()
//
//  PURPOSE:    Grabs all the sizing information we'll need later when the 
//              dialog is resized.
//
void CFindDlg::_InitSizingInfo(HWND hwnd)
{
    RECT            rc, rcClient;
    RECT            rcEdit;
    WINDOWPLACEMENT wp;

    TraceCall("CFindDlg::_InitSizingInfo");

    // Get the overall size of the default dialog template
    GetClientRect(hwnd, &rcClient);
    m_cxDlgDef = rcClient.right - rcClient.left;
    m_yView = rcClient.bottom;

    // Make room for the menu bar and save that for resizing
    AdjustWindowRect(&rcClient, GetWindowStyle(hwnd), TRUE);
    m_ptDragMin.x = rcClient.right - rcClient.left;
    m_ptDragMin.y = rcClient.bottom - rcClient.top;

    GetWindowRect(GetDlgItem(hwnd, IDC_FOLDER), &rcEdit);
    MapWindowRect(NULL, hwnd, &rcEdit);
    m_xEdit = rcEdit.left;
    m_cxFolder = rcEdit.right - rcEdit.left;

    GetWindowRect(GetDlgItem(hwnd, IDC_INCLUDE_SUB), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_xIncSub = rc.left;
    m_yIncSub = rc.top;

    GetWindowRect(GetDlgItem(hwnd, idcStatic1), &rc);
    m_cxStatic = rc.right - rc.left;

    GetWindowRect(GetDlgItem(hwnd, IDC_BROWSE_FOLDER), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_yBrowse = rc.top;
    m_dxBtnGap = rc.left - rcEdit.right;

    GetWindowRect(GetDlgItem(hwnd, IDC_FIND_NOW), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_xBtn = rc.left;
    m_dxBtn = rc.right - rc.left;
    m_yBtn = rc.top;

    GetWindowRect(GetDlgItem(hwnd, IDC_STOP), &rc);
    MapWindowRect(NULL, hwnd, &rc);
    m_dyBtn = rc.top - m_yBtn;

    GetWindowRect(GetDlgItem(hwnd, IDC_FROM), &rc);
    m_cxEdit = rc.right - rc.left;
    m_cyEdit = rc.bottom - rc.top;

    SetWindowPos(hwnd, NULL, 0, 0, rcClient.right - rcClient.left, rcClient.bottom - rcClient.top, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);

    if (sizeof(wp) == GetOption(OPT_FINDER_POS, (LPBYTE)&wp, sizeof(wp)))
    {
        if (wp.showCmd != SW_SHOWMAXIMIZED)
            wp.showCmd = SW_SHOWNORMAL;
        m_cyDlgFull = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
        SetWindowPlacement(hwnd, &wp);
    }
    else
    {
        m_cyDlgFull = (3 * m_ptDragMin.y) / 2;
        CenterDialog(hwnd);
    }
}


//
//  FUNCTION:   CFindDlg::QuerySwitchIdentities()
//
//  PURPOSE:    Determine if it is OK for the identity manager to 
//              switch identities now
//
HRESULT CFindDlg::QuerySwitchIdentities()
{
    if (!IsWindowEnabled(m_hwnd))
        return E_PROCESS_CANCELLED_SWITCH;

    return S_OK;
}


//
//  FUNCTION:   CFindDlg::SwitchIdentities()
//
//  PURPOSE:    The current identity has switched.  Close the window.
//
HRESULT CFindDlg::SwitchIdentities()
{
    if (m_fInProgress)
    {
        CmdStop(ID_STOP, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
        m_fClose = TRUE;
    }
    else
    {
        DestroyWindow(m_hwnd);
    }
    return S_OK;
}


//
//  FUNCTION:   CFindDlg::IdentityInformationChanged()
//
//  PURPOSE:    Information about the current identity has changed.
//              This is ignored.
//
HRESULT CFindDlg::IdentityInformationChanged(DWORD dwType)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\flagconv.h ===
//
//  Flag conversion routines...
//

// Bring in only once
#pragma once

DWORD DwConvertSCFStoARF(DWORD dwSCFS);
DWORD DwConvertARFtoIMAP(DWORD dwARFFlags);
DWORD DwConvertIMAPtoARF(DWORD dwIMAPFlags);
DWORD DwConvertIMAPMboxToFOLDER(DWORD dwImapMbox);
MESSAGEFLAGS ConvertIMFFlagsToARF(DWORD dwIMFFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fldbar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldbar.cpp
//
//  PURPOSE:    Implements CFolderBar
//


#include "pch.hxx"
#include <iert.h>
#include "fldbar.h"
#include "resource.h"
#include <shlwapi.h>
#include "treeview.h"
#include "ourguid.h"
#include "goptions.h"
#include "browser.h"
#include "imnglobl.h"
#include "inpobj.h"
#include "storutil.h"
#include <strconst.h>
#include "demand.h"
#include "dragdrop.h"
#include "multiusr.h"
#include "instance.h"
#include "mirror.h"
// Margins
#define CX_MARGIN_CHILDINDICATOR    4   // space between folder text and child indicator
#define CX_MARGIN_TEXT              5   // space between left edge and folder text
#define CX_MARGIN_ICON              4   // 5 space between left edge and icon
#define CX_MARGIN_ICONTEXT          5   // space between icon and view text
#define CY_MARGIN_ICON              4   // border around icon 
#define CY_MARGIN_TEXTTOP           2   // space between folder name and top edge of bar
#define CY_MARGIN_TEXTBOTTOM        2   // space between folder name and bottom edge of bar
#define CY_MARGIN                   4   // 4? margin below control
#define CX_MARGIN_RIGHTEDGE         2   // margin between the right edge of the bar and the right edge of the window
#define CX_MARGIN_FOLDERVIEWTEXT    5   // space between folder and view text
#define CXY_MARGIN_FLYOUT           4   // 4? margin around flyout scope pane

// Width/Height of child indicator bitmap
#define	CX_LARGE_CHILDINDICATOR	8
#define	CY_LARGE_CHILDINDICATOR	4
#define	CX_SMALL_CHILDINDICATOR	4
#define	CY_SMALL_CHILDINDICATOR	2

#define	CX_SMALLICON	16
#define	CY_SMALLICON	16

#define	DY_SMALLLARGE_CUTOFF	12		// folder bar is small when it takes up more than
										// DY_SMALLLARGE_CUTOFF percent of the available space

// Fly out constants
#define	FLYOUT_INCREMENT	5

// Minimum width of flyout scope pane
#define	CX_MINWIDTH_FLYOUT	200

// Mouse-Over timer ID and interval
#define	IDT_MOUSEOVERCHECK		456
#define	ELAPSE_MOUSEOVERCHECK	250

// Drag/Drop mouse-over dropdown timer ID (interval is defined by OLE)
#define IDT_DROPDOWNCHECK		457

// Drag/Drop mouse leave dropdown removal timer ID and interval
#define IDT_SCOPECLOSECHECK		458
#define ELAPSE_SCOPECLOSECHECK	500

CFolderBar::CFolderBar()
    {
    m_cRef = 1;

    m_fShow = FALSE;
    m_fRecalc = TRUE;
    m_fHighlightIndicator = FALSE;
    m_fHoverTimer = FALSE;

    m_idFolder = FOLDERID_INVALID;

    m_pSite = NULL;

    m_hwnd = NULL;
    m_hwndFrame = NULL;
    m_hwndParent = NULL;
    m_hwndScopeDropDown = NULL;

    m_hfFolderName = 0;
    m_hfViewText = 0;
    m_hIconSmall = 0;

    m_pszFolderName = NULL;
    m_cchFolderName = 0;
    m_pszViewText = NULL;
    m_cchViewText = 0;

    m_pDataObject = NULL;
    m_pDTCur = NULL;
    m_dwEffectCur = 0;
    m_grfKeyState = 0;
    }

CFolderBar::~CFolderBar()
    {
    Assert(m_cRef == 0);

    SafeRelease(m_pSite);
    SafeRelease(m_pDataObject);
    SafeRelease(m_pDTCur);
    SafeMemFree(m_pszFolderName);
    SafeMemFree(m_pszViewText);
    SafeRelease(m_pBrowser);

    if (IsWindow(m_hwndFrame))
        DestroyWindow(m_hwndFrame);

    if (m_hfFolderName)
        DeleteObject(m_hfFolderName);
    if (m_hfViewText)
        DeleteObject(m_hfViewText);
    }

HRESULT CFolderBar::HrInit(IAthenaBrowser *pBrowser)
    {
    m_pBrowser = pBrowser;

    // Don't addref this.  It creates a circular ref count with the browser.
    // m_pBrowser->AddRef();

    BOOL fInfoColumn = FALSE;
    if (SUCCEEDED(m_pBrowser->GetViewLayout(DISPID_MSGVIEW_FOLDERLIST, 0, &fInfoColumn, 0, 0)))
        m_fDropDownIndicator = !fInfoColumn;

    return (S_OK);
    }

HRESULT CFolderBar::QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, IID_IDockingWindow))
        {
        *ppvObj = (IDockingWindow *) this;
        m_cRef++;
        return (S_OK);
        }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
        {
        *ppvObj = (IObjectWithSite *)this;
        m_cRef++;
        return (S_OK);
        }
    else if (IsEqualIID(riid, IID_IDropTarget))
        {
        *ppvObj = (IDropTarget *) this;
        m_cRef++;
        return (S_OK);
        }

    *ppvObj = NULL;
    return (E_NOINTERFACE);
    }

ULONG CFolderBar::AddRef(void)
    {
    return (m_cRef++);
    }

ULONG CFolderBar::Release(void)
    {
    m_cRef--;

    if (m_cRef > 0)
        return (m_cRef);

    delete this;
    return (0);
    }

HRESULT CFolderBar::GetWindow(HWND *pHwnd)
    {
    if (m_hwnd)
        {
        *pHwnd = m_hwnd;
        return (S_OK);
        }
    else
        {
        *pHwnd = NULL;
        return (E_FAIL);
        }
    }

HRESULT CFolderBar::ContextSensitiveHelp(BOOL fEnterMode)
    {
    return (E_NOTIMPL);
    }    

//
//  FUNCTION:   CFolderBar::ShowDW()
//
//  PURPOSE:    Causes the folder bar to be either shown or hidden.
//
//  PARAMETERS:
//      <in> fShow - TRUE if the folder bar should be shown, FALSE to hide.
//
//  RETURN VALUE:
//      HRESULT 
//
#define FOLDERBARCLASS TEXT("FolderBar Window")
#define FRAMECLASS     TEXT("FolderBar Frame")
HRESULT CFolderBar::ShowDW(BOOL fShow)
    {
    HRESULT hr = S_OK;
    TCHAR   szName[CCHMAX_STRINGRES] = {0};
    DWORD dwErr;

    // If we have a site pointer, but haven't been created yet, create the window
    if (!m_hwndFrame && m_pSite)
        {
        m_hwndParent = NULL;
        hr = m_pSite->GetWindow(&m_hwndParent);

        if (SUCCEEDED(hr))
            {
            WNDCLASSEX wc = {0};

            // Check to see if we need to register the class first
            wc.cbSize = sizeof(WNDCLASSEX);
            if (!GetClassInfoEx(g_hInst, FOLDERBARCLASS, &wc))
                {
                wc.lpfnWndProc   = FolderWndProc;
                wc.hInstance     = g_hInst;
                wc.hCursor       = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
                wc.lpszClassName = FOLDERBARCLASS;

                if (!RegisterClassEx(&wc))
                {
                    dwErr = GetLastError();
                }

                wc.lpfnWndProc   = FrameWndProc;
                wc.hbrBackground = (HBRUSH) (COLOR_3DFACE + 1);
                wc.lpszClassName = FRAMECLASS;

                if (!RegisterClassEx(&wc))
                {
                    dwErr = GetLastError();
                }
            }

            m_hwndFrame = CreateWindow(FRAMECLASS, NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                                       0, 0, 1, 1, m_hwndParent, (HMENU) 0, g_hInst, (LPVOID *) this);
            if (!m_hwndFrame)
                {
                GetLastError();
                return (E_OUTOFMEMORY);
                }

            LoadString(g_hLocRes, idsFolderBar, szName, ARRAYSIZE(szName));

            m_hwnd = CreateWindow(FOLDERBARCLASS, szName, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE,
                                  0, 0, 0, 0, m_hwndFrame, (HMENU) 0, g_hInst, (LPVOID*) this);
            if (!m_hwnd)
                {
                GetLastError();
                return (E_OUTOFMEMORY);
                }
            RegisterDragDrop(m_hwnd, (IDropTarget *) this);
            }
        }

    // Set our state flags
    m_fShow = fShow;

    // Resize the folder bar based on its new hidden / visible state
    if (m_hwndFrame)
        {
        ResizeBorderDW(NULL, NULL, FALSE);
        ShowWindow(m_hwndFrame, fShow ? SW_SHOW : SW_HIDE);
        }

    return (hr);
    }


//
//  FUNCTION:   CFolderBar::CloseDW()
//
//  PURPOSE:    Destroys the folder bar.
//
HRESULT CFolderBar::CloseDW(DWORD dwReserved)
    {    
    if (m_hwndFrame)
        {
        DestroyWindow(m_hwndFrame);
        m_hwndFrame = NULL;
        m_hwnd = NULL;
        }
        
    return S_OK;
    }

//
//  FUNCTION:   CFolderBar::ResizeBorderDW()
//
//  PURPOSE:    This is called when the folder bar needs to resize.  The bar
//              in return figures out how much border space will be required 
//              from the parent frame and tells the parent to reserve that
//              space.  The bar then resizes itself to those dimensions.
//
//  PARAMETERS:
//      <in> prcBorder       - Rectangle containing the border space for the
//                             parent.
//      <in> punkToolbarSite - Pointer to the IDockingWindowSite that we are
//                             part of.
//      <in> fReserved       - Ignored.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CFolderBar::ResizeBorderDW(LPCRECT prcBorder,
                                   IUnknown* punkToolbarSite,
                                   BOOL fReserved)
    {
    RECT rcRequest = {0, 0, 0, 0};
    BOOL fFontChange;

    if (!m_pSite)
        return (E_FAIL);

    if (m_fShow)
        {
        RECT rcBorder;

        if (!prcBorder)
            {
            // Find out how big our parent's border space is
            m_pSite->GetBorderDW((IDockingWindow *) this, &rcBorder);
            prcBorder = &rcBorder;
            }

        if (m_fRecalc)
            {
            fFontChange = TRUE;
            InvalidateRect(m_hwnd, NULL, TRUE);
            }
        else
            {
            fFontChange = FALSE;
            InvalidateRect(m_hwnd, NULL, TRUE);
            }            

        // Recalc our internal sizing info
        Recalc(NULL, prcBorder, fFontChange);

        // Position ourself
        rcRequest.top = m_cyControl + CY_MARGIN;

        SetWindowPos(m_hwndFrame, NULL, prcBorder->left, prcBorder->top, prcBorder->right - prcBorder->left,
                     rcRequest.top, SWP_NOACTIVATE | SWP_NOZORDER);
        }

    m_pSite->SetBorderSpaceDW((IDockingWindow *) this, &rcRequest);
    
    return (S_OK);
    }

//
//  FUNCTION:   CFolderBar::SetSite()
//
//  PURPOSE:    Allows the owner of the coolbar to tell it what the current
//              IDockingWindowSite interface to use is.
//
//  PARAMETERS:
//      <in> punkSite - Pointer of the IUnknown to query for IDockingWindowSite.
//                      If this is NULL, we just release our current pointer.
//
//  RETURN VALUE:
//      S_OK - Everything worked
//      E_FAIL - Could not get IDockingWindowSite from the punkSite provided.
//
HRESULT CFolderBar::SetSite(IUnknown* punkSite)
    {
    // If we had a previous pointer, release it.
    if (m_pSite)
        {
        m_pSite->Release();
        m_pSite = NULL;
        }
    
    // If a new site was provided, get the IDockingWindowSite interface from it.
    if (punkSite)    
        {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, 
                                            (LPVOID*) &m_pSite)))
            {
            Assert(m_pSite);
            return E_FAIL;
            }
        }
   
    return (S_OK);    
    }    

HRESULT CFolderBar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}


//
//  FUNCTION:   CFolderBar::SetCurrentFolder()
//
//  PURPOSE:    Tells the control to display information for a different folder
//
//  PARAMETERS:
//      <in> pidl - PIDL for the new folder
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CFolderBar::SetCurrentFolder(FOLDERID idFolder)
    {
    // NOTE - This routine never fails.  It will just show everything blank
    UINT        uIndex = -1;
    TCHAR       sz[CCHMAX_STRINGRES];
    FOLDERINFO  Folder;

    // Invalidate and let the paint routine know that we're going to need to 
    // recalc 
    m_fRecalc = TRUE;
    InvalidateRect(m_hwnd, NULL, TRUE);

    // Save the Folder Id
    m_idFolder = idFolder;

    // Get Folder Info
    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return (S_OK);

    // Set Icon
    uIndex = GetFolderIcon(&Folder);

    // Clear the view text
    SetFolderText(MU_GetCurrentIdentityName());

    if ((g_dwAthenaMode & MODE_NEWSONLY) && (Folder.tyFolder == FOLDER_ROOTNODE))
    {
        //Change the name from OutLookExpress to Outlook News
        ZeroMemory(sz, sizeof(TCHAR) * CCHMAX_STRINGRES);
        LoadString(g_hLocRes, idsOutlookNewsReader, sz, ARRAYSIZE(sz));

        SetFolderName(sz);
    }
    else
    {
        // Set the folder name
        SetFolderName(Folder.pszName);
    }

    // Free the previous icons
    if (m_hIconSmall)
        {
        DestroyIcon(m_hIconSmall);
        m_hIconSmall = 0;
        }

    if (-1 != uIndex)
        {
        // Load the small icon
        HIMAGELIST himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, 
                                RGB(255, 0, 255));
        if (NULL != himl)
            {
            m_hIconSmall = ImageList_GetIcon(himl, uIndex, ILD_NORMAL);
            ImageList_Destroy(himl);
            }
        }

    // If this folder is moderated or blocked, say so
    TCHAR szRes[CCHMAX_STRINGRES];
    if (Folder.dwFlags & FOLDER_MODERATED)
    {
        AthLoadString(idsModerated, szRes, ARRAYSIZE(szRes));
        SetFolderText(szRes);
    }
    else if (Folder.dwFlags & FOLDER_BLOCKED)
    {
        AthLoadString(idsBlocked, szRes, ARRAYSIZE(szRes));
        SetFolderText(szRes);
    }

    g_pStore->FreeRecord(&Folder);

    return (S_OK);
    }


void CFolderBar::SetFolderText(LPCTSTR pszText)
    {
    // Invalidate and let the paint routine know we are going to need to
    // recalc
    m_fRecalc = TRUE;
    InvalidateRect(m_hwnd, NULL, TRUE);

    // Free an old text
    SafeMemFree(m_pszViewText);
    m_cchViewText = 0;

    if (pszText && *pszText)
        {
        m_pszViewText = PszDupA(pszText);
        m_cchViewText = lstrlen(pszText);
        }
    }


void CFolderBar::SetFolderName(LPCTSTR pszFolderName)
    {    
    // Free the old folder name
    SafeMemFree(m_pszFolderName);
    m_cchFolderName = 0;
    
    // Copy the new one
    if (pszFolderName)
        {
        m_pszFolderName = PszDupA(pszFolderName);
        m_cchFolderName = lstrlen(m_pszFolderName);
        }
    }

// Calculates the rectangle which surrounds the folder name
void CFolderBar::GetFolderNameRect(LPRECT prc)
    {
    Assert(prc);

    GetClientRect(m_hwnd, prc);
    prc->right = m_cxFolderNameRight;
    }


void CFolderBar::Recalc(HDC hDC, LPCRECT prcAvailableSpace, BOOL fSizeChange)
    {
    int         cyIcon = CY_SMALLICON,
                cxIcon = CX_SMALLICON;
    BOOL        fReleaseDC;
    TEXTMETRIC  tmFolderName,
                tmViewText;
    RECT        rcClient;
    SIZE        sFolderName,
                sViewText;
    HFONT       hFontOld;

    // Signal that we don't need to recalc again
    m_fRecalc = FALSE;

    if (prcAvailableSpace)
        {
        rcClient.left = 0;
        rcClient.top = 0;
        rcClient.right = prcAvailableSpace->right - prcAvailableSpace->left;
        rcClient.bottom = prcAvailableSpace->bottom - prcAvailableSpace->top;
        }
    else
        GetClientRect(m_hwnd, &rcClient);

    // Get a device context if we were not given one
    if (hDC)
        fReleaseDC = FALSE;
    else
        {
        hDC = GetDC(m_hwnd);
        fReleaseDC = TRUE;
        }

    // Create the fonts
    if (fSizeChange || !m_hfFolderName || !m_hfViewText)
        {
        if (m_hfFolderName)
            DeleteObject(m_hfFolderName);
        if (m_hfViewText)
            DeleteObject(m_hfViewText);
    

        // Create the font we are going to use for the folder name
        m_hfFolderName = GetFont(idsFontFolderSmall, FW_BOLD);
        m_hfViewText = GetFont(idsFontViewTextSmall, FW_BOLD);
        

        // Determine the height of the control, which is whatever is larger of                                                                         i
        // the following two things
        //      1) The icon height plus the icon margin
        //      2) The text height plus the text margin
        hFontOld = SelectFont(hDC, m_hfFolderName);
        GetTextMetrics(hDC, &tmFolderName);
        SelectFont(hDC, hFontOld);
        m_cyControl = max(cyIcon + CY_MARGIN_ICON,
                          tmFolderName.tmHeight + CY_MARGIN_TEXTTOP + CY_MARGIN_TEXTBOTTOM);

        // The top of the folder name text is position so that we have the correct
        // amount of border at the bottom of the control
        m_dyFolderName = m_cyControl - tmFolderName.tmHeight - CY_MARGIN_TEXTBOTTOM;

        // Get the height of the view text
        hFontOld = SelectFont(hDC, m_hfViewText);
        GetTextMetrics(hDC, &tmViewText);
        SelectFont(hDC, hFontOld);

        // The view text is positioned such that it's baseline matches the baseline
        // of the folder name
        m_dyViewText = m_dyFolderName + tmFolderName.tmAscent - tmViewText.tmAscent;

        // The child indicator is positioned such that the bottom of the bitmap lines
        // up with the baseline of the folder name
        m_dyChildIndicator = m_cyControl - CY_MARGIN_TEXTBOTTOM - tmFolderName.tmDescent - GetYChildIndicator();

        // The folder icon is centered within the control
        m_dyIcon = (m_cyControl - cyIcon) / 2;

        // Number must be even to ensure good-looking triangular drop arrow.
        Assert(GetXChildIndicator() % 2 == 0);

        // Width must be multiple of height for triangle to look smooth.
        Assert(GetXChildIndicator() % GetYChildIndicator() == 0);
        }

    // The view text is right justified within the folder bar
    if (m_cchViewText)
        {
        m_rcViewText.top = m_dyViewText;
        m_rcViewText.right = rcClient.right - CX_MARGIN_TEXT;

        m_rcViewText.bottom = rcClient.bottom;
        m_nFormatViewText = DT_RIGHT | DT_TOP | DT_SINGLELINE | DT_NOPREFIX;
        hFontOld = SelectFont(hDC, m_hfViewText);
        GetTextExtentPoint32(hDC, m_pszViewText, m_cchViewText, &sViewText);
        SelectFont(hDC, hFontOld);
        m_rcViewText.left = m_rcViewText.right - sViewText.cx;
        }


    // The folder name is left justified within the folder bar.  It is clipped
    // so that it does not overlap the view text
    if (m_cchFolderName)
        {
        m_rcFolderName.left = CX_MARGIN_ICONTEXT + cxIcon + CX_MARGIN_ICON;
        m_rcFolderName.top = m_dyFolderName;

        if (m_cchViewText)
            m_rcFolderName.right = m_rcViewText.left - CX_MARGIN_FOLDERVIEWTEXT;
        else
            m_rcFolderName.right = rcClient.right;

        m_rcFolderName.bottom = rcClient.bottom;

        if (FDropDownEnabled())
            m_rcFolderName.right -= GetXChildIndicator() + CX_MARGIN_CHILDINDICATOR;

        m_nFormatFolderName = DT_LEFT | DT_BOTTOM | DT_SINGLELINE | DT_NOPREFIX;

        hFontOld = SelectFont(hDC, m_hfFolderName);
        GetTextExtentPoint32(hDC, m_pszFolderName, m_cchFolderName, &sFolderName);

        if (sFolderName.cx > (m_rcFolderName.right - m_rcFolderName.left))
            {
            m_nFormatFolderName |= DT_END_ELLIPSIS;
#ifndef WIN16
            DrawTextEx(hDC, m_pszFolderName, m_cchFolderName, &m_rcFolderName,
                       m_nFormatFolderName | DT_CALCRECT, NULL);
#else
            DrawText(hDC, m_pszFolderName, m_cchFolderName, &m_rcFolderName,
                       m_nFormatFolderName | DT_CALCRECT);
#endif // !WIN16
            }
        else
            {
            m_nFormatFolderName |= DT_NOCLIP;
            m_rcFolderName.right = m_rcFolderName.left + sFolderName.cx;
            }

        SelectFont(hDC, hFontOld);
        m_cxFolderNameRight = m_rcFolderName.right + CX_MARGIN_TEXT;

        if (FDropDownEnabled())
            m_cxFolderNameRight += GetXChildIndicator() + CX_MARGIN_CHILDINDICATOR + 2;
        }


    // When the folder name is clipped it will always display at least one letter
    // followed by ellipsis.  Make sure not to draw the view text over this.
    if (m_cchViewText)
        {
        if (m_rcViewText.left < m_rcFolderName.right + CX_MARGIN_FOLDERVIEWTEXT)
            m_rcViewText.left = m_rcFolderName.right + CX_MARGIN_FOLDERVIEWTEXT;
        else
            m_nFormatViewText |= DT_NOCLIP;
        }

    if (fReleaseDC)
        ReleaseDC(m_hwnd, hDC);
    }

HFONT CFolderBar::GetFont(UINT idsFont, int nWeight)
    {
    // The font info is stored as a string in the resources so the localizers
    // can get to it.  The format of the string is "face,size"
    TCHAR   sz[CCHMAX_STRINGRES];
    LPTSTR  pszFace, pszTok;
    LONG    lSize;

    // Load the setting
    AthLoadString(idsFont, sz, ARRAYSIZE(sz));

    // Parse out the face name
    pszTok = sz;
    pszFace = StrTokEx(&pszTok, g_szComma);

    // Parse out the size
    lSize = StrToInt(StrTokEx(&pszTok, g_szComma));
    return(GetFont(/* pszFace*/ NULL, lSize, nWeight)); // (YST) szFace parametr was always ignored in OE 4.0, 
    }

HFONT CFolderBar::GetFont(LPTSTR pszFace, LONG lSize, int nWeight)
{
    HFONT   hf;
    HDC     hdc = GetDC(m_hwnd);
#ifndef WIN16
    ICONMETRICS icm;
#else
    LOGFONT lf;
#endif

    lSize = -MulDiv(lSize, GetDeviceCaps(hdc, LOGPIXELSY), 720);

#ifndef WIN16
    // Get the title bar font from the system
    icm.cbSize = sizeof(ICONMETRICS);
    SystemParametersInfo(SPI_GETICONMETRICS, sizeof(ICONMETRICS), 
                         (LPVOID) &icm, FALSE);

    // Create the font
    hf = CreateFont(lSize, 0, 0, 0, nWeight, 0, 0, 0, DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    icm.lfFont.lfPitchAndFamily, (pszFace ? pszFace : icm.lfFont.lfFaceName));
#else
    // Get the logical font infomation for the current icon-title font.
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, FALSE);


    // Create the font
    hf = CreateFont(lSize, 0, 0, 0, nWeight /* FW_NORMAL*/, 0, 0, 0, DEFAULT_CHARSET,
                    OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                    lf.lfPitchAndFamily, (pszFace ? pszFace : icm.lfFont.lfFaceName));
#endif // !WIN16

    ReleaseDC(m_hwnd, hdc);

    return (hf);

}

void CFolderBar::OnPaint(HWND hwnd)
    {
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rcClient, 
                rc;
    POINT       pt[3];
    HBRUSH      hBrush,
                hBrushOld;
    HPEN        hPen,
                hPenOld;
    HFONT       hFontOld;
    COLORREF    crFG = GetSysColor(COLOR_WINDOW);
    COLORREF    crWindowText = GetSysColor(COLOR_WINDOWTEXT);
#ifndef WIN16
    COLORREF    crBtnHighlight = GetSysColor(COLOR_BTNHILIGHT);
#else
    COLORREF    crBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
#endif // !WIN16

    GetClientRect(m_hwnd, &rcClient);

    hdc = BeginPaint(m_hwnd, &ps);

    // Recalc the text positions
    if (m_fRecalc)
        Recalc(hdc, NULL, FALSE);

    // Paint the background
    hBrush = CreateSolidBrush(GetSysColor(COLOR_3DSHADOW));
    hBrushOld = SelectBrush(hdc, hBrush);
    PatBlt(hdc, rcClient.left, rcClient.top, rcClient.right - rcClient.left,
           rcClient.bottom - rcClient.top, PATCOPY);
    SelectBrush(hdc, hBrushOld);
    DeleteBrush(hBrush);

    // Set the foreground and background color
    SetBkColor(hdc, GetSysColor(COLOR_3DSHADOW));
    SetTextColor(hdc, crFG);

    // Folder name
    if (m_cchFolderName)
        {
        hFontOld = SelectFont(hdc, m_hfFolderName);

        // Use IDrawText because DrawTextEx() doesn't handle DBCS.  
        // Note, the "bottom - top" nonsense for the last param is to undo some
        // vertical centering that IDrawText is trying to do that we don't want.
        IDrawText(hdc, m_pszFolderName, &m_rcFolderName, m_nFormatFolderName & DT_END_ELLIPSIS,
                  m_rcFolderName.bottom - m_rcFolderName.top);
        SelectFont(hdc, hFontOld);
        
        }

    // Drop-down indicator
    if (FDropDownEnabled())
        {
        pt[0].x = m_rcFolderName.right + CX_MARGIN_CHILDINDICATOR;
        pt[0].y = m_dyChildIndicator;
        pt[1].x = pt[0].x + GetXChildIndicator();
        pt[1].y = pt[0].y;
        pt[2].x = pt[0].x + GetXChildIndicator() / 2;
        pt[2].y = pt[0].y + GetYChildIndicator();

        hPen = CreatePen(PS_SOLID, 1, crFG);
        hBrush = CreateSolidBrush(crFG);
        hPenOld = SelectPen(hdc, hPen);
        hBrushOld = SelectBrush(hdc, hBrush);
        Polygon(hdc, pt, 3);
        SelectPen(hdc, hPenOld);
        SelectBrush(hdc, hBrushOld);
        DeleteObject(hPen);
        DeleteObject(hBrush);
        }

	// Mouse-over highlight
	if (m_fHighlightIndicator || m_hwndScopeDropDown)
		{
		hPen = CreatePen(PS_SOLID, 1, m_hwndScopeDropDown ? crWindowText : crBtnHighlight);
		hPenOld = SelectPen(hdc, hPen);
		pt[0].x = rcClient.left;
		pt[0].y = rcClient.bottom - 1; // - CY_MARGIN;
		pt[1].x = rcClient.left;
		pt[1].y = rcClient.top;
		pt[2].x = m_cxFolderNameRight - 1;
		pt[2].y = rcClient.top;
		Polyline(hdc, (POINT *)&pt, 3);
		SelectPen(hdc, hPenOld);
		DeleteObject(hPen);
		
		hPen = CreatePen(PS_SOLID, 1, m_hwndScopeDropDown ? crBtnHighlight : crWindowText);
		hPenOld = SelectPen(hdc, hPen);
		pt[1].x = m_cxFolderNameRight - 1;
		pt[1].y = rcClient.bottom - 1; //  - CY_MARGIN;
		pt[2].x = pt[1].x;
		pt[2].y = rcClient.top - 1;
		Polyline(hdc, (POINT *)&pt, 3);
		SelectPen(hdc, hPenOld);
		DeleteObject(hPen);
		}

    // View text
    if (m_cchViewText)
        {
        SetTextColor(hdc, crFG);
        hFontOld = SelectFont(hdc, m_hfViewText);
        ExtTextOut(hdc, m_rcViewText.left, m_rcViewText.top, ETO_OPAQUE | ETO_CLIPPED,
                   &m_rcViewText, m_pszViewText, m_cchViewText, NULL);
        SelectFont(hdc, hFontOld);
        }

    // Folder Icon
    if (m_hIconSmall)
        {
        int x = rcClient.left + CX_MARGIN_ICON;
        int y = m_dyIcon;
        
        DrawIconEx(hdc, x, y, m_hIconSmall, CX_SMALLICON, CY_SMALLICON, 0, NULL, DI_NORMAL);
        }

    EndPaint(m_hwnd, &ps);
    }


BOOL CFolderBar::FDropDownEnabled(void)
    {
    return (m_fDropDownIndicator);
    }

void CFolderBar::InvalidateFolderName(void)
    { 
	RECT rcFolderName;
	
	if (m_fRecalc)
		InvalidateRect(m_hwnd, NULL, TRUE);
	else
		{
		GetFolderNameRect(&rcFolderName);
		InvalidateRect(m_hwnd, &rcFolderName, TRUE);
		}
    }

int	CFolderBar::GetXChildIndicator()
    {
	return CX_SMALL_CHILDINDICATOR;
    }

int	CFolderBar::GetYChildIndicator()
    {
	return CY_SMALL_CHILDINDICATOR;
    }

LRESULT CALLBACK CFolderBar::FolderWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CFolderBar *pThis = (CFolderBar *) GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_NCCREATE:
            {
            pThis = (CFolderBar *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            SetWndThisPtr(hwnd, (LONG_PTR) pThis);
            return (TRUE);
            }

        HANDLE_MSG(hwnd, WM_PAINT,       pThis->OnPaint);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,   pThis->OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN, pThis->OnLButtonDown);
        HANDLE_MSG(hwnd, WM_TIMER,       pThis->OnTimer);

        case WM_CREATE:
        {
#ifndef WIN16
         if (g_pConMan)
            g_pConMan->Advise((IConnectionNotify*)pThis);
#endif  
         break;
        }

        case WM_DESTROY:
        {
#ifndef WIN16
         if (g_pConMan)
            g_pConMan->Unadvise((IConnectionNotify*)pThis);
#endif
         RevokeDragDrop(hwnd);
         break;
        }

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            {
            pThis->Recalc(NULL, NULL, TRUE);
            InvalidateRect(pThis->m_hwnd, NULL, TRUE);
            return (0);
            }

        case WM_PALETTECHANGED:

            InvalidateRect(pThis->m_hwnd, NULL, TRUE);
            break;

        case WM_QUERYNEWPALETTE:
            InvalidateRect(pThis->m_hwnd, NULL, TRUE);
            return(TRUE);
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

void CFolderBar::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
    {
    POINT pt = {x, y};
#if 0
    if (!IsRectEmtpy(&m_rcDragDetect) && !PtInRect(m_rcDragDetect, pt))
        {
        SetRectEmpty(m_rcDragDetect);
        HrBeginDrag();
        }
    else
#endif
        DoMouseOver(&pt, MO_NORMAL);
    }


void CFolderBar::OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
    {
    POINT pt = {x, y};
    DoMouseClick(pt, keyFlags);
    }


void CFolderBar::OnTimer(HWND hwnd, UINT id)
    {
    RECT rcClient;
    POINT pt;
    DWORD dwMP;
    BOOL fHighlightOff = FALSE;

    dwMP = GetMessagePos();
    pt.x = LOWORD(dwMP);
    pt.y = HIWORD(dwMP);
    ScreenToClient(m_hwnd, &pt);

    if (id == IDT_MOUSEOVERCHECK)
        {
        GetClientRect(m_hwnd, &rcClient);
		// No need to handle mouse in client area, OnMouseMove will catch this. We
		// only need to catch the mouse moving out of the client area.
		if (!PtInRect(&rcClient, pt))
			{
			KillTimer(m_hwnd, IDT_MOUSEOVERCHECK);
			fHighlightOff = TRUE;
			}
		}
	else if (id == IDT_DROPDOWNCHECK)
		{
		DoMouseClick(pt, 0);
// ???		DoDeferredCall(DEFERREDCALL_REGISTERTARGET);
		fHighlightOff = TRUE;
		}
	else if (id == IDT_SCOPECLOSECHECK)
		{
		KillScopeDropDown();
		}
#ifdef	DEBUG
	else
		AssertSz(FALSE, "Hey! Who has another timer going here?");
#endif

	if (fHighlightOff)
		{
		m_fHighlightIndicator = FALSE;
		InvalidateFolderName();
		}
	
	return;
    }


void CFolderBar::DoMouseOver(LPPOINT ppt, MOMODE moMode)
    {
    HWND hwndActive;
    RECT rcFolderName;

    if (!FDropDownEnabled() || m_hwndScopeDropDown)
        return;

    if (moMode == MO_NORMAL)
        {
        // Only do mouse-over if we are the active window and not d&d
        hwndActive = GetActiveWindow();
        if (!hwndActive || (hwndActive != m_hwndParent && IsChild(m_hwndParent, hwndActive)))
            return;
        }

    GetFolderNameRect(&rcFolderName);

    if (moMode == MO_DRAGLEAVE || moMode == MO_DRAGDROP)
        ppt->x = rcFolderName.left - 1;   // Force point to be outside

    if (m_fHighlightIndicator != PtInRect(&rcFolderName, *ppt))
        {
        m_fHighlightIndicator = !m_fHighlightIndicator;
        InvalidateFolderName();

        if (moMode == MO_DRAGOVER)
            {
            if (!m_hwndScopeDropDown && m_fHoverTimer != m_fHighlightIndicator)
                {
                KillHoverTimer();
                if (m_fHighlightIndicator)
                    m_fHoverTimer = (0 != SetTimer(m_hwnd, IDT_DROPDOWNCHECK, GetDoubleClickTime(), NULL));
                }
            }
        else
            {
            KillTimer(m_hwnd, IDT_MOUSEOVERCHECK);
            if (m_fHighlightIndicator)
                SetTimer(m_hwnd, IDT_MOUSEOVERCHECK, ELAPSE_MOUSEOVERCHECK, NULL);
            }
        }
    }


void CFolderBar::KillHoverTimer()
    {
	if (m_fHoverTimer)
		{
		KillTimer(m_hwnd, IDT_DROPDOWNCHECK);
		m_fHoverTimer = fFalse;
		}
    }


void CFolderBar::DoMouseClick(POINT pt, DWORD grfKeyState)
    {
    RECT rcFolderName;

    if (!FDropDownEnabled())
        return;

    GetFolderNameRect(&rcFolderName);
    if (PtInRect(&rcFolderName, pt))
        {
        if (IsWindow(m_hwndScopeDropDown))
            KillScopeDropDown();
        else
            {
            KillHoverTimer();
            HrShowScopeFlyOut();
            }
        }
    }

void CFolderBar::KillScopeDropDown(void)
    {
	POINT pt;
	
	// During window destruction hwndScopeDropDown gets set to NULL.
	if (IsWindow(m_hwndScopeDropDown))
		{
		KillScopeCloseTimer();
		DestroyWindow(m_hwndScopeDropDown);
        m_hwndScopeDropDown = NULL;
		pt.x = pt.y = 0;
		DoMouseOver(&pt, MO_DRAGLEAVE);
		}
    }

void CFolderBar::SetScopeCloseTimer(void)
    {
	KillScopeCloseTimer();

	// If we can't set the timer, we just do it immediately.
	if (!SetTimer(m_hwnd, IDT_SCOPECLOSECHECK, ELAPSE_SCOPECLOSECHECK, NULL))
		SendMessage(m_hwnd, WM_TIMER, (WPARAM) IDT_SCOPECLOSECHECK, NULL);
    }
    
void CFolderBar::KillScopeCloseTimer(void)
    {
	KillTimer(m_hwnd, IDT_SCOPECLOSECHECK);
    }


HRESULT CFolderBar::HrShowScopeFlyOut(void)
    {
    IAthenaBrowser *pBrowser = NULL;
    CFlyOutScope *pFlyOutScope;

    m_pSite->QueryInterface(IID_IAthenaBrowser, (LPVOID *) &pBrowser);
    Assert(pBrowser);

    pFlyOutScope = new CFlyOutScope;
    if (pFlyOutScope && pBrowser)
        {
        pFlyOutScope->HrDisplay(pBrowser, this, m_hwndParent, 
                                &m_hwndScopeDropDown);
        InvalidateFolderName();
        }
    SafeRelease(pBrowser);

    return (S_OK);
    }


void CFolderBar::Update(BOOL fDisplayNameChanged, BOOL fShowDropDownIndicator)
    {
    if (fDisplayNameChanged)
        {
        SetFolderName(NULL);
        }

    if (fShowDropDownIndicator)
        {
        BOOL fInfoColumn = FALSE;
        if (SUCCEEDED(m_pBrowser->GetViewLayout(DISPID_MSGVIEW_FOLDERLIST, 0, &fInfoColumn, 0, 0)))
            m_fDropDownIndicator = !fInfoColumn;        
        }

    if (fDisplayNameChanged || fShowDropDownIndicator)
        {
        m_fRecalc = TRUE;
        InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }


HRESULT STDMETHODCALLTYPE CFolderBar::DragEnter(IDataObject* pDataObject, 
                                                DWORD grfKeyState, 
                                                POINTL pt, DWORD* pdwEffect)
    {    
    HRESULT hr = S_OK;
    DOUTL(32, _T("CFolderBar::DragEnter() - Starting"));

    // Release Current Data Object
    SafeRelease(m_pDataObject);

    // Initialize our state
    SafeRelease(m_pDTCur);

    // Let's get a drop target
    if (FOLDERID_INVALID == m_idFolder)
        return (E_FAIL);

    // Create the a Drop Target
    CDropTarget *pTarget = new CDropTarget();
    if (pTarget)
    {
        if (FAILED(hr = pTarget->Initialize(m_hwnd, m_idFolder)))
        {
            pTarget->Release();
            return (hr);
        }
    }
    m_pDTCur = pTarget;    

    // Save the Data Object
    m_pDataObject = pDataObject;
    m_pDataObject->AddRef();

    hr = m_pDTCur->DragEnter(m_pDataObject, grfKeyState, pt, &m_dwEffectCur);

    // Save Key State
    m_grfKeyState = grfKeyState;

    // Set the default return value to be failure
    *pdwEffect = m_dwEffectCur;

    return (S_OK);
    }


//
//  FUNCTION:   CFolderBar::DragOver()
//
//  PURPOSE:    This is called as the user drags an object over our target.
//              If we allow this object to be dropped on us, then we will have
//              a pointer in m_pDataObject.
//
//  PARAMETERS:
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - The function succeeded.
//
HRESULT STDMETHODCALLTYPE CFolderBar::DragOver(DWORD grfKeyState, POINTL pt, 
                                                DWORD* pdwEffect)
    {
    HRESULT         hr = E_FAIL;

    // If we don't have a stored data object from DragEnter()
    if (m_pDataObject && NULL != m_pDTCur)
        {
        // If the keys changed, we need to re-query the drop target
        if ((m_grfKeyState != grfKeyState) && m_pDTCur)
            {
            m_dwEffectCur = *pdwEffect;
            hr = m_pDTCur->DragOver(grfKeyState, pt, &m_dwEffectCur);
            }
        else
            {
            hr = S_OK;
            }

        *pdwEffect = m_dwEffectCur;
        m_grfKeyState = grfKeyState;
        }

    ScreenToClient(m_hwnd, (LPPOINT) &pt);
    DoMouseOver((LPPOINT) &pt, MO_DRAGOVER);

    return (hr);
    }
    

//
//  FUNCTION:   CFolderBar::DragLeave()
//
//  PURPOSE:    Allows us to release any stored data we have from a successful
//              DragEnter()
//
//  RETURN VALUE:
//      S_OK - Everything is groovy
//
HRESULT STDMETHODCALLTYPE CFolderBar::DragLeave(void)
    {
    POINT pt = {0, 0};
    DOUTL(32, _T("CFolderBarView::DragLeave()"));

    KillHoverTimer();
    DoMouseOver(&pt, MO_DRAGLEAVE);
    // SetScopeCloseTimer();

    SafeRelease(m_pDTCur);
    SafeRelease(m_pDataObject);

    return (S_OK);
    }
    

//
//  FUNCTION:   CFolderBar::Drop()
//
//  PURPOSE:    The user has let go of the object over our target.  If we 
//              can accept this object we will already have the pDataObject
//              stored in m_pDataObject.  If this is a copy or move, then
//              we go ahead and update the store.  Otherwise, we bring up
//              a send note with the object attached.
//
//  PARAMETERS:
//      <in>  pDataObject - Pointer to the data object being dragged
//      <in>  grfKeyState - Pointer to the current key states
//      <in>  pt          - Point in screen coordinates of the mouse
//      <out> pdwEffect   - Where we return whether this is a valid place for
//                          pDataObject to be dropped and if so what type of
//                          drop.
//
//  RETURN VALUE:
//      S_OK - Everything worked OK
//
HRESULT STDMETHODCALLTYPE CFolderBar::Drop(IDataObject* pDataObject, 
                                          DWORD grfKeyState, POINTL pt, 
                                          DWORD* pdwEffect)
    {
    HRESULT         hr;

    Assert(m_pDataObject == pDataObject);

    if (m_pDTCur)
        {
        hr = m_pDTCur->Drop(pDataObject, grfKeyState, pt, pdwEffect);
        }
    else
        {
        *pdwEffect = 0;
        hr = S_OK;
        }

    KillHoverTimer();
    ScreenToClient(m_hwnd, (LPPOINT) &pt);
    DoMouseOver((LPPOINT) &pt, MO_DRAGDROP);
  
    SafeRelease(m_pDataObject);
    SafeRelease(m_pDTCur);

    return (hr);
    }



LRESULT CALLBACK CFolderBar::FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam)
    {
    CFolderBar *pThis = (CFolderBar *) GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_NCCREATE:
            {
            pThis = (CFolderBar *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            SetWndThisPtr(hwnd, (LONG_PTR) pThis);
            pThis->m_hwnd = hwnd;
            return (TRUE);
            }

        case WM_SIZE:
            {
            SetWindowPos(pThis->m_hwnd, NULL, 0, 0, LOWORD(lParam) - CX_MARGIN_RIGHTEDGE, 
                         HIWORD(lParam) - CY_MARGIN, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            return (TRUE);
            }
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }


#define FLYOUTSCOPECLASS _T("FlyOutScope")
HRESULT CFlyOutScope::HrDisplay(IAthenaBrowser *pBrowser, CFolderBar *pFolderBar,
                                HWND hwndParent, HWND *phwndScope)
    {
    HRESULT hr = S_OK;
    RECT    rc,
            rcFrame,
            rcView;
    int     cx, 
            cy,
            cyMax,
            increments,
            dyOffset;
    const   cmsAvail = 250;
    DWORD   cmsUsed,
            cmsLeft,
            cmsThreshold,
            cmsStart,
            cmsNow;

    Assert(pBrowser);
    Assert(pFolderBar);

    m_pBrowser = pBrowser;
    m_pBrowser->AddRef();
    m_pFolderBar = pFolderBar;
    m_fResetParent = FALSE;
    m_hwndParent = hwndParent;

    m_pFolderBar->GetWindow(&m_hwndFolderBar);
    m_hwndFocus = GetFocus();

    // Create the control
    WNDCLASSEX wc;

    // Check to see if we need to register the class first
    wc.cbSize = sizeof(WNDCLASSEX);
    if (!GetClassInfoEx(g_hInst, FLYOUTSCOPECLASS, &wc))
        {
        wc.style         = 0;
        wc.lpfnWndProc   = FlyWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        wc.hbrBackground = NULL;
        wc.hIcon         = NULL;
        IF_WIN32( wc.hIconSm       = NULL; )
        wc.lpszClassName = FLYOUTSCOPECLASS;

        SideAssert(RegisterClassEx(&wc));
        }
    m_hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, FLYOUTSCOPECLASS, NULL, 
                            WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0, 0, 0,
                            m_hwndParent, 0, g_hInst, (LPVOID) this);
    if (!m_hwnd)
        {
        GetLastError();
        return (E_OUTOFMEMORY);
        }

    // Get the scope pane from the browser
    m_pBrowser->GetTreeView(&m_pTreeView);
    m_pTreeView->GetWindow(&m_hwndTree);
    m_hwndTreeParent = GetParent(m_hwndTree);

    // Turn on the pin button
    SendMessage(m_hwndTree, WM_TOGGLE_CLOSE_PIN, 0, TRUE);

	// Set the focus before changing the parent. In some cases, setting the 
	// focus, causes a selection change notification to come through. This
	// makes the explorer split pane think the user has made their selection
	// and shuts down the drop down scope pane before it is even shown!

    HWND hwndT = GetWindow(m_hwndTree, GW_CHILD);
    SetFocus(m_hwndTree);
    SetParent(m_hwndTree, m_hwnd);
    m_fResetParent = TRUE;
    SetWindowPos(m_hwndTree, NULL, CXY_MARGIN_FLYOUT, CXY_MARGIN_FLYOUT, 0, 0,
                 SWP_NOSIZE | SWP_NOZORDER);
    ShowWindow(m_hwndTree, SW_SHOW);
    m_pTreeView->RegisterFlyOut(m_pFolderBar);

    // Clear the parent for better redraw
    SetParent(m_hwnd, NULL);

    // Set up for the slide, the final position for the flyout will match the
    // left/top/bottom edges of the view.  The width of the scope pane is either
    // 1/3 of the width of the view or CX_MINWIDTH_FLYOUT, whichever is larger.

    // Get the position & size of the view window
    m_pBrowser->GetViewRect(&rcView);
    MapWindowPoints(m_hwndParent, GetDesktopWindow(), (LPPOINT) &rcView, 2);

    // Determine the width of the fly-out
    cx = max(CX_MINWIDTH_FLYOUT, ((rcView.right - rcView.left) / 3) + 2 * CXY_MARGIN_FLYOUT);

    // Calculate the fly-out increments
    cyMax = cy = (rcView.bottom - rcView.top) + (CXY_MARGIN_FLYOUT * 2);
    increments = cy / FLYOUT_INCREMENT;
    cy -= increments * FLYOUT_INCREMENT;

    // Scope pane is positioned at it's final size so that it's size does not
    // change as we drop the flyout down.  This gives better redraw than resizing
    // as the window drops
    SetWindowPos(m_hwndTree, NULL, 0, 0, cx - CXY_MARGIN_FLYOUT * 2, cyMax - CXY_MARGIN_FLYOUT * 2,
                 SWP_NOMOVE | SWP_NOZORDER);

    // Move the window to its initial position
    GetWindowRect(m_hwndFolderBar, &rc);
    MoveWindow(m_hwnd, IS_WINDOW_RTL_MIRRORED(m_hwndParent) ? (rc.right + CXY_MARGIN_FLYOUT - cx) : (rc.left - CXY_MARGIN_FLYOUT), rcView.top - CXY_MARGIN_FLYOUT,
               cx, cy, FALSE);
    ShowWindow(m_hwnd, SW_SHOW);
    SetWindowPos(m_hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

#ifndef WIN16
    if (GetSystemMetrics(SM_SLOWMACHINE))
        {
        // On a slow machine, just show the thing
        SetWindowPos(m_hwnd, NULL, 0, 0, cx, cyMax, SWP_NOMOVE | SWP_NOZORDER);
        }
    else
#endif // !WIN16
        {
        // Whoosh down to the bottom of the frame.  We want to do this in ~250ms on any
        // CPU.  In order to make this work on differing machine speeds, we double
        // the slide speed everytime the remaining time is halved.  If the remaining time
        // is negative, it will finish the slide in one step.

        dyOffset = FLYOUT_INCREMENT;
        cmsStart = ::GetTickCount();
        cmsThreshold = cmsAvail;

        while (cy <= cyMax)
            {
            // Slide the window down
            cy += dyOffset;
            SetWindowPos(m_hwnd, NULL, 0, 0, cx, min(cy, cyMax), SWP_NOMOVE | SWP_NOZORDER);
            UpdateWindow(m_hwnd);
            UpdateWindow(m_hwndTree);

            // Determine the next increment based on time remaining
            cmsNow = GetTickCount();
            cmsUsed = cmsNow - cmsStart;
            if (cmsUsed > cmsAvail && cy < cyMax)
                {
                // Finish it in one step
                cy = cyMax;
                }
            else
                {
                // Double scroll step if time remaining is halved since the 
                // last time we double the scroll step
                cmsLeft = cmsAvail - cmsUsed;
                if (cmsLeft < cmsThreshold)
                    {
                    dyOffset *= 2;
                    cmsThreshold /= 2;
                    }
                }
            }
        }

    *phwndScope = m_hwnd;
    return (hr);    
    }


LRESULT CALLBACK CFlyOutScope::FlyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    CFlyOutScope *pThis = (CFlyOutScope *) GetWndThisPtr(hwnd);

    switch (uMsg)
        {
        case WM_NCCREATE:
            {
            pThis = (CFlyOutScope *) ((LPCREATESTRUCT) lParam)->lpCreateParams;
            SetWndThisPtr(hwnd, (LONG_PTR) pThis);
            pThis->m_hwnd = hwnd;
            return (TRUE);
            }
               
        HANDLE_MSG(hwnd, WM_PAINT,       pThis->OnPaint);
        HANDLE_MSG(hwnd, WM_NOTIFY,      pThis->OnNotify);
        HANDLE_MSG(hwnd, WM_DESTROY,     pThis->OnDestroy);
        HANDLE_MSG(hwnd, WM_SIZE,        pThis->OnSize);

        case WM_NCDESTROY:
            {
            pThis->Release();
            break;
            }
        }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

BOOL CFlyOutScope::OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
    return (0);
    }


void CFlyOutScope::OnPaint(HWND hwnd)
    {
    HDC hdc;
    RECT rcClient;
    PAINTSTRUCT ps;

    GetClientRect(hwnd, &rcClient);

    // Paint the background
    hdc = BeginPaint(hwnd, &ps);
    SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &ps.rcPaint, NULL, 0, NULL);

    // Draw the 3D edge
    DrawEdge(hdc, &rcClient, EDGE_RAISED, BF_RECT);
    EndPaint(hwnd, &ps);
    }


void CFlyOutScope::OnSize(HWND hwnd, UINT state, int cx, int cy)
    {
    RECT rc;

    GetClientRect(hwnd, &rc);
    InvalidateRect(hwnd, &rc, FALSE);
    InflateRect(&rc, -CXY_MARGIN_FLYOUT, -CXY_MARGIN_FLYOUT);
    ValidateRect(hwnd, &rc);
    }


void CFlyOutScope::OnDestroy(HWND hwnd)
    {
    // Make sure to kill any bogus timers still lying around
    m_pFolderBar->KillScopeCloseTimer();
    m_pFolderBar->ScopePaneDied();

    // Reset the parent of the scope pane back to the browser
    if (m_fResetParent)
        {
        ShowWindow(m_hwndTree, SW_HIDE);
        SendMessage(m_hwndTree, WM_TOGGLE_CLOSE_PIN, 0, FALSE);
        SetParent(m_hwndTree, m_hwndTreeParent);
        m_pTreeView->RevokeFlyOut();
        }

    // Set the parent of the drop down pane itself back
    SetParent(m_hwnd, m_hwndFolderBar);

    // $TODO - Review where the focus is supposed to go
    HWND hwndBrowser;
    if (m_pBrowser)
        {
        m_pBrowser->GetWindow(&hwndBrowser);
        PostMessage(hwndBrowser, WM_OESETFOCUS, (WPARAM) m_hwndFocus, 0);
        }
    }


CFlyOutScope::CFlyOutScope()
    {
    m_cRef          = 1;
    m_pBrowser      = 0;
    m_pFolderBar    = 0;
    m_fResetParent  = 0;
    m_pTreeView     = NULL;
    m_hwnd          = NULL;
    m_hwndParent    = NULL;
    m_hwndTree      = NULL;
    m_hwndFolderBar = NULL;
    }

CFlyOutScope::~CFlyOutScope()
    {
    SafeRelease(m_pBrowser);
    SafeRelease(m_pTreeView);
    }

ULONG CFlyOutScope::AddRef(void)
    {
    return (++m_cRef);
    }

ULONG CFlyOutScope::Release(void)
    {
    ULONG cRefT = --m_cRef;

    if (m_cRef == 0)
        delete this;

    return (cRefT);
    }

HRESULT  CFolderBar::OnConnectionNotify(CONNNOTIFY  nCode, LPVOID pvData, CConnectionManager *pConMan)
{
    m_fRecalc = TRUE;
    InvalidateRect(m_hwnd, NULL, TRUE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\finder.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.h
//
//  PURPOSE:    
//

#pragma once


/////////////////////////////////////////////////////////////////////////////
// Forward Definitions
//

#include "storutil.h"
#include "msident.h"

class CStatusBar;
class CViewMenu;
interface IMessageList;

/////////////////////////////////////////////////////////////////////////////
// Types
//

typedef struct tagFINDMSG
{
    ULONG    flags;
    LPTSTR   pszFromHeader;
    LPTSTR   pszSubject;
    LPTSTR   pszRecip;
    LPTSTR   pszBody;
    FILETIME ftDateFrom;
    FILETIME ftDateTo;
} FINDMSG;

/////////////////////////////////////////////////////////////////////////////
// FINDERPARAMS
//
// Used to provide initialization information to the finder class
//
typedef struct tagFINDERPARAMS
{
    FOLDERTYPE     ftType;
    FOLDERID       idFolder;       // Currently Selected Folder
} FINDERPARAMS, * PFINDERPARAMS;

/////////////////////////////////////////////////////////////////////////////
// Public Functions 
//

HRESULT DoFindMsg(FOLDERID idFolder, FOLDERTYPE ftFolder);
HRESULT CopyFindInfo(FINDINFO *pFindSrc, FINDINFO *pFindDst);
void    FreeFindInfo(FINDINFO *pFindInfo);
void CloseFinderTreads(void);

/////////////////////////////////////////////////////////////////////////////
// Class CPumpRefCount
//
class CPumpRefCount : public IUnknown
{
public:
    CPumpRefCount() {m_cRef = 1;}
    ~CPumpRefCount() {PostQuitMessage(0);}

    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

private:
    ULONG       m_cRef;
};

/////////////////////////////////////////////////////////////////////////////
// Class CFindDlg
//
class CFindDlg : public IDispatch, 
                 public IOleCommandTarget,
                 public IStoreCallback,
                 public ITimeoutCallback,
                 public IIdentityChangeNotify
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CFindDlg();
    ~CFindDlg();

    void Show(PFINDERPARAMS pfindparams);
    void HandleMessage(LPMSG lpmsg);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown
    //
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /////////////////////////////////////////////////////////////////////////
    // IDispatch
    //
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return (E_NOTIMPL); }
    STDMETHODIMP GetTypeInfo(unsigned int iTInfo, LCID lcid, ITypeInfo **ppTInfo) { return (E_NOTIMPL); }
    STDMETHODIMP GetTypeInfoCount(unsigned int FAR* pctinfo) { return (E_NOTIMPL); }
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                        DISPPARAMS* pDispParams, VARIANT* pVarResult,
                        EXCEPINFO* pExcepInfo, unsigned int* puArgErr);

    /////////////////////////////////////////////////////////////////////////
    // IOleCommandTarget
    //
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                             OLECMDTEXT *pCmdText); 
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                      VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

    /////////////////////////////////////////////////////////////////////////
    // IStoreCallback methods
    //
    STDMETHODIMP OnBegin(STOREOPERATIONTYPE tyOperation, LPSTOREOPERATIONINFO pOpInfo, IOperationCancel *pCancel);
    STDMETHODIMP OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
    STDMETHODIMP OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
    STDMETHODIMP CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
    STDMETHODIMP OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
    STDMETHODIMP OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
    STDMETHODIMP GetParentWindow(DWORD dwReserved, HWND *phwndParent);

    /////////////////////////////////////////////////////////////////////////
    // ITimeoutCallback
    //
    STDMETHODIMP OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

    /////////////////////////////////////////////////////////////////////////
    // IIdentityChangeNotify
    //
    STDMETHODIMP QuerySwitchIdentities();
    STDMETHODIMP SwitchIdentities();
    STDMETHODIMP IdentityInformationChanged(DWORD dwType);

private:
    /////////////////////////////////////////////////////////////////////////
    // Message Handling
    //
    INT_PTR DlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos, BOOL fSystemMenu);
    void OnGetMinMaxInfo(HWND hwnd, LPMINMAXINFO lpmmi);
    void OnWinIniChange(HWND hwnd, LPCTSTR lpszSectionName);
    void OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags);
    void OnDestroy(HWND hwnd);
    void OnPaint(HWND hwnd);
    LRESULT OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);

    HRESULT CmdOpen(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdOpenFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdReplyForward(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCancelMessage(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdFindNow(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdStop(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdReset(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdBrowseForFolder(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdBlockSender(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCreateRule(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT CmdCombineAndDecode(DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    static INT_PTR CALLBACK ExtFindMsgDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    BOOL    _IsFindEnabled(HWND hwnd);
    void    _ShowResults(HWND hwnd);
    void    _OnFindNow(HWND hwnd);
    FOLDERID _GetCurSel(HWND hwnd);
    void    _StartFind(FOLDERID idFolder, BOOL fSubFolders);

    BOOL    _GetFindValues(HWND hwnd, FINDINFO *pfi);
    void    _SetFindValues(HWND hwnd, FINDINFO *pfi);
    void    _FreeFindInfo(FINDINFO *pfi);
    void    _SetFindIntlFont(HWND hwnd);

    void    _InitSizingInfo(HWND hwnd);

    /////////////////////////////////////////////////////////////////////////
    // Private Class Information
    //
private:
    // Basic Information
    ULONG               m_cRef;
    HWND                m_hwnd;
    FINDINFO            m_rFindInfo;
    HWND                m_hwndList;
    HTIMEOUT            m_hTimeout;
    HACCEL              m_hAccel;

    // Groovy Interface Pointers
    CStatusBar         *m_pStatusBar;    
    IMessageList       *m_pMsgList;
    IOleCommandTarget  *m_pMsgListCT;
    IOperationCancel   *m_pCancel;
    CPumpRefCount      *m_pPumpRefCount;
    HWNDLIST            m_hlDisabled;

    // Sizing information
    int                 m_xBtn;
    int                 m_yBrowse;
    int                 m_dxBtnGap;
    int                 m_dxBtn;
    int                 m_yBtn;
    int                 m_dyBtn;
    int                 m_cxEdit;
    int                 m_xEdit;
    int                 m_cyEdit;
    int                 m_yView;
    int                 m_cxDlgDef;
    int                 m_cyDlgFull;
    int                 m_xIncSub;
    int                 m_yIncSub;
    int                 m_cxFolder;
    int                 m_cxStatic;

    // State
    BOOL                m_fShowResults;
    BOOL                m_fAbort;
    BOOL                m_fClose;
    BOOL                m_fInProgress;
    ULONG               m_ulPct;
    BOOL                m_fFindComplete;

    POINT               m_ptDragMin;
    HICON               m_hIcon,
                        m_hIconSm;

    DWORD               m_dwCookie;
    BOOL                m_fProgressBar,
                        m_fInternal;
    DWORD               m_dwIdentCookie;
    
    // For View.Current View menu
    CViewMenu          *m_pViewMenu;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fldrprop.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldrprop.h
//
//  PURPOSE:    Contains the control ID's and prototypes for the folder
//              and group property sheets
//


#ifndef __FLDRPROP_H__
#define __FLDRPROP_H__

// Dialog control ID's
#define IDC_FOLDERNAME_EDIT                         1001 
#define IDC_GROUPNAME_STATIC                        1002 
#define IDC_STATUS_STATIC                           1003 
#define IDC_LASTVIEWED_STATIC                       1004 
#define IDC_FOLDER_ICON                             1005 
#define IDC_FOLDER_FILE                             1006

//
//  FUNCTION:   GroupProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified group.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the newsgroup
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL GroupProp_Create(HWND hwndParent, FOLDERID idFolder, BOOL fUpdatePage = FALSE);


//
//  FUNCTION:   FolderProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified folder.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the folder
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL FolderProp_Create(HWND hwndParent, FOLDERID idFolder);


#endif // __FLDRPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fldrprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldrprop.cpp
//
//  PURPOSE:    Implements the property sheets for news groups and mail 
//              folders.
//

#include "pch.hxx"
#include "resource.h"
#include "fldrprop.h"
#include <optres.h>
#include <shlwapi.h>
#include "storutil.h"
#include "storecb.h"
#include "newsdlgs.h"
#include "shared.h"
#include "demand.h"

/////////////////////////////////////////////////////////////////////////////
// Private types
//

   
// FOLDERPROP_INFO
//
// This struct contains the information needed to invoke and display the info
// on a property sheet for a mail folder.
typedef struct
    {
    //LPTSTR          pszFolder;
    //CIMAPFolderMgr *pFM;
    //LPCFOLDERIDLIST pfidl;
    FOLDERID        idFolder;
    HICON           hIcon;
    BOOL            fDirty;
    } FOLDERPROP_INFO, *PFOLDERPROP_INFO;
  
    
// GROUPPROP_INFO
// 
// This struct contains the information needed to invoke and display the info
// on a property sheet for a news group.
typedef struct 
    {
    LPTSTR          pszServer;
    LPTSTR          pszGroup;
    FOLDERID        idFolder;
    //LPCFOLDERIDLIST pfidl;
    //CSubList       *pSubList;
    HICON           hIcon;
    } GROUPPROP_INFO, *PGROUPPROP_INFO;

/////////////////////////////////////////////////////////////////////////////
// Private function prototypes
//    
INT_PTR CALLBACK GroupProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam);
INT_PTR CALLBACK GroupProp_UpdateDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam);
INT_PTR CALLBACK FolderProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam);
INT_PTR CALLBACK NewsProp_CacheDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                    LPARAM lParam);
BOOL FolderProp_GetFolder(HWND hwnd, PFOLDERPROP_INFO pfpi, FOLDERID idFolder);
                                    
/////////////////////////////////////////////////////////////////////////////

//
//  FUNCTION:   GroupProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified group.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the newsgroup
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL GroupProp_Create(HWND hwndParent, FOLDERID idFolder, BOOL fUpdatePage)
    {
    GROUPPROP_INFO gpi;
    BOOL fReturn;
    HIMAGELIST himl, himlSmall;
    HICON hIcon, hIconSmall;
    FOLDERINFO Folder;
    FOLDERINFO Store;
    LONG iIcon;
    PROPSHEETPAGE psp[3], *ppsp;
    PROPSHEETHEADER psh;
    
    Assert(IsWindow(hwndParent));
    
    fReturn = FALSE;

    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return FALSE;

    if (FAILED(GetFolderStoreInfo(Folder.idFolder, &Store)))
        {
        g_pStore->FreeRecord(&Folder);
        return FALSE;
        }

    iIcon = GetFolderIcon(&Folder);

    // TODO: we should probably just have a global image list for this...
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFoldersLarge), 32, 0, RGB(255, 0, 255));
    if (himl != NULL)
        {
        hIcon = ImageList_GetIcon(himl, GetFolderIcon(&Folder), ILD_NORMAL);
        if (hIcon != NULL)
            {
            himlSmall = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
            if (himlSmall != NULL)
                {
                hIconSmall = ImageList_GetIcon(himlSmall, iIcon, ILD_NORMAL);
                if (hIconSmall != NULL)
                    {
                    gpi.pszServer = Store.pszName;
                    gpi.pszGroup = Folder.pszName;
                    gpi.idFolder = idFolder;
                    gpi.hIcon = hIcon;
    
                    ppsp = psp;

                    ZeroMemory(psp, sizeof(psp));
                    ppsp->dwSize = sizeof(PROPSHEETPAGE);
                    ppsp->dwFlags = PSP_DEFAULT;
                    ppsp->hInstance = g_hLocRes;
                    ppsp->pszTemplate = MAKEINTRESOURCE(iddGroupProp_General);
                    ppsp->pfnDlgProc = GroupProp_GeneralDlgProc;
                    ppsp->lParam = (LPARAM) &gpi;
                    ppsp++;

                    if (!!(Folder.dwFlags & FOLDER_SUBSCRIBED))
                    {
                        ppsp->dwSize = sizeof(PROPSHEETPAGE);
                        ppsp->dwFlags = PSP_DEFAULT;
                        ppsp->hInstance = g_hLocRes;
                        ppsp->pszTemplate = MAKEINTRESOURCE(iddGroupProp_Update);
                        ppsp->pfnDlgProc = GroupProp_UpdateDlgProc;
                        ppsp->lParam = (LPARAM) &gpi;
                        ppsp++;
                    }
                    else
                    {
                        fUpdatePage = FALSE;
                    }

                    ppsp->dwSize = sizeof(PROPSHEETPAGE);
                    ppsp->dwFlags = PSP_DEFAULT;
                    ppsp->hInstance = g_hLocRes;
                    ppsp->pszTemplate = MAKEINTRESOURCE(iddNewsProp_Cache);
                    ppsp->pfnDlgProc = NewsProp_CacheDlgProc;
                    ppsp->lParam = (LPARAM) &gpi;
                    ppsp++;

                    psh.dwSize = sizeof(PROPSHEETHEADER);
                    psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_PROPTITLE | PSH_USEPAGELANG;
                    psh.hwndParent = hwndParent;
                    psh.hInstance = g_hLocRes;
                    psh.hIcon = hIconSmall;
                    psh.pszCaption = gpi.pszGroup;
                    psh.nPages = (int) (ppsp - psp);
                    psh.nStartPage = fUpdatePage ? 1 : 0;
                    psh.ppsp = psp;
    
                    fReturn = (0 != PropertySheet(&psh));

                    DestroyIcon(hIconSmall);
                    }
                ImageList_Destroy(himlSmall);
                }
            DestroyIcon(hIcon);
            }
        ImageList_Destroy(himl);
        }

    g_pStore->FreeRecord(&Folder);
    g_pStore->FreeRecord(&Store);

    return (fReturn);
    }

//
//  FUNCTION:   FolderProp_Create()
//
//  PURPOSE:    Invokes a property sheet which displays properties for the
//              specified folder.
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the window that should be the dialog's 
//                        parent.
//      <in> pfidl      - fully qualified pidl to the folder
//
//  RETURN VALUE:
//      TRUE  - The dialog was successfully displayed
//      FALSE - The dialog failed.
//
BOOL FolderProp_Create(HWND hwndParent, FOLDERID idFolder)
    {
    FOLDERPROP_INFO fpi = {0};
    GROUPPROP_INFO gpi = {0};
    BOOL fReturn;
    HIMAGELIST himl, himlSmall;
    HICON hIcon, hIconSmall;
    LONG iIcon;
    FOLDERINFO Folder;
    PROPSHEETPAGE psp[3], *ppsp;
    PROPSHEETHEADER psh;
    
    Assert(IsWindow(hwndParent));

    fReturn = FALSE;

    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return FALSE;

    iIcon = GetFolderIcon(&Folder);

    // TODO: we should probably just have a global image list for this...
    himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFoldersLarge), 32, 0, RGB(255, 0, 255));
    if (himl != NULL)
        {
        hIcon = ImageList_GetIcon(himl, iIcon, ILD_NORMAL);
        if (hIcon != NULL)
            {
            himlSmall = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbFolders), 16, 0, RGB(255, 0, 255));
            if (himlSmall != NULL)
                {
                hIconSmall = ImageList_GetIcon(himlSmall, iIcon, ILD_NORMAL);
                if (hIconSmall != NULL)
                    {
                    if (FolderProp_GetFolder(hwndParent, &fpi, idFolder))
                        {
                        fpi.hIcon = hIcon;    
                        fpi.fDirty = FALSE;
                        fpi.idFolder = idFolder;
        
                        ppsp = psp;

                        ZeroMemory(psp, sizeof(psp));
                        ppsp->dwSize = sizeof(PROPSHEETPAGE);
                        ppsp->dwFlags = PSP_DEFAULT;
                        ppsp->hInstance = g_hLocRes;
                        ppsp->pszTemplate = MAKEINTRESOURCE(iddFolderProp_General);
                        ppsp->pfnDlgProc = FolderProp_GeneralDlgProc;
                        ppsp->lParam = (LPARAM) &fpi;
                        ppsp++;

                        if (Folder.tyFolder != FOLDER_LOCAL)
                        {
                            gpi.hIcon = fpi.hIcon;
                            gpi.idFolder = fpi.idFolder;

                            ppsp->dwSize = sizeof(PROPSHEETPAGE);
                            ppsp->dwFlags = PSP_DEFAULT;
                            ppsp->hInstance = g_hLocRes;
                            ppsp->pszTemplate = MAKEINTRESOURCE(iddFolderProp_Update);
                            ppsp->pfnDlgProc = GroupProp_UpdateDlgProc;
                            ppsp->lParam = (LPARAM) &gpi;
                            ppsp++;

                            ppsp->dwSize = sizeof(PROPSHEETPAGE);
                            ppsp->dwFlags = PSP_DEFAULT;
                            ppsp->hInstance = g_hLocRes;
                            ppsp->pszTemplate = MAKEINTRESOURCE(iddNewsProp_Cache);
                            ppsp->pfnDlgProc = NewsProp_CacheDlgProc;
                            ppsp->lParam = (LPARAM) &gpi;
                            ppsp++;
                        }

                        psh.dwSize = sizeof(PROPSHEETHEADER);
                        psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_PROPTITLE | PSH_USEPAGELANG;
                        psh.hwndParent = hwndParent;
                        psh.hInstance = g_hLocRes;
                        psh.hIcon = hIconSmall;
                        psh.pszCaption = Folder.pszName;
                        psh.nPages = (int) (ppsp - psp);
                        psh.nStartPage = 0;
                        psh.ppsp = psp;
    
                        fReturn = (0 != PropertySheet(&psh));
                        }
                    DestroyIcon(hIconSmall);
                    }
                ImageList_Destroy(himlSmall);
                }
            DestroyIcon(hIcon);
            }
        ImageList_Destroy(himl);
        }

    g_pStore->FreeRecord(&Folder);

    return (fReturn);
    }


INT_PTR CALLBACK GroupProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam)
    {
    PGROUPPROP_INFO pgpi = (PGROUPPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];
    FOLDERINFO Folder;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stuff the group name and server name into the dialog's extra bytes
            pgpi = (PGROUPPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pgpi);

            // Intl Stuff
            SetIntlFont(GetDlgItem(hwnd, IDC_FOLDER_FILE));
            
            // Fill in what blanks we know
            SetDlgItemText(hwnd, IDC_GROUPNAME_STATIC, pgpi->pszGroup);
            
            // Put a default value into the string first
            AthLoadString(idsGroupPropStatusDef, szBuffer, ARRAYSIZE(szBuffer));

            // Get the folder info
            if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
            {
                // Is there a file
                if (Folder.pszFile)
                {
                    // Locals
                    CHAR szRootDir[MAX_PATH];

                    // Get the store root
                    if (SUCCEEDED(GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir))))
                    {
                        // Locals
                        CHAR szFilePath[MAX_PATH + MAX_PATH];

                        // Make the file path
                        if (SUCCEEDED(MakeFilePath(szRootDir, Folder.pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath))))
                            SetDlgItemText(hwnd, IDC_FOLDER_FILE, szFilePath);
                    }
                }

                // Load the status string and fill in the blanks
                AthLoadString(idsFolderPropStatus, szRes, ARRAYSIZE(szRes));

                // Format the string
                wsprintf(szBuffer, szRes, Folder.cMessages, Folder.cUnread);                        

                // Cleanup
                g_pStore->FreeRecord(&Folder);
            }

            // Set the group status info
            SetDlgItemText(hwnd, IDC_STATUS_STATIC, szBuffer);            
            
            // Set the icon correctly
            SendDlgItemMessage(hwnd, IDC_FOLDER_ICON, STM_SETICON, (WPARAM)pgpi->hIcon, 0);
            return (TRUE);
        }
    
    return (FALSE);    
    }


INT_PTR CALLBACK GroupProp_UpdateDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                      LPARAM lParam)
    {
    PGROUPPROP_INFO pgpi = (PGROUPPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    BOOL fEnabled;
    DWORD dwFlags;
    FOLDERINFO Folder;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stuff the group name and server name into the dialog's extra bytes
            pgpi = (PGROUPPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pgpi);

            // Get the Folder Info
            if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
            {
                fEnabled = (Folder.dwFlags & (FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL));

                Button_SetCheck(GetDlgItem(hwnd, IDC_GET_CHECK), fEnabled);

                Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
                Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
                Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);

                // Check the right radio button
                if (fEnabled)
                {
                    if (Folder.dwFlags & FOLDER_DOWNLOADHEADERS)
                        Button_SetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), TRUE);
                    else if (Folder.dwFlags & FOLDER_DOWNLOADNEW)
                        Button_SetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), TRUE);
                    else if (Folder.dwFlags & FOLDER_DOWNLOADALL)
                        Button_SetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), TRUE);
                }
                else
                {
                    Button_SetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), TRUE);
                }

                g_pStore->FreeRecord(&Folder);
            }
            return (TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case IDC_GET_CHECK:
                    // Check to see whether this is actually checked or not
                    fEnabled = Button_GetCheck(GET_WM_COMMAND_HWND(wParam, lParam));

                    // Enable or disable the radio buttons
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO), fEnabled);
                    Button_Enable(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO), fEnabled);
                    
                    // Fall through...

                case IDC_NEWHEADERS_RADIO:
                case IDC_NEWMSGS_RADIO:
                case IDC_ALLMSGS_RADIO:
                    PropSheet_Changed(GetParent(hwnd), hwnd);
                    return (TRUE);

                }
            return (FALSE);

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) 
                {
                case PSN_APPLY:
                    if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
                    {
                        dwFlags = Folder.dwFlags;

                        // Remove the previous flags
                        Folder.dwFlags &= ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL);

                        if (Button_GetCheck(GetDlgItem(hwnd, IDC_GET_CHECK)))
                            {
                            if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWHEADERS_RADIO)))
                                Folder.dwFlags |= FOLDER_DOWNLOADHEADERS;
                            else if (Button_GetCheck(GetDlgItem(hwnd, IDC_NEWMSGS_RADIO)))
                                Folder.dwFlags |= FOLDER_DOWNLOADNEW;
                            else if (Button_GetCheck(GetDlgItem(hwnd, IDC_ALLMSGS_RADIO)))
                                Folder.dwFlags |= FOLDER_DOWNLOADALL;
                            }

                        if (Folder.dwFlags != dwFlags)
                            g_pStore->UpdateRecord(&Folder);

                        g_pStore->FreeRecord(&Folder);
                    }

                    PropSheet_UnChanged(GetParent(hwnd), hwnd);
                    SetDlgMsgResult(hwnd, WM_NOTIFY, PSNRET_NOERROR);
                    return (TRUE);
                }
            return (FALSE);

        }

    return (FALSE);
    }

                                       
INT_PTR CALLBACK FolderProp_GeneralDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                        LPARAM lParam)
    {
    PFOLDERPROP_INFO pfpi = (PFOLDERPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    TCHAR szBuffer[CCHMAX_STRINGRES];
    TCHAR szRes[CCHMAX_STRINGRES];
    TCHAR szRes2[64];
    TCHAR szFldr[CCHMAX_FOLDER_NAME + 1];
    FOLDERINFO Folder;
    HRESULT hr;
    HWND hwndEdit;
    HLOCK hLock;
    
    switch (uMsg)
        {
        case WM_INITDIALOG:
            // Stuff the folder name into the dialog's extra bytes
            pfpi = (PFOLDERPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pfpi);
            
            // Put a default value into the string
            AthLoadString(idsFolderPropStatusDef, szBuffer, ARRAYSIZE(szBuffer));
            
            hwndEdit = GetDlgItem(hwnd, IDC_FOLDERNAME_EDIT);
            SetIntlFont(hwndEdit);
            SetIntlFont(GetDlgItem(hwnd, IDC_FOLDER_FILE));

            if (SUCCEEDED(g_pStore->GetFolderInfo(pfpi->idFolder, &Folder)))
                {
                if (Folder.pszFile)
                    {
                    CHAR szRootDir[MAX_PATH];

                    if (SUCCEEDED(GetStoreRootDirectory(szRootDir, ARRAYSIZE(szRootDir))))
                        {
                        CHAR szFilePath[MAX_PATH + MAX_PATH];

                        if (SUCCEEDED(MakeFilePath(szRootDir, Folder.pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath))))
                            SetDlgItemText(hwnd, IDC_FOLDER_FILE, szFilePath);
                        }
                    }

                AthLoadString(idsFolderPropStatus, szRes, ARRAYSIZE(szRes));
                wsprintf(szBuffer, szRes, Folder.cMessages, Folder.cUnread);

                if (FOLDER_IMAP != Folder.tyFolder && Folder.tySpecial == FOLDER_NOTSPECIAL)
                    {
                    SendMessage(hwndEdit, EM_SETREADONLY, (WPARAM)FALSE, 0);
                    SendMessage(hwndEdit, EM_LIMITTEXT, CCHMAX_FOLDER_NAME, 0);
                    }

                SetWindowText(hwndEdit, Folder.pszName);
                g_pStore->FreeRecord(&Folder);
                }
            
            // Set the group status info
            SetDlgItemText(hwnd, IDC_STATUS_STATIC, szBuffer);            
            
            // Need to set the specified icon
            SendDlgItemMessage(hwnd, IDC_FOLDER_ICON, STM_SETICON, (WPARAM)pfpi->hIcon, 0);

            pfpi->fDirty = FALSE;
            return (TRUE);            
            
        case WM_COMMAND:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                {
                PropSheet_Changed(GetParent(hwnd), hwnd);
                pfpi->fDirty = TRUE;
                }
            break;
            
        case WM_NOTIFY:
            NMHDR* pnmhdr = (NMHDR*) lParam;
            
            switch (pnmhdr->code)
                {
                case PSN_APPLY:
                    // Bug #13121 - Only try to change the folder name if the
                    //              the propsheet is dirty.
                    if (pfpi->fDirty)
                        {
                        GetDlgItemText(hwnd, IDC_FOLDERNAME_EDIT, szFldr, sizeof(szFldr) / sizeof(TCHAR));

                        if (!FAILED(hr = RenameFolderProgress(hwnd, pfpi->idFolder, szFldr, NOFLAGS)))
                            SetDlgMsgResult(hwnd, WM_NOTIFY, PSNRET_NOERROR);
                        else
                            AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrRenameFld), hr);

                        pfpi->fDirty = FALSE;
                        }
                    return (0);
                    
                case PSN_KILLACTIVE:
                    SetDlgMsgResult(hwnd, WM_NOTIFY, 0L);
                    return (0);
                }
            break;
        }
    
    return (FALSE);    
    }

//
//  FUNCTION:   FolderProp_GetFolder()
//
//  PURPOSE:    This function is used by the Folder Property dialog to get
//              the store object and folder handle for callers who did not
//              already provide this information.
//
//  PARAMETERS:
//      <in> hwnd - Handle of the property sheet window
//      <in> pfpi - Pointer to the FOLDERPROP_INFO struct that stores the prop
//                  sheet's information.
//      <in> pfidl - fully qualified pidl of folder
//      <in> pfidlLeaf - leaf pidl of folder
//
//  RETURN VALUE:
//      TRUE  - The information was retrieved
//      FALSE - The information was not available
//
BOOL FolderProp_GetFolder(HWND hwnd, PFOLDERPROP_INFO pfpi, FOLDERID idFolder)
    {
    pfpi->idFolder = idFolder;
    return (TRUE);    
    }

INT_PTR CALLBACK NewsProp_CacheDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    FOLDERINFO Folder;
    PGROUPPROP_INFO pgpi = (PGROUPPROP_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
    CHAR szRes[255];
    CHAR szMsg[255 + 255];
    
    switch (uMsg)
        {
        case WM_INITDIALOG:

            // Stuff the group name and server name into the dialog's extra bytes
            pgpi = (PGROUPPROP_INFO) ((PROPSHEETPAGE*) lParam)->lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, (LPARAM) pgpi);
            SendDlgItemMessage(hwnd, IDC_FOLDER_ICON, STM_SETICON, (WPARAM)pgpi->hIcon, 0);

            // Disable the Reset button
            EnableWindow(GetDlgItem(hwnd, idbReset), FALSE);

            // Get the folder information
            if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
            {
                // News 
                if (FOLDER_NEWS == Folder.tyFolder)
                {
                    // If Its news, enable the 
                    EnableWindow(GetDlgItem(hwnd, idbReset), TRUE);
                }

                // Free the Folder Infp
                g_pStore->FreeRecord(&Folder);
            }

            // Locals
            DisplayFolderSizeInfo(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder);

            // Done
            break;
            
        case WM_COMMAND:
            BOOL fRet = FALSE;
            UINT nCmd = GET_WM_COMMAND_ID(wParam, lParam);
            HCURSOR hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));  // Bug 12513. Need to disable button, when process command

            switch (GET_WM_COMMAND_ID(wParam, lParam))
                {
                case idbCompactCache:
                    {
                        if (SUCCEEDED(CleanupFolder(GetParent(hwnd), RECURSE_INCLUDECURRENT, pgpi->idFolder, CLEANUP_COMPACT)))
                            DisplayFolderSizeInfo(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder);
                        fRet = TRUE;
                    }
                    break;

                case idbRemove:
                case idbReset:
                case idbDelete:
                    {
                        // Get Folder Info
                        if (SUCCEEDED(g_pStore->GetFolderInfo(pgpi->idFolder, &Folder)))
                        {
                            // Get Command
                            UINT                idCommand=GET_WM_COMMAND_ID(wParam, lParam);
                            UINT                idString;
                            CLEANUPFOLDERTYPE   tyCleanup;

                            // Remove
                            if (idbRemove == idCommand)
                            {
                                idString = idsConfirmDelBodies;
                                tyCleanup = CLEANUP_REMOVEBODIES;
                            }

                            // Delete
                            else if (idbDelete == idCommand)
                            {
                                idString = idsConfirmDelMsgs;
                                tyCleanup = CLEANUP_DELETE;
                            }

                            // Remove
                            else
                            {
                                Assert(idbReset == idCommand);
                                idString = idsConfirmReset;
                                tyCleanup = CLEANUP_RESET;
                            }

                            // Load the String
                            AthLoadString(idString, szRes, ARRAYSIZE(szRes));
        
                            // Format with the Folder Name
                            wsprintf(szMsg, szRes, Folder.pszName);

                            // Confirm
                            if (IDYES == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szMsg, NULL, MB_YESNO | MB_ICONEXCLAMATION))
                            {
                                // Cleanup the Folder
                                if (SUCCEEDED(CleanupFolder(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder, tyCleanup)))
                                {
                                    // Reset Information
                                    DisplayFolderSizeInfo(hwnd, RECURSE_INCLUDECURRENT, pgpi->idFolder);
                                }
                            }

                            // Free Folder Information
                            g_pStore->FreeRecord(&Folder);
                        }

                        // Message Handled
                        fRet = TRUE;
                    }
                    break;
                }
            SetCursor(hCur);

            if(fRet)
                return 1;
            break;
        }
    return (FALSE);    
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fldbar.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     fldbar.h
//
//  PURPOSE:    Defines the CFolderBar class
//

#ifndef __FLDBAR_H__
#define __FLDBAR_H__

#include "browser.h"
#include "treeview.h"
#include "conman.h"

// Mouse Over Mode enum for DoMouseOver()
#ifndef WIN16
typedef enum MOMODE
#else
enum MOMODE
#endif
{ 
    MO_NORMAL = 0,      // DoMouseOver called in response to WM_MOUSEMOVE
    MO_DRAGOVER,        // in response to IDropTarget::DragEnter/DragOver
    MO_DRAGLEAVE,       // in response to IDropTarget::DragLeave
    MO_DRAGDROP         // in response to IDropTarget::Drop
};

class CFlyOutScope;

class CFolderBar : public IDockingWindow, 
                   public IObjectWithSite, 
                   public IDropTarget,
                   public IConnectionNotify
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and initialization
    CFolderBar();
    ~CFolderBar();
    
    HRESULT HrInit(IAthenaBrowser *pBrowser);

    /////////////////////////////////////////////////////////////////////////
    // IUnknown methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    
    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow methods
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite methods
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    /////////////////////////////////////////////////////////////////////////
    // IDropTarget methods
    virtual STDMETHODIMP DragEnter(IDataObject* pDataObject, DWORD grfKeyState, 
                                        POINTL pt, DWORD* pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject* pDataObject, DWORD grfKeyState,
                                   POINTL pt, DWORD* pdwEffect);

    /////////////////////////////////////////////////////////////////////////
    // CFolderBar members
    HRESULT SetCurrentFolder(FOLDERID idFolder);
    void ScopePaneDied(void);
    void KillScopeCloseTimer(void);
    void Update(BOOL fDisplayNameChanged, BOOL fShowDropDownIndicator);
    void KillScopeDropDown(void);
    void SetScopeCloseTimer(void);
    void SetFolderText(LPCTSTR pszText);

    //IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify(CONNNOTIFY  nCode, LPVOID pvData, CConnectionManager *pConMan);

    
private:
    /////////////////////////////////////////////////////////////////////////
    // Drawing
    void InvalidateFolderName(void);
    void SetFolderName(LPCTSTR pszFolderName);
    void Recalc(HDC hDC, LPCRECT prcAvailableSpace, BOOL fSizeChange);
    BOOL FEnsureIcon(void);
    void GetFolderNameRect(LPRECT prc);
    BOOL FDropDownEnabled(void);
    HFONT GetFont(UINT idsFont, int nWeight = FW_NORMAL);
    HFONT GetFont(LPTSTR pszFace, LONG lSize, int nWeight = FW_NORMAL);
    int	GetXChildIndicator(void);
    int	GetYChildIndicator(void);
    void DoMouseOver(LPPOINT ppt, MOMODE moMode);
    void KillHoverTimer(void);
    void DoMouseClick(POINT pt, DWORD grfKeyState);
    HRESULT HrShowScopeFlyOut(void);


    /////////////////////////////////////////////////////////////////////////
    // Window methods
    static LRESULT CALLBACK FolderWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                          LPARAM lParam);
    static LRESULT CALLBACK FrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam);
    
    void OnPaint(HWND hwnd);
    void OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
    void OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
    void OnTimer(HWND hwnd, UINT id);

    /////////////////////////////////////////////////////////////////////////
    // Misc Data
    ULONG               m_cRef;                 // Reference count
    FOLDERID            m_idFolder;             // Current Folder Id

    // Flags
    BOOL                m_fShow;                // TRUE if we're visible
    BOOL                m_fRecalc;              // TRUE if we should call Recalc() before painting
    BOOL                m_fSmallFolderBar;      // TRUE if we're smaller than big
    BOOL                m_fHighlightIndicator;  // TRUE if the mouse is over out button
    BOOL                m_fHoverTimer;          // TRUE if the hover timer is active
    BOOL                m_fDropDownIndicator;   // TRUE if the 'v' is beside the folder name

    // Interfaces we groove with
    IDockingWindowSite *m_pSite;                // Site pointer
    IAthenaBrowser     *m_pBrowser;             // Browser that owns us
    
    // Handy handles
    HWND                m_hwnd;                 // Our window
    HWND                m_hwndFrame;            // Our frame window 
    HWND                m_hwndParent;           // Our parent's window
    HWND                m_hwndScopeDropDown;    // Handle of the drop down scope pane
    
    // Crayons, markers, paper, etc.
    HFONT               m_hfFolderName;         // Folder name font
    HFONT               m_hfViewText;           // View text font
    HICON               m_hIconSmall;           // Small Icon

    // Sizes etc. for drawing, sizing, and fun!
    int                 m_cyControl,
                        m_dyChildIndicator,
                        m_dyIcon,
                        m_dyViewText,
                        m_dyFolderName,
                        m_cxFolderNameRight;
    RECT                m_rcFolderName,
                        m_rcFolderNamePlsu,
                        m_rcViewText;
    UINT                m_nFormatFolderName,
                        m_nFormatViewText;
    
    // The text we display
    LPTSTR              m_pszFolderName;        // Folder Name
    int                 m_cchFolderName;        // Size of m_pszFolderName
    LPTSTR              m_pszViewText;          // View text
    int                 m_cchViewText;          // Size of m_pszViewText

    // Drag & Drop stuff
    IDataObject        *m_pDataObject;          // Pointer to the IDataObject being dragged over us
    IDropTarget        *m_pDTCur;
    DWORD               m_dwEffectCur;
    DWORD               m_grfKeyState;
    };

    
inline void CFolderBar::ScopePaneDied()
    { m_hwndScopeDropDown = NULL; InvalidateFolderName(); }



class CFlyOutScope 
    {
    friend CFolderBar;

public:
    CFlyOutScope();
    ~CFlyOutScope();
    ULONG AddRef(void);
    ULONG Release(void);
    HRESULT HrDisplay(IAthenaBrowser *pBrowser, CFolderBar *pFolderBar, HWND hwndParent, HWND *phwndScope);
    void Destroy(void);

protected:
    static LRESULT CALLBACK FlyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
    void OnNcDestroy(HWND hwnd);
    void OnPaint(HWND hwnd);
    void OnSize(HWND hwnd, UINT state, int cx, int cy);
    void OnDestroy(HWND hwnd);
    
private:
    ULONG           m_cRef;
    IAthenaBrowser *m_pBrowser;
    CFolderBar     *m_pFolderBar;
    BOOL            m_fResetParent;
    CTreeView      *m_pTreeView;
    HWND            m_hwnd;
    HWND            m_hwndParent;
    HWND            m_hwndTree;
    HWND            m_hwndFolderBar;
    HWND            m_hwndFocus;
    HWND            m_hwndTreeParent;
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\flagconv.cpp ===
//
//  Flag conversion routines...
//  One wishes we didn't need these
//

#include <pch.hxx>
#include "imsgcont.h"
#include "imnxport.h"

DWORD DwConvertSCFStoARF(DWORD dwSCFS)
{
    register DWORD dwRet = 0;

    if (dwSCFS & SCFS_NOSECUI)
        dwRet |= ARF_NOSECUI;
    return dwRet;
}

//***************************************************************************
// Function: DwConvertARFtoIMAP
//
// Purpose:
//   This function takes ARF_* message flags (such as ARF_READ) and maps
// them to IMAP_MSG_FLAGS such as IMAP_MSG_SEEN.
//
// Arguments:
//   DWORD dwARFFlags [in] - ARF_* flags to convert.
//
// Returns:
//   DWORD with the appropriate IMAP_MSG_FLAGS set.
//***************************************************************************
DWORD DwConvertARFtoIMAP(DWORD dwARFFlags)
{
    DWORD dwIMAPFlags = 0;

    Assert(0x0000001F == IMAP_MSG_ALLFLAGS); // Update this function if we get new IMAP flags

    if (dwARFFlags & ARF_REPLIED)
        dwIMAPFlags |= IMAP_MSG_ANSWERED;

    if (dwARFFlags & ARF_FLAGGED)
        dwIMAPFlags |= IMAP_MSG_FLAGGED;

    if (dwARFFlags & ARF_ENDANGERED)
        dwIMAPFlags |= IMAP_MSG_DELETED;

    if (dwARFFlags & ARF_READ)
        dwIMAPFlags |= IMAP_MSG_SEEN;

    if (dwARFFlags & ARF_UNSENT)
        dwIMAPFlags |= IMAP_MSG_DRAFT;

    return dwIMAPFlags;
} // DwConvertARFtoIMAP



//***************************************************************************
// Function: DwConvertIMAPtoARF
//
// Purpose:
//   This function takes IMAP message flags (such as IMAP_MSG_DELETED) and
// maps them to flags suitable for storing in the proptree cache
// (eg, ARF_ENDANGERED).
//
// Arguments:
//   DWORD dwIMAPFlags [in] - IMAP message flags (IMAP_MSGFLAGS) to convert.
//
// Returns:
//   DWORD with appropriate ARF flags set.
//***************************************************************************
DWORD DwConvertIMAPtoARF(DWORD dwIMAPFlags)
{
    DWORD dwARFFlags = 0;

    Assert(0x0000001F == IMAP_MSG_ALLFLAGS); // Update this function if we get more IMAP flags

    if (dwIMAPFlags & IMAP_MSG_ANSWERED)
        dwARFFlags |= ARF_REPLIED;

    if (dwIMAPFlags & IMAP_MSG_FLAGGED)
        dwARFFlags |= ARF_FLAGGED;

    if (dwIMAPFlags & IMAP_MSG_DELETED)
        dwARFFlags |= ARF_ENDANGERED;

    if (dwIMAPFlags & IMAP_MSG_SEEN)
        dwARFFlags |= ARF_READ;

    if (dwIMAPFlags & IMAP_MSG_DRAFT)
        dwARFFlags |= ARF_UNSENT;

    return dwARFFlags;
} // DwConvertIMAPtoARF



DWORD DwConvertIMAPMboxToFOLDER(DWORD dwImapMbox)
{
    DWORD dwRet = 0;

    AssertSz(IMAP_MBOX_ALLFLAGS == 0x0000000F, "This function needs updating!");

    if (IMAP_MBOX_NOINFERIORS & dwImapMbox)
        dwRet |= FOLDER_NOCHILDCREATE;

    if (IMAP_MBOX_NOSELECT & dwImapMbox)
        dwRet |= FOLDER_NOSELECT;

    return dwRet;
} // DwConvertIMAPMboxToFOLDER



MESSAGEFLAGS ConvertIMFFlagsToARF(DWORD dwIMFFlags)
{
    MESSAGEFLAGS    mfResult = 0;

    // IMF_ATTACHMENTS
    if (ISFLAGSET(dwIMFFlags, IMF_ATTACHMENTS))
        FLAGSET(mfResult, ARF_HASATTACH);

    // IMF_SIGNED
    if (ISFLAGSET(dwIMFFlags, IMF_SIGNED))
        FLAGSET(mfResult, ARF_SIGNED);

    // IMF_ENCRYPTED
    if (ISFLAGSET(dwIMFFlags, IMF_ENCRYPTED))
        FLAGSET(mfResult, ARF_ENCRYPTED);

    // IMF_VOICEMAIL
    if (ISFLAGSET(dwIMFFlags, IMF_VOICEMAIL))
        FLAGSET(mfResult, ARF_VOICEMAIL);

    // IMF_NEWS
    if (ISFLAGSET(dwIMFFlags, IMF_NEWS))
        FLAGSET(mfResult, ARF_NEWSMSG);

    return mfResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fontnsc.cpp ===
/*
 *      f o n t n s c . c p p
 *
 *      Implementation of a richedit format bar
 *
 *      Owner: AnthonyF
 *      taken from Capone: brettm
 */

#include "pch.hxx"
#include "resource.h"
#include "fonts.h"
#include <assert.h>
#ifndef WIN16
#include <wchar.h>
#endif
#include <shlwapi.h>
#include "strconst.h"
#include "demand.h"
#include "menures.h"

#ifdef WIN16
#ifdef PRINTER_FONTTYPE
#undef PRINTER_FONTTYPE
#endif
#define PRINTER_FONTTYPE   0
#endif

/*
 *  m a c r o s
 */
#define GETINDEX(m) (DWORD) (((((m) & 0xff000000) >> 24) & 0x000000ff))
#define MAKEINDEX(b, l) (((DWORD)(l) & 0x00ffffff) | ((DWORD)(b) << 24))

/*
 *  c o n s t a n t s
 */
#define NFONTSIZES 7
#define TEMPBUFSIZE 30

/*
 *  t y p e d e f s
 */
INT CALLBACK NEnumFontNameProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam);

/*
 *  g l o b a l   d a t a
 */

/*
 *      Color table for dropdown on toolbar.  Matches COMMDLG colors
 *      exactly.
 */

static DWORD rgrgbColors[] = {
    RGB_AUTOCOLOR,        // "AUTO"},
    RGB(  0,   0, 0),     // "BLACK"},   
    RGB(128,   0, 0),     // "DARK RED"},
    RGB(  0, 128, 0),     // "DARK YELLOW"},
    RGB(128, 128, 0),     // "DARK BLUE"},
    RGB(  0,   0, 128),   // "DARK BLUE"},
    RGB(128,   0, 128),   // "DARK PURPLE"},
    RGB(  0, 128, 128),   // "DARK AQUA"},
    RGB(128, 128, 128),   // "DARK GREY"}, 
    RGB(192, 192, 192),   // "LIGHT GREY"},  
    RGB(255,   0, 0),     // "LIGHT RED"}, 
    RGB(  0, 255, 0),     // "LIGHT GREEN"}, 
    RGB(255, 255, 0),     // "LIGHT YELLOW"},
    RGB(  0,   0, 255),   // "LIGHT BLUE"},  
    RGB(255,   0, 255),   // "LIGHT PURPLE"},
    RGB(  0, 255, 255),   // "LIGHT AQUA"}, 
    RGB(255, 255, 255)   // "WHITE"}    
};

/*
 *  p r o t o t y p e s
 */

HRESULT HrCreateColorMenu(ULONG idmStart, HMENU* pMenu, BOOL fUseAuto)
{
    DWORD               irgb;
    DWORD               mniColor;

    if(pMenu == NULL)
        return E_INVALIDARG;

    *pMenu = CreatePopupMenu();

    if (*pMenu == NULL)
        return E_OUTOFMEMORY;

    // Add the COLORREF version of each entry into the menu
    for (irgb = fUseAuto ? 0 : 1, mniColor=idmStart;
             irgb < sizeof(rgrgbColors)/sizeof(DWORD);
             ++irgb, ++mniColor)
    {
        AppendMenu(*pMenu, MF_ENABLED|MF_OWNERDRAW, mniColor, (LPCSTR)IntToPtr(MAKEINDEX(irgb, rgrgbColors[irgb])));
    }
    return NOERROR;
}


HRESULT HrCreateComboColor(HWND hCombo)
{
    DWORD               irgb;
    DWORD               mniColor;
    LRESULT         lr;

    if(hCombo == NULL)
        return E_INVALIDARG;

    ComboBox_SetExtendedUI(hCombo, TRUE);

    for (irgb = 0; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb)
    {
        lr = ComboBox_AddString(hCombo, (LPCSTR)" ");
        if (lr == CB_ERR || lr == CB_ERRSPACE)
                break;

        ComboBox_SetItemData(hCombo, LOWORD(lr), (LPCSTR)IntToPtr(MAKEINDEX(irgb, rgrgbColors[irgb])));
    }
    return NOERROR;
}


void Color_WMDrawItem(LPDRAWITEMSTRUCT pdis, INT iColor, BOOL fBackground)
{
    HBRUSH                          hbr;
    WORD                            dx, dy, dxBorder;
    RECT                            rc;
    TCHAR                           szColor[MAX_PATH]={0};
    DWORD                           rgbBack, rgbText;
    UINT                            id = pdis->itemID;
    ULONG                           index = 0;

    switch(iColor)
    {
    case iColorMenu:
        if(pdis->itemState&ODS_SELECTED)
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_MENU));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_MENUTEXT));
        }
        break;
    case iColorCombo:
        if(pdis->itemState&ODS_SELECTED)
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
        else
        {
            rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
            rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        }
        break;
    default:
        Assert(FALSE);
    }

    /* compute coordinates of color rectangle and draw it */
    dxBorder  = (WORD) GetSystemMetrics(SM_CXBORDER);
    if(iColor == iColorMenu)
        dx    = (WORD) GetSystemMetrics(SM_CXMENUCHECK);
    else
        dx    = (WORD) GetSystemMetrics(SM_CXBORDER);

    dy        = (WORD) GetSystemMetrics(SM_CYBORDER);
    rc.top    = pdis->rcItem.top + dy;
    rc.bottom = pdis->rcItem.bottom - dy;
    rc.left   = pdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    index = GETINDEX(pdis->itemData);
    LoadString(g_hLocRes, index + idsAutoColor,
                       szColor, sizeof(szColor)/sizeof(TCHAR));
    SelectObject(pdis->hDC, HGetSystemFont(FNT_SYS_MENU));

    ExtTextOut(pdis->hDC, rc.right + 2*dxBorder,
                       pdis->rcItem.top, ETO_OPAQUE, &pdis->rcItem,
                       szColor, lstrlen(szColor), NULL);


    switch(iColor)
    {
    case iColorMenu:
        if(pdis->itemID == ID_FORMAT_COLORAUTO) // auto color item
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
        else if (pdis->itemID == ID_BACK_COLOR_AUTO)
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
        else
            hbr = CreateSolidBrush((DWORD) (pdis->itemData & 0x00ffffff));

        break;
    case iColorCombo:
        if (pdis->itemID == 0) // auto color item
            {
            if (fBackground)
                hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            else
                hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
            }
        else
            hbr = CreateSolidBrush((DWORD)(pdis->itemData & 0x00ffffff));
        break;
    default:
        Assert(FALSE);
    }

    if (hbr)
    {
        hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
        Rectangle(pdis->hDC, rc.left, rc.top, rc.right, rc.bottom);
        DeleteObject(SelectObject(pdis->hDC, hbr));
    }

    // draw radio check.
    if(iColor == iColorMenu && pdis->itemState&ODS_CHECKED)
    {
        WORD left, top, radius;

        if(pdis->itemState&ODS_SELECTED)
            hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHTTEXT));
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));

        if (hbr)
        {
            hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
            left = (WORD) (pdis->rcItem.left + GetSystemMetrics(SM_CXMENUCHECK) / 2);
            top = (WORD) (rc.top + (rc.bottom - rc.top) / 2);
            radius = (WORD) (GetSystemMetrics(SM_CXMENUCHECK) / 4);
            Ellipse(pdis->hDC, left-radius, top-radius, left+radius, top+radius);
            DeleteObject(SelectObject(pdis->hDC, hbr));
        }
    }

    SetTextColor(pdis->hDC, rgbText);
    SetBkColor(pdis->hDC, rgbBack);
}


void Color_WMMeasureItem(HDC hdc, LPMEASUREITEMSTRUCT pmis, INT iColor)
{
    HFONT                           hfontOld = NULL;
    TEXTMETRIC                      tm;
    UINT                            id = pmis->itemID;
    TCHAR                           szColor[MAX_PATH]={0};

    switch(iColor)
    {
    case iColorMenu:
        hfontOld = (HFONT)SelectObject(hdc, HGetSystemFont(FNT_SYS_MENU));
        break;
    case iColorCombo:
        hfontOld = (HFONT)SelectObject(hdc, HGetSystemFont(FNT_SYS_ICON));
        break;
    default:
        Assert(FALSE);
    }

    GetTextMetrics(hdc, &tm);
    SelectObject(hdc, hfontOld);

    ULONG index = GETINDEX(pmis->itemData);
    LoadString(g_hLocRes, index + idsAutoColor,
                       szColor, sizeof(szColor)/sizeof(TCHAR));

    pmis->itemHeight = tm.tmHeight + 2 * GetSystemMetrics(SM_CYBORDER);
    pmis->itemWidth = GetSystemMetrics(SM_CXMENUCHECK) +
                      2 * GetSystemMetrics(SM_CXBORDER) + 
                      2 * tm.tmHeight +
                      (lstrlen(szColor) + 2) *tm.tmAveCharWidth;
}


// displays the colorpopup menu at the specified point. if clrf if NULL, then no clrf is returned
// but instead the appropriate WM_COMMAND is dispatched to the parent window
HRESULT HrColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf)
{
    HRESULT     hr=NOERROR;
    int         tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;

    if(hmenuColor == NULL)
        return E_INVALIDARG;

    if(pclrf)
         tpm|=TPM_RETURNCMD;

    int id = TrackPopupMenu(hmenuColor, tpm,pt.x, pt.y, 0, hwndParent, NULL);

    switch(id)
        {
        case 1:
            return NOERROR;
        case 0:
            return E_FAIL;
        case -1:
            return E_FAIL;

        case ID_FORMAT_COLORAUTO:
        case ID_FORMAT_COLOR1:
        case ID_FORMAT_COLOR2:
        case ID_FORMAT_COLOR3:
        case ID_FORMAT_COLOR4:
        case ID_FORMAT_COLOR5:
        case ID_FORMAT_COLOR6:
        case ID_FORMAT_COLOR7:
        case ID_FORMAT_COLOR8:
        case ID_FORMAT_COLOR9:
        case ID_FORMAT_COLOR10:
        case ID_FORMAT_COLOR11:
        case ID_FORMAT_COLOR12:
        case ID_FORMAT_COLOR13:
        case ID_FORMAT_COLOR14:
        case ID_FORMAT_COLOR15:
        case ID_FORMAT_COLOR16:
            AssertSz(pclrf, "this HAS to be set to get this id back...");
            *pclrf=rgrgbColors[id-ID_FORMAT_COLORAUTO];
            return NOERROR;

        default:
            AssertSz(0, "unexpected return from TrackPopupMenu");
        }

    return E_FAIL;
}


DWORD GetColorRGB(INT index)
{
    return rgrgbColors[index];
}

INT GetColorIndex(INT rbg)
{
    INT iFound = -1;
    for(int irgb = 1; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb)
    {
        if((rbg&0x00ffffff) == (LONG)rgrgbColors[irgb])
        {
            iFound = irgb;
            break;
        }
    }
    return iFound;
}


// fill font name combo box
void FillFontNames(HWND hwndCombo)
{
    LOGFONT lf = {0};
    HDC hdc;

    // reset the contents of the combo
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    hdc = GetDC(NULL);
    if (hdc)
    {
        //to enumerate all styles of all fonts for the default character set
        lf.lfFaceName[0] = '\0';
        lf.lfCharSet = DEFAULT_CHARSET;

        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)NEnumFontNameProcEx, (LPARAM)hwndCombo, 0);
        ReleaseDC(NULL, hdc);
    }
}


INT CALLBACK NEnumFontNameProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam)
{
    LONG        l;
    HWND        hwndCombo = (HWND)lParam;

    Assert(hwndCombo);

    // skip vertical fonts for OE
    if (plf->elfLogFont.lfFaceName[0]=='@')
        return TRUE;    

    // if the font is already listed, don't re-list it
    if(ComboBox_FindStringExact(hwndCombo, -1, plf->elfLogFont.lfFaceName) != -1)
        return TRUE;

    l = ComboBox_AddString(hwndCombo, plf->elfLogFont.lfFaceName);
    if (l!=-1)
        ComboBox_SetItemData(hwndCombo, l, nFontType);

    return TRUE;
}


void FillSizes(HWND hwndSize)
{
    LONG                            id;
    TCHAR                           szBuf[TEMPBUFSIZE];
    *szBuf = 0;
    LRESULT                         lr;

    // Empty the current list
    SendMessage(hwndSize, CB_RESETCONTENT, 0, 0);

    for (id = idsFontSize0; id < NFONTSIZES + idsFontSize0; ++id)
    {
        LoadString(g_hLocRes, id, szBuf, sizeof(szBuf));
        lr = SendMessage(hwndSize, CB_ADDSTRING, 0, (LPARAM) szBuf);
        if (lr == CB_ERR || lr == CB_ERRSPACE)
           break;
    }

}


// size of pszColor must be bigger than 7
HRESULT HrFromIDToRBG(INT id, LPWSTR pwszColor, BOOL fBkColor)
{
    DWORD         cr;

    if(id<0 || id>16 || !pwszColor)
        return E_INVALIDARG;

    if (id == 0)
    {
        if (fBkColor)
            cr = GetSysColor(COLOR_WINDOW);
        else
            cr = GetSysColor(COLOR_WINDOWTEXT);
    }
    else
        cr = rgrgbColors[id];

    return HrGetStringRBG(cr, pwszColor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fontnsc.h ===
#ifndef _FONTNSC_H
#define _FONTNSC_H

HRESULT HrCreateColorMenu(ULONG idmStart, HMENU* pMenu, BOOL fUseAuto);
HRESULT HrCreateComboColor(HWND hCombo);
void Color_WMDrawItem(LPDRAWITEMSTRUCT pdis, INT iColor, BOOL fBackground=FALSE);
DWORD GetColorRGB(INT index);
void Color_WMMeasureItem(HDC hdc, LPMEASUREITEMSTRUCT pmis, INT iColor);
HRESULT HrColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf);
INT GetColorIndex(INT rbg);
void FillFontNames(HWND hwndCombo);
INT CALLBACK NEnumFontNameProc(LOGFONT *plf, TEXTMETRIC *ptm, INT nFontType, LPARAM lParam);
void FillSizes(HWND hwndSize);
HRESULT HrFromIDToRBG(INT id, LPWSTR pwszColor, BOOL fBkColor);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fonts.h ===
// =================================================================================
// F O N T S . H
// =================================================================================
#ifndef __FONTS_H
#define __FONTS_H

// =================================================================================
// Depends On
// =================================================================================

#include "mimeole.h"

// from richedit.h
typedef struct _charformat CHARFORMAT;
struct BODYOPTINFO_tag;

// =================================================================================
// User defined charset map table
// =================================================================================
typedef struct  tagCHARSETMAPTBL
{
    TCHAR szOrginalCharsetStr[32];
    DWORD uiCodePage;
    BOOL  bEditDelete;
} CHARSETMAPTBL, *LPCHARSETMAPTBL ;

// =================================================================================
// Prototypes
// =================================================================================
HFONT HGetSystemFont(FNTSYSTYPE fnttype);
HFONT HGetCharSetFont(FNTSYSTYPE fnttype, HCHARSET hCharset);

VOID SetListViewFont (HWND hwndList, HCHARSET hCharset, BOOL fUpdate);
HCHARSET GetListViewCharset();

UINT GetICP(UINT acp);
HRESULT InitMultiLanguage(void);
void DeinitMultiLanguage(void);
HMENU CreateMimeLanguageMenu(BOOL bMailNote, BOOL bReadNote, UINT cp);
HCHARSET GetMimeCharsetFromMenuID(int nIdm);
HCHARSET GetMimeCharsetFromCodePage(UINT uiCodePage );
int SetMimeLanguageCheckMark(UINT uiCodePage, int index);
void GetRegistryFontInfo(LPCSTR lpszKeyPath);
INT  GetFontSize();
BOOL CheckIntlCharsetMap(HCHARSET hCharset, DWORD *pdwCodePage);
BOOL IntlCharsetMapLanguageCheck(HCHARSET hOldCharset, HCHARSET hNewCharset);
UINT CustomGetCPFromCharset(HCHARSET hCharset, BOOL bReadNote);
BOOL IntlCharsetMapDialogBox(HWND hwndDlg);
int IntlCharsetConflictDialogBox(void);
int GetIntlCharsetLanguageCount(void);
HRESULT HrGetComposeFontString(LPSTR rgchFont, BOOL fMail);
HRESULT HrGetStringRBG(INT rgb, LPWSTR pwszColor);
HRESULT HrGetRBGFromString(INT* pRBG, LPWSTR pwszColor);
//UINT GetDefaultCodePageFromRegistry(void);
void ReadSendMailDefaultCharset(void);
void WriteSendMailDefaultCharset(void);
INT PointSizeToHTMLSize(INT iPointSize);
INT HTMLSizeToPointSize(INT iHTMLSize);
void _GetMimeCharsetLangString(BOOL bWebCharset, UINT uiCodePage, LPINT pnIdm, LPTSTR lpszString, int nSize );
BOOL SetSendCharSetDlg(HWND hwndDlg);
BOOL CheckAutoSelect(UINT * CodePage);

HRESULT FontToCharformat(HFONT hFont, CHARFORMAT *pcf);



#endif // __FONTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\goptions.h ===
#ifndef _INC_GOPTIONS_H
#define _INC_GOPTIONS_H

#include <msoeopt.h>

#ifdef DEBUG

#define OPT_EXPIRE_MINUTES          (OPT_BASE +   300)

#endif // DBUG

extern IOptionBucketEx *g_pOpt;

class COptNotify;
extern COptNotify *g_pOptNotify;

#ifdef DEFINE_OPTION_STRUCTS
static const RECT c_rcNotePosDefault = {50, 20, 580, 450};

#define ROOT_REG    0
#define MAIL_REG    1
#define NEWS_REG    2
#define RULES_REG   3
#define COPTREGKEY  4

LPCSTR c_rgszOptRegKey[COPTREGKEY] =
    {
    NULL,
    c_szMail,
    c_szNews,
    c_szRules
    };

#define OPT_GLOBAL(opt,type,key,val,def,cb,lo,hi,fn) {opt, type, key, val, (LPCSTR)(def), cb, lo, hi, fn},

const OPTIONINFO c_rgOptInfo[] = {

// !!!To add new options, you must keep the "OPT_..." ordinals in ascending order!!!
//         OPTION,                  VARTYPE,  REG KEY,    REG VALUE,              DEFAULT,    DEF SIZE,   MIN,MAX,VALIDATE FUNC
OPT_GLOBAL(OPT_TIPOFTHEDAY,         VT_UI4,   ROOT_REG,   c_szRegTipOfTheDay,     TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWSTATUSBAR,       VT_UI4,   ROOT_REG,   c_szShowStatus,         TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWTREE,            VT_UI4,   ROOT_REG,   c_szShowTree,           TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_TREEWIDTH,           VT_UI4,   ROOT_REG,   c_szTreeWidth,          200,        0,          0,  0,  0)
OPT_GLOBAL(OPT_EXPAND_UNREAD,       VT_UI4,   ROOT_REG,   c_szRegExpandUnread,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BROWSERPOS,          VT_BLOB,  ROOT_REG,   c_szBrowserPos,         NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWBODYBAR,         VT_UI4,   ROOT_REG,   c_szShowBodyBar,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_BODYBARPOS,          VT_UI4,   ROOT_REG,   c_szBodyBarPos,         0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_IMAPPURGE,           VT_UI4,   ROOT_REG,   c_szRegExpungeFolder,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_HIDEFOLDERBAR,       VT_UI4,   ROOT_REG,   c_szRegHideFolderBar,   FALSE,      0,          0,  0,  0)
// spelling options
OPT_GLOBAL(OPT_SPELLALWAYSSUGGEST,  VT_UI4,   ROOT_REG,   c_szRegAlwaysSuggest,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNORENUMBER,   VT_UI4,   ROOT_REG,   c_szRegIgnoreNumbers,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREUPPER,    VT_UI4,   ROOT_REG,   c_szRegIgnoreUpper,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREPROTECT,  VT_UI4,   ROOT_REG,   c_szRegIgnoreProtect,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLCHECKONSEND,    VT_UI4,   ROOT_REG,   c_szRegCheckOnSend,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREDBCS,     VT_UI4,   ROOT_REG,   c_szRegIgnoreDBCS,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLIGNOREURL,      VT_UI4,   ROOT_REG,   c_szRegIgnoreURL,       TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELLCHECKONTYPE,    VT_UI4,   ROOT_REG,   c_szRegCheckOnType,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_CHECKEDMAILACCOUNTS, VT_UI4,   MAIL_REG,   c_szRegCheckedAccounts, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_CHECKEDNEWSACCOUNTS, VT_UI4,   NEWS_REG,   c_szRegCheckedAccounts, FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_AUTO_IMAGE_INLINE,   VT_UI4,   ROOT_REG,   c_szRegAutoImageInline, AUTO_INLINE_FLAT, 0,    0,  0,  0)
OPT_GLOBAL(OPT_USEAUTOCOMPLETE,     VT_UI4,   ROOT_REG,   c_szRegUseAutoComplete, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_REPLYINORIGFMT,      VT_UI4,   ROOT_REG,   c_szRegReplyInOrigFmt,  TRUE,       0,          0,  0,  0)

OPT_GLOBAL(OPT_RASCONNDETAILS,      VT_UI4,   ROOT_REG,   c_szRasConnDetails,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_CONNECTION,   VT_LPSTR, ROOT_REG,   c_szRegDialupConnection,NULL,       0,          0,  CCHMAX_CONNECTOID - 1,  0)
OPT_GLOBAL(OPT_DIALUP_WARN_SWITCH,  VT_UI4,   ROOT_REG,   c_szRegWarnSwitch,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_HANGUP_DONE,  VT_UI4,   ROOT_REG,   c_szRegHangupDone,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_LAST_START,   VT_LPSTR, ROOT_REG,   c_szRegDialupLastStart, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_DIALUP_HANGUP_WITHOUT_DIAL,VT_UI4, ROOT_REG, c_szRegHangupNoDial,  FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_SPOOLERDLGPOS,       VT_BLOB,  ROOT_REG,   c_szRegSpoolerDlgPos,   NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SPOOLERTACK,         VT_UI4,   ROOT_REG,   c_szRegSpoolerTack,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DIAL_DURING_POLL,    VT_UI4,   ROOT_REG,   c_szRegDialDuringPoll,  DO_NOT_DIAL,      0,          0,  0,  0)

OPT_GLOBAL(OPT_LAUNCH_INBOX,        VT_UI4,   ROOT_REG,   c_szRegLaunchInbox,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITYZONE,        VT_UI4,   ROOT_REG,   c_szRegSecurityZone,    DEF_SECURITYZONE, 0,    0,  0,  0)
OPT_GLOBAL(OPT_HARDCODEDHDRS,       VT_UI4,   ROOT_REG,   c_szRegHardCodedHdrs,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SMTPUSEIPFORHELO,    VT_UI4,   ROOT_REG,   c_szRegSmtpUseIpForHelo,FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_FIND_THREAD,         VT_UI4,   ROOT_REG,   c_szRegFindThread,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_FIND_FILTER_STATE,   VT_UI4,   ROOT_REG,   c_szRegFindFilter,      1,          0,          0,  0,  0)

OPT_GLOBAL(OPT_NEWMAILSOUND,        VT_UI4,   MAIL_REG,   c_szOptNewMailSound,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_PURGEWASTE,          VT_UI4,   MAIL_REG,   c_szPurgeWaste,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_ATTACHVCARD,    VT_UI4,   MAIL_REG,   c_szRegAttachVCard,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_VCARDNAME,      VT_LPSTR, MAIL_REG,   c_szRegVCardName,       NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILHYBRIDVIEW,      VT_UI4,   MAIL_REG,   c_szRegShowHybrid,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITYZONELOCKED,  VT_UI4,   ROOT_REG,   c_szRegSecurityZoneLocked, FALSE,   0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILCXSPLIT,         VT_UI4,   MAIL_REG,   c_szRegSplitVertPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILCYSPLIT,         VT_UI4,   MAIL_REG,   c_szRegSplitHorzPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILSPLITDIR,        VT_UI4,   MAIL_REG,   c_szRegSplitDir,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEPOS,         VT_BLOB,  MAIL_REG,   c_szRegNotePos,         &c_rcNotePosDefault, sizeof(RECT), 0, 0, 0)
OPT_GLOBAL(OPT_SENDIMMEDIATE,       VT_UI4,   MAIL_REG,   c_szRegSendImmediate,   TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEEDWELCOMEMSG,      VT_UI4,   MAIL_REG,   c_szNeedWelcomeMsg,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_INCOMDEFENCODE,      VT_UI4,   ROOT_REG,   c_szIncDefEncode,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILSHOWHEADERINFO,  VT_UI4,   MAIL_REG,   c_szMailShowHeaderInfo, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_IMAP4LOGFILE,   VT_LPSTR, MAIL_REG,   c_szRegImap4LogFile,    NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILINDENT,          VT_UI4,   MAIL_REG,   c_szRegIndentChar,      DEF_INDENTCHAR, 0,      0,  0,  0)
OPT_GLOBAL(OPT_MAILLOG,             VT_UI4,   MAIL_REG,   c_szLogPop3,            DEF_LOGMAIL,0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILSMTPLOGFILE,     VT_LPSTR, MAIL_REG,   c_szSmtpLogFile,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILPOP3LOGFILE,     VT_LPSTR, MAIL_REG,   c_szPop3LogFile,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_SEND_HTML,      VT_UI4,   MAIL_REG,   c_szMsgSendHtml,        TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_MIME, VT_UI4,   MAIL_REG,   c_szMsgPlainMime,       TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_ENCODE, VT_UI4, MAIL_REG,   c_szMsgPlainEncoding,   IET_7BIT,   0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_ENCODE,VT_UI4,   MAIL_REG,   c_szMsgHTMLEncoding,    IET_QP,     0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_LINE_WRAP, VT_UI4, MAIL_REG,c_szMsgPlainLineWrap,   DEF_AUTOWRAP, 0,        AUTOWRAP_MIN, AUTOWRAP_MAX, 0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_LINE_WRAP, VT_UI4, MAIL_REG, c_szMsgHTMLLineWrap,    DEF_AUTOWRAP, 0,        AUTOWRAP_MIN, AUTOWRAP_MAX, 0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_ALLOW_8BIT, VT_UI4, MAIL_REG,c_szMsgHTMLAllow8bit,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_PLAIN_ALLOW_8BIT, VT_UI4, MAIL_REG, c_szMsgPlainAllow8bit,FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_LANG_VIEW,      VT_UI4,   MAIL_REG,   c_szLangView,           0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_VIEW_SET_DEFAULT, VT_UI4, MAIL_REG,   c_szLangViewSetDefault, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_AUTOADDTOWABONREPLY, VT_UI4, MAIL_REG,c_szAutoAddToWABOnReply,TRUE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_DEFENCRYPTSYMCAPS, VT_BLOB, MAIL_REG, c_szRegDefEncryptSymcaps, NULL,     0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_SENDINLINEIMAGES, VT_UI4, MAIL_REG,   c_szRegSendInlineImages,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_MSG_HTML_INDENT_REPLY, VT_UI4, MAIL_REG, c_szRegIndentReply,  TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_DIGSIGNMESSAGES,VT_UI4,   MAIL_REG,   c_szRegDigSign,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_ENCRYPTMESSAGES,VT_UI4,   MAIL_REG,   c_szRegEncrypt,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_INCLUDECERT,    VT_UI4,   MAIL_REG,   c_szRegIncludeCert,     TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_LOGIMAP4,       VT_UI4,   MAIL_REG,   c_szRegLogImap4,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_THREAD,         VT_UI4,   MAIL_REG,   c_szRegThreadArticles,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SAVESENTMSGS,        VT_UI4,   MAIL_REG,   c_szOptnSaveInSentItems,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_INCLUDEMSG,          VT_UI4,   MAIL_REG,   c_szRegIncludeMsg,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_POLLFORMSGS,         VT_UI4,   MAIL_REG,   c_szRegPollForMail,     30 * 60 * 1000, 0,      1 * 60 * 1000, 480 * 60 * 1000,0) // milliseconds
OPT_GLOBAL(OPT_MARKASREAD,          VT_UI4,   MAIL_REG,   c_szMarkPreviewAsRead,  5,          0,          0,  60, 0)
OPT_GLOBAL(OPT_MAIL_FONTCOLOR,      VT_UI4,   MAIL_REG,   c_szRegFontColor,       0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTFACE,       VT_LPSTR, MAIL_REG,   c_szRegFontFace,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTSIZE,       VT_UI4,   MAIL_REG,   c_szRegFontSize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTBOLD,       VT_UI4,   MAIL_REG,   c_szRegFontBold,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTITALIC,     VT_UI4,   MAIL_REG,   c_szRegFontItalic,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_FONTUNDERLINE,  VT_UI4,   MAIL_REG,   c_szRegFontUnderline,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_USESTATIONERY,  VT_UI4,   MAIL_REG,   c_szRegUseStationery,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_STATIONERYNAME, VT_LPSTR, MAIL_REG,   c_szRegStationeryName,  NULL,       0,          0,  0,  0)

OPT_GLOBAL(OPT_DOWNLOADCHUNKS,      VT_UI4,   NEWS_REG,   c_szRegDownload,        DEF_DOWNLOADCHUNKS, 0,  50, 1000, 0)
OPT_GLOBAL(OPT_NOTIFYGROUPS,        VT_UI4,   NEWS_REG,   c_szRegNotifyNewGroups, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MARKALLREAD,         VT_UI4,   NEWS_REG,   c_szRegMarkAllRead,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_ATTACHVCARD,    VT_UI4,   NEWS_REG,   c_szRegAttachVCard,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_VCARDNAME,      VT_LPSTR, NEWS_REG,   c_szRegVCardName,       NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_XPORT_LOG,      VT_UI4,   NEWS_REG,   c_szLog,                FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSHYBRIDVIEW,      VT_UI4,   NEWS_REG,   c_szRegShowHybrid,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSCXSPLIT,         VT_UI4,   NEWS_REG,   c_szRegSplitVertPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSCYSPLIT,         VT_UI4,   NEWS_REG,   c_szRegSplitHorzPct,    50,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSSPLITDIR,        VT_UI4,   NEWS_REG,   c_szRegSplitDir,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSDLGPOS,          VT_BLOB,  NEWS_REG,   c_szRegNewsDlgPos,      NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSDLGCOLUMNS,      VT_BLOB,  NEWS_REG,   c_szRegNewsDlgColumns,  NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSSHOWHEADERINFO,  VT_UI4,   NEWS_REG,   c_szNewsShowHeaderInfo, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSNOTEADVREAD,     VT_UI4,   NEWS_REG,   c_szRegNewsNoteAdvRead, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSNOTEADVSEND,     VT_UI4,   NEWS_REG,   c_szRegNewsNoteAdvSend, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSMODERATOR,       VT_UI4,   NEWS_REG,   c_szRegNewsModerator,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSCONTROLHEADER,   VT_UI4,   NEWS_REG,   c_szRegNewsControlHeader, FALSE,    0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWSINDENT,          VT_UI4,   NEWS_REG,   c_szRegIndentChar,      DEF_INDENTCHAR, 0,      0,  0,  0)
OPT_GLOBAL(OPT_CACHEDELETEMSGS,     VT_UI4,   NEWS_REG,   c_szCacheDelMsgDays,    5,          0,          1,  999,0)
OPT_GLOBAL(OPT_CACHEREAD,           VT_UI4,   NEWS_REG,   c_szCacheRead,          FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_CACHECOMPACTPER,     VT_UI4,   NEWS_REG,   c_szCacheCompactPer,    20,         0,          5,  100,0)
OPT_GLOBAL(OPT_NEWSDLDLGPOS,        VT_BLOB,  NEWS_REG,   c_szRegDLDlgPos,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_SEND_HTML,      VT_UI4,   NEWS_REG,   c_szMsgSendHtml,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_MIME, VT_UI4,   NEWS_REG,   c_szMsgPlainMime,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_ENCODE, VT_UI4, NEWS_REG,   c_szMsgPlainEncoding,   IET_7BIT,   0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_ENCODE,VT_UI4,   NEWS_REG,   c_szMsgHTMLEncoding,    IET_QP,     0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_LINE_WRAP, VT_UI4, NEWS_REG,c_szMsgPlainLineWrap,   76,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_LINE_WRAP, VT_UI4, NEWS_REG, c_szMsgHTMLLineWrap,    76,         0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_ALLOW_8BIT, VT_UI4, NEWS_REG,c_szMsgHTMLAllow8bit,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_PLAIN_ALLOW_8BIT, VT_UI4, NEWS_REG, c_szMsgPlainAllow8bit,FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_LANG_VIEW,      VT_UI4,   NEWS_REG,   c_szLangView,           0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_VIEW_SET_DEFAULT, VT_UI4, NEWS_REG,   c_szLangViewSetDefault, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_THREAD,         VT_UI4,   NEWS_REG,   c_szRegThreadArticles,  TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_AUTOEXPAND,          VT_UI4,   NEWS_REG,   c_szRegAutoExpand,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_AUTOFILLPREVIEW,     VT_UI4,   NEWS_REG,   c_szRegNewsFillPreview, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_SENDINLINEIMAGES, VT_UI4, NEWS_REG,   c_szRegSendInlineImages,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTCOLOR,      VT_UI4,   NEWS_REG,   c_szRegFontColor,       0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTFACE,       VT_LPSTR, NEWS_REG,   c_szRegFontFace,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTSIZE,       VT_UI4,   NEWS_REG,   c_szRegFontSize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTBOLD,       VT_UI4,   NEWS_REG,   c_szRegFontBold,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTITALIC,     VT_UI4,   NEWS_REG,   c_szRegFontItalic,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_FONTUNDERLINE,  VT_UI4,   NEWS_REG,   c_szRegFontUnderline,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_USESTATIONERY,  VT_UI4,   NEWS_REG,   c_szRegUseStationery,   FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_STATIONERYNAME, VT_LPSTR, NEWS_REG,   c_szRegStationeryName,  NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_MSG_HTML_INDENT_REPLY, VT_UI4, NEWS_REG, c_szRegIndentReply,  TRUE,       0,          0,  0,  0)

OPT_GLOBAL(OPT_ATHENA_RUNNING,      VT_UI4,   ROOT_REG,   c_szOERunning,          FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MIGRATION_PERFORMED, VT_UI4,   ROOT_REG,   c_szMigrationPerformed, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NO_SELF_ENCRYPT,     VT_UI4,   ROOT_REG,   c_szDontEncryptForSelf, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_LAST_MESSAGE,        VT_BLOB,  ROOT_REG,   c_szLastMsg,            NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_FINDER_POS,          VT_BLOB,  ROOT_REG,   c_szFindPos,            NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_OPAQUE_SIGN,         VT_UI4,   ROOT_REG,   c_szOpaqueSigning,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SPELL_LANGID,        VT_LPSTR, ROOT_REG,   c_szRegSpellLangID,     NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_TEST_MODE,           VT_UI4,   ROOT_REG,   c_szTestMode,           FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DUMP_FILE,           VT_LPSTR, ROOT_REG,   c_szDumpFile,           NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NO_SPLASH,           VT_UI4,   ROOT_REG,   c_szNoSplash,           FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_SHOW_NOTE_STATUSBAR, VT_UI4,   ROOT_REG,   c_szShowStatusbar,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_NOTE_FMTBAR,    VT_UI4,   ROOT_REG,   c_szShowFormatBar,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_ATTACH_VIEW_STYLE,   VT_UI4,   ROOT_REG,   c_szAttachViewStyle,    LVS_ICON,   0,          0,  0,  0)
OPT_GLOBAL(OPT_SIGNATURE_FLAGS,     VT_UI4,   ROOT_REG,   c_szSigFlags,           FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NOPREVIEW,           VT_UI4,   ROOT_REG,   c_szNoPreview,          FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SAVEATTACH_PATH,     VT_LPSTR, ROOT_REG,   c_szSaveAttachPath,     NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_ENVELOPES,      VT_UI4,   ROOT_REG,   c_szShowEnvelopes,      FALSE,      0,          0,  0,  0)

OPT_GLOBAL(OPT_AUTO_ADD_SENDERS_CERT_TO_WAB, VT_UI4, ROOT_REG, c_szAutoAddSendersCertToWAB, TRUE, 0,      0,  0,  0)
OPT_GLOBAL(OPT_VIEWSOURCETABS,      VT_UI4,   ROOT_REG,   c_szViewSrcTabs,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_ENCRYPT_WARN_BITS,  VT_UI4, MAIL_REG, c_szEncryptWarnBits,    0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_SOURCE_EDIT_COLORING,VT_UI4,   ROOT_REG,   c_szSourceEditColoring, TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MESSAGE_LIST_TIPS,   VT_UI4,   ROOT_REG,   c_szRegMsgListTips,     TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEADVREAD,     VT_UI4,   MAIL_REG,   c_szRegMailNoteAdvRead, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEADVSEND,     VT_UI4,   MAIL_REG,   c_szRegMailNoteAdvSend, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWOUTLOOKBAR,      VT_UI4,   ROOT_REG,   c_szRegShowOutlookBar,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NAVPANEWIDTH,        VT_UI4,   ROOT_REG,   c_szRegNavPaneWidth,    200,        0,          0,  0,  0)
OPT_GLOBAL(OPT_NAVPANESPLIT,        VT_UI4,   ROOT_REG,   c_szRegNavPaneSplit,    66,         0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOWCONTACTS,        VT_UI4,   ROOT_REG,   c_szRegShowContacts,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BACKGROUNDCOMPACT,   VT_UI4,   ROOT_REG,   c_szRegBackgroundCompact, TRUE,     0,          0,  0,  0)
OPT_GLOBAL(OPT_FILTERJUNK,          VT_UI4,   RULES_REG,  c_szRegFilterJunk,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_JUNKPCT,             VT_UI4,   RULES_REG,  c_szRegJunkPct,         2,          0,          0,  4,  0)
OPT_GLOBAL(OPT_DELETEJUNK,          VT_UI4,   RULES_REG,  c_szRegDeleteJunk,      FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_DELETEJUNKDAYS,      VT_UI4,   RULES_REG,  c_szRegDeleteJunkDays,  7,          0,          1,  999,  0)
OPT_GLOBAL(OPT_FILTERADULT,         VT_UI4,   RULES_REG,  c_szRegFilterAdult,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_LOGHTTPMAIL,    VT_UI4,   MAIL_REG,   c_szRegLogHTTPMail,     FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_HTTPMAILLOGFILE,VT_LPSTR, MAIL_REG,   c_szRegHTTPMailLogFile, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BASORT,              VT_UI4,   ROOT_REG,   c_szBASort,             0,          0,          0,  999, 0)
OPT_GLOBAL(OPT_WATCHED_COLOR,       VT_UI4,   ROOT_REG,   c_szRegWatchedColor,   10,          0,          0,  16,  0)
OPT_GLOBAL(OPT_POLLFORMSGS_ATSTARTUP, VT_UI4, MAIL_REG,   c_szRegCheckMailOnStart, TRUE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_EXCEPTIONS_WAB,      VT_UI4,   RULES_REG,  c_szExceptionsWAB,      TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_BUDDYLIST_CHECK,     VT_UI4,   RULES_REG,  c_szBLAutoLogon,        TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_CANCEL_ALL_NEWS,     VT_UI4,   NEWS_REG,   c_szRegGodMode,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_REVOKE_CHECK,        VT_UI4,   ROOT_REG,   c_szRevokeCheck,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_DELETED,        VT_UI4,   ROOT_REG,   c_szShowDeleted,        TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SEARCH_BODIES,       VT_UI4,   ROOT_REG,   c_szRegSearchBodies,    FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SUBJECT_THREADING,   VT_UI4,   ROOT_REG,   c_szRegSubjectThreading,TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SHOW_REPLIES,        VT_UI4,   ROOT_REG,   c_szShowReplies,        FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_VIEW_GLOBAL,         VT_UI4,   RULES_REG,  c_szRegGlobalView,      RULEID_INVALID,         0,  0,  0,  0)
OPT_GLOBAL(OPT_MDN_SEND_REQUEST,    VT_UI4,   ROOT_REG,   c_szRequestMDN,         FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURE_READ_RECEIPT, VT_UI4,   ROOT_REG,   c_szSecureRequestMDN,   0,                      0,  0,  0,  0)
OPT_GLOBAL(OPT_MDN_SEND_RECEIPT,    VT_UI4,   ROOT_REG,   c_szSendMDN,            MDN_PROMPTFOR_SENDRECEIPT,  0,  0,  0,  0)
OPT_GLOBAL(OPT_TO_CC_LINE_RCPT,     VT_UI4,   ROOT_REG,   c_szSendReceiptToList,          TRUE,       0,          0,  0,  0)
#ifdef SMIME_V3
OPT_GLOBAL(OPT_USE_LABELS,          VT_UI4,   MAIL_REG,   c_szRegUseLabels,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_POLICYNAME_SIZE,     VT_UI4,   MAIL_REG,   c_szRegPolSize,         0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_POLICYNAME_DATA,     VT_BLOB,  MAIL_REG,   c_szRegPolData,         NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_HAS_CLASSIFICAT,     VT_UI4,   MAIL_REG,   c_szRegHasClass,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_CLASSIFICAT_DATA,    VT_UI4,   MAIL_REG,   c_szRegClassData,       0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_PRIVACYMARK_SIZE,    VT_UI4,   MAIL_REG,   c_szRegPrivSize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_PRIVACYMARK_DATA,    VT_BLOB,  MAIL_REG,   c_szRegPrivData,        NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_CATEGORY_SIZE,       VT_UI4,   MAIL_REG,   c_szRegCategize,        0,          0,          0,  0,  0)
OPT_GLOBAL(OPT_CATEGORY_DATA,       VT_BLOB,  MAIL_REG,   c_szRegCategData,       NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SECREC_USE,          VT_UI4,   MAIL_REG,   c_szRegUseSecRec,       FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECREC_VERIFY,       VT_UI4,   MAIL_REG,   c_szRegVerifySecRec,    FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_MDN_SEC_RECEIPT,     VT_UI4,   MAIL_REG,   c_szSendSecMDN,         MDN_PROMPTFOR_SENDRECEIPT,  0,  0,  0,  0)
OPT_GLOBAL(OPT_SECREC_ENCRYPT,      VT_UI4,   MAIL_REG,   c_szRegEncryptSecRec,   FALSE,      0,          0,  0,  0)

#endif // SMIME_V3
OPT_GLOBAL(OPT_MAIL_STATIONERYNAMEW,VT_LPWSTR,MAIL_REG,   c_szRegStationeryNameW, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_STATIONERYNAMEW,VT_LPWSTR,NEWS_REG,   c_szRegStationeryNameW, NULL,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAIL_STATCONVERTED,  VT_UI4,   MAIL_REG,   c_szRegStatNameConverted,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_NEWS_STATCONVERTED,  VT_UI4,   NEWS_REG,   c_szRegStatNameConverted,  FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_RTL_MSG_DIR,         VT_UI4,   ROOT_REG,   c_szRegRtlMsgDir,       FALSE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_MAILNOTEPOSEX,       VT_BLOB,  MAIL_REG,   c_szRegNotePosEx,       NULL,       0,          0,  0,  0)

OPT_GLOBAL(OPT_SECURITY_MAPI_SEND,  VT_UI4,   MAIL_REG,   c_szRegAppSend,         TRUE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITY_MAPI_SEND_LOCKED, VT_UI4, MAIL_REG, c_szRegAppSendLocked,    FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITY_ATTACHMENT, VT_UI4,   MAIL_REG,   c_szRegSafeAttachments,    TRUE,       0,          0,  0,  0)
OPT_GLOBAL(OPT_SECURITY_ATTACHMENT_LOCKED, VT_UI4, MAIL_REG, c_szRegSafeAttachmentsLocked, FALSE,      0,          0,  0,  0)
OPT_GLOBAL(OPT_READ_IN_TEXT_ONLY,   VT_UI4,   ROOT_REG,   c_szRegSecReadPlainText, FALSE,     0,          0,  0,  0)
};
#endif // DEFINE_OPTION_STRUCTS

#ifndef OPTION_OFF

#define OPTION_OFF          0xffffffff

// signature option stuff
#define SIGTYPE_NONE            0
#define SIGTYPE_TEXT            1
#define SIGTYPE_FILE            2

#define SIGFLAG_AUTONEW         0x0001  // automatically add sig to new messages
#define SIGFLAG_AUTOREPLY       0x0002  // automatically add sig to reply/forward messages

enum
    {
    START_NO_CONNECT = 0,
    START_CONNECT,
    START_PROMPT
    };

enum
    {
    hybridNone = 0,
    hybridHoriz,
    hybridVert,
    hybridMax
    };

enum
    {
    AUTO_INLINE_OFF = 0,
    AUTO_INLINE_FLAT = 1,
    AUTO_INLINE_SLIDE = 2
    };

enum 
{
    DIAL_ALWAYS,
    DIAL_IF_NOT_OFFLINE,
    DO_NOT_DIAL
};

#define INDENTCHAR_NONE     0
#define DEF_INDENTCHAR      _T('>')
#define DEF_AUTOWRAP        76
#define AUTOWRAP_MIN        MIN_CBMAX_BODY_LINE
#define AUTOWRAP_MAX        132
#define DEF_NNTPPORT        119
#define DEF_SNEWSPORT       563
#define DEF_DOWNLOADCHUNKS  300
#define DEF_SECURITYZONE    URLZONE_UNTRUSTED
#define DEF_LOGMAIL         FALSE
#define AUTO_IMAGE_DELAY    2

#define MDN_SENDRECEIPT_AUTO        0x00000001
#define MDN_DONT_SENDRECEIPT        0x00000002
#define MDN_PROMPTFOR_SENDRECEIPT   0x00000004

class COptNotify : public IOptionBucketNotify
    {
    public:
        // ----------------------------------------------------------------------------
        // Construction
        // ----------------------------------------------------------------------------
        COptNotify(void);
        ~COptNotify(void);

        // -------------------------------------------------------------------
        // IUnknown Members
        // -------------------------------------------------------------------
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // -------------------------------------------------------------------
        // IOptionBucketNotify Members
        // -------------------------------------------------------------------
        STDMETHODIMP DoNotification(IOptionBucketEx *pBckt, HWND hwnd, PROPID id);

        // -------------------------------------------------------------------
        // COptNotify Members
        // -------------------------------------------------------------------
        HRESULT Register(HWND hwnd);
        HRESULT Unregister(HWND hwnd);

    private:
        LONG                m_cRef;
        int                 m_cHwnd;
        int                 m_cHwndBuf;
        HWND               *m_rgHwnd;
    };

#endif // OPTION_OFF

DWORD DwGetOption(PROPID id);
DWORD DwGetOptionDefault(PROPID id);
DWORD GetOption(PROPID id, void *pv, DWORD cb);
DWORD IDwGetOption(IOptionBucketEx *pOpt, PROPID id);
DWORD IDwGetOptionDefault(IOptionBucketEx *pOpt, PROPID id);
DWORD IGetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb);

BOOL SetDwOption(PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags);
BOOL SetOption(PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags);
BOOL ISetDwOption(IOptionBucketEx *pOpt, PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags);
BOOL ISetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags);

BOOL InitGlobalOptions(HKEY hkey, LPCSTR szRegOptRoot);
void DeInitGlobalOptions(void);

HRESULT OptionAdvise(HWND hwnd);
HRESULT OptionUnadvise(HWND hwnd);

LONG AthUserCreateKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG AthUserOpenKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult);
LONG AthUserDeleteKey(LPCSTR lpSubKey);
LONG AthUserGetValue(LPCSTR lpSubKey, LPCSTR lpValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG AthUserSetValue(LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData);
LONG AthUserDeleteValue(LPCSTR lpSubKey, LPCSTR lpValueName);

HKEY AthUserGetKeyRoot(void);
void AthUserGetKeyPath(LPSTR szKey, int cch);

#endif // _INC_GOPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\fonts.cpp ===
// =================================================================================
// F O N T S . C P P
// =================================================================================
#include "pch.hxx"
#include "fonts.h"
#include "multlang.h"
#include "xpcomm.h"
#include "strconst.h"
#include "mimeole.h"
#include "goptions.h"
#include "error.h"
#include "thormsgs.h"
#include "richedit.h"
#include "ibodyopt.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "mimeutil.h"
#include "optres.h"
#include "demand.h"
#include "menures.h"
#include "multiusr.h"

// this part creates a MIME COM object from MLAMG.DLL which gives us a consistent 
// language menu to be the same as IE browser
// HMENU CreateMimeLanguageMenu(void)
#include <inetreg.h>
#include <mlang.h>
#include "resource.h"


#define IGNORE_HR(x)    (x)
#define MIMEINFO_NAME_MAX   72
#define DEFAULT_FONTSIZE 2

// MLANG language menu items table
static PMIMECPINFO g_pMimeCPInfo = NULL;
static ULONG g_cMimeCPInfoCount = 0;
static DWORD g_cRefMultiLanguage = 0;

TCHAR   g_szMore[32];
#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
#define BREAK_ITEM 20
#define CP_UNDEFINED            UINT(-1)
#define CP_AUTO                 50001 // cross language detection
#define CP_1252                 1252  // Ansi, Western Europe
#define CCPDEFAULT 2

void SendTridentOptionsChange();

typedef struct {
    UINT cp;
    ULONG  ulIdx;
    int  cUsed;
} CPCACHE;
    
class CCachedCPInfo 
{
public:
    CCachedCPInfo();
    static void InitCpCache (PMIMECPINFO pcp, ULONG ccp);
    static void SaveCodePage (UINT codepage, PMIMECPINFO pcp, ULONG ccp);
    BOOL fAutoSelectInstalled;
    BOOL fAutoSelectChecked;
    static UINT GetCodePage(int idx)
    {
        return idx < ARRAY_SIZE(_CpCache) ? _CpCache[idx].cp: 0;
    }
    static ULONG GetCcp()
    {
        return _ccpInfo;
    }

    static ULONG GetMenuIdx(int idx)
    {
        return idx < ARRAY_SIZE(_CpCache) ? _CpCache[idx].ulIdx: 0;
    }

 private:
    static ULONG _ccpInfo;
    static CPCACHE _CpCache[5];

};

CCachedCPInfo::CCachedCPInfo()
{
    fAutoSelectInstalled = FALSE;
    fAutoSelectChecked = FALSE;
}
// declaration for static members
ULONG CCachedCPInfo::_ccpInfo = CCPDEFAULT;
CPCACHE CCachedCPInfo::_CpCache[5] = 
{
 {CP_AUTO, 0, 0},  // cross-codepage autodetect
 {CP_1252,0,0},
};

CCachedCPInfo g_cpcache;

// useful macros...

inline BOOL IsPrimaryCodePage(MIMECPINFO *pcpinfo)
{
        return pcpinfo->uiCodePage == pcpinfo->uiFamilyCodePage;
}

//------------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::InitCpCache
//  
//              Initialize the cache with default codepages
//              which do not change through the session
//
//------------------------------------------------------------------------
void CCachedCPInfo::InitCpCache (PMIMECPINFO pcp, ULONG ccp)
{
    UINT iCache, iCpInfo;

    if  (pcp &&  ccp > 0)
    {
        for (iCache= 0; iCache < CCPDEFAULT; iCache++)
        {
            for (iCpInfo= 0; iCpInfo < ccp; iCpInfo++)
            {
                if ( pcp[iCpInfo].uiCodePage == _CpCache[iCache].cp )
                {
                    if(CP_AUTO == _CpCache[iCache].cp)
                    {
                       g_cpcache.fAutoSelectInstalled = TRUE;
                    }
                    _CpCache[iCache].ulIdx = iCpInfo;
                    _CpCache[iCache].cUsed = ARRAY_SIZE(_CpCache)-1;

                    break;
                }   
            }
        }
    }
}

//------------------------------------------------------------------------
//
//  Function:   CCachedCPInfo::SaveCodePage
//  
//              Cache the given codepage along with the index to
//              the given array of MIMECPINFO
//
//------------------------------------------------------------------------
void CCachedCPInfo::SaveCodePage (UINT codepage, PMIMECPINFO pcp, ULONG ccp)
{
    int ccpSave = -1;
    BOOL bCached = FALSE;
    UINT i;

    // first check if we already have this cp
    for (i = 0; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cp == codepage)
        {
            ccpSave = i;
            bCached = TRUE;
            break;
        }
    }
    
    // if cache is not full, use the current
    // index to an entry
    if (ccpSave < 0  && _ccpInfo < ARRAY_SIZE(_CpCache))
    {
        ccpSave =  _ccpInfo;
    }
    

    //  otherwise, popout the least used entry. 
    //  the default codepages always stay
    //  this also decriments the usage count
    int cMinUsed = ARRAY_SIZE(_CpCache);
    UINT iMinUsed = 0; 
    for ( i = CCPDEFAULT; i < _ccpInfo; i++)
    {
        if (_CpCache[i].cUsed > 0)
            _CpCache[i].cUsed--;
        
        if ( ccpSave < 0 && _CpCache[i].cUsed < cMinUsed)
        {
            cMinUsed =  _CpCache[i].cUsed;
            iMinUsed =  i;
        }
    }
    if (ccpSave < 0)
        ccpSave = iMinUsed; 
    
    // set initial usage count, which goes down to 0 if it doesn't get 
    // chosen twice in a row (with current array size)
    _CpCache[ccpSave].cUsed = ARRAY_SIZE(_CpCache)-1;
    
    // find a matching entry from given array of
    // mimecpinfo
    if (pcp &&  ccp > 0)
    {
        for (i= 0; i < ccp; i++)
        {
            if ( pcp[i].uiCodePage == codepage )
            {
                _CpCache[ccpSave].cp = codepage;
                _CpCache[ccpSave].ulIdx = i;

                if (!bCached && _ccpInfo < ARRAY_SIZE(_CpCache))
                    _ccpInfo++;

                break;
            }   
        }
    }
}

// Get UI language which can shown, using System fonts

LANGID OEGetUILang()
{
    LANGID lidUI = MLGetUILanguage();   

    if(fIsNT5())            // Nothing for NT5
        return(lidUI);
    
    if (0x0409 != lidUI) // US resource is always no need to munge
    {
        CHAR szUICP[8];
        CHAR szInstallCP[8];
        
        GetLocaleInfo(MAKELCID(lidUI, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szUICP, ARRAYSIZE(szUICP));
        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szInstallCP, ARRAYSIZE(szInstallCP));
        
        if (lstrcmpi(szUICP, szInstallCP))  // return default user language ID
            return(LANGIDFROMLCID(LOCALE_USER_DEFAULT));
    } 
    return (lidUI); // return lang ID from MLGetUILanguage()
    
}





BOOL CheckAutoSelect(UINT * CodePage)
{
    if(g_cpcache.fAutoSelectChecked)
    {
        *CodePage = CP_AUTO;
        return(TRUE);
    }
    return(FALSE);
}

HRESULT _InitMultiLanguage(void)
{
    HRESULT          hr;
    IMultiLanguage  *pMLang1=NULL;
    IMultiLanguage2 *pMLang2=NULL;

    // check if data has been initialized
    if (g_pMimeCPInfo)
        return S_OK ;

    Assert(g_cMimeCPInfoCount == NULL );

    // create MIME COM object
    hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void**)&pMLang2);
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (void**)&pMLang1);

    if (SUCCEEDED(hr))
    {
        UINT cNum;
        IEnumCodePage *pEnumCodePage;

        if (pMLang2)
        {
            hr = pMLang2->EnumCodePages(MIMECONTF_MAILNEWS | MIMECONTF_VALID, OEGetUILang(), &pEnumCodePage);
            if (SUCCEEDED(hr))
                pMLang2->GetNumberOfCodePageInfo(&cNum);
        }
        else
        {
            hr = pMLang1->EnumCodePages(MIMECONTF_MAILNEWS | MIMECONTF_VALID, &pEnumCodePage);
            if (SUCCEEDED(hr))
                pMLang1->GetNumberOfCodePageInfo(&cNum);
        }

        if (SUCCEEDED(hr))
        {
            MemAlloc((LPVOID *)&g_pMimeCPInfo, sizeof(MIMECPINFO) * cNum);
            if ( g_pMimeCPInfo )
            {
                ZeroMemory(g_pMimeCPInfo, sizeof(MIMECPINFO) * cNum);
                hr = pEnumCodePage->Next(cNum, g_pMimeCPInfo, &g_cMimeCPInfoCount);
                IGNORE_HR(MemRealloc((void **)&g_pMimeCPInfo, sizeof(MIMECPINFO) * g_cMimeCPInfoCount));
            }
            pEnumCodePage->Release();
        }

        // Release Objects
        SafeRelease(pMLang1);
        SafeRelease(pMLang2);
    }

    // get default charset, before user make any change to View/Language
    if (g_hDefaultCharsetForMail == NULL)
        ReadSendMailDefaultCharset();

    return hr;
}

HRESULT InitMultiLanguage(void)
{
    // we defer the call to _InitMultiLanguage until it is necessary

    // add reference count
    g_cRefMultiLanguage++ ;

    return S_OK ;
}

void DeinitMultiLanguage(void)
{
    // decrease reference count
    if ( g_cRefMultiLanguage )
       g_cRefMultiLanguage--;

    if ( g_cRefMultiLanguage <= 0 )
    {
        if ( g_pMimeCPInfo)
        {
            MemFree(g_pMimeCPInfo);
            g_pMimeCPInfo = NULL;
            g_cMimeCPInfoCount = 0;
        }

        WriteSendMailDefaultCharset();
    }
   return ;
}

HMENU CreateMimeLanguageMenu(BOOL bMailNote, BOOL bReadNote, UINT cp)
{
    ULONG i;
    HMENU hMenu = NULL;
    ULONG cchXlated ;
    UINT  uCodePage ;
    CHAR  szBuffer[MIMEINFO_NAME_MAX];
    BOOL  fUseSIO;
    BOOL  fBroken = FALSE;
    ULONG iMenuIdx;
    UINT  uNoteCP;
    

    if(fIsNT5())
    {
        if(GetLocaleInfoW(OEGetUILang(), 
                    LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER, 
                    (LPWSTR)(&uCodePage), 
                    sizeof(UINT)/sizeof(WCHAR) ) !=  sizeof(UINT)/sizeof(WCHAR))
        uCodePage = GetACP();
    }
    else
        uCodePage = GetACP();

    if(!cp)
        uNoteCP = uCodePage;
    else
        uNoteCP = GetMapCP(cp, bReadNote);

    bMailNote = FALSE;

    hMenu = CreatePopupMenu();

    if ( g_pMimeCPInfo == NULL)
    {
       _InitMultiLanguage();
       if ( g_pMimeCPInfo == NULL)
       {
            // create an empty menu  
            LoadString(g_hLocRes, idsEmptyStr, szBuffer, MIMEINFO_NAME_MAX);
            AppendMenu(hMenu, MF_DISABLED|MF_GRAYED , (UINT)-1, szBuffer);
            return hMenu ;
       }
    }

    g_cpcache.InitCpCache(g_pMimeCPInfo, g_cMimeCPInfoCount);
    g_cpcache.SaveCodePage(uNoteCP, g_pMimeCPInfo, g_cMimeCPInfoCount);

    for(i = 0; i < g_cpcache.GetCcp(); i++)
    {
        iMenuIdx = g_cpcache.GetMenuIdx(i);
//         cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[iMenuIdx].wszDescription, -1, szBuffer, MIMEINFO_NAME_MAX, NULL, NULL);

        if(!fCheckEncodeMenu(g_pMimeCPInfo[iMenuIdx].uiCodePage, bReadNote))
            continue ;
        
        if(i != 0)
            AppendMenuWrapW(hMenu, MF_ENABLED, iMenuIdx + ID_LANG_FIRST,g_pMimeCPInfo[iMenuIdx].wszDescription);

        // [SBAILEY]: Raid 69638: oe:ml: Autoselect doesnt work (we don't support global encoding auto-detect, therefore don't show it
#if 0
        else if(g_cpcache.fAutoSelectInstalled && bReadNote)
        {
            AppendMenuWrapW(hMenu, MF_ENABLED, iMenuIdx + ID_LANG_FIRST,g_pMimeCPInfo[iMenuIdx].wszDescription);
            AppendMenuWrapW(hMenu, MF_SEPARATOR, 0, 0);            
        }
#endif

        // mark the cp entry so we can skip it for submenu
        // this assumes we'd never use the MSB for MIMECONTF
        g_pMimeCPInfo[iMenuIdx].dwFlags |= 0x80000000;
    } 

    // Check Params
    Assert(g_pMimeCPInfo);
    Assert(g_cMimeCPInfoCount > 0 );

   // add the submenu for the rest of encodings
   HMENU hSubMenu = CreatePopupMenu();
   UINT  uiLastFamilyCp = 0;

    if ( g_cMimeCPInfoCount )
    {
	    // Get System CodePage
        if (hSubMenu)
        {
            for (i = 0; i < g_cMimeCPInfoCount ; i++)
            {
                if(!fCheckEncodeMenu(g_pMimeCPInfo[i].uiCodePage, bReadNote))
                    continue ;

                // skip codepages that are on teir1 menu
                if (!(g_pMimeCPInfo[i].dwFlags & 0x80000000))
                {
                    if ((g_pMimeCPInfo[i].dwFlags & MIMECONTF_VALID)
                      ||  IsPrimaryCodePage(g_pMimeCPInfo+i))
                    {
                        UINT uiFlags = MF_ENABLED;

                        if (uiLastFamilyCp > 0 
                        && uiLastFamilyCp != g_pMimeCPInfo[i].uiFamilyCodePage)
                        {
                            // add separater between different family unless
                            // we will be adding the menu bar break
                            if(i < BREAK_ITEM || fBroken)
                            {
                                AppendMenuWrapW(hSubMenu, MF_SEPARATOR, 0, 0);
                            }
                            else
                            {
                                uiFlags |= MF_MENUBARBREAK;
                                fBroken = TRUE;
                            }
                        }
                        // This menu gets really long. Let's break at a defined number so it all
                        // fits on the screen
                        /* cchXlated = WideCharToMultiByte(uCodePage,
                                                        0, 
                                                        g_pMimeCPInfo[i].wszDescription,
                                                        -1, 
                                                        szBuffer, 
                                                        MIMEINFO_NAME_MAX
                                                        , NULL
                                                        , NULL); */
                        AppendMenuWrapW(hSubMenu, 
                                   uiFlags, 
                                   i+ID_LANG_FIRST,
                                   g_pMimeCPInfo[i].wszDescription);

                        // save the family of added codepage
                        uiLastFamilyCp = g_pMimeCPInfo[i].uiFamilyCodePage;
                    }
                }
                else
                    g_pMimeCPInfo[i].dwFlags &= 0x7FFFFFFF;
            }
            // add this submenu to the last of tier1 menu
            if (!g_szMore[0])
            {
                LoadString(g_hLocRes, 
                                   idsEncodingMore,
                                   g_szMore,
                                   ARRAY_SIZE(g_szMore));
            }
            if (GetMenuItemCount(hSubMenu) > 0)
            {
                MENUITEMINFO mii;

                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU;
                mii.hSubMenu = hSubMenu;

                AppendMenu(hMenu, MF_DISABLED, ID_POPUP_LANGUAGE_MORE, g_szMore);
                SetMenuItemInfo(hMenu, ID_POPUP_LANGUAGE_MORE, FALSE, &mii);
            }
            else
            {
                DestroyMenu(hSubMenu);
            }
            
        }
        
    }
    else
    {
        // create an empty menu  
        LoadString(g_hLocRes, idsEmptyStr, szBuffer, MIMEINFO_NAME_MAX); 
        AppendMenu(hMenu, MF_DISABLED|MF_GRAYED , (UINT)-1, szBuffer);
    }
    
    return hMenu;
}

HCHARSET GetMimeCharsetFromMenuID(int nIdm)
{
    UINT idx;
	 HCHARSET hCharset = NULL ;
    ULONG cchXlated ;
    UINT  uCodePage ;
    CHAR  szBuffer[MIMEINFO_NAME_MAX];

    idx = nIdm - ID_LANG_FIRST;
    if((g_pMimeCPInfo[idx].uiCodePage == CP_AUTO) && g_cpcache.fAutoSelectInstalled)            // Auto Select selected
    {
        g_cpcache.fAutoSelectChecked = !g_cpcache.fAutoSelectChecked;
        return(NULL);
    }


    if ( g_pMimeCPInfo && idx < g_cMimeCPInfoCount )
    {
        uCodePage = GetACP();
        cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[idx].wszBodyCharset, -1, szBuffer, MIMEINFO_NAME_MAX, NULL, NULL);
        // check if BodyCharset starts with '_' like "_iso-2022-JP$ESC"
        // if it is, use BodyCharset
        // otherwise, use WebCharset
        // BUGBUG - special case for Korean 949 use BodyCharset, fix by RTM
        if ( szBuffer[0] != '_' &&  949 != g_pMimeCPInfo[idx].uiCodePage)
            cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[idx].wszWebCharset, -1, szBuffer, MIMEINFO_NAME_MAX, NULL, NULL);
        MimeOleFindCharset(szBuffer,&hCharset);
    }
    return hCharset ;
}

HCHARSET GetMimeCharsetFromCodePage(UINT uiCodePage )
{
	HCHARSET hCharset = NULL ;
    ULONG cchXlated, i ;
    UINT  uCodePage ;
    CHAR  szBuffer[MIMEINFO_NAME_MAX];

    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    if ( g_pMimeCPInfo )
    {
        uCodePage = GetACP();
        for (i = 0; i < g_cMimeCPInfoCount ; i++)
        {
            if (uiCodePage == g_pMimeCPInfo[i].uiCodePage)
            {
                cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszBodyCharset, -1, szBuffer, MIMEINFO_NAME_MAX, NULL, NULL);
                    
                // check if BodyCharset starts with '_' like "_iso-2022-JP$ESC"
                // if it is, use BodyCharset
                // otherwise, use WebCharset
                // BUGBUG - special case for Korean 949 use BodyCharset, fix by RTM
                if ( szBuffer[0] != '_' &&  949 != g_pMimeCPInfo[i].uiCodePage)
                    cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszWebCharset, -1, szBuffer, MIMEINFO_NAME_MAX, NULL, NULL);
                MimeOleFindCharset(szBuffer,&hCharset);
                break ;
            }
        }
    }
    return hCharset ;
}

void _GetMimeCharsetLangString(BOOL bWebCharset, UINT uiCodePage, LPINT pnIdm, LPTSTR lpszString, int nSize )
{
    ULONG i, cchXlated ;
    UINT  uCodePage ;

    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    if ( g_cMimeCPInfoCount )
    {
        // Get System CodePage
        uCodePage = GetACP();
        for (i = 0; i < g_cMimeCPInfoCount ; i++)
        {
            if (uiCodePage == g_pMimeCPInfo[i].uiCodePage)
            {
        		// convert WideString to MultiByteString
                if (lpszString)
                {
                    if (bWebCharset)
                        cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszWebCharset, -1, lpszString, nSize, NULL, NULL);
                    else
                        cchXlated = WideCharToMultiByte(uCodePage, 0, g_pMimeCPInfo[i].wszDescription, -1, lpszString, nSize, NULL, NULL);
                }
                if ( pnIdm )
                    *pnIdm = i+ID_LANG_FIRST;
                break ;
            }
        }
    }

    return ;
}

int SetMimeLanguageCheckMark(UINT uiCodePage, int index)
{
    ULONG i;
    if((g_pMimeCPInfo[index].uiCodePage == CP_AUTO) && g_cpcache.fAutoSelectInstalled && DwGetOption(OPT_INCOMDEFENCODE))
        return (0);    
    else if((g_pMimeCPInfo[index].uiCodePage == CP_AUTO) && g_cpcache.fAutoSelectChecked && g_cpcache.fAutoSelectInstalled)
        return (OLECMDF_LATCHED | OLECMDF_ENABLED);

    UINT iStart = g_cpcache.fAutoSelectInstalled ? 1 : 0;

    if (1 < g_cMimeCPInfoCount)
    {
        if(uiCodePage == g_pMimeCPInfo[index].uiCodePage)
            return (OLECMDF_NINCHED | OLECMDF_ENABLED);
        else 
            return OLECMDF_ENABLED;
    }
    return FALSE;
}

INT  GetFontSize(void)
{
    DWORD cb, iFontSize = 0;

    cb = sizeof(iFontSize);
    AthUserGetValue(NULL, c_szRegValIMNFontSize, NULL, (LPBYTE)&iFontSize, &cb);

    if(iFontSize < 1 || iFontSize > 7)
        iFontSize = 2;

    return((INT)iFontSize);
}

//
// GetICP() - Gets the system's *internet* codepage from the ANSI codepage
//
UINT GetICP(UINT acp)
{
    HCHARSET        hCharset = NULL;
    UINT            icp      = NULL;
    CODEPAGEINFO    rCodePage;
    INETCSETINFO    CsetInfo;
    HRESULT         hr;
    ULONG           i;

    if(!acp)
        acp = GetACP();

    icp = acp;

    // Get the codepage info for acp
    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(acp, &rCodePage));

    // Use the body (internet) charset description to get the codepage id for 
    // the body charset
    IF_FAILEXIT(hr = MimeOleFindCharset(rCodePage.szBodyCset, &hCharset));
    IF_FAILEXIT(hr = MimeOleGetCharsetInfo(hCharset,&CsetInfo));

    // Now, we need to know if MLANG understands this CP
    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    if ( g_cMimeCPInfoCount )
    {
        for (i = 0; i < g_cMimeCPInfoCount ; i++)
        {
            if (CsetInfo.cpiInternet == g_pMimeCPInfo[i].uiCodePage)
            {
                icp = CsetInfo.cpiInternet;
                break ;
            }
        }
    }   

exit:
    return icp;
}

void ReadSendMailDefaultCharset(void)
{
    // Locals
    HKEY            hTopkey;
    DWORD           cb;
    CODEPAGEID      cpiCodePage;

    // only read once, skip if it is defined
    if (g_hDefaultCharsetForMail == NULL)
    {
        cb = sizeof(cpiCodePage);
        if (ERROR_SUCCESS == AthUserGetValue(c_szRegPathMail, c_szDefaultCodePage, NULL, (LPBYTE)&cpiCodePage, &cb))
        {
            if (cpiCodePage == 50222 || cpiCodePage == 50221)
                g_hDefaultCharsetForMail = GetJP_ISOControlCharset();
            else
                g_hDefaultCharsetForMail = GetMimeCharsetFromCodePage(cpiCodePage);
        }
    }

    if (g_hDefaultCharsetForMail == NULL)
    {
        if(FAILED(HGetDefaultCharset(&g_hDefaultCharsetForMail)))
            g_hDefaultCharsetForMail = GetMimeCharsetFromCodePage(GetICP(NULL));
    }

    return;
}

void WriteSendMailDefaultCharset(void)
{
    // Locals
    CODEPAGEID      uiCodePage;
    INETCSETINFO    CsetInfo ;

    // get CodePage from HCHARSET 
    if (g_hDefaultCharsetForMail)
    {
        MimeOleGetCharsetInfo(g_hDefaultCharsetForMail,&CsetInfo);
        uiCodePage = CsetInfo.cpiInternet ;

        AthUserSetValue(c_szRegPathMail, c_szDefaultCodePage, REG_DWORD, (LPBYTE)&uiCodePage, sizeof(uiCodePage));
    }

    return;
}

INT_PTR CALLBACK CharsetChgDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_COMMAND)
    {
        int id = GET_WM_COMMAND_ID(wParam, lParam);

        if (id == IDOK || id  == IDCANCEL ||
                id == idcSendAsUnicode )
        {
            EndDialog(hwndDlg, id);
            return TRUE;
        }
    }
    else if (msg == WM_INITDIALOG )
    {
        CenterDialog(hwndDlg);
    }

    return FALSE;
}

static const HELPMAP g_rgCtxMapCharSetMap[] = 
{
    {idcStatic1,                35545},
    {idcLangCheck,              35540},
    {0,                         0}
};
        
INT_PTR CALLBACK ReadCharsetDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CODEPAGEID cpiWindows;
    CODEPAGEID cpiInternet;
    TCHAR      szCodePage[MAX_PATH];
    TCHAR      szBuffer[MIMEINFO_NAME_MAX] = "";
    int        Idm;

    switch (msg)
    {
        case WM_INITDIALOG:
        {

            // Open Trident\International
            DWORD cb = sizeof(cpiWindows);
            if (ERROR_SUCCESS != SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, c_szDefaultCodePage, NULL, (LPBYTE)&cpiWindows, &cb))
                cpiWindows = GetACP();

            // Open the CodePage Key
            wsprintf(szCodePage, _TEXT("%s\\%d"), c_szRegInternational, cpiWindows);
            cb = sizeof(cpiInternet);
            if (ERROR_SUCCESS != SHGetValue(MU_GetCurrentUserHKey(), szCodePage, c_szDefaultEncoding, NULL, (LPBYTE)&cpiInternet, &cb))
                cpiInternet = GetICP(cpiWindows);

            // Get information about current default charset
            _GetMimeCharsetLangString(FALSE, GetMapCP(cpiInternet, TRUE), &Idm, szBuffer, MIMEINFO_NAME_MAX - 1);

            // Set the String
            SetWindowText(GetDlgItem(hwndDlg, idcStatic1), szBuffer);

            // Set the Default
            CheckDlgButton(hwndDlg, idcLangCheck, DwGetOption(OPT_INCOMDEFENCODE) ? BST_CHECKED:BST_UNCHECKED);
            break ;
        }
        case WM_COMMAND:
        {
            int id = GET_WM_COMMAND_ID(wParam, lParam);

            if (id == IDCANCEL || id == IDOK )
            {
                if(id == IDOK)
                {
                    SetDwOption(OPT_INCOMDEFENCODE, IsDlgButtonChecked(hwndDlg, idcLangCheck), NULL, 0);
#if 0
                    // hack: we should call these only if OpenFontsDialog tells us user has changed the font.
                    g_lpIFontCache->OnOptionChange();
    
                    SendTridentOptionsChange();

                    // Re-Read Default Character Set
                    SetDefaultCharset(NULL);

                    // Reset g_uiCodePage
                    DWORD dwVal = 0;
                    DWORD dwType = 0;
                    DWORD cb = sizeof(dwVal);
                    if (ERROR_SUCCESS == SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, REGSTR_VAL_DEFAULT_CODEPAGE, &dwType, &dwVal, &cb))
                        g_uiCodePage = (UINT)dwVal;
#endif // 0
                }
                EndDialog(hwndDlg, id);
                return TRUE;
            }
            break ;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxMapCharSetMap);

        default:
            break ;
    }

    return FALSE;
}

BOOL CheckIntlCharsetMap(HCHARSET hCharset, DWORD *pdwCodePage)
{
    INETCSETINFO CsetInfo ;
    LPSTR lpCharsetName, lpStr;
    ULONG i;
    UINT uiCodePage ;

    if ( hCharset == NULL )
        return FALSE ;

    if (!pdwCodePage)
        return FALSE ;
    else
        *pdwCodePage = 0 ;

    // get Code page from HCHARSET
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    *pdwCodePage = GetMapCP(CsetInfo.cpiInternet, TRUE); // This func always called for Read note (?!)
    return(*pdwCodePage != CsetInfo.cpiInternet);
}

UINT CustomGetCPFromCharset(HCHARSET hCharset, BOOL bReadNote)
{
    INETCSETINFO CsetInfo = {0};
    UINT uiCodePage = 0 ;

    // get CodePage from HCHARSET 
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    uiCodePage = GetMapCP(CsetInfo.cpiInternet, bReadNote);

    // Bug #51636
    // Check that code page supported by OE

    if(GetMimeCharsetFromCodePage(uiCodePage) == NULL)
    {
        HCHARSET hChar = NULL;

        if(bReadNote)
        {
            if(SUCCEEDED(HGetDefaultCharset(&hChar)))
            {
                if(FAILED(MimeOleGetCharsetInfo(hChar, &CsetInfo)))
                    return(0);
            }
            else
                return(0);
        }
        else
        {
            if(FAILED(MimeOleGetCharsetInfo(g_hDefaultCharsetForMail, &CsetInfo)))
                return(0);
        }

        return(GetMapCP(CsetInfo.cpiInternet, bReadNote));
    }

    return(uiCodePage);
}

BOOL IntlCharsetMapDialogBox(HWND hwndDlg)
{
    DialogBox(g_hLocRes, MAKEINTRESOURCE(iddIntlSetting), hwndDlg, ReadCharsetDlgProc) ;

    return TRUE ;
}

int IntlCharsetConflictDialogBox(void)
{
    return (int) DialogBox(g_hLocRes, MAKEINTRESOURCE(iddCharsetConflict), g_hwndInit, CharsetChgDlgProc);
}

int GetIntlCharsetLanguageCount(void)
{
    if ( g_pMimeCPInfo == NULL)
       _InitMultiLanguage();

    return g_cMimeCPInfoCount ;
}


HCHARSET GetListViewCharset()
{
    HCHARSET hCharset;

    if(g_uiCodePage == GetACP() || 0 == g_uiCodePage)
        hCharset = NULL;
    else
        hCharset = GetMimeCharsetFromCodePage(g_uiCodePage);

    return hCharset;
}

// =================================================================================
// SetListViewFont
// =================================================================================
VOID SetListViewFont (HWND hwndList, HCHARSET hCharset, BOOL fUpdate)
{
    // Locals
    HFONT           hFont;

    // Check Params
    Assert (IsWindow (hwndList));

    hFont = HGetCharSetFont(FNT_SYS_ICON,hCharset);

    // If we got a font, set the list view
    if (hFont)
    {
        // Set the list view font - Dont redraw quite yet
        SendMessage (hwndList, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(fUpdate, 0));

        // Try to reset header back to system icon font... 
        // Get header
        HWND hwndHeader = GetWindow (hwndList, GW_CHILD);
        // Update Header
        hFont = HGetSystemFont(FNT_SYS_ICON);
        // If font
        if (hFont && hwndHeader)                                            
            SendMessage (hwndHeader, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(fUpdate, 0));

        // Refresh
        if (fUpdate)
        {
            InvalidateRect (hwndList, NULL, TRUE);
            InvalidateRect (GetWindow(hwndList, GW_CHILD), NULL, TRUE);
        }
    }
}

// =================================================================================
// HGetSystemFont
// =================================================================================
HFONT HGetSystemFont(FNTSYSTYPE fnttype)
{
    HFONT hFont;
    Assert (g_lpIFontCache);
    if (g_lpIFontCache)
        g_lpIFontCache->GetFont(fnttype, 0, &hFont);
    else
        hFont = NULL;
    return hFont;
}

// =================================================================================
// HGetCharSetFont
// =================================================================================
HFONT HGetCharSetFont(FNTSYSTYPE fnttype, HCHARSET hCharset)
{
    HFONT hFont;
    Assert (g_lpIFontCache);
    if (g_lpIFontCache)
        g_lpIFontCache->GetFont(fnttype, hCharset, &hFont);
    else
        hFont = NULL;
    return hFont;
}


// ******************************************************
// HrGetComposeFontString
//
// Purpose: builds the compose font string based on user settings ready for execing to Trident
//
// the format of the string is:
//
//      "[Bold],[Italic],[Underline],[size],[FGRed.FGGreen.FGBlue],[BGRed.BGGreen.BGBlue],[FontFace]"
//
// Bold, Italic, Underline are either 0/1, indicating on or off. If none specified, 0 assumed.
// Size is a number between 1 and 7. If none specified, 3 assumed
// [FG|BG][Red|Green|Blue] are numbers between 0 and 255. For FG, if none specified black assumed, 
// for BG if none specified then undefined assumed.
// Font Face is a valid font name string
// For example an underline, blue text color, arial setting would be:
// 
//      ,,1,,0.0.255,,Arial
// 
// and a bold, 5 size, black, comic sans MS would be
// 
//      1,0,0,5,,,Comic Sans MS
// ******************************************************

static const TCHAR  c_szOn[]  = "1,",
                    c_szOff[] = "0,";

HRESULT HrGetComposeFontString(LPSTR rgchFont, BOOL fMail)
{
    DWORD               dw = 0, 
                        dwSize = 2;
    TCHAR               szFontFace[LF_FACESIZE+1];
    TCHAR               szTmp[50];

    if (rgchFont==NULL)
        return E_INVALIDARG;

    // "[Bold],[Italic],[Underline],[size],[FGRed.FGGreen.FGBlue],[BGRed.BGGreen.BGBlue],[FontFace]"
    *szFontFace = 0;
    *rgchFont=0;

    // bold
    lstrcat(rgchFont, DwGetOption(fMail ? OPT_MAIL_FONTBOLD : OPT_NEWS_FONTBOLD) ? c_szOn :  c_szOff);

    // italic
    lstrcat(rgchFont, DwGetOption(fMail ? OPT_MAIL_FONTITALIC : OPT_NEWS_FONTITALIC) ? c_szOn :  c_szOff);

    // underline
    lstrcat(rgchFont, DwGetOption(fMail ? OPT_MAIL_FONTUNDERLINE : OPT_NEWS_FONTUNDERLINE) ? c_szOn :  c_szOff);

    dw = DwGetOption(fMail ? OPT_MAIL_FONTSIZE : OPT_NEWS_FONTSIZE);
    
    // map points to HTML size
    dwSize = PointSizeToHTMLSize(dw);

    // font size
    wsprintf(szTmp, "%d,", dwSize);
    lstrcat(rgchFont, szTmp);

    // font foregroundcolor
    if(fMail)
        dw = DwGetOption(OPT_MAIL_FONTCOLOR);
    else
        dw = DwGetOption(OPT_NEWS_FONTCOLOR);

    // write out RGB string
    wsprintf(szTmp, "%d.%d.%d,", GetRValue(dw), GetGValue(dw), GetBValue(dw));
    lstrcat(rgchFont, szTmp);

    // default background color
    lstrcat(rgchFont, ",");
    
    GetOption(fMail ? OPT_MAIL_FONTFACE : OPT_NEWS_FONTFACE, szFontFace, LF_FACESIZE);

    if(*szFontFace == 0)
        LoadString(g_hLocRes, idsComposeFontFace, szFontFace, LF_FACESIZE);

    lstrcat(rgchFont, szFontFace);

    return S_OK;
}


INT PointSizeToHTMLSize(INT iPointSize)
{
    INT     iHTMLSize;
    // 1 ----- 8
    // 2 ----- 10
    // 3 ----- 12
    // 4 ----- 14
    // 5 ----- 18
    // 6 ----- 24
    // 7 ----- 36

    if(iPointSize>=8 && iPointSize<9)
        iHTMLSize = 1;
    else if(iPointSize>=9 && iPointSize<12)
        iHTMLSize = 2;
    else if(iPointSize>=12 && iPointSize<14)
        iHTMLSize = 3;
    else if(iPointSize>=14 && iPointSize<18)
        iHTMLSize = 4;
    else if(iPointSize>=18 && iPointSize<24)
        iHTMLSize = 5;
    else if(iPointSize>=24 && iPointSize<36)
        iHTMLSize = 6;
    else if(iPointSize>=36)
        iHTMLSize = 7;
    else
        iHTMLSize = DEFAULT_FONTSIZE;

    return iHTMLSize;
}


INT HTMLSizeToPointSize(INT iHTMLSize)
{
    INT     iPointSize;
    // 1 ----- 8
    // 2 ----- 10
    // 3 ----- 12
    // 4 ----- 14
    // 5 ----- 18
    // 6 ----- 24
    // 7 ----- 36

    switch (iHTMLSize)
        {
        case 1:
            iPointSize = 8;
            break;
        case 2:
            iPointSize = 10;
            break;
        case 3:
            iPointSize = 12;
            break;
        case 4:
            iPointSize = 14;
            break;
        case 5:
            iPointSize = 18;
            break;
        case 6:
            iPointSize = 24;
            break;
        case 7:
            iPointSize = 36;
            break;
        default:
            iPointSize = 10;
        }

    return iPointSize;
}

HRESULT HrGetStringRBG(INT rgb, LPWSTR pwszColor)
{
    HRESULT       hr = S_OK;
    INT           i;
    DWORD         crTemp;

    if(NULL == pwszColor)
        return E_INVALIDARG;

    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    for(i = 0; i < 6; i++)
    {
        crTemp = (rgb & (0x00f00000 >> (4*i))) >> (4*(5-i));
        pwszColor[i] = (WCHAR)((crTemp < 10)? (crTemp+L'0') : (crTemp+ L'a' - 10));
    }
    pwszColor[6] = L'\0';

    return hr;
}


HRESULT HrGetRBGFromString(INT* pRBG, LPWSTR pwszColor)
{
    HRESULT       hr = S_OK;
    INT           i, rbg = 0, len, n;
    WCHAR          ch;

    if(NULL == pRBG)
        return E_INVALIDARG;

    *pRBG = 0;
    len = lstrlenW(pwszColor);

    for(i=0; i<len; i++)
    {
        n = -1;
        ch = pwszColor[i];
        if(ch >= L'0' && ch <= L'9')
            n = ch - L'0';
        else if(ch >= L'a' && ch <= L'f')
            n = ch - L'a' + 10;
        else if(ch >= L'A' && ch <= L'F')
            n = ch - L'A' + 10;

        if(n < 0)
            continue;

        rbg = rbg*16 + n;
    }

    *pRBG = rbg;

    return hr;
}

// ***************************************************
HRESULT FontToCharformat(HFONT hFont, CHARFORMAT *pcf)
{
    DWORD   dwOldEffects;
    HDC     hdc;
    LOGFONT lf;
    INT     yPerInch;

    if (FAILED(GetObject(hFont, sizeof(lf), &lf)))
        return E_FAIL;

    hdc=GetDC(NULL);
    yPerInch=GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);

    // Set Struct Size
    ZeroMemory(pcf, sizeof (CHARFORMAT));
    pcf->cbSize = sizeof (CHARFORMAT);
     
    // Set mask
    pcf->dwMask = CFM_CHARSET | CFM_BOLD      | CFM_FACE      | CFM_ITALIC |
                  CFM_SIZE    | CFM_STRIKEOUT | CFM_UNDERLINE | CFM_COLOR;

    // Clear all the bits we are about to set.  We restore any bits we can not get from the LOGFONT using dwOldEffects.
    pcf->dwEffects = CFE_AUTOCOLOR;
    pcf->dwEffects |= (lf.lfWeight >= 700) ? CFE_BOLD : 0;
    pcf->dwEffects |= (lf.lfItalic)        ? CFE_ITALIC : 0;
    pcf->dwEffects |= (lf.lfStrikeOut)     ? CFE_STRIKEOUT : 0;
    pcf->dwEffects |= (lf.lfUnderline)     ? CFE_UNDERLINE : 0;
    pcf->yHeight = -(int)((1440*lf.lfHeight)/yPerInch);  // I think this is he conversion?
    pcf->crTextColor = 0;   // use autocolor
    pcf->bCharSet = lf.lfCharSet;
    pcf->bPitchAndFamily = lf.lfPitchAndFamily;
    lstrcpyn (pcf->szFaceName, lf.lfFaceName, LF_FACESIZE - 1);

    return S_OK;
}

static const HELPMAP g_rgCtxMapSendCharSetMap[] = 
{
    {idcLangCombo,              50910},
    {IDC_RTL_MSG_DIR_CHECK,     50912},
    {IDC_ENGLISH_HDR_CHECK,     50915},
    {0,                         0}
};

INT_PTR CALLBACK SetSendCharsetDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND    hWndCombo;
    ULONG   i ;
    ULONG   cchXlated ;
    UINT    uiCodePage;
    CHAR    szBuffer[MIMEINFO_NAME_MAX];
    UINT    uiACP = GetACP();
    INETCSETINFO    CsetInfo ;
    int index = 0;
    int SelIndex = 0;

    hWndCombo = GetDlgItem(hwndDlg, idcLangCombo);

    switch (msg)
    {
        case WM_INITDIALOG:
        {
            CenterDialog(hwndDlg);

            // Init global CPs structire, if it was not inited yet
            if ( g_pMimeCPInfo == NULL)
                _InitMultiLanguage();
    
            // Get information about current default charset
            MimeOleGetCharsetInfo(g_hDefaultCharsetForMail,&CsetInfo);
            uiCodePage = CsetInfo.cpiInternet ;

            // Fill combo box with available charsets for Send
            for (i = 0; i < g_cMimeCPInfoCount ; i++)
            {
                if(!fCheckEncodeMenu(g_pMimeCPInfo[i].uiCodePage, FALSE))
                    continue ;

                cchXlated = WideCharToMultiByte(uiACP,
                                                        0, 
                                                        g_pMimeCPInfo[i].wszDescription,
                                                        -1, 
                                                        szBuffer, 
                                                        MIMEINFO_NAME_MAX
                                                        , NULL
                                                        , NULL);


                index = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, ((LPARAM) szBuffer));
                if(index != CB_ERR)
                    SendMessage(hWndCombo, CB_SETITEMDATA, index, ((LPARAM) (g_pMimeCPInfo[i].uiCodePage)));

                if(g_pMimeCPInfo[i].uiCodePage == uiCodePage)
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_RTL_MSG_DIR_CHECK),
                        ((g_pMimeCPInfo[i].uiFamilyCodePage == 1255) ||
                         (g_pMimeCPInfo[i].uiFamilyCodePage == 1256) ||
                         (g_pMimeCPInfo[i].uiFamilyCodePage == 1200)));
                }

            }

            //Set current selection to default charset, we can't detect this in the above
            //loop because the combobox sorting may change the index
            for (i = 0; i < g_cMimeCPInfoCount ; i++)
            {
                if(uiCodePage == (UINT)SendMessage(hWndCombo, CB_GETITEMDATA, i, NULL))
                {
                    SelIndex = i;
                    break;
                }
            }

            SendMessage(hWndCombo, CB_SETCURSEL, SelIndex, 0L);

            CheckDlgButton(hwndDlg, IDC_ENGLISH_HDR_CHECK, DwGetOption(OPT_HARDCODEDHDRS) ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwndDlg, IDC_RTL_MSG_DIR_CHECK, DwGetOption(OPT_RTL_MSG_DIR) ? BST_CHECKED:BST_UNCHECKED);
            break ;
        }
        case WM_COMMAND:
        {
            int id = GET_WM_COMMAND_ID(wParam, lParam);
            HCHARSET hCharset = NULL ;

            if ((id == idcLangCombo) && (GET_WM_COMMAND_CMD(wParam,lParam) == CBN_SELCHANGE))
            {
                index = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0L);
                if(index != CB_ERR)
                {
                    uiCodePage = (UINT) SendMessage(hWndCombo, CB_GETITEMDATA, index, 0);
                    if(((int) uiCodePage) != CB_ERR)
                    {
                        for (i = 0; i < g_cMimeCPInfoCount ; i++)
                        {
                            if(g_pMimeCPInfo[i].uiCodePage == uiCodePage)
                            {
                                EnableWindow(GetDlgItem(hwndDlg, IDC_RTL_MSG_DIR_CHECK),
                                    ((g_pMimeCPInfo[i].uiFamilyCodePage == 1255) ||
                                     (g_pMimeCPInfo[i].uiFamilyCodePage == 1256) ||
                                     (g_pMimeCPInfo[i].uiFamilyCodePage == 1200)));
                            }
                        }
                    }
                }
            }
            else if (id == IDCANCEL || id == IDOK )
            {
                if (id == IDOK )
                {
                    index = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0L);
                    if(index != CB_ERR)
                    {
                        uiCodePage = (UINT) SendMessage(hWndCombo, CB_GETITEMDATA, index, 0);
                        if(((int) uiCodePage) != CB_ERR)
                        {
                            AthUserSetValue(c_szRegPathMail, c_szDefaultCodePage, 
                                    REG_DWORD, (LPBYTE)&uiCodePage, sizeof(uiCodePage));
                            g_hDefaultCharsetForMail = GetMimeCharsetFromCodePage(uiCodePage );
                            WriteSendMailDefaultCharset();
                        }
                    }
                    SetDwOption(OPT_HARDCODEDHDRS, IsDlgButtonChecked(hwndDlg, IDC_ENGLISH_HDR_CHECK), NULL, 0);
                    SetDwOption(OPT_RTL_MSG_DIR, (IsWindowEnabled(GetDlgItem(hwndDlg, IDC_RTL_MSG_DIR_CHECK)) && IsDlgButtonChecked(hwndDlg, IDC_RTL_MSG_DIR_CHECK)), NULL, 0);
                }

                EndDialog(hwndDlg, id);
                return TRUE;
            }

            break ;
        }

        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwndDlg, msg, wParam, lParam, g_rgCtxMapSendCharSetMap);

        default:
            break ;
    }

    return FALSE;
}



BOOL SetSendCharSetDlg(HWND hwndDlg)
{
    DialogBox(g_hLocRes, MAKEINTRESOURCE(iddSendIntlSetting), hwndDlg, SetSendCharsetDlgProc) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\hotlinks.cpp ===
// =================================================================================
// L I N K S . C P P
// =================================================================================
#include "pch.hxx"
#include "resource.h"
#include "hotlinks.h"
#include "error.h"
#include "xpcomm.h"
#include "goptions.h"
#include "strconst.h"
#include <shlwapi.h>

// =================================================================================
// Globals
// =================================================================================
static COLORREF g_crLink = RGB(0,0,128);
static COLORREF g_crLinkVisited = RGB(128,0,0);


// =================================================================================
// ParseLinkColorFromSz
// =================================================================================
VOID ParseLinkColorFromSz(LPTSTR lpszLinkColor, LPCOLORREF pcr)
{
    // Locals
    ULONG           iString = 0;
    TCHAR           chToken,
                    szColor[5];
    DWORD           dwR,
                    dwG,
                    dwB;

    // Red
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwR = StrToInt(szColor);

    // Green
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T(','))
        goto exit;
    dwG = StrToInt(szColor);

    // Blue
    if (!FStringTok (lpszLinkColor, &iString, ",", &chToken, szColor, 5, TRUE) || chToken != _T('\0'))
        goto exit;
    dwB = StrToInt(szColor);

    // Create color
    *pcr = RGB(dwR, dwG, dwB);

exit:
    // Done
    return;
}

// =================================================================================
// LookupLinkColors
// =================================================================================
BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed)
{
    // Locals
    HKEY        hReg=NULL;
    TCHAR       szLinkColor[255],
                szLinkVisitedColor[255];
    LONG        lResult;
    DWORD       cb;

    // Init
    *szLinkColor = _T('\0');
    *szLinkVisitedColor = _T('\0');

    // Look for IE's link color
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szIESettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto tryns;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorIE, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorIE, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

tryns:
    // Try Netscape
    if (RegOpenKeyEx (HKEY_CURRENT_USER, (LPTSTR)c_szNSSettingsPath, 0, KEY_ALL_ACCESS, &hReg) != ERROR_SUCCESS)
        goto exit;

    // Query for value
    cb = sizeof (szLinkVisitedColor);
    RegQueryValueEx(hReg, (LPTSTR)c_szLinkVisitedColorNS, 0, NULL, (LPBYTE)szLinkVisitedColor, &cb);
    cb = sizeof (szLinkColor);
    lResult = RegQueryValueEx(hReg, (LPTSTR)c_szLinkColorNS, 0, NULL, (LPBYTE)szLinkColor, &cb);

    // Close Reg
    RegCloseKey(hReg);

    // Did we find it
    if (lResult == ERROR_SUCCESS)
        goto found;

    // Not Found
    goto exit;

found:

    // Parse Link
    ParseLinkColorFromSz(szLinkColor, &g_crLink);
    ParseLinkColorFromSz(szLinkVisitedColor, &g_crLinkVisited);
    
    if (pclrLink)
        *pclrLink = g_crLink;
    if (pclrViewed)    
        *pclrViewed = g_crLinkVisited;
    return (TRUE);

exit:
    // Done
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\goptions.cpp ===
#include "pch.hxx"
#include "strconst.h"
#include <mimeole.h>
#include <imnact.h>
#include "imsgcont.h"
#include <goptions.h>
#include <thormsgs.h>
#include "sigs.h"
#include <shlwapi.h>
#undef _INC_GOPTIONS_H
#define DEFINE_OPTION_STRUCTS
#include <goptions.h>
#include "demand.h"
#include "multiusr.h"

IOptionBucketEx *g_pOpt = NULL;
COptNotify *g_pOptNotify = NULL;

BOOL             g_fBadShutdown = FALSE;

static OPTBCKTINIT g_init =
{
    c_rgOptInfo,
    ARRAYSIZE(c_rgOptInfo),
    
    HKEY_CURRENT_USER,
    c_szRegRoot,
    c_rgszOptRegKey,
    COPTREGKEY
};

BOOL InitGlobalOptions(HKEY hkey, LPCSTR szRegOptRoot)
{
    OPTBCKTINIT     init;
    LPCOPTBCKTINIT  pinit;
    HRESULT         hr;
    
    Assert(NULL == g_pOpt);
    Assert(NULL == g_pOptNotify);
    
    g_init.hkey = MU_GetCurrentUserHKey();
    
    IF_NULLEXIT(g_pOptNotify = new COptNotify);
    
    IF_FAILEXIT(hr = CreateOptionBucketEx(&g_pOpt));
    pinit = &g_init;
    
    if (NULL != hkey)
    {
        Assert(NULL != szRegOptRoot);
        init = g_init;
        init.hkey = hkey;
        init.pszRegKeyBase = szRegOptRoot;
        pinit = &init;
    }
    
    IF_FAILEXIT(hr = g_pOpt->Initialize(pinit));
    IF_FAILEXIT(hr = g_pOpt->SetNotification((IOptionBucketNotify *)g_pOptNotify));
    
    // signature manager
    IF_FAILEXIT(hr = InitSignatureManager(pinit->hkey, pinit->pszRegKeyBase));
    
    // if the running regkey is still there, we shut down badly
    g_fBadShutdown = DwGetOption(OPT_ATHENA_RUNNING);
    SetDwOption(OPT_ATHENA_RUNNING, TRUE, NULL, 0);

exit:
    return (S_OK == hr);
}

void DeInitGlobalOptions(void)
{
    
    if (NULL != g_pOpt)
    {
        SetDwOption(OPT_ATHENA_RUNNING, FALSE, NULL, 0);
        g_pOpt->Release();
        g_pOpt = NULL;
    }
    
    if (NULL != g_pOptNotify)
    {
        g_pOptNotify->Release();
        g_pOptNotify = NULL;
    }
    
    DeinitSignatureManager();
}

DWORD DwGetOption(PROPID id)
{
    Assert(NULL != g_pOpt);
    
    return(IDwGetOption(g_pOpt, id));
}

DWORD DwGetOptionDefault(PROPID id)
{
    Assert(NULL != g_pOpt);
    
    return(IDwGetOptionDefault(g_pOpt, id));
}

DWORD GetOption(PROPID id, void *pv, DWORD cb)
{
    Assert(NULL != g_pOpt);
    
    return(IGetOption(g_pOpt, id, pv, cb));
}

DWORD IDwGetOption(IOptionBucketEx *pOpt, PROPID id)
{
    PROPVARIANT var;
    HRESULT hr;
    DWORD dw = 0;
    
    Assert(NULL != pOpt);

    // special case attachment checks to allow for ADM setting of group policy
    if ((id == OPT_SECURITY_ATTACHMENT) || (id == OPT_SECURITY_ATTACHMENT_LOCKED))
    {
        HKEY hkey;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_READ, &hkey))
        {
            DWORD dwVal, cb;

            cb = sizeof(dwVal);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szBlockAttachments, 0, NULL, (LPBYTE)&dwVal, &cb))
            {
                // if set then unsafe attachments are both locked and also disallowed
                if (dwVal == 1)
                    dw = 1;
            }

            RegCloseKey(hkey);
        }
    }

    if (!dw)
    {
        IF_FAILEXIT(hr = pOpt->GetProperty(MAKEPROPSTRING(id), &var, 0));

        Assert(VT_UI4 == var.vt);
        dw = var.ulVal;
    }
    
exit:
    return(dw);
}

DWORD IDwGetOptionDefault(IOptionBucketEx *pOpt, PROPID id)
{
    PROPVARIANT var;
    HRESULT hr;
    DWORD dw = 0;
    
    Assert(pOpt != NULL);
    IF_FAILEXIT(hr = pOpt->GetPropertyDefault(id, &var, 0));

    Assert(var.vt == VT_UI4);
    dw = var.ulVal;

exit:
    return(dw);
}

DWORD IGetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb)
{
    PROPVARIANT var;
    HRESULT     hr = S_OK;
    DWORD       cbT = 0;
    LPBYTE      pByte = NULL;
    
    Assert(NULL != pOpt);
    IF_FAILEXIT(hr = pOpt->GetProperty(MAKEPROPSTRING(id), &var, 0));

    switch (var.vt)
    {
        case VT_LPSTR:
            pByte = (LPBYTE)var.pszVal;
            cbT = lstrlen(var.pszVal) + 1;
            break;

        case VT_LPWSTR:
            pByte = (LPBYTE)var.pwszVal;
            cbT = (lstrlenW(var.pwszVal) + 1) * sizeof(WCHAR);
            break;

        case VT_BLOB:
            pByte = (LPBYTE)var.blob.pBlobData;
            cbT = var.blob.cbSize;
            break;

        default:
            Assert(FALSE);
            IF_FAILEXIT(hr = E_FAIL);
            break;
    }

    if (cb >= cbT && pByte)
        CopyMemory(pv, pByte, cbT);
    else
        IF_FAILEXIT(hr = E_FAIL);

exit:
    MemFree(pByte);

    return (SUCCEEDED(hr) ? cbT : 0);
}

BOOL SetDwOption(PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags)
{
    Assert(NULL != g_pOpt);
    
    return(ISetOption(g_pOpt, id, &dw, sizeof(DWORD), hwnd, dwFlags));
}

BOOL SetOption(PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags)
{
    Assert(NULL != g_pOpt);
    
    return(ISetOption(g_pOpt, id, pv, cb, hwnd, dwFlags));
}

BOOL ISetDwOption(IOptionBucketEx *pOpt, PROPID id, DWORD dw, HWND hwnd, DWORD dwFlags)
{
    Assert(NULL != pOpt);
    
    return(ISetOption(pOpt, id, &dw, sizeof(DWORD), hwnd, dwFlags));
}

BOOL ISetOption(IOptionBucketEx *pOpt, PROPID id, void *pv, DWORD cb, HWND hwnd, DWORD dwFlags)
{
    HRESULT     hr;
    PROPINFO    info;
    PROPVARIANT var;
    
    Assert(NULL != pOpt);
    Assert(NULL != pv);
    
    info.cbSize = sizeof(info);
    IF_FAILEXIT(hr = pOpt->GetPropertyInfo(id, &info, 0));

    var.vt = info.vt;

    switch(var.vt)
    {
        case VT_UI4:
            var.ulVal = *((DWORD *)pv);
            break;

        case VT_LPSTR:
            var.pszVal = (LPSTR)pv;
            break;

        case VT_LPWSTR:
            var.pwszVal = (LPWSTR)pv;
            break;

        case VT_BLOB:
            var.blob.cbSize = cb;
            var.blob.pBlobData = (BYTE *)pv;
            break;

        default:
            Assert(FALSE);
            IF_FAILEXIT(hr = E_FAIL);
            break;
    }
    
    IF_FAILEXIT(hr = pOpt->ISetProperty(hwnd, MAKEPROPSTRING(id), &var, dwFlags));

    // TODO: notify option objects that option changed

exit:
    return(SUCCEEDED(hr));
}

HRESULT OptionAdvise(HWND hwnd)
{
    Assert(NULL != g_pOptNotify);
    return(g_pOptNotify->Register(hwnd));
}

HRESULT OptionUnadvise(HWND hwnd)
{
    Assert(NULL != g_pOptNotify);
    return(g_pOptNotify->Unregister(hwnd));
}

COptNotify::COptNotify(void)
{
    m_cRef = 1;
    m_cHwnd = 0;
    m_cHwndBuf = 0;
    m_rgHwnd = NULL;
}

COptNotify::~COptNotify(void)
{
    MemFree(m_rgHwnd);
}

STDMETHODIMP COptNotify::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (NULL == ppv)
        return(E_INVALIDARG);
    
    if (IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if (IID_IOptionBucketNotify == riid)
    {
        *ppv = (IOptionBucketNotify *)this;
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
    
    ((IUnknown *)*ppv)->AddRef();

    return(S_OK);
}

STDMETHODIMP_(ULONG) COptNotify::AddRef(void)
{
    return((ULONG)InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) COptNotify::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return((ULONG)cRef);
}

#define CADVISEOPT  32

HRESULT COptNotify::Register(HWND hwnd)
{
    HRESULT hr = S_OK;
    int cbuf;
    
    if (m_cHwnd == m_cHwndBuf)
    {
        cbuf = m_cHwndBuf + CADVISEOPT;
        IF_NULLEXIT(MemRealloc((void **)&m_rgHwnd, sizeof(HWND) * cbuf));
        m_cHwndBuf = cbuf;
    }
    
    Assert(m_rgHwnd != NULL);
    m_rgHwnd[m_cHwnd] = hwnd;
    m_cHwnd++;

exit:
    return hr;
}

HRESULT COptNotify::Unregister(HWND hwnd)
{
    int index = 0;
    
    while (index < m_cHwnd)
    {
        if (m_rgHwnd[index] == hwnd)
            break;
        index++;
    }
    if (index >= m_cHwnd)
        return (E_FAIL);
    
    if (m_cHwnd == 1)
    {
        MemFree(m_rgHwnd);
        m_rgHwnd = NULL;
        m_cHwndBuf = 0;
    }
    else
    {
        while (index < m_cHwnd)
        {
            m_rgHwnd[index] = m_rgHwnd[index+1];
            index++;
        }
    }
    m_cHwnd--;
    
    return (S_OK);
}

STDMETHODIMP COptNotify::DoNotification(IOptionBucketEx *pBckt, HWND hwnd, PROPID id)
{
    int i;
    
    for (i = 0; i < m_cHwnd; i++)
    {
        if (hwnd != m_rgHwnd[i] && IsWindow(m_rgHwnd[i]))
            PostMessage(m_rgHwnd[i], CM_OPTIONADVISE, id, 0);
    }
    
    return(S_OK);
}

void GetUserKeyPath(LPCSTR lpSubKey, LPSTR sz, int cch)
{
    Assert(sz != NULL);
    Assert(cch >= MAX_PATH);
    
    LPCTSTR pszUserRoot = c_szRegRoot;
    
    if (lpSubKey == NULL)
        lstrcpy(sz, pszUserRoot);
    else
        wsprintf(sz, c_szPathFileFmt, pszUserRoot, lpSubKey);
}

LONG AthUserCreateKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(RegCreateKeyEx(MU_GetCurrentUserHKey(), sz, 0, NULL, REG_OPTION_NON_VOLATILE,
        samDesired, NULL, phkResult, lpdwDisposition));
}

LONG AthUserOpenKey(LPCSTR lpSubKey, REGSAM samDesired, PHKEY phkResult)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(RegOpenKeyEx(MU_GetCurrentUserHKey(), sz, 0, samDesired, phkResult));
}

LONG AthUserDeleteKey(LPCSTR lpSubKey)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHDeleteKey(MU_GetCurrentUserHKey(), sz));
}

LONG AthUserGetValue(LPCSTR lpSubKey, LPCSTR lpValueName, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHGetValue(MU_GetCurrentUserHKey(), sz, lpValueName, lpType, lpData, lpcbData));
}

LONG AthUserSetValue(LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, CONST BYTE *lpData, DWORD cbData)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHSetValue(MU_GetCurrentUserHKey(), sz, lpValueName, dwType, lpData, cbData));
}
 
LONG AthUserDeleteValue(LPCSTR lpSubKey, LPCSTR lpValueName)
{
    char sz[MAX_PATH];
    
    GetUserKeyPath(lpSubKey, sz, ARRAYSIZE(sz));
    
    return(SHDeleteValue(MU_GetCurrentUserHKey(), sz, lpValueName));
}

HKEY AthUserGetKeyRoot(void)
{
    return(MU_GetCurrentUserHKey());
}

void AthUserGetKeyPath(LPSTR szKey, int cch)
{
    Assert(cch >= MAX_PATH);
    
    LPCTSTR pszRegRoot = c_szRegRoot;
    Assert(pszRegRoot);
    
    lstrcpy(szKey, pszRegRoot);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\hotlinks.h ===
// =================================================================================
// L I N K S . H
// =================================================================================
#ifndef __LINKS_H
#define __LINKS_H

BOOL LookupLinkColors(LPCOLORREF pclrLink, LPCOLORREF pclrViewed);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\grplist2.cpp ===
#include "pch.hxx"
#include <iert.h>
#include <store.h>
#include "grplist2.h"
#include "resource.h"
#include "ourguid.h"
#include "thormsgs.h"
#include "goptions.h"
#include "strconst.h"
#include <inetcfg.h>
#include <fonts.h>
#include <columns.h>
#include <imagelst.h>
#include <instance.h>
#include <spoolui.h>
#include <options.h>
#include <acctutil.h>
#include <menuutil.h>
#include "storutil.h"
#include "xputil.h"
#include <browser.h>
#include "demand.h"
#include "menures.h"
#include "storecb.h"


ASSERTDATA

int __cdecl GroupListCompare(const void *lParam1, const void *lParam2);

void FreeChildren(SUBNODE *pNode)
{
    DWORD i;
    SUBNODE *pNodeT;

    Assert(pNode != NULL);
    
    if (pNode->pChildren != NULL)
    {
        for (i = 0, pNodeT = pNode->pChildren; i < pNode->cChildren; i++, pNodeT++)
        {
            FreeChildren(pNodeT);
        }

        MemFree(pNode->pChildren);
        pNode->pChildren = NULL;
        pNode->cChildren = 0;
    }

    if (pNode->pszName != NULL)
    {
        MemFree(pNode->pszName);
        pNode->pszName = NULL;
    }

    if (pNode->pszDescription != NULL)
    {
        MemFree(pNode->pszDescription);
        pNode->pszDescription = NULL;
    }
}

CGroupList::CGroupList()
{
    m_cRef = 1;
    m_hwndList = NULL;
    m_hwndHeader = NULL;
    m_himlFolders = NULL;
    m_himlState = NULL;

    m_pAdvise = NULL;
    m_pColumns = NULL;
    m_pEmptyList = NULL;

    m_csi = 0;
    m_csiBuf = 0;
    m_psi = NULL;
    m_psiCurr = NULL;

    m_cIndex = 0;
    m_cIndexBuf = 0;
    m_rgpIndex = NULL;

    m_pszSearch = NULL;
    m_filter = 0;
    m_fUseDesc = FALSE;
}

CGroupList::~CGroupList()
{
    DWORD i;
    SERVERINFO *psi;

    if (m_pszSearch != NULL)
        MemFree(m_pszSearch);
    
    if (m_rgpIndex != NULL)
        MemFree(m_rgpIndex);

    if (m_psi != NULL)
    {
        for (i = 0, psi = m_psi; i < m_csi; i++, psi++)
        {
            FreeChildren(&psi->root);
            if (psi->pszSearch != NULL)
                MemFree(psi->pszSearch);
        }

        MemFree(m_psi);
    }

    if (m_pEmptyList != NULL)
        delete m_pEmptyList;

    if (m_pColumns != NULL)
        m_pColumns->Release();
    
    if (m_himlFolders != NULL)
        ImageList_Destroy(m_himlFolders);
    if (m_himlState != NULL)
        ImageList_Destroy(m_himlState);
}

/////////////////////////////////////////////////////////////////////////
//
// OLE Interfaces
//

////////////////////////////////////////////////////////////////////////
//
//  IUnknown
//
////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CGroupList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IOleCommandTarget *)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppvObj = (void*) (IOleCommandTarget *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGroupList::AddRef()
{
    DOUT(TEXT("CGroupList::AddRef() - m_cRef = %d"), m_cRef + 1);
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGroupList::Release()
{
    DOUT(TEXT("CGroupList::Release() - m_cRef = %d"), m_cRef - 1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

BOOL CGroupList::_IsSelectedFolder(DWORD dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial)
{
    HRESULT hr;
    DWORD iItem = -1;
    SUBNODE *pNode;

    while (-1 != (iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED)))
    {
        pNode = NodeFromIndex(iItem);
        if (pNode == NULL)
            continue;

        if (fIgnoreSpecial && !!(pNode->flags & SN_SPECIAL))
            continue;

        if (fAll)
        {
            // If all must match and this one doesn't, then we can quit now.
            if (!(fCondition == !!(pNode->flags & dwFlags)))
                return (FALSE);
        }
        else
        {
            // If only one needs to match and this one does, then we can
            // quit now.
            if (fCondition == !!(pNode->flags & dwFlags))
                return (TRUE);
        }
    }

    // If the user wanted all to match, and we get here all did match.  If the
    // user wanted only one to match and we get here, then none matched and we
    // fail.
    return (fAll);
}

HRESULT CGroupList::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG i;
    int iSel, cSel, cItems;
    OLECMD *pcmd;
    SUBNODE *pNode;

    Assert(cCmds > 0);
    Assert(prgCmds != NULL);
    
    cSel = ListView_GetSelectedCount(m_hwndList);    
    cItems = ListView_GetItemCount(m_hwndList);
    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);

    for (i = 0, pcmd = prgCmds; i < cCmds; i++, pcmd++)
    {
        if (pcmd->cmdf == 0)
        {
            switch (pcmd->cmdID)
            {
                case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
                case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
                case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
                case ID_UNMARK_RETRIEVE_FLD:
                    // TODO: should this be based on the first selection or all selected???
                    pcmd->cmdf = OLECMDF_SUPPORTED;
                    if (iSel != -1)
                    {
                        pNode = NodeFromIndex(iSel);
                        if (pNode && !!(pNode->flags & SN_SUBSCRIBED))
                        {
                            if ((pcmd->cmdID == ID_MARK_RETRIEVE_FLD_NEW_HDRS && !!(pNode->flags & SN_DOWNLOADHEADERS)) ||
                                (pcmd->cmdID == ID_MARK_RETRIEVE_FLD_NEW_MSGS && !!(pNode->flags & SN_DOWNLOADNEW)) ||
                                (pcmd->cmdID == ID_MARK_RETRIEVE_FLD_ALL_MSGS && !!(pNode->flags & SN_DOWNLOADALL)) ||
                                (pcmd->cmdID == ID_UNMARK_RETRIEVE_FLD && 0 == (pNode->flags & SN_SYNCMASK)))
                                pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_LATCHED;
                            else
                                pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                        }
                    }
                    break;

                case ID_SUBSCRIBE:
                case ID_UNSUBSCRIBE:
                    if (_IsSelectedFolder(SN_SUBSCRIBED, pcmd->cmdID == ID_UNSUBSCRIBE, FALSE, TRUE))
                        pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        pcmd->cmdf = OLECMDF_SUPPORTED;
                    break;

                case ID_SELECT_ALL:
                case ID_REFRESH:
                case ID_RESET_LIST:
                    pcmd->cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            }
        }
    }
    
    return(S_OK);
}
    
HRESULT CGroupList::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT hr;
    int iSel;
    BOOL fShow;
    
    hr = S_OK;
    
    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
        case ID_UNMARK_RETRIEVE_FLD:
            MarkForDownload(nCmdID);
            break;

        case ID_SUBSCRIBE:
        case ID_UNSUBSCRIBE:
            Subscribe(nCmdID == ID_SUBSCRIBE);
            break;

        case ID_TOGGLE_SUBSCRIBE:
            Subscribe(TOGGLE);
            break;

        case ID_REFRESH:
        case ID_RESET_LIST:
            hr = DownloadList();
            hr = SwitchServer(TRUE);
            break;
        
        case ID_SELECT_ALL:
            ListView_SelectAll(m_hwndList);
            if (m_hwndList != GetFocus())
                SetFocus(m_hwndList);
            break;

        default:
            hr = S_FALSE;
            break;
    }
    
    return(hr);
}

HRESULT CGroupList::Initialize(IGroupListAdvise *pAdvise, CColumns *pColumns, HWND hwndList, FOLDERTYPE type)
{
    HRESULT hr;
    ULONG cServer;

    m_type = type;

    Assert(pAdvise != NULL);
    m_pAdvise = pAdvise; // don't AddRef or we'll have circular refcount

    Assert(pColumns != NULL);
    m_pColumns = pColumns;
    m_pColumns->AddRef();

    Assert(m_hwndList == NULL);
    m_hwndList = hwndList;

    m_hwndHeader = ListView_GetHeader(m_hwndList);
    Assert(m_hwndHeader != NULL);

    // Set the image lists for the listview
    Assert(m_himlFolders == NULL);
    m_himlFolders = InitImageList(16, 16, MAKEINTRESOURCE(idbFolders), cFolderIcon, RGB(255, 0, 255));
    Assert(m_himlFolders);
    ListView_SetImageList(m_hwndList, m_himlFolders, LVSIL_SMALL);
    
    Assert(m_himlState == NULL);
    m_himlState = InitImageList(16, 16, MAKEINTRESOURCE(idb16x16st), iiconStMax, RGB(255, 0, 255));
    Assert(m_himlState);
    ListView_SetImageList(m_hwndList, m_himlState, LVSIL_STATE);
    ListView_SetCallbackMask(m_hwndList, LVIS_STATEIMAGEMASK);       

    SetIntlFont(m_hwndList);

    Assert(g_pAcctMan != NULL);
    hr = g_pAcctMan->GetAccountCount(type == FOLDER_NEWS ? ACCT_NEWS : ACCT_MAIL, &cServer);
    if (FAILED(hr))
        return(hr);

    Assert(cServer > 0);
    if (!MemAlloc((void **)&m_psi, sizeof(SERVERINFO) * cServer))
    {
        return(E_OUTOFMEMORY);
    }
    else
    {
        ZeroMemory(m_psi, sizeof(SERVERINFO) * cServer);
        m_csiBuf = cServer;
    }

    m_pEmptyList = new CEmptyList;
    if (m_pEmptyList == NULL)
        return(E_OUTOFMEMORY);

    return(hr);
}

HRESULT CGroupList::HandleNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr, LRESULT *plres)
{
    HD_NOTIFY *phdn;
    int iSel;
    DWORD dwPos;
    UINT uChanged;
    FOLDERINFO info;
    LV_HITTESTINFO lvhti;
    SUBNODE *pNode;
    NM_LISTVIEW *pnmlv;
    LV_DISPINFO *pDispInfo;
    DWORD cColumns;
    NMCUSTOMDRAW *pnmcd;
    COLUMN_ID id;
    FOLDERID idFolder;
    COLUMN_SET *rgColumns;
    HRESULT hr;
    FNTSYSTYPE fntType;

    Assert(plres != NULL);
    *plres = 0;

    if (pnmhdr->hwndFrom != m_hwndList &&
        pnmhdr->hwndFrom != m_hwndHeader)
        return(S_FALSE);

    hr = S_OK;

    switch (pnmhdr->code)
    {
        case LVN_ITEMACTIVATE:
            // Tell our host to open the selected items
            iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
            if (iSel >= 0)
                m_pAdvise->ItemActivate(IdFromIndex(iSel));
            break;
        
        case LVN_GETDISPINFO:
            pDispInfo = (LV_DISPINFO *)pnmhdr;
            id = m_pColumns->GetId(pDispInfo->item.iSubItem);
        
            if ((DWORD)pDispInfo->item.iItem < m_cIndex)
                GetDisplayInfo(pDispInfo, id);
            break;
        
        case LVN_KEYDOWN:
            if (((LV_KEYDOWN *)pnmhdr)->wVKey == VK_SPACE)
            {
                Subscribe(TOGGLE);
            }
            break;
        
        case NM_CUSTOMDRAW:
            pnmcd = (NMCUSTOMDRAW *)pnmhdr;
        
            // If this is a prepaint notification, we tell the control we're interested
            // in further notfications.
            if (pnmcd->dwDrawStage == CDDS_PREPAINT)
            {
                *plres = CDRF_NOTIFYITEMDRAW;
                break;
            }
        
            // Do some extra work here to not show the selection on the priority or
            // attachment sub columns.
            // $REVIEW - Why?
            if ((pnmcd->dwDrawStage == CDDS_ITEMPREPAINT) || (pnmcd->dwDrawStage == (CDDS_ITEMPREPAINT | CDDS_SUBITEM)))
            {
                pNode = NodeFromIndex(pnmcd->dwItemSpec);
                if (pNode)
                {
                    Assert(0 == (pNode->flags & SN_HIDDEN));
                    if (!!(pNode->flags & SN_GRAYED))
                    {
                        LPNMLVCUSTOMDRAW(pnmcd)->clrText = GetSysColor(COLOR_GRAYTEXT);
                    }

                    *plres = CDRF_NOTIFYSUBITEMDRAW;
                }
                break;
            }
        
            *plres = CDRF_DODEFAULT;
            break;

        case LVN_ITEMCHANGED:
            pnmlv = (NM_LISTVIEW *)pnmhdr;
            if (!!(pnmlv->uChanged & LVIF_STATE) &&
                !!((LVIS_SELECTED | LVIS_FOCUSED) & (pnmlv->uOldState ^ pnmlv->uNewState)))
            {
                m_pAdvise->ItemUpdate();
            }
            break;
        
        case HDN_ENDTRACK:
            phdn = (HD_NOTIFY *)pnmhdr;
            m_pColumns->SetColumnWidth(phdn->iItem, phdn->pitem->cxy);
            break;
        
        case HDN_DIVIDERDBLCLICK:
            phdn = (HD_NOTIFY *)pnmhdr;
            // When the user double clicks on a header divider, we're supposed to
            // autosize that column.
            m_pColumns->SetColumnWidth(phdn->iItem, ListView_GetColumnWidth(m_hwndList, phdn->iItem));
            break;

        case LVN_ODFINDITEM:
            *plres = -1;
            break;

        default:
            hr = S_FALSE;
            break;
    }
    
    return(hr);
}

HRESULT CGroupList::SetServer(FOLDERID id)
{
    DWORD i;
    SERVERINFO *pinfo;
    HRESULT hr;
    BOOL fInit;

    Assert(id != FOLDERID_INVALID);
    Assert(m_csiBuf > 0);
    Assert(m_psi != NULL);

    if (m_psiCurr != NULL && id == m_psiCurr->root.id)
        return(S_OK);

    for (i = 0, pinfo = m_psi; i < m_csi; i++, pinfo++)
    {
        if (pinfo->root.id == id)
            break;
    }

    fInit = FALSE;

    if (i == m_csi)
    {
        // we haven't loaded this server yet
        Assert(m_csi < m_csiBuf);
        pinfo->root.id = id;
        Assert(pinfo->root.pChildren == NULL);
        Assert(pinfo->root.cChildren == 0);
        Assert(pinfo->pszSearch == NULL);
        Assert(pinfo->filter == 0);

        hr = InitializeServer(pinfo, NULL);
        if (FAILED(hr))
            return(hr);

        m_csi++;
        fInit = TRUE;
    }

#ifdef DEBUG
    if (m_psiCurr != NULL)
    {
        Assert((m_psiCurr->pszSearch == NULL && m_pszSearch == NULL) || 0 == lstrcmpi(m_psiCurr->pszSearch, m_pszSearch));
        Assert(m_psiCurr->filter == m_filter);
        Assert(m_psiCurr->fUseDesc == m_fUseDesc);
    }
#endif // DEBUG

    m_psiCurr = pinfo;

    if (fInit && m_psiCurr->root.cChildren == 0)
    {
        hr = DownloadList();
    }

    hr = SwitchServer(FALSE);

    return(hr);
}

HRESULT SaveSubscribeState(SUBNODE *pNode, SUBSTATEINFO *pInfo)
{
    HRESULT hr;
    DWORD i, cAlloc;
    SUBNODE *pNodeT;

    Assert(pNode != NULL);
    Assert(pInfo != NULL);

    hr = S_OK;

    for (i = 0, pNodeT = pNode->pChildren; i < pNode->cChildren; i++, pNodeT++)
    {
        if ((pNodeT->flags & SN_SUBSCRIBED) != (pNodeT->flagsOrig & SN_SUBSCRIBED))
        {
            if (pInfo->cState == pInfo->cStateBuf)
            {
                cAlloc = pInfo->cStateBuf + 256;
                if (!MemAlloc((void **)&pInfo->pState, cAlloc * sizeof(SUBSTATE)))
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                pInfo->cStateBuf = cAlloc;
            }

            pInfo->pState[pInfo->cState].id = pNodeT->id;
            pInfo->pState[pInfo->cState].fSub = !!(pNodeT->flags & SN_SUBSCRIBED);
            pInfo->cState++;
        }

        if (pNodeT->pChildren != NULL)
        {
            hr = SaveSubscribeState(pNodeT, pInfo);
            if (FAILED(hr))
                break;
        }
    }

    return(hr);
}

int GetSubscribeState(SUBSTATEINFO *pInfo, FOLDERID idFolder)
{
    DWORD i;
    SUBSTATE *pState;
    int iState = -1;

    Assert(pInfo != NULL);

    for (i = 0, pState = pInfo->pState; i < pInfo->cState; i++, pState++)
    {
        if (pState->id == idFolder)
        {
            iState = pState->fSub;
            break;
        }
    }

    return(iState);
}

HRESULT CGroupList::DownloadList()
{
    HRESULT hr;
    HWND hwnd;
    SUBSTATEINFO info = { 0 };

    Assert(m_psiCurr != NULL);

    m_psiCurr->fNewViewed = FALSE;

    if (m_psiCurr->fDirty && m_psiCurr->root.pChildren != NULL)
        SaveSubscribeState(&m_psiCurr->root, &info);

    DownloadNewsgroupList(m_hwndList, m_psiCurr->root.id);

    FreeChildren(&m_psiCurr->root);
    m_psiCurr->cChildrenTotal = 0;

    hr = InitializeServer(m_psiCurr, &info);

    if (info.pState != NULL)
        MemFree(info.pState);

    return(hr);
}

HRESULT CGroupList::Filter(LPCSTR pszSearch, DWORD tab, BOOL fUseDesc)
{
    HRESULT hr;
    DWORD dwFilter;

    Assert(((int) tab) >= SUB_TAB_ALL && tab <= SUB_TAB_NEW);

    switch (tab)
    {
        case SUB_TAB_ALL:
            dwFilter = 0;
            break;
        case SUB_TAB_SUBSCRIBED:
            dwFilter = SN_SUBSCRIBED;
            break;
        case SUB_TAB_NEW:
            dwFilter = SN_NEW;
            break;
    }

    hr = S_OK;

    if (m_pszSearch != NULL)
        MemFree(m_pszSearch);
    if (pszSearch != NULL)
        m_pszSearch = PszDup(pszSearch);
    else
        m_pszSearch = NULL;
    m_filter = dwFilter;
    m_fUseDesc = fUseDesc;

    if (m_psiCurr != NULL)
    {
        hr = SwitchServer(FALSE);
        Assert(SUCCEEDED(hr));
    }

    return(hr);
}

HRESULT CGroupList::HasDescriptions(BOOL *pfDesc)
{
    Assert(pfDesc != NULL);
    Assert(m_psiCurr != NULL);

    *pfDesc = m_psiCurr->fHasDesc;

    return(S_OK);
}

HRESULT CGroupList::SwitchServer(BOOL fForce)
{
    HRESULT hr;
    DWORD cSub;
    HCURSOR hcur;

    Assert(m_psiCurr != NULL);

    m_cIndex = 0;
    if (m_psiCurr->cChildrenTotal > m_cIndexBuf)
    {
        if (!MemRealloc((void **)&m_rgpIndex, m_psiCurr->cChildrenTotal * sizeof(SUBNODE *)))
            return(E_OUTOFMEMORY);
        m_cIndexBuf = m_psiCurr->cChildrenTotal;
#ifdef DEBUG
        ZeroMemory(m_rgpIndex, m_psiCurr->cChildrenTotal * sizeof(SUBNODE *));
#endif // DEBUG
    }

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Make sure the empty list window is hidden
    m_pEmptyList->Hide();

    // Turn off painting for the listview
    SetWindowRedraw(m_hwndList, FALSE);    

    if (m_filter == SN_NEW)
        m_psiCurr->fNewViewed = TRUE;

    hr = FilterServer(m_psiCurr, m_pszSearch, m_filter, m_fUseDesc, fForce);
    if (SUCCEEDED(hr))
    {
        cSub = 0;
        if (m_psiCurr->root.cChildren > 0)
            GetVisibleSubNodes(&m_psiCurr->root, m_rgpIndex, m_cIndexBuf, &cSub);

        m_cIndex = cSub;
    }

    ListView_SetItemCount(m_hwndList, m_cIndex);    
    if (m_cIndex > 0)
    {
        ListView_SetItemState(m_hwndList, -1, 0, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }

    if (m_cIndex == 0)
        m_pEmptyList->Show(m_hwndList, (LPSTR)idsEmptySubscriptionList);

    SetWindowRedraw(m_hwndList, TRUE);
    UpdateWindow(m_hwndList);

    SetCursor(hcur);

    return(hr);
}

HRESULT CommitChildren(SUBNODE *pParent, CStoreCB *pStoreCB)
{
    DWORD iNode;
    SUBNODE *pNode;
    HRESULT hr = S_OK;
    FOLDERINFO info;

    Assert(pParent != NULL);
    Assert(pParent->pChildren != NULL);
    Assert(pParent->cChildren > 0);

    for (iNode = 0, pNode = pParent->pChildren; iNode < pParent->cChildren; iNode++, pNode++)
    {
        if ((pNode->flags & SN_SUBSCRIBED) != (pNode->flagsOrig & SN_SUBSCRIBED))
        {
            if (pStoreCB != NULL)
                pStoreCB->Reset();

            hr = g_pStore->SubscribeToFolder(pNode->id, !!(pNode->flags & SN_SUBSCRIBED), pStoreCB);
            if (E_PENDING == hr)
            {
                Assert(pStoreCB != NULL);
                hr = pStoreCB->Block();
            }

            if (FAILED(hr))
                break;
        }

        if ((pNode->flags & SN_SYNCMASK) != (pNode->flagsOrig & SN_SYNCMASK))
        {
            hr = g_pStore->GetFolderInfo(pNode->id, &info);
            if (SUCCEEDED(hr))
            {
                info.dwFlags &= ~SN_SYNCMASK;
                info.dwFlags |= (SN_SYNCMASK & pNode->flags);

                hr = g_pStore->UpdateRecord(&info);
                Assert(SUCCEEDED(hr));

                g_pStore->FreeRecord(&info);
            }
        }

        pNode->flagsOrig = pNode->flags;    

        if (pNode->cChildren > 0)
        {
            hr = CommitChildren(pNode, pStoreCB);
            if (FAILED(hr))
                break;
        }
    }

    return(hr);
}

HRESULT CGroupList::Commit(HWND hwndSubscribeDlg)
{
    DWORD i;
    SERVERINFO *psi;
    HLOCK hLockNotify;
    HRESULT hr = S_OK;
    CStoreCB *pCB = NULL;

    if (m_type == FOLDER_IMAP)
    {
        pCB = new CStoreCB;
        if (pCB == NULL)
            return(E_OUTOFMEMORY);

        hr = pCB->Initialize(hwndSubscribeDlg, MAKEINTRESOURCE(idsUpdatingFolderList), FALSE);
    }

    if (SUCCEEDED(hr))
    {
        g_pStore->LockNotify(NOFLAGS, &hLockNotify);

        for (i = 0, psi = m_psi; i < m_csi; i++, psi++)
        {
            if (psi->fNewViewed)
                _SetNewViewed(psi);

            if (psi->fDirty)
            {
                if (psi->root.cChildren > 0)
                {
                    Assert(psi->root.pChildren != NULL);
                    hr = CommitChildren(&psi->root, pCB);
                    
                    if (FAILED(hr))
                        break;
                }

                psi->fDirty = FALSE;
            }
        }

        g_pStore->UnlockNotify(&hLockNotify);

        if (pCB != NULL)
            pCB->Close();
    }

    if (pCB != NULL)
        pCB->Release();

    return(hr);
}

HRESULT CGroupList::_SetNewViewed(SERVERINFO *psi)
{
    FOLDERINFO info;
    HRESULT hr;
    DWORD iNode;
    SUBNODE *pNode;

    Assert(psi != NULL);

    if (SUCCEEDED(g_pStore->GetFolderInfo(psi->root.id, &info)))
    {
        if (!!(info.dwFlags & FOLDER_HASNEWGROUPS))
        {
            info.dwFlags &= ~FOLDER_HASNEWGROUPS;
            g_pStore->UpdateRecord(&info);
        }

        g_pStore->FreeRecord(&info);
    }

    for (iNode = 0, pNode = psi->root.pChildren; iNode < psi->root.cChildren; iNode++, pNode++)
    {
        if (!!(pNode->flags & SN_NEW))
        {
            hr = g_pStore->GetFolderInfo(pNode->id, &info);
            if (SUCCEEDED(hr))
            {
                if (!!(info.dwFlags & FOLDER_NEW))
                {
                    info.dwFlags &= ~FOLDER_NEW;

                    hr = g_pStore->UpdateRecord(&info);
                    Assert(SUCCEEDED(hr));
                }

                g_pStore->FreeRecord(&info);
            }
        }
    }

    return(S_OK);
}

HRESULT CGroupList::GetFocused(FOLDERID *pid)
{
    int iSel;
    HRESULT hr;

    Assert(pid != NULL);

    hr = S_FALSE;

    iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
    if (iSel >= 0)
    {
        *pid = IdFromIndex((DWORD)iSel);
        hr = S_OK;
    }

    return(hr);
}

HRESULT CGroupList::GetSelected(FOLDERID *pid, DWORD *pcid)
{
    int iSel, cSel;
    DWORD cid;

    Assert(pid != NULL);
    Assert(pcid != NULL);

    cid = *pcid;
    *pcid = 0;

    if (cid < ListView_GetSelectedCount(m_hwndList))
        return(E_FAIL);

    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        *pid = IdFromIndex((DWORD)iSel);
        pid++;
        (*pcid)++;
    }

    return(S_OK);
}

HRESULT CGroupList::GetSelectedCount(DWORD *pcid)
{
    Assert(pcid != NULL);

    *pcid = ListView_GetSelectedCount(m_hwndList);

    return(S_OK);
}

HRESULT CGroupList::Dirty()
{
    DWORD i;
    HRESULT hr;

    hr = S_FALSE;

    for (i = 0; i < m_csi; i++)
    {
        if (m_psi[i].fDirty || m_psi[i].fNewViewed)
        {
            hr = S_OK;
            break;
        }
    }

    return(hr);
}

#define GLIC_ROOT               0x0001

HRESULT CGroupList::InitializeServer(SERVERINFO *pinfo, SUBSTATEINFO *pInfo)
{
    HRESULT hr;
    FOLDERINFO info;
    DWORD cChildrenTotal;
    HCURSOR hcur;

    Assert(pinfo != NULL);
    Assert(pinfo->root.pChildren == NULL);
    Assert(pinfo->root.cChildren == 0);
    Assert(pinfo->cChildrenTotal == 0);

    pinfo->root.indent = (WORD)-1;
    pinfo->fHasDesc = FALSE;

    hr = g_pStore->GetFolderInfo(pinfo->root.id, &info);
    if (SUCCEEDED(hr))
    {
        pinfo->tyFolder = info.tyFolder;

        cChildrenTotal = 0;
        if (ISFLAGSET(info.dwFlags, FOLDER_HASCHILDREN))
        {
            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            hr = InsertChildren(pinfo, &pinfo->root, &info, GLIC_ROOT, &cChildrenTotal, pInfo);
            if (SUCCEEDED(hr))
                pinfo->cChildrenTotal = cChildrenTotal;
            else
                FreeChildren(&pinfo->root);

            SetCursor(hcur);
        }

        g_pStore->FreeRecord(&info);
    }

    return(hr);
}

HRESULT CGroupList::InsertChildren(SERVERINFO *pinfo, SUBNODE *pParent, FOLDERINFO *pInfo, DWORD dwFlags, DWORD *pcChildrenTotal, SUBSTATEINFO *pState)
{
    FOLDERINFO info;
    HRESULT hr;
    int iSubState;
    WORD indent;
    ULONG cAlloc;
    DWORD iNode=0;
    SUBNODE *prgNode=NULL;
    IEnumerateFolders *pEnum;

    Assert(pParent != NULL);
    Assert(pParent->pChildren == NULL);
    Assert(pParent->cChildren == 0);
    Assert(pInfo != NULL);
    Assert(pcChildrenTotal != NULL);

    if (!!(dwFlags & GLIC_ROOT))
    {
        indent = 0;
        dwFlags &= ~GLIC_ROOT;
    }
    else
    {
        indent = pParent->indent + 1;
    }

    hr = g_pStore->EnumChildren(pInfo->idFolder, FALSE, &pEnum);
    if (SUCCEEDED(hr))
    {
        hr = pEnum->Count(&cAlloc);
        if (SUCCEEDED(hr) && cAlloc > 0)
        {
            if (!MemAlloc((void **)&prgNode, cAlloc * sizeof(SUBNODE)))
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                ZeroMemory(prgNode, cAlloc * sizeof(SUBNODE));

                while (S_OK == pEnum->Next(1, &info, NULL))
                {
                    Assert(pParent->cChildren < cAlloc);

                    if (0 == (FOLDER_HIDDEN & info.dwFlags))
                    {
                        prgNode[iNode].id = info.idFolder;
                        prgNode[iNode].indent = indent;
                        prgNode[iNode].flags = (SN_FOLDERMASK & (WORD)(info.dwFlags));
                        prgNode[iNode].pszName = PszDup(info.pszName);
                        prgNode[iNode].tySpecial = info.tySpecial;
                        if (info.pszDescription != NULL)
                        {
                            prgNode[iNode].pszDescription = PszDup(info.pszDescription);
                            pinfo->fHasDesc = TRUE;
                        }

                        if (!!(info.dwFlags & FOLDER_NEW))
                            prgNode[iNode].flags |= SN_NEW;
                        if (info.tySpecial != FOLDER_NOTSPECIAL)
                            prgNode[iNode].flags |= SN_SPECIAL;

                        prgNode[iNode].flagsOrig = prgNode[iNode].flags;

                        if (pState != NULL)
                        {
                            iSubState = GetSubscribeState(pState, info.idFolder);
                            if (iSubState != -1)
                            {
                                if (!!iSubState)
                                    prgNode[iNode].flags |= SN_SUBSCRIBED;
                                else
                                    prgNode[iNode].flags &= ~SN_SUBSCRIBED;
                            }
                        }

                        if (ISFLAGSET(info.dwFlags, FOLDER_HASCHILDREN))
                        {
                            hr = InsertChildren(pinfo, &prgNode[iNode], &info, dwFlags, pcChildrenTotal, pState);
                            if (FAILED(hr))
                            {
                                g_pStore->FreeRecord(&info);
                                break;
                            }
                        }

                        iNode++;
                        pParent->cChildren++;
                        (*pcChildrenTotal)++;
                    }

                    g_pStore->FreeRecord(&info);
                }

                pParent->pChildren = prgNode;

                // sort the root level of mail folders so special folders are handled correctly
                if (pInfo->tyFolder != FOLDER_NEWS &&
                    !!(pInfo->dwFlags & FOLDER_SERVER) &&
                    pParent->cChildren > 0)
                {
                    qsort(pParent->pChildren, pParent->cChildren, sizeof(SUBNODE), GroupListCompare);
                }
            }
        }

        pEnum->Release();
    }

    return(hr);
}

HRESULT CGroupList::FilterServer(SERVERINFO *pinfo, LPCSTR pszSearch, DWORD filter, BOOL fUseDesc, BOOL fForce)
{
    HRESULT hr;
    BOOL fVis, fStricter, fSame;

    Assert(pinfo != NULL);

    hr = S_OK;
    fStricter = TRUE;
    fSame = TRUE;

    if (pszSearch == NULL)
    {
        if (pinfo->pszSearch != NULL)
        {
            MemFree(pinfo->pszSearch);
            pinfo->pszSearch = NULL;

            fStricter = FALSE;
            fSame = FALSE;
        }
    }
    else
    {
        if (pinfo->pszSearch != NULL)
        {
            if (0 != lstrcmpi(pinfo->pszSearch, pszSearch))
            {
                fSame = FALSE;

                if (NULL == StrStrI(pszSearch, pinfo->pszSearch))
                    fStricter = FALSE;
            }

            MemFree(pinfo->pszSearch);
        }
        else
        {
            fSame = FALSE;
        }

        pinfo->pszSearch = PszDup(pszSearch);
    }

    if (pinfo->filter != filter)
    {
        fSame = FALSE;
        fStricter = (fStricter && pinfo->filter == 0);
        pinfo->filter = filter;
    }

    if (pinfo->fUseDesc != fUseDesc)
    {
        fSame = FALSE;
        fStricter = (fStricter && pinfo->fUseDesc);
        pinfo->fUseDesc = fUseDesc;
    }

    if (fForce)
    {
        fSame = FALSE;
        fStricter = FALSE;
    }

    if (fSame && pinfo->fFiltered)
        return(S_OK);

    if (pinfo->root.cChildren > 0)
    {
        Assert(pinfo->root.pChildren != NULL);
        hr = FilterChildren(pinfo, &pinfo->root, fStricter, &fVis);
    }

    if (hr == S_OK)
        pinfo->fFiltered = TRUE;

    return(hr);
}

inline BOOL SubstringSearch(LPCSTR pszTarget, LPCSTR pszSearch)
{
    LPCSTR pszT = pszTarget;
    LPCSTR pszS = pszSearch;
    
    while (*pszT !=0 && *pszS != 0)
    {
        if (*pszT != *pszS && 
            (char)CharLower((LPSTR)IntToPtr(MAKELONG((BYTE)*pszT, 0))) != *pszS)
        {
            pszT -= (pszS - pszSearch);
            pszS = pszSearch;
        }
        else    
        {
            pszS++;
        }
        pszT++;
    }    
    
    return (*pszS == 0);    
}

HRESULT CGroupList::FilterChildren(SERVERINFO *pinfo, SUBNODE *pParent, BOOL fStricter, BOOL *pfChildVisible)
{
    LPSTR pszT, pszTok, pszToken;
    FOLDERINFO info;
    HRESULT hr;
    SUBNODE *pNode;
    BOOL fMatch, fVis;
    DWORD i;

    Assert(pinfo != NULL);
    Assert(pParent != NULL);
    Assert(pParent->pChildren != NULL);
    Assert(pParent->cChildren > 0);
    Assert(pfChildVisible != NULL);
    
    *pfChildVisible = FALSE;
    hr = S_OK;

    // TODO: we should cache this so we don't allocate it multiple times for IMAP
    pszT = NULL;
    if (pinfo->pszSearch != NULL)
    {
        if (!MemAlloc((void **)&pszT, lstrlen(pinfo->pszSearch) + 1))
            return(E_OUTOFMEMORY);
    }

    for (i = 0, pNode = pParent->pChildren; i < pParent->cChildren; i++, pNode++)
    {
        if (fStricter && !!(pNode->flags & SN_HIDDEN))
        {
            // if our search criteria is stricter and it was hidden before,
            // we don't need to waste time with it again because it is
            // still going to be hidden

            continue;
        }

        pNode->flags |= SN_HIDDEN;
        pNode->flags &= ~(SN_CHILDVIS | SN_GRAYED);

        if (pinfo->filter == 0)
            fMatch = TRUE;
        else
            fMatch = !!(pNode->flags & pinfo->filter);

        if (fMatch && pinfo->pszSearch != NULL)
        {
            lstrcpy(pszT, pinfo->pszSearch);
            pszTok = pszT;
            pszToken = StrTokEx(&pszTok, c_szDelimiters);
            while (NULL != pszToken)
            {
                if (!SubstringSearch(pNode->pszName, pszToken) &&
                    (pNode->pszDescription == NULL || !SubstringSearch(pNode->pszDescription, pszToken)))
                {
                    fMatch = FALSE;
                    break;
                }

                pszToken = StrTokEx(&pszTok, c_szDelimiters);
            }
        }

        if (fMatch)
        {
            *pfChildVisible = TRUE;
            pNode->flags &= ~SN_HIDDEN;
        }
        else if (pNode->cChildren > 0)
        {
            pNode->flags |= SN_GRAYED;
        }

        if (pNode->cChildren > 0)
        {
            Assert(pNode->pChildren != NULL);

            hr = FilterChildren(pinfo, pNode, fStricter, &fVis);
            if (FAILED(hr))
                break;

            if (fVis)
            {
                *pfChildVisible = TRUE;
                pNode->flags &= ~SN_HIDDEN;
                pNode->flags |= SN_CHILDVIS;
            }
        }
    }

    if (pszT != NULL)
        MemFree(pszT);

    return(hr);
}

HRESULT CGroupList::GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id)
{
    SUBNODE *pNode;
    int count;
    FOLDERINFO info;
    HRESULT hr;
    
    pNode = NodeFromIndex((DWORD)pDispInfo->item.iItem);
    if (NULL == pNode)
        return (S_OK);
    
    if (!!(pDispInfo->item.mask & LVIF_TEXT))
    {
        if (id == COLUMN_NEWSGROUP || id == COLUMN_FOLDER)
        {
            lstrcpyn(pDispInfo->item.pszText, pNode->pszName, pDispInfo->item.cchTextMax);
        }
        else if (id == COLUMN_DOWNLOAD)
        {
            if (!!(pNode->flags & SN_SUBSCRIBED) && !!(pNode->flags & SN_SYNCMASK))
            {
                if (!!(pNode->flags & SN_DOWNLOADALL))
                    AthLoadString(idsAllMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(pNode->flags & SN_DOWNLOADNEW))
                    AthLoadString(idsNewMessages, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
                else if (!!(pNode->flags & SN_DOWNLOADHEADERS))
                    AthLoadString(idsNewHeaders, pDispInfo->item.pszText, pDispInfo->item.cchTextMax);
            }
        }
        else if (id == COLUMN_TOTAL || id == COLUMN_UNREAD)
        {
            hr = g_pStore->GetFolderInfo(pNode->id, &info);
            if (SUCCEEDED(hr))
            {
                if (id == COLUMN_UNREAD)
                    count = info.cUnread;
                else
                    count = info.cMessages;

                if (count < 0)
                    count = 0;
                wsprintf(pDispInfo->item.pszText, "%d", count);

                g_pStore->FreeRecord(&info);
            }
        }
        else if (id == COLUMN_DESCRIPTION)
        {
            if (pNode->pszDescription != NULL)
                lstrcpyn(pDispInfo->item.pszText, pNode->pszDescription, pDispInfo->item.cchTextMax);
        }
    }
    
    if (!!(pDispInfo->item.mask & LVIF_IMAGE))
    {
        if (id == COLUMN_NEWSGROUP)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(pNode->flags & SN_SUBSCRIBED))
            {
                pDispInfo->item.iImage = iNewsGroup;
            }
        }
        else if (COLUMN_FOLDER == id)
        {
            pDispInfo->item.iImage = iNullBitmap;
            if (!!(pNode->flags & SN_SUBSCRIBED))
            {
                hr = g_pStore->GetFolderInfo(pNode->id, &info);
                if (SUCCEEDED(hr))
                {
                    if (info.tySpecial == FOLDER_NOTSPECIAL)
                        pDispInfo->item.iImage = iFolderClosed;
                    else
                        pDispInfo->item.iImage = (iInbox + (info.tySpecial - 1));

                    g_pStore->FreeRecord(&info);
                }
            }
        }
    }
    
    if (!!(pDispInfo->item.mask & LVIF_STATE))
    {
        if (id == COLUMN_NEWSGROUP)
        {
            if (!!(pNode->flags & SN_NEW))
                pDispInfo->item.state = INDEXTOSTATEIMAGEMASK(iiconStateNew + 1);
        }
    }
    
    if (!!(pDispInfo->item.mask & LVIF_INDENT))
    {
        if (COLUMN_FOLDER == id)
            pDispInfo->item.iIndent = pNode->indent;
    }

    return(S_OK);    
}
    
HRESULT CGroupList::Subscribe(BOOL fSubscribe)
{
    BOOL fDirty;
    FOLDERINFO info;
    FOLDERID id;
    SUBNODE *pNode;
    int iSel;
    HRESULT hr;
    HCURSOR hcur;
    
    if (fSubscribe == TOGGLE)
    {
        iSel = ListView_GetNextItem(m_hwndList, -1, LVNI_ALL | LVNI_SELECTED | LVNI_FOCUSED);
        if (iSel == -1)
            return(S_OK);
        
        pNode = NodeFromIndex(iSel);

        fSubscribe = (pNode && (0 == (pNode->flags & SN_SUBSCRIBED)));
    }
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    fDirty = FALSE;
    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        pNode = NodeFromIndex(iSel);
        
        if (pNode && 0 == (pNode->flags & SN_SPECIAL) &&
            fSubscribe ^ !!(pNode->flags & SN_SUBSCRIBED))
        {
            pNode->flags ^= SN_SUBSCRIBED;
            pNode->flags &= ~SN_SYNCMASK;
            
            fDirty = TRUE;

            ListView_RedrawItems(m_hwndList, iSel, iSel);
        }
    }
    
    if (fDirty)
    {
        m_psiCurr->fDirty = TRUE;

        m_pAdvise->ItemUpdate();
    }

    SetCursor(hcur);
    
    return(S_OK);
}

void CGroupList::GetVisibleSubNodes(SUBNODE *pParent, SUBNODE **rgpIndex, DWORD cIndex, DWORD *pdwSub)
{
    DWORD i;
    SUBNODE *pNode;

    Assert(pParent != NULL);
    Assert(pParent->pChildren != NULL);
    Assert(pParent->cChildren > 0);
    Assert(pdwSub != NULL);

    for (i = 0, pNode = pParent->pChildren; i < pParent->cChildren; i++, pNode++)
    {
#ifdef DEBUG
        // a node can't have visible children unless it has kids
        if (!!(pNode->flags & SN_CHILDVIS))
            Assert(pNode->cChildren > 0);
        // a node can't be grayed unless it has kids
        if (!!(pNode->flags & SN_GRAYED))
            Assert(pNode->cChildren > 0);
#endif // DEBUG

        if (0 == (pNode->flags & SN_HIDDEN))
        {
            if (rgpIndex != NULL)
            {
                Assert(*pdwSub < cIndex);
                rgpIndex[*pdwSub] = pNode;
            }
            (*pdwSub)++;

            if (pNode->cChildren > 0)
                GetVisibleSubNodes(pNode, rgpIndex, cIndex, pdwSub);
        }
    }
}

HRESULT CGroupList::MarkForDownload(DWORD nCmdID)
{
    BOOL fDirty;
    FOLDERINFO info;
    SUBNODE *pNode;
    int iSel;
    HRESULT hr;
    HCURSOR hcur;
    WORD flag;
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    switch (nCmdID)
    {
        case ID_MARK_RETRIEVE_FLD_NEW_HDRS:
            flag = SN_DOWNLOADHEADERS;
            break;

        case ID_MARK_RETRIEVE_FLD_NEW_MSGS:
            flag = SN_DOWNLOADNEW;
            break;

        case ID_MARK_RETRIEVE_FLD_ALL_MSGS:
            flag = SN_DOWNLOADALL;
            break;

        case ID_UNMARK_RETRIEVE_FLD:
            flag = 0;
            break;

        default:
            Assert(FALSE);
            break;
    }

    fDirty = FALSE;
    iSel = -1;
    while (-1 != (iSel = ListView_GetNextItem(m_hwndList, iSel, LVNI_SELECTED | LVNI_ALL)))
    {
        pNode = NodeFromIndex(iSel);
        
        if (pNode && !!(pNode->flags & SN_SUBSCRIBED) &&
            (pNode->flags & SN_SYNCMASK) != flag)
        {
            pNode->flags &= ~SN_SYNCMASK;
            pNode->flags |= flag;

            fDirty = TRUE;

            ListView_RedrawItems(m_hwndList, iSel, iSel);
        }
    }
    
    if (fDirty)
    {
        m_psiCurr->fDirty = TRUE;

        m_pAdvise->ItemUpdate();
    }

    SetCursor(hcur);
    
    return(S_OK);
}

int __cdecl GroupListCompare(const void *lParam1, const void *lParam2) 
{
    int cmp;

    Assert(lParam1 != NULL);
    Assert(lParam2 != NULL);

    if (((SUBNODE *)lParam1)->tySpecial != FOLDER_NOTSPECIAL)
    {
        if (((SUBNODE *)lParam2)->tySpecial != FOLDER_NOTSPECIAL)
            cmp = ((SUBNODE *)lParam1)->tySpecial - ((SUBNODE *)lParam2)->tySpecial;
        else
            cmp = -1;
    }
    else
    {
        if (((SUBNODE *)lParam2)->tySpecial != FOLDER_NOTSPECIAL)
            cmp = 1;
        else
            cmp = lstrcmpi(((SUBNODE *)lParam1)->pszName, ((SUBNODE *)lParam2)->pszName);
    }

    return(cmp);
}

class CGroupListCB : public IStoreCallback, ITimeoutCallback
{
    public:
        // IUnknown 
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        // IStoreCallback
        HRESULT STDMETHODCALLTYPE OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel);
        HRESULT STDMETHODCALLTYPE OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus);
        HRESULT STDMETHODCALLTYPE OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE CanConnect(LPCSTR pszAccountId, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType);
        HRESULT STDMETHODCALLTYPE OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo);
        HRESULT STDMETHODCALLTYPE OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse);
        HRESULT STDMETHODCALLTYPE GetParentWindow(DWORD dwReserved, HWND *phwndParent);

        // ITimeoutCallback
        virtual HRESULT STDMETHODCALLTYPE OnTimeoutResponse(TIMEOUTRESPONSE eResponse);

        CGroupListCB();
        ~CGroupListCB();

        HRESULT Initialize(FOLDERID id);
        HRESULT GetResult(void) { return(m_hr); }
        
        static INT_PTR CALLBACK CGroupListCB::DownloadGroupsDlg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    private:
        ULONG       m_cRef;
        HRESULT     m_hr;
        FOLDERID    m_id;
        FOLDERTYPE  m_tyFolder;
        HWND        m_hwnd;
        LPSTR       m_pszAcct;
        BOOL        m_fCancel;
        HTIMEOUT    m_hTimeout;
        STOREOPERATIONTYPE m_type;
        IOperationCancel *m_pCancel;
        BOOL        m_fDescriptions;
};

INT_PTR CALLBACK CGroupListCB::DownloadGroupsDlg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT         hr;
    CGroupListCB   *pThis = (CGroupListCB *)GetWindowLongPtr(hwnd, DWLP_USER);
    char            szBuffer[CCHMAX_STRINGRES], szRes[CCHMAX_STRINGRES];
        
    switch (uMsg)
        {
        case WM_INITDIALOG:
            Assert(lParam);
            pThis = (CGroupListCB *)lParam;

            pThis->m_hwnd = hwnd;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            // Center the dialog over the parent window
            CenterDialog(hwnd);

            Assert(pThis->m_tyFolder == FOLDER_HTTPMAIL || pThis->m_tyFolder == FOLDER_NEWS || pThis->m_tyFolder == FOLDER_IMAP);
            if (pThis->m_tyFolder != FOLDER_NEWS)
            {
                AthLoadString(idsDownloadFoldersTitle, szRes, ARRAYSIZE(szRes));
                SetWindowText(hwnd, szRes);

                AthLoadString(idsDownloadFoldersText, szRes, ARRAYSIZE(szRes));
                SetDlgItemText(hwnd, idcStatic1, szRes);
            }

            // Set the progress text to contain the server name
            Assert(pThis->m_pszAcct);
            GetWindowText(hwnd, szBuffer, ARRAYSIZE(szBuffer));
            wsprintf(szRes, szBuffer, pThis->m_pszAcct);
            SetWindowText(hwnd, szRes);

            // Open and start the animation
            Animate_OpenEx(GetDlgItem(hwnd, idcAnimation), g_hLocRes, idanCopyMsgs);
            Animate_Play(GetDlgItem(hwnd, idcAnimation), 0, -1, -1);

            hr = g_pStore->Synchronize(pThis->m_id,
                    pThis->m_fDescriptions ? (SYNC_STORE_GET_DESCRIPTIONS | SYNC_STORE_REFRESH) : SYNC_STORE_REFRESH,
                    (IStoreCallback *)pThis);
            Assert(!SUCCEEDED(hr));
            if (hr == E_PENDING)
                EnableWindow(GetDlgItem(hwnd, IDCANCEL), FALSE);
            else
                EndDialog(hwnd, 0);
            return(TRUE);

        case WM_COMMAND:
            Assert(pThis != NULL);

            if (LOWORD(wParam) == IDCANCEL && HIWORD(wParam) == BN_CLICKED)
                {
                if (pThis->m_pCancel != NULL)
                    pThis->m_pCancel->Cancel(CT_CANCEL);

                return(TRUE);
                }
            break;
            
        case WM_STORE_COMPLETE:
            EndDialog(hwnd, 0);
            break;

        case WM_DESTROY:
            Assert(pThis != NULL);
            break;
        }
    
    return(0);    
    }

HRESULT DownloadNewsgroupList(HWND hwnd, FOLDERID id)
{
    HRESULT hr;
    CGroupListCB *pCB;

    pCB = new CGroupListCB;
    if (pCB == NULL)
        return(E_OUTOFMEMORY);

    hr = pCB->Initialize(id);
    if (SUCCEEDED(hr))
    {
        DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddDownloadGroups), hwnd, CGroupListCB::DownloadGroupsDlg, (LPARAM)pCB);

        hr = pCB->GetResult();
    }

    pCB->Release();

    return(hr);
}

CGroupListCB::CGroupListCB()
{
    m_cRef = 1;
    m_hr = E_FAIL;
    m_hwnd = NULL;
    m_pszAcct = NULL;
    m_fCancel = FALSE;
    m_hTimeout = NULL;
    m_type = SOT_INVALID;
    m_pCancel = NULL;
    m_fDescriptions = FALSE;
}

CGroupListCB::~CGroupListCB()
{
    CallbackCloseTimeout(&m_hTimeout);

    if (m_pszAcct != NULL)
        MemFree(m_pszAcct);
    if (m_pCancel != NULL)
        m_pCancel->Release();
}

HRESULT STDMETHODCALLTYPE CGroupListCB::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
        *ppvObj = (void*) (IUnknown *)(IStoreCallback *)this;
    else if (IsEqualIID(riid, IID_IStoreCallback))
        *ppvObj = (void*) (IStoreCallback *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CGroupListCB::AddRef()
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CGroupListCB::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CGroupListCB::Initialize(FOLDERID id)
{
    HRESULT hr;
    FOLDERINFO info;
    DWORD dw;
    IImnAccount *pAcct;

    m_id = id;

    hr = g_pStore->GetFolderInfo(id, &info);
    if (SUCCEEDED(hr))
    {
        Assert(!!(info.dwFlags & FOLDER_SERVER));
        Assert(info.pszAccountId != NULL);

        m_pszAcct = PszDup(info.pszName);
        if (m_pszAcct == NULL)
            hr = E_OUTOFMEMORY;

        m_tyFolder = info.tyFolder;

        if (m_tyFolder == FOLDER_NEWS)
        {
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, info.pszAccountId, &pAcct)))
            {
                if (SUCCEEDED(pAcct->GetPropDw(AP_NNTP_USE_DESCRIPTIONS, &dw)))
                    m_fDescriptions = (BOOL)dw;

                pAcct->Release();
            }
        }

        g_pStore->FreeRecord(&info);
    }

    return(hr);
}

HRESULT CGroupListCB::OnBegin(STOREOPERATIONTYPE tyOperation, STOREOPERATIONINFO *pOpInfo, IOperationCancel *pCancel)
{
    Assert(m_pCancel == NULL);
    Assert(m_type == SOT_INVALID);

    m_type = tyOperation;

    if (pCancel != NULL)
    {
        m_pCancel = pCancel;
        m_pCancel->AddRef();
    }

    EnableWindow(GetDlgItem(m_hwnd, IDCANCEL), TRUE);

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnProgress(STOREOPERATIONTYPE tyOperation, DWORD dwCurrent, DWORD dwMax, LPCSTR pszStatus)
{
    CHAR szRes[255];
    CHAR szBuffer[255];

    CallbackCloseTimeout(&m_hTimeout);

    if (SOT_CONNECTION_STATUS == tyOperation)
    {
        AthLoadString(XPUtil_StatusToString((IXPSTATUS)dwCurrent), szRes, ARRAYSIZE(szRes));
        SetDlgItemText(m_hwnd, idcProgText, szRes);
    }

    else if (SOT_SYNCING_STORE == tyOperation)
    {
        AthLoadString(m_tyFolder == FOLDER_NEWS ? idsDownloadingGroups : idsDownloadingImapFldrs, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuffer, szRes, dwCurrent);
        SetDlgItemText(m_hwnd, idcProgText, szBuffer);
    }
    else if (SOT_SYNCING_DESCRIPTIONS == tyOperation)
    {
        AthLoadString(idsDownloadingDesc, szRes, ARRAYSIZE(szRes));
        wsprintf(szBuffer, szRes, dwCurrent);
        SetDlgItemText(m_hwnd, idcProgText, szBuffer);
    }

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnTimeout(LPINETSERVER pServer, LPDWORD pdwTimeout, IXPTYPE ixpServerType)
{
    return CallbackOnTimeout(pServer, ixpServerType, *pdwTimeout, (ITimeoutCallback *)this, &m_hTimeout);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::CanConnect(LPCSTR pszAccountId, DWORD dwFlags)
{
    HWND    hwndParent;
    DWORD   dwReserved = 0;

    GetParentWindow(dwReserved, &hwndParent);

    return CallbackCanConnect(pszAccountId, hwndParent,
        (dwFlags & CC_FLAG_DONTPROMPT) ? FALSE : TRUE);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnLogonPrompt(LPINETSERVER pServer, IXPTYPE ixpServerType)
{
    CallbackCloseTimeout(&m_hTimeout);
    return CallbackOnLogonPrompt(m_hwnd, pServer, ixpServerType);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnComplete(STOREOPERATIONTYPE tyOperation, HRESULT hrComplete, LPSTOREOPERATIONINFO pOpInfo, LPSTOREERROR pErrorInfo)
{
    m_hr = hrComplete;

    CallbackCloseTimeout(&m_hTimeout);

    if (FAILED(hrComplete))
        CallbackDisplayError(m_hwnd, hrComplete, pErrorInfo);

    if (m_type != tyOperation)
        return(S_OK);

    Assert(m_hwnd != NULL);
    PostMessage(m_hwnd, WM_STORE_COMPLETE, 0, 0);

    if (m_pCancel != NULL)
    {
        m_pCancel->Release();
        m_pCancel = NULL;
    }
    
    m_type = SOT_INVALID;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, INT *piUserResponse)
{
    CallbackCloseTimeout(&m_hTimeout);
    return CallbackOnPrompt(m_hwnd, hrError, pszText, pszCaption, uType, piUserResponse);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::GetParentWindow(DWORD dwReserved, HWND *phwndParent)
{
    Assert(m_hwnd != NULL);

    *phwndParent = m_hwnd;

    return(S_OK);
}

HRESULT STDMETHODCALLTYPE CGroupListCB::OnTimeoutResponse(TIMEOUTRESPONSE eResponse)
{
    // Close my timeout
    return CallbackOnTimeoutResponse(eResponse, m_pCancel, &m_hTimeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\grplist2.h ===
#ifndef _INC_GRPLIST2_H
#define _INC_GRPLIST2_H

#include <columns.h>

#define idcAnimation 1001
#define idcProgText  1002

class CColumns;
class CEmptyList;
class CStoreDlgCB;

enum
    {
    SUB_TAB_ALL = 0,
    SUB_TAB_SUBSCRIBED,
    SUB_TAB_NEW
    };

// used for ISubscriptionManager::Subscribe( )
#define TOGGLE  ((BOOL)-1)

// SUBNODE dwFlags
#define SN_SUBSCRIBED       0x0001  // same as FOLDER_SUBSCRIBED
#define SN_CHILDVIS         0x0002  // display prop only
#define SN_GRAYED           0x0004  // display prop only
#define SN_HIDDEN           0x0008  // display prop only
#define SN_NEW              0x0010
#define SN_SPECIAL          0x0020
#define SN_DOWNLOADHEADERS  0x0800  // same as FOLDER_DOWNLOADHEADERS
#define SN_DOWNLOADNEW      0x1000  // same as FOLDER_DOWNLOADNEW
#define SN_DOWNLOADALL      0x2000  // same as FOLDER_DOWNLOADALL

#define SN_FOLDERMASK       (SN_SUBSCRIBED | SN_DOWNLOADHEADERS | SN_DOWNLOADNEW | SN_DOWNLOADALL)
#define SN_SYNCMASK         (SN_DOWNLOADHEADERS | SN_DOWNLOADNEW | SN_DOWNLOADALL)

typedef struct tagSUBNODE
{
    FOLDERID    id;
    WORD        indent;
    WORD        flags;
    WORD        flagsOrig;
    LPSTR       pszName;
    LPSTR       pszDescription;
    WORD        tySpecial;
    
    struct tagSUBNODE *pChildren;
    DWORD       cChildren;
} SUBNODE;

typedef struct tagSERVERINFO
{
    BOOL        fFiltered;
    BOOL        fDirty;
    LPSTR       pszSearch;
    DWORD       filter;
    BOOL        fUseDesc;
    BOOL        fHasDesc;
    FOLDERTYPE  tyFolder;
    BOOL        fNewViewed;

    DWORD       cChildrenTotal;
    SUBNODE     root;
} SERVERINFO;

typedef struct tagSUBSTATE
{
    FOLDERID id;
    BOOL fSub;
} SUBSTATE;

typedef struct SUBSTATEINFO
{
    DWORD cState;
    DWORD cStateBuf;
    SUBSTATE *pState;
} SUBSTATEINFO;

interface IGroupListAdvise : public IUnknown
{
public:    
    virtual HRESULT STDMETHODCALLTYPE ItemUpdate(void) = 0;
    virtual HRESULT STDMETHODCALLTYPE ItemActivate(FOLDERID id) = 0;
};

class CGroupList : public IOleCommandTarget
    {
    public:
        /////////////////////////////////////////////////////////////////////////
        //
        // OLE Interfaces
        //
    
        // IUnknown 
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        virtual ULONG   STDMETHODCALLTYPE AddRef(void);
        virtual ULONG   STDMETHODCALLTYPE Release(void);

        // IOleCommandTarget
        HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], 
                                       OLECMDTEXT *pCmdText); 
        HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, 
                                       VARIANTARG *pvaIn, VARIANTARG *pvaOut); 

        // CGroupList
        HRESULT STDMETHODCALLTYPE Initialize(IGroupListAdvise *pAdvise, CColumns *pColumns, HWND hwndList, FOLDERTYPE type);
        HRESULT STDMETHODCALLTYPE HandleNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr, LRESULT *plResult);
        HRESULT STDMETHODCALLTYPE SetServer(FOLDERID id);
        HRESULT STDMETHODCALLTYPE Filter(LPCSTR pszSearch, DWORD tab, BOOL fUseDescription);
        HRESULT STDMETHODCALLTYPE Commit(HWND hwndSubscribeDlg);
        HRESULT STDMETHODCALLTYPE GetFocused(FOLDERID *pid);
        HRESULT STDMETHODCALLTYPE GetSelected(FOLDERID *pid, DWORD *pcid);
        HRESULT STDMETHODCALLTYPE GetSelectedCount(DWORD *pcid);
        HRESULT STDMETHODCALLTYPE Dirty(void);
        HRESULT STDMETHODCALLTYPE HasDescriptions(BOOL *pfDesc);

        /////////////////////////////////////////////////////////////////////////
        //
        // Constructors, Destructors, and Initialization
        //
        CGroupList();
        virtual ~CGroupList();
        
    private:
        inline SUBNODE *NodeFromIndex(DWORD_PTR index)
        {
            Assert(index < m_cIndex);
            if (index < m_cIndex)
            {
                Assert(m_rgpIndex[index] != NULL);
                return(m_rgpIndex[index]);
            }
            return (NULL);
        }

        inline FOLDERID IdFromIndex(DWORD index)
        {
            SUBNODE *pnode;
            pnode = NodeFromIndex(index);
            return(pnode->id);
        }

        HRESULT InitializeServer(SERVERINFO *pinfo, SUBSTATEINFO *pInfo);
        HRESULT FilterServer(SERVERINFO *pinfo, LPCSTR pszSearch, DWORD tab, BOOL fUseDesc, BOOL fForce);
        HRESULT InsertChildren(SERVERINFO *pinfo, SUBNODE *pParent, FOLDERINFO *pInfo, DWORD dwFlags, DWORD *pcChildrenTotal, SUBSTATEINFO *pState);
        HRESULT FilterChildren(SERVERINFO *pinfo, SUBNODE *pNode, BOOL fStricter, BOOL *pfChildVisible);
        HRESULT SwitchServer(BOOL fForce);
        HRESULT DownloadList(void);

        HRESULT Subscribe(BOOL fSubscribe);
        HRESULT MarkForDownload(DWORD nCmdID);

        HRESULT GetDisplayInfo(LV_DISPINFO *pDispInfo, COLUMN_ID id);
        void    GetVisibleSubNodes(SUBNODE *pNode, SUBNODE **rgpIndex, DWORD cIndex, DWORD *pdwSub);

        HRESULT _SetNewViewed(SERVERINFO *psi);
        BOOL    _IsSelectedFolder(DWORD dwFlags, BOOL fCondition, BOOL fAll, BOOL fIgnoreSpecial);

    private:
        UINT                m_cRef;
        HWND                m_hwndList;
        HWND                m_hwndHeader;
        HIMAGELIST          m_himlFolders;
        HIMAGELIST          m_himlState;

        IGroupListAdvise   *m_pAdvise;
        CColumns           *m_pColumns;
        CEmptyList         *m_pEmptyList;

        FOLDERTYPE          m_type;
        DWORD               m_csi;
        DWORD               m_csiBuf;
        SERVERINFO         *m_psi;
        SERVERINFO         *m_psiCurr;

        DWORD               m_cIndex;
        DWORD               m_cIndexBuf;
        SUBNODE           **m_rgpIndex;

        LPSTR               m_pszSearch;
        DWORD               m_filter;
        BOOL                m_fUseDesc;
    };

HRESULT DownloadNewsgroupList(HWND hwnd, FOLDERID id);

#endif // _INC_GRPLIST2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\imnapi.cpp ===
// =================================================================================
// I M N A P I . C P P - IMN exported apis
// =================================================================================
#include "pch.hxx"
#include "mimeole.h"
#include "mimeutil.h"
#include "imnapi.h"
#include "ipab.h"
#include <error.h>
#include "demand.h"

#ifdef TNEF
// =================================================================================
// Globals
// =================================================================================
static HINSTANCE g_hImnTnefDll = NULL;

// =================================================================================
// Defines
// =================================================================================
#define IMNTNEF_DLL "imntnef.dll"

// =================================================================================
// imntnef function decls
// =================================================================================
typedef HRESULT (STDAPICALLTYPE *PFNHRGETTNEFRTFSTREAM)(LPSTREAM lpstmTnef, LPSTREAM lpstmRtf);
typedef HRESULT (STDAPICALLTYPE *PFNHRINIT)(BOOL fInit);

// =================================================================================
// Globals
// =================================================================================
PFNHRINIT               g_pfnHrInit = NULL;
PFNHRGETTNEFRTFSTREAM   g_pfnHrGetTnefRtfStream = NULL;

#endif // TNEF


// =================================================================================
// 
// HrMailMsgToImsg:
// 
// =================================================================================
HRESULT HrMailMsgToImsg(LPMIMEMESSAGE lpMailMsg, LPMESSAGEINFO pMsgInfo, LPIMSG lpimsg)
{
    ADRINFO         adrinfo;
    HRESULT         hr = S_OK;
    ULONG           count, 
                    i;
    IMSGPRIORITY    Pri;
    LPHBODY         rghAttach = 0;
    PROPVARIANT     rVariant;
    LPMIMEMESSAGE   pMsg = NULL;
    LPSTREAM        lpstmAttach = NULL;
    LPWABAL         lpwabal = NULL;
    LPWSTR          pwszSubj = NULL,
                    pwszFile = NULL;


    Assert(lpMailMsg != NULL);
    Assert(lpimsg != NULL);
    
    ZeroMemory(lpimsg, sizeof(IMSG));
    
    MimeOleGetBodyPropW(lpMailMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &pwszSubj);
    lpimsg->lpszSubject = PszToANSI(CP_ACP, pwszSubj);
    if (pwszSubj && !lpimsg->lpszSubject)
        IF_NULLEXIT(lpimsg->lpszSubject);
    
    rVariant.vt = VT_FILETIME;
    if (SUCCEEDED(lpMailMsg->GetProp(PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
        CopyMemory(&lpimsg->ftReceive, &rVariant.filetime, sizeof(FILETIME));
    
    rVariant.vt = VT_FILETIME;
    if (SUCCEEDED(lpMailMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant)))
        CopyMemory(&lpimsg->ftSend, &rVariant.filetime, sizeof(FILETIME));
    
    
    // flags
    if (pMsgInfo != NULL)
    {
        if (pMsgInfo->dwFlags & ARF_READ)
            lpimsg->uFlags |= MSGFLAG_READ;
        if (!!(pMsgInfo->dwFlags & ARF_UNSENT))
            lpimsg->uFlags |= MSGFLAG_UNSENT;
        if (!!(pMsgInfo->dwFlags & ARF_SUBMITTED))
            lpimsg->uFlags |= MSGFLAG_SUBMIT;
    }
    
    // Priority
    Pri = IMSG_PRI_NORMAL;
    rVariant.vt = VT_UI4;
    if (SUCCEEDED(lpMailMsg->GetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant)))
        Pri = (IMSGPRIORITY)rVariant.ulVal;
    
    switch (Pri)
    {
        case IMSG_PRI_LOW:
            lpimsg->wPriority = PRI_LOW;
            break;
        
        case IMSG_PRI_HIGH:
            lpimsg->wPriority = PRI_HIGH;
            break;
        
        case IMSG_PRI_NORMAL:
        default:
            lpimsg->wPriority = PRI_NORMAL;
            break;
    }
    
    lpMailMsg->GetTextBody(TXT_HTML, IET_DECODED, &lpimsg->lpstmHtml, NULL);
    
    // get the plain text body
    lpMailMsg->GetTextBody(TXT_PLAIN, IET_DECODED, &lpimsg->lpstmBody, NULL);
    
    IF_FAILEXIT(HrGetWabalFromMsg(lpMailMsg, &lpwabal));

    // get the sender/recipient information
    if (lpwabal)
    {
        count = lpwabal->CEntries();
        if (count > 0)
        {
            IF_NULLEXIT(MemAlloc((LPVOID*)&lpimsg->lpIaddr, sizeof(IADDRINFO)*count));
            
            ZeroMemory(lpimsg->lpIaddr, sizeof(IADDRINFO)*count);
            
            if (lpwabal->FGetFirst(&adrinfo))
            {
                i = 0;
                
                do
                {
                    switch(adrinfo.lRecipType)
                    {
                    case MAPI_TO:
                        lpimsg->lpIaddr[i].dwType = IADDR_TO;
                        break;
                        
                    case MAPI_ORIG:
                        lpimsg->lpIaddr[i].dwType = IADDR_FROM;
                        break;
                        
                    case MAPI_CC:
                        lpimsg->lpIaddr[i].dwType = IADDR_CC;
                        break;
                        
                    case MAPI_BCC:
                        lpimsg->lpIaddr[i].dwType = IADDR_BCC;
                        break;
                        
                    case MAPI_REPLYTO:
                        goto GetNext;
                        
                    default:
                        Assert(FALSE);
                        break;
                    }
                    
                    lpimsg->lpIaddr[i].lpszAddress = PszToANSI(CP_ACP, adrinfo.lpwszAddress);
                    if (adrinfo.lpwszAddress && !lpimsg->lpIaddr[i].lpszAddress)
                        IF_NULLEXIT(NULL);

                    lpimsg->lpIaddr[i].lpszDisplay = PszToANSI(CP_ACP, adrinfo.lpwszDisplay);
                    if (adrinfo.lpwszDisplay && !lpimsg->lpIaddr[i].lpszDisplay)
                        IF_NULLEXIT(NULL);
                    
                    i++;
GetNext:        
                    ;
                }
                while(lpwabal->FGetNext(&adrinfo));
                
                lpimsg->cAddress = i;
            }
        }
        
    }
        
    // Loop through the attachments
    IF_FAILEXIT(hr = lpMailMsg->GetAttachments(&count, &rghAttach));
    
    if (count > 0)
    {
        IF_NULLEXIT(MemAlloc((LPVOID*)&lpimsg->lpIatt, sizeof(IATTINFO)*count));
        
        ZeroMemory(lpimsg->lpIatt, sizeof(IATTINFO)*count);
        
        for (i=0; i<count; i++)
        {
            if (lpMailMsg->IsContentType(rghAttach[i], STR_CNT_MESSAGE, STR_SUB_RFC822)!=S_OK)
            {
                // it's a file
                IMimeBody   *pBody = 0;
                
                lpimsg->lpIatt[i].lpstmAtt=0;
                lpimsg->lpIatt[i].dwType = IATT_FILE;
                
                if (lpMailMsg->BindToObject(rghAttach[i], IID_IMimeBody, (LPVOID *)&pBody)==S_OK)
                {
                    if (SUCCEEDED(pBody->GetData(IET_BINARY, &lpstmAttach)))
                    {
                        lpimsg->lpIatt[i].lpstmAtt = lpstmAttach;
                    }
                    pBody->Release();
                }
                
                if (!lpimsg->lpIatt[i].lpstmAtt)                    
                    lpimsg->lpIatt[i].fError = TRUE;
                
                MimeOleGetBodyPropW(lpMailMsg, rghAttach[i], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &pwszFile);
                lpimsg->lpIatt[i].lpszFileName = PszToANSI(CP_ACP, pwszFile);
                if (pwszFile && !lpimsg->lpIatt[i].lpszFileName)
                    IF_NULLEXIT(NULL);
                SafeMimeOleFree(pwszFile);
            }
            else
            {
                // message attachment
                lpimsg->lpIatt[i].dwType = IATT_MSG;
                
                IF_FAILEXIT(hr = lpMailMsg->BindToObject(rghAttach[i], IID_IMimeMessage, (LPVOID *)&pMsg));

                IF_NULLEXIT(MemAlloc((void **)&lpimsg->lpIatt[i].lpImsg, sizeof(IMSG)));

                IF_FAILEXIT(hr = HrMailMsgToImsg(pMsg, NULL, lpimsg->lpIatt[i].lpImsg));
                SafeRelease(pMsg);
            }
        }
        lpimsg->cAttach = i;
    }
    
exit:
    ReleaseObj(lpwabal);
    
    if (FAILED(hr))
        FreeImsg(lpimsg);
    
    ReleaseObj(pMsg);
    MemFree(rghAttach);
    MemFree(pwszSubj);
    MemFree(pwszFile);
    return hr;
}

// =================================================================================
// HrImsgToMailMsg
// =================================================================================
HRESULT HrImsgToMailMsg (LPIMSG lpImsg, LPMIMEMESSAGE *lppMailMsg, LPSTREAM *lppstmMsg)
{
    // Locals
    HRESULT             hr = S_OK;
    ULONG               i;
    LPSTREAM            lpstmPlain = NULL, lpstmAttMsg = NULL;
    LPWABAL             lpWabal = NULL;
    LPMIMEMESSAGE       lpMailMsg=NULL,
                        lpAttMailMsg=0;
    PROPVARIANT         rVariant;

    // Check Params
    Assert (lpImsg && lppMailMsg);

    // Create CMailMsg
    hr = HrCreateMessage(&lpMailMsg);
    if(FAILED(hr))
        goto exit;

    // Properties
    MimeOleSetBodyPropA(lpMailMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, lpImsg->lpszSubject);

    rVariant.vt = VT_FILETIME;
    CopyMemory(&rVariant.filetime, &lpImsg->ftSend, sizeof(FILETIME));
    lpMailMsg->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant);

    if (lpImsg->lpstmHtml)
    {
        // Rewind the stream
        HrRewindStream (lpImsg->lpstmHtml);

        // Set Body Stream
        lpMailMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, lpImsg->lpstmHtml, NULL);
    }

    // Set BODY_PLAIN
    if (lpImsg->lpstmBody)
    {
        // Rewind the stream
        HrRewindStream (lpImsg->lpstmBody);

        // Set Body Stream
        lpMailMsg->SetTextBody(TXT_PLAIN, IET_DECODED, NULL, lpImsg->lpstmBody, NULL);
    }

    // Priority
    switch (lpImsg->wPriority)
    {
        case PRI_LOW:
            rVariant.ulVal = IMSG_PRI_LOW;
            break;

        case PRI_HIGH:
            rVariant.ulVal = IMSG_PRI_HIGH;
            break;

        default:
            rVariant.ulVal = IMSG_PRI_NORMAL;
            break;
    }
    rVariant.vt = VT_UI4;
    lpMailMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);

    // Get Address List
    CHECKHR(hr=HrCreateWabalObject(&lpWabal));
    
    // Loop Addresses
    for (i=0; i<lpImsg->cAddress; i++)
    {
        LONG lRecipType;
        switch (lpImsg->lpIaddr[i].dwType)
        {
            case IADDR_TO:
                lRecipType = MAPI_TO;
                break;

            case IADDR_FROM:
                lRecipType = MAPI_ORIG;
                break;

            case IADDR_CC:
                lRecipType = MAPI_CC;
                break;

            case IADDR_BCC:
                lRecipType = MAPI_BCC;
                break;

            default:
                Assert (FALSE);
                break;
        }
        CHECKHR(hr = lpWabal->HrAddEntryA(lpImsg->lpIaddr[i].lpszDisplay, lpImsg->lpIaddr[i].lpszAddress, lRecipType));
    }

    CHECKHR(hr=HrSetWabalOnMsg(lpMailMsg, lpWabal));

    // Loop through the attachments
    for (i=0; i<lpImsg->cAttach; i++)
    {
        // Errored Attachment
        if (lpImsg->lpIatt[i].fError)
            continue;

        // Handle Attachment Type
        switch (lpImsg->lpIatt[i].dwType)
        {
        case IATT_FILE:
            LPSTR   lpszFile;

            if (lpImsg->lpIatt[i].lpszFileName != NULL || lpImsg->lpIatt[i].lpszPathName != NULL)
                {
                lpszFile = lpImsg->lpIatt[i].lpszFileName ? lpImsg->lpIatt[i].lpszFileName : lpImsg->lpIatt[i].lpszPathName;

                // AttachFile will work of lpstmAtt is NULL or NOT
                CHECKHR(hr=lpMailMsg->AttachFile(lpszFile, lpImsg->lpIatt[i].lpstmAtt, NULL));
                }
            break;

        case IATT_MSG:
            CHECKHR (hr = HrImsgToMailMsg (lpImsg->lpIatt[i].lpImsg, &lpAttMailMsg, &lpstmAttMsg));
            
            CHECKHR (hr = lpMailMsg->AttachObject(IID_IMimeMessage, (LPVOID)lpAttMailMsg, NULL));
            SafeRelease (lpAttMailMsg);
            SafeRelease (lpstmAttMsg);
            break;

        case IATT_OLE:
        default:
            Assert (FALSE);
            break;
        }
    }

    // Does the user want me to stream it out
    if (lppstmMsg)
    {
        CHECKHR (hr = lpMailMsg->GetMessageSource(lppstmMsg, COMMIT_ONLYIFDIRTY));
    }

exit:
    // Cleanup
    SafeRelease (lpWabal);
    SafeRelease (lpstmPlain);
    SafeRelease (lpAttMailMsg);
    SafeRelease (lpstmAttMsg);

    if (FAILED (hr))
    {
        SafeRelease (lpMailMsg);
        if(lppstmMsg)
            SafeRelease ((*lppstmMsg));
    }
    else
    {
        *lppMailMsg = lpMailMsg;
    }

    // Done
    return hr;
}

#ifdef TNEF

// =================================================================================
// HrInitImnTnefDll
// =================================================================================
HRESULT HrInitImnTnefDll (BOOL fInit)
{
    // Locals
    static BOOL     s_fUnableToLoadDll = FALSE;
    HRESULT         hr = S_OK;

    // Init
    if (fInit)
    {
        // Have we failed to load the required dll
        if (s_fUnableToLoadDll)
            return E_FAIL;

        // Make sure the dll is loaded
        if (g_hImnTnefDll == NULL)
        {
            // Wait
            SetCursor (LoadCursor (NULL, IDC_WAIT));

            // Load the dll
            g_hImnTnefDll = LoadLibrary (IMNTNEF_DLL);

            // Did it load ?
            if (g_hImnTnefDll == NULL)
            {
                SetCursor (LoadCursor (NULL, IDC_ARROW));
                s_fUnableToLoadDll = TRUE;
                hr = TRAPHR (E_FAIL);
                goto exit;
            }

            // Get the proc addresses
            g_pfnHrInit = (PFNHRINIT)GetProcAddress (g_hImnTnefDll, "HrInit");
            g_pfnHrGetTnefRtfStream = (PFNHRGETTNEFRTFSTREAM)GetProcAddress (g_hImnTnefDll, "HrGetTnefRtfStream");

            // Failed to get proc address
            if (g_pfnHrInit == NULL || g_pfnHrGetTnefRtfStream == NULL)
            {
                SetCursor (LoadCursor (NULL, IDC_ARROW));
                FreeLibrary (g_hImnTnefDll);
                g_hImnTnefDll = NULL;
                g_pfnHrInit = NULL;
                g_pfnHrGetTnefRtfStream = NULL;
                s_fUnableToLoadDll = TRUE;
                hr = TRAPHR (E_FAIL);
                goto exit;
            }

            // Try to init the dll
            hr = (*g_pfnHrInit)(TRUE);
            if (FAILED (hr))
            {
                SetCursor (LoadCursor (NULL, IDC_ARROW));
                (*g_pfnHrInit)(FALSE);
                FreeLibrary (g_hImnTnefDll);
                g_hImnTnefDll = NULL;
                g_pfnHrInit = NULL;
                g_pfnHrGetTnefRtfStream = NULL;
                s_fUnableToLoadDll = TRUE;
                hr = TRAPHR (E_FAIL);
                goto exit;
            }

            // Reset cursor
            SetCursor (LoadCursor (NULL, IDC_ARROW));
        }
    }

    else
    {
        // Is the dll loaded
        if (g_hImnTnefDll)
        {
            // Deinit
            (*g_pfnHrInit)(FALSE);
            FreeLibrary (g_hImnTnefDll);
            g_hImnTnefDll = NULL;
            g_pfnHrInit = NULL;
            g_pfnHrGetTnefRtfStream = NULL;
        }
    }

exit:
    // Done
    return hr;
}

// =================================================================================
// HrGetTnefRtfStream
// =================================================================================
HRESULT HrGetTnefRtfStream (LPSTREAM lpstmTnef, LPSTREAM lpstmRtf)
{
    // Locals
    HRESULT         hr = S_OK;

    // Init our tnef converter dll
    hr = HrInitImnTnefDll (TRUE);
    if (FAILED (hr))
        goto exit;

    // Can we do it
    if (!g_hImnTnefDll || !g_pfnHrGetTnefRtfStream)
    {
        hr = TRAPHR (E_FAIL);
        goto exit;
    }

    // Call into the dll
    hr = (*g_pfnHrGetTnefRtfStream)(lpstmTnef, lpstmRtf);

exit:
    // Done
    return hr;
}

#endif // TNEF


// =====================================================================================
// FreeImsg
// =====================================================================================
VOID WINAPI_16 FreeImsg (LPIMSG lpImsg)
{
    // Locals
    ULONG           i;

    // Nothing
    if (lpImsg == NULL)
        return;

    // Free Stuff
    if (lpImsg->lpszSubject)
        MemFree(lpImsg->lpszSubject);
    lpImsg->lpszSubject = NULL;

    if (lpImsg->lpstmBody)
        lpImsg->lpstmBody->Release ();
    lpImsg->lpstmBody = NULL;

    if (lpImsg->lpstmHtml)
        lpImsg->lpstmHtml->Release ();
    lpImsg->lpstmHtml = NULL;

    // Walk Address list
    for (i=0; i<lpImsg->cAddress; i++)
    {
        if (lpImsg->lpIaddr[i].lpszAddress)
            MemFree(lpImsg->lpIaddr[i].lpszAddress);
        lpImsg->lpIaddr[i].lpszAddress = NULL;

        if (lpImsg->lpIaddr[i].lpszDisplay)
            MemFree(lpImsg->lpIaddr[i].lpszDisplay);
        lpImsg->lpIaddr[i].lpszDisplay = NULL;
    }

    // Free Address list
    if (lpImsg->lpIaddr)
        MemFree(lpImsg->lpIaddr);
    lpImsg->lpIaddr = NULL;

    // Walk Attachment list
    for (i=0; i<lpImsg->cAttach; i++)
    {
        if (lpImsg->lpIatt[i].lpszFileName)
            MemFree(lpImsg->lpIatt[i].lpszFileName);
        lpImsg->lpIatt[i].lpszFileName = NULL;

        if (lpImsg->lpIatt[i].lpszPathName)
            MemFree(lpImsg->lpIatt[i].lpszPathName);
        lpImsg->lpIatt[i].lpszPathName = NULL;

        if (lpImsg->lpIatt[i].lpszExt)
            MemFree(lpImsg->lpIatt[i].lpszExt);
        lpImsg->lpIatt[i].lpszExt = NULL;

        if (lpImsg->lpIatt[i].lpImsg)
        {
            FreeImsg (lpImsg->lpIatt[i].lpImsg);
            MemFree(lpImsg->lpIatt[i].lpImsg);
            lpImsg->lpIatt[i].lpImsg = NULL;
        }

        if (lpImsg->lpIatt[i].lpstmAtt)
            lpImsg->lpIatt[i].lpstmAtt->Release ();
        lpImsg->lpIatt[i].lpstmAtt = NULL;
    }

    // Free the att list
    if (lpImsg->lpIatt)
        MemFree(lpImsg->lpIatt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\imnapi.h ===
// =================================================================================
// I M N A P I . H - IMN exported apis
// =================================================================================
#ifndef __IMNAPI_H
#define __IMNAPI_H

// =====================================================================================
// Depends on
// =====================================================================================

typedef interface IMimeMessage IMimeMessage;
typedef /* [unique] */ IMimeMessage __RPC_FAR *LPMIMEMESSAGE;
typedef struct tagMESSAGEINFO *LPMESSAGEINFO;

// =====================================================================================
// Address Types
// =====================================================================================
#define IADDR_TO        100
#define IADDR_FROM      101
#define IADDR_CC        102
#define IADDR_BCC       103

// =====================================================================================
// Address Info Struct
// =====================================================================================
typedef struct IADDRINFO
{
    DWORD               dwType;
    LPTSTR              lpszDisplay;
    LPTSTR              lpszAddress;

} IADDRINFO, *LPIADDRINFO;

// =====================================================================================
// Attach Types
// =====================================================================================
#define IATT_FILE       100
#define IATT_MSG        101
#define IATT_OLE        102

// =====================================================================================
// IAttach Info Struct
// =====================================================================================
typedef struct tagIATTINFO
{
    DWORD               dwType;
    LPTSTR              lpszFileName;
    LPTSTR              lpszPathName;
    LPTSTR              lpszExt;
    LPSTREAM            lpstmAtt;
    BOOL                fError;
    struct IMSG         *lpImsg;

} IATTINFO, *LPIATTINFO;

// =====================================================================================
// Priorities
// =====================================================================================
#define PRI_NORMAL          100
#define PRI_LOW             101
#define PRI_HIGH            102

// =====================================================================================
// IMN Message Info Struct
// =====================================================================================
typedef struct IMSG
{
    WORD                wPriority;
    LPTSTR              lpszSubject;
    FILETIME            ftSend;
    FILETIME            ftReceive;
    ULONG               uFlags;
    LPSTREAM            lpstmBody;
    ULONG               cAddress;
    LPIADDRINFO         lpIaddr;
    ULONG               cAttach;
    LPIATTINFO          lpIatt;

    LPSTREAM            lpstmHtml;
} IMSG, *LPIMSG;

STDAPI MailNewsDllInit (BOOL fInit);
STDAPI HrImnRouteMessage (LPIADDRINFO lpIaddrRoute, ULONG cAddrRoute, LPIMSG lpImsg);

class CMailMsg;
HRESULT HrImsgToMailMsg (LPIMSG lpImsg, LPMIMEMESSAGE *lppMailMsg, LPSTREAM *lppstmMsg);
HRESULT HrMailMsgToImsg(LPMIMEMESSAGE lpMailMsg, LPMESSAGEINFO pMsgInfo, LPIMSG lpImsg);

EXTERN_C_16 void WINAPI_16 FreeImsg(LPIMSG lpImsg);
typedef void (*PFNFREEIMSG)(LPIMSG);

#ifdef TNEF
HRESULT HrInitImnTnefDll (BOOL fInit);
HRESULT HrGetTnefRtfStream (LPSTREAM lpstmTnef, LPSTREAM lpstmRtf);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\imagelst.h ===
#ifndef _INC_IMAGELST_H
#define _INC_IMAGELST_H
/*
 *  i m a g e l s t . h
 *
 *  Purpose:
 *      Born from the fire of util.h, this is where all the
 *      "shared image list stuff" went.
 *
 *  History:
 *      Halloween 1996 - Created (t-erikne)
 *
 *  Copyright (C) Microsoft Corp. 1996
 * 
 */

enum
    {
    iiconReplyOverlay = 0,
    iiconForwardOverlay,
    iiconSortAsc,
    iiconSortDesc,
    iiconHeaderPri,
    iiconHeaderAttach,
    iiconPriLow,
    iiconPriHigh,
    iiconAttach,
    iiconUnReadMail,
    iiconReadMail,
    iiconUnSentMail,
    iiconMailUnReadSigned,
    iiconMailUnReadEncrypted,
    iiconMailUnReadSignedAndEncrypted,
    iiconMailReadSigned,
    iiconMailReadEncrypted,
    iiconMailReadSignedAndEncrypted,
    iiconMailUnReadBadSigned,
    iiconMailUnReadBadEncrypted,
    iiconMailUnReadBadSignedAndEncrypted,
    iiconMailReadBadSigned,
    iiconMailReadBadEncrypted,
    iiconMailReadBadSignedAndEncrypted,
    iiconNewsHeader,
    iiconNewsHeaderRead,
    iiconNewsUnread,
    iiconNewsRead,
    iiconNewsFailed,    
    iiconNewsUnsent,
    iiconMailHeader,
    iiconMailDeleted,
    iiconVoiceMail,
    iiconHeaderFlag,
    iiconFlag,
    iiconHeaderDownload,
    iiconDownload,
    iiconHeaderThreadState,
    iiconWatchThread,
    iiconIgnoreThread,
    iiconNewsUnreadSigned,
    iiconNewsReadSigned,
    iiconSmMax
    };
    
enum
    {
    iiconStatePriHigh,
    iiconStateDownload,
    iiconStateNew,
    iiconStateFailed,
    iiconStateCollapsed,
    iiconStateExpanded,
    iiconStateUnchecked,
    iiconStateChecked,
    iiconStateIndeterminate,
    iiconStateCollapsedDownload,
    iiconStateExpandedDownload,
    iiconStateDisabled,
    iiconStateInvalid,
    iiconStateDefault,
    iiconStMax
    };
    
enum 
    {
    OVERLAY_REPLY = 1,
    OVERLAY_FORWARD = 2
    };

#define cxImlSmall      16
#define cyImlSmall      16

#define GIML_SMALL      0x0001
#define GIML_STATE      0x0004

HIMAGELIST  InitImageList(int cx, int cy, LPCSTR szbm, int cicon, COLORREF cr);
HIMAGELIST  GetImageList(UINT fIml);
void        FreeImageLists(void);
BOOL        LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal);
void        TileImage(HBITMAP hbmp, HDC hdc, LPPOINT lpptOrigin, LPRECT lprcDest);

#endif // _INC_IMAGELST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\impapi.cpp ===
#include "pch.hxx"
#include "strconst.h"
#include "mimeole.h"
#include "mimeutil.h"
#include <error.h>
#include <imnapi.h>
#include "goptions.h"
#include <resource.h>
#include <mso.h>
#include <envelope.h>
#include "ipab.h"
#define NO_IMPORT_ERROR
#include <newimp.h>
#include <impapi.h>
#include "storutil.h"
#include "demand.h"
#include "msgfldr.h"
#include "store.h"

class CMailImporter : public IMailImporter
    {
    private:
        ULONG         m_cRef;

    public:
        CMailImporter(void);
        ~CMailImporter(void);

        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        HRESULT Initialize(HWND hwnd);

        STDMETHODIMP OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie);
    };

class CFolderImport : public IFolderImport
    {
    private:
        ULONG               m_cRef;
        IMessageFolder     *m_pFolder;

        STDMETHODIMP ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm);

    public:
        CFolderImport(void);
        ~CFolderImport(void);
        
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
        ULONG   STDMETHODCALLTYPE AddRef(void);
        ULONG   STDMETHODCALLTYPE Release(void);

        HRESULT Initialize(IMessageFolder *pFolder);

        STDMETHODIMP SetMessageCount(ULONG cMsg);
        STDMETHODIMP ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach);
        STDMETHODIMP ImportMessage(IMSG *pimsg);
    };

HRESULT GetImsgFromFolder(IMessageFolder *pfldr, LPMESSAGEINFO pMsgInfo, IMSG *pimsg);

CFolderImport::CFolderImport()
    {
    m_cRef = 1;
    m_pFolder = NULL;
    }

CFolderImport::~CFolderImport()
    {
    SafeRelease(m_pFolder);
    }

ULONG CFolderImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CFolderImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CFolderImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IFolderImport == riid)
        *ppv = (IFolderImport *)this;
    else if (IID_IUnknown == riid)
        *ppv = (IFolderImport *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CFolderImport::Initialize(IMessageFolder *pFolder)
    {
    Assert(pFolder != NULL);
    m_pFolder = pFolder;
    m_pFolder->AddRef();
    return(S_OK);
    }

HRESULT CFolderImport::SetMessageCount(ULONG cMsg)
    {
    return(S_OK);
    }

HRESULT CFolderImport::ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach)
    {
    IMimeMessage *pMsg;
    HRESULT hr;
    DWORD iAttach, dwPri;
    PROPVARIANT rVariant;
    DWORD dwMsgFlags;

    Assert(pstm != NULL);
    Assert(m_pFolder != NULL);

    if (rgszAttach == NULL)
        {
        Assert(cAttach == 0);
        return(ImportMessage(type, dwState, pstm));
        }

    Assert(cAttach > 0);

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        return(hr);

    hr = HrCreateMessage(&pMsg);
    if (SUCCEEDED(hr))
        {
        hr = pMsg->Load(pstm);
        if (SUCCEEDED(hr))
            {
            for (iAttach = 0; iAttach < cAttach; iAttach++)
                {
                Assert(rgszAttach[iAttach] != NULL);

                pMsg->AttachFile(rgszAttach[iAttach], NULL, NULL);
                }

            dwPri = dwState & MSG_PRI_MASK;
            if (dwPri != 0)
                {
                if (dwPri == MSG_PRI_HIGH)
                    rVariant.ulVal = IMSG_PRI_HIGH;
                else if (dwPri == MSG_PRI_LOW)
                    rVariant.ulVal = IMSG_PRI_LOW;
                else
                    rVariant.ulVal = IMSG_PRI_NORMAL;

                rVariant.vt = VT_UI4;
                pMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
                }

            // Compute the Default arf flags
            dwMsgFlags = 0;

            // Is the Message Read ?
            if (FALSE == ISFLAGSET(dwState, MSG_STATE_UNREAD))
                FLAGSET(dwMsgFlags, ARF_READ);

            // Unsent
            if (ISFLAGSET(dwState, MSG_STATE_UNSENT))
                FLAGSET(dwMsgFlags, ARF_UNSENT);

            // Submitted
            // if (ISFLAGSET(dwState, MSG_STATE_SUBMITTED))
            //     FLAGSET(dwMsgFlags, ARF_SUBMITTED);

            if (type == MSG_TYPE_NEWS)
                FLAGSET(dwMsgFlags, ARF_NEWSMSG);

            // Insert the message
            hr = m_pFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, dwMsgFlags, 0, pMsg, NOSTORECALLBACK);
            Assert(hr != E_PENDING);
            }

        pMsg->Release();
        }

    return(hr);
    }

HRESULT CFolderImport::ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm)
    {
    WORD pri;
    IMimeMessage *pMsg;
    HRESULT hr;
    DWORD dwPri;
    PROPVARIANT rVariant;
    DWORD dwMsgFlags;

    Assert(pstm != NULL);
    Assert(m_pFolder != NULL);

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        return(hr);

    hr = HrCreateMessage(&pMsg);
    if (SUCCEEDED(hr))
        {
        if (SUCCEEDED(hr = pMsg->Load(pstm)))
            {
            dwPri = dwState & MSG_PRI_MASK;
            if (dwPri != 0)
                {
                if (dwPri == MSG_PRI_HIGH)
                    rVariant.ulVal = IMSG_PRI_HIGH;
                else if (dwPri == MSG_PRI_LOW)
                    rVariant.ulVal = IMSG_PRI_LOW;
                else
                    rVariant.ulVal = IMSG_PRI_NORMAL;

                rVariant.vt = VT_UI4;
                pMsg->SetProp(PIDTOSTR(PID_ATT_PRIORITY), 0, &rVariant);
                }


            // Compute the Default arf flags
            dwMsgFlags = 0;

            // Is the Message Read ?
            if (FALSE == ISFLAGSET(dwState, MSG_STATE_UNREAD))
                FLAGSET(dwMsgFlags, ARF_READ);

            // Unsent
            if (ISFLAGSET(dwState, MSG_STATE_UNSENT))
                FLAGSET(dwMsgFlags, ARF_UNSENT);

            // Submitted
            // if (ISFLAGSET(dwState, MSG_STATE_SUBMITTED))
            //     FLAGSET(dwMsgFlags, ARF_SUBMITTED);

            if (type == MSG_TYPE_NEWS)
                FLAGSET(dwMsgFlags, ARF_NEWSMSG);

            // Insert the message
            hr = m_pFolder->SaveMessage(NULL, SAVE_MESSAGE_GENID, dwMsgFlags, 0, pMsg, NOSTORECALLBACK);
            Assert(hr != E_PENDING);
            }

        pMsg->Release();
        }

    return(hr);
    }

HRESULT CFolderImport::ImportMessage(IMSG *pimsg)
    {
    HRESULT hr;
    MESSAGEID id;
    MESSAGEINFO info;
    LPMIMEMESSAGE   pMsg;

    Assert(pimsg != NULL);

    hr = HrImsgToMailMsg(pimsg, &pMsg, NULL);
    if (!FAILED(hr))
        {
        hr = m_pFolder->SaveMessage(&id, SAVE_MESSAGE_GENID, ISFLAGSET(pimsg->uFlags, MSGFLAG_READ) ? ARF_READ : 0, 0, pMsg, NOSTORECALLBACK);
        Assert(hr != E_PENDING);
        if (SUCCEEDED(hr))
        {
            // handle receive time
            ZeroMemory(&info, sizeof(MESSAGEINFO));
            info.idMessage = id;
            if (DB_S_FOUND == m_pFolder->FindRecord(IINDEX_PRIMARY, COLUMNS_ALL, &info, NULL))
            {
                Assert(pimsg->ftReceive.dwLowDateTime != 0 || pimsg->ftReceive.dwHighDateTime != 0);

                CopyMemory(&info.ftReceived, &pimsg->ftReceive, sizeof(FILETIME));
                m_pFolder->UpdateRecord(&info);

                m_pFolder->FreeRecord(&info);
            }
        }

        pMsg->Release();
        }

    return(hr);
    }


CMailImporter::CMailImporter()
    {
    m_cRef = 1;
    }

CMailImporter::~CMailImporter()
    {
    }

HRESULT CMailImporter::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    if (IID_IMailImporter == riid)
        *ppv = (IMailImporter *)this;
    else if (IID_IUnknown == riid)
        *ppv = (IMailImporter *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

ULONG CMailImporter::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CMailImporter::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CMailImporter::Initialize(HWND hwnd)
    {
    return S_OK;
    }

HRESULT CMailImporter::OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie)
    {
    HRESULT hr;
    FOLDERID idFolder, idFolderNew;
    CFolderImport *pFldrImp;
    IMessageFolder *pFolder;
    TCHAR sz[CCHMAX_FOLDER_NAME + 1];

    Assert(szFolder != NULL);
    Assert(ppFldrImp != NULL);
    Assert(dwFlags == 0);

    *ppFldrImp = NULL;

    if (dwCookie == COOKIE_ROOT)
        idFolder = FOLDERID_LOCAL_STORE;
    else
        idFolder = (FOLDERID)dwCookie;

    idFolderNew = FOLDERID_INVALID;

    if (type != FOLDER_TYPE_NORMAL)
        {
        LoadString(g_hLocRes, idsInbox + (type - FOLDER_TYPE_INBOX), sz, ARRAYSIZE(sz));
        szFolder = sz;
        }

    if (FAILED(GetFolderIdFromName(g_pStore, szFolder, idFolder, &idFolderNew)))
        {
        FOLDERINFO Folder={0};

        Folder.idParent = idFolder;
        Folder.tySpecial = FOLDER_NOTSPECIAL;
        Folder.pszName = (LPSTR)szFolder;
        Folder.dwFlags = FOLDER_SUBSCRIBED;

        hr = g_pStore->CreateFolder(NOFLAGS, &Folder, NOSTORECALLBACK);
        Assert(hr != E_PENDING);
        if (FAILED(hr))
            return(hr);

        idFolderNew = Folder.idFolder;
        }

    hr = g_pStore->OpenFolder(idFolderNew, NULL, NOFLAGS, &pFolder);
    if (FAILED(hr))
        return(hr);

    pFldrImp = new CFolderImport;
    if (pFldrImp == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = pFldrImp->Initialize(pFolder);
        if (FAILED(hr))
            {
            pFldrImp->Release();
            pFldrImp = NULL;
            }
        }

    pFolder->Release();

    *ppFldrImp = pFldrImp;
    *pdwCookie = (DWORD_PTR)idFolderNew;

    return(S_OK);
    }

void DoImport(HWND hwnd)
    {
    HRESULT hr;
    HMODULE hlibImport;
    PFNPERFORMIMPORT lpfnPerformImport;
    CMailImporter *pImp;

    hr = hrImportLoad;

    hlibImport = LoadLibrary(c_szImnimpDll);
    if (hlibImport != NULL)
        {
        lpfnPerformImport = (PFNPERFORMIMPORT)GetProcAddress(hlibImport, achPerformImport);
        if (lpfnPerformImport != NULL)
            {
            pImp = new CMailImporter;
            if (pImp == NULL)
                {
                hr = E_OUTOFMEMORY;
                }
            else
                {
                hr = pImp->Initialize(hwnd);
                if (SUCCEEDED(hr))
                    lpfnPerformImport(hwnd, pImp, 0);

                pImp->Release();
                }
            }

        FreeLibrary(hlibImport);
        }

    if (FAILED(hr))
        {
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrImport), hr);
        }
    }

// EXPORT STUFF

IMPFOLDERNODE *InsertFolderNode(IMPFOLDERNODE *plist, IMPFOLDERNODE *pnode)
    {
    BOOL fNodeNormal, fCurrNormal;
    IMPFOLDERNODE *pprev, *pcurr;

    Assert(pnode != NULL);
    pnode->pnext = NULL;

    if (plist == NULL)
        return(pnode);
    
    pprev = NULL;
    pcurr = plist;
    while (pcurr != NULL)
        {
        fNodeNormal = pnode->type == FOLDER_TYPE_NORMAL;
        fCurrNormal = pcurr->type == FOLDER_TYPE_NORMAL;

        if (!fNodeNormal &&
            fCurrNormal)
            break;
        
        if (fNodeNormal == fCurrNormal &&
            lstrcmpi(pnode->szName, pcurr->szName) <= 0)
            break;

        pprev = pcurr;
        pcurr = pcurr->pnext;
        }

    if (pcurr == NULL)
        {
        // insert at end of list
        Assert(pprev != NULL);
        pprev->pnext = pnode;
        }
    else if (pprev == NULL)
        {
        // insert at beginning of list
        pnode->pnext = plist;
        plist = pnode;
        }
    else
        {
        pprev->pnext = pnode;
        pnode->pnext = pcurr;
        }

    return(plist);
    }

HRESULT ExpGetSubFolders(IMPFOLDERNODE *pparent, FOLDERID idParent, IMPFOLDERNODE **pplist)
    {
    HRESULT hr;
    TCHAR *sz;
    IMPFOLDERNODE *pnode, *plist;
    HANDLE_16 hnd;
    FOLDERINFO Folder={0};
    IEnumerateFolders *pEnum;

    Assert(pplist != NULL);
    Assert(idParent != FOLDERID_INVALID);

    *pplist = NULL;
    plist = NULL;

    hr = g_pStore->EnumChildren(idParent, FALSE, &pEnum);
    if (SUCCEEDED(hr))
        {
        while (S_OK == pEnum->Next(1, &Folder, NULL))
            {
            if (!MemAlloc((void **)&pnode, sizeof(IMPFOLDERNODE) + CCHMAX_FOLDER_NAME * sizeof(TCHAR)))
                {
                hr = E_OUTOFMEMORY;
                break;
                }

            ZeroMemory(pnode, sizeof(IMPFOLDERNODE));
            sz = (TCHAR *)((BYTE *)pnode + sizeof(IMPFOLDERNODE));

            pnode->pparent = pparent;
            pnode->depth = (pparent != NULL) ? (pparent->depth + 1) : 0;
            pnode->szName = sz;
            lstrcpy(sz, Folder.pszName);
            pnode->lparam = (LPARAM)Folder.idFolder;
            pnode->cMsg = Folder.cMessages;

            if (Folder.tySpecial == FOLDER_INBOX)
                pnode->type = FOLDER_TYPE_INBOX;
            else if (Folder.tySpecial == FOLDER_OUTBOX)
                pnode->type = FOLDER_TYPE_OUTBOX;
            else if (Folder.tySpecial == FOLDER_SENT)
                pnode->type = FOLDER_TYPE_SENT;
            else if (Folder.tySpecial == FOLDER_DELETED)
                pnode->type = FOLDER_TYPE_DELETED;
            else if (Folder.tySpecial == FOLDER_DRAFT)
                pnode->type = FOLDER_TYPE_DRAFT;

            plist = InsertFolderNode(plist, pnode);

            hr = ExpGetSubFolders(pnode, Folder.idFolder, &pnode->pchild);
            if (FAILED(hr))
                break;

            g_pStore->FreeRecord(&Folder);
            }

        pEnum->Release();
        }

    *pplist = plist;

    g_pStore->FreeRecord(&Folder);

    return(hr);
    }

HRESULT WINAPI_16 ExpGetFolderList(IMPFOLDERNODE **pplist)
    {
    IMPFOLDERNODE *plist;
    HRESULT hr;

    if (pplist == NULL)
        return(E_INVALIDARG);

    plist = NULL;

    hr = ExpGetSubFolders(NULL, FOLDERID_LOCAL_STORE, &plist);
    if (FAILED(hr))
        {
        ExpFreeFolderList(plist);
        plist = NULL;
        }

    *pplist = plist;

    return(hr);
    }

void WINAPI_16 ExpFreeFolderList(IMPFOLDERNODE *plist)
    {
    IMPFOLDERNODE *pnode;

    while (plist != NULL)
        {
        if (plist->pchild != NULL)
            ExpFreeFolderList(plist->pchild);
        pnode = plist;
        plist = plist->pnext;
        MemFree(pnode);
        }
    }

void DoExport(HWND hwnd)
    {
    HRESULT hr;
    HMODULE hlibImport;
    PFNEXPMSGS lpfnExportMessages;

    hr = hrImportLoad;

    hlibImport = LoadLibrary(c_szImnimpDll);
    if (hlibImport != NULL)
        {
        lpfnExportMessages = (PFNEXPMSGS)GetProcAddress(hlibImport, MAKEINTRESOURCE(MAKELONG(3, 0)));
        if (lpfnExportMessages != NULL)
            {
            lpfnExportMessages(hwnd);
            hr = S_OK;
            }

        FreeLibrary(hlibImport);
        }

    if (FAILED(hr))
        {
        AthErrorMessageW(hwnd, MAKEINTRESOURCEW(idsAthenaMail), MAKEINTRESOURCEW(idsErrExport), hr);
        }
    }

typedef struct tagEXPENUM
    {
    IMessageFolder *pFolder;
    HROWSET hRowset;
    } EXPENUM;

HRESULT WINAPI_16 ExpGetFirstImsg(HANDLE idFolder, IMSG *pimsg, HANDLE_16 *phnd)
    {
    EXPENUM *penum;
    HRESULT hr;
    MESSAGEINFO MsgInfo;

    Assert(pimsg != NULL);
    Assert(phnd != NULL);
    *phnd = NULL;

    hr = E_FAIL;
    penum = NULL;

    if (!MemAlloc((void **)&penum, sizeof(EXPENUM)))
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        ZeroMemory(penum, sizeof(EXPENUM));

        hr = g_pStore->OpenFolder((FOLDERID)idFolder, NULL, NOFLAGS, &penum->pFolder);
        if (!FAILED(hr))
            {
            hr = penum->pFolder->CreateRowset(IINDEX_PRIMARY, NOFLAGS, &penum->hRowset);
            if (!FAILED(hr))
                {
                hr = penum->pFolder->QueryRowset(penum->hRowset, 1, (LPVOID *)&MsgInfo, NULL);
                if (!FAILED(hr))
                    {
                    if (S_OK == hr)
                        {
                        hr = GetImsgFromFolder(penum->pFolder, &MsgInfo, pimsg);
                        penum->pFolder->FreeRecord(&MsgInfo);
                        }
                    else
                        Assert(S_FALSE == hr);
                    }
                }
            }
        }

    if (hr != S_OK)
        {
        ExpGetImsgClose((HANDLE_16)penum);
        penum = NULL;
        }

    *phnd = (HANDLE_16)penum;

    return(hr);
    }

HRESULT WINAPI_16 ExpGetNextImsg(IMSG *pimsg, HANDLE_16 hnd)
    {
    HRESULT hr;
    EXPENUM *pee;
    MESSAGEINFO MsgInfo;

    Assert(pimsg != NULL);
    Assert(hnd != NULL);

    pee = (EXPENUM *)hnd;

    hr = pee->pFolder->QueryRowset(pee->hRowset, 1, (LPVOID *)&MsgInfo, NULL);
    if (hr == S_OK)
        {
        hr = GetImsgFromFolder(pee->pFolder, &MsgInfo, pimsg);
        pee->pFolder->FreeRecord(&MsgInfo);
        }

    return(hr);
    }

void WINAPI_16 ExpGetImsgClose(HANDLE_16 hnd)
    {
    EXPENUM *pee;

    pee = (EXPENUM *)hnd;

    if (pee != NULL)
        {
        if (pee->pFolder != NULL)
            {
            pee->pFolder->CloseRowset(&pee->hRowset);
            pee->pFolder->Release();
            }

        MemFree(pee);
        }
    }

HRESULT GetImsgFromFolder(IMessageFolder *pfldr, LPMESSAGEINFO pMsgInfo, IMSG *pimsg)
    {
    LPMIMEMESSAGE   pMsg;
    HRESULT         hr =  E_OUTOFMEMORY;

    // for import/export we want the secure message, so pass TRUE
    hr = pfldr->OpenMessage(pMsgInfo->idMessage, OPEN_MESSAGE_SECURE, &pMsg, NOSTORECALLBACK);
    if (SUCCEEDED(hr))
        {
        hr = HrMailMsgToImsg(pMsg, pMsgInfo, pimsg);
        pMsg->Release();
        }            

    return(hr);
    }

void DoMigration(HWND hwnd)
    {
    HMODULE hlibImport;
    PFNPERFORMMIGRATION lpfnPerformMigration;
    CMailImporter *pImp;
    
    if (!!DwGetOption(OPT_MIGRATION_PERFORMED))
        return;

    hlibImport = LoadLibrary(c_szImnimpDll);
    if (hlibImport != NULL)
        {
        lpfnPerformMigration = (PFNPERFORMMIGRATION)GetProcAddress(hlibImport, achPerformMigration);
        if (lpfnPerformMigration != NULL)
            {
            pImp = new CMailImporter;
            if (pImp != NULL)
                {
                if (SUCCEEDED(pImp->Initialize(hwnd)) &&
                    SUCCEEDED(lpfnPerformMigration(hwnd, pImp, 0)))
                    {
                    SetDwOption(OPT_MIGRATION_PERFORMED, TRUE, NULL, 0);
                    }

                pImp->Release();
                }
            }

        FreeLibrary(hlibImport);
        }
    }


HRESULT SimpleImportMailFolders(
    IMailImporter *pMailImporter, 
    IMailImport *pMailImport, 
    DWORD_PTR dwSourceCookie, 
    DWORD_PTR dwParentDestCookie)
{
    HRESULT hr = S_OK;
    DWORD_PTR cookie;
    IMPORTFOLDER folder;
    IFolderImport *pFolderImport = NULL;
    IEnumFOLDERS *pFolderEnum = NULL;

    // Enumerate source folders
    IF_FAILEXIT(hr = pMailImport->EnumerateFolders(dwSourceCookie, &pFolderEnum));

    do {
        // Get next source folder
        hr = pFolderEnum->Next(&folder);
        if (hr == S_OK) {
            // Open the destination folder by this name in this hierarchy position
            hr = pMailImporter->OpenFolder(dwParentDestCookie,
                                           folder.szName, 
                                           FOLDER_TYPE_NORMAL, 
                                           0, 
                                           &pFolderImport, 
                                           &cookie);
            if (!FAILED(hr)) {
                // Import the enumerated source folder into the opened destination folder
                pMailImport->ImportFolder(folder.dwCookie, pFolderImport);

                // Close the destination folder
                SafeRelease(pFolderImport);

                if (folder.fSubFolders > 0) {
                    // Recursively import subfolders
                    SimpleImportMailFolders(pMailImporter, pMailImport, folder.dwCookie, cookie);
                }
            }
        }
    } while (hr == S_OK);

exit:
    SafeRelease(pFolderImport);
    SafeRelease(pFolderEnum);

    return hr;
}


HRESULT SimpleImportNewsList(CMessageStore *pSrcStore)
    {
    HRESULT hr = S_OK;
    IEnumerateFolders *pEnum = NULL;
    FOLDERINFO info;

    IF_FAILEXIT(hr = pSrcStore->EnumChildren(FOLDERID_ROOT, TRUE, &pEnum));

    while (S_OK == pEnum->Next(1, &info, NULL)) {
        // info.pszName is the server/account name
        // info.pszAccountId is the source's account ID
        // info.idFolder is this account's folder ID
        // info.dwFlags contains FOLDER_HASCHILDREN
        // info.tyFolder specifies FOLDER_NEWS

        if ((info.tyFolder == FOLDER_NEWS) &&
            (info.dwFlags & FOLDER_HASCHILDREN)) {

            IImnAccount *pAccount = NULL;
            
            // Match this account to the destination
            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, info.pszName, &pAccount);

            if ((hr == S_OK) && (pAccount != NULL)) {
                TCHAR szID[CCHMAX_ACCOUNT_NAME];

                hr = pAccount->GetPropSz(AP_ACCOUNT_ID, szID, ARRAYSIZE(szID));

                if (hr == S_OK) {
                    IEnumerateFolders *pEnumDest = NULL;
                    IEnumerateFolders *pEnumChild = NULL;
                    FOLDERID destFolderID = 0;

                    // Lookup destination folder id for this account name
                    hr = g_pStore->EnumChildren(FOLDERID_ROOT, TRUE, &pEnumDest);
                    if ((hr == S_OK) && (pEnumDest != NULL)) {
                        FOLDERINFO infoDest;

                        while (S_OK == pEnumDest->Next(1, &infoDest, NULL)) {
                            if ((destFolderID == 0) &&
                                (_tcscmp(info.pszName, infoDest.pszName) == 0)) {
                                destFolderID = infoDest.idFolder;
                            }
                            g_pStore->FreeRecord(&infoDest);
                        }
                    }
                    SafeRelease(pEnumDest);

                    // Read in source newsgroups
                    hr = pSrcStore->EnumChildren(info.idFolder, TRUE, &pEnumChild);

                    if ((hr == S_OK) && (pEnumChild != NULL)) {

                        FOLDERINFO infoChild;

                        // Add folders to destination account
                        while(S_OK == pEnumChild->Next(1, &infoChild, NULL)) {
                            LPSTR oldID;

                            // infoChild.idParent needs to be the dest server folder ID

                            oldID = infoChild.pszAccountId;
                            infoChild.pszAccountId = szID;
                            infoChild.idParent = destFolderID;

                            hr = g_pStore->CreateFolder(CREATE_FOLDER_LOCALONLY, &infoChild, NOSTORECALLBACK);
                            if (SUCCEEDED(hr)) {
                                hr = g_pStore->SubscribeToFolder(infoChild.idFolder, TRUE, NULL);
                            }
                            infoChild.pszAccountId = oldID;

                            pSrcStore->FreeRecord(&infoChild);
                        }
                    }
                    SafeRelease(pEnumChild);
                }
            }
            SafeRelease(pAccount);
        }
        pSrcStore->FreeRecord(&info);
    }


exit:
    SafeRelease(pEnum);

    return hr;
}


HRESULT ImportMailStoreToGUID(IMailImport *pMailImport, GUID *pDestUUID, LPCSTR pszDestStoreDir)
    {
    HRESULT hr = S_OK;

    CMailImporter *pNew=NULL;
    pNew = new CMailImporter;
    IF_NULLEXIT(pNew);

    // Sometimes during the SimpleStoreInit, Wab is initialized as well.
    // Since it is never terminated, some registry key will remain opened.
    // The consumer of this function will not be able to unload a mapped user
    // hive because of this. To fix this problem, we added the Wab init here
    // and an corresponding Wab done later on.
    HrInitWab (TRUE);

    IF_FAILEXIT(SimpleStoreInit(pDestUUID, pszDestStoreDir));

    IF_FAILEXIT(SimpleImportMailFolders(pNew, pMailImport, COOKIE_ROOT, COOKIE_ROOT));
 
exit:
    SimpleStoreRelease();

    HrInitWab (FALSE);

    SafeRelease(pNew);

    return hr;
    }

HRESULT ImportNewsListToGUID(LPCSTR pszSrcPath, GUID *pDestUUID, LPCSTR pszDestStoreDir)
    {
    HRESULT hr = S_OK;

    CMessageStore *pSrcStore=NULL;
    pSrcStore = new CMessageStore(FALSE);
    IF_NULLEXIT(pSrcStore);

    IF_FAILEXIT(pSrcStore->Initialize(pszSrcPath));

    // Sometimes during the SimpleStoreInit, Wab is initialized as well.
    // Since it is never terminated, some registry key will remain opened.
    // The consumer of this function will not be able to unload a mapped user
    // hive because of this. To fix this problem, we added the Wab init here
    // and an corresponding Wab done later on.
    HrInitWab (TRUE);

    IF_FAILEXIT(SimpleStoreInit(pDestUUID, pszDestStoreDir));

    IF_FAILEXIT(SimpleImportNewsList(pSrcStore));

exit:
    SimpleStoreRelease();

    HrInitWab (FALSE);

    SafeRelease(pSrcStore);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\impapi.h ===
#ifndef _INC_IMPAPI_H
#define _INC_IMPAPI_H

typedef enum tagIMPORTFOLDERTYPE IMPORTFOLDERTYPE;

#define INVALID_FOLDER_HANDLE   ((HANDLE)MAXULONG_PTR)

typedef struct tagIMPFOLDERNODE
    {
    struct tagIMPFOLDERNODE *pnext;
    struct tagIMPFOLDERNODE *pchild;
    struct tagIMPFOLDERNODE *pparent;

    int depth;
    TCHAR *szName;
    IMPORTFOLDERTYPE type;
    ULONG cMsg;

    LPARAM lparam;

    BOOL fImport;
    DWORD_PTR dwReserved;   // for use by the import code, the client code should ignore this
    } IMPFOLDERNODE;

typedef struct IMSG IMSG;

void DoImport(HWND hwnd);

void DoMigration(HWND hwnd);

typedef HRESULT (*PFNEXPMSGS)(HWND);

void DoExport(HWND hwnd);

#ifdef WIN16
EXTERN_C {
#endif
HRESULT WINAPI_16 ExpGetFolderList(IMPFOLDERNODE **plist);
typedef HRESULT (*PFNEXPGETFOLDERLIST)(IMPFOLDERNODE **);

void WINAPI_16 ExpFreeFolderList(IMPFOLDERNODE *plist);
typedef void (*PFNEXPFREEFOLDERLIST)(IMPFOLDERNODE *);

HRESULT WINAPI_16 ExpGetFirstImsg(HANDLE hfolder, IMSG *pimsg, HANDLE_16 *phnd);
typedef HRESULT (*PFNEXPGETFIRSTIMSG)(HANDLE, IMSG *, HANDLE_16 *);

HRESULT WINAPI_16 ExpGetNextImsg(IMSG *pimsg, HANDLE_16 hnd);
typedef HRESULT (*PFNEXPGETNEXTIMSG)(IMSG *, HANDLE_16);

void WINAPI_16 ExpGetImsgClose(HANDLE_16 hnd);
typedef void (*PFNEXPGETIMSGCLOSE)(HANDLE_16);
#ifdef WIN16
}
#endif

#endif // _INC_IMPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\imagelst.cpp ===
/*
 *  i m a g e l s t . c p p
 *
 *  Purpose:                     
 *      utilities for images and imagelists
 *    
 *  Copyright (C) Microsoft Corp. 1996
 * 
 */

#include "pch.hxx"
#include "resource.h"   // idb stuff
#include "imagelst.h"

/////////////////////////////////////////////////////////////////////////////
// 
// Macros
//

#define ILT_PARTIALBLT_LEFT     0
#define ILT_PARTIALBLT_TOP      1
#define ILT_PARTIALBLT_RIGHT    2
#define ILT_PARTIALBLT_BOTTOM   3

/////////////////////////////////////////////////////////////////////////////
//
// Global Data
//

static HIMAGELIST g_himlAthSm = NULL;
static HIMAGELIST g_himlAthSt = NULL;

/////////////////////////////////////////////////////////////////////////////
// 
// Prototypes
//

HIMAGELIST InitImageList(int cx, int cy, LPSTR szbm, int cicon);

//
// TileImage
//
// This function tiles a bitmap in lprcDest, using lpptOrigin as the origin
//
void TileImage(HBITMAP hbmp, HDC hdc, LPPOINT lpptOrigin, LPRECT lprcDest)
{
    BOOL    fFirstRow, fFirstCol;
    int     nRows, nCols, nSaveCols, offset;
    int     rgOffsetPartialBlt[4];
    POINT   ptTileOrigin, ptDraw, ptDest, ptSrc;
    SIZE    sizeImage, sizeRect, sizeBlt;
    HDC     hdcBmp=0;
    HBITMAP hbmpOrig=0;
    BITMAP  bm;

    if(!hdc)
        return;

    if(!(hdcBmp = CreateCompatibleDC(hdc)))
        goto fail;

    if(!(hbmpOrig = SelectBitmap(hdcBmp, hbmp)))
        goto fail;
    
    GetObject(hbmp, sizeof(BITMAP), &bm);
    sizeImage.cx = bm.bmWidth;
    sizeImage.cy = bm.bmHeight;

    // Generate the true origin with the tile
    lpptOrigin->x %= sizeImage.cx;
    lpptOrigin->y %= sizeImage.cy;

    // We will start the tile so that the origin lines up
    ptTileOrigin.x = lprcDest->left - lpptOrigin->x;
    ptTileOrigin.y = lprcDest->top - lpptOrigin->y;

    // Figure out how many rows and columns wo need
    sizeRect.cx = lprcDest->right - ptTileOrigin.x;
    sizeRect.cy = lprcDest->bottom - ptTileOrigin.y;

    nRows = sizeRect.cy / sizeImage.cy;
    nRows += (sizeRect.cy % sizeImage.cy) ? 1 : 0;
    nSaveCols = sizeRect.cx / sizeImage.cx;
    nSaveCols += (sizeRect.cx % sizeImage.cx) ? 1 : 0;

    // Generate the partial blt offsets
    rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] = lprcDest->top - ptTileOrigin.y;
     rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] = lprcDest->left - ptTileOrigin.x;
    if (sizeImage.cy >= sizeRect.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy - sizeRect.cy;
    else if(sizeRect.cy % sizeImage.cy)
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = sizeImage.cy -
                (sizeRect.cy % sizeImage.cy);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] = 0;
    if (sizeImage.cx >= sizeRect.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx - sizeRect.cx;
    else if(sizeRect.cx % sizeImage.cx)
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = sizeImage.cx -
                (sizeRect.cx % sizeImage.cx);
    else
        rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] = 0;

    // Draw the tiles
    ptDraw.y = ptTileOrigin.y;
    fFirstRow = TRUE;
    while (nRows--)
        {
        ptDraw.x = ptTileOrigin.x;
        nCols = nSaveCols;
        fFirstCol = TRUE;
        while (nCols--)
            {
            ptDest = ptDraw;
            sizeBlt = sizeImage;
            ptSrc.x = ptSrc.y = 0; 
            // Handle partial boundary Blts
            if (fFirstRow && rgOffsetPartialBlt[ILT_PARTIALBLT_TOP] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_TOP];
                ptDest.y += offset;
                sizeBlt.cy -= offset;
                ptSrc.y += offset;
                }
            if (nRows == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM] != 0)
                sizeBlt.cy -= rgOffsetPartialBlt[ILT_PARTIALBLT_BOTTOM];
            if (fFirstCol && rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT] != 0)
                {
                offset = rgOffsetPartialBlt[ILT_PARTIALBLT_LEFT];
                ptDest.x += offset;
                sizeBlt.cx -= offset;
                ptSrc.x += offset;
                }
            if (nCols == 0 && rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT] != 0)
                sizeBlt.cx -= rgOffsetPartialBlt[ILT_PARTIALBLT_RIGHT];
            // Just do it
            BitBlt(hdc, ptDest.x, ptDest.y,    sizeBlt.cx, sizeBlt.cy,
                    hdcBmp, ptSrc.x, ptSrc.y, SRCCOPY);
            ptDraw.x += sizeImage.cx;
            fFirstCol = FALSE;
            }
        ptDraw.y += sizeImage.cy;
        fFirstRow = FALSE;
        }

fail:
    if(hdcBmp) 
        {
        if(hbmpOrig)
            SelectBitmap(hdcBmp, hbmpOrig);
        DeleteDC(hdcBmp);
        }
}

HIMAGELIST InitImageList(int cx, int cy, LPCSTR szbm, int cicon, COLORREF cr)
{
    HBITMAP hbm;
    HIMAGELIST himl;

    if(!fIsWhistler())
        himl = ImageList_Create(cx, cy, ILC_MASK, cicon, 0);
    else
        himl = ImageList_Create(cx, cy, ILC_COLOR32|ILC_MASK, cicon, 0);

    if (himl != NULL)
        {
        hbm = LoadBitmap(g_hLocRes, szbm);
        Assert(hbm != NULL);

        ImageList_AddMasked(himl, hbm, cr);

        DeleteObject((HGDIOBJ)hbm);
        }

    return(himl);
}

HIMAGELIST GetImageList(UINT fIml)
{
    if (fIml == GIML_SMALL)
    {
        if (g_himlAthSm == NULL)
        {
            g_himlAthSm = InitImageList(cxImlSmall, cyImlSmall, MAKEINTRESOURCE(idb16x16), iiconSmMax, RGB(255, 0, 255));
            ImageList_SetOverlayImage(g_himlAthSm, iiconReplyOverlay, OVERLAY_REPLY);
            ImageList_SetOverlayImage(g_himlAthSm, iiconForwardOverlay, OVERLAY_FORWARD);
        }

        return(g_himlAthSm);
    }
    else if (fIml == GIML_STATE)
    {
        if (g_himlAthSt == NULL)
            g_himlAthSt = InitImageList(cxImlSmall, cyImlSmall, MAKEINTRESOURCE(idb16x16st), iiconStMax, RGB(255, 0, 255));
        return(g_himlAthSt);
    }

    return(NULL);
}

void FreeImageLists(void)
{
    if (g_himlAthSm != NULL)
        {
        ImageList_Destroy(g_himlAthSm);
        g_himlAthSm = NULL;
        }

    if (g_himlAthSt != NULL)
        {
        ImageList_Destroy(g_himlAthSt);
        g_himlAthSt = NULL;
        }
}

BOOL LoadBitmapAndPalette(int idbmp, HBITMAP *phbmp, HPALETTE *phpal)
{
    int i, n;
    HBITMAP hbmp;
    HPALETTE hpal;
    HDC hdcBitmap;
    DWORD adw[257];
    BOOL fret = FALSE;

    Assert(phbmp != NULL);
    Assert(phpal != NULL);

    hdcBitmap = NULL;
    *phbmp = NULL;
    *phpal = NULL;

    hbmp = (HBITMAP)LoadImage(g_hLocRes, MAKEINTRESOURCE(idbmp),
                    IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if (hbmp == NULL)
        goto DoneLoadBitmap;

    hdcBitmap = CreateCompatibleDC(NULL);
    if (hdcBitmap == NULL)
        goto DoneLoadBitmap;
    SelectObject(hdcBitmap, (HGDIOBJ)hbmp);
    n = GetDIBColorTable(hdcBitmap, 0, 256, (LPRGBQUAD)&adw[1]);
    for (i = 1; i <= n; i++)
        adw[i] = RGB(GetBValue(adw[i]), GetGValue(adw[i]), GetRValue(adw[i]));
    adw[0] = MAKELONG(0x300, n);
    hpal = CreatePalette((LPLOGPALETTE)&adw[0]);
    if (hpal == NULL)
        goto DoneLoadBitmap;

    *phbmp = hbmp;
    *phpal = hpal;

    fret = TRUE;

DoneLoadBitmap:
    if (hdcBitmap != NULL)
        DeleteDC(hdcBitmap);

    return(fret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\imsgcont.h ===
////////////////////////////////////////////////////////////////////////
//
//  IMsgContainer
//
//  Manages internet message headers
//
////////////////////////////////////////////////////////////////////////

#ifndef _INC_IMSGCONT_H
#define _INC_IMSGCONT_H

#include "columns.h"

typedef struct tagFINDMSG FINDMSG;

// from inc\storbase.h
typedef DWORD   MSGID;

// Used for MarkThread()
typedef enum {
    MARK_THD_NO_SUPERPARENT =   0x0001,
    MARK_THD_FOR_DL =           0x0002,
    MARK_THD_NO_DL =            0x0004,
    MARK_THD_AS_READ =          0x0008,
    MARK_THD_AS_UNREAD =        0x0010
} MARKTHREADTYPE;

// Used in RemoveHeaders() and by the view
typedef enum {
    FILTER_NONE         = 0x0001,   // show all (cannot be used w/ other flags)
    FILTER_READ         = 0x0002,   // hide read messages
    FILTER_NOBODY       = 0x0004,   // hide messages without dl'd bodies
    FILTER_SHOWFILTERED = 0x0008,   // display filtered messages
    FILTER_SHOWDELETED  = 0x0010,   // display deleted messages
    PRUNE_NONREPLIES    = 0x0020,   // hide threads that are not replies to sender
} FILTERTYPE;

// Generic flags for IMessageCont methods
// use these if there is no specific set below
#define IMC_BYMSGID     0x0000      // dwIndex is a msgid (DEFAULT)
#define IMC_BYROW       0x0001      // dwIndex specifies a row
#define IMC_COMMONFLAGS 0x0002      // the mask, state, dword, whatever is SCFS_ flags (otherwise ARF_ or MSG_)
#define IMC_CONVERTARFTOMSG 0x0004

// Used by HrGetNext
#define GNM_NEXT        0x0000      // get next (DEFAULT)
// 0x0001 reserved for IMC_BYROW
// IMC_COMMONFLAGS not accepted
#define GNM_PREV        0x0004      // get previous instead of next (can't be used with GNM_UNREAD or GNM_THREAD)
#define GNM_UNREAD      0x0008      // get next unread (can't be used with GNM_PREV)
#define GNM_THREAD      0x0010      // get next thread (can't be used with GNM_PREV)
#define GNM_SKIPMAIL    0x0020      // skip over mail messages
#define GNM_SKIPNEWS    0x0040      // skip over news messages
#define GNM_SKIPUNSENT  0x0080      // skip unsent messages

// Used by GetMsgBy
#define GETMSG_SECURE   (TRUE)
#define GETMSG_INSECURE (FALSE)

// State and mask flags for SetCachedFlags
// NOTE: we list here only the flags that are easily convertable
// between ARF_ and MSG_.  Our flag situation is very annoying.
#define SCFS_NOSECUI    0x0001
#define SCFS_ALLFLAGS   0x0001      // do not use explicitly

DECLARE_INTERFACE(IMsgContainer)
{
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;
    STDMETHOD(Advise) (THIS_ HWND hwndAdvise) PURE;
    STDMETHOD(CollapseBranch) (THIS_ DWORD dwRow, LPDWORD pdwCount) PURE;
    STDMETHOD(ExpandAllThreads) (THIS_ BOOL fExpand) PURE;
    STDMETHOD(ExpandBranch) (THIS_ DWORD dwRow, LPDWORD pdwCount) PURE;
    STDMETHOD_(ULONG, GetCount) (THIS) PURE;
    STDMETHOD(GetDisplayInfo) (THIS_ LV_DISPINFO *plvdi, COLUMN_ID idColumn) PURE;
    STDMETHOD_(int, GetIndex) (THIS_ DWORD dwMsgId, BOOL fForceUnthreadedSearch = FALSE) PURE;
    STDMETHOD_(BOOL, GetMsgId) (THIS_ DWORD dwRow, LPDWORD pdwMsgId) PURE;
    STDMETHOD(GetMsgByIndex) (THIS_ DWORD dwRow, LPMIMEMESSAGE *ppMsg, HWND hwnd, BOOL *pfCached, BOOL fDownload, BOOL fSecure) PURE;
    STDMETHOD(GetMsgByMsgId) (THIS_ MSGID msgid, LPMIMEMESSAGE *ppMsg, HWND hwnd, BOOL *pfCached, BOOL fDownload, BOOL fSecure) PURE;
    STDMETHOD(HrFindItem) (THIS_ LPCSTR szSearch, ULONG *puRow) PURE;
    STDMETHOD(HrGetNext) (THIS_ DWORD dwIndex, LPDWORD pdwMsgId, DWORD dwFlags) PURE;
    STDMETHOD_(BOOL, FFlagState) (THIS_ DWORD dwIndex, DWORD dwMask, DWORD dwFlags) PURE;
    STDMETHOD_(BOOL, IsCollapsedThread) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, HasBody) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, HasKids) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, IsRowRead) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, IsRowOrChildUnread) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(BOOL, IsRowFiltered) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(void, MarkAll) (THIS_ BOOL fRead) PURE;
    STDMETHOD_(void, MarkAllDL) (THIS_ BOOL fDL) PURE;
    STDMETHOD_(void, MarkSelected) (THIS_ HWND hwndList, MARKTHREADTYPE mtt) PURE;
    STDMETHOD_(void, MarkOne) (THIS_ BOOL fRead, DWORD dwMsgId) PURE;
    STDMETHOD_(void, MarkOneRow) (THIS_ BOOL fRead, DWORD dwRow) PURE;
    STDMETHOD_(void, MarkOneRowDL) (THIS_ BOOL fDL, DWORD dwRow) PURE;
    STDMETHOD(MarkThread) (THIS_ DWORD mtType, DWORD dwRow) PURE;
    STDMETHOD_(void, SetFilterState) (THIS_ DWORD dwFilterState) PURE;
    STDMETHOD_(void, SetViewWindow) (THIS_ HWND hwnd, BOOL fNoUI) PURE;
    STDMETHOD_(void, Sort) (THIS_ COLUMN_ID idSort, BOOL fReverse, BOOL fThread) PURE;
    STDMETHOD(Unadvise) (THIS_ HWND hwndAdvise) PURE;
    STDMETHOD(HrFindNext) (THIS_ FINDMSG *pfmsg, DWORD dwRow, BOOL fIgnoreFirst) PURE;
    STDMETHOD(CreateDragObject) (THIS_ HWND hwndList, DWORD *pdwEffectOk, IDataObject **ppDataObject) PURE;
    STDMETHOD(Delete) (THIS_ DWORD dwMsgId, BOOL fForce) PURE;
    STDMETHOD(SetCachedFlagsBy) (THIS_ DWORD dwIndex, DWORD dwState, DWORD dwStateMask, DWORD *pdwNewFlags, DWORD dwFlags) PURE;
    STDMETHOD(SetMsgViewLanguage) (THIS_ MSGID msgid, DWORD dwCodePage) PURE;
    STDMETHOD(GetMsgViewLanguage) (THIS_ MSGID msgid, DWORD *pdwCodePage) PURE;
    STDMETHOD_(void, SetUIMode) (THIS_ BOOL fUI) PURE;
    STDMETHOD_(int, GetItemParent) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(int, GetFirstChild) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(int, GetEmptyFolderString) (THIS) PURE;
    STDMETHOD_(BOOL, IsRowDeleted) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(WORD, GetRowHighlight) (THIS_ DWORD dwRow) PURE;
    STDMETHOD_(void, UpdateAdvises)(THIS_ DWORD dwMsgId) PURE;
};

#endif // _INC_IMSGCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inetcfg.cpp ===
#include "pch.hxx"
#include "strconst.h"
#include "error.h"
#include "acctutil.h"
#include "inetcfg.h"
#include <icwcfg.h>
#include "impapi.h"
#include <options.h>
#include <shlwapi.h>
#include "shlwapip.h" 
#include "regutil.h"
#include <resource.h>
#include "instance.h"
#include <browser.h>
#include <multiusr.h>
#include "demand.h"

ASSERTDATA

void HandleIncompleteAccts(HWND hwnd, BOOL fMail);

DWORD g_dwIcwFlags = 0;     //Cleared when switching identities
static const TCHAR c_szSetShellNext[] = TEXT("SetShellNext");

HRESULT GetDefaultNameEmail(BOOL fMail, LPSTR pszName, int cchName, LPSTR pszEmail, int cchEmail)
{
    HRESULT hr;
    IImnAccount *pAcct;

    Assert(pszName != NULL);
    Assert(pszEmail != NULL);

    pAcct = NULL;

    hr = g_pAcctMan->GetDefaultAccount(fMail ? ACCT_MAIL : ACCT_NEWS, &pAcct);
    if (FAILED(hr))
    {
        Assert(pAcct == NULL);
        fMail = !fMail;

        hr = g_pAcctMan->GetDefaultAccount(fMail ? ACCT_MAIL : ACCT_NEWS, &pAcct);
        if (FAILED(hr))
            return(E_FAIL);
    }

    Assert(pAcct != NULL);

    *pszName = 0;
    *pszEmail = 0;

    pAcct->GetPropSz(fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, pszName, cchName);
    pAcct->GetPropSz(fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, pszEmail, cchEmail);
    
    pAcct->Release();

    return(S_OK);
}

HRESULT NeedToRunICW(LPCSTR pszCmdLine)
{
    char        *sz;
    HINSTANCE   hlib;
    HRESULT     hr;
    LONG        lRes;
    HKEY        hkey;
    BOOL        fRunICW;
    PFNCHECKCONNECTIONWIZARD pfnWiz;
    PFNSETSHELLNEXT pfnSet;
    DWORD       dw, cb, dwType;
    
    Assert(pszCmdLine != NULL);
    
    hr = S_FALSE;
    
    g_dwIcwFlags = 0;   //re-initialize this in case the user is switching
    
    fRunICW = TRUE;
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, ICW_REGPATHSETTINGS, ICW_REGKEYCOMPLETED, &dwType, (LPBYTE)&dw, &cb))
        fRunICW = (dw == 0);
    
    if (fRunICW)
    {
        if (MemAlloc((void **)&sz, MAX_PATH))
        {
            hlib = LoadLibrary(c_szInetcfgDll);
            if (hlib != NULL)
            {
                pfnWiz = (PFNCHECKCONNECTIONWIZARD)GetProcAddress(hlib, c_szCheckConnWiz);
                pfnSet = (PFNSETSHELLNEXT)GetProcAddress(hlib, c_szSetShellNext);
                if (pfnWiz != NULL && pfnSet != NULL)
                {
                    if (GetExePath(c_szMainExe, &sz[1], MAX_PATH - 1, FALSE))
                    {
                        sz[0] = '"';
                        cb = lstrlen(sz);
                        sz[cb] = '"';
                        cb++;
                        sz[cb] = 0; // in case we don't append the arg
                        
                        dw = lstrlen(pszCmdLine);
                        if (dw > 0 && (dw + cb + 3) <= MAX_PATH)
                            // room for a space (between exe and arg), escape backslash, and terminating NULL
                        {
                            sz[cb] = ' ';
                            cb++;
                            
                            if (*pszCmdLine == '/')
                            {
                                sz[cb] = '/';
                                cb++;
                            }
                            
                            lstrcpy(&sz[cb], pszCmdLine);
                        }
                        
                        dwType = ICW_LAUNCHFULL | ICW_LAUNCHMANUAL;
                        if (ERROR_SUCCESS == pfnSet(sz))
                            dwType |= ICW_USE_SHELLNEXT;
                        
                        if (ERROR_SUCCESS == pfnWiz(dwType, &dw))
                        {
                            if (!!(dw & (ICW_LAUNCHEDFULL | ICW_LAUNCHEDMANUAL)))
                                hr = S_OK;
                            else
                                hr = S_FALSE;
                        }
                    }
                }
                
                FreeLibrary(hlib);
            }
            
            MemFree(sz);
        }
    }
    
    return(hr);
}

void SetStartFolderType(FOLDERTYPE fType)
{
    if (fType == FOLDER_LOCAL || fType == FOLDER_IMAP || fType == FOLDER_HTTPMAIL)
        g_dwIcwFlags |= ICW_MAIL_START;
    else if (fType == FOLDER_NEWS)
        g_dwIcwFlags |= ICW_NEWS_START;
    else
    {
        Assert(fType == FOLDER_ROOTNODE);
    }
}

BOOL FMailWizardNeeded(VOID)
{
    // Locals
    ULONG           cAccts;
    
    // We better have been initialized
    Assert(g_pAcctMan != NULL);
    
    // No SMTP, POP3 or IMAP servers ?
    if (!g_pAcctMan || FAILED(g_pAcctMan->GetAccountCount(ACCT_MAIL, &cAccts)))
        cAccts = 0;
    
    // No mail servers configured
    return(cAccts == 0);
}

// fForce defaults to FALSE, fShowUI defaults to TRUE
HRESULT ProcessICW(HWND hwnd, FOLDERTYPE fType, BOOL fForce, BOOL fShowUI)
{
    HRESULT     hr;
    DWORD       dwProp;
    FOLDERID    id;
    BOOL        fMail, fBrowse;
    DWORD       cNewsServers;
    TCHAR       sz[CCHMAX_DISPLAY_NAME], szT[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAcct;
    
    if (fType == FOLDER_ROOTNODE)
    {
        // we're at the root
        if (!!(g_dwIcwFlags & ICW_MAIL_START))
        {
            // if we were started up with a mail arg, then we'll behave
            // as if we're in a mail folder
            fType = FOLDER_LOCAL;
        }
        else if (!!(g_dwIcwFlags & ICW_NEWS_START))
        {
            // started with a news arg, so we'll behave as if
            // we're in a news folder
            fType = FOLDER_NEWS;
        }
        else
        {
            // just started at the root, let's assume mail
            fType = FOLDER_LOCAL;
        }
    }
    
    fMail = (fType != FOLDER_NEWS) && ((g_dwAthenaMode & MODE_OUTLOOKNEWS) != MODE_OUTLOOKNEWS);
    
    if (fMail)
    {
        if (0 == (g_dwIcwFlags & ICW_MAIL_DEF))
        {
            if (!(g_dwAthenaMode & MODE_NEWSONLY))
            {
                if (fShowUI)
                    DoDefaultClientCheck(hwnd, DEFAULT_MAIL);
            }        
            g_dwIcwFlags |= ICW_MAIL_DEF;
        }
        
        // if the wizard has already attempted to be run for mail
        // or it isn't needed, then we're done
        if (((!fForce && DwGetOption(OPT_CHECKEDMAILACCOUNTS)) || !FMailWizardNeeded()))
        {
            if (fShowUI)
            {
                DoMigration(hwnd);
                SetDwOption(OPT_CHECKEDMAILACCOUNTS, 1, NULL, 0);
            }
            
            return(S_OK);
        }
    }
    else
    {
        if (0 == (g_dwIcwFlags & ICW_NEWS_DEF))
        {
            if ((g_dwAthenaMode & MODE_OUTLOOKNEWS) == MODE_OUTLOOKNEWS)
                DoDefaultClientCheck(hwnd, DEFAULT_NEWS | DEFAULT_OUTNEWS);
            else
                DoDefaultClientCheck(hwnd, DEFAULT_NEWS);
            
            g_dwIcwFlags |= ICW_NEWS_DEF;
        }
        
        // if the wizard has already attempted to be run for news
        // or it isn't needed, then we're done
        g_pAcctMan->GetAccountCount(ACCT_NEWS, &cNewsServers);
        if (cNewsServers || (!fForce && DwGetOption(OPT_CHECKEDNEWSACCOUNTS)))
        {
            SetDwOption(OPT_CHECKEDNEWSACCOUNTS, 1, NULL, 0);
            
            return(S_OK);
        }
    }
    
    Assert(g_pAcctMan != NULL);

    // We are missing information and need to bring up the ICW,
    // but only do so if we are allowed to show UI (some SMAPI codepaths prevent this)
    if (!fShowUI || !g_pAcctMan)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    fBrowse = FALSE;
    id = FOLDERID_INVALID;

    hr = g_pAcctMan->CreateAccountObject(fMail ? ACCT_MAIL : ACCT_NEWS, &pAcct);
    if (SUCCEEDED(hr))
    {
        hr = GetDefaultNameEmail(fMail, sz, ARRAYSIZE(sz), szT, ARRAYSIZE(szT));
        if (SUCCEEDED(hr))
        {
            if (*sz != 0)
                pAcct->SetPropSz(fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, sz);

            if (*szT != 0)
                pAcct->SetPropSz(fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, szT);
        }
        
        hr = pAcct->DoWizard(hwnd, ACCT_WIZ_MIGRATE | ACCT_WIZ_INTERNETCONNECTION |
            ACCT_WIZ_HTTPMAIL | ACCT_WIZ_OE);
        // Test g_pBrowser as no need to browse if got here via startup code
        if (g_pBrowser &&
            hr == S_OK &&
            SUCCEEDED(pAcct->GetServerTypes(&dwProp)) &&
            0 == (dwProp & SRV_POP3) &&
            SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szT, ARRAYSIZE(szT))) &&
            SUCCEEDED(g_pStore->FindServerId(szT, &id)))
        {
            fBrowse = TRUE;
        }

        pAcct->Release();    
    }
    
    if (fMail)
    {
        SetDwOption(OPT_CHECKEDMAILACCOUNTS, 1, NULL, 0);
        
        DoMigration(hwnd);
    }
    else
    {
        SetDwOption(OPT_CHECKEDNEWSACCOUNTS, 1, NULL, 0);
    }

    if (fBrowse)
    {
        Assert(id != FOLDERID_INVALID);
        g_pBrowser->BrowseObject(id, 0);
    }

exit:
    return(hr);
}
    
void ProcessIncompleteAccts(HWND hwnd)
{
    if (0 == (g_dwIcwFlags & ICW_INCOMPLETE))
    {
        HandleIncompleteAccts(hwnd, TRUE);
        HandleIncompleteAccts(hwnd, FALSE);
        
        g_dwIcwFlags |= ICW_INCOMPLETE;
    }
}

void HandleIncompleteAccts(HWND hwnd, BOOL fMail)
{
    HRESULT hr;
    char sz[CCHMAX_ACCOUNT_NAME], szT[CCHMAX_ACCOUNT_NAME], szCurr[CCHMAX_ACCOUNT_NAME];
    IImnAccount *pAcct;
    
    Assert(g_pAcctMan != NULL);

    hr = g_pAcctMan->GetIncompleteAccount(fMail ? ACCT_MAIL : ACCT_NEWS, sz, ARRAYSIZE(sz));
    if (hr == S_OK)
    {
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, sz, &pAcct)))
        {
            hr = GetDefaultNameEmail(fMail, sz, ARRAYSIZE(sz), szT, ARRAYSIZE(szT));
            if (SUCCEEDED(hr))
            {
                hr = pAcct->GetPropSz(fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, szCurr, ARRAYSIZE(szCurr));
                if (FAILED(hr) && *sz != 0)
                    pAcct->SetPropSz(fMail ? AP_SMTP_DISPLAY_NAME : AP_NNTP_DISPLAY_NAME, sz);

                hr = pAcct->GetPropSz(fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, szCurr, ARRAYSIZE(szCurr));
                if (FAILED(hr) && *szT != 0)
                    pAcct->SetPropSz(fMail ? AP_SMTP_EMAIL_ADDRESS : AP_NNTP_EMAIL_ADDRESS, szT);
            }

            pAcct->DoWizard(hwnd, ACCT_WIZ_INTERNETCONNECTION | ACCT_WIZ_HTTPMAIL | ACCT_WIZ_OE);
            
            pAcct->Release();
        }
        
        g_pAcctMan->SetIncompleteAccount(fMail ? ACCT_MAIL : ACCT_NEWS, NULL);
    }
}

void DoAcctImport(HWND hwnd, BOOL fMail)
{
    IImnAccount *pAcct;
    HRESULT		hr;
    DWORD		dwFlags = 0;

    hr = g_pAcctMan->CreateAccountObject(fMail ? ACCT_MAIL : ACCT_NEWS, &pAcct);
    if (SUCCEEDED(hr))
    {
		dwFlags = fMail ? ACCT_WIZ_MAILIMPORT : ACCT_WIZ_NEWSIMPORT;
		dwFlags |= (ACCT_WIZ_INTERNETCONNECTION | ACCT_WIZ_HTTPMAIL | ACCT_WIZ_OE);
        hr = pAcct->DoWizard(hwnd, dwFlags);
        
        pAcct->Release();    
        
        if (hr == E_NoAccounts)
            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsAthena),
            MAKEINTRESOURCEW((fMail ? idsNoAccountsFound : idsNoNewsAccountsFound)),
            NULL, MB_ICONINFORMATION | MB_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inetcfg.h ===
#ifndef _INC_INETCFG
#define _INC_INETCFG

#define ICW_MAIL_START  0x0001  // we started up with a mail argument
#define ICW_NEWS_START  0x0002  // we started up with a news argument
#define ICW_MAIL_DEF    0x0010  // default mail thing has been done
#define ICW_NEWS_DEF    0x0020  // default news thing has been done
#define ICW_INCOMPLETE  0x0040  // incomplete accounts thing has been done

void SetStartFolderType(FOLDERTYPE ft);
HRESULT ProcessICW(HWND hwnd, FOLDERTYPE ft, BOOL fForce = FALSE, BOOL fShowUI = TRUE);

void ProcessIncompleteAccts(HWND hwnd);

HRESULT NeedToRunICW(LPCSTR pszCmdLine);

void DoAcctImport(HWND hwnd, BOOL fMail);

#endif // _INC_INETCFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inetdef.h ===
/*
 *   i n e t d e f . h
 *    
 *    Purpose:
 *        Defered wininet.
 *    
 *    Owner:
 *        brettm.
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */

#ifndef _INETDEF_H
#define _INETDEF_H

#include "wininet.h"

HRESULT HrInit_WinInetDef(BOOL fInit);

HINTERNET Def_InternetOpen (
    IN LPCSTR lpszAgent, 
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

BOOL Def_InternetReadFile (
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

HINTERNET Def_InternetOpenUrl (
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

BOOL
Def_InternetCloseHandle (
    IN HINTERNET hInternet
    );

#endif  //_INETDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inpobj.h ===
extern HRESULT UnkHasFocusIO(IUnknown *punkThis);
extern HRESULT UnkTranslateAcceleratorIO(IUnknown *punkThis, LPMSG lpMsg);
extern HRESULT UnkUIActivateIO(IUnknown *punkThis, BOOL fActivate, LPMSG lpMsg);

extern HRESULT UnkOnFocusChangeIS(IUnknown *punkThis, IUnknown *punkSrc, BOOL fSetFocus);

extern HRESULT UnkSetSite(IUnknown *punk, IUnknown *punkSite);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inpobj.cpp ===
#include "pch.hxx"
#include "inpobj.h"
#include <shlguid.h>

// IInputObject helpers

HRESULT UnkHasFocusIO(IUnknown *punkThis)
{
    HRESULT hres = E_FAIL;

    if (punkThis != NULL) 
        {
        IInputObject *pio;

        hres = punkThis->QueryInterface(IID_IInputObject, (LPVOID*)&pio);
        if (SUCCEEDED(hres)) 
            {
            hres = pio->HasFocusIO();
            pio->Release();
            }
        }

    return hres;
}

HRESULT UnkTranslateAcceleratorIO(IUnknown *punkThis, MSG* pmsg)
{
    HRESULT hres = E_FAIL;

    if (punkThis != NULL) 
        {
        IInputObject *pio;

        hres = punkThis->QueryInterface(IID_IInputObject, (LPVOID*)&pio);
        if (SUCCEEDED(hres)) 
            {
            hres = pio->TranslateAcceleratorIO(pmsg);
            pio->Release();
            }
        }

    return hres;
}

HRESULT UnkUIActivateIO(IUnknown *punkThis, BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres = E_FAIL;

    if (punkThis != NULL) 
        {
        IInputObject *pio;

        hres = punkThis->QueryInterface(IID_IInputObject, (LPVOID*)&pio);
        if (SUCCEEDED(hres)) 
            {
            hres = pio->UIActivateIO(fActivate, lpMsg);
            pio->Release();
            }
        }

    return hres;
}

// IInputObjectSite helpers

HRESULT UnkOnFocusChangeIS(IUnknown *punkThis, IUnknown *punkSrc, BOOL fSetFocus)
{
    HRESULT hres = E_FAIL;

    if (punkThis != NULL) 
        {
        IInputObjectSite *pis;

        hres = punkThis->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pis);
        if (SUCCEEDED(hres)) 
            {
            hres = pis->OnFocusChangeIS(punkSrc, fSetFocus);
            pis->Release();
            }
        }

    return hres;
}

// IObjectWithSite helpers

HRESULT UnkSetSite(IUnknown *punk, IUnknown *punkSite)
{
    HRESULT hr = E_FAIL;
    IObjectWithSite *pows;

    Assert(punk);
    if (punk) {
        hr = punk->QueryInterface(IID_IObjectWithSite, (void**)&pows);
        Assert(SUCCEEDED(hr));
        if (SUCCEEDED(hr)) {
            hr = pows->SetSite(punkSite);
            Assert(SUCCEEDED(hr));
            pows->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\infcolum.cpp ===
#include "pch.hxx"
#include <resource.h>
#include "error.h"
#include "treeview.h"
#include "inpobj.h"
#include "infcolum.h"
#include "goptions.h"
#include "strconst.h"
#include "menuutil.h"
#include "fldbar.h"
#include "ourguid.h"
#include "baui.h"

CInfoColumn::~CInfoColumn()
{
    DOUTL(1, TEXT("CInfoColulmn::~CInfoColumn: %x"), this);

    SafeRelease(m_pDwSite);    
    SafeRelease(m_pTreeView);
    m_hwndParent = 0;

    if (m_hwndInfoColumn)
    {
        DestroyWindow(m_hwndInfoColumn);
    }

    //Destroy image list if we have one.
    if (m_himl)
    {
        ImageList_Destroy(m_himl);
        m_himl = 0;
    }

    if (m_hfIcon)
        DeleteObject(m_hfIcon);

    SafeRelease(m_pMsgrAb);
}

CInfoColumn::CInfoColumn ()
{
    m_hwndInfoColumn    = 0;
    m_hwndRebar         = 0;
    m_fShow             = 0;
    m_hwndParent        = 0;
    m_CurFocus          = 0;
    m_pDwSite           = 0;
    m_cRef              = 1;
    m_xWidth            = DwGetOption(OPT_TREEWIDTH);
    m_himl              = 0;
    m_pTreeView         = 0;
    m_pMsgrAb             = 0;
    m_hfIcon            = NULL;
    m_fRebarDragging    = FALSE;
    m_pFolderBar        = NULL;
    m_cVisibleBands     = 0;
    ZeroMemory(m_BandList, sizeof(m_BandList));
    ZeroMemory(m_CacheCmdTarget, sizeof(m_CacheCmdTarget));
    m_fDragging = FALSE;
}

HRESULT CInfoColumn::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleWindow)
        || IsEqualIID(riid, IID_IDockingWindow))
    {
        *ppvObj = (IDockingWindow*)this;
        m_cRef++;
        DOUTL(2, TEXT("CInfoColumn::QI(IID_IDockingWindow) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IInputObject))
    {
        *ppvObj = (IInputObject*)this;
        m_cRef++;
        DOUTL(2, TEXT("CInfoColumn::QI(IID_IInputObject) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = (IObjectWithSite*)this;
        m_cRef++;
        DOUTL(2, TEXT("CInfoColumn::QI(IID_IObjectWithSite) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IInputObjectSite))
    {
        *ppvObj = (IInputObjectSite*)this;
        m_cRef++;
        DOUTL(2, TEXT("CInfoColumn::QI(IID_IInputObjectSite) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = (IOleCommandTarget*)this;
        m_cRef++;
        DOUTL(2, TEXT("CInfoColumn::QI(IID_IOleCommandTarget) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

    
ULONG CInfoColumn::AddRef()
    {
    m_cRef++;
    DOUTL(4, TEXT("CInfoColumn::AddRef() - m_cRef = %d"), m_cRef);
    return m_cRef;
    }

ULONG CInfoColumn::Release()
{
    DOUTL(4, TEXT("CInfoColumn::Release() - m_cRef = %d"), m_cRef);

    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


//
//  FUNCTION:   CInfoColumn::GetWindow()
//
//  PURPOSE:    Returns the window handle of the top side rebar.
//
HRESULT CInfoColumn::GetWindow(HWND * lphwnd)
    {
    if (m_hwndRebar)
        {
        *lphwnd = m_hwndRebar;
        return (S_OK);
        }
    else
        {
        *lphwnd = 0;
        return (E_FAIL);
        }
    }

HRESULT CInfoColumn::ContextSensitiveHelp(BOOL fEnterMode)
    {
    return (E_NOTIMPL);
    }    

#define INFOCOLUMNCLASS TEXT("InfoColumn")
HRESULT  CInfoColumn::CreateInfoColumn(BOOL fVisible)
{
    if (m_hwndInfoColumn)
        return (hrAlreadyExists);

    m_hwndInfoColumn = CreateWindowEx(WS_EX_CONTROLPARENT, INFOCOLUMNCLASS, 0, 
                                      WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | (fVisible ? WS_VISIBLE : 0),
                                      0, 0, 100, 200, m_hwndParent, (HMENU) 0, g_hInst, this);
    if (!m_hwndInfoColumn)
    {
        DWORD err;
        err = GetLastError();
        AssertSz(0, _T("CInfoColumn::CreateInfoColumn() - Failed to create a window"));
        return E_FAIL;
    }    

    return S_OK;
}

//
//  FUNCTION:   CInfoColumn::InfoColumnWndProc() 
//
//  PURPOSE:    Handles messages sent to the InfoColumn root window.
//
LRESULT CALLBACK EXPORT_16 CInfoColumn::InfoColumnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CInfoColumn     *pInfoColumn = 0;

    if (uMsg == WM_NCCREATE)
    {
        pInfoColumn = (CInfoColumn*)((LPCREATESTRUCT) lParam)->lpCreateParams;
        SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)pInfoColumn);
    }
    else
    {
        pInfoColumn = (CInfoColumn*)GetWindowLong(hwnd, GWL_USERDATA);
    }
    
    Assert (pInfoColumn);
 
    return pInfoColumn->PrivateProcessing(hwnd, uMsg, wParam, lParam);
}



//IDockingWindow::ShowDw
HRESULT CInfoColumn::ShowDW(BOOL fShow)
{
    HRESULT hres = S_OK;
    int     i = 0, 
            j = 0;

    m_fShow = fShow;       
    // Check to see if our window has been created yet.  If not, do that first.
    if (!m_hwndInfoColumn && m_pDwSite)
    {
        m_hwndParent = 0;        
        hres = m_pDwSite->GetWindow(&m_hwndParent);
        
        if (SUCCEEDED(hres))
        {
#ifndef WIN16   // WNDCLASSEX
            WNDCLASSEX              wc;
#else
            WNDCLASS                wc;
#endif

            // Check to see if we need to register our window class    
#ifndef WIN16
            wc.cbSize = sizeof(WNDCLASSEX);
            if (!GetClassInfoEx(g_hInst, INFOCOLUMNCLASS, &wc))
#else
            if (!GetClassInfo(g_hInst, INFOCOLUMNCLASS, &wc))
#endif
            {
                wc.style            = 0;
                wc.lpfnWndProc      = InfoColumnWndProc;
                wc.cbClsExtra       = 0;
#ifndef WIN16
                wc.cbWndExtra       = 0;
#else
                wc.cbWndExtra       = 4;
#endif
                wc.hInstance        = g_hInst;
                wc.hCursor          = LoadCursor(0, IDC_SIZEWE);
                wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
                wc.lpszMenuName     = 0;
                wc.lpszClassName    = INFOCOLUMNCLASS;
                wc.hIcon            = 0;
#ifndef WIN16
                wc.hIconSm          = 0;

                RegisterClassEx(&wc);
#else
                RegisterClass(&wc);
#endif
            }
            
            hres = CreateInfoColumn(fShow);
            if (FAILED(hres))
                return E_FAIL;
        }
                
       m_hwndRebar = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_CONTROLPARENT, REBARCLASSNAME, 0,
                                    RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_DBLCLKTOGGLE | RBS_FIXEDORDER 
                                    | WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | 
                                    CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_VERT, 0, 0, 0, 0,
                                    m_hwndInfoColumn, (HMENU)0, g_hInst, 0);
        if (!m_hwndRebar)
        {
            DestroyWindow(m_hwndInfoColumn);
            return E_FAIL;
        }

        hres = CreateBands();
        Assert(SUCCEEDED(hres));

        GetFontParams();
        //SendMessage(m_hwndRebar, RB_SETEXTENDEDSTYLE, RBS_EX_OFFICE9, RBS_EX_OFFICE9);
    }

    // Resize the rebar based on it's new hidden / visible state and also 
    // show or hide the window.    
    if (m_hwndInfoColumn) 
    {
        /*
        if(fShow)
        {
            //If #of visible bands is zero, this means we were hidden before in options.
            if (!m_cVisibleBands)
                ShowAllBands();
        }
        else
        {
            //We are being hidden
            m_cVisibleBands = 0;
        }
        */
        ResizeBorderDW(0, 0, FALSE);
        ShowWindow(m_hwndInfoColumn, fShow ? SW_SHOW : SW_HIDE);

        hres = S_OK;
    }

    return hres;
}

void CInfoColumn::ShowAllBands()
{
    int             Count;
    REBARBANDINFO   rbbinfo;

    Count = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    m_cVisibleBands = Count;

    for (--Count; Count >= 0; Count--)
    {
        ZeroMemory(&rbbinfo, sizeof(REBARBANDINFO));
        rbbinfo.cbSize = sizeof(REBARBANDINFO);
        rbbinfo.fMask  = RBBIM_STYLE;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, Count, (LPARAM)&rbbinfo);

        rbbinfo.fStyle &= ~RBBS_HIDDEN;
        SendMessage(m_hwndRebar, RB_SETBANDINFO, Count, (LPARAM)&rbbinfo);
    }
}

HRESULT CInfoColumn::AddMsgrAb(DWORD dwSize, BOOL fVisible)
{
    HRESULT     hres = E_FAIL;

    if(!fVisible)
        return hres;

    hres = CreateMsgrAbCtrl(&m_pMsgrAb);
    if (SUCCEEDED(hres))
    {
        IInputObject    *pObj;
        if (SUCCEEDED(hres = m_pMsgrAb->QueryInterface(IID_IInputObject, (LPVOID*)&pObj)))
        {
            if (SUCCEEDED(hres = AddObject(pObj, m_fShow)))
            {
                REBARBANDINFO          bandinfo = {0};
                IOleWindow             *pOleWindow;         

                if (SUCCEEDED(m_pMsgrAb->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWindow))) 
                {
                    if (SUCCEEDED(pOleWindow->GetWindow(&bandinfo.hwndChild)))
                    {
                        char        BandTitle[CCHMAX_STRINGRES];
                        ZeroMemory(BandTitle, sizeof (BandTitle));

                        if (g_hLocRes)
                            LoadString(g_hLocRes, idsABBandTitle, BandTitle, sizeof(BandTitle));

                        bandinfo.cbSize     = sizeof (REBARBANDINFO);
                        bandinfo.fMask      = RBBIM_CHILD | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE |
                                              RBBIM_CHILDSIZE | RBBIM_TEXT | RBBIM_LPARAM;
                        bandinfo.fStyle     = RBBS_VARIABLEHEIGHT | (fVisible ? 0 : RBBS_HIDDEN);
                        bandinfo.wID        = ICBLAB;
                        //Height
                        bandinfo.cx         = dwSize;
                        bandinfo.cxMinChild = 0;
                        //Width
                        bandinfo.cyMinChild = m_xWidth - GetSystemMetrics(SM_CXFRAME);  
                        bandinfo.cyChild    = m_xWidth - GetSystemMetrics(SM_CXFRAME);
                        bandinfo.cyMaxChild = MAX_WIDTH;

                        bandinfo.lpText     = BandTitle;

                        IDropDownFldrBar    *pddf;
                        m_pMsgrAb->QueryInterface(IID_IDropDownFldrBar, (void**)&pddf);
                        bandinfo.lParam     = (LPARAM)pddf;

                        SendMessage(m_hwndRebar, RB_INSERTBAND, -1, (LPARAM)&bandinfo);

                        if (fVisible)
                            ++m_cVisibleBands;
                        
                        hres = S_OK;
                    }
                    pOleWindow->Release();
                }
            }
        }

        if (m_pMsgrAb->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_CacheCmdTarget[ITB_BUDDYADDRBOOK - ITB_INFOCOL_BASE]) != S_OK)
        {
            m_CacheCmdTarget[ITB_BUDDYADDRBOOK - ITB_INFOCOL_BASE]  = NULL; 
        }
    }
    return hres;
}

void  CInfoColumn::GetFontParams()
{
    //Get the Icon font and save it
    ICONMETRICS     icm;

    icm.cbSize = sizeof(ICONMETRICS);
    SystemParametersInfo(SPI_GETICONMETRICS, 
                         sizeof(ICONMETRICS), 
                         (LPVOID) &icm, FALSE);

    if (m_hfIcon)
        DeleteObject(m_hfIcon);

    m_hfIcon = CreateFontIndirect(&(icm.lfFont));
    if (m_hfIcon)
    {
        SendMessage(m_hwndRebar, WM_SETFONT, (WPARAM) m_hfIcon, MAKELPARAM(TRUE, 0));
    }
}

//
//  FUNCTION:   CInfoColumn::CloseDW()
//
//  PURPOSE:    Destroys the InfoColumnWindow.
//
//IDockingWindow::CloseDW
HRESULT CInfoColumn::CloseDW(DWORD dwReserved)
{
    IObjectWithSite *pObject = 0;

    // Save our settings before we close anything
    SaveSettings();

    //Go through the list of objects and deactivate them.
    for (DWORD index = 0; index < IC_MAX_OBJECTS; index++)
    {
        if (m_BandList[index].pBandObj)
        {
            m_BandList[index].pBandObj->UIActivateIO(FALSE, 0);
            
            if (SUCCEEDED(m_BandList[index].pBandObj->QueryInterface(IID_IObjectWithSite, (LPVOID *) &pObject)))
            {
                pObject->SetSite(0);
                pObject->Release();
            }
            SafeRelease(m_BandList[index].pBandObj);
        }
        SafeRelease(m_CacheCmdTarget[index]);
    }

    //Go through the bands and release lParam pointer
    CleanupLParam();

    if (m_pTreeView)
        {
        m_pTreeView->SetSite(0);
        m_pTreeView->DeInit();
        }
    SafeRelease(m_pTreeView);
    SafeRelease(m_CurFocus);

    if (m_hwndInfoColumn)
    {
        DestroyWindow(m_hwndInfoColumn);
        m_hwndInfoColumn = 0;
    }
    SafeRelease(m_CurFocus);
    return S_OK;
}

void CInfoColumn::CleanupLParam()
{
    int             count = 0;
    REBARBANDINFO   rbbinfo;

    count = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    for (--count; count >= 0; count--)
    {
        ZeroMemory(&rbbinfo, sizeof(REBARBANDINFO));
        rbbinfo.cbSize  = sizeof(REBARBANDINFO); 
        rbbinfo.fMask   = RBBIM_LPARAM;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, count, (LPARAM)&rbbinfo);
        if (rbbinfo.lParam)
        {
            ((IDropDownFldrBar*)rbbinfo.lParam)->Release();
        }

    }
    
}

//
//  FUNCTION:   CInfoColumn::ResizeBorderDW()
//
//  PURPOSE:    This is called by the browser or dockwindow site when InfoColumn needs to resize.  
//              The Infocolumn in return figures out how much border space will be required 
//              from the parent frame and tells the parent to reserve that
//              space.  The InfoColumn then resizes itself to those dimensions.
//
//  PARAMETERS:
//      <in> prcBorder       - Rectangle containing the border space for the
//                             parent.
//      <in> punkToolbarSite - Pointer to the IDockingWindowSite that we are
//                             part of.
//      <in> fReserved       - Ignored.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CInfoColumn::ResizeBorderDW(LPCRECT     prcBorder,
                                 IUnknown*      punkToolbarSite,
                                 BOOL           fReserved)
{

    const DWORD  c_cxResizeBorder = 3;

    HRESULT hres = S_OK;
    RECT    rcRequest = { 0, 0, 0, 0 };
    
    // If we don't have a stored site pointer, we can't resize.
    if (!m_pDwSite)
        {
        AssertSz(m_pDwSite, _T("CInfoColumn::ResizeBorderDW() - Can't resize ")
                 _T("without an IDockingWindowSite interface to call."));
        return (E_INVALIDARG);
        }
        
    // If we're visible, then calculate our border rectangle.    
    if ((m_fShow) && (m_hwndInfoColumn))
    {
        if (!prcBorder)
        {
            RECT rcBorder;
            
            // Find out how big our parent's border space is
            m_pDwSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
            prcBorder = &rcBorder;
            Assert (prcBorder);
        }

        RECT rcRebar = {0};
        if (IsWindow(m_hwndRebar))
        {
            GetWindowRect(m_hwndRebar, &rcRebar);
            POINT   pt;
            pt.x = rcRebar.right;
            pt.y = rcRebar.top;
            if (!ScreenToClient(m_hwndRebar, &pt))
                return E_FAIL;
            rcRebar.right = pt.x;
        }

        rcRequest.left = min(prcBorder->right - prcBorder->left, rcRebar.right + GetSystemMetrics(SM_CXFRAME));

        hres = m_pDwSite->RequestBorderSpaceDW((IDockingWindow*)this, &rcRequest);
        
    }
    m_pDwSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);        

    //We should set the border space before we set the window pos. Because resizing will call this function
    //again and the last SetBorderSpaceDW from us will be with the co-ordinates before re-sizing. This will be bad
    if (SUCCEEDED(hres) && m_hwndInfoColumn && m_fShow)
    {
        if (!SetWindowPos(m_hwndInfoColumn, 
                     0,
                     prcBorder->left,
                     prcBorder->top,
                     rcRequest.left,
                     prcBorder->bottom - prcBorder->top,
                     SWP_NOZORDER | SWP_NOACTIVATE))
        {
            AssertSz(FALSE, _T("Setwindowpos failed"));
        }
    }

    return hres;
}

//IObjectWithSite::SetSite
HRESULT CInfoColumn::SetSite(IUnknown   *pUnkSite)
{
    if (m_pDwSite)
    {
        m_pDwSite->Release();
        m_pDwSite = 0;
    }

    if (pUnkSite)
    {
        if (FAILED(pUnkSite->QueryInterface(IID_IDockingWindowSite, (LPVOID*)&m_pDwSite)))
        {
            Assert (m_pDwSite);
            return E_FAIL;
        }
    }
    return S_OK;
}

//IObjectWithSite::GetSite
HRESULT CInfoColumn::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////
//
//  IInputObject
//
////////////////////////////////////////////////////////////////////////

HRESULT CInfoColumn::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    if (fActivate)
    {
        UnkOnFocusChangeIS(m_pDwSite, (IInputObject*)this, TRUE);
        SetFocus(m_hwndRebar);
    }
    return S_OK;    
}

HRESULT CInfoColumn::HasFocusIO(void)
{
    if ( m_hwndRebar == 0 )
       return( S_FALSE );
    HWND hwndFocus = GetFocus();
    return ((hwndFocus && (hwndFocus == m_hwndRebar || IsChild(m_hwndRebar, hwndFocus)))) ? S_OK : S_FALSE;
}    
    
HRESULT CInfoColumn::TranslateAcceleratorIO(LPMSG pMsg)
{
    //Cycle through all the child windows and forward this if they have focus
    for (DWORD  i = 0; i < IC_MAX_OBJECTS; i++)
    {
        if (m_BandList[i].pBandObj && UnkHasFocusIO(m_BandList[i].pBandObj) == S_OK)
        {
            if (UnkTranslateAcceleratorIO(m_BandList[i].pBandObj, pMsg) == S_OK)
            {
                return S_OK;
            }
            break;
        }
    }
    return (S_FALSE);
}    

//IInputObjectSite
HRESULT CInfoColumn::OnFocusChangeIS(IUnknown *punk, BOOL   fSetFocus)
{
    HRESULT       hres = S_OK;
    IInputObject  *prevfocus;
    
    if (punk)
    {
        if (fSetFocus)
        {
            prevfocus = m_CurFocus;
            HRESULT       hres = punk->QueryInterface(IID_IInputObject, (LPVOID*)&m_CurFocus);
            if (FAILED(hres))
            { 
                //reset Cur focus back to the previous one
                m_CurFocus = prevfocus;
                return hres;
            }

            //We should also let the browser know that we have the focus now
            IInputObjectSite    *pinpsite;
            if (SUCCEEDED(m_pDwSite->QueryInterface(IID_IInputObjectSite, (LPVOID*)&pinpsite)))
            {
                pinpsite->OnFocusChangeIS((IDockingWindow*)this, fSetFocus);
                pinpsite->Release();
            }

            if (prevfocus)
            {
                prevfocus->UIActivateIO(FALSE, 0);
                prevfocus->Release();
            }

            hres =  S_OK;
        }
    }
    else
        hres = E_INVALIDARG;

    return hres;
}

//IDropTarget
HRESULT CInfoColumn::DragEnter(  IDataObject *pDataObject, 
                                 DWORD       grfKeyState, 
                                 POINTL      pt,          
                                 DWORD       *pdwEffect)
{
    return E_NOTIMPL;
}

HRESULT CInfoColumn::DragOver(  DWORD        grfKeyState, 
                                POINTL       pt,         
                                DWORD        *pdwEffect )
{
    return E_NOTIMPL;
}

HRESULT CInfoColumn::DragLeave(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CInfoColumn::Drop(  IDataObject      *pDataObject,   
                            DWORD            grfKeyState,
                            POINTL           pt,             
                            DWORD            *pdwEffect)
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////
//
//  Private Methods
//
////////////////////////////////////////////////////////////////////////

LRESULT CInfoColumn::PrivateProcessing(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
        {
        HANDLE_MSG(hwnd, WM_CREATE,         OnCreate);
        HANDLE_MSG(hwnd, WM_LBUTTONDOWN,    OnLButtonDown);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,      OnMouseMove);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,      OnLButtonUp);
        HANDLE_MSG(hwnd, WM_SIZE,           OnSize);
        HANDLE_MSG(hwnd, WM_CONTEXTMENU,    OnContextMenu);

        case WM_NOTIFY:
            return OnNotify(hwnd, wParam, (LPNMHDR) lParam);

        case WM_NCDESTROY:
            RevokeDragDrop(hwnd);
            SetWindowLong(hwnd, GWL_USERDATA, 0);
            m_hwndInfoColumn = 0;
            break;
            
        case WM_SETFOCUS:
            if (m_hwndRebar && ((HWND)wParam) != m_hwndRebar)
            {
                SetFocus(m_hwndRebar);
            }
            UnkOnFocusChangeIS(m_pDwSite, (IDockingWindow*)this, TRUE);
            return 0;

        case WMR_CLICKOUTSIDE:
        {
            BOOL fHide = FALSE;

            if (wParam == CLK_OUT_KEYBD || wParam == CLK_OUT_DEACTIVATE)
                fHide = TRUE;
            else if (wParam == CLK_OUT_MOUSE)
                fHide = !IsOurWindow((HWND)lParam);
                //fHide = ((HWND) lParam != m_hwndRebar && (HWND) lParam != m_hwndInfoColumn);

            if (fHide)
                m_pFolderBar->KillScopeDropDown();
            return (fHide);
        }
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

BOOL    CInfoColumn::IsOurWindow(HWND   hwnd)
{
    BOOL    bRet = FALSE;

    if ((hwnd != m_hwndInfoColumn) && (hwnd != m_hwndRebar))
    {
        int                 BandCount;
        REBARBANDINFO       rbbinfo;

        BandCount = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
        for (--BandCount; BandCount >= 0; BandCount--)
        {
            ZeroMemory(&rbbinfo, sizeof(REBARBANDINFO));
            rbbinfo.cbSize = sizeof(REBARBANDINFO);
            rbbinfo.fMask  = RBBIM_CHILD;
            SendMessage(m_hwndRebar, RB_GETBANDINFO, BandCount, (LPARAM)&rbbinfo);
            if ((rbbinfo.hwndChild == hwnd) ||
                (IsChild(rbbinfo.hwndChild, hwnd)))
            {
                bRet = TRUE;
                break;
            }
        }
    }
    else
    {
        bRet = TRUE;
    }
    return bRet;
}

void CInfoColumn::OnLButtonDown(HWND hwnd, 
                              BOOL fDoubleClick, 
                              int  x, 
                              int  y, 
                              UINT keyFlags)
{
    if ((!m_fRebarDragging) && (GetParent(m_hwndInfoColumn) == m_hwndParent))
    {
        // Capture the mouse
        SetCapture(m_hwndInfoColumn);

        // Start dragging
        m_fDragging = TRUE;
    }
}

void CInfoColumn::OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    HCURSOR hcur;
    POINT pt = {x, y};
    RECT rcClient;

    // If we're dragging, update the the window sizes
    if (m_fDragging)
    {
        // Make sure the tree is still a little bit visible
        if (x > 32)
        {
            SetDwOption(OPT_TREEWIDTH, x, 0, 0);
            ResizeBands(x - GetSystemMetrics(SM_CXFRAME));
            ResizeBorderDW(0, 0, FALSE);
        }
    }

    if(m_fRebarDragging)
    {
        //This is a temporary hack while the shell team fixes the RB_FIXEDORDER style in their code.
        //BUG#12591
        //This is bug has been fixed and verified as of 7/14/98. Hence removing the hack
        //if (y >= 5)
            SendMessage(m_hwndRebar, RB_DRAGMOVE, 0, MAKELPARAM(1, y));
    }
}


void CInfoColumn::OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    if (m_fDragging)
    {
        ReleaseCapture();
        m_fDragging = FALSE;
    }

    if (m_fRebarDragging)
    {
        m_fRebarDragging = FALSE;
        SendMessage(m_hwndRebar, RB_ENDDRAG, 0, 0);
        if (GetCapture() == hwnd)
        {
            ReleaseCapture();
        }
    }
}


void CInfoColumn::ResizeBands(int cx)
{
    UINT            uBandCount;
    UINT            Index;
    REBARBANDINFO   rbbinfo = {0};

    uBandCount = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    for (Index = 0; Index < uBandCount; Index++)
    {
        //We do this in order to get CxMinChild. Execpt for OE TOday band this value 
        //is set to zero at this point of time.
        rbbinfo.cbSize = sizeof(REBARBANDINFO);
        rbbinfo.fMask  = RBBIM_CHILDSIZE;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, Index, (LPARAM)&rbbinfo);
        
        rbbinfo.cyChild     = cx;
        rbbinfo.cyMinChild  = cx;
        SendMessage(m_hwndRebar, RB_SETBANDINFO, Index, (LPARAM)&rbbinfo);
    }
}

BOOL CInfoColumn::OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    REBARINFO   rebarinfo;

#ifdef NEVER

    m_himl = ImageList_LoadBitmap(g_hLocRes, MAKEINTRESOURCE(idbInfoColumn), 16, 0, RGB(255, 0, 255)); 

    rebarinfo.cbSize = sizeof (REBARINFO);
    rebarinfo.fMask  = RBIM_IMAGELIST;
    rebarinfo.himl   = m_himl;
    SendMessage (m_hwndRebar, RB_SETBARINFO, 0, (LPARAM)&rebarinfo);
#endif NEVER

    RegisterDragDrop(hwnd, this);

    return TRUE;
}

void CInfoColumn::OnSize(HWND   hwnd, UINT  state, int cxClient, int cyClient)
{
    if (m_hwndRebar && IsWindow(m_hwndRebar))
    {

        if (m_hwndParent != GetParent(m_hwndInfoColumn))
        {
            //This is being called by Folder Bar
            ResizeBands(cxClient);
        }
        cxClient = cxClient - GetSystemMetrics(SM_CXFRAME);
        if (!SetWindowPos(m_hwndRebar, 0, 0, 0,
             cxClient,
             cyClient,
             SWP_NOZORDER | SWP_NOACTIVATE))
           DWORD err = GetLastError();

    }
}

LRESULT CInfoColumn::OnNotify(HWND   hwnd, WPARAM wParam, LPNMHDR lpnmh)
{
    LRESULT     retval = 0;

    switch (lpnmh->code)
    {
        case RBN_BEGINDRAG:
            retval = OnICBeginDrag((LPNMREBAR)lpnmh);
            break;

        case RBN_LAYOUTCHANGED:
            retval = TRUE;
            break;

        case RBN_HEIGHTCHANGE:
            if (m_hwndParent == GetParent (m_hwndInfoColumn))
                ResizeBorderDW(0, 0, FALSE);
            retval = TRUE;
            break;

        case NM_KILLFOCUS:
            if (m_pFolderBar)
                m_pFolderBar->KillScopeDropDown();
            break;

        case NM_SETFOCUS:
            UnkOnFocusChangeIS(m_pDwSite, (IDockingWindow*)this, TRUE);
            break;

    }
    return retval;
}

LRESULT CInfoColumn::OnICBeginDrag(LPNMREBAR pnm)
{
    SetCapture(m_hwndInfoColumn);
    SendMessage(m_hwndRebar, RB_BEGINDRAG, pnm->uBand, (LPARAM)-2);
    m_fRebarDragging = TRUE;
    return 1;
}

HRESULT CInfoColumn::HrInit(IAthenaBrowser      *pBrowser,
                            ITreeViewNotify     *ptvNotify)
{    
    HRESULT     hres = E_FAIL;

    if (pBrowser && ptvNotify)
    {
        if(m_pTreeView = new CTreeView(ptvNotify))
            //Add the treeview before OEToday since we navigate to the front page using TreeView.
            hres = m_pTreeView->HrInit(0, pBrowser);    
    }

    return hres;
}

HRESULT  CInfoColumn::AddTreeView(DWORD dwSize, BOOL fVisible)
{
    REBARBANDINFO   bandinfo = {0};
    RECT            rctree;
    int             cxFrame;
    int             iWidth;
    char            BandTitle[CCHMAX_STRINGRES];
    HRESULT         hres = E_FAIL;
    IInputObject   *pObj;

    if (SUCCEEDED(m_pTreeView->QueryInterface(IID_IInputObject, (LPVOID*)&pObj)))
    {
        if (SUCCEEDED(hres = AddObject(pObj, m_fShow)))
        {
            cxFrame = GetSystemMetrics(SM_CXFRAME);
            iWidth = m_xWidth - cxFrame;

            if (SUCCEEDED(m_pTreeView->GetWindow(&bandinfo.hwndChild)))
            {
                /*
                if (dwSize == 0)
                {
                    //We make the TreeView atleast half of the InfoColumn window. Starting up
                    //with the TreeView minimized is confusing out people
                    GetClientRect(m_hwndInfoColumn, &rctree);
                    dwSize = rctree.bottom / 2;
                }
                */
                if (g_hLocRes)
                {
                    LoadString(g_hLocRes, idsMNBandTitle, BandTitle, sizeof(BandTitle));
                }

                bandinfo.cbSize     = sizeof (REBARBANDINFO);
                bandinfo.fMask      = RBBIM_CHILD | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE 
                                      | RBBIM_CHILDSIZE | RBBIM_TEXT | RBBIM_LPARAM;
                bandinfo.fStyle     = RBBS_VARIABLEHEIGHT | (fVisible ? 0 : RBBS_HIDDEN);
                bandinfo.wID        = ICTREEVIEW;
                //Height
                bandinfo.cx         = dwSize; 
                //Width
                bandinfo.cyMinChild = (UINT)iWidth;
                bandinfo.cyChild    = (UINT)iWidth;
                bandinfo.cyMaxChild = MAX_WIDTH;
                bandinfo.lpText     = BandTitle;

                IDropDownFldrBar    *pddf;
                m_pTreeView->QueryInterface(IID_IDropDownFldrBar, (void**)&pddf);
                bandinfo.lParam     = (LPARAM)pddf;

                SendMessage(m_hwndRebar, RB_INSERTBAND, -1, (LPARAM)&bandinfo);
                if (fVisible)
                {
                    ++m_cVisibleBands;
                }
                hres = S_OK;
            }
        }
    }

    if (m_pTreeView->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&m_CacheCmdTarget[ITB_TREE - ITB_INFOCOL_BASE]) != S_OK)
    {
        m_CacheCmdTarget[ITB_TREE - ITB_INFOCOL_BASE] = NULL;
    }
    return hres;
}

void CInfoColumn::AddOETodayBand(DWORD dwSize, BOOL fVisible)
{
    REBARBANDINFO   bandinfo = {0};
    char            BandTitle[CCHMAX_STRINGRES] = {0};
    

    //Add Outlook Express band
    if (g_hLocRes)
    {
        LoadString(g_hLocRes, idsOEBandTitle, BandTitle, sizeof(BandTitle));
    }
    bandinfo.cbSize         = sizeof (REBARBANDINFO);
    bandinfo.fMask          = RBBIM_STYLE | RBBIM_ID | RBBIM_TEXT | RBBIM_SIZE 
                              | RBBIM_CHILDSIZE | RBBIM_TEXT;
    bandinfo.fStyle         = RBBS_FIXEDSIZE | (fVisible ? 0 : RBBS_HIDDEN);
    bandinfo.cyMinChild     = m_xWidth - GetSystemMetrics(SM_CXFRAME);
    bandinfo.cxMinChild     = 0;
    bandinfo.cx             = 0;
    bandinfo.wID            = ICOETODAY;
    bandinfo.lpText         = BandTitle;
    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT) -1, (LPARAM)&bandinfo);
    if (fVisible)
        ++m_cVisibleBands;
}

CTreeView*  CInfoColumn::GetTreeView()
{
    Assert(m_pTreeView);
    m_pTreeView->AddRef();
    return m_pTreeView;
}

HRESULT CInfoColumn::AddObject(IInputObject *pinpobj, DWORD fShow)
{
    DWORD       dwIndex;
    HRESULT     hres;

    if (SUCCEEDED(FindBandListIndex(&dwIndex)))  
    {
        m_BandList[dwIndex].fShow = fShow;
        m_BandList[dwIndex].pBandObj = pinpobj;

        IObjectWithSite *pObject = 0;
        hres = pinpobj->QueryInterface(IID_IObjectWithSite, (LPVOID *) &pObject);
        if (SUCCEEDED(hres))
        {
            pObject->SetSite((IDockingWindow *) this);
            pObject->Release();
        }

        m_BandList[dwIndex].pBandObj->UIActivateIO(fShow, 0);

        hres = S_OK;

    }
    else
        hres = E_FAIL;
    
    return hres;

}

DWORD CInfoColumn::FindBandObject(IInputObject   *pinpobj)
{
    if (pinpobj)
    {
        DWORD   index;
        for (index = 0; index < IC_MAX_OBJECTS; index++)
        {
            if (pinpobj == m_BandList[index].pBandObj)
                return index;
        }
    }
    return INVALID_BAND_INDEX;
}

HRESULT CInfoColumn::FindBandListIndex(DWORD *pdwindex)
{
    DWORD   index;

    for (index = 0; index < IC_MAX_OBJECTS; index++)
    {
        if (!m_BandList[index].pBandObj)
        {
            *pdwindex = index;
            return S_OK;
        }
    }
    return E_FAIL;
}

BOOL    CInfoColumn::CycleFocus(BOOL    fReverse)
{
    DWORD   Index;
    BOOL    fRet = FALSE;

    if (m_CurFocus)
    {
        Index = FindBandObject(m_CurFocus);
        if (fReverse)
        {
            Index--;
        }
        else
        {
            Index++;
        }
        fRet = SetCycledFocus(Index, fReverse);
    }
    return fRet;
}

BOOL    CInfoColumn::CycleFocus(DWORD LastorFirst, BOOL fReverse)
{
    DWORD   Index;
    BOOL    fRet = FALSE;

    if (LastorFirst == INFOCOLUMN_FIRST)
    {
        Index   = GetFirstBand();
        fRet    = SetCycledFocus(Index, fReverse);        
    }
    else
    if (LastorFirst == INFOCOLUMN_LAST)
    {
        Index = GetLastBand();
        fRet  = SetCycledFocus(Index, fReverse);
    }
    return fRet;
}

BOOL    CInfoColumn::SetCycledFocus(DWORD Index, BOOL fReverse)
{
    BOOL    fRet = FALSE;

    if ((Index >= 0) && (Index < IC_MAX_OBJECTS) && m_BandList[Index].pBandObj)
    {
      
        IOleWindow  *pOleWnd;
        if (SUCCEEDED(m_BandList[Index].pBandObj->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWnd)))
        {
            HWND    hwnd;
            if (SUCCEEDED(pOleWnd->GetWindow(&hwnd)))
            {
                RECT    Clientrc;

                GetClientRect(hwnd, &Clientrc);
                if (Clientrc.bottom)
                {
                    SetFocus(hwnd);
                    fRet = TRUE;
                }
                else
                {
                    fRet = SetCycledFocus(fReverse ? --Index : ++Index, fReverse);
                }
            }
            pOleWnd->Release();
        }
    }
    return fRet;
}

DWORD   CInfoColumn::GetFirstBand()
{
    DWORD   Index;

    for (Index = 0; Index < IC_MAX_OBJECTS; Index++)
    {
        if (m_BandList[Index].pBandObj)
        {
            break;
        }
    }
    return Index;
}

DWORD   CInfoColumn::GetLastBand()
{
    DWORD   Index;

    for (Index = 0; Index < IC_MAX_OBJECTS; Index++)
    {
        if (!m_BandList[Index].pBandObj)
        {
            break;
        }
    }
    return (--Index);
}


void    CInfoColumn::ForwardMessages(UINT  msg, WPARAM wParam, LPARAM lParam)
{

    SendMessage(m_hwndRebar, msg, wParam, lParam);

    for (DWORD Index = 0; Index < IC_MAX_OBJECTS; Index++)
    {
        if(m_BandList[Index].pBandObj)
        {
            IOleWindow  *polewnd;
            if(SUCCEEDED(m_BandList[Index].pBandObj->QueryInterface(IID_IOleWindow, (LPVOID*)&polewnd)))
            {
                HWND    hwnd;
                if (SUCCEEDED(polewnd->GetWindow(&hwnd)))
                {
                    SendMessage(hwnd, msg, wParam, lParam);
                }
            }
            polewnd->Release();
        }
    }
    GetFontParams();

}


HRESULT CInfoColumn::SaveSettings(void)
{
    HRESULT       hr = E_FAIL;
    DWORD         iBand;
    DWORD         cBands;
    HKEY          hKey = 0;
    HKEY          hSubKey = 0;
    REBARBANDINFO rbbi;
    TCHAR         szSubKey[CCHMAX_STRINGRES];
    BOOL          fVisible = TRUE;
    DWORD         dwDisposition = 0;
    DWORD         dwResult;
    DWORD         VersionID;

    // If we don't have a rebar control, then there's nothing to save
    if (!m_hwndRebar)
        return (S_FALSE);

    // Zero - init this structure
    ZeroMemory(&rbbi, sizeof(REBARBANDINFO));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_STYLE | RBBIM_CHILD | RBBIM_SIZE | RBBIM_ID;

    // Delete the old key so there's no leftover information
    AthUserDeleteKey(c_szRegInfoColumn);

    // Get the reg key we need
    if (ERROR_SUCCESS != AthUserCreateKey(c_szRegInfoColumn, KEY_ALL_ACCESS, &hKey, &dwDisposition))
        goto exit;

    VersionID = LEFTPANE_VERSION;
    AthUserSetValue(c_szRegInfoColumn, "Version", REG_BINARY, (const LPBYTE)&VersionID, sizeof(DWORD)); 

    // Get the number of bands from the rebar
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);

    // Loop through bands we know about
    for (iBand = 0; iBand < cBands; iBand++)
    {
        // Get the band information
        if (SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi))
        {
            fVisible = !(rbbi.fStyle & RBBS_HIDDEN);

            // Open a subkey for this one
            wsprintf(szSubKey, c_szRegICBand, iBand);
            dwResult = RegCreateKeyEx(hKey, szSubKey, 0, 0, REG_OPTION_NON_VOLATILE, 
                                      KEY_ALL_ACCESS, 0, &hSubKey, &dwDisposition);
            if (ERROR_SUCCESS == dwResult)
            {
                RegSetValueEx(hSubKey, c_szRegICBandID, 0, REG_DWORD, (const LPBYTE) &(rbbi.wID), sizeof(UINT));
                RegSetValueEx(hSubKey, c_szRegICBandSize, 0, REG_DWORD, (const LPBYTE) &(rbbi.cx), sizeof(UINT));
                RegSetValueEx(hSubKey, c_szRegICBandVisible, 0, REG_DWORD, (const LPBYTE) &fVisible, sizeof(BOOL));

                RegCloseKey(hSubKey);
            }
        }
    }

exit:
    if (hKey)
        RegCloseKey(hKey);

    return (hr);
}


HRESULT CInfoColumn::CreateBands(void)
{
    HRESULT hr;
    HKEY    hKey = 0;
    HKEY    hSubKey = 0;
    DWORD   iBand;
    DWORD   cBands = IC_MAX_OBJECTS;
    TCHAR   szSubKey[CCHMAX_STRINGRES];
    LONG    lResult;
    DWORD   dwType;
    DWORD   dwID;
    DWORD   dwHeight;
    DWORD   dwVisible;
    DWORD   cbData;

    // First see if we have any persisted settings.  If not, then
    // create the default band set.
    lResult = AthUserOpenKey(c_szRegInfoColumn, KEY_READ | KEY_QUERY_VALUE, &hKey);
    if (lResult != ERROR_SUCCESS)
        return CreateDefaultBands();

    //See if the version numbers match
    DWORD VersionID = 0;
    cbData = sizeof(DWORD);
    lResult = AthUserGetValue(c_szRegInfoColumn, "Version", &dwType, (LPBYTE)&VersionID, &cbData); 
    if ((lResult != ERROR_SUCCESS) || (VersionID != LEFTPANE_VERSION))
    {
        RegCloseKey(hKey);
        hKey = 0;
        return CreateDefaultBands();
    }

    // If we have saved information, figure out how many bands are saved
    if (hKey)
    {
        RegQueryInfoKey(hKey, 0, 0, 0, &cBands, 0, 0, 0, 0, 0, 0, 0);
        
        // If there are not any bands saved, then we use defaults
        if (!cBands)
        {
            RegCloseKey(hKey);
            hKey = 0;
            hr = CreateDefaultBands();
            goto exit;
        }
    }

    // Loop through the bands in the registry
    for (iBand = 0; iBand < cBands; iBand++)
    {
        // Open the band's subkey
        wsprintf(szSubKey, c_szRegICBand, iBand);
        if (ERROR_SUCCESS == RegOpenKeyEx(hKey, szSubKey, 0, KEY_READ, &hSubKey))
        {
            // Read the band ID.  If this ain't valid, we skip the whole band.
            cbData = sizeof(DWORD);
            lResult = RegQueryValueEx(hSubKey, c_szRegICBandID, 0, &dwType, 
                                      (LPBYTE) &dwID, &cbData);
            if (lResult != ERROR_SUCCESS || dwID > IC_MAX_OBJECTS)
                continue;

            // Read the band height
            lResult = RegQueryValueEx(hSubKey, c_szRegICBandSize, 0, &dwType,
                                      (LPBYTE) &dwHeight, &cbData);
            if (lResult != ERROR_SUCCESS)
                dwHeight = 0;

            // Read the visibility status
            lResult = RegQueryValueEx(hSubKey, c_szRegICBandVisible, 0, &dwType,
                                      (LPBYTE) &dwVisible, &cbData);
            if (lResult != ERROR_SUCCESS)
                dwVisible = TRUE;

            // Now that we have all of this lovely information, create the
            // band.
            switch (dwID)
            {
                case ICOETODAY:
                    break;

                case ICTREEVIEW:
                    AddTreeView(dwHeight, dwVisible);
                    break;

                case ICBLAB:
                    AddMsgrAb(dwHeight, dwVisible);
                    break;

                default:
                    AssertSz(FALSE, "CInfoColumn::CreateBands() - Unknown band ID.");
            }

            // Close the reg key
            RegCloseKey(hSubKey);
        }
    }

    hr = S_OK;

exit:
    if (hKey)
        RegCloseKey(hKey);

    return (hr);
}


HRESULT CInfoColumn::CreateDefaultBands(void)
{
    // Loop through the bands and create one of each
    for (UINT id = 0; id < IC_MAX_OBJECTS; id++)
    {
        switch (id)
        {
            case ICOETODAY:
                break;

            case ICTREEVIEW:
                {
                    //Poeple want to see the TreeView the first time they start up
                    RECT    rctree = {0};
                    if (m_hwndInfoColumn)
                    {
                        GetClientRect(m_hwndInfoColumn, &rctree);
                    }

                    AddTreeView(rctree.bottom / 2);
                    break;
                }
            case ICBLAB:
                AddMsgrAb();
                break;

            default:
                AssertSz(FALSE, "CInfoColumn::CreateBands() - Unknown band ID.");
        }
    }

    return (S_OK);
}


void CInfoColumn::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
    // Load the context menu
    HMENU hMenu = LoadPopupMenu(IDR_INFOCOLUMN_POPUP);
    if (!hMenu)
        return;

    // Loop through the bands and see which ones are visible
    DWORD cBands, iBand;
    REBARBANDINFO rbbi = {0};

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_STYLE | RBBIM_ID;

    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    for (iBand = 0; iBand < cBands; iBand++)
    {
        if (SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi))
        {
            if (!(rbbi.fStyle & RBBS_HIDDEN))
            {
                switch (rbbi.wID)
                {
                    case ICBLAB:
                        CheckMenuItem(hMenu, ID_INFOCOLUMN_CONTACTS, MF_BYCOMMAND | MF_CHECKED);
                        break;

                    case ICTREEVIEW:
                        CheckMenuItem(hMenu, ID_INFOCOLUMN_FOLDER_LIST, MF_BYCOMMAND | MF_CHECKED);
                        break;
                }
            }
        }
    }

    DWORD cmd;
    cmd = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                           xPos, yPos, m_hwndInfoColumn, NULL);

    if (cmd != 0)
    {
        switch (cmd)
        {
            case ID_INFOCOLUMN_CONTACTS:                
                if (m_pMsgrAb)
                {
                    ShowHideBand(ICBLAB);
                }
                else
                {
                    AddMsgrAb();
                }
                break;

            case ID_INFOCOLUMN_FOLDER_LIST:
                if (m_pTreeView)
                {
                    ShowHideBand(ICTREEVIEW);
                }
                else
                {
                    AddTreeView();
                }
                break;
        }
    }

    //If none of the bands is visible, hide the InfoColumn too
    if (!m_cVisibleBands)
    {
        //We can't afford to hide all the bands as it will shrink the Rebar window itself
        //so we make all the bands visible, but hide the InfoColumn Window
        ShowAllBands();
        if (GetParent(m_hwndInfoColumn) != m_hwndParent && m_pFolderBar)
                m_pFolderBar->KillScopeDropDown();

        g_pBrowser->SetViewLayout(DISPID_MSGVIEW_FOLDERLIST, LAYOUT_POS_NA, FALSE, 0, 0);
    }
}


void CInfoColumn::ShowHideBand(DWORD dwBandID)
{
    REBARBANDINFO rbbi = {0};
    DWORD cBands;
    DWORD iBand;

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_ID | RBBIM_STYLE;

    // Find the band
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    for (iBand = 0; iBand < cBands; iBand++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi);
        if (rbbi.wID == dwBandID)
        {
            if (rbbi.fStyle & RBBS_HIDDEN)
            {
                rbbi.fStyle &= ~RBBS_HIDDEN;
                ++m_cVisibleBands;
            }
            else
            {
                rbbi.fStyle |= RBBS_HIDDEN;
                --m_cVisibleBands;
            }

            SendMessage(m_hwndRebar, RB_SETBANDINFO, iBand, (LPARAM) &rbbi);
            return;
        }
    }

    AssertSz(FALSE, "Failed to find the requested band.");
}
//Called by the Folder Bar as a drop down pane
HRESULT CInfoColumn::RegisterFlyOut(CFolderBar *pFolderBar)
{
    Assert(m_pFolderBar == NULL);

    //If all our bands are hidden then make all of them visible.
    //This happens only when the user hides all the bands making the
    //InfoColumn disappear, which causes the drop down to be visible 
    //from folder bar.
    if (!m_cVisibleBands)
    {
        ShowAllBands();
    }
    m_pFolderBar = pFolderBar;
    m_pFolderBar->AddRef();
    RegisterChildren(pFolderBar, TRUE);    
    RegisterGlobalDropDown(m_hwndInfoColumn);
    return S_OK;
}

HRESULT CInfoColumn::RevokeFlyOut(void)
{
    if (m_pFolderBar)
        {
        m_pFolderBar->Release();
        m_pFolderBar = NULL;
        }
    RegisterChildren(NULL, FALSE);
    UnregisterGlobalDropDown(m_hwndInfoColumn);

    return S_OK;
}

//Called by Folder Bar for drop down scope
HRESULT CInfoColumn::GetInfoColWnd(HWND * lphwnd)
{
    if (m_hwndInfoColumn)
    {
        *lphwnd = m_hwndInfoColumn;
        return (S_OK);
    }
    else
    {
        *lphwnd = 0;
        return (E_FAIL);
    }
}

HRESULT CInfoColumn::RegisterChildren(CFolderBar    *pFolder, BOOL Register)
{
    int             BandCount;
    REBARBANDINFO   rbbinfo;

    
    BandCount = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);

    for (--BandCount; BandCount >= 0; BandCount--)
    {
        ZeroMemory(&rbbinfo, sizeof(REBARBANDINFO));
        rbbinfo.fMask = RBBIM_LPARAM;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, BandCount, (LPARAM)&rbbinfo);

        if (rbbinfo.lParam)
        {
            if (Register)
                ((IDropDownFldrBar*)rbbinfo.lParam)->RegisterFlyOut(pFolder);
            else
                ((IDropDownFldrBar*)rbbinfo.lParam)->RevokeFlyOut();
        }
   }
   return S_OK;
}

HRESULT CInfoColumn::HasFocus(UINT   itb)
{
    HRESULT         hres = S_FALSE;
    IInputObject    *pinpobj = NULL;

    switch (itb)
    {
        case ITB_TREE:
            if (m_pTreeView && SUCCEEDED(m_pTreeView->QueryInterface(IID_IInputObject, (void**)&pinpobj)))
            {
                hres = pinpobj->HasFocusIO();
            }
            break;

        case ITB_BUDDYADDRBOOK:
            if (m_pMsgrAb && SUCCEEDED(m_pMsgrAb->QueryInterface(IID_IInputObject, (void**)&pinpobj)))
            {
                hres = pinpobj->HasFocusIO();
            }
            break;
    }
    if (pinpobj)
        pinpobj->Release();
    return hres;
}

HRESULT STDMETHODCALLTYPE CInfoColumn::QueryStatus(const        GUID *pguidCmdGroup, 
                                                   ULONG        cCmds, 
                                                   OLECMD       *prgCmds, 
                                                   OLECMDTEXT   *pCmdText)
{
    // Always let all bands have a shot at this
    for (UINT i = 0; i < IC_MAX_OBJECTS; i++)
    {
        // Check to see if we have a command target for this band.
        if (m_CacheCmdTarget[i])
            m_CacheCmdTarget[i]->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
    }
    
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CInfoColumn::Exec(const GUID   *pguidCmdGroup, 
                                            DWORD        nCmdID, 
                                            DWORD        nCmdExecOpt, 
                                            VARIANTARG   *pvaIn, 
                                            VARIANTARG   *pvaOut)
{
    IOleCommandTarget *pcmdTarget = NULL;
    HRESULT            hr = S_FALSE;

    // Loop through all the bands to see if this is their command
    for (UINT i = 0; i < IC_MAX_OBJECTS; i++)
    {
        // Check to see if we have a command target for this band
        if (m_CacheCmdTarget[i])
        {
            // See if the command belongs to this band
            if (SUCCEEDED(hr = m_CacheCmdTarget[i]->Exec(pguidCmdGroup, nCmdID, 
                                                         nCmdExecOpt, pvaIn, pvaOut)))
            {
                return (hr);
            }
        }
    }

    return (OLECMDERR_E_NOTSUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inireg.cpp ===
/*
 *	ini file/registry manipulation
 *	
 */

#include "pch.hxx"
#include "strconst.h"

ASSERTDATA

// 
// UINT RegGetKeyNumbers(HKEY hkRegDataBase, const TCHAR *szRegSection)
// Enumerate KEYS in szRegSection and return number of keys (subsections).
//
// Return 0, if szRegSection is not found, or doesn't have subsections
//
//  Created: 14 Oct. 1994 by YSt
//
//  Modified 10 Nov. 1997 by YSt
//
UINT RegGetKeyNumbers(HKEY hkRegDataBase, const TCHAR *szRegSection)
{
	LONG lRes;
	HKEY hkSection;
	DWORD iSubKey = 0;

	lRes = RegOpenKeyEx(hkRegDataBase, szRegSection, 0, KEY_ALL_ACCESS, &hkSection);

	if(lRes != ERROR_SUCCESS)				// Cannot open reg database
		return(0);

    // Get number of subkeys
    lRes = RegQueryInfoKey(hkSection, NULL, NULL, NULL, &iSubKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	RegCloseKey(hkSection);

	if(lRes == ERROR_SUCCESS)
		return((UINT) iSubKey);
	else 
		return(0);
}

//
// BOOL RegGetKeyNameFromIndex(HKEY hkRegDataBase, const TCHAR *szRegSection, UINT Index,
//								const TCHAR * szBuffer, UINT cbBuffer)
//
// Return name of key (subsection) from Index in szBuffer. cbBuffer has a size of szBuffer. You must 
// first call RegGetKeyNumbers for enumerating values.
//
//  Created: 14 Oct. 1994 by YSt
//
BOOL RegGetKeyNameFromIndex(HKEY hkRegDataBase, const TCHAR *szRegSection, UINT Index,
								TCHAR * szBuffer, DWORD *pcbBuffer)
{
	LONG lRes;
	HKEY hkSection;
	FILETIME ft;
	
	lRes = RegOpenKeyEx(hkRegDataBase, szRegSection, 0, KEY_ALL_ACCESS, &hkSection);

	if(lRes != ERROR_SUCCESS)				// Cannot open reg database
		return(FALSE);

	lRes = RegEnumKeyEx(hkSection, (DWORD) Index, szBuffer, pcbBuffer, NULL, NULL, NULL, &ft);

	RegCloseKey(hkSection);

	if(lRes	!= ERROR_SUCCESS)	
		return (FALSE);

	return (TRUE);		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\infcolum.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     Infcolum.h
//
//  PURPOSE:    Defines the CInfoColumn class.

#ifndef __INFCOLUM_H__
#define __INFCOLUM_H__

#include    "treeview.h"

interface IMsgrAb;
// interface IBLView;
                
#define     MAX_WIDTH           0xffff
#define     IMAGE_HEIGHT        16
#define     INVALID_BAND_INDEX  (UINT)-1

#define     INFOCOLUMN_LAST      (0xffff - 1)
#define     INFOCOLUMN_FIRST     0xffff

class CFolderBar;

#define LEFTPANE_VERSION    0x01    
//Band Ids
enum {
    ICTREEVIEW = 0,
    ICBLAB,
    ICOETODAY,
    IC_MAX_OBJECTS
};

#define     idcInfoColumn   2500
#define     idcTreeViewBand idcInfoColumn + 1
#define     idcOETodayBand  idcInfoColumn + 2

typedef struct TagColumnObjItem
{
    IInputObject        *pBandObj;
    BORDERWIDTHS        rcBandBorder;
    DWORD               fShow;
}ColumnObjItem;


class CInfoColumn : public IDockingWindow,
                    public IDropTarget,
                    public IInputObject,
                    public IInputObjectSite,
                    public IObjectWithSite,
                    public IOleCommandTarget
{
public:
    CInfoColumn();
    HRESULT HrInit(IAthenaBrowser      *pBrowser,
                   ITreeViewNotify     *ptvNotify);
    virtual ~CInfoColumn(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    HRESULT CInfoColumn::GetInfoColWnd(HWND * lphwnd);  
    HRESULT     RegisterFlyOut(CFolderBar *pFolderBar);
    HRESULT     RevokeFlyOut(void);
    LRESULT     PrivateProcessing(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static      LRESULT CALLBACK InfoColumnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    CTreeView*  GetTreeView();
    BOOL        CycleFocus(BOOL     fReverse);
    BOOL        CycleFocus(DWORD    LastorFirst, BOOL fReverse);        
    void        ForwardMessages(UINT    msg, WPARAM     wParam, LPARAM lParam);
    HRESULT     HasFocus(UINT   itb);
    IMsgrAb*    GetBAComtrol(void) {return m_pMsgrAb; }


    //IOleWindow::GetWindow
    virtual STDMETHODIMP GetWindow(HWND* lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    //IDockingWindow
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT     prcBorder,
                                         IUnknown*  punkToolbarSite,
                                         BOOL       fReserved);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);

    //IInputObject
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO(void);
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG pMsg);

    //IIinputObjectSite
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    //IObjectWithSite
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID *ppvSite);
    virtual STDMETHODIMP SetSite(IUnknown   *pUnkSite);

    //IOleCommandTarget
    HRESULT STDMETHODCALLTYPE QueryStatus(const GUID    *pguidCmdGroup, 
                                          ULONG         cCmds, 
                                          OLECMD        rgCmds[], 
                                          OLECMDTEXT    *pCmdText);
    HRESULT STDMETHODCALLTYPE Exec(const GUID   *pguidCmdGroup, 
                                    DWORD       nCmdID, 
                                    DWORD       nCmdExecOpt, 
                                    VARIANTARG  *pvaIn, 
                                    VARIANTARG  *pvaOut);
    
    //IDropTarget
    virtual STDMETHODIMP DragEnter(  IDataObject *pDataObject, 
                                     DWORD       grfKeyState, 
                                     POINTL      pt,          
                                     DWORD       *pdwEffect);

    virtual STDMETHODIMP DragOver(  DWORD        grfKeyState, 
                                    POINTL       pt,         
                                    DWORD        *pdwEffect );

    virtual STDMETHODIMP DragLeave(void);

    virtual STDMETHODIMP Drop(  IDataObject      *pDataObject,   
                                DWORD            grfKeyState,
                                POINTL           pt,             
                                DWORD            *pdwEffect);

private:
    HRESULT     CreateInfoColumn(BOOL fVisible);
    LRESULT     WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL        OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
    LRESULT     OnNotify(HWND   hwnd, WPARAM wParam, LPNMHDR lParam);
    void        OnSize(HWND   hwnd, UINT  state, int cxClient, int cyClient);
    void        OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int  x, int  y, UINT keyFlags);
    void        OnMouseMove(HWND hwnd, int x, int y, UINT   keyFlags);
    void        OnLButtonUp(HWND hwnd, int x, int y, UINT   keyFlags);
    LRESULT     OnICBeginDrag(LPNMREBAR pnm);
    void        OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);
    HRESULT     FindBandListIndex(DWORD *pdwindex);
    DWORD       FindBandObject(IInputObject   *punk);
    HRESULT     AddObject(IInputObject *pinpObj, DWORD fShow);
    void        ResizeBands(int width);
    void        GetFontParams();
    BOOL        SetCycledFocus(DWORD Index, BOOL fReverse);
    DWORD       GetFirstBand();
    DWORD       GetLastBand();

    HRESULT     AddTreeView(DWORD dwSize = 0, BOOL fVisible = TRUE);
    HRESULT     AddMsgrAb(DWORD dwSize = 0, BOOL fVisible = TRUE);
    void        AddOETodayBand(DWORD dwSize = 0, BOOL fVisible = TRUE);

    HRESULT     SaveSettings(void);
    HRESULT     CreateBands(void);
    HRESULT     CreateDefaultBands(void);
    void        ShowHideBand(DWORD dwBandID);
    BOOL        IsOurWindow(HWND   hwnd);
    HRESULT     RegisterChildren(CFolderBar    *pFolder, BOOL Register);
    void        CleanupLParam();
    void        ShowAllBands();

private:
    HFONT               m_hfIcon;
    UINT                m_cRef;
    IDockingWindowSite  *m_pDwSite;
    ColumnObjItem       m_BandList[IC_MAX_OBJECTS];
    IOleCommandTarget   *m_CacheCmdTarget[IC_MAX_OBJECTS];
    IInputObject        *m_CurFocus;
    HWND                m_hwndInfoColumn;
    HWND                m_hwndRebar;
    HWND                m_hwndParent;
    BOOL                m_fShow;
    CTreeView           *m_pTreeView;
    IMsgrAb             *m_pMsgrAb;
    LONG                m_xWidth;
    HIMAGELIST          m_himl;
    BOOL                m_fRebarDragging;
    CFolderBar          *m_pFolderBar;
    int                 m_cVisibleBands;
    BOOL                m_fDragging;
};

#endif //__INFCOLUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\inetdef.cpp ===
/*
 *   i n e t d e f . c p p
 *    
 *    Purpose:
 *        Defered wininet.dll
 *    
 *    Owner:
 *        brettm.
 *    
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */
#include "pch.hxx"
#include "strconst.h"
#include "resource.h"
#include "inetdef.h"

ASSERTDATA

/* 
 *  t y p e d e f s
 */
typedef INTERNETAPI HINTERNET (WINAPI *PFNINTERNETOPEN)(
    IN LPCSTR lpszAgent, 
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef BOOL (WINAPI *PFNINTERNETREADFILE)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

typedef INTERNETAPI HINTERNET (WINAPI *PFNINTERNETOPENURL) (
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef BOOL (WINAPI *PFNINTERNETCLOSEHANDLE) (
    IN HINTERNET hInternet
    );

static PFNINTERNETOPEN          s_pfnInternetOpen=NULL;
static PFNINTERNETREADFILE      s_pfnInternetReadFile=NULL;
static PFNINTERNETOPENURL       s_pfnInternetOpenUrl=NULL;
static PFNINTERNETCLOSEHANDLE   s_pfnInternetCloseHandle=NULL;

static const TCHAR  c_szAPIInternetOpen[]       ="InternetOpenA",
                    c_szAPIInternetOpenUrl[]    ="InternetOpenUrlA",
                    c_szAPIInternetReadFile[]   ="InternetReadFile",
                    c_szAPIInternetCloseHandle[]="InternetCloseHandle",
                    c_szWinInet[]               ="WININET.DLL";

/* 
 *  s t a t i c s
 */

static HINSTANCE           s_hInstWinINet=0;

/* 
 * t y p e d e f s
 */

HRESULT HrInit_WinInetDef(BOOL fInit)
{
    static  BOOL s_fInited=FALSE;

    if(fInit)
        {
        if (s_fInited)
            return NOERROR;

        if(!s_hInstWinINet)
            s_hInstWinINet=LoadLibrary(c_szWinInet);

        s_pfnInternetOpen = (PFNINTERNETOPEN)GetProcAddress(s_hInstWinINet, c_szAPIInternetOpen);
        s_pfnInternetOpenUrl = (PFNINTERNETOPENURL)GetProcAddress(s_hInstWinINet, c_szAPIInternetOpenUrl);
        s_pfnInternetReadFile = (PFNINTERNETREADFILE)GetProcAddress(s_hInstWinINet, c_szAPIInternetReadFile);
        s_pfnInternetCloseHandle = (PFNINTERNETCLOSEHANDLE)GetProcAddress(s_hInstWinINet, c_szAPIInternetCloseHandle);

        if(s_hInstWinINet==NULL || 
            s_pfnInternetOpenUrl==NULL || 
            s_pfnInternetOpen==NULL || 
            s_pfnInternetReadFile==NULL ||
            s_pfnInternetCloseHandle==NULL)
            {
            AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrLoadWinInet), NULL, MB_OK);
            return E_FAIL;
            }        
        s_fInited=TRUE;
        }
    else
        {
        if(s_hInstWinINet)
            {
            FreeLibrary(s_hInstWinINet);
            s_hInstWinINet=NULL;
            }
        s_fInited=FALSE;
        }
    return NOERROR;
}



HINTERNET Def_InternetOpen (
    IN LPCSTR lpszAgent, 
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    HRESULT hr;

    hr=HrInit_WinInetDef(TRUE);
    if(FAILED(hr))
        return NULL;

    Assert(s_pfnInternetOpen);

    return s_pfnInternetOpen(lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags);
}


BOOL Def_InternetReadFile (
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    HRESULT hr;
    hr=HrInit_WinInetDef(TRUE);
    if(FAILED(hr))
        return hr;

    Assert(s_pfnInternetReadFile);

    return s_pfnInternetReadFile(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
}


HINTERNET Def_InternetOpenUrl (
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    )
{
    HRESULT hr;

    hr=HrInit_WinInetDef(TRUE);
    if(FAILED(hr))
        return NULL;

    Assert(s_pfnInternetOpenUrl);

    return s_pfnInternetOpenUrl(hInternet, lpszUrl, lpszHeaders, dwHeadersLength, dwFlags, dwContext);
}

BOOL Def_InternetCloseHandle(IN HINTERNET hInternet)
{
    HRESULT hr;

    hr=HrInit_WinInetDef(TRUE);
    if(FAILED(hr))
        return NULL;

    Assert(s_pfnInternetCloseHandle);

    return s_pfnInternetCloseHandle(hInternet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\iso8601.h ===
#ifndef __ISO8601_H
#define __ISO8601_H

#define ISO8601_ST_YEAR         0x00000001
#define ISO8601_ST_MONTH        0x00000002
#define ISO8601_ST_DAYOFWEEK    0x00000004
#define ISO8601_ST_DAY          0x00000008
#define ISO8601_ST_HOUR         0x00000010
#define ISO8601_ST_MINUTE       0x00000020
#define ISO8601_ST_MILLISEC     0x00000040

class iso8601
{
public:
    static HRESULT toSystemTime(char *pszISODate, SYSTEMTIME *pst, DWORD *pdwFlags, BOOL fLenient = TRUE, BOOL fPartial = TRUE);
    static HRESULT toFileTime(char *pszISODate, FILETIME *pft, DWORD *pdwFlags, BOOL fLenient = TRUE, BOOL fPartial = TRUE);

    static HRESULT fromSystemTime(SYSTEMTIME *pst, char *pszISODate);
    static HRESULT fromFileTime(FILETIME *pft, char *pszISOData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\itbar.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     itbar.cpp
//
//  PURPOSE:    Implements the sizable coolbar window.
//

/********************************************************************************
Please do not make any changes to this file because this file is going to be 
deleted from this project soon
Instead add the changes to tbbands.cpp and tbbands.h
*********************************************************************************/

#include "pch.hxx"
#include "ourguid.h"    
#include "browser.h"
#include <resource.h>
#include "itbar.h"
#include "strconst.h"
#include "thormsgs.h"
#include <error.h>
#include "xpcomm.h"
#include "conman.h"
#include "mailnews.h"
#include "shared.h"
#include <shlwapi.h>
#include "statnery.h"
#include "goptions.h"
#include "menuutil.h"
#include "menures.h"
#include <shlobjp.h>
#include <shlguidp.h>
#include "demand.h"
#include "baui.h"

UINT GetCurColorRes(void);

CCoolbar::CCoolbar() : m_cRef(1), m_yCapture(-1)
{
    DOUTL(1, TEXT("ctor CCoolbar %x"), this);
    
    m_cRef = 1;
    m_ptbSite = NULL;
    m_cxMaxButtonWidth = 70;
    m_ftType = FOLDER_TYPESMAX;
    m_ptai = NULL;
    m_fSmallIcons = FALSE;
    
    m_hwndParent = NULL;
    m_hwndTools = NULL;
    m_hwndBrand = NULL;
    m_hwndSizer = NULL;
    m_hwndRebar = NULL;
    
    ZeroMemory(&m_cbsSavedInfo, sizeof(COOLBARSAVE));
    m_csSide = COOLBAR_TOP;
    m_dwState = 0;
    
    m_idbBack = 0;
    m_hbmBack = NULL;
    m_hbmBrand = NULL;
    Assert(2 == CIMLISTS);
    m_rghimlTools[IMLIST_DEFAULT] = NULL;
    m_rghimlTools[IMLIST_HOT] = NULL;
    
    m_hpal = NULL;
    m_hdc = NULL;
    m_xOrg = 0;
    m_yOrg = 0;
    m_cxBmp = 0;
    m_cyBmp = 0;
    m_cxBrand = 0;
    m_cyBrand = 0;
    m_cxBrandExtent = 0;
    m_cyBrandExtent = 0;
    m_cyBrandLeadIn = 0;
    m_rgbUpperLeft = 0;

    m_pMenuBand  = NULL;
    m_pDeskBand  = NULL;
    m_pShellMenu = NULL;
    m_pWinEvent  = NULL;
    m_mbCallback = NULL;

    m_xCapture = -1;
    m_yCapture = -1;
    
    // Bug #12953 - Try to load the localized max button width from the resources
    TCHAR szBuffer[32];
    if (AthLoadString(idsMaxCoolbarBtnWidth, szBuffer, ARRAYSIZE(szBuffer)))
    {
        m_cxMaxButtonWidth = StrToInt(szBuffer);
        if (m_cxMaxButtonWidth == 0)
            m_cxMaxButtonWidth = 70;
    }
}


CCoolbar::~CCoolbar()
{
    int i;
    
    DOUTL(1, TEXT("dtor CCoolbar %x"), this);
    
    if (m_ptbSite)
    {
        AssertSz(m_ptbSite == NULL, _T("CCoolbar::~CCoolbar() - For some reason ")
            _T("we still have a pointer to the site."));
        m_ptbSite->Release();
        m_ptbSite = NULL;
    }
    
    if (m_hpal)
        DeleteObject(m_hpal);
    if (m_hdc)
        DeleteDC(m_hdc);
    if (m_hbmBrand)
        DeleteObject(m_hbmBrand);
    if ( m_hbmBack )
        DeleteObject( m_hbmBack );
    
    for (i = 0; i < CIMLISTS; i++)
    {
        if (m_rghimlTools[i])
            ImageList_Destroy(m_rghimlTools[i]);
    }

    SafeRelease(m_pDeskBand);
    SafeRelease(m_pMenuBand);
    SafeRelease(m_pWinEvent);
    SafeRelease(m_pShellMenu);
    SafeRelease(m_mbCallback);
}


//
//  FUNCTION:   CCoolbar::HrInit()
//
//  PURPOSE:    Initializes the coolbar with the information needed to load
//              any persisted reg settings and the correct arrays of buttons
//              to display.
//
//  PARAMETERS:
//      <in> idBackground - Resource ID of the background bitmap to use.
//
//  RETURN VALUE:
//      S_OK - Everything initialized correctly.
//
HRESULT CCoolbar::HrInit(DWORD idBackground, HMENU hmenu)
{
    DWORD cbData;
    DWORD dwType;
    
    // Save the path and value so we can save ourselves on exit
    m_idbBack = idBackground;
    
    // See if we can get the previously saved information first
    ZeroMemory(&m_cbsSavedInfo, sizeof(COOLBARSAVE));
    
    cbData = sizeof(COOLBARSAVE);
    AthUserGetValue(NULL, c_szRegCoolbarLayout, &dwType, (LPBYTE)&m_cbsSavedInfo, &cbData); 
    
    if (m_cbsSavedInfo.dwVersion != COOLBAR_VERSION)
    {
        // Either the version didn't match, or we didn't read anything.  Use
        // default values
        m_cbsSavedInfo.dwVersion = COOLBAR_VERSION;
        m_cbsSavedInfo.csSide = COOLBAR_TOP;
        
        m_cbsSavedInfo.bs[0].wID        = CBTYPE_MENUBAND;
        m_cbsSavedInfo.bs[0].dwStyle    = RBBS_GRIPPERALWAYS;

        m_cbsSavedInfo.bs[1].wID        = CBTYPE_BRAND; 

        m_cbsSavedInfo.bs[2].wID        = CBTYPE_TOOLS;
        m_cbsSavedInfo.bs[2].dwStyle    = RBBS_BREAK;
        
        m_cbsSavedInfo.dwState |= CBSTATE_COMPRESSED;
    }
    
    m_csSide = m_cbsSavedInfo.csSide;
    m_dwState = m_cbsSavedInfo.dwState;
  
    m_hMenu = hmenu;

    return (S_OK);    
}    


HRESULT CCoolbar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IOleWindow)
        || IsEqualIID(riid, IID_IDockingWindow))
    {
        *ppvObj = (IDockingWindow*)this;
        m_cRef++;
        DOUTL(2, TEXT("CCoolbar::QI(IID_IDockingWindow) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = (IObjectWithSite*)this;
        m_cRef++;
        DOUTL(2, TEXT("CCoolbar::QI(IID_IObjectWithSite) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellMenuCallback))
    {
        *ppvObj = (IShellMenuCallback*)this;
        m_cRef++;
        DOUTL(2, TEXT("CCoolbar::QI(IID_IShellCallback) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    
    *ppvObj = NULL;
    return E_NOINTERFACE;
}


ULONG CCoolbar::AddRef()
{
    m_cRef++;
    DOUTL(4, TEXT("CCoolbar::AddRef() - m_cRef = %d"), m_cRef);
    return m_cRef;
}

ULONG CCoolbar::Release()
{
    m_cRef--;
    DOUTL(4, TEXT("CCoolbar::Release() - m_cRef = %d"), m_cRef);
    
    if (m_cRef > 0)
        return m_cRef;
    
    delete this;
    return 0;
}


//
//  FUNCTION:   CCoolbar::GetWindow()
//
//  PURPOSE:    Returns the window handle of the top side rebar.
//
HRESULT CCoolbar::GetWindow(HWND * lphwnd)
{
    if (m_hwndSizer)
    {
        *lphwnd = m_hwndSizer;
        return (S_OK);
    }
    else
    {
        *lphwnd = NULL;
        return (E_FAIL);
    }
}


HRESULT CCoolbar::ContextSensitiveHelp(BOOL fEnterMode)
{
    return (E_NOTIMPL);
}    


//
//  FUNCTION:   CCoolbar::SetSite()
//
//  PURPOSE:    Allows the owner of the coolbar to tell it what the current
//              IDockingWindowSite interface to use is.
//
//  PARAMETERS:
//      <in> punkSite - Pointer of the IUnknown to query for IDockingWindowSite.
//                      If this is NULL, we just release our current pointer.
//
//  RETURN VALUE:
//      S_OK - Everything worked
//      E_FAIL - Could not get IDockingWindowSite from the punkSite provided.
//
HRESULT CCoolbar::SetSite(IUnknown* punkSite)
{
    // If we had a previous pointer, release it.
    if (m_ptbSite)
    {
        m_ptbSite->Release();
        m_ptbSite = NULL;
    }
    
    // If a new site was provided, get the IDockingWindowSite interface from it.
    if (punkSite)    
    {
        if (FAILED(punkSite->QueryInterface(IID_IDockingWindowSite, 
            (LPVOID*) &m_ptbSite)))
        {
            Assert(m_ptbSite);
            return E_FAIL;
        }
    }
    
    return (S_OK);    
}    

HRESULT CCoolbar::GetSite(REFIID riid, LPVOID *ppvSite)
{
    return E_NOTIMPL;
}

//
//  FUNCTION:   CCoolbar::ShowDW()
//
//  PURPOSE:    Causes the coolbar to be either shown or hidden.
//
//  PARAMETERS:
//      <in> fShow - TRUE if the coolbar should be shown, FALSE to hide.
//
//  RETURN VALUE:
//      HRESULT 
//
#define SIZABLECLASS TEXT("SizableRebar")
HRESULT CCoolbar::ShowDW(BOOL fShow)
{
    HRESULT hres = S_OK;
    int     i = 0, j = 0;
    
    // Check to see if our window has been created yet.  If not, do that first.
    if (!m_hwndSizer && m_ptbSite)
    {
        m_hwndParent = NULL;        
        hres = m_ptbSite->GetWindow(&m_hwndParent);
        
        if (SUCCEEDED(hres))
        {
            WNDCLASSEX              wc;
            
            // Check to see if we need to register our window class    
            wc.cbSize = sizeof(WNDCLASSEX);
            if (!GetClassInfoEx(g_hInst, SIZABLECLASS, &wc))
            {
                wc.style            = 0;
                wc.lpfnWndProc      = SizableWndProc;
                wc.cbClsExtra       = 0;
                wc.cbWndExtra       = 0;
                wc.hInstance        = g_hInst;
                wc.hCursor          = NULL;
                wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
                wc.lpszMenuName     = NULL;
                wc.lpszClassName    = SIZABLECLASS;
                wc.hIcon            = NULL;
                wc.hIconSm          = NULL;
                
                RegisterClassEx(&wc);
            }
            
            // Load the background bitmap to use for the coolbar and also get
            // a handle to the HDC and Palette for the coolbar.  This will be
            // used to draw the animated logo later.
            m_hdc = CreateCompatibleDC(NULL);
            if (GetDeviceCaps(m_hdc, RASTERCAPS) & RC_PALETTE)
                m_hpal = SHCreateShellPalette(m_hdc);
            
            // If we're trying to show the coolbar, then create the rebar and
            // add it's bands based on information saved in the registry.
            if (SUCCEEDED(CreateRebar(fShow)))
            {
                for (i = 0; i < (int) CBANDS; i++)
                {
                    switch (m_cbsSavedInfo.bs[i].wID)
                    {
                    case CBTYPE_BRAND:
                        hres = ShowBrand();
                        break;

                    case CBTYPE_MENUBAND:
                        hres = CreateMenuBand(&m_cbsSavedInfo.bs[i]);
                        break;

                    case CBTYPE_TOOLS:
                        hres = AddTools(&(m_cbsSavedInfo.bs[i]));
                        break;
                    }
                }
            }
        }
    }
    
    // Set our state flags.  If we're going to hide, then also save our current
    // settings in the registry.

    /*
    if (fShow)
        ClearFlag(CBSTATE_HIDDEN);
    else
    {
        SetFlag(CBSTATE_HIDDEN);        
        //SaveSettings();
    }
    */
    
    // Resize the rebar based on it's new hidden / visible state and also 
    // show or hide the window.    
    if (m_hwndSizer) 
    {
        ResizeBorderDW(NULL, NULL, FALSE);
        //ShowWindow(m_hwndSizer, fShow ? SW_SHOW : SW_HIDE);
    }
    
    if (g_pConMan)
        g_pConMan->Advise(this);
    
    return hres;
}

void CCoolbar::HideToolbar(DWORD    dwBandID)
{
    REBARBANDINFO   rbbi = {0};
    DWORD           cBands;
    DWORD           iBand;

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_ID | RBBIM_STYLE;

    // Find the band
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    for (iBand = 0; iBand < cBands; iBand++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi);
        if (rbbi.wID == dwBandID)
        {
            if (rbbi.fStyle & RBBS_HIDDEN)
            {
                rbbi.fStyle &= ~RBBS_HIDDEN;
            }
            else
            {
                rbbi.fStyle |= RBBS_HIDDEN;
            }

            rbbi.fMask = RBBIM_STYLE;
            SendMessage(m_hwndRebar, RB_SETBANDINFO, iBand, (LPARAM) &rbbi);
            return;
        }
    }

}

//
//  FUNCTION:   CCoolbar::CloseDW()
//
//  PURPOSE:    Destroys the coolbar.
//
HRESULT CCoolbar::CloseDW(DWORD dwReserved)
{    
    if (m_hwndSizer)
    {
        SaveSettings();
        DestroyWindow(m_hwndSizer);
        m_hwndSizer = NULL;
    }
    

    if (m_pDeskBand)
    {
        IInputObject    *pinpobj;

        if (SUCCEEDED(m_pDeskBand->QueryInterface(IID_IInputObject, (LPVOID*)&pinpobj)))
        {
            pinpobj->UIActivateIO(FALSE, NULL);
            pinpobj->Release();
        }

        IObjectWithSite    *pobjsite;

        if (SUCCEEDED(m_pDeskBand->QueryInterface(IID_IObjectWithSite, (LPVOID*)&pobjsite)))
        {
            pobjsite->SetSite(NULL);
            pobjsite->Release();
        }
        m_pDeskBand->ShowDW(FALSE);
    }
    return S_OK;
}


//
//  FUNCTION:   CCoolbar::ResizeBorderDW()
//
//  PURPOSE:    This is called when the coolbar needs to resize.  The coolbar
//              in return figures out how much border space will be required 
//              from the parent frame and tells the parent to reserve that
//              space.  The coolbar then resizes itself to those dimensions.
//
//  PARAMETERS:
//      <in> prcBorder       - Rectangle containing the border space for the
//                             parent.
//      <in> punkToolbarSite - Pointer to the IDockingWindowSite that we are
//                             part of.
//      <in> fReserved       - Ignored.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CCoolbar::ResizeBorderDW(LPCRECT prcBorder,
                                 IUnknown* punkToolbarSite,
                                 BOOL fReserved)
{
    const DWORD  c_cxResizeBorder = 3;
    const DWORD  c_cyResizeBorder = 3;
    
    HRESULT hres = S_OK;
    RECT    rcRequest = { 0, 0, 0, 0 };
    
    // If we don't have a stored site pointer, we can't resize.
    if (!m_ptbSite)
    {
        AssertSz(m_ptbSite, _T("CCoolbar::ResizeBorderDW() - Can't resize ")
            _T("without an IDockingWindowSite interface to call."));
        return (E_INVALIDARG);
    }
    
    // If we're visible, then calculate our border rectangle.    
    /*
    if (IsFlagClear(CBSTATE_HIDDEN))
    {
    */
        RECT rcBorder, rcRebar, rcT;
        int  cx, cy;
        
        // Get the size this rebar currently is
        GetWindowRect(m_hwndRebar, &rcRebar);
        cx = rcRebar.right - rcRebar.left;
        cy = rcRebar.bottom - rcRebar.top;
        
        // Find out how big our parent's border space is
        m_ptbSite->GetBorderDW((IDockingWindow*) this, &rcBorder);
        
        // If we're vertical, then we need to adjust our height to
        // match what the parent has.  If we're horizontal, then 
        // adjust our width.
        if (VERTICAL(m_csSide))
            cy = rcBorder.bottom - rcBorder.top;
        else
            cx = rcBorder.right - rcBorder.left;
        
        // Bug #31007 - There seems to be a problem in commctrl
        // IEBug #5574  either with the REBAR or with the Toolbar
        //              when they are vertical.  If the we try to
        //              size them to 2 or less, we lock up.  This
        //              is a really poor fix, but there's no way
        //              to get commctrl fixed this late in the game.
        if (cy < 5) cy = 10;
        if (cx < 5) cx = 10;
        
        // Move the rebar to the new position.
        if (m_csSide == COOLBAR_LEFT || m_csSide == COOLBAR_TOP)
        {
            SetWindowPos(m_hwndRebar, NULL, 0, 0, cx, cy, 
                SWP_NOZORDER | SWP_NOACTIVATE);
        }
        else
        {
            if (m_csSide == COOLBAR_BOTTOM)
                SetWindowPos(m_hwndRebar, NULL, 0, c_cyResizeBorder,
                cx, cy, SWP_NOZORDER | SWP_NOACTIVATE);
            else
                SetWindowPos(m_hwndRebar, NULL, c_cxResizeBorder, 0,
                cx, cy, SWP_NOZORDER | SWP_NOACTIVATE);
        }                     
        
        // Figure out how much border space to ask the site for
        GetWindowRect(m_hwndRebar, &rcRebar);
        switch (m_csSide)
        {
            case COOLBAR_TOP:
                rcRequest.top = rcRebar.bottom - rcRebar.top + c_cxResizeBorder;
                break;
            
            case COOLBAR_LEFT:
                rcRequest.left = rcRebar.right - rcRebar.left + c_cyResizeBorder;
                break;
            
            case COOLBAR_BOTTOM:
                rcRequest.bottom = rcRebar.bottom - rcRebar.top + c_cxResizeBorder;
                break;
            
            case COOLBAR_RIGHT:
                rcRequest.right = rcRebar.right - rcRebar.left + c_cyResizeBorder;
                break;
            
            default:
                AssertSz(FALSE, _T("CCoolbar::ResizeBorderDW() - What other")
                    _T(" sides are there???"));
                break;                
        }
        
        // Ask the site for that border space
        if (SUCCEEDED(m_ptbSite->RequestBorderSpaceDW((IDockingWindow*) this, &rcRequest)))
        {
            // Position the window based on the area given to us
            switch (m_csSide)
            {
                case COOLBAR_TOP:
                    SetWindowPos(m_hwndSizer, NULL, 
                        rcBorder.left, 
                        rcBorder.top,
                        rcRebar.right - rcRebar.left, 
                        rcRequest.top + rcBorder.top, 
                        SWP_NOZORDER | SWP_NOACTIVATE);                
                    break;
                
                case COOLBAR_LEFT:
                    SetWindowPos(m_hwndSizer, NULL, 
                        rcBorder.left, 
                        rcBorder.top, 
                        rcRequest.left, 
                        rcBorder.bottom - rcBorder.top,
                        SWP_NOZORDER | SWP_NOACTIVATE);                             
                    break;
                
                case COOLBAR_BOTTOM:
                    SetWindowPos(m_hwndSizer, NULL, 
                        rcBorder.left, 
                        rcBorder.bottom - rcRequest.bottom,
                        rcBorder.right - rcBorder.left, 
                        rcRequest.bottom, 
                        SWP_NOZORDER | SWP_NOACTIVATE);
                    GetClientRect(m_hwndSizer, &rcT);
                    break;
                
                case COOLBAR_RIGHT:
                    SetWindowPos(m_hwndSizer, NULL, 
                        rcBorder.right - rcRequest.right, 
                        rcBorder.top, 
                        rcRequest.right, 
                        rcBorder.bottom - rcBorder.top,
                        SWP_NOZORDER | SWP_NOACTIVATE);                             
                    break;
            }
        }
    /*
    } 
    */
    
    // Now tell the site how much border space we're using.    
    m_ptbSite->SetBorderSpaceDW((IDockingWindow*) this, &rcRequest);
    
    return hres;
}


//
//  FUNCTION:   CCoolbar::Invoke()
//
//  PURPOSE:    Allows the owner of the coolbar to force the coolbar to do 
//              something.
//
//  PARAMETERS:
//      <in> id - ID of the command the caller wants the coolbar to do.
//      <in> pv - Pointer to any parameters the coolbar might need to carry
//                out the command.
//
//  RETURN VALUE:
//      S_OK - The command was carried out.
//      
//  COMMENTS:
//      <???>
//
HRESULT CCoolbar::Invoke(DWORD id, LPVOID pv)
{
    switch (id)
    {
        // Starts animating the logo
        case idDownloadBegin:
            StartDownload();
            break;
        
            // Stops animating the logo
        case idDownloadEnd:
            StopDownload();
            break;
        
            // Update the enabled / disabled state of buttons on the toolbar
        case idStateChange:
        {
            // pv is a pointer to a COOLBARSTATECHANGE struct
            COOLBARSTATECHANGE* pcbsc = (COOLBARSTATECHANGE*) pv;
            SendMessage(m_hwndTools, TB_ENABLEBUTTON, pcbsc->id, 
                MAKELONG(pcbsc->fEnable, 0));
            break;
        }
        
        case idToggleButton:
        {
            COOLBARSTATECHANGE* pcbsc = (COOLBARSTATECHANGE *) pv;
            SendMessage(m_hwndTools, TB_CHECKBUTTON, pcbsc->id,
                MAKELONG(pcbsc->fEnable, 0));
            break;
        }
        
        case idBitmapChange:
        {
            // pv is a pointer to a COOLBARBITMAPCHANGE struct
            COOLBARBITMAPCHANGE *pcbc = (COOLBARBITMAPCHANGE*) pv;
        
            SendMessage(m_hwndTools, TB_CHANGEBITMAP, pcbc->id, MAKELPARAM(pcbc->index, 0));
            break;
        }
        
            // Sends a message directly to the toolbar.    
        case idSendToolMessage:
            #define ptm ((TOOLMESSAGE *)pv)
            ptm->lResult = SendMessage(m_hwndTools, ptm->uMsg, ptm->wParam, ptm->lParam);
            break;
            #undef ptm
        
        case idCustomize:
            SendMessage(m_hwndTools, TB_CUSTOMIZE, 0, 0);
            break;
        
    }
    
    return S_OK;
}


//
//  FUNCTION:   CCoolbar::StartDownload()
//
//  PURPOSE:    Starts animating the logo.
//
void CCoolbar::StartDownload()
{
    if (m_hwndBrand)
    {
        SetFlag(CBSTATE_ANIMATING);
        SetFlag(CBSTATE_FIRSTFRAME);
        m_yOrg = 0;
        SetTimer(m_hwndSizer, ANIMATION_TIMER, 100, NULL);
    }
}


//
//  FUNCTION:   CCoolbar::StopDownload()
//
//  PURPOSE:    Stops animating the logo.  Restores the logo to it's default
//              first frame.
//
void CCoolbar::StopDownload()
{
    int           i, cBands;
    REBARBANDINFO rbbi;
    
    // Set the background colors for this band back to the first frame
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_BRAND == rbbi.wID)
        {
            rbbi.fMask = RBBIM_COLORS;
            rbbi.clrFore = m_rgbUpperLeft;
            rbbi.clrBack = m_rgbUpperLeft;
            SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM) &rbbi);
            
            break;
        }
    }
    
    // Reset the state flags
    ClearFlag(CBSTATE_ANIMATING);
    ClearFlag(CBSTATE_FIRSTFRAME);
    
    KillTimer(m_hwndSizer, ANIMATION_TIMER);
    InvalidateRect(m_hwndBrand, NULL, FALSE);
    UpdateWindow(m_hwndBrand);
}

BOOL CCoolbar::CheckForwardWinEvent(HWND hwnd,  UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HWND hwndForward = NULL;
    switch(uMsg)
    {
    case WM_NOTIFY:
        hwndForward = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwndForward = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
    case WM_PALETTECHANGED:
        hwndForward = m_hwndRebar;
        break;
    }

    if (hwndForward && m_pWinEvent && m_pWinEvent->IsWindowOwner(hwndForward) == S_OK)
    {
        LRESULT lres;
        m_pWinEvent->OnWinEvent(hwndForward, uMsg, wParam, lParam, &lres);
        if (plres)
            *plres = lres;
        return TRUE;
    }

    return FALSE;
}

//
//  FUNCTION:   CCoolbar::SizableWndProc() 
//
//  PURPOSE:    Handles messages sent to the coolbar root window.
//
LRESULT EXPORT_16 CALLBACK CCoolbar::SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCoolbar* pitbar = (CCoolbar*)GetProp(hwnd, TEXT("CCoolbar"));
    DWORD dw;
    
    if (!pitbar)
        goto CallDWP;
    
    switch(uMsg)
    {
        case WM_SYSCOLORCHANGE:
            // Reload the graphics
            LoadGlyphs(pitbar->m_hwndTools, CIMLISTS, pitbar->m_rghimlTools, (fIsWhistler() ? TB_BMP_CX : TB_BMP_CX_W2K),
                (fIsWhistler() ? ((GetCurColorRes() > 24) idb32256Browser : idbBrowser) :
                                  ((GetCurColorRes() > 8) ? idbNW256Browser : idbNWBrowser)));
            pitbar->UpdateToolbarColors();
            InvalidateRect(pitbar->m_hwndTools, NULL, TRUE);
            pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, NULL);
            break;
        
        case WM_WININICHANGE:
        case WM_FONTCHANGE:
            // Forward this to our child windows
            LoadGlyphs(pitbar->m_hwndTools, CIMLISTS, pitbar->m_rghimlTools, (fIsWhistler() ? TB_BMP_CX : TB_BMP_CX_W2K), 
                (fIsWhistler() ? ((GetCurColorRes() > 24) idb32256Browser : idbBrowser) :
                                  ((GetCurColorRes() > 8) ? idbNW256Browser : idbNWBrowser)));
            SendMessage(pitbar->m_hwndTools, uMsg, wParam, lParam);
            InvalidateRect(pitbar->m_hwndTools, NULL, TRUE);
            pitbar->SetMinDimensions();
            pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, NULL);
            break;
        
        case WM_SETCURSOR:
            // We play with the cursor a bit to make the resizing cursor show 
            // up when the user is over the edge of the coolbar that allows 
            // them to drag to resize etc.
            if ((HWND) wParam == hwnd)
            {
                if (pitbar->m_dwState & CBSTATE_INMENULOOP)
                    SetCursor(LoadCursor(NULL, IDC_ARROW));
                else    
                    SetCursor(LoadCursor(NULL, 
                    VERTICAL(pitbar->m_csSide) ? IDC_SIZEWE : IDC_SIZENS));
                return (TRUE);                
            }
            return (FALSE);    
        
        case WM_LBUTTONDOWN:
            // The user is about to resize the bar.  Capture the cursor so we
            // can watch the changes.
            if (VERTICAL(pitbar->m_csSide))
                pitbar->m_xCapture = GET_X_LPARAM(lParam);
            else
                pitbar->m_yCapture = GET_Y_LPARAM(lParam);    
            SetCapture(hwnd);
            break;
        
        case WM_MOUSEMOVE:
            // The user is resizing the bar.  Handle updating the sizes as
            // they drag.
            if (VERTICAL(pitbar->m_csSide))
            {
                if (pitbar->m_xCapture != -1)
                {
                    if (hwnd != GetCapture())
                        pitbar->m_xCapture = -1;
                    else
                        pitbar->TrackSlidingX(GET_X_LPARAM(lParam));
                }
            }
            else    
            {
                if (pitbar->m_yCapture != -1)
                {
                    if (hwnd != GetCapture())
                        pitbar->m_yCapture = -1;
                    else
                        pitbar->TrackSlidingY(GET_Y_LPARAM(lParam));
                }
            }
            break;
        
        case WM_LBUTTONUP:
            // The user is done resizing.  release our capture and reset our
            // state.
            if (pitbar->m_yCapture != -1 || pitbar->m_xCapture != -1)
            {
                ReleaseCapture();
                pitbar->m_yCapture = -1;
                pitbar->m_xCapture = -1;
            }
            break;
        
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
            // We must swallow these messages to avoid infinit SendMessage
            break;
        
        case WM_DRAWITEM:
            // Draws the animating brand
            if (wParam == idcBrand)
                pitbar->DrawBranding((LPDRAWITEMSTRUCT) lParam);
            break;
        
        case WM_MEASUREITEM:
            // Draws the animating brand
            if (wParam == idcBrand)
            {
                ((LPMEASUREITEMSTRUCT) lParam)->itemWidth  = pitbar->m_cxBrand;
                ((LPMEASUREITEMSTRUCT) lParam)->itemHeight = pitbar->m_cyBrand;
            }
            break;
        
        case WM_TIMER:
            // This timer fires every time we need to draw the next frame in
            // animating brand.
            if (wParam == ANIMATION_TIMER)
            {
                if (pitbar->m_hwndBrand)
                {
                    pitbar->m_yOrg += pitbar->m_cyBrand;
                    if (pitbar->m_yOrg >= pitbar->m_cyBrandExtent)
                        pitbar->m_yOrg = pitbar->m_cyBrandLeadIn;
                
                    InvalidateRect(pitbar->m_hwndBrand, NULL, FALSE);
                    UpdateWindow(pitbar->m_hwndBrand);
                }
            }
            break;
        
        case WM_NOTIFY:
            {
                LRESULT lres;
                if (pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, &lres))
                    return lres;
                return pitbar->OnNotify(hwnd, lParam);
            }
        
        case WM_COMMAND:
            {
                LRESULT lres;
                if (pitbar->CheckForwardWinEvent(hwnd,  uMsg, wParam, lParam, &lres))
                    return lres;
                return SendMessage(pitbar->m_hwndParent, WM_COMMAND, wParam, lParam);
            }
        
        case WM_CONTEXTMENU:
            pitbar->OnContextMenu((HWND) wParam, LOWORD(lParam), HIWORD(lParam));
            break;
        
        case WM_PALETTECHANGED:
            // BUGBUG: we could optimize this by realizing and checking the
            // return value
            //
            // for now we will just invalidate ourselves and all children...
            RedrawWindow(pitbar->m_hwndSizer, NULL, NULL,
                RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            break;
        
        case CM_CONNECT:
            // wParam is hMenuConnect, lParam is CmdID
            g_pConMan->Connect((HMENU) wParam, lParam, pitbar->m_hwndParent);
            g_pConMan->FreeConnectMenu((HMENU) wParam);
            break;
        
        case TT_ISTEXTVISIBLE:
            return (!(pitbar->m_dwState & CBSTATE_COMPRESSED));
        
        case WM_DESTROY:
            // Clean up our pointers
            RemoveProp(hwnd, TEXT("CCoolbar"));
            pitbar->Release(); // Corresponding to AddRef at SetProp
        
            DOUTL(1, _T("CCoolbar::WM_DESTROY - Called RemoveProp. Called")
                _T(" Release() new m_cRef=%d"), pitbar->m_cRef);
        
            //Unregister with the connection manager
            if (g_pConMan)
                g_pConMan->Unadvise(pitbar);
        
            // fall through
        
        default:
CallDWP:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }
    
    return 0L;
}

HRESULT CCoolbar::OnCommand(HWND hwnd, int idCmd, HWND hwndControl, UINT cmd)
{
    LPTSTR pszTest;
    
    switch (idCmd)
    {
        case idcBrand:  // click on the spinning globe
            OnHelpGoto(hwnd, ID_MSWEB_PRODUCT_NEWS);
            break;
        
        case ID_CUSTOMIZE:
            SendMessage(m_hwndTools, TB_CUSTOMIZE, 0, 0);
            break;
        
        case ID_TOOLBAR_TOP:
        //case ID_TOOLBAR_LEFT:
        case ID_TOOLBAR_BOTTOM:
        //case ID_TOOLBAR_RIGHT:
            {
                // There's a painting problem that occurs going from top to bottom
                // and vice versa.  If that's what we're doing, we repaint when
                // we're done.
                BOOL fRepaint;
                fRepaint = (VERTICAL(m_csSide) == VERTICAL(idCmd - ID_TOOLBAR_TOP));
            
                m_csSide = (COOLBAR_SIDE) (idCmd - ID_TOOLBAR_TOP);
                ChangeOrientation();
            
                if (fRepaint)
                    InvalidateRect(m_hwndTools, NULL, FALSE);
            }
            break;
        
        case ID_TEXT_LABELS:
            CompressBands(!IsFlagSet(CBSTATE_COMPRESSED));
            break;
        
        default:
            return S_FALSE;
    }
    return S_OK;
}

HRESULT CCoolbar::OnInitMenuPopup(HMENU hMenuContext)
{
    CheckMenuRadioItem(hMenuContext, ID_TOOLBAR_TOP, ID_TOOLBAR_RIGHT, 
        ID_TOOLBAR_TOP + m_csSide, MF_BYCOMMAND);
    
    CheckMenuItem(hMenuContext, ID_TEXT_LABELS, 
        MF_BYCOMMAND | IsFlagSet(CBSTATE_COMPRESSED) ? MF_UNCHECKED : MF_CHECKED);
    return S_OK;
}

LRESULT CCoolbar::OnNotify(HWND hwnd, LPARAM lparam)
{
    NMHDR   *lpnmhdr = (NMHDR*)lparam;

    switch (lpnmhdr->idFrom)
    {
        case idcCoolbar:
            switch (lpnmhdr->code)
            {
            case RBN_HEIGHTCHANGE:
                ResizeBorderDW(NULL, NULL, FALSE);
                break;

            case RBN_CHILDSIZE:
                NMREBARCHILDSIZE    *lpchildsize = (NMREBARCHILDSIZE*)lparam;
                if (lpchildsize->wID == CBTYPE_TOOLS)
                {
                    SetWindowPos(m_hwndTools, NULL, lpchildsize->rcChild.left, lpchildsize->rcChild.right,
                                lpchildsize->rcChild.right - lpchildsize->rcChild.left,
                                lpchildsize->rcChild.bottom - lpchildsize->rcChild.top,
                                SWP_NOZORDER | SWP_NOACTIVATE);

                }
                else
                if (lpchildsize->wID == CBTYPE_BRAND)
                {
                    SetWindowPos(m_hwndBrand, NULL, lpchildsize->rcChild.left, lpchildsize->rcChild.right,
                                lpchildsize->rcChild.right - lpchildsize->rcChild.left,
                                lpchildsize->rcChild.bottom - lpchildsize->rcChild.top,
                                SWP_NOZORDER | SWP_NOACTIVATE);
                }
                break;
            }
        
        case idcToolbar:
            if (lpnmhdr->code == TBN_GETBUTTONINFOA)
                return OnGetButtonInfo((TBNOTIFY*) lparam);
        
            if (lpnmhdr->code == TBN_QUERYDELETE)
                return (TRUE);
        
            if (lpnmhdr->code == TBN_QUERYINSERT)
                return (TRUE);
        
            if (lpnmhdr->code == TBN_ENDADJUST)
            {
                IAthenaBrowser *psbwr;
            
                // Update the size of the sizer
                SetMinDimensions();
                ResizeBorderDW(NULL, NULL, FALSE);
            
                // check IDockingWindowSite 
                if (m_ptbSite)
                {
                    // get IAthenaBrowser interface
                    if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IAthenaBrowser,(void**)&psbwr)))
                    {
                        psbwr->UpdateToolbar();
                        psbwr->Release();
                    }
                }
            }
        
            if (lpnmhdr->code == TBN_RESET)    
            {
                // Remove all the buttons from the toolbar
                int cButtons = SendMessage(m_hwndTools, TB_BUTTONCOUNT, 0, 0);
                while (--cButtons >= 0)
                    SendMessage(m_hwndTools, TB_DELETEBUTTON, cButtons, 0);
            
                // Set the buttons back to the default    
                SendMessage(m_hwndTools, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
                SendMessage(m_hwndTools, TB_ADDBUTTONS, m_ptai->cDefButtons, 
                    (LPARAM) m_ptai->rgDefButtons);
            
                return (TRUE);    
            }
        
            if (lpnmhdr->code == TBN_CUSTHELP)
            {
                // WinHelp(m_hwndTools, c_szMailHelpFile, HELP_CONTEXT, IDH_NEWS_COMM_GROUPBOX);
                OEHtmlHelp(m_hwndTools, c_szCtxHelpFileHTMLCtx, HH_DISPLAY_TOPIC, (DWORD) (LPCSTR) "idh_proced_cust_tool.htm");
                return (TRUE);
            }
        
            if (lpnmhdr->code == TBN_DROPDOWN)
            {
                return OnDropDown(hwnd, lpnmhdr);
            }
        
            break;
    }
    
    return (0L);    
}


LRESULT CCoolbar::OnDropDown(HWND hwnd, LPNMHDR lpnmh)
{
    HMENU           hMenuPopup = NULL;
    TBNOTIFY       *ptbn = (TBNOTIFY *)lpnmh ;
    UINT            uiCmd = ptbn->iItem ;
    RECT            rc;
    DWORD           dwCmd = 0;
    IAthenaBrowser *pBrowser;
    BOOL            fPostCmd = TRUE;
    IOleCommandTarget *pTarget;
    
    // Load and initialize the appropriate dropdown menu
    switch (uiCmd)
    {
        case ID_POPUP_LANGUAGE:
            {
                // check IDockingWindowSite 
                if (m_ptbSite)
                {
                    // get IAthenaBrowser interface
                    if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IAthenaBrowser, (void**) &pBrowser)))
                    {
                        // get language menu from shell/browser
                        pBrowser->GetLanguageMenu(&hMenuPopup, 0);
                        pBrowser->Release();
                    }
                }
            } 
            break;
        
        case ID_NEW_MSG_DEFAULT:
            GetStationeryMenu(&hMenuPopup);

            /* $INFOCOLUMN
            // Disable Send Instant Msg item
            if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IAthenaBrowser, (void**) &pBrowser)))
            {
                CInfoColumn * pInfoColumn = NULL;
                if(SUCCEEDED(pBrowser->GetInfoColumn(&pInfoColumn)))
                {
                    IMsgrAb * pMsgrAb = pInfoColumn->GetBAComtrol();
                    if(pMsgrAb)
                    {
                        BOOL fRet;
                        pMsgrAb->get_InstMsg(&fRet);
                        if(fRet == FALSE)
                            EnableMenuItem(hMenuPopup, ID_SEND_INSTANT_MESSAGE, MF_BYCOMMAND | MF_GRAYED);
                    }
                    pInfoColumn->Release();
                }
                pBrowser->Release();
            } 
            */
            break;
        
        case ID_PREVIEW_PANE:
            {
                // Load the menu
                hMenuPopup = LoadPopupMenu(IDR_PREVIEW_POPUP);
                if (!hMenuPopup)
                    break;
            
                // check IDockingWindowSite 
                if (m_ptbSite)
                {
                    // get IAthenaBrowser interface
                    if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
                    {
                        MenuUtil_EnablePopupMenu(hMenuPopup, pTarget);
                        pTarget->Release();
                    }
                }
            
                break;
            }
        
        default:
            AssertSz(FALSE, "CCoolbar::OnDropDown() - Unhandled TBN_DROPDOWN notification");
            return (TBDDRET_NODEFAULT);
    }
    
    // If we loaded a menu, then go ahead and display it    
    if (hMenuPopup)
    {
        SendMessage(m_hwndTools, TB_GETRECT, ptbn->iItem, (LPARAM)&rc);
        MapWindowRect(m_hwndTools, HWND_DESKTOP, &rc);
        
        SetFlag(CBSTATE_INMENULOOP);
        dwCmd = TrackPopupMenuEx(hMenuPopup, TPM_RETURNCMD | TPM_LEFTALIGN, 
            rc.left, rc.bottom, m_hwndParent, NULL);                        
        ClearFlag(CBSTATE_INMENULOOP);
    }        
    
    // Clean up anything needing to be cleaned up
    switch (uiCmd)
    {
        case ID_LANGUAGE:
            break;
        
        case ID_NEW_MSG_DEFAULT:
            DestroyMenu(hMenuPopup);
            break;
    }
    
    if (fPostCmd && dwCmd)
        PostMessage(m_hwndSizer, WM_COMMAND, dwCmd, 0);
    
    return (TBDDRET_DEFAULT);
}


void CCoolbar::OnContextMenu(HWND hwndFrom, int xPos, int yPos)
{
    HMENU hMenu, hMenuContext;
    TCHAR szBuf[256];
    HWND  hwnd;
    HWND  hwndSizer = GetParent(hwndFrom);
    POINT pt = {xPos, yPos};
    
    // Make sure the context menu only appears on the toolbar bars
    hwnd = WindowFromPoint(pt);
    /*
    if (GetClassName(hwnd, szBuf, ARRAYSIZE(szBuf)))
        if (0 != lstrcmpi(szBuf, TOOLBARCLASSNAME))
            return;
    */
    if (hwnd == m_hwndTools)
    {
        if (NULL != (hMenu = LoadMenu(g_hLocRes, MAKEINTRESOURCE(IDR_TOOLBAR_POPUP))))
        {
            hMenuContext = GetSubMenu(hMenu, 0);
            OnInitMenuPopup(hMenuContext);
            
            SetFlag(CBSTATE_INMENULOOP);
            TrackPopupMenu(hMenuContext, TPM_RIGHTBUTTON, xPos, yPos, 0, 
                hwndFrom, NULL);
            ClearFlag(CBSTATE_INMENULOOP);
            DestroyMenu(hMenu);
        }
    }
    else
    if (hwnd == m_hwndMenuBand)
    {
        HandleCoolbarPopup(xPos, yPos);
    }

}


//
//  FUNCTION:   CCoolbar::OnGetButtonInfo()
//
//  PURPOSE:    Handles the TBN_GETBUTTONINFO notification by returning
//              the buttons availble for the toolbar.
//
//  PARAMETERS:
//      ptbn - pointer to the TBNOTIFY struct we need to fill in.
//
//  RETURN VALUE:
//      Returns TRUE to tell the toolbar to use this button, or FALSE
//      otherwise.
//
LRESULT CCoolbar::OnGetButtonInfo(TBNOTIFY* ptbn)
{
    // Start by returning information for the first array of 
    // buttons
    if ((ptbn->iItem < (int) m_ptai->cDefButtons && (ptbn->iItem >= 0)))
    {
        // Grab the button info out of the array
        ptbn->tbButton = m_ptai->rgDefButtons[ptbn->iItem];
        
        // Return the string info from the string resource.  Note,
        // pszText already points to a buffer allocated by the
        // control and cchText has the length of that buffer.
        LoadString(g_hLocRes, m_ptai->rgidsButtons[ptbn->tbButton.iString],
            ptbn->pszText, ptbn->cchText);
        return (TRUE);
    }
    else
    {
        // Now return information for the extra buttons not on the `
        // toolbar by default.
        if (ptbn->iItem < (int) (m_ptai->cDefButtons + m_ptai->cExtraButtons)) 
        {
            ptbn->tbButton = m_ptai->rgExtraButtons[ptbn->iItem - m_ptai->cDefButtons];
            
            // The control has already created a buffer for us to copy
            // the string into.
            LoadString(g_hLocRes, m_ptai->rgidsButtons[ptbn->tbButton.iString],
                ptbn->pszText, ptbn->cchText);
            return (TRUE);
        }
        else
        {
            // No more buttons to add, so return FALSE.
            return (FALSE);
        }
    }
}    


HRESULT CCoolbar::ShowBrand(void)
{
    REBARBANDINFO   rbbi;
    
    // create branding window
    /*
    m_hwndBrand = CreateWindow(TEXT("button"), NULL,WS_CHILD | BS_OWNERDRAW,
        0, 0, 400, 200, m_hwndRebar, (HMENU) idcBrand,
        g_hInst, NULL);
    */
    m_hwndBrand = CreateWindow(TEXT("button"), NULL,WS_CHILD | BS_OWNERDRAW,
        0, 0, 0, 0, m_hwndRebar, (HMENU) idcBrand,
        g_hInst, NULL);

    if (!m_hwndBrand)
    {
        DOUTL(1, TEXT("!!!ERROR!!! CITB:Show CreateWindow(BRANDING) failed"));
        return(E_OUTOFMEMORY);
    }
    
    LoadBrandingBitmap();
    
    // add branding band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_STYLE | RBBIM_COLORS | RBBIM_CHILD | RBBIM_ID;
    rbbi.fStyle = RBBS_FIXEDSIZE;
    rbbi.wID    = CBTYPE_BRAND;
    rbbi.clrFore = m_rgbUpperLeft;
    rbbi.clrBack = m_rgbUpperLeft;
    rbbi.hwndChild = m_hwndBrand;
    
    
    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT) -1, (LPARAM) (LPREBARBANDINFO) &rbbi);
    
    return (S_OK);
}

HRESULT CCoolbar::LoadBrandingBitmap()
{
    HKEY        hKey;
    DIBSECTION  dib;
    DWORD       dwcbData;
    DWORD       dwType = 0;
    BOOL        fReg = FALSE;
    BOOL        fRegLoaded = FALSE;
    TCHAR       szScratch[MAX_PATH];
    TCHAR       szExpanded[MAX_PATH];
    LPTSTR      psz;
    
    if (m_hbmBrand)
    {
        DeleteObject(m_hbmBrand);
        m_hbmBrand = NULL;
    }
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegKeyCoolbar, 0, KEY_QUERY_VALUE, &hKey))
    {
        fReg = TRUE;
        dwcbData = MAX_PATH;
        if (fReg && (ERROR_SUCCESS == RegQueryValueEx(hKey, IsFlagSet(CBSTATE_COMPRESSED) ? c_szValueSmBrandBitmap : c_szValueBrandBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &dwcbData)))
        {
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szScratch, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szScratch;
            
            m_hbmBrand = (HBITMAP) LoadImage(NULL, psz, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            
            if (m_hbmBrand)
                fRegLoaded = TRUE;
        }
    }
    
    if (!m_hbmBrand)
    {
        int id = IsFlagSet(CBSTATE_COMPRESSED) ? (fIsWhistler() ? idbHiBrand26 : idbBrand26) : 
                (fIsWhistler() ? idbHiBrand38 : idbBrand38);
        m_hbmBrand = (HBITMAP)LoadImage(g_hLocRes, MAKEINTRESOURCE(id), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
    }
    
    GetObject(m_hbmBrand, sizeof(DIBSECTION), &dib);
    m_cxBrandExtent = dib.dsBm.bmWidth;
    m_cyBrandExtent = dib.dsBm.bmHeight;
    
    m_cxBrand = m_cxBrandExtent;
    
    dwcbData = sizeof(DWORD);
    
    if (!fRegLoaded || (ERROR_SUCCESS != RegQueryValueEx(hKey, IsFlagSet(CBSTATE_COMPRESSED) ? c_szValueSmBrandHeight : c_szValueBrandHeight, NULL, &dwType,
        (LPBYTE)&m_cyBrand, &dwcbData)))
        m_cyBrand = m_cxBrandExtent;
    
    
    if (!fRegLoaded || (ERROR_SUCCESS != RegQueryValueEx(hKey, IsFlagSet(CBSTATE_COMPRESSED) ? c_szValueSmBrandLeadIn : c_szValueBrandLeadIn, NULL, &dwType,
        (LPBYTE)&m_cyBrandLeadIn, &dwcbData)))
        m_cyBrandLeadIn = 4;
    
    m_cyBrandLeadIn *= m_cyBrand;
    
    SelectObject(m_hdc, m_hbmBrand);
    
    m_rgbUpperLeft = GetPixel(m_hdc, 1, 1);
    
    if (fReg)
        RegCloseKey(hKey);
    
    // now look for old branding entries for IE2.0 and, if found, stick them
    // in the first frame of the animation sequence    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyIEMain, 0, KEY_QUERY_VALUE, &hKey))
    {
        dwcbData = MAX_PATH;
        
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, IsFlagSet(CBSTATE_COMPRESSED) ? c_szValueSmallBitmap : c_szValueLargeBitmap, NULL, &dwType,
            (LPBYTE)szScratch, &dwcbData))
        {
            if (REG_EXPAND_SZ == dwType)
            {
                ExpandEnvironmentStrings(szScratch, szExpanded, ARRAYSIZE(szExpanded));
                psz = szExpanded;
            }
            else
                psz = szScratch;
            
            HBITMAP hbmOld = (HBITMAP) LoadImage(NULL, psz, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE);
            
            if (hbmOld)
            {
                HDC hdcOld = CreateCompatibleDC(m_hdc);
                
                if (hdcOld)
                {
                    GetObject(hbmOld, sizeof(DIBSECTION), &dib);
                    SelectObject(hdcOld, hbmOld);
                    m_rgbUpperLeft = GetPixel(hdcOld, 1, 1);
                    StretchBlt(m_hdc, 0, 0, m_cxBrandExtent, m_cyBrand, hdcOld, 0, 0,
                        dib.dsBm.bmWidth, dib.dsBm.bmHeight, SRCCOPY);
                    DeleteDC(hdcOld);
                }
                
                DeleteObject(hbmOld);
            }
        }
        
        RegCloseKey(hKey);
    }
    
    return(S_OK);
}
    
    
void CCoolbar::DrawBranding(LPDRAWITEMSTRUCT lpdis)
{
    HPALETTE hpalPrev;
    int     x, y, cx, cy;
    int     yOrg = 0;
    
    if (IsFlagSet(CBSTATE_ANIMATING))
        yOrg = m_yOrg;
    
    if (IsFlagSet(CBSTATE_FIRSTFRAME))
    {
        REBARBANDINFO rbbi;
        int cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
        
        ZeroMemory(&rbbi, sizeof(rbbi));
        rbbi.cbSize = sizeof(REBARBANDINFO);
        rbbi.fMask = RBBIM_ID;
        
        for (int i = 0; i < cBands; i++)
        {
            SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
            
            if (CBTYPE_BRAND == rbbi.wID)
            {
                rbbi.fMask = RBBIM_COLORS;
                rbbi.clrFore = m_rgbUpperLeft;
                rbbi.clrBack = m_rgbUpperLeft;
                
                SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM) &rbbi);
                break;
            }
        }
        
        ClearFlag(CBSTATE_FIRSTFRAME);
    }
    
    if (m_hpal)
    {
        hpalPrev = SelectPalette(lpdis->hDC, m_hpal, TRUE);
        RealizePalette(lpdis->hDC);
    }
    
    x  = lpdis->rcItem.left;
    cx = lpdis->rcItem.right - x;
    y  = lpdis->rcItem.top;
    cy = lpdis->rcItem.bottom - y;
    
    if (m_cxBrand > m_cxBrandExtent)
    {
        HBRUSH  hbrBack = CreateSolidBrush(m_rgbUpperLeft);
        int     xRight = lpdis->rcItem.right;
        
        x += (m_cxBrand - m_cxBrandExtent) / 2;
        cx = m_cxBrandExtent;
        lpdis->rcItem.right = x;
        FillRect(lpdis->hDC, &lpdis->rcItem, hbrBack);
        lpdis->rcItem.right = xRight;
        lpdis->rcItem.left = x + cx;
        FillRect(lpdis->hDC, &lpdis->rcItem, hbrBack);
        
        DeleteObject(hbrBack);
    }
    
    BitBlt(lpdis->hDC, x, y, cx, cy, m_hdc, 0, yOrg, SRCCOPY);
    
    if (m_hpal)
    {
        SelectPalette(lpdis->hDC, hpalPrev, TRUE);
        RealizePalette(lpdis->hDC);
    }
}
    

BOOL CCoolbar::SetMinDimensions(void)
{
    REBARBANDINFO rbbi;
    LRESULT       lButtonSize;
    int           i, cBands;
    
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    
    for (i = 0; i < cBands; i++)
    {
        rbbi.fMask = RBBIM_ID;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        
        switch (rbbi.wID)
        {
        case CBTYPE_BRAND:
            rbbi.cxMinChild = m_cxBrand;
            rbbi.cyMinChild = m_cyBrand;
            break;
            
        case CBTYPE_TOOLS:
        case CBTYPE_MENUBAND:
            lButtonSize = SendMessage(m_hwndTools, TB_GETBUTTONSIZE, 0, 0L);
            rbbi.cxMinChild = VERTICAL(m_csSide) ? HIWORD(lButtonSize) : LOWORD(lButtonSize);
            rbbi.cyMinChild = VERTICAL(m_csSide) ? LOWORD(lButtonSize) : HIWORD(lButtonSize);
            break;
            
        }
        
        rbbi.fMask = RBBIM_CHILDSIZE;
        SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM)&rbbi);
    }
    return TRUE;
}


BOOL CCoolbar::CompressBands(BOOL fCompress)
{
    LRESULT         lTBStyle = 0;
    int             i, cBands;
    REBARBANDINFO   rbbi;
    
    if (!!fCompress == IsFlagSet(CBSTATE_COMPRESSED))
        // no change -- return immediately
        return(FALSE);
    
    if (fCompress)
        SetFlag(CBSTATE_COMPRESSED);
    else
        ClearFlag(CBSTATE_COMPRESSED);    
    
    m_yOrg = 0;
    LoadBrandingBitmap();
    
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    for (i = 0; i < cBands; i++)
    {
        rbbi.fMask = RBBIM_ID;
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        
        if (fCompress)
        {
            switch (rbbi.wID)
            {
            case CBTYPE_TOOLS:
                SendMessage(m_hwndTools, TB_SETMAXTEXTROWS, 0, 0L);
                SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0,MAX_TB_COMPRESSED_WIDTH));
                break;
            }            
        }        
        else
        {
            switch (rbbi.wID)
            {
            case CBTYPE_TOOLS:
                SendMessage(m_hwndTools, TB_SETMAXTEXTROWS, 
                    VERTICAL(m_csSide) ? MAX_TB_TEXT_ROWS_VERT : MAX_TB_TEXT_ROWS_HORZ, 0L);
                SendMessage(m_hwndTools, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, m_cxMaxButtonWidth));
                break;
            }
        }
    }
    
    SetMinDimensions();
    
    return(TRUE);
}

    
void CCoolbar::TrackSlidingX(int x)
{
    int           cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0L);
    int           cRows  = SendMessage(m_hwndRebar, RB_GETROWCOUNT, 0, 0L);
    int           cxRow  = SendMessage(m_hwndRebar, RB_GETROWHEIGHT, cBands - 1, 0L);  // This should work correctly if vertical
    REBARBANDINFO rbbi;
    RECT          rc;
    int           cxBefore;
    BOOL          fChanged = FALSE;
    
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_STYLE;
    
    GetWindowRect(m_hwndRebar, &rc);
    cxBefore = rc.right - rc.left;
    
    if (((m_csSide == COOLBAR_LEFT) && (x < (m_xCapture - (cxRow / 2)))) ||
        ((m_csSide == COOLBAR_RIGHT) && (x > (m_xCapture + (cxRow / 2)))))
    {        
        if (cRows == 1)
            fChanged = CompressBands(TRUE);
        /*
        else
        {
            while (0 > --cBands)
            {
                SendMessage(m_hwndRebar, RB_GETBANDINFO, cBands, (LPARAM) &rbbi);
                if (fChanged = (rbbi.fStyle & RBBS_BREAK))
                {
                    rbbi.fStyle &= ~RBBS_BREAK;
                    SendMessage(m_hwndRebar, RB_SETBANDINFO, cBands, (LPARAM) &rbbi);
                    break;
                }
            }
        }
        */
    }
    else if (((m_csSide == COOLBAR_LEFT) && (x > (m_xCapture + (cxRow / 2)))) ||
        ((m_csSide == COOLBAR_RIGHT) && (x < (m_xCapture - (cxRow / 2)))))
    {
        /*
        if (!(fChanged = CompressBands(FALSE)) && (cRows < (cBands - 1)))
        {
            while (0 > --cBands)
            {
                SendMessage(m_hwndRebar, RB_GETBANDINFO, cBands, (LPARAM) &rbbi);
                if (fChanged = !(rbbi.fStyle & (RBBS_BREAK | RBBS_FIXEDSIZE)))
                {
                    rbbi.fStyle |= RBBS_BREAK;
                    SendMessage(m_hwndRebar, RB_SETBANDINFO, cBands, (LPARAM) &rbbi);
                    break;
                }
            }
        }
        */
    }
    
    // TODO: There is a drawing glitch when you resize from 3 bars (No Text) to 3 bars
    // with text. The _yCapture gets set to a value greater than y. So on the
    // next MOUSEMOVE it figures that the user moved up and switches from 3 bars with text
    // to 2 bars with text.
    if (fChanged)
    {
        GetWindowRect(m_hwndRebar, &rc);
        m_xCapture += (rc.right - rc.left) - cxBefore;
    }
}


void CCoolbar::TrackSlidingY(int y)
{
    int           cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0L);
    int           cRows  = SendMessage(m_hwndRebar, RB_GETROWCOUNT, 0, 0L);
    int           cyRow  = SendMessage(m_hwndRebar, RB_GETROWHEIGHT, cBands - 1, 0L);
    REBARBANDINFO rbbi;
    RECT          rc;
    int           cyBefore;
    BOOL          fChanged = FALSE;
    
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_STYLE;
    
    GetWindowRect(m_hwndRebar, &rc);
    cyBefore = rc.bottom - rc.top;
    
    if (((m_csSide == COOLBAR_TOP) && (y < (m_yCapture - (cyRow / 2)))) ||
        ((m_csSide == COOLBAR_BOTTOM) && (y > (m_yCapture + (cyRow / 2)))))
    {
        if (cRows == 1)
            fChanged = CompressBands(TRUE);
        /*
        else
        {
            while (0 > --cBands)
            {
                SendMessage(m_hwndRebar, RB_GETBANDINFO, cBands, (LPARAM) &rbbi);
                if (fChanged = (rbbi.fStyle & RBBS_BREAK))
                {
                    rbbi.fStyle &= ~RBBS_BREAK;
                    SendMessage(m_hwndRebar, RB_SETBANDINFO, cBands, (LPARAM) &rbbi);
                    break;
                }
            }
        }
        */
    }
    else if (((m_csSide == COOLBAR_TOP) && (y > (m_yCapture + (cyRow / 2)))) ||
        ((m_csSide == COOLBAR_BOTTOM) && (y < (m_yCapture - (cyRow / 2)))))
    {
        /*
        if (!(fChanged = CompressBands(FALSE)) && (cRows < (cBands - 1)))
        {
            while (0 > --cBands)
            {
                SendMessage(m_hwndRebar, RB_GETBANDINFO, cBands, (LPARAM) &rbbi);
                if (fChanged = !(rbbi.fStyle & (RBBS_BREAK | RBBS_FIXEDSIZE)))
                {
                    rbbi.fStyle |= RBBS_BREAK;
                    SendMessage(m_hwndRebar, RB_SETBANDINFO, cBands, (LPARAM) &rbbi);
                    break;
                }
            }
        }
        */
    }
    
    // TODO: There is a drawing glitch when you resize from 3 bars (No Text) to 3 bars
    // with text. The _yCapture gets set to a value greater than y. So on the
    // next MOUSEMOVE it figures that the user moved up and switches from 3 bars with text
    // to 2 bars with text.
    if (fChanged)
    {
        GetWindowRect(m_hwndRebar, &rc);
        m_yCapture += (rc.bottom - rc.top) - cyBefore;
    }
}


// Flips the rebar from being horizontal to to vertical or the other way.
BOOL CCoolbar::ChangeOrientation()
{
    LONG lStyle, lTBStyle;
    
    lTBStyle = SendMessage(m_hwndTools, TB_GETSTYLE, 0, 0L);
    lStyle = GetWindowLong(m_hwndRebar, GWL_STYLE);
    SendMessage(m_hwndTools, WM_SETREDRAW, 0, 0L);
    
    if (VERTICAL(m_csSide))
    {
        // Moving to Vertical
        lStyle |= CCS_VERT;
        lTBStyle |= TBSTYLE_WRAPABLE;
    }
    else
    {
        // Moving to Horizontal
        lStyle &= ~CCS_VERT;
        lTBStyle &= ~TBSTYLE_WRAPABLE;        
    }
    
    SendMessage(m_hwndTools, TB_SETSTYLE, 0, lTBStyle);
    SendMessage(m_hwndTools, WM_SETREDRAW, 1, 0L);
    SetWindowLong(m_hwndRebar, GWL_STYLE, lStyle);
    
    SetMinDimensions();
    ResizeBorderDW(NULL, NULL, FALSE);
    return TRUE;
}

    
//
//  FUNCTION:   CCoolbar::CreateRebar(BOOL fVisible)
//
//  PURPOSE:    Creates a new rebar and sizer window.
//
//  RETURN VALUE:
//      Returns S_OK if the bar was created and inserted correctly, 
//      hrAlreadyExists if a band already is in that position, 
//      E_OUTOFMEMORY if a window couldn't be created.
//
HRESULT CCoolbar::CreateRebar(BOOL fVisible)
{
    if (m_hwndSizer)
        return (hrAlreadyExists);
    
    // $TODO: Only give the bar with the address bar the WS_TABSTOP style.
    m_hwndSizer = CreateWindowEx(0, SIZABLECLASS, NULL, WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | (fVisible ? WS_VISIBLE : 0),
        0, 0, 100, 36, m_hwndParent, (HMENU) 0, g_hInst, NULL);
    if (m_hwndSizer)
    {
        DOUTL(4, TEXT("Calling SetProp. AddRefing new m_cRef=%d"), m_cRef + 1);
        AddRef();  // Note we Release in WM_DESTROY
        SetProp(m_hwndSizer, TEXT("CCoolbar"), this);

        /*
        m_hwndRebar = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
            RBS_FIXEDORDER | RBS_VARHEIGHT | RBS_BANDBORDERS | WS_VISIBLE |
            WS_BORDER | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | 
            CCS_NODIVIDER | CCS_NOPARENTALIGN | (VERTICAL(m_csSide) ? CCS_VERT : 0),
            0, 0, 100, 136, m_hwndSizer, (HMENU) idcCoolbar, g_hInst, NULL);
        */
        m_hwndRebar = CreateWindowEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
                           RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_REGISTERDROP | RBS_DBLCLKTOGGLE |
                           WS_VISIBLE | WS_BORDER | WS_CHILD | WS_CLIPCHILDREN |
                           WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                           (VERTICAL(m_csSide) ? CCS_VERT : 0),
                            0, 0, 100, 136, m_hwndSizer, (HMENU) idcCoolbar, g_hInst, NULL);
        if (m_hwndRebar)
        { 
            SendMessage(m_hwndRebar, RB_SETTEXTCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNTEXT));
            SendMessage(m_hwndRebar, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));
            //SendMessage(m_hwndRebar, RB_SETEXTENDEDSTYLE, RBS_EX_OFFICE9, RBS_EX_OFFICE9);

            return (S_OK);
        }
    }
    
    DestroyWindow(m_hwndSizer);    
    return (E_OUTOFMEMORY);    
}

void SendSaveRestoreMessage(HWND hwnd, const TOOLBARARRAYINFO *ptai, BOOL fSave)
{
    TBSAVEPARAMS tbsp;
    char szSubKey[MAX_PATH], sz[MAX_PATH];
    DWORD dwType;
    DWORD dwVersion;
    DWORD cbData = sizeof(DWORD);
    DWORD dwError;
    
    tbsp.hkr = AthUserGetKeyRoot();
    AthUserGetKeyPath(sz, ARRAYSIZE(sz));
    if (ptai->pszRegKey != NULL)
    {
        wsprintf(szSubKey, c_szPathFileFmt, sz, ptai->pszRegKey);
        tbsp.pszSubKey = szSubKey;
    }
    else
    {
        tbsp.pszSubKey = sz;
    }
    tbsp.pszValueName = ptai->pszRegValue;

    // First check to see if the version has changed
    if (!fSave)
    {
        if (ERROR_SUCCESS == AthUserGetValue(ptai->pszRegKey, c_szRegToolbarVersion, &dwType, (LPBYTE) &dwVersion, &cbData))
        {
            if (dwVersion == COOLBAR_VERSION)    
                SendMessage(hwnd, TB_SAVERESTORE, (WPARAM)fSave, (LPARAM)&tbsp);
        }
    }
    else
    {
        dwVersion = COOLBAR_VERSION;
        SendMessage(hwnd, TB_SAVERESTORE, (WPARAM)fSave, (LPARAM)&tbsp);
        dwError = AthUserSetValue(ptai->pszRegKey, c_szRegToolbarVersion, REG_DWORD, (LPBYTE) &dwVersion, cbData);
    }
}

//
//  FUNCTION:   CCoolbar::SaveSettings()
//
//  PURPOSE:    Called when we should save our state out to the specified reg
//              key.
//
void CCoolbar::SaveSettings(void)
{
    char            szSubKey[MAX_PATH], sz[MAX_PATH];
    DWORD           iBand;
    REBARBANDINFO   rbbi;
    HKEY            hKey;
    DWORD           cBands;

    // If we don't have the window, there is nothing to save.
    if (!m_hwndRebar || !m_ptai)
        return;
    
    ZeroMemory(&rbbi, sizeof(REBARBANDINFO));
    
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);

    // Collect the bar-specific information
    m_cbsSavedInfo.dwVersion = COOLBAR_VERSION;
    m_cbsSavedInfo.dwState   = m_dwState;
    m_cbsSavedInfo.csSide    = m_csSide;
    
    // Loop through the bands and save their information as well
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_STYLE | RBBIM_CHILD | RBBIM_SIZE | RBBIM_ID;
    
    for (iBand = 0; iBand < cBands; iBand++)
    {
        Assert(IsWindow(m_hwndRebar));
        if (SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi))
        {
            // Save the information that we care about with this band
            m_cbsSavedInfo.bs[iBand].cx      = rbbi.cx;
            m_cbsSavedInfo.bs[iBand].dwStyle = rbbi.fStyle;
            m_cbsSavedInfo.bs[iBand].wID     = rbbi.wID;
            
            // If this band has a toolbar, then we should instruct the toolbar
            // to save it's information now
            if (m_cbsSavedInfo.bs[iBand].wID == CBTYPE_TOOLS)
            {
                SendSaveRestoreMessage(rbbi.hwndChild, m_ptai, TRUE);
            }
        }
        else
        {
            // Default Values
            m_cbsSavedInfo.bs[iBand].wID = CBTYPE_NONE;
            m_cbsSavedInfo.bs[iBand].dwStyle = 0;
            m_cbsSavedInfo.bs[iBand].cx = 0;
        }
    }
    
    // We have all the information collected, now save that to the specified
    // registry location
    AthUserSetValue(NULL, c_szRegCoolbarLayout, REG_BINARY, (const LPBYTE)&m_cbsSavedInfo, sizeof(COOLBARSAVE)); 
}

    
//
//  FUNCTION:   CCoolbar::AddTools()
//
//  PURPOSE:    Inserts the primary toolbar into the coolbar.
//
//  PARAMETERS:
//      pbs - Pointer to a PBANDSAVE struct with the styles and size of the
//            band to insert.
//
//  RETURN VALUE:
//      Returns an HRESULT signifying success or failure.
//
HRESULT CCoolbar::AddTools(PBANDSAVE pbs)
{    
    REBARBANDINFO   rbbi;
    
    // add tools band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_ID | RBBIM_STYLE;
    rbbi.fStyle     = pbs->dwStyle;
    rbbi.cx         = pbs->cx;
//    rbbi.wID        = CBTYPE_TOOLS;
    rbbi.wID        = pbs->wID;
    
    if (IsFlagClear(CBSTATE_NOBACKGROUND) && !m_hbmBack && m_idbBack)
        m_hbmBack = (HBITMAP) LoadImage(g_hLocRes, MAKEINTRESOURCE(m_idbBack), 
        IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);
    
    if (m_hbmBack)
    {
        rbbi.fMask  |= RBBIM_BACKGROUND;
        rbbi.fStyle |= RBBS_FIXEDBMP;
        rbbi.hbmBack = m_hbmBack;
    }
    else
    {
        rbbi.fMask |= RBBIM_COLORS;
        rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
        rbbi.clrBack = GetSysColor(COLOR_BTNFACE);
    }
    
    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT) -1, (LPARAM) (LPREBARBANDINFO) &rbbi);
    
    return(S_OK);
}


HRESULT CCoolbar::SetFolderType(FOLDERTYPE ftType)
{
    TCHAR         szToolsText[(MAX_TB_TEXT_LENGTH+2) * MAX_TB_BUTTONS];
    int           i, cBands;
    REBARBANDINFO rbbi;
    HWND          hwndDestroy = NULL;
    
    // If we haven't created the rebar yet, this will fail.  Call ShowDW() first.
    if (!IsWindow(m_hwndRebar))
        return (E_FAIL);
    
    // Check to see if this would actually be a change
    if (ftType == m_ftType)
        return (S_OK);
    
    // First find the band with the toolbar
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_TOOLS == rbbi.wID)
            break;
    }
    
    // We didn't find it.
    if (i >= cBands)
        return (E_FAIL);
    
    // Destroy the old toolbar if it exists
    if (IsWindow(m_hwndTools))
    {
        // Save it's button configuration
        SendSaveRestoreMessage(m_hwndTools, m_ptai, TRUE);
        
        SendMessage(m_hwndTools, TB_SETIMAGELIST, 0, NULL);
        SendMessage(m_hwndTools, TB_SETHOTIMAGELIST, 0, NULL);
        hwndDestroy = m_hwndTools;
    }
    
    // Update our internal state information with the new folder type
    Assert(ftType < FOLDER_TYPESMAX);
    m_ftType = ftType;
    m_ptai = &(g_rgToolbarArrayInfo[m_ftType]);
    
    // Create a new toolbar
    m_hwndTools = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
        WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS 
        | WS_CLIPCHILDREN | WS_CLIPSIBLINGS 
        | CCS_NODIVIDER | CCS_NOPARENTALIGN 
        | CCS_ADJUSTABLE | CCS_NORESIZE | 
        (VERTICAL(m_csSide) ? TBSTYLE_WRAPABLE : 0),
        0, 0, 0, 0, m_hwndRebar, (HMENU) idcToolbar, 
        g_hInst, NULL);
    
    Assert(m_hwndTools);
    if (!m_hwndTools)
    {
        DOUTL(1, TEXT("CCoolbar::SetFolderType() CreateWindow(TOOLBAR) failed"));
        return(E_OUTOFMEMORY);
    }
    
    InitToolbar();
    
    // If we have previously save configuration info for this toolbar, load it 
    SendSaveRestoreMessage(m_hwndTools, m_ptai, FALSE);
    
    // First find the band with the toolbar
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_TOOLS == rbbi.wID)
            break;
    }
    
    
    // Add the toolbar to the rebar
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_CHILD;
    rbbi.hwndChild = m_hwndTools;
    
    SendMessage(m_hwndRebar, RB_SETBANDINFO, (UINT) i, (LPARAM) (LPREBARBANDINFO) &rbbi);
    if (hwndDestroy)
        DestroyWindow(hwndDestroy);
    SetMinDimensions();
    ResizeBorderDW(NULL, NULL, FALSE);
    
    return (S_OK);
}

void CCoolbar::SetSide(COOLBAR_SIDE csSide)
{
    m_csSide = csSide;
    ChangeOrientation();
}

void CCoolbar::SetText(BOOL fText)
{
    CompressBands(!fText);
}


UINT GetCurColorRes(void)
{
    HDC hdc;
    UINT uColorRes;
    
    hdc = GetDC(NULL);
    uColorRes = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);
    
    return uColorRes;
}

/*  InitToolbar:
**
**  Purpose:
**      makes decisions about small/large bitmaps and which
**      imagelist given the colordepth, then calls the
**      barutil InitToolbar
*/
void CCoolbar::InitToolbar()
{
    TCHAR   szToolsText[(MAX_TB_TEXT_LENGTH+2) * MAX_TB_BUTTONS];
    HKEY    hKey;
    TCHAR   szValue[32];
    DWORD   cbValue = sizeof(szValue);
    int     idBmp;
    
    // Check to see if the user has decided to use that crazy 16x16 images
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegSmallIconsPath,
        0, KEY_READ, &hKey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_szRegSmallIconsValue, 0,
            0, (LPBYTE) szValue, &cbValue))
        {
            // people in IE decided it would be cool to store a boolean
            // value as REG_SZ "Yes" and "No".  Lovely.
            m_fSmallIcons = !lstrcmpi(szValue, c_szYes);
        }
        RegCloseKey(hKey);
    }
    
    if (m_fSmallIcons)
    {
        idBmp = (fIsWhistler() ? ((GetCurColorRes() > 24) ? idb32SmBrowser : idbSmBrowser): idbNWSmBrowser);
    }
    
    // Check to see what our color depth is
    else if (GetCurColorRes() > 24)
    {
        idBmp = (fIsWhistler() ? idb32256Browser : idbNW256Browser);
    }
    else if (GetCurColorRes() > 8)
    {
        idBmp = (fIsWhistler() ? idb256Browser : idbNW256Browser);
    }
    else
    {
        idBmp = (fIsWhistler() ? idbBrowser : idbNWBrowser);
    }
    
    LoadToolNames((UINT*) m_ptai->rgidsButtons, m_ptai->cidsButtons, szToolsText);
    SendMessage(m_hwndTools, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_DRAWDDARROWS);
    
    ::InitToolbar(m_hwndTools, CIMLISTS, m_rghimlTools, m_ptai->cDefButtons, 
        m_ptai->rgDefButtons, szToolsText,
        m_fSmallIcons ? TB_SMBMP_CX : (fIsWhistler() ? TB_BMP_CX : TB_BMP_CX_W2K),
        m_fSmallIcons ? TB_SMBMP_CY : TB_BMP_CY,
        IsFlagSet(CBSTATE_COMPRESSED) ? MAX_TB_COMPRESSED_WIDTH : m_cxMaxButtonWidth,
        idBmp,
        IsFlagSet(CBSTATE_COMPRESSED), VERTICAL(m_csSide));
    
    //Register with the connection manager
    if (g_pConMan)
    {
        //If Work offline is set then we should check the work offline button
        SendMessage(m_hwndTools, TB_CHECKBUTTON, ID_WORK_OFFLINE, (LPARAM)(MAKELONG(g_pConMan->IsGlobalOffline(), 0)));
    }
}


void CCoolbar::UpdateToolbarColors(void)
{
    REBARBANDINFO   rbbi;
    UINT            i;
    UINT            cBands;
    
    // First find the band with the toolbar
    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask  = RBBIM_ID;
    
    for (i = 0; i < cBands; i++)
    {
        SendMessage(m_hwndRebar, RB_GETBANDINFO, i, (LPARAM) &rbbi);
        if (CBTYPE_TOOLS == rbbi.wID)
            break;
    }
    
    // add tools band
    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize  = sizeof(REBARBANDINFO);
    rbbi.fMask   = RBBIM_COLORS;
    rbbi.clrFore = GetSysColor(COLOR_BTNTEXT);
    rbbi.clrBack = GetSysColor(COLOR_BTNFACE);
    
    SendMessage(m_hwndRebar, RB_SETBANDINFO, i, (LPARAM) (LPREBARBANDINFO) &rbbi);
}


HRESULT CCoolbar::OnConnectionNotify(CONNNOTIFY nCode, 
    LPVOID                 pvData,
    CConnectionManager     *pConMan)
{
    if ((m_hwndTools) && (nCode == CONNNOTIFY_WORKOFFLINE))
    {
        SendMessage(m_hwndTools, TB_CHECKBUTTON, ID_WORK_OFFLINE, (LPARAM)MAKELONG((BOOL)pvData, 0));
    }
    return S_OK;
}


//
//  FUNCTION:   InitToolbar()
//
//  PURPOSE:    Given all the parameters needed to configure a toolbar,
//              this function loads the image lists and configures the
//              toolbar.
//
//  PARAMETERS:
//      hwnd     - Handle of the toolbar window to init.
//      phiml    - Array of imagelists where the hot, disabled, and normal 
//                 buttons are returned.
//      nBtns    - The number of buttons in the ptbb array.
//      ptbb     - Array of buttons to add to the toolbar.
//      pStrings - List of toolbar button / tooltip strings to add.
//      cx, cy   - Size of the bitmaps being added to the toolbar.
//      cxMax    - Maximum button width.
//      idBmp    - Resource id of the first image list to load.
//

void InitToolbar(const HWND hwnd, const int cHiml, HIMAGELIST *phiml,
    UINT nBtns, const TBBUTTON *ptbb,
    const TCHAR *pStrings,
    const int cxImg, const int cyImg, const int cxMax,
    const int idBmp, const BOOL fCompressed,
    const BOOL fVertical)
{
    int nRows;
    
    if (fCompressed)
        nRows = 0;
    else
        nRows = fVertical ? MAX_TB_TEXT_ROWS_VERT : MAX_TB_TEXT_ROWS_HORZ;
    
    LoadGlyphs(hwnd, cHiml, phiml, cxImg, idBmp);
    
    // this tells the toolbar what version we are
    SendMessage(hwnd, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);
    
    SendMessage(hwnd, TB_SETMAXTEXTROWS,      nRows, 0L);
    SendMessage(hwnd, TB_SETBITMAPSIZE,       0, MAKELONG(cxImg, cyImg));
    SendMessage(hwnd, TB_SETBUTTONWIDTH,      0, MAKELONG(0, cxMax));
    if (pStrings)   SendMessage(hwnd, TB_ADDSTRING,  0, (LPARAM) pStrings);
    if (nBtns)      SendMessage(hwnd, TB_ADDBUTTONS, nBtns, (LPARAM) ptbb);
}


void LoadGlyphs(const HWND  hwnd, const int   cHiml, HIMAGELIST *phiml, const int   cx,
    const int   idBmp)
{
    const UINT  uFlags = LR_LOADMAP3DCOLORS | LR_CREATEDIBSECTION;
    HIMAGELIST  LocHiml[CIMLISTS];

    if (phiml == NULL)
    {
        phiml = LocHiml;
    }

    for (int i = 0; i < cHiml; i++)
    {
        if (phiml[i])
            ImageList_Destroy(phiml[i]);
        phiml[i] = ImageList_LoadImage(g_hLocRes,
            MAKEINTRESOURCE(idBmp + i), cx, 0, RGB(255, 0, 255),
            IMAGE_BITMAP, uFlags);
        
    }
    
    SendMessage(hwnd, TB_SETIMAGELIST, 0, (LPARAM) phiml[IMLIST_DEFAULT]);
    
    // if we weren't given a full set of lists to do, then don't set this
    if (CIMLISTS == cHiml)
    {
        SendMessage(hwnd, TB_SETHOTIMAGELIST, 0, (LPARAM) phiml[IMLIST_HOT]);
    }
}


BOOL LoadToolNames(const UINT *rgIds, const UINT cIds, TCHAR *szTools)
{
    for (UINT i = 0; i < cIds; i++)
    {
        LoadString(g_hLocRes, rgIds[i], szTools, MAX_TB_TEXT_LENGTH);
        szTools += lstrlen(szTools) + 1;
    }
    
    *szTools = TEXT('\0');
    return(TRUE);
}


HRESULT CCoolbar::Update(void)
{
    DWORD               cButtons = 0;
    OLECMD             *rgCmds;
    TBBUTTON            tb;
    DWORD               cCmds = 0;
    IOleCommandTarget  *pTarget = NULL;
    DWORD               i;
    DWORD               dwState;
    
    // Get the number of buttons on the toolbar
    cButtons = SendMessage(m_hwndTools, TB_BUTTONCOUNT, 0, 0);
    if (0 == cButtons) 
        return (S_OK);
    
    // Allocate an array of OLECMD structures for the buttons
    if (!MemAlloc((LPVOID *) &rgCmds, sizeof(OLECMD) * cButtons))
        return (E_OUTOFMEMORY);
    
    // Loop through the buttons and get the ID for each
    for (i = 0; i < cButtons; i++)
    {
        if (SendMessage(m_hwndTools, TB_GETBUTTON, i, (LPARAM) &tb))
        {
            // Toolbar returns zero for seperators
            if (tb.idCommand)
            {
                rgCmds[cCmds].cmdID = tb.idCommand;
                rgCmds[cCmds].cmdf  = 0;
                cCmds++;
            }
        }
    }
    
    // I don't see how this can be false
    Assert(m_ptbSite);
    
    // Do the QueryStatus thing    
    if (SUCCEEDED(m_ptbSite->QueryInterface(IID_IOleCommandTarget, (void**) &pTarget)))
    {
        if (SUCCEEDED(pTarget->QueryStatus(NULL, cCmds, rgCmds, NULL)))
        {
            // Go through the array now and do the enable / disable thing
            for (i = 0; i < cCmds; i++)
            {
                // Get the current state of the button
                dwState = SendMessage(m_hwndTools, TB_GETSTATE, rgCmds[i].cmdID, 0);
                
                // Update the state with the feedback we've been provided
                if (rgCmds[i].cmdf & OLECMDF_ENABLED)
                    dwState |= TBSTATE_ENABLED;
                else
                    dwState &= ~TBSTATE_ENABLED;
                
                if (rgCmds[i].cmdf & OLECMDF_LATCHED)
                    dwState |= TBSTATE_CHECKED;
                else
                    dwState &= ~TBSTATE_CHECKED;
                
                // Radio check has no meaning here.
                Assert(0 == (rgCmds[i].cmdf & OLECMDF_NINCHED));
                
                SendMessage(m_hwndTools, TB_SETSTATE, rgCmds[i].cmdID, dwState);

                // If this is the work offline button, we need to do a bit more work
                if (rgCmds[i].cmdID == ID_WORK_OFFLINE)
                {
                    _UpdateWorkOffline(rgCmds[i].cmdf);
                }
            }
        }
        
        pTarget->Release();
    }
    
    MemFree(rgCmds);
    
    return (S_OK);
}

void CCoolbar::_UpdateWorkOffline(DWORD cmdf)
{
    TBBUTTONINFO tbbi = { 0 };
    TCHAR        szRes[CCHMAX_STRINGRES];
    int          idString;

    // Because we change the text and image for the "Work Offline" button,
    // we need to do some work here based on whether or not the button is
    // checked or not.

    if (cmdf & OLECMDF_LATCHED)
    {
        idString    = idsWorkOnline;
        tbbi.iImage = iCBWorkOnline;
    }
    else
    {
        idString    = idsWorkOffline;
        tbbi.iImage = iCBWorkOffline;
    }

    // Load the new string
    AthLoadString(idString, szRes, ARRAYSIZE(szRes));

    // Fill in the struct
    tbbi.cbSize  = sizeof(TBBUTTONINFO);
    tbbi.dwMask  = TBIF_IMAGE | TBIF_TEXT;
    tbbi.pszText = szRes;

    // Update the button
    SendMessage(m_hwndTools, TB_SETBUTTONINFO, ID_WORK_OFFLINE, (LPARAM) &tbbi);
}

HRESULT CCoolbar::CreateMenuBand(PBANDSAVE pbs)
{
    HRESULT     hres;
    HWND        hwndBrowser;
    HMENU       hMenu;
    IShellMenu  *pShellMenu;

    //Get the hwnd for the browser
    if (g_pBrowser)
    {
        hres = g_pBrowser->GetWindow(&hwndBrowser);
        if (hres != S_OK)
            return hres;
    }

    //hMenu = ::GetMenu(hwndBrowser);
    
    //Cocreate menuband
    hres = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_IShellMenu, (LPVOID*)&m_pShellMenu);
    if (hres != S_OK)
    {
        return hres;
    }

    /*
    m_mbCallback = new CMenuCallback;
    if (m_mbCallback == NULL)
    {
        hres = S_FALSE;
        return hres;
    }
    */
    
    m_pShellMenu->Initialize(m_mbCallback, -1, ANCESTORDEFAULT, SMINIT_DEFAULTTOTRACKPOPUP | SMINIT_HORIZONTAL | 
        /*SMINIT_USEMESSAGEFILTER|*/  SMINIT_TOPLEVEL);

    m_pShellMenu->SetMenu(m_hMenu, hwndBrowser, SMSET_DONTOWN);

    hres = AddMenuBand(pbs);

    return hres;
}

HRESULT CCoolbar::AddMenuBand(PBANDSAVE pbs)
{
    REBARBANDINFO   rbbi;
    HRESULT         hres;
    HWND            hwndMenuBand = NULL;
    IObjectWithSite *pObj;

    hres = m_pShellMenu->QueryInterface(IID_IDeskBand, (LPVOID*)&m_pDeskBand);
    if (FAILED(hres))
        return hres;

    hres = m_pShellMenu->QueryInterface(IID_IMenuBand, (LPVOID*)&m_pMenuBand);
    if (FAILED(hres))
        return hres;

    hres = m_pDeskBand->QueryInterface(IID_IWinEventHandler, (LPVOID*)&m_pWinEvent);
    if (FAILED(hres))
        return hres;

    hres = m_pDeskBand->QueryInterface(IID_IObjectWithSite, (LPVOID*)&pObj);
    if (FAILED(hres))
        return hres;

    pObj->SetSite((IDockingWindow*)this);
    pObj->Release();

    m_pDeskBand->GetWindow(&m_hwndMenuBand);

    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_ID | RBBIM_STYLE | RBBIM_CHILD;
    rbbi.fStyle     = pbs->dwStyle;
    rbbi.cx         = pbs->cx;
    rbbi.wID        = pbs->wID;
    rbbi.hwndChild  = m_hwndMenuBand;
    
    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)(LPREBARBANDINFO)&rbbi);

    HWND hwndBrowser;
    if (g_pBrowser)
    {
        hres = g_pBrowser->GetWindow(&hwndBrowser);
        if (hres != S_OK)
            return hres;
    }

    SetForegroundWindow(hwndBrowser);

    /*
    IInputObject* pio;
    if (SUCCEEDED(m_pDeskBand->QueryInterface(IID_IInputObject, (void**)&pio)))
    {
        pio->UIActivateIO(TRUE, NULL);
        pio->Release();
    }
    */
    m_pDeskBand->ShowDW(TRUE);

    SetNotRealSite();
    
    //Get Bandinfo and set 

    return S_OK;
}

HRESULT CCoolbar::TranslateMenuMessage(MSG  *pmsg, LRESULT  *lpresult)
{
    if (m_pMenuBand)
        return m_pMenuBand->TranslateMenuMessage(pmsg, lpresult);
    else
        return S_FALSE;
}

HRESULT CCoolbar::IsMenuMessage(MSG *lpmsg)
{
    if (m_pMenuBand)
        return m_pMenuBand->IsMenuMessage(lpmsg);
    else
        return S_FALSE;
}

void CCoolbar::SetNotRealSite()
{
    IOleCommandTarget   *pOleCmd;

    if (m_pDeskBand->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&pOleCmd) == S_OK)
    {
        //pOleCmd->Exec(&CGID_MenuBand, MBANDCID_NOTAREALSITE, TRUE, NULL, NULL);
        pOleCmd->Exec(&CLSID_MenuBand, 3, TRUE, NULL, NULL);
        pOleCmd->Release();
    }
}

void CCoolbar::HandleCoolbarPopup(UINT xPos, UINT yPos)
{
    // Load the context menu
    HMENU hMenu = LoadPopupMenu(IDR_COOLBAR_POPUP);
    if (!hMenu)
        return;

    // Loop through the bands and see which ones are visible
    DWORD cBands, iBand;
    REBARBANDINFO rbbi = {0};

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_STYLE | RBBIM_ID;

    cBands = SendMessage(m_hwndRebar, RB_GETBANDCOUNT, 0, 0);
    for (iBand = 0; iBand < cBands; iBand++)
    {
        if (SendMessage(m_hwndRebar, RB_GETBANDINFO, iBand, (LPARAM) &rbbi))
        {
            if (!(rbbi.fStyle & RBBS_HIDDEN))
            {
                switch (rbbi.wID)
                {
                    case CBTYPE_TOOLS:
                        CheckMenuItem(hMenu, ID_COOLTOOLBAR, MF_BYCOMMAND | MF_CHECKED);
                        break;
                }
            }
        }
    }

    SetFlag(CBSTATE_INMENULOOP);
    DWORD cmd;
    cmd = TrackPopupMenuEx(hMenu, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                           xPos, yPos, m_hwndSizer, NULL);

    if (cmd != 0)
    {
        switch (cmd)
        {
            case ID_COOLTOOLBAR:
                HideToolbar(CBTYPE_TOOLS);
                break;

       }
    }

    ClearFlag(CBSTATE_INMENULOOP);

    if (hMenu)
        DestroyMenu(hMenu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\ipab.cpp ===
// ===========================================================================
// I P A B . C P P
// ===========================================================================
#include "pch.hxx"
#include "ipab.h"
#include "error.h"
#include "xpcomm.h"
#include <strconst.h>
#include "ourguid.h"
#include <wabguid.h>        // IID_IDistList etc.
#include <certs.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <mimeole.h>
#include <secutil.h>
#include "demand.h"
#include "conman.h"
#include "multiusr.h"
#include "instance.h"

// ===========================================================================
// G L O B A L S - The globals are set int HrInitWab
// ===========================================================================
static BOOL                 g_fWabInit = FALSE;
static BOOL                 g_fWabLoaded = FALSE;
static HINSTANCE            g_hWab32Dll = NULL;
static LPWABOPEN            g_lpfnWabOpen = NULL;
static LPWABOBJECT          g_lpWabObject = NULL;
static LPADRBOOK            g_lpAdrBook = NULL;
static CRITICAL_SECTION     g_rWabCritSect = {0};
static CWab                *g_pWab = NULL;
static TCHAR                c_szOEThis[] = "OE_ThisPtr";

// ===========================================================================
// P R O T O T Y P E S
// ===========================================================================
HRESULT HrLoadWab (VOID);
BOOL    FUnloadWab (VOID);
VOID    ReleaseWabObjects (LPWABOBJECT lpWabObject, LPADRBOOK lpAdrBook);
void    SerialAdrInfoString(LPWSTR *ppwszDest, LPWSTR pwszSrc, ULONG *pcbOff,
                             LPBYTE *ppbData);
HRESULT HrAddrInfoListToHGlobal (LPADRINFOLIST lpAdrInfoList,
                                 HGLOBAL *phGlobal);
HRESULT HrHGlobalToAddrInfoList (HGLOBAL hGlobal, LPADRINFOLIST *lplpAdrInfoList);   // caller frees with MemFree
ULONG   CbAdrInfoSize (LPADRINFO lpAdrInfo);
HRESULT HrSetAdrEntry (LPWABOBJECT lpWab, LPADRENTRY lpAdrEntry,
                       LPADRINFO lpAdrInfo, DWORD mask);
LPTSTR  SzWabStringDup (LPWABOBJECT lpWab, LPCSTR lpcsz, LPVOID lpParentObject);
LPWSTR  SzWabStringDupW(LPWABOBJECT lpWab, LPCWSTR lpcwsz, LPVOID lpParentObject);
LPBYTE  LpbWabBinaryDup (LPWABOBJECT lpWab, LPBYTE lpbSrc, ULONG cb, LPVOID lpParentObject);
void STDMETHODCALLTYPE DismissWabWindow(ULONG_PTR ulUIParam, LPVOID lpvContext);

#ifdef DEBUG
void    DEBUGDumpAdrList(LPADRLIST pal);
#endif

// ===========================================================================
// HrInitWab
// ===========================================================================
HRESULT HrInitWab (BOOL fInit)
{
    // Locals
    HRESULT         hr = S_OK;

    // Initialize the WAB
    if (fInit)
    {
        // Have we already been initialized ?
        if (g_fWabInit)
            goto exit;

        // Wab has been inited, doesn't imply success
        g_fWabInit = TRUE;

        // Init Critical Section
        InitializeCriticalSection (&g_rWabCritSect);

        // Load the WAB
        CHECKHR (hr = HrLoadWab ());
    }

    // Unload Wab
    else
    {
        // Not inited ?
        if (!g_fWabInit)
            goto exit;

        // Unload Wab
        if (FUnloadWab () == TRUE)
        {
            // Kill critical section
            DeleteCriticalSection (&g_rWabCritSect);

            // Not inited
            g_fWabInit = FALSE;
        }
    }

exit:
    // Done
    if (fInit && FAILED (hr))
        AthMessageBoxW(g_hwndInit, MAKEINTRESOURCEW(idsAthena), MAKEINTRESOURCEW(idsErrLoadingWAB), NULL, MB_OK);

    return hr;
}


const static TCHAR lpszWABDLLRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR lpszWABEXERegPathKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
const static TCHAR lpszWABEXE[] = TEXT("wab.exe");

// =============================================================================
// HrLoadPathWABEXE - creaetd vikramm 5/14/97 - loads the registered path of the
// latest wab.exe
// szPath - pointer to a buffer
// cbPath - sizeof buffer
// =============================================================================
// ~~~~ @TODO dhaws Might need to convert this
HRESULT HrLoadPathWABEXE(LPTSTR szPath, ULONG cbPath)
{
    DWORD  dwType;
    ULONG  cbData = cbPath;
    HKEY hKey;

    Assert(szPath != NULL);
    Assert(cbPath > 0);

    *szPath = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABEXERegPathKey, 0, KEY_READ, &hKey))
        {
        SHQueryValueEx( hKey, c_szEmpty, NULL, &dwType, (LPBYTE) szPath, &cbData);

        RegCloseKey(hKey);
        }

    if(!lstrlen(szPath))
        lstrcpy(szPath, lpszWABEXE);

    return S_OK;
}

// ===========================================================================
// HrLoadLibraryWabDLL - added vikramm 5/14 - new wab setup needs this
// ===========================================================================
HINSTANCE LoadLibraryWabDLL (VOID)
{
    TCHAR  szWABDllPath[MAX_PATH];
    DWORD  dwType;
    ULONG  cbData = sizeof(szWABDllPath);
    HKEY hKey;

    *szWABDllPath = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABDLLRegPathKey, 0, KEY_READ, &hKey))
        {
        SHQueryValueEx( hKey, c_szEmpty, NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

        RegCloseKey(hKey);
        }

    if(!lstrlen(szWABDllPath))
        lstrcpy(szWABDllPath, WAB_DLL_NAME);

    return(LoadLibrary(szWABDllPath));
}


// ===========================================================================
// HrLoadWab
// ===========================================================================
HRESULT HrLoadWab (VOID)
{
    // Locals
    HRESULT         hr = S_OK;
    WAB_PARAM       wp = {0};
    LPWAB           pWab;

    // We better be init'ed
    Assert (g_fWabInit == TRUE);

    // Enter Critical Section
    EnterCriticalSection (&g_rWabCritSect);

    // Load the WAB Dll
    g_hWab32Dll = LoadLibraryWabDLL();

    // Did it load
    if (g_hWab32Dll == NULL)
    {
        hr = TRAPHR (hrUnableToLoadWab32Dll);
        goto exit;
    }

    // Get WABOpen proc
    IF_WIN32(g_lpfnWabOpen = (LPWABOPEN)GetProcAddress (g_hWab32Dll, "WABOpen");)
    IF_WIN16(g_lpfnWabOpen = (LPWABOPEN)GetProcAddress (g_hWab32Dll, "_WABOpen");)

    // Did we get the proc ?
    if (g_lpfnWabOpen == NULL)
    {
        hr = TRAPHR (hrUnableToLoadWab32Dll);
        goto exit;
    }

    // get the current user id to open the right view in the WAB.
    wp.cbSize = sizeof(WAB_PARAM);
    wp.guidPSExt = CLSID_AddrObject; // was CLSID_OEBAControl, bug 99652;
    wp.ulFlags = (g_dwAthenaMode & MODE_NEWSONLY) ? WAB_ENABLE_PROFILES | MAPI_UNICODE:
                                                    WAB_ENABLE_PROFILES | MAPI_UNICODE | WAB_USE_OE_SENDMAIL;


    // Open the wab and get the objects
    CHECKHR (hr = (*g_lpfnWabOpen)(&g_lpAdrBook, &g_lpWabObject, &wp, 0));

    pWab = new CWab;
    if (pWab == NULL)
    {
        hr = TRAPHR (hrMemory);
        goto exit;
    }
    else
    {
        g_pWab = pWab;
    }

    // Yee-hah, the wab is loaded
    g_fWabLoaded = TRUE;

exit:
    // Leave Critical Section
    LeaveCriticalSection (&g_rWabCritSect);

    // Done
    return hr;
}

// ===========================================================================
// UnloadWab
// ===========================================================================
BOOL FUnloadWab (VOID)
{
    // Locals
    ULONG           cWabObjectRefs = 0, cAdrBookRefs = 0, cWabRefs = 0;
    BOOL            fResult = FALSE;

    // We better have been inited
    Assert (g_fWabInit == TRUE);

    // Enter Critical Section
    EnterCriticalSection (&g_rWabCritSect);

    // Release global objects
    if (g_lpAdrBook && g_lpWabObject && g_pWab)
    {
        if (g_pWab)
            g_pWab->OnClose();      // the close callback will release it.


        // Get Ref Counts and cleanup
        cWabRefs = g_pWab->Release ();
        g_pWab = NULL;

        cAdrBookRefs = g_lpAdrBook->Release ();
        g_lpAdrBook = NULL;

        cWabObjectRefs = g_lpWabObject->Release ();
        g_lpWabObject = NULL;
        g_fWabLoaded = FALSE;
        fResult = TRUE;

        // These better be the same
        //Assert (cWabObjectRefs == cAdrBookRefs);

        // Can we unload now ?
        if (cWabObjectRefs == 0 && cAdrBookRefs == 0 && cWabRefs == 0)
        {
            // Unload the dll
            if (g_hWab32Dll)
            {
                FreeLibrary (g_hWab32Dll);
                g_hWab32Dll = NULL;
            }

            // Reset the proc pointer to NULL
            g_lpfnWabOpen = NULL;

        }
    }

    // Leave Critical Section
    LeaveCriticalSection (&g_rWabCritSect);

    // Done
    return fResult;
}

// ===========================================================================
// ReleaseWabObjects
// ===========================================================================
VOID ReleaseWabObjects (LPWABOBJECT lpWabObject, LPADRBOOK lpAdrBook)
{
    // Locals
    ULONG           cWabObjectRefs = 0, cAdrBookRefs = 0;

    // We better have been inited
    Assert (g_fWabInit == TRUE);

    // Check Params
    if (lpWabObject == NULL || lpAdrBook == NULL)
    {
        Assert (FALSE);
        return;
    }

    // Enter Critical Section
    EnterCriticalSection (&g_rWabCritSect);

    // Release objects
    Assert (g_lpAdrBook && g_lpWabObject)

    // Release the wab
    cAdrBookRefs = lpAdrBook->Release ();
    cWabObjectRefs = lpWabObject->Release ();

    // Ref counts should hit zero at the same time
#ifdef DEBUG
    if (cWabObjectRefs==0)
        Assert(cAdrBookRefs==0);

    if (cAdrBookRefs==0)
        Assert(cWabObjectRefs==0);
#endif

    // If both counts are zero, we can unload the dll
    if (cWabObjectRefs == 0 && cAdrBookRefs == 0)
    {
        // Set globals
        g_lpWabObject = NULL;
        g_lpAdrBook = NULL;

        // Unload the WAB
        if (g_hWab32Dll)
        {
            FreeLibrary (g_hWab32Dll);
            g_hWab32Dll = NULL;
        }

        // Reset the proc pointer to NULL
        g_lpfnWabOpen = NULL;

        // Not loaded, not inited
        g_fWabLoaded = FALSE;

        // Not inited
        g_fWabInit = FALSE;

        // Leave Critical Section
        LeaveCriticalSection (&g_rWabCritSect);

        // Kill critical section
        DeleteCriticalSection (&g_rWabCritSect);

    }
    else
    {
        // Leave Critical Section
        LeaveCriticalSection (&g_rWabCritSect);
    }

    // Done
    return;
}


/***************************************************************************

    Name      : FWABTranslateAccelerator

    Purpose   : Give an open WAB window a change to look for accelerators.

    Parameters: lpmsg -> lpmsg from the current event

    Returns   : BOOL - was the event used

***************************************************************************/

BOOL FWABTranslateAccelerator(LPMSG lpmsg)
{
    if (g_pWab)
        return g_pWab->FTranslateAccelerator(lpmsg);
    else
        return FALSE;
}

// ===========================================================================
// HrCreateWabObject
// ===========================================================================
HRESULT HrCreateWabObject (LPWAB *lppWab)
{
    // Locals
    HRESULT             hr = S_OK;

    // Check Params
    Assert (lppWab);

    hr=HrInitWab(TRUE);
    if (FAILED(hr))
        return hr;

    // Verify Globals
    if (g_fWabLoaded == FALSE || g_fWabInit == FALSE)
    {
        return TRAPHR (hrWabNotLoaded);
    }

    // Enter Critical Section
    EnterCriticalSection (&g_rWabCritSect);

    // Verify globals
    Assert (g_lpfnWabOpen && g_hWab32Dll && g_lpAdrBook && g_lpWabObject && g_pWab);

    // Inst it

    g_pWab->AddRef();
    *lppWab = g_pWab;

    // Leave Critical Section
    LeaveCriticalSection (&g_rWabCritSect);

    // Done
    return hr;
}

// ===========================================================================
// DismissWabWindow
// ===========================================================================
void STDMETHODCALLTYPE DismissWabWindow(ULONG_PTR ulUIParam, LPVOID lpvContext)
{
    CWab *pWab = (CWab *) lpvContext;

    Assert(pWab == g_pWab);


    if (pWab == g_pWab)
    {
        g_pWab->BrowseWindowClosed();
    }
}

/*
-
-   Checks for the existence of a Contact with a specific e-mail address
*
*/
HRESULT HrCheckEMailExistence(LPADRBOOK lpAdrBook, LPWABOBJECT lpWabObject, LPWSTR lpwszLookup)
{
    HRESULT     hr = NOERROR;
    ULONG       i = 0, j=0;
    LPADRLIST   lpAdrList = NULL;
    BOOL        fFound = FALSE;

    Assert(lpAdrBook && lpWabObject);

    hr = lpWabObject->AllocateBuffer(sizeof(ADRLIST), (LPVOID *)&lpAdrList);
    if(FAILED(hr))
        goto Cleanup;

    Assert(lpAdrList);
    lpAdrList->cEntries = 1;
    lpAdrList->aEntries[0].ulReserved1 = 0;
    lpAdrList->aEntries[0].cValues = 1;

    hr = lpWabObject->AllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpAdrList->aEntries[0].rgPropVals);
    if(FAILED(hr))
        goto Cleanup;

    lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_EMAIL_ADDRESS_W;
    lpAdrList->aEntries[0].rgPropVals[0].Value.lpszW = lpwszLookup;

    hr = lpAdrBook->ResolveName (   0,
                                    WAB_RESOLVE_LOCAL_ONLY |
                                    WAB_RESOLVE_ALL_EMAILS |
                                    WAB_RESOLVE_USE_CURRENT_PROFILE |
                                    WAB_RESOLVE_UNICODE,
                                    NULL, lpAdrList);
    if(FAILED(hr))
        goto Cleanup;

    for(j=0; j<lpAdrList->aEntries[0].cValues; j++)
    {
        if(lpAdrList->aEntries[0].rgPropVals[j].ulPropTag == PR_ENTRYID)
        {
            fFound = TRUE;
            break;
        }
    }

    if(!fFound)
        hr = MAPI_E_NOT_FOUND;

Cleanup:
    if (lpAdrList)
    {
        for (ULONG ul = 0; ul < lpAdrList->cEntries; ul++)
            lpWabObject->FreeBuffer(lpAdrList->aEntries[ul].rgPropVals);
        lpWabObject->FreeBuffer(lpAdrList);
    }
    return hr;
}


/***************************************************************************

    Name      : HrWABCreateEntry

    Purpose   : Create a new entry in the WAB

    Parameters: lpAdrBook -> ADDRBOOK object
                lpWabObject -> WABOBJECT for allocators
                lpszDisplay -> display name to set [optional]
                lpszAddress -> email address to set [optional]
                ulFlags = flags for CreateEntry
                          CREATE_CHECK_DUP_STRICT
                lppMailUser -> returned MAILUSER object. [optional]

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrWABCreateEntry(LPADRBOOK lpAdrBook, LPWABOBJECT lpWabObject,
                            LPWSTR lpwszDisplay, LPWSTR lpwszAddress, ULONG ulFlags,
                            LPMAILUSER *lppMailUser, ULONG ulSaveFlags)
{
    LPABCONT        pabcWAB = NULL;
    ULONG           cbEidWAB;
    LPENTRYID       peidWAB = NULL;
    LPMAILUSER      lpMailUser = NULL;
    SPropValue      rgpv[3];
    SPropTagArray   ptaEID = {1, {PR_ENTRYID}};
    LPSPropValue    ppvDefMailUser=0;
    SizedSPropTagArray(1, ptaDefMailUser)=
                        { 1, {PR_DEF_CREATE_MAILUSER} };
    ULONG           cProps,
                    ulObjectType;
    HRESULT         hr;

    Assert(lpwszDisplay);
    Assert(lpAdrBook);
    Assert(lpWabObject);

    if(lpwszAddress && *lpwszAddress)
    {
        // Check if the e-mail exists before auto-adding-to-wab
        hr = HrCheckEMailExistence(lpAdrBook, lpWabObject, lpwszAddress);
        if(hr != MAPI_E_NOT_FOUND)
        {
            //either it's found or it's an error
            //if it's found, then this function should generate a collision error
            if(hr == NOERROR)
                hr = MAPI_E_COLLISION;
            goto error;
        }
    }

    // Create a new contact with these properties
    // First, create the basic contact with only a display name
    hr = lpAdrBook->GetPAB(&cbEidWAB, &peidWAB);
    if (FAILED(hr))
        goto error;

    hr = lpAdrBook->OpenEntry(cbEidWAB, peidWAB, NULL, 0, &ulObjectType, (LPUNKNOWN *)&pabcWAB);
    if (FAILED(hr))
        goto error;

    Assert(ulObjectType == MAPI_ABCONT);

    lpWabObject->FreeBuffer(peidWAB);

    hr = pabcWAB->GetProps((LPSPropTagArray)&ptaDefMailUser, 0, &cProps, &ppvDefMailUser);
    if (FAILED(hr) || ! ppvDefMailUser || ppvDefMailUser->ulPropTag != PR_DEF_CREATE_MAILUSER)
        goto error;

    hr = pabcWAB->CreateEntry(ppvDefMailUser->Value.bin.cb, (LPENTRYID)ppvDefMailUser->Value.bin.lpb,
                                        ulFlags, (LPMAPIPROP *)&lpMailUser);
    if (FAILED(hr))
        goto error;

    rgpv[0].ulPropTag = PR_DISPLAY_NAME_W;
    rgpv[0].Value.lpszW = lpwszDisplay;
    cProps = 1;

    if (lpwszAddress)
    {
        rgpv[1].ulPropTag = PR_ADDRTYPE_W;
        rgpv[1].Value.lpszW = L"SMTP";
        cProps++;

        rgpv[2].ulPropTag = PR_EMAIL_ADDRESS_W;
        rgpv[2].Value.lpszW = lpwszAddress;
        cProps++;
    }

    hr = lpMailUser->SetProps(cProps, rgpv, NULL);
    if (FAILED(hr))
        goto error;

    hr = lpMailUser->SaveChanges(ulSaveFlags /*KEEP_OPEN_READONLY*/);
    if (FAILED(hr))
        goto error;

    // Return the new object if it was asked for
    if (lppMailUser)
    {
        *lppMailUser = lpMailUser;
        lpMailUser = NULL;  // short circuit the release below.
    }

error:
    ReleaseObj(lpMailUser);
    ReleaseObj(pabcWAB);

    if (ppvDefMailUser)
        lpWabObject->FreeBuffer(ppvDefMailUser);

    return(hr);
}


// ===========================================================================
// CWab::CWab
// ===========================================================================
CWab::CWab ()
{
    DOUT ("CWab::CWab");
    m_cRef = 1;
    m_lpWabObject = g_lpWabObject;
    m_lpWabObject->AddRef();
    m_lpAdrBook = g_lpAdrBook;
    m_lpAdrBook->AddRef();
    m_hwnd = NULL;
    m_pfnWabWndProc = NULL;
    ZeroMemory(&m_adrParm, sizeof(m_adrParm));
    m_fInternal = FALSE;
    ZeroMemory(&m_hlDisabled, sizeof(HWNDLIST));
}

// ===========================================================================
// CWab::CWab
// ===========================================================================
CWab::~CWab ()
{
    DOUT ("CWab::~CWab");
    ReleaseWabObjects (m_lpWabObject, m_lpAdrBook);
}

// =============================================================================
// CWab::AddRef
// =============================================================================
ULONG CWab::AddRef (VOID)
{
    DOUT("CWab::AddRef %lx ==> %d", this, m_cRef+1);
    return ++m_cRef;
}

// =============================================================================
// CWab::Release
// =============================================================================
ULONG CWab::Release (VOID)
{
    DOUT("CWab::Release %lx ==> %d", this, m_cRef-1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// =============================================================================
// CWab::FVerifyState
// =============================================================================
BOOL CWab::FVerifyState (VOID)
{
    // We need these things !
    if (m_lpWabObject == NULL || m_lpAdrBook == NULL)
    {
        Assert (FALSE);
        return FALSE;
    }

    // Done
    return TRUE;
}

// =============================================================================
// CWab::HrPickNames
// =============================================================================
HRESULT CWab::HrPickNames (HWND hwndParent, ULONG *rgulTypes, int cWells, int iFocus, BOOL fNews, LPADRLIST *lppal)
{
    // Locals
    int             i, ids;
    HRESULT         hr = S_OK;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wsz2[CCHMAX_STRINGRES];
    ADRPARM         AdrParms = {0};
    LPWSTR         *ppwszWells = NULL;

    // Check Parameters
    Assert (lppal);
    Assert(cWells > 0);

    // Have we been initialized
    if (FVerifyState () == FALSE)
    {
        hr = TRAPHR (E_FAIL);
        return hr;
    }

    if (!MemAlloc((LPVOID *)&ppwszWells, cWells*sizeof(LPWSTR)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    ZeroMemory(ppwszWells, cWells * sizeof(LPWSTR));

    AthLoadStringW(idsMsgRecipients, wsz2, ARRAYSIZE(wsz2));
    AthLoadStringW(idsPickRecipientsTT, wsz, ARRAYSIZE(wsz));

    AdrParms.ulFlags=DIALOG_MODAL|MAPI_UNICODE;
    AdrParms.lpszCaption=(LPTSTR)wsz;
    AdrParms.cDestFields = cWells;

    AdrParms.nDestFieldFocus = iFocus;
    AdrParms.lpulDestComps = rgulTypes;
    AdrParms.lpszDestWellsTitle = (LPTSTR)wsz2;

    for (i = 0; i < cWells; i++)
    {
        switch (rgulTypes[i])
        {
            case MAPI_TO:
                if (!fNews)
                {
                    ids = idsToWell;
                    break;
                }
                // fall thru...

            case MAPI_CC:
                ids = idsCcWell;
                break;

            case MAPI_ORIG:
                ids = idsFromWell;
                break;

            case MAPI_REPLYTO:
                ids = idsReplyToWell;
                break;

            case MAPI_BCC:
                ids = idsBccWell;
                break;

            default:
                Assert(FALSE);
                break;
        }

        if (!MemAlloc((LPVOID *)&ppwszWells[i], CCHMAX_STRINGRES * sizeof(WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        AthLoadStringW(ids, ppwszWells[i], CCHMAX_STRINGRES);
    }

    AdrParms.lppszDestTitles = (LPTSTR *)ppwszWells;

    // Show the dialog
    hr = m_lpAdrBook->Address ((ULONG_PTR *)&hwndParent, &AdrParms, lppal);

#ifdef DEBUG
    DEBUGDumpAdrList(*lppal);
#endif

    // Cleanup
    if (ppwszWells)
    {
        for (i=0; i<cWells; i++)
            SafeMemFree(ppwszWells[i]);

        MemFree(ppwszWells);
    }
error:
    // Done
    return hr;
}

// =============================================================================
// CWab::HrGeneralPickNames
// =============================================================================
HRESULT CWab::HrGeneralPickNames(HWND hwndParent, ADRPARM *pAdrParms, LPADRLIST *lppal)
{
    // Locals
    HRESULT         hr = S_OK;

    // Check Parameters
    Assert (lppal);

    // Have we been initialized
    if (FVerifyState () == FALSE)
    {
        hr = TRAPHR (E_FAIL);
        return hr;
    }

    // Show the dialog
    hr = m_lpAdrBook->Address ((ULONG_PTR *)&hwndParent, pAdrParms, lppal);

    // Cleanup
    if (FAILED (hr))
    {
        if (*lppal)
        {
            m_lpWabObject->FreeBuffer (*lppal);
            *lppal = NULL;
        }
    }

    // Done
    return hr;
}


// =============================================================================
// CWab::HrBrowse
// =============================================================================
HRESULT CWab::HrBrowse (HWND hwndParent, BOOL fModal)
{
    ULONG_PTR   uiParam = (ULONG_PTR)hwndParent;
    LPADRLIST   pAdrList = NULL;
    HRESULT     hr;
    TCHAR       szWabCaption[CCHMAX_STRINGRES];

    // Change to use IAddrBook::Address
    Assert(m_lpAdrBook);

    AthLoadString(idsAddressBook, szWabCaption, sizeof(szWabCaption));

    ZeroMemory(&m_adrParm, sizeof(m_adrParm));
    m_adrParm.ulFlags = fModal ? DIALOG_MODAL : DIALOG_SDI;
    if (!fModal)
    {
        //m_adrParm.lpszCaption = szWabCaption;
        m_adrParm.lpfnDismiss = &DismissWabWindow;
        m_adrParm.lpvDismissContext = (void *)this;
    }

    hr = m_lpAdrBook->Address(&uiParam, &m_adrParm, &pAdrList);
    if (SUCCEEDED(hr) && g_pInstance && !fModal)
    {
        // subclass the wab window, if there isn't one already up
        if (GetProp((HWND)uiParam, c_szOEThis) == 0)
        {
            m_pfnWabWndProc = (WNDPROC)SetWindowLongPtr((HWND)uiParam, GWLP_WNDPROC, (LONG_PTR)WabSubProc);
            SetProp((HWND)uiParam, c_szOEThis, (HANDLE)this);
            SetProp((HWND)uiParam, c_szOETopLevel, (HANDLE)TRUE);
            CoIncrementInit("WabWindow", MSOEAPI_START_SHOWERRORS, NULL, NULL);
            AddRef();
        }
    }

    m_hwnd = (HWND)uiParam;

    return NOERROR;
}


// =============================================================================
// CWab::HrAddNewEntry
// =============================================================================
HRESULT CWab::HrAddNewEntryA(LPTSTR lpszDisplay, LPTSTR lpszAddress)
{
    LPWSTR  pwszDisplay = NULL,
            pwszAddress = NULL;
    HRESULT hr = S_OK;

    Assert(lpszDisplay);

    IF_NULLEXIT(pwszDisplay = PszToUnicode(CP_ACP, lpszDisplay));

    // If lpszAddress is null, we have an incomplete Entry. This is ok.
    pwszAddress = PszToUnicode(CP_ACP, lpszAddress);
    if (lpszAddress && !pwszAddress)
        IF_NULLEXIT(NULL);

    hr = HrAddNewEntry(pwszDisplay, pwszAddress);

exit:
    MemFree(pwszDisplay);
    MemFree(pwszAddress);
    return hr;
}

HRESULT CWab::HrAddNewEntry(LPWSTR lpwszDisplay, LPWSTR lpwszAddress)
{
    return(HrWABCreateEntry(m_lpAdrBook,
                            m_lpWabObject,
                            lpwszDisplay,
                            lpwszAddress,
                            CREATE_CHECK_DUP_STRICT|MAPI_UNICODE,
                            NULL));
}

VOID CWab::FreeLPSRowSet(LPSRowSet lpsrs)
{
    UINT i;
    if(NULL == m_lpWabObject)
        return;

    if(lpsrs)
    {
        for(i=0;i<lpsrs->cRows;i++)
            m_lpWabObject->FreeBuffer(lpsrs->aRow[i].lpProps);
        m_lpWabObject->FreeBuffer(lpsrs);
    }
}


VOID CWab::FreePadrlist(LPADRLIST lpAdrList)
{
    if(NULL == m_lpWabObject)
        return;

    if(lpAdrList)
    {
        for (ULONG iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry)
        {
            if(lpAdrList->aEntries[iEntry].rgPropVals)
                m_lpWabObject->FreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
        }
        m_lpWabObject->FreeBuffer(lpAdrList);
    }
}


HRESULT CWab::HrFind(HWND hwnd, LPWSTR lpwszLookup)
{
    HRESULT     hr = NOERROR;
    ULONG       i = 0, j=0;
    LPSRowSet   lpsrs = NULL;
    ULONG       cbEntryID=0;
    LPENTRYID   lpEntryID=NULL;
    ULONG       ulObjType = 0;
    LPADRLIST   lpAdrList = NULL;
    BOOL        fFound = FALSE;

    Assert(m_lpAdrBook && m_lpWabObject);

    if (lpwszLookup == NULL)
        return E_INVALIDARG;

    hr = m_lpWabObject->AllocateBuffer(sizeof(ADRLIST), (LPVOID *)&lpAdrList);
    if(FAILED(hr))
        goto Cleanup;

    Assert(lpAdrList);
    lpAdrList->cEntries = 1;
    lpAdrList->aEntries[0].ulReserved1 = 0;
    lpAdrList->aEntries[0].cValues = 1;

    hr = m_lpWabObject->AllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpAdrList->aEntries[0].rgPropVals);
    if(FAILED(hr))
        goto Cleanup;

    lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_EMAIL_ADDRESS_W;
    lpAdrList->aEntries[0].rgPropVals[0].Value.lpszW = lpwszLookup;

    hr = m_lpAdrBook->ResolveName ((ULONG_PTR)hwnd, WAB_RESOLVE_NO_NOT_FOUND_UI |
                                                WAB_RESOLVE_ALL_EMAILS |
                                                WAB_RESOLVE_USE_CURRENT_PROFILE |
                                                MAPI_DIALOG |
                                                WAB_RESOLVE_UNICODE,
                                                NULL, lpAdrList);

    if(FAILED(hr))
        goto Cleanup;

    for(j=0; j<lpAdrList->aEntries[0].cValues; j++)
    {
        if(lpAdrList->aEntries[0].rgPropVals[j].ulPropTag == PR_ENTRYID)
        {
            cbEntryID = lpAdrList->aEntries[0].rgPropVals[j].Value.bin.cb;
            lpEntryID = (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[j].Value.bin.lpb;
            fFound = TRUE;
            hr = g_lpAdrBook->Details((ULONG_PTR *)&hwnd, NULL, NULL, cbEntryID, lpEntryID, NULL, NULL, NULL, DIALOG_MODAL);
            if(FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
                goto Cleanup;
            hr = NOERROR;
            break;
        }
    }

Cleanup:
    FreePadrlist(lpAdrList);

    if(!fFound && hr!=MAPI_E_USER_CANCEL)
        hr = E_FAIL;

    if(hr==MAPI_E_USER_CANCEL)
        hr = NOERROR;

    return hr;
}

enum
{
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidPR_OBJECT_TYPE,
    ieidMax
};

static const SizedSPropTagArray(ieidMax, ptaEid_A)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME_A,
        PR_ENTRYID,
        PR_OBJECT_TYPE
    }
};

static const SizedSPropTagArray(ieidMax, ptaEid_W)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME_W,
        PR_ENTRYID,
        PR_OBJECT_TYPE
    }
};


HRESULT CWab::HrFillComboWithPABNames(HWND hwnd, int* pcRows)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet   lpRow = NULL;
    LPABCONT    lpContainer = NULL;
    HRESULT     hr=NOERROR;
    ULONG       cbEID=0;
    LPENTRYID   lpEID = NULL;
    int         cNumRows = 0;
    int         nRows=0;
    LPSTR       psz = NULL;
    LPWSTR      lpwsz = NULL;

#if defined(FIX_75835)
    COMBOBOXEXITEMW cbeiw;
    SSortOrderSet ssos;
#endif

    if(NULL==hwnd || NULL==pcRows)
        return E_INVALIDARG;

    IF_FAILEXIT(hr = m_lpAdrBook->GetPAB(&cbEID, &lpEID));

    IF_FAILEXIT(hr = m_lpAdrBook->OpenEntry(cbEID, (LPENTRYID)lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpContainer));

    // Request UNICODE strings in table
    IF_FAILEXIT(hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS | MAPI_UNICODE, &lpTable));

    // We only care about a few columns
    IF_FAILEXIT(hr =lpTable->SetColumns((LPSPropTagArray)&ptaEid_W, 0));

#if defined(FIX_75835)
    // Sort the list (synchronously) on display name as ComboBoxEx doesn't support CBS_SORT
    ssos.cCategories = ssos.cExpanded = 0;
    ssos.cSorts = 1;
    ssos.aSort[0].ulPropTag = PR_DISPLAY_NAME_W;
    ssos.aSort[0].ulOrder   = TABLE_SORT_ASCEND;

    IF_FAILEXIT(hr = lpTable->SortTable(&ssos, 0));
#endif

    // We will add the display names in order, starting with the first
    IF_FAILEXIT(hr = lpTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL));

    nRows = 0;
    do
    {
        lpRow = NULL;
        hr = lpTable->QueryRows(1, 0, &lpRow);
        if(FAILED(hr))
            goto CleanLoop;

        cNumRows = lpRow->cRows;
        if(cNumRows)
        {
            // If we have a mailuser and their display name is valid
            if((lpRow->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER) &&
               (PROP_TYPE(lpRow->aRow[0].lpProps[ieidPR_DISPLAY_NAME].ulPropTag) != PT_ERROR))
            {
                lpwsz = lpRow->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszW;

#if defined(FIX_75835)
                if(NULL != lpwsz)
                {
                    // display name
                    cbeiw.pszText = lpwsz;
                    cbeiw.mask = CBEIF_TEXT;
                    cbeiw.iItem = -1;

                    SendMessage(hwnd, CBEM_INSERTITEMW, 0, (LPARAM)&cbeiw);
                    nRows++;
                }
#else
                if (psz = PszToANSI(CP_ACP, lpwsz))
                {
                    ComboBox_AddString(hwnd, (LPARAM)psz);
                    MemFree(psz);
                }
#endif
            }
        }

CleanLoop:
        if(lpRow)
            FreeLPSRowSet(lpRow);

    }while(cNumRows);

    *pcRows = nRows;

exit:
    ReleaseObj(lpTable);
    ReleaseObj(lpContainer);
    if(lpEID)
        m_lpWabObject->FreeBuffer(lpEID);

    return hr;
}


HRESULT CWab::HrFromIDToName(LPTSTR lpszName, ULONG cbEID, LPENTRYID lpEID)
{
    ULONG       ulObjType = 0, ulResult=0;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet   lpRow = NULL;
    LPABCONT    lpContainer = NULL;
    ULONG       cbEIDPAB = 0;
    LPENTRYID   lpEIDPAB = NULL;
    HRESULT     hr = NOERROR;
    int         cNumRows = 0;
    int         nRows = 0;

    if(0==cbEID || NULL==lpEID || lpszName==NULL)
        return E_INVALIDARG;

    *lpszName = 0;
    hr = m_lpAdrBook->GetPAB(&cbEIDPAB, &lpEIDPAB);
    if(FAILED(hr))
        goto error;

    hr = m_lpAdrBook->OpenEntry(cbEIDPAB, (LPENTRYID)lpEIDPAB, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpContainer);
    if(FAILED(hr))
        goto error;

    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS, &lpTable);
    if(FAILED(hr))
        goto error;

    hr =lpTable->SetColumns((LPSPropTagArray)&ptaEid_A, 0);
    if(FAILED(hr))
        goto error;

    hr = lpTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
    if(FAILED(hr))
        goto error;

    nRows = 0;
    do
    {
        lpRow = NULL;
        hr = lpTable->QueryRows(1, 0, &lpRow);
        if(FAILED(hr))
            goto CleanLoop;

        cNumRows = lpRow->cRows;
        if(cNumRows)
        {
            if(lpRow->aRow[0].lpProps[2].Value.l == MAPI_MAILUSER)
            {
                hr=m_lpAdrBook->CompareEntryIDs(cbEID, (LPENTRYID)lpEID,
                                    lpRow->aRow[0].lpProps[1].Value.bin.cb,
                                    (LPENTRYID)lpRow->aRow[0].lpProps[1].Value.bin.lpb, 0, &ulResult);

                if ( (!FAILED(hr)) && ulResult &&
                     PROP_TYPE(lpRow->aRow[0].lpProps[0].ulPropTag) != PT_ERROR )
                {
                    lstrcpy(lpszName, lpRow->aRow[0].lpProps[0].Value.lpszA);
                    goto CleanLoop;
                }

            }
        }

CleanLoop:
        if(lpRow)
        {
            FreeLPSRowSet(lpRow);
            lpRow = NULL;
        }

        if(FAILED(hr))
            goto error;

        if(*lpszName)
            break;

    }while(cNumRows);

    if(*lpszName==0)
        hr = E_FAIL;

error:
    ReleaseObj(lpTable);
    ReleaseObj(lpContainer);
    if(lpEIDPAB)
        m_lpWabObject->FreeBuffer(lpEIDPAB);
    return hr;
}


HRESULT CWab::HrFromNameToIDs(LPCTSTR lpszVCardName, ULONG* pcbEID, LPENTRYID* lppEID)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpTable = NULL;
    LPSRowSet   lpRow = NULL;
    LPABCONT    lpContainer = NULL;
    HRESULT     hr = NOERROR;
    ULONG       cbEID = 0, cbEIDFound = 0;
    LPENTRYID   lpEID = NULL, lpEIDFound = NULL;
    int         cNumRows = 0;
    int         nRows = 0;
    LPTSTR      lpsz = NULL;
    BOOL        fFound = FALSE;

    if(NULL==pcbEID || NULL==lppEID)
        return E_INVALIDARG;

    *pcbEID = NULL;
    *lppEID = NULL;

    hr = m_lpAdrBook->GetPAB(&cbEID, &lpEID);
    if(FAILED(hr))
        goto error;

    hr = m_lpAdrBook->OpenEntry(cbEID, (LPENTRYID)lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpContainer);
    if(FAILED(hr))
        goto error;

    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS, &lpTable);
    if(FAILED(hr))
        goto error;

    hr =lpTable->SetColumns((LPSPropTagArray)&ptaEid_A, 0);
    if(FAILED(hr))
        goto error;

    hr = lpTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
    if(FAILED(hr))
        goto error;

    nRows = 0;
    do
    {
        lpRow = NULL;
        hr = lpTable->QueryRows(1, 0, &lpRow);
        if(FAILED(hr))
            goto CleanLoop;

        cNumRows = lpRow->cRows;
        if(cNumRows)
        {
            if(lpRow->aRow[0].lpProps[2].Value.l == MAPI_MAILUSER)
            {
                lpsz = lpRow->aRow[0].lpProps[0].Value.lpszA; //display name
                if( PROP_TYPE(lpRow->aRow[0].lpProps[0].ulPropTag) != PT_ERROR &&
                    lpsz &&
                    0 == lstrcmp(lpsz, lpszVCardName) )
                {
                    cbEIDFound = lpRow->aRow[0].lpProps[1].Value.bin.cb;
                    lpEIDFound = (LPENTRYID)lpRow->aRow[0].lpProps[1].Value.bin.lpb;
                    if(0!=cbEIDFound && NULL!=lpEIDFound)
                    {
                        *lppEID = (LPENTRYID)LpbWabBinaryDup(m_lpWabObject, (LPBYTE)lpEIDFound, cbEIDFound, NULL);
                        if(NULL == *lppEID)
                        {
                            hr = E_OUTOFMEMORY;
                            goto CleanLoop;
                        }
                        *pcbEID = cbEIDFound;
                        fFound = TRUE;
                    }
                    else
                        hr = E_FAIL;

                    goto CleanLoop;
                }
            }
        }

CleanLoop:
        if(lpRow)
        {
            FreeLPSRowSet(lpRow);
            lpRow = NULL;
        }

        if(FAILED(hr))
            goto error;


        if(fFound)
            break;

    }while(cNumRows);

    if(!fFound)
        hr = E_FAIL;

error:
    ReleaseObj(lpTable);
    ReleaseObj(lpContainer);
    if(lpEID)
        m_lpWabObject->FreeBuffer(lpEID);

    return hr;
}


const static SizedSPropTagArray(4, Cols)=
{
    4,
    {
        PR_DISPLAY_NAME_W,
        PR_EMAIL_ADDRESS_W,
        PR_NICKNAME_W,
        PR_ENTRYID,
    }
};

HRESULT CWab::HrGetPABTable(LPMAPITABLE* ppTable)
{
    ULONG       ulObjType = 0;
    LPMAPITABLE lpTable = NULL;
    LPABCONT    lpContainer = NULL;
    ULONG       cbEID = 0;
    LPENTRYID   lpEID = NULL;
    HRESULT     hr;

    if(NULL == ppTable)
        return E_INVALIDARG;

    *ppTable = NULL;

    hr = m_lpAdrBook->GetPAB(&cbEID, &lpEID);
    if(FAILED(hr))
        goto error;

    hr = m_lpAdrBook->OpenEntry(cbEID, (LPENTRYID)lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpContainer);
    if(FAILED(hr))
        goto error;

    hr = lpContainer->GetContentsTable(WAB_PROFILE_CONTENTS|MAPI_UNICODE, &lpTable);
    if(FAILED(hr))
        goto error;

    hr =lpTable->SetColumns((LPSPropTagArray)&Cols, 0);
    if(FAILED(hr))
        goto error;

    *ppTable = lpTable;
    lpTable = NULL;//avoid releasing it.

error:
    ReleaseObj(lpTable);
    ReleaseObj(lpContainer);
    if(lpEID)
        m_lpWabObject->FreeBuffer(lpEID);

    return hr;
}



HRESULT CWab::SearchPABTable(LPMAPITABLE lpTable, LPWSTR pszValue, LPWSTR pszFound, INT cch)
{
    LPSRowSet       lpRow = NULL;
    SRestriction    Res;
    SPropValue      propSearch;
    HRESULT         hr=E_FAIL;
    int             cNumRows = 0;

    if(NULL==lpTable || NULL==pszValue || NULL==*pszValue || NULL==pszFound)
        return E_INVALIDARG;

    ZeroMemory(&Res, sizeof(SRestriction));
    ZeroMemory(&propSearch, sizeof(SPropValue));
    *pszFound = 0;
    for(int i = 0; i < (int)(Cols.cValues - 1); i++)
    {
        propSearch.ulPropTag = Cols.aulPropTag[i];
        propSearch.Value.lpszW = pszValue;

        Res.rt = RES_CONTENT;
        Res.res.resContent.ulFuzzyLevel = FL_IGNORECASE | FL_PREFIX;
        Res.res.resContent.ulPropTag = propSearch.ulPropTag;
        Res.res.resContent.lpProp = &propSearch;
        hr = lpTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
        if(FAILED(hr))
            return hr;

        do
        {
            hr = lpTable->FindRow(&Res, BOOKMARK_CURRENT, NULL);
            if(FAILED(hr))
                break;

            lpRow = NULL;
            cNumRows = 0;
            lpTable->QueryRows(1, 0, &lpRow);
            if(lpRow)
            {
                cNumRows = lpRow->cRows;
                if(cNumRows)
                {
                    LPWSTR  lpsz = lpRow->aRow[0].lpProps[i].Value.lpszW;
                    if(lstrlenW(lpsz) > 0)
                    {
                        if(*pszFound == 0 || StrCmpIW(lpsz, pszFound) < 0)
                            StrCpyNW(pszFound, lpsz, cch);
                    }
                }
                FreeLPSRowSet(lpRow);
            }
        } while(i!=0 && cNumRows);

        if(*pszFound)
            break;
    }

    return hr;
}


HRESULT CWab::HrCreateVCardFile(LPCTSTR lpszVCardName, LPCTSTR lpszFileName)
{
    ULONG       ulObjType = 0;
    HRESULT     hr=NOERROR;
    ULONG       cbEID=0;
    LPENTRYID   lpEID = NULL;
    LPMAILUSER  lpMailUser = NULL;

    if(NULL==lpszVCardName || NULL==lpszFileName)
        return E_INVALIDARG;

    hr = HrFromNameToIDs(lpszVCardName, &cbEID, &lpEID);
    if(FAILED(hr))
        goto error;

    hr = m_lpAdrBook->OpenEntry(cbEID, lpEID, NULL, 0, &ulObjType, (LPUNKNOWN *)&lpMailUser);
    if(FAILED(hr))
        goto error;

    hr = m_lpWabObject->VCardCreate(m_lpAdrBook, 0, (LPTSTR)lpszFileName, lpMailUser);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(lpMailUser);
    if(lpEID)
        m_lpWabObject->FreeBuffer(lpEID);

    return hr;
}


HRESULT CWab::HrNewEntry(HWND hwnd, LPTSTR lpszName)
{
    ULONG       cbEID=0, cbEIDRet=0;
    LPENTRYID   lpEID = NULL, lpEIDRet = NULL;
    HRESULT     hr=NOERROR;

    hr = m_lpAdrBook->GetPAB(&cbEID, &lpEID);
    if(FAILED(hr))
        goto error;

    hr = m_lpAdrBook->NewEntry((ULONG_PTR)hwnd, 0, cbEID, lpEID, 0, NULL, &cbEIDRet, &lpEIDRet);
    if(FAILED(hr))
        goto error;

    HrFromIDToName(lpszName, cbEIDRet, lpEIDRet);

error:
    if(lpEID)
        m_lpWabObject->FreeBuffer(lpEID);

    if(lpEIDRet)
        m_lpWabObject->FreeBuffer(lpEIDRet);

    return hr;
}

LRESULT CWab::WabSubProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWab    *pWab;
    HWND    hwndActive;
    LRESULT lResult;

    pWab = (CWab *)GetProp(hwnd, c_szOEThis);
    if (!pWab)
        return 0;

    switch (uMsg)
    {
        case WM_NCDESTROY:
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)pWab->m_pfnWabWndProc);
            RemoveProp(hwnd, c_szOEThis);
            RemoveProp(hwnd, c_szOETopLevel);

            lResult = CallWindowProc(pWab->m_pfnWabWndProc, hwnd, uMsg, wParam, lParam);

            pWab->Release();

            // bug #59420, can't freelibrary the wab inside the wndproc
            PostMessage(g_hwndInit, ITM_WAB_CO_DECREMENT, 0, 0);
            return lResult;

        case WM_ENABLE:
            if (!pWab->m_fInternal)
            {
                Assert (wParam || (pWab->m_hlDisabled.cHwnd == NULL && pWab->m_hlDisabled.rgHwnd == NULL));
                EnableThreadWindows(&pWab->m_hlDisabled, (0 != wParam), ETW_OE_WINDOWS_ONLY, hwnd);
                g_hwndActiveModal = wParam ? NULL : hwnd;
            }
            break;

        case WM_OE_ENABLETHREADWINDOW:
            pWab->m_fInternal = 1;
            EnableWindow(hwnd, (BOOL)wParam);
            pWab->m_fInternal = 0;
            break;

        case WM_OE_ACTIVATETHREADWINDOW:
            hwndActive = GetLastActivePopup(hwnd);
            if (hwndActive && IsWindowEnabled(hwndActive) && IsWindowVisible(hwndActive))
                ActivatePopupWindow(hwndActive);
            break;

        case WM_ACTIVATEAPP:
            if (wParam && g_hwndActiveModal && g_hwndActiveModal != hwnd &&
                !IsWindowEnabled(hwnd))
            {
                // $MODAL
                // if we are getting activated, and are disabled then
                // bring our 'active' window to the top
                Assert (IsWindow(g_hwndActiveModal));
                PostMessage(g_hwndActiveModal, WM_OE_ACTIVATETHREADWINDOW, 0, 0);
            }
            break;

    }

    return CallWindowProc(pWab->m_pfnWabWndProc, hwnd, uMsg, wParam, lParam);
}



HRESULT CWab::HrEditEntry(HWND hwnd, LPTSTR lpszName)
{
    ULONG       cbEID = 0;
    LPENTRYID   lpEID = NULL;
    HRESULT     hr = NOERROR;

    if(NULL == lpszName)
        return E_INVALIDARG;

    hr = HrFromNameToIDs(lpszName, &cbEID, &lpEID);
    if(FAILED(hr))
        goto error;

    hr=m_lpAdrBook->Details((ULONG_PTR *)&hwnd, NULL, NULL, cbEID, lpEID, NULL, NULL, NULL, DIALOG_MODAL);
    if(FAILED(hr))
        goto error;

    HrFromIDToName(lpszName, cbEID, lpEID);

error:
    if(lpEID)
        m_lpWabObject->FreeBuffer(lpEID);

    return hr;
}



// =============================================================================
// HrCreateWabalObject
// =============================================================================
HRESULT HrCreateWabalObject (LPWABAL *lppWabal)
{
    // Locals
    HRESULT             hr = S_OK;

    // Check Params
    Assert (lppWabal);

    hr=HrInitWab(TRUE);
    if (FAILED(hr))
        return hr;

    // Verify Globals
    if (g_fWabLoaded == FALSE || g_fWabInit == FALSE)
    {
        return TRAPHR (hrWabNotLoaded);
    }

    // Enter Critical Section
    EnterCriticalSection (&g_rWabCritSect);

    // Verify globals
    Assert (g_lpfnWabOpen && g_hWab32Dll && g_lpAdrBook && g_lpWabObject);

    // Inst it
    *lppWabal = new CWabal;
    if (*lppWabal == NULL)
    {
        hr = TRAPHR (hrMemory);
        goto exit;
    }

exit:
    // Leave Critical Section
    LeaveCriticalSection (&g_rWabCritSect);

    // Done
    return hr;
}

// ===========================================================================
// CWabal::CWabal
// ===========================================================================
CWabal::CWabal ()
{
    DOUT ("CWabal::CWabal");
    m_cRef = 1;
    m_cActualEntries = 0;
    m_lpAdrList = NULL;
    m_lpWabObject = g_lpWabObject;
    m_lpWabObject->AddRef();
    m_lpAdrBook = g_lpAdrBook;
    m_lpAdrBook->AddRef();
    m_cMemberEnum=0;
    m_cMembers = 0;
    m_lprwsMembers = NULL;
    m_pMsg = NULL;
}

// ===========================================================================
// CWabal::CWabal
// ===========================================================================
CWabal::~CWabal ()
{
    DOUT ("CWabal::~CWabal");
    Reset ();
    ReleaseWabObjects (m_lpWabObject, m_lpAdrBook);
}

// =============================================================================
// CWabal::AddRef
// =============================================================================
ULONG CWabal::AddRef (VOID)
{
    DOUT("CWabal::AddRef %lx ==> %d", this, m_cRef+1);
    return ++m_cRef;
}

// =============================================================================
// CWabal::Release
// =============================================================================
ULONG CWabal::Release (VOID)
{
    DOUT("CWabal::Release %lx ==> %d", this, m_cRef-1);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// =============================================================================
// CWabal::FVerifyState
// =============================================================================
BOOL CWabal::FVerifyState (VOID)
{
    // We need these things !
    if (m_lpWabObject == NULL || m_lpAdrBook == NULL)
    {
        Assert (FALSE);
        return FALSE;
    }

    // Done
    return TRUE;
}


// =============================================================================
// CWabal::HrAddEntry
// =============================================================================
HRESULT CWabal::HrAddEntryA(LPTSTR lpszDisplay, LPTSTR lpszAddress, LONG lRecipType)
{
    LPWSTR  pwszDisplay = NULL,
            pwszAddress = NULL;
    HRESULT hr = S_OK;

    Assert(lpszDisplay);

    IF_NULLEXIT(pwszDisplay = PszToUnicode(CP_ACP, lpszDisplay));

    // If lpszAddress is null, we have an incomplete Entry. This is ok.
    pwszAddress = PszToUnicode(CP_ACP, lpszAddress);
    if (lpszAddress && !pwszAddress)
        IF_NULLEXIT(NULL);

    hr = HrAddEntry(pwszDisplay, pwszAddress, lRecipType);

exit:
    MemFree(pwszDisplay);
    MemFree(pwszAddress);
    return hr;
}

HRESULT CWabal::HrAddEntry (LPWSTR lpwszDisplay, LPWSTR lpwszAddress, LONG lRecipType)
{
    // Locals
    HRESULT             hr = S_OK;
    ADRINFO             rAdrInfo;

    // Verify State
    if (FVerifyState () == FALSE)
        return TRAPHR (E_FAIL);

    // Zero
    ZeroMemory (&rAdrInfo, sizeof (ADRINFO));

    // Set adrinfo items
    rAdrInfo.lpwszDisplay = lpwszDisplay;
    rAdrInfo.lpwszAddress = lpwszAddress;
    rAdrInfo.lRecipType = lRecipType;
    rAdrInfo.fDistList = FALSE;
    if (lRecipType == MAPI_ORIG) {
        rAdrInfo.pMsg = m_pMsg;     // only on senders
    }

    // Do we need to grow m_lpAdrList ?
    if (m_lpAdrList == NULL || m_cActualEntries == m_lpAdrList->cEntries)
    {
        // Lets grow my current address list by GROW_SIZE
        CHECKHR (hr = HrGrowAdrlist (&m_lpAdrList, GROW_SIZE));
    }

    // Put new entry into m_cActualEntries
    CHECKHR (hr = HrSetAdrEntry (m_lpWabObject, &m_lpAdrList->aEntries[m_cActualEntries], &rAdrInfo, 0));

    // Increment actual entries
    m_cActualEntries++;

exit:
    // Done
    return hr;
}


// =============================================================================
// CWabal::HrAddEntry
// =============================================================================
HRESULT CWabal::HrAddEntry (LPADRINFO lpAdrInfo, BOOL fCheckDupes)
{
    // Locals
    HRESULT             hr = S_OK;

    // Check Params
    Assert (lpAdrInfo);

    // Verify State
    if (FVerifyState () == FALSE)
        return TRAPHR (E_FAIL);

    // Do we need to grow m_lpAdrList ?
    if (m_lpAdrList == NULL || m_cActualEntries == m_lpAdrList->cEntries)
    {
        // Lets grow my current address list by GROW_SIZE
        CHECKHR (hr = HrGrowAdrlist (&m_lpAdrList, GROW_SIZE));
    }

    BOOL    fSameType,
            fSameEmail;

    if (fCheckDupes)
        {
        for(ULONG ul=0; ul<m_cActualEntries; ul++)
            {
            fSameType=fSameEmail=FALSE;
            for(ULONG ulProp=0; ulProp<m_lpAdrList->aEntries[ul].cValues; ulProp++)
                {
                if (m_lpAdrList->aEntries[ul].rgPropVals[ulProp].ulPropTag==PR_EMAIL_ADDRESS_W &&
                    StrCmpIW(m_lpAdrList->aEntries[ul].rgPropVals[ulProp].Value.lpszW, lpAdrInfo->lpwszAddress)==0)
                    fSameEmail=TRUE;

                if (m_lpAdrList->aEntries[ul].rgPropVals[ulProp].ulPropTag==PR_RECIPIENT_TYPE &&
                    (m_lpAdrList->aEntries[ul].rgPropVals[ulProp].Value.l == lpAdrInfo->lRecipType))
                    fSameType=TRUE;

                }

            if (fSameEmail && fSameType)
                {
                DOUTL(4, "  -- Already in cache");
                return NOERROR;
                }
            }
        DOUTL(4, "  -- Adding.");
        }


    // Put new entry into m_cActualEntries
    CHECKHR (hr = HrSetAdrEntry (m_lpWabObject, &m_lpAdrList->aEntries[m_cActualEntries], lpAdrInfo, 0));

    // Increment actual entries
    m_cActualEntries++;

exit:
    // Done
    return hr;
}
#define FOUND_ENTRYID   0x01
#define FOUND_DISTLIST  0x02
#define FOUND_EMAIL     0x04

// =============================================================================
// CWabal::ValidateForSending()
// =============================================================================
HRESULT CWabal::IsValidForSending()
{
    DWORD       dwMask = 0;
    ADRENTRY    *pAE = NULL;

    if (m_cActualEntries == 0)
        return hrNoRecipients;

    // walk thro' the list and make sure everyone has an entry-id and email name
    AssertSz(m_lpAdrList, "How can this be NULL with >0 entries?");

    for (ULONG ul=0; ul < m_cActualEntries; ul++)
    {
        dwMask = 0;

        pAE = &m_lpAdrList->aEntries[ul];
        for (ULONG ulProp=0; ulProp < pAE->cValues; ulProp++)
        {
            switch (pAE->rgPropVals[ulProp].ulPropTag)
            {
            case PR_ENTRYID:
                dwMask |= FOUND_ENTRYID;
                break;

            case PR_OBJECT_TYPE:
                if (pAE->rgPropVals[ulProp].Value.l==MAPI_DISTLIST)
                    dwMask |= FOUND_DISTLIST;
                break;

            case PR_RECIPIENT_TYPE:
                if ((pAE->rgPropVals[ulProp].Value.l==MAPI_ORIG) &&
                    (m_cActualEntries == 1))
                    return hrNoRecipients;
                break;

            case PR_EMAIL_ADDRESS:
            case PR_EMAIL_ADDRESS_W:
                dwMask |= FOUND_EMAIL;
                break;
            }
        }

        // Fail if we don't have and email address, or we don't have a distList and an entryID
        if (!((dwMask & FOUND_EMAIL) || ((dwMask & FOUND_ENTRYID) && (dwMask & FOUND_DISTLIST))))
            return hrEmptyRecipientAddress;
    }
    return S_OK;
}


// =============================================================================
// CWabal::HrCopyTo
// =============================================================================
HRESULT CWabal::HrCopyTo (LPWABAL lpWabal)
{
    // Locals
    HRESULT             hr = S_OK;
    ADRINFO             rAdrInfo;
    BOOL                fFound;

    // Reset the destination
    lpWabal->Reset ();

    // Iterate through addresses
    fFound = FGetFirst (&rAdrInfo);
    while (fFound)
    {
        // Add it into lpWabal
        CHECKHR (hr = lpWabal->HrAddEntry (&rAdrInfo));

        // Get the next address
        fFound = FGetNext (&rAdrInfo);
    }

exit:
    // Done
    return hr;
}

// =============================================================================
// CWabal::Reset
// =============================================================================
VOID CWabal::Reset (VOID)
{
    // Are we ready
    if (FVerifyState () == FALSE)
        return;

    // If we have an address list, blow it away
    if (m_lpAdrList)
    {
        // Free propvals
        for (ULONG i=0; i<m_lpAdrList->cEntries; i++)
            m_lpWabObject->FreeBuffer (m_lpAdrList->aEntries[i].rgPropVals);

        // Free Address List
        m_lpWabObject->FreeBuffer (m_lpAdrList);
        m_lpAdrList = NULL;
    }

    // Reset actual entries
    m_cActualEntries = 0;
}

// =============================================================================
// CWabal::HrGetFirst
// =============================================================================
BOOL CWabal::FGetFirst (LPADRINFO lpAdrInfo)
{
    // Verify State
    if (FVerifyState () == FALSE)
        return FALSE;

    // Nothing in my list
    if (m_lpAdrList == NULL || m_cActualEntries == 0)
        return FALSE;

    // Set cookie in addrinfo
    lpAdrInfo->dwReserved = 0;

    AdrEntryToAdrInfo(&m_lpAdrList->aEntries[lpAdrInfo->dwReserved], lpAdrInfo);

    // Set associated message
    lpAdrInfo->pMsg = (lpAdrInfo->lRecipType == MAPI_ORIG) ? m_pMsg : NULL;

    return TRUE;
}

// =============================================================================
// CWabal::HrGetNext
// =============================================================================
BOOL CWabal::FGetNext (LPADRINFO lpAdrInfo)
{
    // Verify State
    if (FVerifyState () == FALSE)
        return NULL;

    // Go to next address
    lpAdrInfo->dwReserved++;

    // Anymore
    if (lpAdrInfo->dwReserved >= m_cActualEntries)
        return FALSE;

    AdrEntryToAdrInfo(&m_lpAdrList->aEntries[lpAdrInfo->dwReserved], lpAdrInfo);

    // Set associated message
    lpAdrInfo->pMsg = (lpAdrInfo->lRecipType == MAPI_ORIG) ? m_pMsg : NULL;

    // Done
    return TRUE;
}

BOOL CWabal::FFindFirst(LPADRINFO lpAdrInfo, LONG lRecipType)
{

    if (FGetFirst(lpAdrInfo))
        do
        if (lpAdrInfo->lRecipType==lRecipType)
            return TRUE;
        while(FGetNext(lpAdrInfo));
    return FALSE;
}


// =============================================================================
// CWabal::LpGetNext
// =============================================================================
HRESULT CWabal::HrResolveNames (HWND hwndParent, BOOL fShowDialog)
{
    // Locals
    HRESULT             hr = S_OK;
    HCURSOR             hcur=NULL;
    HWND                hwndFocus = GetFocus();
    ULONG               ulFlags = WAB_RESOLVE_USE_CURRENT_PROFILE | WAB_RESOLVE_ALL_EMAILS | WAB_RESOLVE_UNICODE;

    // Have we been initialized
    if (FVerifyState () == FALSE)
        return TRAPHR (E_FAIL);

    hcur = HourGlass();

    if(g_pConMan && g_pConMan->IsGlobalOffline())
        ulFlags |= WAB_RESOLVE_LOCAL_ONLY;

    // BUG: 23760: ResolveNames pumps messages against an LDAP server
    if (fShowDialog)
    {
        Assert(IsWindow(hwndParent));
        EnableWindow(GetTopMostParent(hwndParent), FALSE);
        ulFlags |= MAPI_DIALOG;
        hr = m_lpAdrBook->ResolveName ((ULONG_PTR)hwndParent, ulFlags, NULL, m_lpAdrList);
        EnableWindow(GetTopMostParent(hwndParent), TRUE);
        //BUG: user can't put focus back on our dialog wnd for us as we disabled
        // the window and the progress dialog got a wm_destroy before we return
        // so we cache the focus and set ut back
        if (hwndFocus)
            SetFocus(hwndFocus);
    }
    else
        hr = m_lpAdrBook->ResolveName ((ULONG_PTR)hwndParent, ulFlags, NULL, m_lpAdrList);

    if (hcur)
        SetCursor(hcur);
    // Done
    return hr;
}

// =============================================================================
// SzWabStringDup
// =============================================================================
LPTSTR SzWabStringDup (LPWABOBJECT lpWab, LPCTSTR pcsz, LPVOID lpParentObject)
{
    // Locals
    LPTSTR pszDup;
    ULONG cb;
    HRESULT hr;

    Assert (lpWab);

    if (pcsz == NULL)
        return NULL;

    INT nLen = lstrlen(pcsz) + 1;

    cb = nLen * sizeof(TCHAR);

    if (lpParentObject == NULL)
        hr = lpWab->AllocateBuffer (cb, (LPVOID *)&pszDup);
    else
        hr = lpWab->AllocateMore (cb, lpParentObject, (LPVOID *)&pszDup);

    if (!FAILED (hr) && pszDup)
        CopyMemory (pszDup, pcsz, cb);

    return pszDup;
}

LPWSTR SzWabStringDupW(LPWABOBJECT lpWab, LPCWSTR pcwsz, LPVOID lpParentObject)
{
    // Locals
    LPWSTR pwszDup;
    ULONG cb;
    HRESULT hr;

    Assert (lpWab);

    if (pcwsz == NULL)
        return NULL;

    INT nLen = lstrlenW(pcwsz) + 1;

    cb = nLen * sizeof(WCHAR);

    if (lpParentObject == NULL)
        hr = lpWab->AllocateBuffer (cb, (LPVOID *)&pwszDup);
    else
        hr = lpWab->AllocateMore (cb, lpParentObject, (LPVOID *)&pwszDup);

    if (!FAILED (hr) && pwszDup)
        CopyMemory (pwszDup, pcwsz, cb);

    return pwszDup;
}

// =============================================================================
// LpbWabBinaryDup
// =============================================================================
LPBYTE LpbWabBinaryDup(LPWABOBJECT lpWab, LPBYTE lpbSrc, ULONG cb, LPVOID lpParentObject)
{
    // Locals
    HRESULT hr;
    LPBYTE  pb=0;

    Assert (lpWab);
    Assert (lpbSrc);

    if (lpParentObject == NULL)
        hr = lpWab->AllocateBuffer (cb, (LPVOID *)&pb);
    else
        hr = lpWab->AllocateMore (cb, lpParentObject, (LPVOID *)&pb);

    if (pb)
        CopyMemory (pb, lpbSrc, cb);

    return pb;
}

// =============================================================================
// CWabal::HrAddUnresolved
// =============================================================================
HRESULT CWabal::HrAddUnresolved(LPWSTR lpwszDisplayName, LONG lRecipType)
{
    HRESULT         hr=NOERROR;
    ULONG           cb;
    LPADRENTRY      lpAdrEntry;

    Assert(lpwszDisplayName);

    // Do we need to grow m_lpAdrList ?
    if (m_lpAdrList == NULL || m_cActualEntries == m_lpAdrList->cEntries)
    {
        // Lets grow my current address list by GROW_SIZE
        CHECKHR (hr = HrGrowAdrlist (&m_lpAdrList, GROW_SIZE));
    }

    // Put new entry into m_cActualEntries
    lpAdrEntry=&m_lpAdrList->aEntries[m_cActualEntries];
    lpAdrEntry->cValues=2;
    cb = (2*sizeof(SPropValue)) + (lstrlenW(lpwszDisplayName)+1) * sizeof(WCHAR);
    // Allocate some memory
    hr = m_lpWabObject->AllocateBuffer (cb, (LPVOID *)&lpAdrEntry->rgPropVals);
    // Alloc failed ?
    if (FAILED (hr))
    {
        hr = TRAPHR (hrMemory);
        goto exit;
    }

    // Set the Properties
    lpAdrEntry->rgPropVals[0].ulPropTag = PR_DISPLAY_NAME_W;
    lpAdrEntry->rgPropVals[0].Value.lpszW=(LPWSTR)((DWORD_PTR)(lpAdrEntry->rgPropVals) + (DWORD)(2*sizeof(SPropValue)));
    StrCpyW(lpAdrEntry->rgPropVals[0].Value.lpszW, lpwszDisplayName);
    lpAdrEntry->rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE;
    lpAdrEntry->rgPropVals[1].Value.l= lRecipType;
    m_cActualEntries++;

exit:
    // Done
    return hr;

}

// =============================================================================
// HrSetAdrEntry
// =============================================================================
HRESULT HrSetAdrEntry (LPWABOBJECT lpWab, LPADRENTRY lpAdrEntry,
                       LPADRINFO lpAdrInfo, DWORD mask)
{
    // Locals
    HRESULT         hr = S_OK;
    ULONG           cValues;
    DWORD           dwAlloc;
    DWORD           cMaskBits;
    DWORD           mask2;

    // Allocate properties
    Assert (lpAdrEntry->rgPropVals == NULL);

    // BrettM laughed at me that I was passing the bit count into this function.
    // So, lets count them
    mask2 = mask;
    for (cMaskBits=0; mask2; cMaskBits++)
        mask2&=mask2-1;

    // Allocate some memory
    dwAlloc = ((cMaskBits) ? cMaskBits : AE_colLast) * sizeof (SPropValue);
    hr = lpWab->AllocateBuffer (dwAlloc, (LPVOID *)&lpAdrEntry->rgPropVals);

    // Alloc failed ?
    if (FAILED (hr))
    {
        hr = TRAPHR (hrMemory);
        goto exit;
    }

    // Zero init
    ZeroMemory (lpAdrEntry->rgPropVals, dwAlloc);

    // Set the Properties

    // Init Properties ?
    cValues = 0;
    if (lpAdrInfo)
    {
        // If the mask is empty, then we're doing all properties;
        // else, if the mask has the bit set, test for emptiness
        // and bang in a default; else skip it

        if (!mask || mask & AIM_DISPLAY)
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag = PR_DISPLAY_NAME_W;
            if (FIsStringEmptyW(lpAdrInfo->lpwszDisplay))
            {
                LPWSTR pwszDisplay;

                if (!FIsStringEmptyW(lpAdrInfo->lpwszAddress))
                    pwszDisplay = SzWabStringDupW(lpWab, lpAdrInfo->lpwszAddress, lpAdrEntry->rgPropVals);
                else
                {
                    WCHAR szUnknown[255];
                    AthLoadStringW(idsUnknown, szUnknown, ARRAYSIZE(szUnknown));
                    pwszDisplay = SzWabStringDupW(lpWab, szUnknown, lpAdrEntry->rgPropVals);
                }
                lpAdrEntry->rgPropVals[cValues].Value.lpszW = SzWabStringDupW(lpWab, pwszDisplay, lpAdrEntry->rgPropVals);
            }
            else
            {
                lpAdrEntry->rgPropVals[cValues].Value.lpszW = SzWabStringDupW(lpWab, lpAdrInfo->lpwszDisplay, lpAdrEntry->rgPropVals);
            }

            cValues++;
        }

        if (!mask || mask & AIM_ADDRESS)
        {
            if (!FIsStringEmptyW(lpAdrInfo->lpwszAddress))
            {
                lpAdrEntry->rgPropVals[cValues].ulPropTag = PR_EMAIL_ADDRESS_W;
                lpAdrEntry->rgPropVals[cValues].Value.lpszW = SzWabStringDupW(lpWab, lpAdrInfo->lpwszAddress, lpAdrEntry->rgPropVals);
                cValues++;

            }
        }

        if (!mask || mask & AIM_ADDRTYPE)
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag       = PR_ADDRTYPE_W;
            if (FIsStringEmptyW(lpAdrInfo->lpwszAddrType))
                lpAdrEntry->rgPropVals[cValues].Value.lpszW = SzWabStringDupW(lpWab, (LPWSTR)c_wszSMTP, lpAdrEntry->rgPropVals);
            else
                lpAdrEntry->rgPropVals[cValues].Value.lpszW = SzWabStringDupW(lpWab, lpAdrInfo->lpwszAddrType, lpAdrEntry->rgPropVals);

            cValues++;
        }

        if (lpAdrInfo->lpwszSurName && (!mask || mask & AIM_SURNAME))
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag       = PR_SURNAME_W;
            lpAdrEntry->rgPropVals[cValues++].Value.lpszW   = SzWabStringDupW(lpWab, lpAdrInfo->lpwszSurName, lpAdrEntry->rgPropVals);
        }

        if (lpAdrInfo->lpwszGivenName && (!mask || mask & AIM_GIVENNAME))
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag       = PR_GIVEN_NAME_W;
            lpAdrEntry->rgPropVals[cValues++].Value.lpszW   = SzWabStringDupW(lpWab, lpAdrInfo->lpwszGivenName, lpAdrEntry->rgPropVals);
        }

        if (!mask || mask & AIM_RECIPTYPE)
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag       = PR_RECIPIENT_TYPE;
            lpAdrEntry->rgPropVals[cValues++].Value.l       = lpAdrInfo->lRecipType;
        }

        if (lpAdrInfo->tbCertificate.pBlobData && (!mask || mask & AIM_CERTIFICATE))
        {
            ThumbprintToPropValue(&lpAdrEntry->rgPropVals[cValues],
                &lpAdrInfo->tbCertificate,
                &lpAdrInfo->blSymCaps,
                lpAdrInfo->ftSigningTime,
                lpAdrInfo->fDefCertificate);
            cValues++;
        }

        if (lpAdrInfo->cbEID && (!mask || mask & AIM_EID))
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag     = PR_ENTRYID;
            lpAdrEntry->rgPropVals[cValues].Value.bin.cb  = lpAdrInfo->cbEID;
            lpAdrEntry->rgPropVals[cValues].Value.bin.lpb =
                LpbWabBinaryDup(lpWab, lpAdrInfo->lpbEID, lpAdrInfo->cbEID, lpAdrEntry->rgPropVals);
            if (lpAdrEntry->rgPropVals[cValues].Value.bin.lpb==NULL)
            {
                hr=E_OUTOFMEMORY;
                goto exit;
            }
            cValues++;
        }

        if (!mask || mask & AIM_OBJECTTYPE)
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag = PR_OBJECT_TYPE;
            lpAdrEntry->rgPropVals[cValues++].Value.l=lpAdrInfo->fDistList?MAPI_DISTLIST:MAPI_MAILUSER;
        }

        if (!mask || mask & AIM_INTERNETENCODING)
        {
            lpAdrEntry->rgPropVals[cValues].ulPropTag       = PR_SEND_INTERNET_ENCODING;
            lpAdrEntry->rgPropVals[cValues++].Value.l=lpAdrInfo->fPlainText?BODY_ENCODING_TEXT:BODY_ENCODING_TEXT_AND_HTML;
        }

    }

#ifdef DEBUG
    if (cMaskBits && cValues > cMaskBits)
        AssertSz(0, TEXT("Bad... the mask bits don't cover our mem usage"));
#endif

    DOUTL(4, "HrSetAdrEntry: lRecip=%d", lpAdrInfo->lRecipType);

    // Set number of values
    // use cValues since we may have skipped some due to null params and therefore
    // cMaskBits >= cValues (t-erikne)
    lpAdrEntry->cValues = cValues;

exit:
    // Done
    return hr;
}

// =============================================================================
// CWabal::HrAllocAdrList
// =============================================================================
HRESULT CWabal::HrGrowAdrlist (LPADRLIST *lppalCurr, ULONG caeToAdd)
{
    // Locals
    HRESULT         hr = S_OK;
    ULONG           i, j, cbNew, cbCurr = 0;
    LPADRLIST       lpalNew = NULL;

    // Determine number of bytes needed
    cbNew = sizeof(ADRLIST) + caeToAdd * sizeof(ADRENTRY);

    // Determine number of entries currently in address list
    if (*lppalCurr)
    {
        cbCurr = (UINT)((*lppalCurr)->cEntries * sizeof(ADRENTRY));
    }

    // Add current cb
    cbNew += cbCurr;

    // Allocate new buffer
    hr = m_lpWabObject->AllocateBuffer (cbNew, (LPVOID *)&lpalNew);
    if (FAILED (hr))
    {
        hr = TRAPHR (hrMemory);
        goto exit;
    }

    // If current address list ?
    if (*lppalCurr)
    {
        // Copy Current Address list into new address list
        CopyMemory (lpalNew, *lppalCurr, sizeof (ADRLIST) + cbCurr);

        // Free current buffer
        m_lpWabObject->FreeBuffer (*lppalCurr);

        // Reset pointer
        *lppalCurr = NULL;
    }

    else
        lpalNew->cEntries = 0;

    // Update entries count
    //N seems like we don't need j, just offset the i count by this much?
    j = lpalNew->cEntries;
    lpalNew->cEntries += caeToAdd;

    // Mark new ADRENTRY's as empty and allocate the propvalue array
    for (i=0; i<caeToAdd; i++)
    {
        // Zero init adrentry
        ZeroMemory (&lpalNew->aEntries[j+i], sizeof (ADRENTRY));
    }

    // Assume new pointer
    *lppalCurr = lpalNew;

exit:
    // Done
    return hr;
}



void CWabal::AdrEntryToAdrInfo(LPADRENTRY lpAdrEntry, LPADRINFO lpAdrInfo)
{
    ULONG           ul,
                    cValues;
    LPSPropValue    ppv;

    //N look at some kind of {} init
    lpAdrInfo->lpwszAddress = NULL;
    lpAdrInfo->lpwszAddrType = NULL;
    lpAdrInfo->lpwszDisplay = NULL;
    lpAdrInfo->lpwszSurName = NULL;
    lpAdrInfo->lpwszGivenName = NULL;
    lpAdrInfo->lRecipType = -1;
    lpAdrInfo->fResolved = FALSE;
    lpAdrInfo->fDistList = FALSE;
    lpAdrInfo->fPlainText = FALSE;
    lpAdrInfo->fDefCertificate = FALSE;
    lpAdrInfo->tbCertificate.pBlobData = (BYTE*)0;
    lpAdrInfo->tbCertificate.cbSize = 0;
    lpAdrInfo->blSymCaps.pBlobData = (BYTE*)0;
    lpAdrInfo->blSymCaps.cbSize = 0;
    lpAdrInfo->ftSigningTime.dwLowDateTime = lpAdrInfo->ftSigningTime.dwHighDateTime = 0;
    lpAdrInfo->cbEID=0;
    lpAdrInfo->lpbEID=0;

    cValues=lpAdrEntry->cValues;
    AssertSz(cValues, "An empty addrentry?");
    ppv=lpAdrEntry->rgPropVals;

    for(ul=0; ul<cValues; ul++, ppv++)
        PropValToAdrInfo(ppv, lpAdrInfo);

    DOUTL(4, "AddrEntry2AddrInfo: lRecip=%d", lpAdrInfo->lRecipType);
    AssertSz(lpAdrInfo->lpwszAddress==NULL ||
                lpAdrInfo->lRecipType != -1, "A resolved entry should have a recip type!");
}

HRESULT CWab::HrDetails(HWND hwndOwner, LPADRINFO *lplpAdrInfo)
{
    HRESULT         hr;
    HWND            hwnd=hwndOwner;
    LPADRINFO       lpAdrInfoNew=0;
    ADRINFO         adrInfo;
    LPMAPIPROP      pmp=0;
    LPSPropValue    ppv=0;
    ULONG           ul;
    HCURSOR         hcur=NULL;
    SizedSPropTagArray(2, tagNewProps)=
        {2, {PR_EMAIL_ADDRESS_W, PR_DISPLAY_NAME_W}};

    if (!m_lpAdrBook)
        return E_FAIL;

    if (!lplpAdrInfo || !*lplpAdrInfo)
        return E_INVALIDARG;

    hcur = HourGlass();

    hr=m_lpAdrBook->Details((ULONG_PTR *)&hwnd, NULL, NULL, (*lplpAdrInfo)->cbEID, (LPENTRYID)(*lplpAdrInfo)->lpbEID, NULL, NULL, NULL, 0);

    // re-read the props that may have changed...

    CopyMemory(&adrInfo, *lplpAdrInfo, sizeof(ADRINFO));

    hr=m_lpAdrBook->OpenEntry((*lplpAdrInfo)->cbEID, (LPENTRYID)(*lplpAdrInfo)->lpbEID,
                              &IID_IMAPIProp, 0, &ul, (LPUNKNOWN *)&pmp);
    if (FAILED(hr))
        goto error;

    hr=pmp->GetProps((LPSPropTagArray)&tagNewProps, 0, &ul, &ppv);
    if (FAILED(hr))
        goto error;

    adrInfo.lpwszAddress = ppv[0].ulPropTag == PR_EMAIL_ADDRESS_W ? ppv[0].Value.lpszW : NULL;
    adrInfo.lpwszDisplay = ppv[1].ulPropTag == PR_DISPLAY_NAME_W ? ppv[1].Value.lpszW : NULL;

    hr=HrDupeAddrInfo(&adrInfo, &lpAdrInfoNew);
    if (FAILED(hr))
        goto error;

    // release the old, and replace with the new
    MemFree(*lplpAdrInfo);
    *lplpAdrInfo=lpAdrInfoNew;

error:
    ReleaseObj(pmp);
    if (ppv)
        m_lpWabObject->FreeBuffer(ppv);
    if (hcur)
        SetCursor(hcur);
    return hr;
}


HRESULT HrDupeAddrInfo(LPADRINFO lpAdrInfo, LPADRINFO *lplpAdrInfo)
{
    ULONG   cb=0;
    LPBYTE  pb;

    if (!lpAdrInfo || !lplpAdrInfo)
        return E_INVALIDARG;

    *lplpAdrInfo=NULL;

    cb=CbAdrInfoSize(lpAdrInfo);

#ifdef _WIN64
    cb = LcbAlignLcb(cb);
#endif

    if (!MemAlloc((LPVOID *)lplpAdrInfo, cb))
        return E_OUTOFMEMORY;

    ZeroMemory(*lplpAdrInfo, cb);
    pb=(LPBYTE)*lplpAdrInfo + sizeof(ADRINFO);

#ifdef _WIN64
        pb = MyPbAlignPb(pb);
#endif // _WIN64

    if (lpAdrInfo->lpwszAddress)
    {
        StrCpyW((LPWSTR)pb, lpAdrInfo->lpwszAddress);
        (*lplpAdrInfo)->lpwszAddress=(LPWSTR)pb;
        pb+=(lstrlenW(lpAdrInfo->lpwszAddress)+1)*sizeof(WCHAR);
#ifdef _WIN64
        pb = MyPbAlignPb(pb);
#endif // _WIN64

    }
    if (lpAdrInfo->lpwszDisplay)
    {
        StrCpyW((LPWSTR)pb, lpAdrInfo->lpwszDisplay);
        (*lplpAdrInfo)->lpwszDisplay=(LPWSTR)pb;
        pb+=(lstrlenW(lpAdrInfo->lpwszDisplay)+1)*sizeof(WCHAR);
#ifdef _WIN64
        pb = MyPbAlignPb(pb);
#endif // _WIN64
    }
    if (lpAdrInfo->lpwszAddrType)
    {
        StrCpyW((LPWSTR)pb, lpAdrInfo->lpwszAddrType);
        (*lplpAdrInfo)->lpwszAddrType=(LPWSTR)pb;
        pb+=(lstrlenW(lpAdrInfo->lpwszAddrType)+1)*sizeof(WCHAR);
#ifdef _WIN64
        pb = MyPbAlignPb(pb);
#endif // _WIN64
    }
    if (lpAdrInfo->lpwszSurName)
    {
        StrCpyW((LPWSTR)pb, lpAdrInfo->lpwszSurName);
        (*lplpAdrInfo)->lpwszSurName=(LPWSTR)pb;
        pb+=(lstrlenW(lpAdrInfo->lpwszSurName)+1)*sizeof(WCHAR);
#ifdef _WIN64
        pb = MyPbAlignPb(pb);
#endif // _WIN64
    }
    if (lpAdrInfo->lpwszGivenName)
    {
        StrCpyW((LPWSTR)pb, lpAdrInfo->lpwszGivenName);
        (*lplpAdrInfo)->lpwszGivenName=(LPWSTR)pb;
        pb+=(lstrlenW(lpAdrInfo->lpwszGivenName)+1)*sizeof(WCHAR);
#ifdef _WIN64
        pb = MyPbAlignPb(pb);
#endif // _WIN64
    }

    // Certificate properties
    (*lplpAdrInfo)->tbCertificate.cbSize = lpAdrInfo->tbCertificate.cbSize;
    (*lplpAdrInfo)->tbCertificate.pBlobData = lpAdrInfo->tbCertificate.pBlobData;
    (*lplpAdrInfo)->blSymCaps.cbSize = lpAdrInfo->blSymCaps.cbSize;
    (*lplpAdrInfo)->blSymCaps.pBlobData = lpAdrInfo->blSymCaps.pBlobData;
    (*lplpAdrInfo)->ftSigningTime.dwLowDateTime = lpAdrInfo->ftSigningTime.dwLowDateTime;
    (*lplpAdrInfo)->ftSigningTime.dwHighDateTime = lpAdrInfo->ftSigningTime.dwHighDateTime;
    (*lplpAdrInfo)->fDefCertificate = lpAdrInfo->fDefCertificate;

    (*lplpAdrInfo)->lRecipType=lpAdrInfo->lRecipType;
    (*lplpAdrInfo)->fResolved=lpAdrInfo->fResolved;
    (*lplpAdrInfo)->fDistList=lpAdrInfo->fDistList;
    (*lplpAdrInfo)->fPlainText=lpAdrInfo->fPlainText;
    (*lplpAdrInfo)->pMsg =lpAdrInfo->pMsg;

    if (lpAdrInfo->cbEID)
    {
        (*lplpAdrInfo)->lpbEID=(LPBYTE)pb;
        (*lplpAdrInfo)->cbEID=lpAdrInfo->cbEID;
        CopyMemory(pb, lpAdrInfo->lpbEID, lpAdrInfo->cbEID);
    }
    return NOERROR;
}

ULONG CbAdrInfoSize(LPADRINFO lpAdrInfo)
{
    ULONG   cb=sizeof(ADRINFO);

#ifdef _WIN64
        cb = LcbAlignLcb(cb);
#endif
    Assert(lpAdrInfo);

    if (lpAdrInfo->lpwszAddress)
    {
        cb+=(lstrlenW(lpAdrInfo->lpwszAddress)+1)*sizeof(WCHAR);
#ifdef _WIN64
        cb = LcbAlignLcb(cb);
#endif
    }
    if (lpAdrInfo->lpwszDisplay)
    {
        cb+=(lstrlenW(lpAdrInfo->lpwszDisplay)+1)*sizeof(WCHAR);
#ifdef _WIN64
        cb = LcbAlignLcb(cb);
#endif
    }
    if (lpAdrInfo->lpwszAddrType)
    {
        cb+=(lstrlenW(lpAdrInfo->lpwszAddrType)+1)*sizeof(WCHAR);
#ifdef _WIN64
        cb = LcbAlignLcb(cb);
#endif
    }
    if (lpAdrInfo->lpwszSurName)
    {
        cb+=(lstrlenW(lpAdrInfo->lpwszSurName)+1)*sizeof(WCHAR);
#ifdef _WIN64
        cb = LcbAlignLcb(cb);
#endif
    }
    if (lpAdrInfo->lpwszGivenName)
    {
        cb+=(lstrlenW(lpAdrInfo->lpwszGivenName)+1)*sizeof(WCHAR);
#ifdef _WIN64
        cb = LcbAlignLcb(cb);
#endif
    }
    cb+=lpAdrInfo->cbEID;

    return cb;
}

void SerialAdrInfoString(LPWSTR *ppwszDest, LPWSTR pwszSrc, ULONG *pcbOff, LPBYTE *ppbData)
{
    ULONG   cb;

    if (pwszSrc)
    {
        (*ppwszDest)=(LPWSTR)((ULONG_PTR)(*pcbOff));
        StrCpyW((LPWSTR)(*ppbData), pwszSrc);
        cb=(lstrlenW(pwszSrc)+1)*sizeof(WCHAR);
        (*ppbData)+=cb;
        (*pcbOff)+=cb;
    }
}


HRESULT HrCreateWabalObjectFromHGlobal(HGLOBAL hGlobal, LPWABAL *lplpWabal)
{
    HRESULT         hr;
    LPWABAL         lpWabal=0;
    LPADRINFOLIST   lpAdrInfoList;
    LPADRINFOLIST   lpAdrInfoListNew;
    LPADRINFO       lpAdrInfo;
    ULONG           cb,
                    uRow;

    if (!lplpWabal)
        return E_INVALIDARG;

    if (!hGlobal)
        return E_INVALIDARG;

    hr=HrCreateWabalObject(&lpWabal);
    if (FAILED(hr))
        return hr;

    cb = (ULONG) GlobalSize(hGlobal);

    // create a new 'unflattened' addr info list
    if (!MemAlloc((LPVOID *)&lpAdrInfoListNew, cb))
        return E_OUTOFMEMORY;

    ZeroMemory(lpAdrInfoListNew, cb);

    lpAdrInfoList=(LPADRINFOLIST)GlobalLock(hGlobal);
    if (!lpAdrInfoList)
    {
        MemFree(lpAdrInfoListNew);
        return E_FAIL;
    }

    // copy the flat data
    CopyMemory(lpAdrInfoListNew, lpAdrInfoList, cb);
    lpAdrInfoListNew->rgAdrInfo=(LPADRINFO)((DWORD_PTR)lpAdrInfoListNew->rgAdrInfo + (DWORD_PTR)lpAdrInfoListNew);
    lpAdrInfo=lpAdrInfoListNew->rgAdrInfo;

    // patch the pointers...
    for(uRow=0; uRow<lpAdrInfoListNew->cValues; uRow++, lpAdrInfo++)
    {
        // All the address offsets are in bytes. Make sure we convert to chars.
        if (lpAdrInfo->lpwszAddress)
            lpAdrInfo->lpwszAddress += (DWORD_PTR)lpAdrInfoListNew/sizeof(WCHAR);
        if (lpAdrInfo->lpwszDisplay)
            lpAdrInfo->lpwszDisplay += (DWORD_PTR)lpAdrInfoListNew/sizeof(WCHAR);
        if (lpAdrInfo->lpwszAddrType)
            lpAdrInfo->lpwszAddrType += (DWORD_PTR)lpAdrInfoListNew/sizeof(WCHAR);
        if (lpAdrInfo->lpwszSurName)
            lpAdrInfo->lpwszSurName += (DWORD_PTR)lpAdrInfoListNew/sizeof(WCHAR);
        if (lpAdrInfo->lpwszGivenName)
            lpAdrInfo->lpwszGivenName += (DWORD_PTR)lpAdrInfoListNew/sizeof(WCHAR);
        if (lpAdrInfo->lpbEID)
            lpAdrInfo->lpbEID+=(DWORD_PTR)lpAdrInfoListNew;
    }

    // now add it all to the wabal

    lpAdrInfo=lpAdrInfoListNew->rgAdrInfo;
    for(uRow=0; uRow<lpAdrInfoListNew->cValues; uRow++, lpAdrInfo++)
        {
        if (lpAdrInfo->fResolved)
            lpWabal->HrAddEntry(lpAdrInfo);
        else
            lpWabal->HrAddUnresolved(lpAdrInfo->lpwszDisplay, -1);
        }
    *lplpWabal=lpWabal;
    GlobalUnlock(hGlobal);
    MemFree(lpAdrInfoListNew);
    return NOERROR;
}



HRESULT CWabal::HrBuildHGlobal(HGLOBAL *phGlobal)
{
    HGLOBAL         hGlobal=0;
    ADRINFO         adrInfo;
    ULONG           cbAlloc,
#ifdef DEBUG
                    cFound=0,
#endif
                    cb;
    LPADRINFOLIST   lpAdrInfoList;
    ULONG           cbOff;
    LPADRINFO       lpAdrInfo;
    LPBYTE          pbData;

    if (!phGlobal)
        return E_INVALIDARG;

    *phGlobal=0;

    cbAlloc=sizeof(ADRINFOLIST);

    if (FGetFirst(&adrInfo))
    {
        do
        cbAlloc+=CbAdrInfoSize(&adrInfo);
        while(FGetNext(&adrInfo));
    }
    else
        return E_FAIL;

    hGlobal=GlobalAlloc(GMEM_SHARE|GHND, cbAlloc);
    if (!hGlobal)
        return E_OUTOFMEMORY;

    lpAdrInfoList=(LPADRINFOLIST)GlobalLock(hGlobal);
    if (!lpAdrInfoList)
    {
        GlobalFree(hGlobal);
        return E_FAIL;
    }

    cbOff=sizeof(ADRINFOLIST);
    lpAdrInfoList->rgAdrInfo=(LPADRINFO)((ULONG_PTR)cbOff);
    lpAdrInfo=(LPADRINFO)((DWORD_PTR)lpAdrInfoList+cbOff);
    cbOff+=m_cActualEntries*sizeof(ADRINFO);
    lpAdrInfoList->cValues=m_cActualEntries;
    pbData=(LPBYTE)((DWORD_PTR)lpAdrInfoList+cbOff);


    SideAssert(FGetFirst(&adrInfo));       // there HAS to be entries at this point!

    do
    {
        // copy the flat data
        CopyMemory(lpAdrInfo, &adrInfo, sizeof(ADRINFO));

        // patch the pointers...
        SerialAdrInfoString(&lpAdrInfo->lpwszAddress, adrInfo.lpwszAddress, &cbOff, &pbData);
        SerialAdrInfoString(&lpAdrInfo->lpwszDisplay, adrInfo.lpwszDisplay, &cbOff, &pbData);
        SerialAdrInfoString(&lpAdrInfo->lpwszAddrType, adrInfo.lpwszAddrType, &cbOff, &pbData);
        SerialAdrInfoString(&lpAdrInfo->lpwszSurName, adrInfo.lpwszSurName, &cbOff, &pbData);
        SerialAdrInfoString(&lpAdrInfo->lpwszGivenName, adrInfo.lpwszGivenName, &cbOff, &pbData);
        AssertSz(lpAdrInfo->cbEID==adrInfo.cbEID, "this should have been copied already");
        cb=lpAdrInfo->cbEID;
        if (cb)
        {
            lpAdrInfo->lpbEID=(LPBYTE)((ULONG_PTR)cbOff);
            CopyMemory(pbData, adrInfo.lpbEID, cb);
            cbOff+=cb;
            pbData+=cb;
        }
        lpAdrInfo++;
#ifdef DEBUG
        cFound++;
#endif
    }
    while(FGetNext(&adrInfo));

#ifdef DEBUG
    Assert(cFound==m_cActualEntries);
#endif
    GlobalUnlock(hGlobal);
    *phGlobal=hGlobal;

    return NOERROR;
}

HRESULT CWabal::HrRulePickNames(HWND hwndParent, LONG lRecipType, UINT uidsCaption, UINT uidsWell, UINT uidsWellButton)
{
    // Locals
    HRESULT         hr=S_OK;
    ADRPARM         rAdrParms={0};
    LPWAB           lpWab=0;
    WCHAR           wszRes1[255],
                    wszRes2[255],
                    wszRes3[255];
    ULONG           uRow;
    LPWSTR          rgwszWells[1] = { wszRes3 };

    if (m_lpAdrList == NULL || m_cActualEntries == m_lpAdrList->cEntries)
        {
        // Lets grow my current address list by GROW_SIZE
        CHECKHR (hr = HrGrowAdrlist (&m_lpAdrList, GROW_SIZE));
        }

    AthLoadStringW(uidsCaption, wszRes1, ARRAYSIZE(wszRes1));
    AthLoadStringW(uidsWell, wszRes2, ARRAYSIZE(wszRes2));
    AthLoadStringW(uidsWellButton, wszRes3, ARRAYSIZE(wszRes3));

    rAdrParms.ulFlags = DIALOG_MODAL|MAPI_UNICODE;
    rAdrParms.lpszCaption = (LPTSTR)wszRes1;
    rAdrParms.lpszDestWellsTitle = (LPTSTR)wszRes2;
    rAdrParms.cDestFields = 1;
    rAdrParms.nDestFieldFocus = 0;
    rAdrParms.lppszDestTitles = (LPTSTR*)rgwszWells;
    rAdrParms.lpulDestComps = (ULONG *)&lRecipType;

    CHECKHR(hr=HrCreateWabObject(&lpWab));

    hr=lpWab->HrGeneralPickNames(hwndParent, &rAdrParms, &m_lpAdrList);

    CHECKHR(hr);
    //HACKHACK: ugh, this is nasty, the pal mayhave been realloced, or maybe
    // our old pal, need to figure out how many real entries are in it...

    m_cActualEntries=0;

    if (m_lpAdrList)
        {
        for(uRow=0; uRow<m_lpAdrList->cEntries; uRow++)
            if (m_lpAdrList->aEntries[uRow].cValues)
                m_cActualEntries++;
        }

exit:
    ReleaseObj(lpWab);
    return hr;
}

HRESULT CWabal::HrPickNames (HWND hwndParent, ULONG *rgulTypes, int cWells, int iFocus, BOOL fNews)
{
    HRESULT         hr;
    LPWAB           lpWab=0;
    ULONG           uRow;

    if (m_lpAdrList == NULL || m_cActualEntries == m_lpAdrList->cEntries)
    {
        // Lets grow my current address list by GROW_SIZE
        CHECKHR (hr = HrGrowAdrlist (&m_lpAdrList, GROW_SIZE));
    }

    CHECKHR(hr=HrCreateWabObject(&lpWab));

    hr=lpWab->HrPickNames(hwndParent, rgulTypes, cWells, iFocus, fNews, &m_lpAdrList);

    CHECKHR(hr);
    //HACKHACK: ugh, this is nasty, the pal mayhave been realloced, or maybe
    // our old pal, need to figure out how many real entries are in it...

    m_cActualEntries=0;

    if (m_lpAdrList)
    {
        for(uRow=0; uRow<m_lpAdrList->cEntries; uRow++)
            if (m_lpAdrList->aEntries[uRow].cValues)
                m_cActualEntries++;
    }

exit:
    ReleaseObj(lpWab);
    return hr;
}

#ifdef ADDTOWAB_COPYENTRIES
HRESULT CWab::HrAddToWAB(HWND hwndOwner, LPADRINFO lpAdrInfo)
{
    HRESULT         hr;
    HCURSOR         hcur;
    LPABCONT        pabcWAB=NULL;
    ULONG           cbEidWAB,
                    ul;
    LPENTRYID       peidWAB=0;
    SBinary         bin;
    ENTRYLIST       el={0, &bin};

    if (!lpAdrInfo)
        return E_INVALIDARG;

    hcur=SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr=m_lpAdrBook->GetPAB(&cbEidWAB, &peidWAB);
    if (FAILED(hr))
        goto error;

    hr=m_lpAdrBook->OpenEntry(cbEidWAB, peidWAB, NULL,
                                0, &ul, (LPUNKNOWN *)&pabcWAB);
    if (FAILED(hr))
        goto error;

    m_lpWabObject->FreeBuffer(peidWAB);
    Assert(ul == MAPI_ABCONT);

    bin.cb=lpAdrInfo->cbEID;
    bin.lpb=lpAdrInfo->lpbEID;

    hr=pabcWAB->CopyEntries(&el, (ULONG)hwndOwner, NULL, CREATE_CHECK_DUP_STRICT);
    if (FAILED(hr))
        goto error;


error:
    ReleaseObj(pabcWAB);
    if (hcur)
        SetCursor(hcur);

    return hr;
}
#endif


HRESULT CWab::HrAddToWAB(HWND hwndOwner, LPADRINFO lpAdrInfo, LPMAPIPROP * lppMailUser)
{
    HRESULT         hr;
    HCURSOR         hcur;
    LPABCONT        pabcWAB=NULL;
    ULONG           cbEidWAB,
                    ul;
    LPENTRYID       peidWAB=0;
    LPMAPIPROP      lpProps=0,
                    lpPropsUser=0;
    DWORD           cUsedValues;
    SPropValue      rgpv[3];
    SPropTagArray   ptaEID = {1, {PR_ENTRYID}};
    LPSPropValue    ppv=0,
                    ppvDefMailUser=0,
                    ppvUser=0;
    ULONG           cUserProps=0;
    ENTRYLIST       el;
    SBinary         sbin;
    SizedSPropTagArray(1, ptaDefMailUser)=
        { 1, {PR_DEF_CREATE_MAILUSER} };

    if (!lpAdrInfo)
        return E_INVALIDARG;

    hcur=SetCursor(LoadCursor(NULL, IDC_WAIT));

    hr=m_lpAdrBook->GetPAB(&cbEidWAB, &peidWAB);
    if (FAILED(hr))
        goto error;

    hr=m_lpAdrBook->OpenEntry(cbEidWAB, peidWAB, NULL,
                                0, &ul, (LPUNKNOWN *)&pabcWAB);
    if (FAILED(hr))
        goto error;

    m_lpWabObject->FreeBuffer(peidWAB);
    Assert(ul == MAPI_ABCONT);


    hr=pabcWAB->GetProps((LPSPropTagArray)&ptaDefMailUser, 0, &ul, &ppvDefMailUser);
    if (FAILED(hr) || !ppvDefMailUser || ppvDefMailUser->ulPropTag!=PR_DEF_CREATE_MAILUSER)
        goto error;

    hr=pabcWAB->CreateEntry(ppvDefMailUser->Value.bin.cb, (LPENTRYID)ppvDefMailUser->Value.bin.lpb,
                            CREATE_CHECK_DUP_STRICT, &lpProps);
    if (FAILED(hr))
        goto error;

    if (lpAdrInfo->lpbEID)
    {
        // if we have an entry for the user (could be an LDAP search), then let's copy across all the props
        // note. we still override these with the displayname props and possible cert props later on.
        if (m_lpAdrBook->OpenEntry(lpAdrInfo->cbEID, (LPENTRYID)lpAdrInfo->lpbEID, &IID_IMAPIProp, 0, &ul, (LPUNKNOWN *)&lpPropsUser)==S_OK)
        {
            Assert (ul == MAPI_MAILUSER);
            if (lpPropsUser->GetProps(NULL, 0, &cUserProps, &ppvUser)==S_OK)
            {
                for (ULONG u=0; u<cUserProps; u++)
                    if (ppvUser[u].ulPropTag == PR_ENTRYID)
                        ppvUser[u].ulPropTag = PR_NULL;

                    lpProps->SetProps(cUserProps, ppvUser, NULL);
                    m_lpWabObject->FreeBuffer(ppvUser);
            }
            lpPropsUser->Release();
        }
    }

    rgpv[0].ulPropTag = PR_DISPLAY_NAME_W;
    rgpv[0].Value.lpszW = lpAdrInfo->lpwszDisplay;
    rgpv[1].ulPropTag = PR_EMAIL_ADDRESS_W;
    rgpv[1].Value.lpszW = lpAdrInfo->lpwszAddress;
    cUsedValues = 2;
    if (lpAdrInfo->pMsg)
    {
        HCERTSTORE hc, hcMsg;
        THUMBBLOB tbSigner = {0};
        BLOB blSymCaps = {0};
        FILETIME ftSigningTime = {0};
        PCCERT_CONTEXT pcSigningCert = NULL;
        PROPVARIANT var;
        IMimeBody *pBody = NULL;
        HBODY      hBody = NULL;

        // Does this message have a sender cert?
        if (SUCCEEDED(GetSigningCert(lpAdrInfo->pMsg, &pcSigningCert, &tbSigner, &blSymCaps, &ftSigningTime)))
        {
            // Get the sender's cert from the message and add it to the AddressBook cert store
            if (hc = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                        X509_ASN_ENCODING, NULL,
                        CERT_SYSTEM_STORE_CURRENT_USER, c_szWABCertStore))
            {
                CertAddCertificateContextToStore(hc, pcSigningCert,
                        CERT_STORE_ADD_REPLACE_EXISTING, NULL);
                CertFreeCertificateContext(pcSigningCert);
                CertCloseStore(hc, 0);
            }

            // Add the CA certs
            // Get the hcMsg property from the message

            if(FAILED(hr = HrGetInnerLayer(lpAdrInfo->pMsg, &hBody)))
                goto ex;

            if (SUCCEEDED(lpAdrInfo->pMsg->BindToObject(hBody ? hBody : HBODY_ROOT, IID_IMimeBody, (void **)&pBody)))
            {
#ifdef _WIN64
                if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE_64, &var)))
                {
                    hcMsg = (HCERTSTORE)(var.pulVal);     // Closed in WM_DESTROY
#else // !_WIN64
                if (SUCCEEDED(pBody->GetOption(OID_SECURITY_HCERTSTORE, &var)))
                {
                    hcMsg = (HCERTSTORE) var.ulVal;     // Closed in WM_DESTROY
#endif
                    if (hcMsg) // message store containing certs
                    {
                        hc = CertOpenStore(CERT_STORE_PROV_SYSTEM_A,
                            X509_ASN_ENCODING, NULL,
                            CERT_SYSTEM_STORE_CURRENT_USER, c_szCACertStore);
                        if (hc)
                        {
                            HrSaveCACerts(hc, hcMsg);
                            CertCloseStore(hc, 0);
                        }
                        CertCloseStore(hcMsg, 0);   // was addref'd when we got it.
                    }
                }
                ReleaseObj(pBody);
            }

ex:
            if (SUCCEEDED(hr=ThumbprintToPropValue(&rgpv[cUsedValues],
                    &tbSigner,
                    &blSymCaps,
                    ftSigningTime,
                    TRUE)))         // Since we are creating the entry, this must be default.
                cUsedValues++;

            if (tbSigner.pBlobData)
                MemFree(tbSigner.pBlobData);

            if (blSymCaps.pBlobData)
                MemFree(blSymCaps.pBlobData);
        }
    }

    hr=lpProps->SetProps(cUsedValues, rgpv, NULL);
    if (FAILED(hr))
        goto error;

    hr=lpProps->SaveChanges(KEEP_OPEN_READONLY);
    if (FAILED(hr))
    {

//        if (tbSigner.pBlobData)
//            {   // There is a cert.  We should try to merge it into the existing entry.
//  BUGBUG: NYI
//
//            }
//            else

        goto error;
    }

    hr=lpProps->GetProps(&ptaEID, 0, &ul, &ppv);
    if (!FAILED(hr) && ppv && ppv->ulPropTag==PR_ENTRYID)
    {
        hr=m_lpAdrBook->Details((ULONG_PTR *)&hwndOwner, NULL, NULL, ppv->Value.bin.cb, (LPENTRYID)ppv->Value.bin.lpb, NULL, NULL, NULL, 0);
    }

    if (lppMailUser)
    {
        *lppMailUser = lpProps;
    }
    else
    {
        ReleaseObj(lpProps);
    }

    if (hr==MAPI_E_USER_CANCEL)
    {
        // the user canceled details, blow away the new entry, silent fail
        el.cValues=1;
        el.lpbin=&ppv->Value.bin;
        pabcWAB->DeleteEntries(&el, 0);
    }

error:
    ReleaseObj(pabcWAB);

    if (ppv)
        m_lpWabObject->FreeBuffer(ppv);

    if (ppvDefMailUser)
        m_lpWabObject->FreeBuffer(ppvDefMailUser);

    if (hcur)
        SetCursor(hcur);

    return hr;
}

HRESULT CWab::HrUpdateWABEntry(LPADRINFO lpAdrInfo, DWORD mask)
{
    HRESULT         hr;
    LPMAILUSER      lpMailUser = NULL;
    ULONG           ulObjType;
    ADRENTRY        adrentry = {0};

    if (!(lpAdrInfo->cbEID && lpAdrInfo->lpbEID))
        return E_INVALIDARG;

    if (FAILED(hr=m_lpAdrBook->OpenEntry(lpAdrInfo->cbEID, (LPENTRYID)lpAdrInfo->lpbEID,
                                NULL, MAPI_MODIFY, &ulObjType,
                                (LPUNKNOWN *)&lpMailUser)))
        goto exit;

    Assert(lpMailUser);

    if (FAILED(hr = HrSetAdrEntry (m_lpWabObject, &adrentry, lpAdrInfo, mask)))
        goto exit;

    if (FAILED(hr = lpMailUser->SetProps(adrentry.cValues, adrentry.rgPropVals, NULL)))
        goto exit;

    hr = lpMailUser->SaveChanges(KEEP_OPEN_READONLY);

exit:
    ReleaseObj(lpMailUser);

    return hr;
}

HRESULT CWab::HrUpdateWABEntryNoEID(HWND hwndParent, LPADRINFO lpAdrInfo, DWORD mask)
{
    HRESULT     hr;
    SizedADRLIST (1, adrlist) = {1, {0,0,NULL}};
    DWORD       i;

    if (lpAdrInfo->lpbEID)
        return E_INVALIDARG;

    if (FAILED(hr = HrSetAdrEntry (m_lpWabObject, &adrlist.aEntries[0], lpAdrInfo, AIM_DISPLAY)))
        goto exit;
    if (FAILED(hr = m_lpAdrBook->ResolveName ((ULONG_PTR)hwndParent, MAPI_DIALOG, NULL, (LPADRLIST)&adrlist)))
        goto exit;
    for (i=0; i<adrlist.aEntries[0].cValues; i++)
        {
        if (PR_ENTRYID == adrlist.aEntries[0].rgPropVals[i].ulPropTag)
            {
            lpAdrInfo->cbEID = adrlist.aEntries[0].rgPropVals[i].Value.bin.cb;
            lpAdrInfo->lpbEID = adrlist.aEntries[0].rgPropVals[i].Value.bin.lpb;
            break;
            }
        }
    if (!lpAdrInfo->lpbEID)
        {
        hr = TrapError(E_FAIL);
        goto exit;
        }
    hr = HrUpdateWABEntry(lpAdrInfo, mask);

exit:
    if (adrlist.aEntries[0].rgPropVals)
        m_lpWabObject->FreeBuffer(adrlist.aEntries[0].rgPropVals);
    lpAdrInfo->cbEID = 0;
    lpAdrInfo->lpbEID = NULL;
    return hr;
}


// =============================================================================
// CWab::HrGetAdrBook
// =============================================================================
HRESULT CWab::HrGetAdrBook(LPADRBOOK* lppAdrBook)
{
    Assert(lppAdrBook);
    if (!lppAdrBook)
        return E_INVALIDARG;

    *lppAdrBook = m_lpAdrBook;
        return NOERROR;
}

// =============================================================================
// CWab::HrGetWabObject
// =============================================================================
HRESULT CWab::HrGetWabObject(LPWABOBJECT* lppWabObject)
{
    Assert(lppWabObject);
    if (!lppWabObject)
        return E_INVALIDARG;

    *lppWabObject = m_lpWabObject;
        return NOERROR;
}

/***************************************************************************

    Name      : FTranslateAccelerator

    Purpose   : Give an open WAB window a change to look for accelerators.

    Parameters: lpmsg -> lpmsg from the current event

    Returns   : BOOL - was the event used

***************************************************************************/

BOOL CWab::FTranslateAccelerator(LPMSG lpmsg)
{
    if (m_adrParm.lpfnABSDI && m_hwnd && GetActiveWindow() == m_hwnd)
        return ((m_adrParm.lpfnABSDI)((ULONG_PTR)m_hwnd, (LPVOID)lpmsg));

    return FALSE;
}

/***************************************************************************

    Name      : OnClose

    Purpose   : We are closing the application.  If the window is open, tell
                it to close.

    Parameters: none

    Returns   : HRESULT

***************************************************************************/

HRESULT CWab::OnClose()
{
    DOUT ("CWab::OnClose");

    if (m_hwnd)
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    return S_OK;
}

HRESULT    HrCloseWabWindow()
{
    HRESULT hr = S_OK;

    if (g_pWab)
        hr = g_pWab->OnClose();

    return hr;
}


#ifdef DEBUG
void DEBUGDumpAdrList(LPADRLIST pal)
{
    char    sz[2048];
    WCHAR   wsz[2048];

    ULONG   ul,
            ulProp;

    if (!pal)
        {
        OutputDebugString("<Empty Adrlist>\n\r");
        return;
        }

    wsprintf(sz, "AdrList:: (%d entries)", pal->cEntries);
    OutputDebugString(sz);

    for(ul=0; ul<pal->cEntries; ul++)
        {
        wsprintf(sz, "\n\r  %d) {cVal=%d, {", ul, pal->aEntries[ul].cValues);
        OutputDebugString(sz);
        for(ulProp=0; ulProp<pal->aEntries[ul].cValues; ulProp++)
            {
            switch(pal->aEntries[ul].rgPropVals[ulProp].ulPropTag)
                {
                case PR_ENTRYID:
                    OutputDebugString("EID");
                    break;
                case PR_EMAIL_ADDRESS:
                    OutputDebugString("ADDRESS");
                    break;
                case PR_EMAIL_ADDRESS_W:
                    OutputDebugString("ADDRESS_W");
                    break;
                case PR_ADDRTYPE:
                    OutputDebugString("ADDRTYPE");
                    break;
                case PR_ADDRTYPE_W:
                    OutputDebugString("ADDRTYPE_W");
                    break;
                // If the prop is ansi, the output might be funky.
                case PR_DISPLAY_NAME:
                    wsprintf(sz, "DISP(%s)", pal->aEntries[ul].rgPropVals[ulProp].Value.lpszA);
                    OutputDebugString(sz);
                    break;
                case PR_DISPLAY_NAME_W:
                    AthwsprintfW(wsz, ARRAYSIZE(wsz), L"DISP(%s)", pal->aEntries[ul].rgPropVals[ulProp].Value.lpszW);
                    OutputDebugStringWrapW(wsz);
                    break;
                case PR_SURNAME:
                    OutputDebugString("SURNAME");
                    break;
                case PR_SURNAME_W:
                    OutputDebugString("SURNAME_W");
                    break;
                case PR_GIVEN_NAME:
                    OutputDebugString("GIVENNAME");
                    break;
                case PR_GIVEN_NAME_W:
                    OutputDebugString("GIVENNAME_W");
                    break;
                case PROP_ID(PR_RECIPIENT_TYPE):
                    wsprintf(sz, "RECIPTYPE(%d)", pal->aEntries[ul].rgPropVals[ulProp].Value.l);
                    OutputDebugString(sz);
                    break;
                case PROP_ID(PR_SEARCH_KEY):
                    OutputDebugString("SEARCHKEY");
                    break;
                case PROP_ID(PR_OBJECT_TYPE):
                    OutputDebugString("OBJTYPE");
                    break;

                default:
                    wsprintf(sz, "<unknown> 0x%x", pal->aEntries[ul].rgPropVals[ulProp].ulPropTag);
                    OutputDebugString(sz);
                    break;
                }

            if (ulProp+1<pal->aEntries[ul].cValues)
                OutputDebugString(", ");
            }
        OutputDebugString("}}");
        }
    OutputDebugString("\n\r");
}

#endif



HRESULT CWabal::HrAdrInfoFromRow(LPSRow lpsrw, LPADRINFO lpAdrInfo, LONG lRecipType)
{
    LPSPropValue    ppv;
    ULONG           ul,
                    cValues;

    Assert(lpsrw);
    Assert(lpAdrInfo);

    lpAdrInfo->lpwszAddress = NULL;
    lpAdrInfo->lpwszAddrType = NULL;
    lpAdrInfo->lpwszDisplay = NULL;
    lpAdrInfo->lpwszSurName = NULL;
    lpAdrInfo->lpwszGivenName = NULL;
    lpAdrInfo->lRecipType = lRecipType;
    lpAdrInfo->fResolved = FALSE;
    lpAdrInfo->fDistList = FALSE;
    lpAdrInfo->fDefCertificate = FALSE;
    lpAdrInfo->tbCertificate.pBlobData = (BYTE*)0;
    lpAdrInfo->tbCertificate.cbSize = 0;
    lpAdrInfo->blSymCaps.pBlobData = (BYTE*)0;
    lpAdrInfo->blSymCaps.cbSize = 0;
    lpAdrInfo->ftSigningTime.dwLowDateTime = lpAdrInfo->ftSigningTime.dwHighDateTime = 0;
    lpAdrInfo->cbEID=0;
    lpAdrInfo->lpbEID=0;

    cValues=lpsrw->cValues;
    ppv=lpsrw->lpProps;
    AssertSz(cValues, "empty address??");

    for(ul=0; ul<cValues; ul++, ppv++)
        PropValToAdrInfo(ppv, lpAdrInfo);

    DOUTL(4, "AddrEntry2AddrInfo: lRecip=%d", lpAdrInfo->lRecipType);
    AssertSz(lpAdrInfo->lpwszAddress==NULL ||
                lpAdrInfo->lRecipType != -1, "A resolved entry should have a recip type!");



    return NOERROR;
}


 void CWabal::PropValToAdrInfo(LPSPropValue ppv, LPADRINFO lpAdrInfo)
 {
     switch(ppv->ulPropTag)
        {
        case PR_SEND_INTERNET_ENCODING:
            lpAdrInfo->fPlainText = (ppv->Value.l == BODY_ENCODING_TEXT);
            break;

        case PR_OBJECT_TYPE:
            Assert(ppv->Value.l==MAPI_MAILUSER || ppv->Value.l==MAPI_DISTLIST);
            lpAdrInfo->fDistList=(ppv->Value.l==MAPI_DISTLIST);
            break;

        case PR_EMAIL_ADDRESS:
            AssertSz(FALSE, "Have to take care of this case.");
            //Assert(!lpAdrInfo->lpszAddress);
            //lpAdrInfo->lpszAddress = ppv->Value.lpszA;
            break;

        case PR_EMAIL_ADDRESS_W:
            Assert(!lpAdrInfo->lpwszAddress);
            lpAdrInfo->lpwszAddress = ppv->Value.lpszW;
            break;

        case PR_ADDRTYPE:
            AssertSz(FALSE, "Have to take care of this case.");
            //Assert(!lpAdrInfo->lpszAddrType);
            //lpAdrInfo->lpszAddrType = ppv->Value.lpszA;
            break;

        case PR_ADDRTYPE_W:
            Assert(!lpAdrInfo->lpwszAddrType);
            lpAdrInfo->lpwszAddrType = ppv->Value.lpszW;
            break;

        case PR_RECIPIENT_TYPE:
            Assert(lpAdrInfo->lRecipType==-1);
            lpAdrInfo->lRecipType = ppv->Value.l;
            break;

        case PR_DISPLAY_NAME:
            AssertSz(FALSE, "Have to take care of this case.");
            //Assert(!lpAdrInfo->lpszDisplay);
            //lpAdrInfo->lpszDisplay = ppv->Value.lpszA;
            break;

        case PR_DISPLAY_NAME_W:
            Assert(!lpAdrInfo->lpwszDisplay);
            lpAdrInfo->lpwszDisplay = ppv->Value.lpszW;
            break;

        case PR_SURNAME:
            AssertSz(FALSE, "Have to take care of this case.");
            //Assert(!lpAdrInfo->lpszSurName);
            //lpAdrInfo->lpszSurName = ppv->Value.lpszA;
            break;

        case PR_GIVEN_NAME:
            AssertSz(FALSE, "Have to take care of this case.");
            //Assert(!lpAdrInfo->lpszGivenName);
            //lpAdrInfo->lpszGivenName = ppv->Value.lpszA;
            break;

        case PR_SURNAME_W:
            Assert(!lpAdrInfo->lpwszSurName);
            lpAdrInfo->lpwszSurName = ppv->Value.lpszW;
            break;

        case PR_GIVEN_NAME_W:
            Assert(!lpAdrInfo->lpwszGivenName);
            lpAdrInfo->lpwszGivenName = ppv->Value.lpszW;
            break;

        case PR_ENTRYID:
            lpAdrInfo->cbEID=ppv->Value.bin.cb;
            lpAdrInfo->lpbEID=ppv->Value.bin.lpb;
            lpAdrInfo->fResolved=TRUE;  // it's resolved if it has an entryid
            break;

        case PR_USER_X509_CERTIFICATE:
            // Assume only one value in cert array.
            Assert(ppv->Value.MVbin.cValues == 1);
            if (ppv->Value.MVbin.cValues)
                {
                BOOL fDefault = FALSE;
                GetX509CertTags(&ppv->Value.MVbin.lpbin[0], &lpAdrInfo->tbCertificate, &lpAdrInfo->blSymCaps,
                  &lpAdrInfo->ftSigningTime, &fDefault);
                lpAdrInfo->fDefCertificate = fDefault;
                }
            break;
    }
}


HRESULT CWabal::HrExpandTo(LPWABAL lpWabal)
{
    ADRINFO         adrInfo;
    LPSRowSet       prwsDL=0;
    HRESULT         hr=S_OK;
    SBinary         eidDL;
    DLSEARCHINFO    DLSearch={0};

    if (!lpWabal)
        return E_INVALIDARG;

    if (FGetFirst(&adrInfo))
        do
            {
            if (adrInfo.fDistList)
                {
                eidDL.cb=adrInfo.cbEID;
                eidDL.lpb=adrInfo.lpbEID;

                if (!FDLVisted(eidDL, &DLSearch))
                    {
                    // this is a new distribution list, let's open it and scan..

                    // add this distlist to our searchlist, and recurse...
                    hr=HrAddToSearchList(eidDL, &DLSearch);
                    if (FAILED(hr))
                        goto error;

                    hr=HrGetDistListRows(eidDL, &prwsDL);
                    if (FAILED(hr))
                        {
                        hr = hrEmptyDistList;
                        goto error;
                        }

                    hr=HrAddDistributionList(lpWabal, prwsDL, adrInfo.lRecipType, &DLSearch);
                    if (FAILED(hr))
                        goto error;

                    m_lpWabObject->FreeBuffer(prwsDL);
                    prwsDL=NULL;
                    }
                }
            else
                {
                hr=lpWabal->HrAddEntry(&adrInfo, TRUE);
                if (FAILED(hr))
                    goto error;

                }
            }
        while(FGetNext(&adrInfo));

error:
    if (prwsDL)
        m_lpWabObject->FreeBuffer(prwsDL);

    FreeSearchList(&DLSearch);
    return hr;
}




HRESULT CWabal::HrAddDistributionList(LPWABAL lpWabal, LPSRowSet lprws, LONG lRecipType, PDLSEARCHINFO pDLSearch)
{
    HRESULT     hr=NOERROR;
    ULONG       ul;
    LPSRowSet   prwsDL=0;
    ADRINFO     adrInfo;

    for(ul=0; ul<lprws->cRows; ul++)
    {
        if (lprws->aRow[ul].lpProps[AE_colObjectType].ulPropTag==PR_OBJECT_TYPE &&
            lprws->aRow[ul].lpProps[AE_colObjectType].Value.l == MAPI_DISTLIST &&
            lprws->aRow[ul].lpProps[AE_colEntryID].ulPropTag==PR_ENTRYID)
        {

            if (!FDLVisted(lprws->aRow[ul].lpProps[AE_colEntryID].Value.bin, pDLSearch))
            {
                // this is a new distribution list, let's open it and scan..

                // add this distlist to our searchlist, and recurse...
                hr=HrAddToSearchList(lprws->aRow[ul].lpProps[AE_colEntryID].Value.bin, pDLSearch);
                if (FAILED(hr))
                    goto error;

                hr=HrGetDistListRows(lprws->aRow[ul].lpProps[AE_colEntryID].Value.bin, &prwsDL);
                if (FAILED(hr))
                    goto error;

                hr=HrAddDistributionList(lpWabal, prwsDL, lRecipType, pDLSearch);
                if (FAILED(hr))
                    goto error;

                m_lpWabObject->FreeBuffer(prwsDL);
                prwsDL=NULL;
            }

        }
        else
            if ( lprws->aRow[ul].lpProps[AE_colObjectType].ulPropTag==PR_OBJECT_TYPE &&
                lprws->aRow[ul].lpProps[AE_colObjectType].Value.l == MAPI_MAILUSER )
            {
                // just a regular user...
                hr=HrAdrInfoFromRow(&lprws->aRow[ul], &adrInfo, lRecipType);
                if (FAILED(hr))
                    goto error;
                hr=lpWabal->HrAddEntry(&adrInfo, TRUE);
                if (FAILED(hr))
                    goto error;
            }

    }

error:
    if (prwsDL)
        m_lpWabObject->FreeBuffer(prwsDL);
    return hr;
}



BOOL CWabal::FDLVisted(SBinary eidDL, PDLSEARCHINFO pDLSearch)
{
    ULONG   ul,
            ulResult=0;
    HRESULT hr;

    for(ul=0; ul<pDLSearch->cValues; ul++)
        {
        hr=m_lpAdrBook->CompareEntryIDs(eidDL.cb, (LPENTRYID)eidDL.lpb,
                            pDLSearch->rgEid[ul].cb,
                            (LPENTRYID)pDLSearch->rgEid[ul].lpb, 0, &ulResult);
        if ((!FAILED(hr)) && ulResult)
            return TRUE;
        }

    return FALSE;
}


HRESULT CWabal::HrAddToSearchList(SBinary eidDL, PDLSEARCHINFO pDLSearch)
{
    ULONG   ulResult=0;
    LPBYTE  lpb=0;

    if (pDLSearch->cValues==pDLSearch->cAlloc)
        {
        // time to grow...
        if (!MemRealloc((LPVOID *)&pDLSearch->rgEid, sizeof(SBinary)*(pDLSearch->cAlloc+GROW_SIZE)))
            return E_OUTOFMEMORY;

        //ZeroInit the new stuff...
        ZeroMemory(&pDLSearch->rgEid[pDLSearch->cAlloc], sizeof(SBinary)*GROW_SIZE);
        pDLSearch->cAlloc+=GROW_SIZE;
        }

    if (!MemAlloc((LPVOID *)&lpb, eidDL.cb))
        return E_OUTOFMEMORY;

    pDLSearch->rgEid[pDLSearch->cValues].cb=eidDL.cb;
    pDLSearch->rgEid[pDLSearch->cValues].lpb=lpb;
    CopyMemory(lpb, eidDL.lpb, eidDL.cb);
    pDLSearch->cValues++;
    return NOERROR;
}


HRESULT CWabal::FreeSearchList(PDLSEARCHINFO pDLSearch)
{
    ULONG   ul;

    if (pDLSearch)
        {
        for(ul=0; ul<pDLSearch->cValues; ul++)
            if (pDLSearch->rgEid[ul].lpb)
                MemFree(pDLSearch->rgEid[ul].lpb);

#ifdef DEBUG
        for(ul=pDLSearch->cValues; ul<pDLSearch->cAlloc; ul++)
            AssertSz(pDLSearch->rgEid[ul].cb==NULL && pDLSearch->rgEid[ul].lpb==NULL, "should be null!");
#endif
        if (pDLSearch->rgEid)
            MemFree(pDLSearch->rgEid);
        }
    return NOERROR;
}


HRESULT CWabal::HrGetDistListRows(SBinary eidDL, LPSRowSet *psrws)
{
    HRESULT             hr;
    LPMAPITABLE         ptblDistList=0;
    ULONG               ulObjType,
                        cRows=0;
    LPDISTLIST          pDistList=0;

    Assert(m_lpAdrBook);

    hr=m_lpAdrBook->OpenEntry(eidDL.cb, (LPENTRYID)eidDL.lpb, &IID_IDistList, 0, &ulObjType, (LPUNKNOWN *)&pDistList);
    if (FAILED(hr))
        goto cleanup;

    Assert(pDistList);

    hr=pDistList->GetContentsTable(MAPI_UNICODE, &ptblDistList);
    if (FAILED(hr))
        goto cleanup;

    Assert(ptblDistList);

    hr=ptblDistList->GetRowCount(0, &cRows);
    if (FAILED(hr))
        goto cleanup;

    hr=ptblDistList->SetColumns((LPSPropTagArray)&AE_props, 0);
    if (FAILED(hr))
        goto cleanup;

    hr=ptblDistList->QueryRows(cRows, 0, psrws);
    if (FAILED(hr))
        goto cleanup;

cleanup:
    ReleaseObj(ptblDistList);
    ReleaseObj(pDistList);
    return hr;
}

HRESULT CWabal::HrGetPMP(ULONG cbEntryID, LPENTRYID lpEntryID, ULONG *lpul, LPMAPIPROP *lppmp)
{
    return m_lpAdrBook->OpenEntry(cbEntryID, lpEntryID, &IID_IMAPIProp, 0, lpul, (LPUNKNOWN *)lppmp);
}


/***************************************************************************

    Name      : HrBuildCertSBinaryData

    Purpose   : Takes as input all the data needed for a cert entry
                in PR_USER_X509_CERTIFICATE and returns a pointer to
                memory that contains all the input data in the correct
                format to be plugged in to the lpb member of an SBinary
                structure.  This memory should be Freed by the caller.


    Parameters: bIsDefault - TRUE if this is the default cert
                pblobCertThumbPrint - The actual certificate thumbprint
                pblobSymCaps - symcaps blob
                ftSigningTime - Signing time
                lplpbData - receives the buffer with the data
                lpcbData - receives size of the data

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  THUMBBLOB*            pPrint,
  BLOB *                pSymCaps,
  FILETIME              ftSigningTime,
  LPBYTE UNALIGNED FAR* lplpbData,
  ULONG UNALIGNED FAR*  lpcbData)
{
    DWORD       cbDefault, cbPrint, cbSymCaps;
    HRESULT     hr = S_OK;
    LPCERTTAGS  lpCurrentTag;
    ULONG       cbSize, cProps;
    LPBYTE      lpb = NULL;


    cbDefault   = sizeof(bIsDefault);
    cbPrint     = pPrint->cbSize;
    cbSymCaps   = pSymCaps->cbSize;
    cProps      = 2;
    cbSize      = LcbAlignLcb(cbDefault) + LcbAlignLcb(cbPrint);

    if (cbSymCaps) {
        cProps++;

        cbSize += LcbAlignLcb(cbSymCaps);
    }
    if (ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime) {
        cProps++;
        cbSize += LcbAlignLcb(sizeof(FILETIME));
    }
    cbSize += LcbAlignLcb(cProps * SIZE_CERTTAGS);

    if (!MemAlloc((LPVOID *)&lpb, cbSize))
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }

    // Set the default property
    lpCurrentTag = (LPCERTTAGS)lpb;
    lpCurrentTag->tag       = CERT_TAG_DEFAULT;
    lpCurrentTag->cbData    = (WORD) (SIZE_CERTTAGS + cbDefault);
    memcpy(&lpCurrentTag->rgbData,
        &bIsDefault,
        cbDefault);

    // Set the thumbprint property
    lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + LcbAlignLcb(lpCurrentTag->cbData));

    lpCurrentTag->tag       = CERT_TAG_THUMBPRINT;
    lpCurrentTag->cbData    = (WORD) (SIZE_CERTTAGS + cbPrint);
    memcpy(&lpCurrentTag->rgbData, pPrint->pBlobData, cbPrint);

    // Set the SymCaps property
    if (cbSymCaps) {
        lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + LcbAlignLcb(lpCurrentTag->cbData));
        lpCurrentTag->tag       = CERT_TAG_SYMCAPS;
        lpCurrentTag->cbData    = (WORD) (SIZE_CERTTAGS + pSymCaps->cbSize);
        memcpy(&lpCurrentTag->rgbData, pSymCaps->pBlobData, cbSymCaps);
    }

    // Signing time property
    if (ftSigningTime.dwLowDateTime || ftSigningTime.dwHighDateTime) {
        lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + LcbAlignLcb(lpCurrentTag->cbData));
        lpCurrentTag->tag       = CERT_TAG_SIGNING_TIME;
        lpCurrentTag->cbData    = (WORD) (SIZE_CERTTAGS + sizeof(FILETIME));
        memcpy(&lpCurrentTag->rgbData, &ftSigningTime, sizeof(FILETIME));
    }


    *lpcbData = cbSize;
    *lplpbData = lpb;
exit:
    return(hr);
}


HRESULT ThumbprintToPropValue(LPSPropValue ppv,
                              THUMBBLOB *pPrint,
                              BLOB *pSymCaps,
                              FILETIME ftSigningTime,
                              BOOL fDefPrint)
{
    SBinary UNALIGNED *pSBin;
    DWORD       cbDefault, cbPrint, cbSymCaps;
    HRESULT     hr = S_OK;
    LPCERTTAGS  lpCurrentTag;
    ULONG       cbSize, cProps;

    Assert(ppv && pPrint);

    if (!pPrint->pBlobData)
        return E_INVALIDARG;

    ppv->ulPropTag              = PR_USER_X509_CERTIFICATE;
    ppv->Value.MVbin.cValues    = 1;

    if (!MemAlloc((LPVOID *)&ppv->Value.MVbin.lpbin, sizeof(SBinary)*ppv->Value.MVbin.cValues))
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }
    pSBin = ppv->Value.MVbin.lpbin;

    hr = HrBuildCertSBinaryData(
      fDefPrint,
      pPrint,
      pSymCaps,
      ftSigningTime,
      &pSBin->lpb,
      &pSBin->cb);

exit:
    return hr;
}

ULONG CWabal::DeleteRecipType(LONG lRecipType)
{
    ULONG ulNew = 0, ulRemoved;

    for (ULONG ul = 0; ul < m_cActualEntries; ul++)
        {
        for (ULONG ulProp = 0; ulProp < m_lpAdrList->aEntries[ul].cValues; ulProp++)
            {
            if (m_lpAdrList->aEntries[ul].rgPropVals[ulProp].ulPropTag == PR_RECIPIENT_TYPE)
                {
                if (m_lpAdrList->aEntries[ul].rgPropVals[ulProp].Value.l != lRecipType)
                    m_lpAdrList->aEntries[ulNew++] = m_lpAdrList->aEntries[ul];
                else
                    m_lpWabObject->FreeBuffer(m_lpAdrList->aEntries[ul].rgPropVals);
                break;
                }
            }
        }

    ulRemoved = m_cActualEntries - ulNew;
    if (ulRemoved)
        ZeroMemory(&m_lpAdrList->aEntries[ulNew], ulRemoved * sizeof(ADRENTRY));
    m_cActualEntries = ulNew;

    return ulRemoved;
}

void CWabal::UnresolveOneOffs()
{
    ULONG           ulEntry, ulProp;
    LPADRENTRY      pae;
    LPSPropValue    pPropDisp, pPropEmail, pProp;

    for (ulEntry = 0, pae = m_lpAdrList->aEntries; ulEntry < m_cActualEntries; ulEntry++, pae++)
    {
        pPropDisp = NULL;
        pPropEmail = NULL;
        for (ulProp = 0, pProp = pae->rgPropVals; ulProp < pae->cValues && !(pPropDisp && pPropEmail); ulProp++, pProp++)
        {
            AssertSz(pProp->ulPropTag != PR_DISPLAY_NAME, "Have more cases to find.");
            AssertSz(pProp->ulPropTag != PR_EMAIL_ADDRESS, "Have more cases to find.");
            if (pProp->ulPropTag == PR_DISPLAY_NAME_W)
                pPropDisp = pProp;
            else if (pProp->ulPropTag == PR_EMAIL_ADDRESS_W)
                pPropEmail = pProp;
        }
        if (pPropDisp && pPropEmail)
        {
            if (!StrCmpW(pPropDisp->Value.lpszW, pPropEmail->Value.lpszW))
                pPropEmail->ulPropTag = PR_NULL;
        }
    }
}


/***************************************************************************

    Name      : FindX509CertTag

    Purpose   : Finds a tag inside the USER_X509_CERTIFICATE SBinary

    Parameters: lpsb -> SBinary for a particular cert
                ulTag = tag to search for
                pcbReturn -> returned size (data only).
    Returns   : pointer into SBinary data location for the tag.

    Comment   :

***************************************************************************/
LPBYTE FindX509CertTag(LPSBinary lpsb, ULONG ulTag, ULONG * pcbReturn) {
    LPCERTTAGS      lpCurrentTag = NULL;
    LPBYTE          lpbTagEnd = NULL;
    LPBYTE          lpbReturn = NULL;

    *pcbReturn = 0;

    Assert(lpsb->lpb[0] != 0x30);       // Should have found this out before we got here.
    if (lpsb && lpsb->cb && (lpsb->lpb[0] != 0x30))
        {
        lpCurrentTag = (LPCERTTAGS)lpsb->lpb;
        lpbTagEnd = (LPBYTE)lpCurrentTag + lpsb->cb;

        while ((LPBYTE)lpCurrentTag < lpbTagEnd && (ulTag != lpCurrentTag->tag))
            {
            if (lpCurrentTag->cbData == 0)
                {
                DOUTL(4, "Bad CertTag in PR_USER_X509_CERTIFICATE");
                break;        // Safety valve, prevent infinite loop if bad data
                }
            lpCurrentTag = (LPCERTTAGS)((BYTE*)lpCurrentTag + lpCurrentTag->cbData);
#ifdef _WIN64
            lpCurrentTag = (LPCERTTAGS)MyPbAlignPb((BYTE*)lpCurrentTag);
#endif // _WIN64
            }

        // Did we find it?
        if ((LPBYTE)lpCurrentTag < lpbTagEnd && ulTag == lpCurrentTag->tag && lpCurrentTag->cbData >= SIZE_CERTTAGS)
            {
            lpbReturn = (LPBYTE)lpCurrentTag->rgbData;
            *pcbReturn = lpCurrentTag->cbData - SIZE_CERTTAGS;
            }
        }
    return(lpbReturn);
}


/***************************************************************************

    Name      : GetX509CertTags

    Purpose   : Parses the PR_USER_X509_CERTIFICATE property value into
                thumbprint, symcaps and signing time.

    Parameters: lpsb -> SBinary for a particular cert
                ptbCertificate -> returned thumbblob to write to.  (required)
                pblSymCaps -> returned symcaps blob.  (optional)
                pftSigningTime -> returned signing time (optional)
                pfDefault -> returned default flag (optional)

    Returns   : HRESULT

    Comment   : Note that the blob props will be returned with pointers into
                the lpsb data.  Don't free them!  Don't free the propvalue
                prior to use!

***************************************************************************/
HRESULT GetX509CertTags(LPSBinary lpsb, THUMBBLOB * ptbCertificate, BLOB * pblSymCaps, LPFILETIME pftSigningTime, BOOL * pfDefault) {
    HRESULT hr = S_OK;
    LPBYTE pbData;
    ULONG cbData = 0;

    Assert(ptbCertificate);

    // Initialize the return values
    ptbCertificate->pBlobData = NULL;
    ptbCertificate->cbSize = 0;
    if (pblSymCaps) {
        pblSymCaps->pBlobData = NULL;
        pblSymCaps->cbSize = 0;
    }
    if (pftSigningTime) {
        pftSigningTime->dwLowDateTime = pftSigningTime->dwHighDateTime = 0;
    }
    if (pfDefault) {
        *pfDefault = FALSE;
    }

    // Find the thumbprint.  No thumbprint, no use trying other tags.
    if (pbData = FindX509CertTag(lpsb, CERT_TAG_THUMBPRINT, &cbData)) {
        ptbCertificate->pBlobData = pbData;
        ptbCertificate->cbSize = cbData;

        // Symcaps tag
        if (pblSymCaps && (pbData = FindX509CertTag(lpsb, CERT_TAG_SYMCAPS, &cbData))) {
            pblSymCaps->pBlobData = pbData;
            pblSymCaps->cbSize = cbData;
        }

        // Signing time tag
        if (pftSigningTime && (pbData = FindX509CertTag(lpsb, CERT_TAG_SIGNING_TIME, &cbData))) {
            memcpy(pftSigningTime, &pbData, min(sizeof(FILETIME), cbData));
        }

        // scan for "default" tag
        if (pfDefault && (pbData = FindX509CertTag(lpsb, CERT_TAG_DEFAULT, &cbData))) {
            memcpy((void*)pfDefault, pbData, min(cbData, sizeof(*pfDefault)));
        }
    }
    return(hr);
}

void ImportWAB(HWND hwnd)
{
    WABIMPORTPARAM wip;
    HRESULT hr;

    hr = HrInitWab(TRUE);
    if (FAILED(hr))
        return;

    // Verify Globals
    if (!g_fWabLoaded || !g_fWabInit)
        return;

    EnterCriticalSection (&g_rWabCritSect);

    if (g_lpWabObject != NULL && g_lpAdrBook != NULL)
    {
        wip.cbSize = sizeof(WABIMPORTPARAM);
        wip.lpAdrBook = g_lpAdrBook;
        wip.hWnd = hwnd;
        wip.ulFlags = MAPI_DIALOG;
        wip.lpszFileName = NULL;

        // this is really intuitive. let's cast a struct to a string! yippee!
        g_lpWabObject->Import((LPSTR)&wip);
    }

    LeaveCriticalSection (&g_rWabCritSect);
}

void Wab_CoDecrement()
{
    // bug #59420, can't freelibrary the wab inside the wndproc
    // so we post a decrement message to our init window and cleanup
    // when the stack is unwound
    if (g_pInstance)
        CoDecrementInit("WabWindow", NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\layout.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     layout.cpp
//
//  PURPOSE:    Implements the layout property sheet
//

#include "pch.hxx"
#include "resource.h"
#include "goptions.h"
#include "browser.h"
#include "layout.h"
#include "thormsgs.h"
#include <mailnews.h>
#include "instance.h"

ASSERTDATA

static const char c_szPropBrowser[] = "Browser";
static const char c_szPropLayout[] = "Layout";

INT_PTR CALLBACK LayoutProp_General(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL    LayoutProp_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
void    LayoutProp_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
LRESULT LayoutProp_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr);
void    LayoutProp_SetOption(HWND hwndDlg, int idCtl, DWORD dwOpt);
void    LayoutProp_EnableToolbarControls(HWND hwnd, BOOL fEnable);
void    LayoutProp_EnablePreviewControls(HWND hwnd, BOOL fEnable);

typedef struct tagLAYOUT_INFO {
    IAthenaBrowser *pBrowser;
    LAYOUT         *pLayout;
} LAYOUT_INFO, *PLAYOUT_INFO;

//
//  FUNCTION:   LayoutProp_Create()
//
//  PURPOSE:    Invokes the Window Layout property sheet
//
//  PARAMETERS:
//      <in> hwndParent - Handle of the parent of the dialog box
//
//  RETURN VALUE:
//      <???>
//
//  COMMENTS:
//      <???>
//
BOOL LayoutProp_Create(HWND hwndParent, IAthenaBrowser *pBrowser, LAYOUT *pLayout)
    {
    PROPSHEETPAGE   psp;
    PROPSHEETHEADER psh;
    BOOL            fReturn;
    HICON           hIconSmall;
    TCHAR           szTitle[CCHMAX_STRINGRES];
    LAYOUT_INFO     rLayout= { pBrowser, pLayout };

    // Load the title bar icon
    hIconSmall = (HICON) LoadImage(g_hLocRes, MAKEINTRESOURCE(idiWindowLayout),
                                   IMAGE_ICON, 16, 16, 0);
    
    // Load the title bar caption
    AthLoadString(idsWindowLayout, szTitle, ARRAYSIZE(szTitle));

    ZeroMemory(&psp, sizeof(PROPSHEETPAGE));
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hLocRes;
    psp.pszTemplate = MAKEINTRESOURCE(iddViewLayout);
    psp.pfnDlgProc  = LayoutProp_General;
    psp.lParam      = (LPARAM) pBrowser;

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_USEHICON | PSH_PROPSHEETPAGE | PSH_PROPTITLE | PSH_USEPAGELANG;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hLocRes;
    psh.hIcon = hIconSmall;
    psh.pszCaption = szTitle;
    psh.nPages = 1;
    psh.nStartPage = 0;
    psh.ppsp = &psp;

    fReturn = !!PropertySheet(&psh);

    if (hIconSmall)
        SideAssert(DestroyIcon(hIconSmall));

    return (fReturn);
    }

const static HELPMAP g_rgCtxMapLayout[] = {
    {IDC_CHECK_FOLDERLIST, IDH_LAYOUT_FOLDER_LIST},
    {IDC_CHECK_FOLDERBAR, IDH_LAYOUT_FOLDER_BAR},
    {IDC_CHECK_CONTACTS, 35702},
    {IDC_CHECK_OUTLOOKBAR, 35700},
    {IDC_CHECK_STATUSBAR, 35704},
    {IDC_CHECK_TOOLBAR, 35706},
    {IDC_CHECK_FILTERBAR, 35708},
    {IDC_CHECK_INFOPANE, 35712},
    {IDC_BUTTON_CUSTOMIZE, IDH_LAYOUT_CUSTOMIZE_BUTTONS},
    {IDC_CHECK_PREVIEW, IDH_LAYOUT_PREVIEW_PANE},
    {IDC_RADIO_SPLIT_HORZ, IDH_LAYOUT_PREVIEW_PANE_MOVE},
    {IDC_RADIO_SPLIT_VERT, IDH_LAYOUT_PREVIEW_PANE_MOVE},
    {IDC_CHECK_PREVIEW_HEADER, IDH_LAYOUT_SHOW_HEADERS},
    {idcStatic1, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic2, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic3, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic4, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic5, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic6, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic7, IDH_NEWS_COMM_GROUPBOX},
    {idcStatic8, IDH_NEWS_COMM_GROUPBOX},
    {0, 0}};

INT_PTR CALLBACK LayoutProp_General(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    LRESULT lResult;
    LAYOUT *pLayout;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            return (BOOL) HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, 
                                               LayoutProp_OnInitDialog);

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wParam, lParam, LayoutProp_OnCommand);
            return (TRUE);

        case WM_NOTIFY:
            lResult = HANDLE_WM_NOTIFY(hwnd, wParam, lParam, LayoutProp_OnNotify);
            SetDlgMsgResult(hwnd, WM_NOTIFY, lResult);
            return (TRUE);

        case WM_DESTROY:
            RemoveProp(hwnd, c_szPropBrowser);
            pLayout = (LAYOUT *)GetProp(hwnd, c_szPropLayout);
            if (pLayout != NULL)
                MemFree(pLayout);
            RemoveProp(hwnd, c_szPropLayout);
            return (TRUE);

        case WM_HELP:
        case WM_CONTEXTMENU:
            return(OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgCtxMapLayout));
        }
    return (FALSE);
    }


BOOL LayoutProp_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
    {
    IAthenaBrowser *pBrowser = NULL;
    CBands         *pCoolbar = NULL;
    BOOL            fText = TRUE;
    FOLDERTYPE      ftType = FOLDER_ROOTNODE;
    BOOL            fEnabled = FALSE;
    DWORD           dwHybrid = hybridNone;
    DWORD           dwSplitDir = 0;
    LAYOUT         *pLayout;
    BOOL            fPreviewPaneHeader = 0;

    Assert(lParam);

    pBrowser = (IAthenaBrowser *)(((PROPSHEETPAGE *) lParam)->lParam);
    Assert(pBrowser != NULL);

    if (!MemAlloc((void **)&pLayout, sizeof(LAYOUT)))
        return(FALSE);

    pLayout->cbSize = sizeof(LAYOUT);
    SideAssert(SUCCEEDED(pBrowser->GetLayout(pLayout)));

    // Stash the pointer to the browser
    SetProp(hwnd, c_szPropBrowser, (HANDLE) pBrowser);
    SetProp(hwnd, c_szPropLayout, (HANDLE) pLayout);

    // Set the basic checks
    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_FOLDERBAR), pLayout->fFolderBar);
    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_FOLDERLIST), pLayout->fFolderList);
    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_STATUSBAR), pLayout->fStatusBar);
    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_INFOPANE), pLayout->fInfoPane);
    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_OUTLOOKBAR), pLayout->fOutlookBar);
    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_CONTACTS), pLayout->fContacts);

    EnableWindow(GetDlgItem(hwnd, IDC_CHECK_CONTACTS), !(g_dwAthenaMode & MODE_OUTLOOKNEWS));

    if (!pLayout->fInfoPaneEnabled)
        ShowWindow(GetDlgItem(hwnd, IDC_CHECK_INFOPANE), SW_HIDE);


    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_TOOLBAR), pLayout->fToolbar);
    if (!pLayout->fToolbar)
        LayoutProp_EnableToolbarControls(hwnd, FALSE);

    Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_FILTERBAR), pLayout->fFilterBar);


    // Set the preview pane options
    pBrowser->GetFolderType(&ftType);

    if (ftType == FOLDER_HTTPMAIL)
        ShowWindow(GetDlgItem(hwnd, IDC_CHECK_INFOPANE), SW_HIDE);

    if (FOLDER_NEWS == ftType || FOLDER_LOCAL == ftType || FOLDER_HTTPMAIL == ftType || FOLDER_IMAP == ftType)
        {
        // Mail and news have different preview pane options.  We need to
        // load those controls separately
        if (ftType == FOLDER_NEWS)
            {
            dwHybrid = pLayout->fNewsPreviewPane;
            dwSplitDir = pLayout->fNewsSplitVertically;
            fPreviewPaneHeader = pLayout->fNewsPreviewPaneHeader;
            }
        else
            {
            dwHybrid = pLayout->fMailPreviewPane;
            dwSplitDir = pLayout->fMailSplitVertically;
            fPreviewPaneHeader = pLayout->fMailPreviewPaneHeader;
            }

        Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_PREVIEW), 
                        hybridNone != dwHybrid);
        Button_SetCheck(GetDlgItem(hwnd, IDC_RADIO_SPLIT_HORZ),
                        dwSplitDir == 0);
        Button_SetCheck(GetDlgItem(hwnd, IDC_RADIO_SPLIT_VERT),
                        dwSplitDir == 1);
        Button_SetCheck(GetDlgItem(hwnd, IDC_CHECK_PREVIEW_HEADER),
                        fPreviewPaneHeader);

        if (dwHybrid == hybridNone)
            LayoutProp_EnablePreviewControls(hwnd, FALSE);
        }
    else
        {
        EnableWindow(GetDlgItem(hwnd, IDC_CHECK_PREVIEW), FALSE);
        LayoutProp_EnablePreviewControls(hwnd, FALSE);
        }


    PropSheet_UnChanged(GetParent(hwnd), hwnd);
    return (TRUE);
    }

void LayoutProp_EnableToolbarControls(HWND hwnd, BOOL fEnable)
    {

    EnableWindow(GetDlgItem(hwnd, IDC_BUTTON_CUSTOMIZE), fEnable);
    }

void LayoutProp_EnablePreviewControls(HWND hwnd, BOOL fEnable)
    {
    EnableWindow(GetDlgItem(hwnd, IDC_RADIO_SPLIT_HORZ), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RADIO_SPLIT_VERT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_CHECK_PREVIEW_HEADER), fEnable);
    }

void LayoutProp_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
    {
    BOOL fChecked;

    switch (id)
        {
        case IDC_CHECK_PREVIEW:
            fChecked = Button_GetCheck(hwndCtl);
            LayoutProp_EnablePreviewControls(hwnd, fChecked);
            break;

        case IDC_CHECK_TOOLBAR:
            fChecked = Button_GetCheck(hwndCtl);
            LayoutProp_EnableToolbarControls(hwnd, fChecked);
            break;

        case IDC_BUTTON_CUSTOMIZE:
            {
            CBands       *pCoolbar = NULL;
            IAthenaBrowser *pBrowser = (IAthenaBrowser *) GetProp(hwnd, c_szPropBrowser);

            if (pBrowser)
                {
                pBrowser->GetCoolbar(&pCoolbar);
                if (pCoolbar)
                    {
                    pCoolbar->Invoke(idCustomize, 0);
                    SetForegroundWindow(GetParent(hwnd));
                    pCoolbar->Release();
                    }
                }

            break;
            }
        }

    PropSheet_Changed(GetParent(hwnd), hwnd);
    return;
    }


LRESULT LayoutProp_OnNotify(HWND hwnd, int idFrom, LPNMHDR pnmhdr)
    {
    CBands          *pCoolbar = NULL;
    IAthenaBrowser *pBrowser = (IAthenaBrowser *) GetProp(hwnd, c_szPropBrowser);
    LAYOUT         *pLayout = (LAYOUT *) GetProp(hwnd, c_szPropLayout);
    FOLDERTYPE      ftType;
    HWND            hwndBrowser;
    register BOOL   fChecked;
    BOOL            fSplit;
    BOOL            fHeader;

    switch (pnmhdr->code)
        {
        case PSN_APPLY:
            Assert(pBrowser != NULL);

            // Basic Options
            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_FOLDERBAR);
            if (fChecked != (BOOL) pLayout->fFolderBar)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_FOLDERBAR, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fFolderBar = fChecked;
            }

            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_FOLDERLIST);
            if (fChecked != (BOOL) pLayout->fFolderList)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_FOLDERLIST, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fFolderList = fChecked;
            }

            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_STATUSBAR);
            if (fChecked != (BOOL) pLayout->fStatusBar)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_STATUSBAR, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fStatusBar = fChecked;
            }

            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_OUTLOOKBAR);
            if (fChecked != (BOOL) pLayout->fOutlookBar)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_OUTLOOK_BAR, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fOutlookBar = fChecked;
            }

            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_CONTACTS);
            if (fChecked != (BOOL) pLayout->fContacts)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_CONTACTS, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fContacts = fChecked;
            }

            if (pLayout->fInfoPaneEnabled)
                {
                    fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_INFOPANE);
                    if (fChecked != (BOOL) pLayout->fInfoPane)
                    {
                        pBrowser->SetViewLayout(DISPID_MSGVIEW_INFOPANE, LAYOUT_POS_NA, fChecked, 0, 0);
                        pLayout->fInfoPane = fChecked;
                    }
                }

            // Toolbar
            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_TOOLBAR);
            if (fChecked != (BOOL) pLayout->fToolbar)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_TOOLBAR, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fToolbar = fChecked;
            }

            //Filter Bar
            fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_FILTERBAR);
            if (fChecked != (BOOL)pLayout->fFilterBar)
            {
                pBrowser->SetViewLayout(DISPID_MSGVIEW_FILTERBAR, LAYOUT_POS_NA, fChecked, 0, 0);
                pLayout->fFilterBar = fChecked;
            }

            // Preview Pane
            if (IsWindowEnabled(GetDlgItem(hwnd, IDC_CHECK_PREVIEW)))
                {                
                pBrowser->GetFolderType(&ftType);
                fChecked = IsDlgButtonChecked(hwnd, IDC_CHECK_PREVIEW);
                fSplit = IsDlgButtonChecked(hwnd, IDC_RADIO_SPLIT_VERT);
                fHeader = IsDlgButtonChecked(hwnd, IDC_CHECK_PREVIEW_HEADER);

                if (ftType == FOLDER_NEWS)
                    {
                    pBrowser->SetViewLayout(DISPID_MSGVIEW_PREVIEWPANE_NEWS, 
                                            fSplit ? LAYOUT_POS_LEFT : LAYOUT_POS_BOTTOM, 
                                            fChecked, 
                                            fHeader, 0);
                    }
                else
                    {
                    pBrowser->SetViewLayout(DISPID_MSGVIEW_PREVIEWPANE_MAIL, 
                                            fSplit ? LAYOUT_POS_LEFT : LAYOUT_POS_BOTTOM, 
                                            fChecked, 
                                            fHeader, 0);
                    }
                }

            PropSheet_UnChanged(GetParent(hwnd), hwnd);
            return (0);
        }

    return (0);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\ipab.h ===
// ===============================================================================
// I P A B . H
// ===============================================================================
#ifndef __IPAB_H
#define __IPAB_H

// ===============================================================================
// Dependencies
// ===============================================================================
#include <wabp.h>

typedef BLOB THUMBBLOB;

// ===============================================================================
// D E F I N E S
// ===============================================================================
#define GROW_SIZE           5

// ===============================================================================
// W A B  Property structs
// ===============================================================================
enum
{
    AE_colEMailAddress = 0,
    AE_colAddrType,
    AE_colRecipType,
    AE_colDisplayName,
    AE_colSurName,
    AE_colGivenName,
    AE_colEntryID,
    AE_colObjectType,
    AE_colInternetEncoding,
    AE_colLast
};

static const SizedSPropTagArray(AE_colLast, AE_props)=
{
    AE_colLast,
    {
        PR_EMAIL_ADDRESS_W,
        PR_ADDRTYPE_W,
        PR_RECIPIENT_TYPE,
        PR_DISPLAY_NAME_W,
        PR_SURNAME_W,
        PR_GIVEN_NAME_W,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_SEND_INTERNET_ENCODING
    }
};

/**** Dont mess with the order of these arrays (especially the address components street,city,zip etc ****/
// The code that uses this structure is commented out. If and when that is used again, we will uncomment
// this again. Also, might need to convert the PR_DISPLAY_NAME to PR_DISPLAY_NAME_W along with a few others.
/*static const SizedSPropTagArray(24, ToolTipProps)=
{
    24,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_PERSONAL_HOME_PAGE,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_COMPANY_NAME,
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_BUSINESS_HOME_PAGE
    }
};*/

// ToolTipProps mask

#define   SET_PERINFO          0x0001
#define   SET_PERADDRESS       0x0002
#define   SET_BUSINFO          0x0004
#define   SET_BUSTITLE         0x0008
#define   SET_BUSDEPT          0x0016
#define   SET_BUSOFF           0x0032
#define   SET_BUSCOMP          0x0064
#define   SET_BUSADDRESS       0x0128
#define   SET_NOTES            0x0256

// ADRINFO mask
#define AIM_ADDRESS             0x0001
#define AIM_DISPLAY             0x0002
#define AIM_ADDRTYPE            0x0004
#define AIM_SURNAME             0x0008
#define AIM_GIVENNAME           0x0010
#define AIM_RECIPTYPE           0x0020
#define AIM_CERTIFICATE         0x0040
#define AIM_OBJECTTYPE          0x0080  // fDistList
#define AIM_EID                 0x0100
#define AIM_INTERNETENCODING    0x0200

typedef struct tagADRINFO           // WARNING: if you change this
{                                   // be sure to change DupeAdrInfo!
    DWORD           dwReserved;
    LPWSTR          lpwszAddress;    // Addresses must be in US printable ascii.
    LPWSTR          lpwszDisplay;
    LPWSTR          lpwszAddrType;
    LPWSTR          lpwszSurName;
    LPWSTR          lpwszGivenName;
    LONG            lRecipType;
    THUMBBLOB       tbCertificate;
    BLOB            blSymCaps;
    FILETIME        ftSigningTime;
    LPMIMEMESSAGE   pMsg;               // used for cert store, signing cert, etc.
    BOOL            fResolved       :1,
                    fDistList       :1,
                    fDefCertificate :1,
                    fPlainText      :1;

    // unique ID, if there is one
    BYTE            *lpbEID;
    ULONG           cbEID;
} ADRINFO, *LPADRINFO;

// AddrInfo list used for drag-drop of multiple AddrInfo's
typedef struct ADRINFOLIST_tag
{
    ULONG       cValues;
    LPADRINFO   rgAdrInfo;
}   ADRINFOLIST,
    FAR *LPADRINFOLIST;

typedef struct tagDLSEARCHINFO
{
    ULONG       cValues,        // count and list of distribution lists
                cAlloc;
    LPSBinary   rgEid;          // involved in this search...
}   DLSEARCHINFO,
    *PDLSEARCHINFO;


// ===============================================================================
// CWabal - WAB Address List class
// ===============================================================================
class CWabal;
typedef CWabal *LPWABAL;
class CWabal
{
private:
    ULONG               m_cRef;
    ULONG               m_cActualEntries;
    LPWABOBJECT         m_lpWabObject;
    LPADRBOOK           m_lpAdrBook;
    LPADRLIST           m_lpAdrList;
    ULONG               m_cMemberEnum,
                        m_cMembers;
    LPSRowSet           m_lprwsMembers;
    LPMIMEMESSAGE       m_pMsg;

private:
    BOOL FVerifyState (VOID);
    HRESULT HrGrowAdrlist (LPADRLIST *lppalCurr, ULONG caeToAdd);
    void AdrEntryToAdrInfo(LPADRENTRY lpAdrEntry, LPADRINFO lpAdrInfo);


    HRESULT HrAdrInfoFromRow(LPSRow lpsrw, LPADRINFO lpAdrInfo, LONG lRecipType);
    void PropValToAdrInfo(LPSPropValue ppv, LPADRINFO lpAdrInfo);
    HRESULT HrAddDistributionList(LPWABAL lpWabal, LPSRowSet lprws, LONG lRecipType, PDLSEARCHINFO pDLSearch);
    BOOL FDLVisted(SBinary eidDL, PDLSEARCHINFO pDLSearch);
    HRESULT HrAddToSearchList(SBinary eidDL, PDLSEARCHINFO pDLSearch);
    HRESULT FreeSearchList(PDLSEARCHINFO pDLSearch);
    HRESULT HrGetDistListRows(SBinary eidDL, LPSRowSet *psrws);

public:
    // Construct and Destruct
    CWabal ();
    ~CWabal ();

    // Ref counting
    ULONG AddRef (VOID);
    ULONG Release (VOID);

    // Adding an address
    HRESULT HrAddEntry (LPWSTR lpszDisplay, LPWSTR lpszAddress, LONG lRecipType);
    HRESULT HrAddEntryA(LPTSTR lpszDisplay, LPTSTR lpszAddress, LONG lRecipType);
    HRESULT HrAddEntry (LPADRINFO lpAdrInfo, BOOL fCheckDupes=FALSE);
    HRESULT HrAddUnresolved(LPWSTR lpszDisplayName, LONG lRecipType);
    ULONG   DeleteRecipType(LONG lRecipType);

    // Copy to a new wabal
    HRESULT HrCopyTo (LPWABAL lpWabal);
    HRESULT HrExpandTo(LPWABAL lpWabal);

    // Getting the lpadrlist
    LPADRLIST LpGetList (VOID);

    // Wab Object Accessors
    SCODE FreeBuffer(void *pv) { return m_lpWabObject->FreeBuffer(pv); }
    SCODE AllocateBuffer(ULONG ulSize, LPVOID FAR * lppv)
        { return m_lpWabObject->AllocateBuffer(ulSize, lppv); }
    SCODE AllocateMore(ULONG ulSize, LPVOID lpv, LPVOID FAR * lppv)
        { return m_lpWabObject->AllocateMore(ulSize, lpv, lppv); }

    // Give access to the IAdrBook object
    LPADRBOOK GetAdrBook(void) { return(m_lpAdrBook); }
    LPWABOBJECT GetWABObject(void) { return(m_lpWabObject); }

    // Set and Get the message object associated with this Wabal
    VOID SetAssociatedMessage(LPMIMEMESSAGE pMsg)
        { m_pMsg = pMsg; }
    LPMIMEMESSAGE GetAssociatedMessage(void)
        { return (m_pMsg); }

    HRESULT IsValidForSending();

    __inline    ULONG CEntries (VOID) { return m_cActualEntries; }

    // Reset address list
    VOID Reset (VOID);

    // Iterating through the list - LPADRINFO == NULL WHEN NO MORE
    // using dDupe, a new copy is returned, the caller must free this
    // using MemFree.
    BOOL FGetFirst (LPADRINFO lpAdrInfo);
    BOOL FGetNext (LPADRINFO lpAdrInfo);

    BOOL FFindFirst(LPADRINFO lpAdrInfo, LONG lRecipType);

    // Resolve Names
    HRESULT HrResolveNames (HWND hwndParent, BOOL fShowDialog);

    // builds a drag drop serialised HGLOBAL for a Wabal
    HRESULT HrBuildHGlobal(HGLOBAL *phGlobal);

    HRESULT HrPickNames (HWND hwndParent, ULONG *rgulTypes, int cWells, int iFocus, BOOL fNews);
    HRESULT HrRulePickNames(HWND hwndParent, LONG lRecipType, UINT uidsTitle, UINT uidsWell, UINT uidsWellButton);

    HRESULT HrGetPMP(ULONG cbEntryID, LPENTRYID lpEntryID, ULONG *lpul, LPMAPIPROP *lppmp);

    HRESULT HrSmartFind(HWND hwnd, LPSPropValue lpProps, ULONG cProps, LPENTRYID * lppEIDWAB,
      LPULONG lpcbEIDWAB);

    void UnresolveOneOffs();
};

// ===============================================================================
// CWab - Internet Personal Address Book
// ===============================================================================
class CWab
{
private:
    ULONG               m_cRef;
    LPWABOBJECT         m_lpWabObject;
    LPADRBOOK           m_lpAdrBook;
    ADRPARM             m_adrParm;
    HWND                m_hwnd;
    WNDPROC             m_pfnWabWndProc;
    BOOL                m_fInternal;
    HWNDLIST            m_hlDisabled;

private:
    BOOL FVerifyState (VOID);

public:
    // Construct and Destruct
    CWab ();
    ~CWab ();

    // Ref counting
    ULONG AddRef(VOID);
    ULONG Release(VOID);

    // Init the pab
    HRESULT HrInit(VOID);

    // Browse the address book
    HRESULT HrBrowse(HWND hwndParent, BOOL fModal=FALSE);
    HRESULT OnClose();

    // Pick names from the address book
    HRESULT HrPickNames (HWND hwndParent, ULONG *rgulTypes, int cWells, int iFocus, BOOL fNews, LPADRLIST *lppal);
    HRESULT HrGeneralPickNames(HWND hwndParent, ADRPARM *pAdrParms, LPADRLIST *lppal);

    // Add Entry
    HRESULT HrAddNewEntry(LPWSTR lpszDisplay, LPWSTR lpszAddress);
    HRESULT HrAddNewEntryA(LPTSTR lpszDisplay, LPTSTR lpszAddress);

    // Show details on a recipient
    HRESULT HrDetails(HWND hwndOwner, LPADRINFO *lplpAdrInfo);

    // add entry to the wab
    HRESULT HrAddToWAB(HWND hwndOwner, LPADRINFO lpAdrInfo, LPMAPIPROP * lppMailUser);
    HRESULT HrAddToWAB(HWND hwndOwner, LPADRINFO lpAdrInfo) {
        return HrAddToWAB(hwndOwner, lpAdrInfo, NULL);
    }

    // update a set of fields on an entry
    HRESULT HrUpdateWABEntryNoEID(HWND hwndParent, LPADRINFO lpAdrInfo, DWORD mask);
    // EID must be valid for this one
    HRESULT HrUpdateWABEntry(LPADRINFO lpAdrInfo, DWORD mask);

    HRESULT HrFind(HWND hwnd, LPWSTR lpwszAddress);

    HRESULT HrFillComboWithPABNames(HWND hwnd, int* pcRows);

    HRESULT HrCreateVCardFile(LPCTSTR szVCardName, LPCTSTR szFileName);

    HRESULT HrFromNameToIDs(LPCTSTR lpszVCardName, ULONG* pcbEID, LPENTRYID* lppEID);
    HRESULT HrFromIDToName(LPTSTR lpszName, ULONG cbEID, LPENTRYID lpEID);

    HRESULT HrNewEntry(HWND hwnd, LPTSTR lpszName);

    HRESULT HrEditEntry(HWND hwnd, LPTSTR lpszName);

    HRESULT HrGetAdrBook(LPADRBOOK* lppAdrBook);

    HRESULT HrGetWabObject(LPWABOBJECT* lppWabObject);

    BOOL FTranslateAccelerator(LPMSG lpmsg);
    VOID FreeLPSRowSet(LPSRowSet lpsrs);
    VOID FreePadrlist(LPADRLIST lpAdrList);
    VOID BrowseWindowClosed()   {m_hwnd = NULL;}
    HRESULT HrGetPABTable(LPMAPITABLE* ppTable);
    HRESULT SearchPABTable(LPMAPITABLE lpTable, LPWSTR pszValue, LPWSTR pszFound, INT cch);

    static LRESULT WabSubProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Added for ToolTip in the Preview Header pane

    HRESULT ResolveName(LPWSTR lpszName, LPWSTR *lppszResolvedText);
};

typedef CWab * LPWAB;

// ===============================================================================
// P R O T O T Y P E S
// ===============================================================================
HRESULT HrInitWab (BOOL fInit);
HRESULT HrCreateWabObject (LPWAB *lppWab);
HRESULT HrCreateWabalObject (LPWABAL *lppWabal);
HRESULT HrCreateWabalObjectFromHGlobal(HGLOBAL hGlobal, LPWABAL *lppWabal);
HRESULT HrCloseWabWindow();

HRESULT HrLoadPathWABEXE(LPTSTR szPath, ULONG cbPath);
BOOL    FWABTranslateAccelerator(LPMSG lpmsg);

// utility functions
HRESULT HrDupeAddrInfo(LPADRINFO lpAdrInfo, LPADRINFO *lplpAdrInfo);
HRESULT HrInitWab (BOOL fInit);
HRESULT HrBuildCertSBinaryData(
  BOOL                  bIsDefault,
  THUMBBLOB*            pPrint,
  BLOB *                pSymCaps,
  FILETIME              ftSigningTime,
  LPBYTE UNALIGNED FAR* lplpbData,
  ULONG UNALIGNED FAR*  lpcbData);
LPBYTE FindX509CertTag(LPSBinary lpsb, ULONG ulTag, ULONG * pcbReturn);
HRESULT GetX509CertTags(LPSBinary lpsb, THUMBBLOB * ptbCertificate, BLOB * pblSymCaps, LPFILETIME pftSigningTime, BOOL * pfDefault);
HRESULT HrWABCreateEntry(LPADRBOOK lpAdrBook, LPWABOBJECT lpWabObject,
  LPWSTR lpwszDisplay, LPWSTR lpszAddress, ULONG ulFlags, LPMAILUSER * lppMailUser, ULONG ulSaveFlags=KEEP_OPEN_READONLY);
HRESULT ThumbprintToPropValue(LPSPropValue ppv, THUMBBLOB *pPrint, BLOB *pSymCaps, FILETIME ftSigningTime, BOOL fDefPrint);
void ImportWAB(HWND hwnd);

void Wab_CoDecrement();

#endif // __IPAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\layout.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     layout.h
//
//  PURPOSE:    Defines the IDs and public functions for the layout prop
//              sheet.
//

#include "browser.h"

BOOL LayoutProp_Create(HWND hwndParent, IAthenaBrowser *pBrowser, LAYOUT *pLayout);
INT_PTR CALLBACK LayoutProp_General(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define IDC_CHECK_FOLDERLIST                102
#define IDC_CHECK_FOLDERBAR                 103
#define IDC_CHECK_PREVIEW                   104
#define IDC_RADIO_SPLIT_HORZ                105
#define IDC_RADIO_SPLIT_VERT                106
#define IDC_CHECK_PREVIEW_HEADER	        107

// This order must match the order of the COOLBAR_SIDE enum in itbar.h
#define IDC_BUTTON_CUSTOMIZE		114
#define IDC_CHECK_TIP			    115
#define IDC_CHECK_STATUSBAR         116
#define IDC_CHECK_INFOPANE          117
#define IDC_CHECK_TOOLBAR           118
#define IDC_CHECK_OUTLOOKBAR        119
#define IDC_CHECK_CONTACTS          120
#define IDC_CHECK_FILTERBAR         121
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\iso8601.cpp ===
#include "pch.hxx"
#include <stdio.h>
#include <windows.h>
#include "iso8601.h"

// This code implements a parser & generater for the ISO 8601 date format.

// This table defines different "types" of characters for use as the columns
// of the state table

unsigned char iso8601chartable[256] = {
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0x82, 0,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// State table
// 0x80 bit = Error
// 0x20 = Add character & advance to next field
// 0x40 = Add character & advance to next field + skip one (for day of week)
// 0x1f = Mask to determine next state #

// Columns = input character type: unknown, number, "-", "T", ":", "Z"
unsigned char iso8601StateTable[][6] =
{
	0x80, 0x01, 0x25, 0x80, 0x80, 0x80, // year
	0x80, 0x02, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x03, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x24, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x06, 0x05, 0x85, 0x85, 0x05, //0x04 month
	0x80, 0x06, 0x48, 0x80, 0x80, 0x80,
	0x80, 0x47, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x09, 0x08, 0x88, 0x88, 0x08, //0x07 day
	0x80, 0x09, 0x8b, 0x2b, 0x8b, 0x80,
	0x80, 0x2a, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x0c, 0x8b, 0x0b, 0x8b, 0x08, //0x0a hour
	0x80, 0x0c, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x2d, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x0f, 0x8e, 0x8e, 0x0e, 0x08, //0x0d min
	0x80, 0x0f, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x30, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x12, 0x91, 0x91, 0x11, 0x08, //0x10 sec
	0x80, 0x12, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x30, 0x80, 0x80, 0x80, 0x80,
};

// Convert a character string formatted as iso8601 into a SYSTEMTIME structure
// Supports both basic & extended forms of iso8601.
// isoDate: Input string. It can be null or space terminated.
// pSysTime: Output SYSTEMTIME structure
// lenient: true for normal operation. "false" if you want to detect incorrectly
//			formatted iso8601. Will still return the "best guess" value.
// partial: Set to true if you will accept partial results. Note that this just fills
//			in zeros where data is missing, which strictly speaking can't be distinguished
//			from real zeros in this implementation. An improvement would have a second
//			structure to fill in with validity bits.

HRESULT iso8601::toSystemTime(char *pszISODate, SYSTEMTIME *pst, DWORD *pdwFlags, BOOL fLenient, BOOL fPartial)
{
	HRESULT hr = S_OK;
	WORD *dateWords = (WORD *)pst;
	WORD *endWord = dateWords + 7;	// To detect the end of the date
	DWORD dwFlags = NOFLAGS;
    int state = 0;
	DWORD pos = 0;
	*dateWords = 0;

    if (NULL == pszISODate || NULL == pst)
        return E_INVALIDARG;

	// Main state machine loop. Loop until a space or null.
	while(*pszISODate && *pszISODate != ' ')
	{
		char code = iso8601chartable[*pszISODate];
		if(code & 0x80)
			{
			if(!fLenient)
				hr = E_FAIL;	// Illegal character only when lenient
			code = code & 0x7f;
			}
		unsigned char action = iso8601StateTable[state][code];
		
		state = action&0x1f;	// Calculate the next state

		if(code == 1)	// The character code 1 is always a number which gets accumulated
        {
            dwFlags |= (1 << pos);
			*dateWords = *dateWords * 10 + *pszISODate - '0';
        }

		switch(action >> 5)
		{
		case 0x1:
			if(!fPartial && !*dateWords)
				hr = E_FAIL; // Only partial, error
			if(dateWords == endWord)	// Prevent an overflow
            {
                if (pdwFlags)
                    *pdwFlags = dwFlags;
				return S_OK;
            }
            pos++;
			dateWords++;
			*dateWords = 0;
			break;
		case 0x2:	// Finish piece & advance twice (past day of week)
			if(!fPartial && !*dateWords)
				hr = E_FAIL; // Only partial, error

			// We don't need to check for an overflow here since the state machine
			// only calls this to skip "dayofweek" in the SYSTEMTIME structure.
			// We could do dateWords+=2 instead of the following if leaving random
			// values in dayofweek is acceptable.
			dateWords++;
			*dateWords = 0;
			dateWords++;
			*dateWords = 0;
            pos += 2;
			break;
		}
		if((action & 0x80) && !fLenient)
			hr = E_FAIL;
		pszISODate++;
	}

	// Zero out the rest of the SYSTEMTIME structure
	while(dateWords < endWord)
		*(++dateWords) = 0;

    if (pdwFlags)
        *pdwFlags = dwFlags;

	return hr;
}

// The function toExtended accepts a SYSTEMTIME and converts it into the ISO8601 extended
// form, placeing it in the character buffer 'buf'. The buffer 'buf' must have room for
// a minimum of 40 characters to support the longest forms of 8601 (currently only 21 are used).
HRESULT iso8601::fromSystemTime(SYSTEMTIME *pst, char *pszISODate)
{
    if (NULL == pst || NULL == pszISODate)
        return E_INVALIDARG;

	pszISODate[0] = pst->wYear / 1000 + '0';
	pszISODate[1] = ((pst->wYear / 100) % 10) + '0';
	pszISODate[2] = ((pst->wYear / 10) % 10) + '0';
	pszISODate[3] = ((pst->wYear) % 10) + '0';
	pszISODate[4] = '.';
	pszISODate[5] = pst->wMonth / 10 + '0';
	pszISODate[6] = (pst->wMonth % 10) + '0';
	pszISODate[7] = '.';
	pszISODate[8] = pst->wDay / 10 + '0';
	pszISODate[9] = (pst->wDay % 10) + '0';
	pszISODate[10] = 'T';
	pszISODate[11] = pst->wHour / 10 + '0';
	pszISODate[12] = (pst->wHour % 10) + '0';
	pszISODate[13] = ':';
	pszISODate[14] = pst->wMinute / 10 + '0';
	pszISODate[15] = (pst->wMinute % 10) + '0';
	pszISODate[16] = ':';
	pszISODate[17] = pst->wSecond / 10 + '0';
	pszISODate[18] = (pst->wSecond % 10) + '0';
	pszISODate[19] = 'Z';
	pszISODate[20] = 0;

	return S_OK;
}

HRESULT iso8601::toFileTime(char *pszISODate, FILETIME *pft, DWORD *pdwFlags, BOOL fLenient, BOOL fPartial)
{
    SYSTEMTIME  st;
    HRESULT     hr;

    hr = toSystemTime(pszISODate, &st, pdwFlags, fLenient, fPartial);

    if (SUCCEEDED(hr))
        hr = (SystemTimeToFileTime(&st, pft)?S_OK:E_FAIL);

    return hr;
}

HRESULT iso8601::fromFileTime(FILETIME *pft, char *pszISODate)
{
    SYSTEMTIME  stTime;
    HRESULT     hr = E_FAIL;

    if (FileTimeToSystemTime(pft, &stTime))
        hr = fromSystemTime(&stTime, pszISODate);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\itbar.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     itbar.h
//
//  PURPOSE:    Defines the CCoolbar class.
//

/******************************************************
Please do not make any changes to this file. 
Instead add the changes to tbbands.cpp and tbbands.h. 
This file will be deleted from the project soon.
******************************************************/

#ifndef __ITBAR_H__
#define __ITBAR_H__

#include "conman.h"
#include "mbcallbk.h"

typedef struct tagTOOLBARARRAYINFO TOOLBARARRAYINFO;

#define SIZABLECLASS TEXT("SizableRebar")

// Length of the text under each quick links and toolbar buttton
#define MAX_QL_TEXT_LENGTH      256
#define BAND_NAME_LEN           32

// Number of Sites on the quick link bar and max number of toolbar buttons
#define MAX_TB_BUTTONS          10

/*
// Indicies for the Coolbar bar
#define CBTYPE_NONE              0
#define CBTYPE_BRAND             1
#define CBTYPE_TOOLS             2
#define CBTYPE_MENUBAND          3
#define CBANDS                   3
*/
#define CBANDS                   3

// Identify the sides of the window
typedef enum { 
    COOLBAR_TOP = 0, 
    COOLBAR_LEFT, 
    COOLBAR_BOTTOM, 
    COOLBAR_RIGHT, 
    COOLBAR_SIDEMAX
} COOLBAR_SIDE;

#define VERTICAL(side)      (BOOL)(((side) == COOLBAR_LEFT) || ((side) == COOLBAR_RIGHT))

#define COOLBAR_VERSION         0x03

#define MAX_TB_COMPRESSED_WIDTH 42
#define MAX_TB_TEXT_ROWS_VERT   2
#define MAX_TB_TEXT_ROWS_HORZ   1

// Dimensions of Coolbar Glyphs ..
#define TB_BMP_CX_W2K           22
#define TB_BMP_CX               24
#define TB_BMP_CY               24
#define TB_SMBMP_CX             16
#define TB_SMBMP_CY             16

// Max length of Button titles
#define MAX_TB_TEXT_LENGTH      256

// Indices for Toolbar imagelists
enum {
    IMLIST_DEFAULT = 0,
    IMLIST_HOT,
    CIMLISTS
};

void InitToolbar(const HWND hwnd, const int cHiml, HIMAGELIST *phiml,
                 UINT nBtns, const TBBUTTON *ptbb,
                 const TCHAR *pStrings,
                 const int cxImg, const int cyImg, const int cxMax,
                 const int idBmp, const BOOL fCompressed,
                 const BOOL fVertical);
void LoadGlyphs(const HWND hwnd, const int cHiml, HIMAGELIST *phiml, const int cx, const int idBmp);
BOOL LoadToolNames(const UINT *rgIds, const UINT cIds, LPTSTR szTools);



// These are the various states the coolbar can have
#define CBSTATE_HIDDEN          0x00000001
#define CBSTATE_COMPRESSED      0x00000002
#define CBSTATE_NOBACKGROUND    0x00000004
#define CBSTATE_ANIMATING       0x00000008
#define CBSTATE_COLORBUTTONS    0x00000010
#define CBSTATE_INMENULOOP      0x00000020
#define CBSTATE_FIRSTFRAME      0x00000040

// BANDSAVE &  - These structures are used to persist the state of the coolbar
// COOLBARSAVE   including the band order, visiblity, size, side, etc.
typedef struct tagBANDSAVE {
    DWORD           wID;
    DWORD           dwStyle;
    DWORD           cx;
} BANDSAVE, *PBANDSAVE;

typedef struct tagCOOLBARSAVE {
    DWORD           dwVersion;
    DWORD           dwState;
    COOLBAR_SIDE    csSide;
    BANDSAVE        bs[CBANDS];
} COOLBARSAVE, *PCOOLBARSAVE;
    
// These structs are used for the CCoolbar::Invoke() member.  They allow
// the caller to specify more information for particular commands.
typedef struct tagCOOLBARSTATECHANGE {
    UINT id;
    BOOL fEnable;
} COOLBARSTATECHANGE, *LPCOOLBARSTATECHANGE;

typedef struct tagCOOLBARBITMAPCHANGE {
    UINT id;
    UINT index;
} COOLBARBITMAPCHANGE;

typedef struct tagUPDATEFOLDERNAME {
    LPTSTR pszServer;
    LPTSTR pszGroup;
} UPDATEFOLDERNAME, *LPUPDATEFOLDERNAME;

typedef struct tagTOOLMESSAGE
    {
    UINT uMsg;
    WPARAM wParam;
    LPARAM lParam;
    LRESULT lResult;
    } TOOLMESSAGE;

void SendSaveRestoreMessage(HWND hwnd, const TOOLBARARRAYINFO *ptai, BOOL fSave);

class CCoolbar : public IDockingWindow,
                 public IObjectWithSite,
                 public IConnectionNotify
    {
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and initialization
    CCoolbar();
    HRESULT HrInit(DWORD idBackground, HMENU    hmenu);

protected:
    virtual ~CCoolbar();

public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    /////////////////////////////////////////////////////////////////////////
    // IDockingWindow methods
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                        IUnknown* punkToolbarSite,
                                        BOOL fReserved);

    /////////////////////////////////////////////////////////////////////////
    // IObjectWithSite methods
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, LPVOID * ppvSite);

    /////////////////////////////////////////////////////////////////////////
    // IConnectionNotify
    virtual STDMETHODIMP OnConnectionNotify(CONNNOTIFY nCode, LPVOID pvData, CConnectionManager *pConMan);

    /////////////////////////////////////////////////////////////////////////
    // This allows the view to send commands etc. to the toolbar
    virtual STDMETHODIMP Invoke(DWORD id, LPVOID pv);
    HRESULT SetFolderType(FOLDERTYPE ftType);

    virtual STDMETHODIMP OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    virtual STDMETHODIMP OnInitMenuPopup(HMENU hMenu);
    BOOL  GetText(void) { return !IsFlagSet(CBSTATE_COMPRESSED); }
    COOLBAR_SIDE GetSide(void) { return (m_csSide); }
    void SetSide(COOLBAR_SIDE csSide);
    void SetText(BOOL fText);

    HRESULT Update(void);
    HRESULT TranslateMenuMessage(MSG *lpmsg, LRESULT   *lpresult);
    HRESULT IsMenuMessage(MSG *lpmsg);
    void    SetNotRealSite();
    BOOL CheckForwardWinEvent(HWND hwnd,  UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);

protected:
    void StartDownload();
    void StopDownload();

    /////////////////////////////////////////////////////////////////////////
    // Window procedure and message handlers
    static LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, 
                                           LPARAM lParam);
    virtual LRESULT OnNotify(HWND hwnd, LPARAM lparam);
    virtual void OnContextMenu(HWND hwndFrom, int xPos, int yPos);
    virtual LRESULT OnDropDown(HWND hwnd, LPNMHDR lpnmh);

    LRESULT OnGetButtonInfo(TBNOTIFY* ptbn);

    /////////////////////////////////////////////////////////////////////////
    // Used for animating the logo to show progress
    HRESULT ShowBrand(void);
    HRESULT LoadBrandingBitmap(void);    
    void DrawBranding(LPDRAWITEMSTRUCT lpdis);

    /////////////////////////////////////////////////////////////////////////
    // For sizing etc.
    BOOL SetMinDimensions(void);    
    BOOL CompressBands(BOOL fCompress);
    void TrackSlidingX(int x);
    void TrackSlidingY(int y);
    BOOL ChangeOrientation();

    /////////////////////////////////////////////////////////////////////////
    // Initialization and persistance
    HRESULT CreateRebar(BOOL);
    void SaveSettings(void);
    
    /////////////////////////////////////////////////////////////////////////
    // Toolbar Stuff
    HRESULT AddTools(PBANDSAVE pbs);
    void InitToolbar();
    void UpdateToolbarColors(void);
    void _UpdateWorkOffline(DWORD cmdf);

    HRESULT CreateMenuBand(PBANDSAVE pbs);
    HRESULT AddMenuBand(PBANDSAVE pbs);

    void    HideToolbar(DWORD    dwBandID);
    void    HandleCoolbarPopup(UINT xPos, UINT yPos);

    /////////////////////////////////////////////////////////////////////////
    // Misc. stuff
    UINT                m_cRef;              // Ref count
    IDockingWindowSite *m_ptbSite;
    LONG                m_cxMaxButtonWidth;    
    FOLDERTYPE          m_ftType;
    const TOOLBARARRAYINFO   *m_ptai;
    BOOL                m_fSmallIcons;
    
    /////////////////////////////////////////////////////////////////////////
    // Handy window handles to have around
    HWND            m_hwndParent;
    HWND            m_hwndTools;
    HWND            m_hwndBrand;
    HWND            m_hwndSizer;
    HWND            m_hwndRebar;

    /////////////////////////////////////////////////////////////////////////
    // State variables
    COOLBARSAVE     m_cbsSavedInfo;
    COOLBAR_SIDE    m_csSide;
    DWORD           m_dwState;

    /////////////////////////////////////////////////////////////////////////
    // GDI Resources
    UINT            m_idbBack;              // Id of the background bitmap.  Set by the subclasses.
    HBITMAP         m_hbmBack;              // Background bitmap
    HBITMAP         m_hbmBrand;
    HIMAGELIST      m_rghimlTools[CIMLISTS];  // These are for the default toolbar

    /////////////////////////////////////////////////////////////////////////
    // Used for animating the logo etc
    HPALETTE        m_hpal;
    HDC             m_hdc;
    int             m_xOrg;
    int             m_yOrg;
    int             m_cxBmp;
    int             m_cyBmp;
    int             m_cxBrand;
    int             m_cyBrand;
    int             m_cxBrandExtent;
    int             m_cyBrandExtent;
    int             m_cyBrandLeadIn;
    COLORREF        m_rgbUpperLeft;  

    /////////////////////////////////////////////////////////////////////////
    // Used in resizing etc
    int             m_xCapture;
    int             m_yCapture;

    //Used by Menubands
    IShellMenu      *m_pShellMenu;
    IDeskBand       *m_pDeskBand;
    IMenuBand       *m_pMenuBand;
    HMENU           m_hMenu;
    CMenuCallback   *m_mbCallback;
    IWinEventHandler *m_pWinEvent;
    HWND            m_hwndMenuBand;
    };

// DOUTL levels
#define DM_TBSITE   0
#define DM_TBCMD    0
#define DM_TBREF    TF_SHDREF
#define DM_LAYOUT   0

#define FCIDM_BRANDING          12345
#define ANIMATION_TIMER         123
#define ANIMATION_DELTA_X       25
#define ANIMATION_DELTA_Y       5

// flags for _dwURLChangeFlags
#define URLCHANGED_TYPED              0x0001
#define URLCHANGED_SELECTEDFROMCOMBO  0x0002

#define idDownloadBegin         100
#define idDownloadEnd           101
#define idStateChange           102
#define idUpdateFolderList      103
#define idUpdateCurrentFolder   104
#define idSendToolMessage       105
#define idBitmapChange          106
#define idToggleButton          107
#define idCustomize             108

// Child window id's
#define idcCoolbarBase          2000
#define idcSizer                (idcCoolbarBase - 2)
#define idcCoolbar              (idcCoolbarBase - 1)
#define idcToolbar              (idcCoolbarBase + CBTYPE_TOOLS)
#define idcBrand                (idcCoolbarBase + CBTYPE_BRAND)

// Coolbar drawing states
#define DRAW_NOBACKGROUND       0x1
#define DRAW_COLORBUTTONS       0x2

// Folder switching timer
#define FOLDER_SWITCHTIMER      200
#define FOLDER_SWITCHDELAY      400


#endif // __ITBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\mbcallbk.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     mbcallbk.cpp
//
//  PURPOSE:    Implements the sizable coolbar window.
//

#include "pch.hxx"
#include "mbcallbk.h"

CMenuCallback::CMenuCallback() : m_cRef(1)
{
}

CMenuCallback::~CMenuCallback()
{
    //ASSERT(_punkSite == NULL);

}

STDMETHODIMP_(ULONG) CMenuCallback::AddRef ()
{
    return ++m_cRef;
}

/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CMenuCallback::Release()
{
//    ASSERT(m_cRef > 0);
    m_cRef--;

    if( m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CMenuCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{ 
    if (IsEqualIID(riid, IID_IObjectWithSite))
    {
        *ppvObj = (IObjectWithSite*)this;
        m_cRef++;
        DOUTL(2, TEXT("CMenuCallback::QI(IID_IObjectWithSite) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IShellMenuCallback))
    {
        *ppvObj = (IShellMenuCallback*)this;
        m_cRef++;
        DOUTL(2, TEXT("CMenuCallback::QI(IID_IShellCallback) called. _cRef=%d"), m_cRef);
        return S_OK;
    }
    
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = S_FALSE;

    switch (uMsg)
    {
        case    SMC_GETINFO:
        {
            SMINFO  *psmInfo = (SMINFO*)lParam;
            if (psmInfo->dwMask & SMIM_FLAGS)
            {
                psmInfo->dwFlags |= SMIF_TRACKPOPUP;
                hres = S_OK;
            }
            break;
        }

        default:
            hres = S_FALSE;
    }

    return hres;
}

STDMETHODIMP CMenuCallback::SetSite(IUnknown* punk)
{
    _pUnkSite = punk;
    return S_OK;
}

STDMETHODIMP CMenuCallback::GetSite(REFIID riid, void** ppvsite)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\mbcallbk.h ===
#ifndef _mcallbk_H_
#define _mcallbk_H_


// IShellMenuCallback implementation
class CMenuCallback : public IShellMenuCallback,
                           public IObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** IObjectWithSite methods (override)***
    STDMETHODIMP SetSite(IUnknown* punk);
    STDMETHODIMP CMenuCallback::GetSite(REFIID riid, void** ppvsite);

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CMenuCallback();
private:
    virtual ~CMenuCallback();
    int         m_cRef;
    IUnknown     *_pUnkSite;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\menuutil.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     menuutil.h
//
//  PURPOSE:    Reusable menu & menu command handling code
//

#pragma once
#include "statbar.h"


// #defines that can be used with QueryStatus
inline DWORD QS_ENABLED(BOOL enabled)
{
    return (enabled ? OLECMDF_SUPPORTED|OLECMDF_ENABLED : OLECMDF_SUPPORTED);
}

inline DWORD QS_CHECKED(BOOL checked)
{
    return (checked ? OLECMDF_SUPPORTED|OLECMDF_ENABLED|OLECMDF_LATCHED : OLECMDF_SUPPORTED|OLECMDF_ENABLED);
}

inline DWORD QS_ENABLECHECK(BOOL enabled, BOOL checked)    
{
    if (!enabled)
        return OLECMDF_SUPPORTED;
    else
        return (checked ? OLECMDF_SUPPORTED|OLECMDF_ENABLED|OLECMDF_LATCHED : OLECMDF_SUPPORTED|OLECMDF_ENABLED);
}

inline DWORD QS_CHECKFORLATCH(BOOL enabled, BOOL checked)    
{
    if (!enabled)
        return (checked ? OLECMDF_SUPPORTED|OLECMDF_LATCHED : OLECMDF_SUPPORTED);
    else
        return (checked ? OLECMDF_SUPPORTED|OLECMDF_ENABLED|OLECMDF_LATCHED : OLECMDF_SUPPORTED|OLECMDF_ENABLED);
}

inline DWORD QS_RADIOED(BOOL radioed)
{
    return (radioed ? OLECMDF_SUPPORTED|OLECMDF_ENABLED|OLECMDF_NINCHED : OLECMDF_SUPPORTED|OLECMDF_ENABLED);
}

inline DWORD QS_ENABLERADIO(BOOL enabled, BOOL radioed)
{
    if (!enabled)
        return OLECMDF_SUPPORTED;
    else
        return (radioed ? OLECMDF_SUPPORTED|OLECMDF_ENABLED|OLECMDF_NINCHED : OLECMDF_SUPPORTED|OLECMDF_ENABLED);
}


//
//  FUNCTION:   MenuUtil_GetContextMenu()
//
//  PURPOSE:    Returns a handle to the context menu that is appropriate for
//              the folder type passed in pidl.  The correct menu items will
//              be enabled, disabled, bolded, etc.
//
HRESULT MenuUtil_GetContextMenu(FOLDERID idFolder, IOleCommandTarget *pTarget, HMENU *phMenu);

//
//  FUNCTION:   MenuUtil_OnDelete()
//
//  PURPOSE:    Deletes the folder designated by the pidl.
//
void MenuUtil_OnDelete(HWND hwnd, FOLDERID idFolder, BOOL fNoTrash);
void MenuUtil_DeleteFolders(HWND hwnd, FOLDERID *pidFolder, DWORD cFolder, BOOL fNoTrash);
                               
//
//  FUNCTION:   MenuUtil_OnProperties()
//
//  PURPOSE:    Displays properties for the folder designated by the pidl
//
void MenuUtil_OnProperties(HWND hwnd, FOLDERID idFolder);

void MenuUtil_OnSetDefaultServer(FOLDERID idFolder);
void MenuUtil_OnSubscribeGroups(HWND hwnd, FOLDERID *pidFolder, DWORD cFolder, BOOL fSubscribe);
void MenuUtil_OnMarkNewsgroups(HWND hwnd, int id, FOLDERID idFolder);
void MenuUtil_SyncThisNow(HWND hwnd, FOLDERID idFolder);

// BUG #41686 Catchup Implementation

void MenuUtil_OnCatchUp(FOLDERID idFolder);

// if you want to prepend use iPos 0
#define MMPOS_APPEND    (int)-1
#define MMPOS_REPLACE   (int)-2

// MergeMenus uFlags definitions
#define MMF_SEPARATOR   0x0001
#define MMF_BYCOMMAND   0x0002

BOOL MergeMenus(HMENU hmenuSrc, HMENU hmenuDst, int iPos, UINT uFlags);
HMENU LoadPopupMenu(UINT id);

typedef void (*WALKMENUFN)(HMENU, UINT, LPVOID);
void WalkMenu(HMENU hMenu, WALKMENUFN pfn, LPVOID lpv);

HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, IOleCommandTarget *pTarget);

void MenuUtil_SetPopupDefault(HMENU hPopup, UINT idDefault);

void HandleMenuSelect(CStatusBar *pStatus, WPARAM wParam, LPARAM lParam);

//
//  FUNCTION:   MenuUtil_ReplaceHelpMenu
//
//  PURPOSE:    Appends the OE help menu to the back of the menu
//
void MenuUtil_ReplaceHelpMenu(HMENU hMenu);
void MenuUtil_ReplaceNewMsgMenus(HMENU hMenu);
void MenuUtil_ReplaceMessengerMenus(HMENU hMenu);
BOOL MenuUtil_BuildMessengerString(LPTSTR szMesStr);

BOOL MenuUtil_HandleNewMessageIDs(DWORD id, HWND hwnd, FOLDERID folderID, BOOL fMail, BOOL fModal, IUnknown *pUnkPump);
HRESULT MenuUtil_NewMessageIDsQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText, BOOL fMail);
HRESULT MenuUtil_EnableMenu(HMENU hMenu, IOleCommandTarget *pTarget);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\mimeutil.h ===
// --------------------------------------------------------------------------------
// Mimeutil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIMEUTIL_H
#define __MIMEUTIL_H

// --------------------------------------------------------------------------------
// Dependencies
// --------------------------------------------------------------------------------
#include "mimeole.h"
#include "imnact.h"
class CWabal;
typedef CWabal *LPWABAL;
typedef struct SECURITY_PARAMtag SECURITY_PARAM;
typedef struct tagHTMLOPT HTMLOPT;
typedef struct tagPLAINOPT PLAINOPT;

// --------------------------------------------------------------------------------
// Mail Message Index Cache Header
// --------------------------------------------------------------------------------
#define SafeMimeOleFree(_pv) \
    if (_pv) { \
        Assert(g_pMoleAlloc); \
        g_pMoleAlloc->Free(_pv); \
        _pv = NULL; \
    } else

#define MimeOleAlloc(_cb)  g_pMoleAlloc->Alloc(_cb)

// --------------------------------------------------------------------------------
// Cached Current Default Character Set From Fonts Options Dialog
// --------------------------------------------------------------------------------
extern HCHARSET g_hDefaultCharsetForNews;
extern HCHARSET g_hDefaultCharsetForMail;
extern int g_iLastCharsetSelection;
extern int g_iCurrentCharsetSelection;

// --------------------------------------------------------------------------------
// Message constructors
// Note: Everyone should use HrCreateMessage as it wraps the MimeOle call passing
//       an Athena-Specific implementation of the MimeInline Object to correctly
//       in-line HTML and PLAIN text
// --------------------------------------------------------------------------------
HRESULT HrCreateMessage(IMimeMessage **ppMsg);


// --------------------------------------------------------------------------------
// Message Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrSaveMsgToFile(LPMIMEMESSAGE pMsg, LPSTR lpszFile);
HRESULT HrLoadMsgFromFile(LPMIMEMESSAGE pMsg, LPSTR lpszFile);
HRESULT HrLoadMsgFromFileW(LPMIMEMESSAGE pMsg, LPWSTR lpwszFile);
HRESULT HrDupeMsg(LPMIMEMESSAGE pMsg, LPMIMEMESSAGE *ppMsg);
HRESULT HrSetServer(LPMIMEMESSAGE pMsg, LPSTR lpszServer);
HRESULT HrSetAccount(LPMIMEMESSAGE pMsg, LPSTR pszAcctName);
HRESULT HrSetAccountByAccount(LPMIMEMESSAGE pMsg, IImnAccount *pAcct);


// --------------------------------------------------------------------------------
// Wabal Conversion Functions
// --------------------------------------------------------------------------------
HRESULT HrGetWabalFromMsg(LPMIMEMESSAGE pMsg, LPWABAL *ppWabal);
HRESULT HrSetWabalOnMsg(LPMIMEMESSAGE pMsg, LPWABAL pWabal);
HRESULT HrCheckDisplayNames(LPWABAL lpWabal, CODEPAGEID cpID);
#if 0
HRESULT HrSetReplyTo(LPMIMEMESSAGE pMsg, LPSTR lpszEmail);
#endif
LONG MimeOleRecipToMapi(IADDRESSTYPE addrtype);
IADDRESSTYPE MapiRecipToMimeOle(LONG lRecip);


// --------------------------------------------------------------------------------
// Attachment helper functions
// --------------------------------------------------------------------------------
HRESULT HrRemoveAttachments(LPMIMEMESSAGE pMsg, BOOL fKeepRelatedSection);
// Note: the caller of GetAttachIcon must call DestroyIcon on the hIcon returned!
HRESULT GetAttachmentCount(LPMIMEMESSAGE pMsg, ULONG *cCount);

// --------------------------------------------------------------------------------
// Random Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrComputeLineCount(LPMIMEMESSAGE pMsg, LPDWORD pdw);
HRESULT HrHasEncodedBodyParts(LPMIMEMESSAGE pMsg, ULONG cBody, LPHBODY rghBody);
HRESULT HrHasBodyParts(LPMIMEMESSAGE pMsg);
HRESULT HrIsBodyEncoded(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrCopyHeader(LPMIMEMESSAGE pMsg, HBODY hBodyDest, HBODY hBodySrc, LPCSTR pszName);
HRESULT HrSetMessageText(LPMIMEMESSAGE pMsg, LPTSTR pszText);

// --------------------------------------------------------------------------------
// MHTML Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrIsInRelatedSection(LPMIMEMESSAGE pMsg, HBODY hBody);
#if 0
HRESULT HrFindUrlInMsg(LPMIMEMESSAGE pMsg, LPSTR lpszUrl, LPSTREAM *ppstm);
HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt);
#endif
// --------------------------------------------------------------------------------
// Random functions that probably shouldn't even be in this file
// --------------------------------------------------------------------------------
#if 0
HRESULT HrEscapeQuotedString (LPTSTR pszIn, LPTSTR *ppszOut);
#endif
// sizeof(lspzBuffer) needs to be == or > CCHMAX_CSET_NAME
HRESULT HrGetMetaTagName(HCHARSET hCharset, LPSTR lpszBuffer);


#if 0
// --------------------------------------------------------------------------------
// functions for ghosting props
// --------------------------------------------------------------------------------
HRESULT HrMarkGhosted(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrIsGhosted(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrGhostKids(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrDeleteGhostedKids(LPMIMEMESSAGE pMsg, HBODY hBody);
#endif

// --------------------------------------------------------------------------------
// Internat Stuff
// --------------------------------------------------------------------------------
HRESULT HGetDefaultCharset(HCHARSET *hCharset);
void SetDefaultCharset(HCHARSET hCharset);
UINT uCodePageFromCharset(HCHARSET hCharset);
UINT uCodePageFromMsg(LPMIMEMESSAGE pMsg);
HRESULT HrSetMsgCodePage(LPMIMEMESSAGE pMsg, UINT uCodePage);
#if 0
HRESULT HrIStreamWToInetCset(LPSTREAM pstmW, HCHARSET hCharset, LPSTREAM *ppstmOut);
#endif
// --------------------------------------------------------------------------------
// Property Utilities
// --------------------------------------------------------------------------------
HRESULT HrSetSentTimeProp(IMimeMessage *pMessage, LPSYSTEMTIME pst /* optional */ );
HRESULT HrSetMailOptionsOnMessage(IMimeMessage *pMessage, HTMLOPT *pHtmlOpt, PLAINOPT *pPlainOpt,
    HCHARSET hCharset, BOOL fHTML);
HRESULT HrSafeToEncodeToCP(LPWSTR pwsz, CODEPAGEID cpID);
HRESULT HrSafeToEncodeToCPA(LPCSTR psz, CODEPAGEID cpSrc, CODEPAGEID cpDest);

#endif // __MIMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\mimeutil.cpp ===
// --------------------------------------------------------------------------------
// Mimeutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "demand.h"
#include "ipab.h"
#include "resource.h"
#include <mimeole.h>
#include "mimeutil.h"
#include "secutil.h"
#include "strconst.h"
#include "oleutil.h"
#include <error.h>
#include "options.h"
#include <shlwapi.h>
#include "fonts.h"
#include "multlang.h"
#include "xpcomm.h"
#include "multiusr.h"

// --------------------------------------------------------------------------------
// Cached Current Default Character Set From Fonts Options Dialog
// --------------------------------------------------------------------------------
static HCHARSET g_hDefaultCharset=NULL; // default charset for reading
HCHARSET g_hDefaultCharsetForMail=NULL; // default charset for sending news
int g_iLastCharsetSelection=0;    // last charset selection from View/Language
int g_iCurrentCharsetSelection=0; // current charset selection from View/Language


// --------------------------------------------------------------------------------
// local function
// --------------------------------------------------------------------------------
HRESULT HrGetCodePageTagName(ULONG uCodePage, BSTR *pbstr);
HRESULT GetSubTreeAttachCount(LPMIMEMESSAGE pMsg, HBODY hFirst, ULONG *cCount);
         
HRESULT HrSetMessageText(LPMIMEMESSAGE pMsg, LPTSTR pszText)
{
    TCHAR       rgchText[CCHMAX_STRINGRES];
    HBODY       hBody;
    IStream    *pstm;

    // Is it a string resource id?
    if (IS_INTRESOURCE(pszText))
    {
        if (0 == AthLoadString(PtrToUlong(pszText), rgchText, sizeof(rgchText)))
            return E_FAIL;
        
        pszText = rgchText;
    }
    
    if (SUCCEEDED(pMsg->GetBody(IBL_ROOT, 0, &hBody)))
        pMsg->DeleteBody(hBody, 0);
    
    if (MimeOleCreateVirtualStream(&pstm)==S_OK)
    {
        pstm->Write(pszText, lstrlen(rgchText)*sizeof(TCHAR), NULL);
        pMsg->SetTextBody(TXT_HTML, IET_BINARY, NULL, pstm, NULL);
        pstm->Release();
    }
    pMsg->Commit(0);

    return S_OK;
}

HRESULT HrGetWabalFromMsg(LPMIMEMESSAGE pMsg, LPWABAL *ppWabal)
{
    ADDRESSLIST         addrList={0};
    HRESULT             hr = S_OK;
    LPWABAL             lpWabal = NULL;
    LONG                lRecipType;
    ULONG               i;
    LONG                lMapiType;
    LPADDRESSPROPS      pSender = NULL;
    LPADDRESSPROPS      pFrom = NULL;
    LPWSTR              pwszEmail = NULL;

    if (!pMsg || !ppWabal)
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr = HrCreateWabalObject(&lpWabal));

    lpWabal->SetAssociatedMessage(pMsg);

    IF_FAILEXIT(hr=pMsg->GetAddressTypes(IAT_KNOWN, IAP_FRIENDLYW | IAP_EMAIL | IAP_ADRTYPE, &addrList));

    for (i=0; i<addrList.cAdrs; i++)
    {
        // Raid 40730 - OE shows a message was sent by 2 people if the sender and from field do not match.
        lMapiType = MimeOleRecipToMapi(addrList.prgAdr[i].dwAdrType);
        
        // If Originator and IAT_FROM
        if (MAPI_ORIG == lMapiType)
        {
            // If IAT_SENDER, remember this item but don't add it yet
            if (ISFLAGSET(addrList.prgAdr[i].dwAdrType, IAT_SENDER))
                pSender = &addrList.prgAdr[i];
            
            // Have we seen the pFrom
            if (ISFLAGSET(addrList.prgAdr[i].dwAdrType, IAT_FROM))
                pFrom = &addrList.prgAdr[i];
        }
        
        // Don't add the IAT_SENDER
        if (!ISFLAGSET(addrList.prgAdr[i].dwAdrType, IAT_SENDER))
        {
            pwszEmail = PszToUnicode(CP_ACP, addrList.prgAdr[i].pszEmail);
            if (addrList.prgAdr[i].pszEmail && !pwszEmail)
                IF_FAILEXIT(hr = E_OUTOFMEMORY);

            // Add an Entry
            IF_FAILEXIT(hr = lpWabal->HrAddEntry(addrList.prgAdr[i].pszFriendlyW, pwszEmail, lMapiType));

            SafeMemFree(pwszEmail);
        }
    }

    // If no pFrom, and we have a pSender, at the entry
    if (NULL == pFrom && NULL != pSender)
    {
        pwszEmail = PszToUnicode(CP_ACP, addrList.prgAdr[i].pszEmail);
        if (addrList.prgAdr[i].pszEmail && !pwszEmail)
            IF_FAILEXIT(hr = E_OUTOFMEMORY);

        // Add an Entry
        IF_FAILEXIT(hr = lpWabal->HrAddEntry(pSender->pszFriendlyW, pwszEmail, MAPI_ORIG));
    }
    
    // success
    *ppWabal = lpWabal;
    lpWabal->AddRef();

exit:
    ReleaseObj(lpWabal);
    MemFree(pwszEmail);
    g_pMoleAlloc->FreeAddressList(&addrList);

    return hr;
}


HRESULT HrCheckDisplayNames(LPWABAL lpWabal, CODEPAGEID cpID)
{
    HRESULT             hr = S_OK;
    ADRINFO             wabInfo = {0};
    LPWABAL             lpWabalFlat = NULL;
    IMimeBody          *pBody = NULL;
    IImnAccount        *pAccount = NULL;
    
    
    if (!lpWabal)
        return E_INVALIDARG;
    
    // flatten the distribution lists in the wabal...
    IF_FAILEXIT(hr = HrCreateWabalObject(&lpWabalFlat));
    
    IF_FAILEXIT(hr = lpWabal->HrExpandTo(lpWabalFlat));
    
    // use the new flat-wabal
    lpWabal = lpWabalFlat;
  
    if (lpWabal->FGetFirst(&wabInfo))
    {
        do
        {
            IF_FAILEXIT((hr = HrSafeToEncodeToCP(wabInfo.lpwszDisplay, cpID)));
            if (MIME_S_CHARSET_CONFLICT == hr)
                goto exit;
        }
        while (lpWabal->FGetNext(&wabInfo));
    }
    
exit:
    ReleaseObj(lpWabalFlat);
    return hr;
}

HRESULT HrSetWabalOnMsg(LPMIMEMESSAGE pMsg, LPWABAL lpWabal)
{
    LPMIMEADDRESSTABLE  pAddrTable = NULL;
    LPMIMEADDRESSTABLEW pAddrTableW = NULL;
    ADRINFO             wabInfo = {0};
    LPWABAL             lpWabalFlat = NULL;
    HADDRESS            hAddress = NULL;
    HRESULT             hr = S_OK;
    ADDRESSPROPS        rAddress;
    const DWORD         dwSecurity = DwGetSecurityOfMessage(pMsg);
    const BOOL          fEncrypt = BOOL(MST_ENCRYPT_MASK & dwSecurity);
    const BOOL          fSigned = BOOL(MST_SIGN_MASK & dwSecurity);
    ULONG               cbSymCapsMe = 0;
    LPBYTE              pbSymCapsMe = NULL;
    BOOL                fFreeSymCapsMe = FALSE;
    LPVOID              pvSymCapsCookie = NULL;
    PROPVARIANT         var;
    IMimeBody          *pBody = NULL;
    IImnAccount        *pAccount = NULL;
    
    
    if (!pMsg || !lpWabal)
        return E_INVALIDARG;
    
    IF_FAILEXIT(hr = pMsg->GetAddressTable(&pAddrTable));
    IF_FAILEXIT(hr = pAddrTable->QueryInterface(IID_IMimeAddressTableW, (LPVOID*)&pAddrTableW));
    
    pAddrTableW->DeleteTypes(IAT_ALL);
    
    // flatten the distribution lists in the wabal...
    IF_FAILEXIT(hr = HrCreateWabalObject(&lpWabalFlat));
    
    lpWabal->SetAssociatedMessage(pMsg);
    
    IF_FAILEXIT(hr = lpWabal->HrExpandTo(lpWabalFlat));
    
    // use the new flat-wabal
    lpWabal = lpWabalFlat;
    
    
    if (fEncrypt || fSigned) 
    {
        //
        // Signed message gets OID_SECURITY_SYMCAPS
        //
        // Encrypted message uses SYMCAPS to prime the pump on the algorithm determination engine.
        //
        // Get the body object
        if (SUCCEEDED(hr = pMsg->BindToObject(HBODY_ROOT, IID_IMimeBody, (void **)&pBody))) 
        {
            // Get the default caps blob from the registry
            var.vt = VT_LPSTR;
            IF_FAILEXIT(hr = pMsg->GetProp(PIDTOSTR(PID_ATT_ACCOUNTID), NOFLAGS, &var));

            hr = g_pAcctMan->FindAccount(AP_ACCOUNT_ID, var.pszVal, &pAccount);
            SafeMemFree(var.pszVal);
            IF_FAILEXIT(hr);

            if(SUCCEEDED(hr = pAccount->GetProp(AP_SMTP_ENCRYPT_ALGTH, NULL, &cbSymCapsMe)))
            {
                if (! MemAlloc((LPVOID *)&pbSymCapsMe, cbSymCapsMe)) 
                {
                    cbSymCapsMe = 0;
                } 
                else 
                {
                    if(FAILED(hr = pAccount->GetProp(AP_SMTP_ENCRYPT_ALGTH, pbSymCapsMe, &cbSymCapsMe)))
                    {
                        Assert(FALSE);  // Huh, now it fails?
                        SafeMemFree(pbSymCapsMe);
                        cbSymCapsMe = 0;
                    } 
                    else 
                    {
                        fFreeSymCapsMe = TRUE;
                    }

                }

            }
            ReleaseObj(pAccount);
            if(FAILED(hr))
            {
                // No Symcap option set for ME.  Go get the default value.
                if (SUCCEEDED(HrGetHighestSymcaps(&pbSymCapsMe, &cbSymCapsMe))) 
                {
                    fFreeSymCapsMe = TRUE;
                }
            }
            
            // Set our SYMCAPS property on the message
            if (fSigned && cbSymCapsMe) 
            {
                var.vt = VT_BLOB;
                var.blob.cbSize = cbSymCapsMe;
                var.blob.pBlobData = pbSymCapsMe;
                pBody->SetOption(OID_SECURITY_SYMCAPS, &var);
            }
            
            if (fEncrypt) 
            {
                if (! cbSymCapsMe) 
                {
                    // Default value for algorithm determination
                    pbSymCapsMe = (LPBYTE)c_RC2_40_ALGORITHM_ID;
                    cbSymCapsMe = cbRC2_40_ALGORITHM_ID;
                }
                
                // Prime the pump for calculating encryption algorithm
                if (FAILED(hr = MimeOleSMimeCapInit(pbSymCapsMe, cbSymCapsMe, &pvSymCapsCookie))) 
                {
                    DOUTL(DOUTL_CRYPT, "MimeOleSMimeCapInit -> %x", hr);
                }
            }
            if (fFreeSymCapsMe) 
            {
                SafeMemFree(pbSymCapsMe);
            }
        }
    }
    
    
    if (lpWabal->FGetFirst(&wabInfo))
    {
        do
        {
            rAddress.dwProps = IAP_ENCRYPTION_PRINT;
            
            LONG    l;
            
            l = MapiRecipToMimeOle(wabInfo.lRecipType);

            IF_FAILEXIT(hr = pAddrTableW->AppendW(l, IET_DECODED, wabInfo.lpwszDisplay, wabInfo.lpwszAddress, &hAddress));

            if (fEncrypt)
            {
                // need to treat sender differently since there is
                // no cert in the wab for her
                // it gets taken care of in _HrPrepSecureMsgForSending in secutil
                if (MAPI_ORIG != wabInfo.lRecipType && MAPI_REPLYTO != wabInfo.lRecipType)
                {
                    BLOB blSymCaps;
                    FILETIME ftSigningTime;
                    
                    blSymCaps.cbSize = 0;
                    
                    // if these fail, big deal.  We just don't have a print then.
                    // we'll wait for the S/MIME engine to yell, since there may
                    // be other things wrong with other certs.
                    hr = HrGetThumbprint(lpWabal, &wabInfo, &(rAddress.tbEncryption), &blSymCaps, &ftSigningTime);
                    if (SUCCEEDED(hr) && rAddress.tbEncryption.pBlobData)
                    {
                        pAddrTableW->SetProps(hAddress, &rAddress);
                        SafeMemFree(rAddress.tbEncryption.pBlobData);
                        
                        if (pvSymCapsCookie) 
                        {
                            if (blSymCaps.cbSize && blSymCaps.pBlobData) 
                            {
                                // Pass the recipient's SYMCAPS to the algorithm selection engine
                                hr = MimeOleSMimeCapAddSMimeCap(
                                    blSymCaps.pBlobData,
                                    blSymCaps.cbSize,
                                    pvSymCapsCookie);
                                MemFree(blSymCaps.pBlobData);
                            } 
                            else 
                            {
                                LPBYTE pbCert = NULL;
                                ULONG cbCert = 0;
                                
                                // Need to get the cert context for this cert
                                // BUGBUG: MimeOleSMimeCapAddCert currently doesn't even look
                                // at the cert.  Why should we bother getting it from the thumbprint?
                                // It only looks at fParanoid
                                
                                hr = MimeOleSMimeCapAddCert(pbCert,
                                    cbCert,
                                    FALSE,      // fParanoid,
                                    pvSymCapsCookie);
                            }
                        }
                    }
                }
            }
        }
        while (lpWabal->FGetNext(&wabInfo));
    }
    
    if (fEncrypt) 
    {
        LPBYTE pbEncode = NULL;
        ULONG cbEncode = 0;
        BOOL fFreeEncode = FALSE;
        DWORD dwBits = 0;
        
        if (pvSymCapsCookie) 
        {
            // Finish up with SymCaps and save the ALG_BULK
            MimeOleSMimeCapGetEncAlg(pvSymCapsCookie,
                pbEncode,
                &cbEncode,
                &dwBits);
            
            if (cbEncode) 
            {
                if (! MemAlloc((LPVOID *)&pbEncode, cbEncode)) 
                {
                    cbEncode = 0;
                } 
                else 
                {
                    fFreeEncode = TRUE;
                    if (SUCCEEDED(hr = MimeOleSMimeCapGetEncAlg(
                        pvSymCapsCookie,
                        pbEncode,
                        &cbEncode,
                        &dwBits))) 
                    {
                    }
                }
            } 
            else 
            {
                // Hey, there should ALWAYS be at least RC2 (40 bit).  What happened?
                AssertSz(cbEncode, "MimeOleSMimeCapGetEncAlg gave us no encoding algorithm");
            }
        }
        if (! pbEncode) 
        {
            // Stick in the RC2 value as a default
            pbEncode = (LPBYTE)c_RC2_40_ALGORITHM_ID;
            cbEncode = cbRC2_40_ALGORITHM_ID;
        }
        
        // Ah, finally, we have calculated the algorithm.
        // Set it on the message body
        var.vt = VT_BLOB;
        var.blob.cbSize = cbEncode;
        var.blob.pBlobData = pbEncode;
        hr = pBody->SetOption(OID_SECURITY_ALG_BULK, &var);
        
        if (fFreeEncode) 
        {
            SafeMemFree(pbEncode);
        }
    }
    
    // No more commits needed in the address table hr=pAddrTableW->Commit();
    
exit:
    MemFree(pvSymCapsCookie);
    ReleaseObj(pBody);
    ReleaseObj(pAddrTable);
    ReleaseObj(pAddrTableW);
    ReleaseObj(lpWabalFlat);

    return hr;
}

#if 0
HRESULT HrSetReplyTo(LPMIMEMESSAGE pMsg, LPSTR lpszEmail)
{
    LPMIMEADDRESSTABLE  pAddrTable=0;
    HRESULT             hr;

    if (!pMsg)
        return E_INVALIDARG;

    hr=pMsg->GetAddressTable(&pAddrTable);
    if (FAILED(hr))
        goto error;

    hr=pAddrTable->Append(IAT_REPLYTO, IET_DECODED, NULL, lpszEmail, NULL);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pAddrTable);
    return hr;
}
#endif

LONG MimeOleRecipToMapi(IADDRESSTYPE addrtype)
{
    LONG    lRecipType = MAPI_ORIG;

    AssertSz(addrtype & IAT_KNOWN, "Must be a known type for this to work!!");

    switch (addrtype)
        {
        case IAT_FROM:
        case IAT_SENDER:
            lRecipType=MAPI_ORIG;
            break;
        case IAT_TO:
            lRecipType=MAPI_TO;
            break;
        case IAT_CC:
            lRecipType=MAPI_CC;
            break;
        case IAT_BCC:
            lRecipType=MAPI_BCC;
            break;
        case IAT_REPLYTO:
            lRecipType=MAPI_REPLYTO;
            break;
        default:
            Assert(FALSE);
        }
    return lRecipType;
}


IADDRESSTYPE MapiRecipToMimeOle(LONG lRecip)
{
    IADDRESSTYPE addrtype = IAT_UNKNOWN;

    switch (lRecip)
        {
        case MAPI_ORIG:
            addrtype=IAT_FROM;
            break;
        case MAPI_TO:
            addrtype=IAT_TO;
            break;
        case MAPI_CC:
            addrtype=IAT_CC;
            break;
        case MAPI_BCC:
            addrtype=IAT_BCC;
            break;
        case MAPI_REPLYTO:
            addrtype=IAT_REPLYTO;
            break;
        default:
            Assert(FALSE);
        }
    return addrtype;
}


// CANDIDATES.
// This function is never called to dup a message that has all the security
// fully encoded into the message. Because of that, we always need to clear
// the security flags and then reset them into the 
HRESULT HrDupeMsg(LPMIMEMESSAGE pMsg, LPMIMEMESSAGE *ppMsg)
{
    LPMIMEMESSAGE       pMsgDupe=0;
    IMimePropertySet    *pPropsSrc,
                        *pPropsDest;
    LPSTREAM            pstm=0;
    HRESULT             hr;
    HCHARSET            hCharset ;
    DWORD               dwSecFlags = MST_NONE;
    SECSTATE            secState = {0};
    LPCSTR              rgszHdrCopy[] = {
                                PIDTOSTR(PID_ATT_ACCOUNTID),
                                STR_ATT_ACCOUNTNAME,
                                PIDTOSTR(PID_ATT_STOREMSGID),
                                PIDTOSTR(PID_ATT_STOREFOLDERID) };


    if (!ppMsg || !pMsg)
        return E_INVALIDARG;

    *ppMsg=0;

    hr=HrCreateMessage(&pMsgDupe);
    if (FAILED(hr))
        goto error;

    HrGetSecurityState(pMsg, &secState, NULL);
    if (IsSecure(secState.type))
    {
        dwSecFlags = MST_CLASS_SMIME_V1;
        if (IsSigned(secState.type))
            dwSecFlags |= ((DwGetOption(OPT_OPAQUE_SIGN)) ? MST_THIS_BLOBSIGN : MST_THIS_SIGN);

        if (IsEncrypted(secState.type))
            dwSecFlags |= MST_THIS_ENCRYPT;

        hr = HrInitSecurityOptions(pMsg, 0);
        if (FAILED(hr))
            goto error;
    }
        
    hr = pMsg->GetMessageSource(&pstm, 0);
    if (FAILED(hr))
        goto error;

    pMsg->GetCharset(&hCharset);

    hr= pMsgDupe->Load(pstm);
    if (FAILED(hr))
        goto error;

    if (hCharset)   // for uuencode msg, we need to do this to carry over the charset
        pMsgDupe->SetCharset(hCharset, CSET_APPLY_ALL);

    if (pMsgDupe->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropsDest)==S_OK)
        {
        if (pMsg->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pPropsSrc)==S_OK)
            {
            pPropsSrc->CopyProps(ARRAYSIZE(rgszHdrCopy), rgszHdrCopy, pPropsDest);
            pPropsSrc->Release();
            }
        pPropsDest->Release();
        }

    if (MST_NONE != dwSecFlags)
    {
        hr = HrInitSecurityOptions(pMsg, dwSecFlags);
        if (FAILED(hr))
            goto error;

        hr = HrInitSecurityOptions(pMsgDupe, dwSecFlags);
        if (FAILED(hr))
            goto error;
    }
    *ppMsg = pMsgDupe;
    pMsgDupe->AddRef();

error:
    ReleaseObj(pMsgDupe);
    CleanupSECSTATE(&secState);
    ReleaseObj(pstm);
    return hr;
}



HRESULT HrRemoveAttachments(LPMIMEMESSAGE pMsg, BOOL fKeepRelatedSection)
{
    HRESULT     hr;
    ULONG       cAttach,
                uAttach;
    LPHBODY     rghAttach=0;
    HBODY       hBody;

    if(!pMsg)
        return E_INVALIDARG;

    hr = pMsg->GetAttachments(&cAttach, &rghAttach);
    if (FAILED(hr))
        goto error;

    for(uAttach=0; uAttach<cAttach; uAttach++)
        {
        if (fKeepRelatedSection &&
            HrIsInRelatedSection(pMsg, rghAttach[uAttach])==S_OK)
            continue;                // skip related content

        hr = pMsg->DeleteBody(rghAttach[uAttach], 0);
        if (FAILED(hr))
            goto error;
        }

    //N BUGBUG
    /*this is to keep the tree (which may now be a
    multipart with single child) in sync.  We should
    look at DeleteBody performing this.  Additionally,
    we could have the children whose parents are deleted
    inherit their parents' inheritable properties*/
    pMsg->Commit(0);

error:
    SafeMimeOleFree(rghAttach);
    return hr;
}


HRESULT HrCreateMessage(IMimeMessage **ppMsg)
{
    return MimeOleCreateMessage(NULL, ppMsg);
}



HRESULT GetAttachmentCount(LPMIMEMESSAGE pMsg, ULONG *pcCount)
{
    HRESULT hr = E_INVALIDARG;
    ULONG   cCount = 0;

    if (pMsg && pcCount)
        {
        HBODY   hRootBody;

        // WHY? because GetAttachments calculated from renderred body parts. If we call
        // on a fresh stream it returns 2 - for the multi/alternate plain/html section
        // GetTextBody will mark these body parts as inlinable and they won't show as
        // 'attachments'
        pMsg->GetTextBody(TXT_HTML, IET_UNICODE, NULL, &hRootBody);
        pMsg->GetTextBody(TXT_PLAIN, IET_UNICODE, NULL, &hRootBody);

        hr = pMsg->GetBody(IBL_ROOT, NULL, &hRootBody);
        if (!FAILED(hr))
            {
            if(S_OK != pMsg->IsContentType(hRootBody, STR_CNT_MULTIPART, STR_SUB_RELATED))
                hr = GetSubTreeAttachCount(pMsg, hRootBody, &cCount);
            }
        }

    *pcCount = cCount;
    return hr;
}


HRESULT GetSubTreeAttachCount(LPMIMEMESSAGE pMsg, HBODY hFirst, ULONG *pcCount)
{
    HRESULT hr = S_OK;
    HBODY hIter = hFirst;
    ULONG cCount = 0;

    do
        {
        // Is multipart?
        if(S_OK == pMsg->IsContentType(hIter, STR_CNT_MULTIPART, NULL))
            {
            // Only count the sub tree if is not multipart/related,
            if (S_OK != pMsg->IsContentType(hIter, NULL, STR_SUB_RELATED))
                {
                ULONG cLocalCount;
                HBODY hMultiPart;
                hr = pMsg->GetBody(IBL_FIRST, hIter, &hMultiPart);

                // If GetBody fails, just ignore this sub tree
                if (!FAILED(hr))
                    {
                    hr = GetSubTreeAttachCount(pMsg, hMultiPart, &cLocalCount);
                    if (FAILED(hr))
                        goto Error;
                    cCount += cLocalCount;
                    }
                }
            }
        else
            {
            PROPVARIANT rVariant;

            rVariant.vt = VT_I4;

            // See RAID-56665:  Should ignore this type
            if (S_OK != pMsg->IsContentType(hIter, STR_CNT_APPLICATION, STR_SUB_MSTNEF))
                {
                if (FAILED(pMsg->GetBodyProp(hIter, PIDTOSTR(PID_ATT_RENDERED), NOFLAGS, &rVariant)) || rVariant.ulVal==FALSE)
                    cCount++;
                }
            }
        } while (S_OK == pMsg->GetBody(IBL_NEXT, hIter, &hIter));

Error:
    *pcCount = cCount;
    return hr;
}


HRESULT HrSaveMsgToFile(LPMIMEMESSAGE pMsg, LPSTR lpszFile)
{
    return HrIPersistFileSave((LPUNKNOWN)pMsg, lpszFile);
}


HRESULT HrSetServer(LPMIMEMESSAGE pMsg, LPSTR lpszServer)
{
    PROPVARIANT rUserData;

    if (!lpszServer)
        return S_OK;

    rUserData.vt = VT_LPSTR;
    rUserData.pszVal = lpszServer;
    return pMsg->SetProp(PIDTOSTR(PID_ATT_SERVER), 0, &rUserData);
}

HRESULT HrSetAccount(LPMIMEMESSAGE pMsg, LPSTR pszAcctName)
{
    IImnAccount *pAccount;
    PROPVARIANT rUserData;

    if (!pszAcctName)
        return S_OK;

    if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, pszAcctName, &pAccount)))
    {
        CHAR szId[CCHMAX_ACCOUNT_NAME];

        rUserData.vt = VT_LPSTR;
        rUserData.pszVal = (LPSTR)pszAcctName;
        pMsg->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);

        if (SUCCEEDED(pAccount->GetPropSz(AP_ACCOUNT_ID, szId, sizeof(szId))))
        {
            rUserData.pszVal = szId;
            pMsg->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);
        }

        pAccount->Release();
    }
    else
        return(E_FAIL);

    return(S_OK);
}


HRESULT HrSetAccountByAccount(LPMIMEMESSAGE pMsg, IImnAccount *pAcct)
{
    TCHAR       szAccount[CCHMAX_ACCOUNT_NAME];
    TCHAR       szId[CCHMAX_ACCOUNT_NAME];
    PROPVARIANT rUserData;

    if (!pAcct)
        return S_OK;

    rUserData.vt = VT_LPSTR;

    // Having the name in the msg is good, but not necessary
    if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_NAME, szAccount, sizeof(szAccount))))
    {
        rUserData.pszVal = (LPSTR)szAccount;
        pMsg->SetProp(STR_ATT_ACCOUNTNAME, 0, &rUserData);
    }

    // Must have the account ID in the msg
    if (SUCCEEDED(pAcct->GetPropSz(AP_ACCOUNT_ID, szId, sizeof(szId))))
    {
        rUserData.pszVal = szId;
        pMsg->SetProp(PIDTOSTR(PID_ATT_ACCOUNTID), 0, &rUserData);
    }
    else
        return(E_FAIL);

    return(S_OK);
}


HRESULT HrLoadMsgFromFile(LPMIMEMESSAGE pMsg, LPSTR lpszFile)
{
    return HrIPersistFileLoad((LPUNKNOWN)pMsg, lpszFile);
}

HRESULT HrLoadMsgFromFileW(LPMIMEMESSAGE pMsg, LPWSTR lpwszFile)
{
    return HrIPersistFileLoadW((LPUNKNOWN)pMsg, lpwszFile);
}


#define CCH_COUNTBUFFER 4096
HRESULT HrComputeLineCount(LPMIMEMESSAGE pMsg, LPDWORD pdw)
{
    HRESULT     hr;
    BODYOFFSETS rOffset;
    LPSTREAM    pstm=0;
    TCHAR       rgch[CCH_COUNTBUFFER+1];
    ULONG       cb,
                i,
                cLines=0;

    if (!pdw)
        return E_INVALIDARG;

    *pdw=0;

    hr = pMsg->GetMessageSource(&pstm, COMMIT_ONLYIFDIRTY);
    if (FAILED(hr))
        goto error;

    hr=pMsg->GetBodyOffsets(HBODY_ROOT, &rOffset);
    if (FAILED(hr))
        goto error;

    hr=HrStreamSeekSet(pstm, rOffset.cbBodyStart);
    if (FAILED(hr))
        goto error;

    while (pstm->Read(rgch, CCH_COUNTBUFFER, &cb)==S_OK && cb)
        {
        if (cLines==0)  // if there's text, then there's atleast one line.
            cLines++;

        for (i=0; i<cb; i++)
            {
            if (rgch[i]=='\n')
                cLines++;
            }
        }

error:
    ReleaseObj(pstm);
    *pdw=cLines;
    return hr;
}

#if 0
// =====================================================================================
// HrEscapeQuotedString - quotes '"' and '\'
// =====================================================================================
HRESULT HrEscapeQuotedString (LPTSTR pszIn, LPTSTR *ppszOut)
{
    LPTSTR pszOut;
    TCHAR  ch;

    // worst case - escape every character, so use double original strlen
    if (!MemAlloc((LPVOID*)ppszOut, (2 * lstrlen(pszIn) + 1) * sizeof(TCHAR)))
        return E_OUTOFMEMORY;
    pszOut = *ppszOut;

    while (ch = *pszIn++)
        {
        if (ch == _T('"') || ch == _T('\\'))
            *pszOut++ = _T('\\');
        *pszOut++ = ch;
        }
    *pszOut = _T('\0');
    return NOERROR;
}
#endif


HRESULT HrHasBodyParts(LPMIMEMESSAGE pMsg)
{
    DWORD   dwFlags=0;

    if (pMsg)
        pMsg->GetFlags(&dwFlags);

    return (dwFlags&IMF_HTML || dwFlags & IMF_PLAIN)? S_OK : S_FALSE;
}

HRESULT HrHasEncodedBodyParts(LPMIMEMESSAGE pMsg, ULONG cBody, LPHBODY rghBody)
{
    ULONG   uBody;

    if (cBody==0 || rghBody==NULL)
        return S_FALSE;

    for (uBody=0; uBody<cBody; uBody++)
        {
        if (HrIsBodyEncoded(pMsg, rghBody[uBody])==S_OK)
            return S_OK;
        }

    return S_FALSE;
}


/*
 * looks for non-7bit or non-8bit encoding
 */
HRESULT HrIsBodyEncoded(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    LPSTR   lpsz;
    HRESULT hr=S_FALSE;

    if (!FAILED(MimeOleGetBodyPropA(pMsg, hBody, PIDTOSTR(PID_HDR_CNTXFER), NOFLAGS, &lpsz)))
        {
        if (lstrcmpi(lpsz, STR_ENC_7BIT)!=0 && lstrcmpi(lpsz, STR_ENC_8BIT)!=0)
            hr=S_OK;

        SafeMimeOleFree(lpsz);
        }
    return hr;
}

// sizeof(lspzBuffer) needs to be == or > CCHMAX_CSET_NAME
HRESULT HrGetMetaTagName(HCHARSET hCharset, LPSTR lpszBuffer)
{
    INETCSETINFO    rCsetInfo;
    CODEPAGEINFO    rCodePage;
    HRESULT         hr;
    LPSTR           psz;

    if (hCharset == NULL)
        return E_INVALIDARG;

    hr = MimeOleGetCharsetInfo(hCharset, &rCsetInfo);
    if (FAILED(hr))
        goto error;

    hr = MimeOleGetCodePageInfo(rCsetInfo.cpiInternet, &rCodePage);
    if (FAILED(hr))
        goto error;

    psz = rCodePage.szWebCset;

    if (FIsEmpty(psz))      // if no webset, try the body cset
        psz = rCodePage.szBodyCset;

    if (FIsEmpty(psz))
        {
        hr = E_FAIL;
        goto error;
        }

    lstrcpy(lpszBuffer, psz);

error:
    return hr;
}

// --------------------------------------------------------------------------------
// SetDefaultCharset
// --------------------------------------------------------------------------------
void SetDefaultCharset(HCHARSET hCharset)
{
    g_hDefaultCharset = hCharset;
}

// --------------------------------------------------------------------------------
// HGetCharsetFromCodepage
// --------------------------------------------------------------------------------
HRESULT HGetCharsetFromCodepage(CODEPAGEID cp, HCHARSET *phCharset)
{
    CODEPAGEINFO    rCodePage;
    HRESULT         hr = S_OK;

    if(!phCharset)
        return E_INVALIDARG;

    // Ask MimeOle for the CodePage Information
    IF_FAILEXIT(hr = MimeOleGetCodePageInfo(cp, &rCodePage));

    // Better Have a WebCharset
    if (!(ILM_WEBCSET & rCodePage.dwMask))
    {
        hr = E_FAIL;
        goto exit;
    }

    // Find the body charset
    hr = MimeOleFindCharset(rCodePage.szWebCset, phCharset);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// HGetDefaultCharset
// --------------------------------------------------------------------------------
HRESULT HGetDefaultCharset(HCHARSET *phCharset)
{
    DWORD           cb;
    CODEPAGEID      cpiWindows,
                    cpiInternet;
    CHAR            szCodePage[MAX_PATH];    
    HCHARSET        hDefaultCharset = NULL; // default charset for reading
    HRESULT         hr = E_FAIL;

    // No Null...
    if (g_hDefaultCharset)
    {
        if(phCharset)
            *phCharset = g_hDefaultCharset;
        return S_OK;
    }

    // Open Trident\International
    cb = sizeof(cpiWindows);
    if (ERROR_SUCCESS != SHGetValue(MU_GetCurrentUserHKey(), c_szRegInternational, c_szDefaultCodePage, NULL, (LPBYTE)&cpiWindows, &cb))
        cpiWindows = GetACP();

    // Open the CodePage Key
    wsprintf(szCodePage, "%s\\%d", c_szRegInternational, cpiWindows);
    cb = sizeof(cpiInternet);
    if (ERROR_SUCCESS != SHGetValue(MU_GetCurrentUserHKey(), szCodePage, c_szDefaultEncoding, NULL, (LPBYTE)&cpiInternet, &cb))
        cpiInternet = GetICP(cpiWindows);

    // If you can't get the charset, this could be because of user
    // roaming or cset uninstall, retry with the default codepage
    if(FAILED(HGetCharsetFromCodepage(cpiInternet, &hDefaultCharset)) && (cpiInternet != GetACP()))
    {
        cpiInternet = GetACP();
        IF_FAILEXIT(hr = HGetCharsetFromCodepage(cpiInternet, &hDefaultCharset));
    }

    // for JP codepage 50221 and 50222, we have to check whether it is
    // consistent with registry. If not, we need to override it.
    // 50221 and 50222 both have same user friendly name "JIS-allow 1 byte Kana".
    // but in registry, it defines which one should be used.
    if (cpiInternet == 50222 || cpiInternet == 50221 )
        hDefaultCharset = GetJP_ISOControlCharset();

    // Set the default charset
    g_hDefaultCharset = hDefaultCharset;

    // Tell MimeOle About the New Default Charset...
    IF_FAILEXIT(hr = MimeOleSetDefaultCharset(hDefaultCharset));

    if(phCharset)
        *phCharset = hDefaultCharset;

exit:    
    return hr;
}


HRESULT HrIsInRelatedSection(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HBODY   hBodyParent;

    if (!FAILED(pMsg->GetBody(IBL_PARENT, hBody, &hBodyParent)) &&
            (pMsg->IsContentType(hBodyParent, STR_CNT_MULTIPART, STR_SUB_RELATED)==S_OK))
        return S_OK;
    else
        return S_FALSE;
}


#if 0
HRESULT HrMarkGhosted(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT pv;

    Assert (pMsg && hBody);

    pv.vt = VT_I4;
    pv.lVal = TRUE;
    return pMsg->SetBodyProp(hBody, PIDTOSTR(PID_ATT_GHOSTED), NOFLAGS, &pv);
}


HRESULT HrIsReferencedUrl(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT rVariant;

    rVariant.vt = VT_I4;

    if (!FAILED(pMsg->GetBodyProp(hBody, PIDTOSTR(PID_ATT_RENDERED), NOFLAGS, &rVariant)) && rVariant.ulVal)
        return S_OK;

    return S_FALSE;
}


HRESULT HrIsGhosted(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT pv;

    pv.vt = VT_I4;



    if (pMsg->GetBodyProp(hBody, PIDTOSTR(PID_ATT_GHOSTED), NOFLAGS, &pv)==S_OK &&
        pv.vt == VT_I4 && pv.lVal == TRUE)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT HrGhostKids(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HRESULT hr=S_OK;

    if (pMsg && hBody)
        {
        if (!FAILED(pMsg->GetBody(IBL_FIRST, hBody, &hBody)))
            {
            do
                {
                if (HrIsReferencedUrl(pMsg, hBody)==S_OK)
                    {
                    hr = HrMarkGhosted(pMsg, hBody);
                    if (FAILED(hr))
                        goto error;
                    }
                }
            while (!FAILED(pMsg->GetBody(IBL_NEXT, hBody, &hBody)));
            }
        }
error:
    return hr;
}


HRESULT HrDeleteGhostedKids(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HRESULT     hr=S_OK;
    ULONG       cKids=0,
                uKid;
    LPHBODY     rghKids=0;

    pMsg->CountBodies(hBody, FALSE, &cKids);
    if (cKids)
        {
        if (!MemAlloc((LPVOID *)&rghKids, sizeof(HBODY) * cKids))
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }

        cKids = 0;

        if (!FAILED(pMsg->GetBody(IBL_FIRST, hBody, &hBody)))
            {
            do
                {
                if (HrIsGhosted(pMsg, hBody)==S_OK)
                    {
                    rghKids[cKids++] = hBody;
                    }
                }
            while (!FAILED(pMsg->GetBody(IBL_NEXT, hBody, &hBody)));
            }

        for (uKid = 0; uKid < cKids; uKid++)
            {
            hr=pMsg->DeleteBody(rghKids[uKid], 0);
            if (FAILED(hr))
                goto error;
            }

        }

error:
    SafeMemFree(rghKids);
    return hr;
}
#endif

// --------------------------------------------------------------------------------
// HrSetSentTimeProp
// --------------------------------------------------------------------------------
HRESULT HrSetSentTimeProp(IMimeMessage *pMessage, LPSYSTEMTIME pst)
{
    // Locals
    PROPVARIANT rVariant;
    SYSTEMTIME  st;

    // No time was passed in
    if (NULL == pst)
    {
        GetSystemTime(&st);
        pst = &st;
    }

    // Setup the Variant
    rVariant.vt = VT_FILETIME;
    SystemTimeToFileTime(&st, &rVariant.filetime);

    // Set the property and return
    return TrapError(pMessage->SetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &rVariant));
}

// --------------------------------------------------------------------------------
// HrSetMailOptionsOnMessage
// --------------------------------------------------------------------------------
HRESULT HrSetMailOptionsOnMessage(IMimeMessage *pMessage, HTMLOPT *pHtmlOpt, PLAINOPT *pPlainOpt,
    HCHARSET hCharset, BOOL fHTML)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rVariant;
    ENCODINGTYPE    ietEncoding;
    ULONG           uSaveFmt,
                    uWrap;
    BOOL            f8Bit,
                    fWrap=FALSE;

    // Invalid Arg
    Assert(pMessage && pHtmlOpt && pPlainOpt);

    // Html Mail
    if (fHTML)
    {
        uSaveFmt = (ULONG)SAVE_RFC1521;             // always MIME
        ietEncoding = (IsSecure(pMessage) ? IET_QP : pHtmlOpt->ietEncoding);
        // ietEncoding = pHtmlOpt->ietEncoding;
        f8Bit = pHtmlOpt->f8Bit;
        uWrap = pHtmlOpt->uWrap;
        fWrap = (IET_7BIT == pHtmlOpt->ietEncoding && uWrap > 0) ? TRUE : FALSE;
    }
    else
    {
        // Bug 44270: UUEncode on secure message doesn't make sense.  If they asked for secure, they get Mime.
        uSaveFmt = (ULONG)((pPlainOpt->fMime || IsSecure(pMessage)) ? SAVE_RFC1521 : SAVE_RFC822);
        ietEncoding = pPlainOpt->ietEncoding;
        f8Bit = pPlainOpt->f8Bit;
        uWrap = pPlainOpt->uWrap;
        fWrap = (IET_7BIT == pPlainOpt->ietEncoding && uWrap > 0) ? TRUE : FALSE;
    }

    // Save Format
    rVariant.vt = VT_UI4;
    rVariant.ulVal = uSaveFmt;
    CHECKHR(hr = pMessage->SetOption(OID_SAVE_FORMAT, &rVariant));

    // Text body encoding
    rVariant.ulVal = (ULONG)ietEncoding;
    CHECKHR(hr = pMessage->SetOption(OID_TRANSMIT_TEXT_ENCODING, &rVariant));

    // Plain Text body encoding
    rVariant.ulVal = (ULONG)ietEncoding;
    CHECKHR(hr = pMessage->SetOption(OID_XMIT_PLAIN_TEXT_ENCODING, &rVariant));

    // HTML Text body encoding
    rVariant.ulVal = (ULONG)((IET_7BIT == ietEncoding) ? IET_QP : ietEncoding);
    CHECKHR(hr = pMessage->SetOption(OID_XMIT_HTML_TEXT_ENCODING, &rVariant));

    // Wrapping Length
    if (uWrap)
    {
        rVariant.ulVal = (ULONG)uWrap;
        CHECKHR(hr = pMessage->SetOption(OID_CBMAX_BODY_LINE, &rVariant));
    }

    // Allow 8bit Header
    rVariant.vt = VT_BOOL;
    rVariant.boolVal = (VARIANT_BOOL)!!f8Bit;
    CHECKHR(hr = pMessage->SetOption(OID_ALLOW_8BIT_HEADER, &rVariant));

    // Wrapping
    rVariant.boolVal = (VARIANT_BOOL)!!fWrap;
    CHECKHR(hr = pMessage->SetOption(OID_WRAP_BODY_TEXT, &rVariant));

    // set the character set also based on what's set in the fontUI.
    if (hCharset)
        CHECKHR(hr = pMessage->SetCharset(hCharset, CSET_APPLY_ALL));

exit:
    // Done
    return hr;
}


HRESULT HrSetMsgCodePage(LPMIMEMESSAGE pMsg, UINT uCodePage)
{
    HRESULT     hr=E_FAIL;
    HCHARSET    hCharset;

    if (pMsg == NULL || uCodePage == 0)
        return E_INVALIDARG;

    // use the WEB charset then the BODY charset, then default charset.
    // EXCEPT for codepage 932 (shift-jis) where bug #61416 requires we ignore the webcarset

    if (uCodePage != 932)
        hr = MimeOleGetCodePageCharset(uCodePage, CHARSET_WEB, &hCharset);

    if (FAILED(hr))
        hr = MimeOleGetCodePageCharset(uCodePage, CHARSET_BODY, &hCharset);

    if (!FAILED(hr))
        hr = pMsg->SetCharset(hCharset, CSET_APPLY_ALL);

    return hr;
}


UINT uCodePageFromCharset(HCHARSET hCharset)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = GetACP();

    if (hCharset &&
        (MimeOleGetCharsetInfo(hCharset, &CsetInfo)==S_OK))
        uiCodePage = CsetInfo.cpiInternet ;

    return uiCodePage;
}

UINT uCodePageFromMsg(LPMIMEMESSAGE pMsg)
{
    HCHARSET hCharset=0;

    if (pMsg)
        pMsg->GetCharset(&hCharset);
    return uCodePageFromCharset(hCharset);
}

HRESULT HrSafeToEncodeToCP(LPWSTR pwsz, CODEPAGEID cpID)
{
    HRESULT hr = S_OK;
    INT     cbIn = (lstrlenW(pwsz)+1)*sizeof(WCHAR);
    DWORD   dwTemp = 0;

    IF_FAILEXIT(hr = ConvertINetString(&dwTemp, CP_UNICODE, cpID, (LPCSTR)pwsz, &cbIn, NULL, NULL));
    if (S_FALSE == hr)
        hr = MIME_S_CHARSET_CONFLICT;

exit:
    return hr;
}

HRESULT HrSafeToEncodeToCPA(LPCSTR psz, CODEPAGEID cpSrc, CODEPAGEID cpDest)
{
    HRESULT hr = S_OK;
    LPWSTR  pwsz = NULL;
    
    Assert(psz);

    IF_NULLEXIT(pwsz = PszToUnicode(cpSrc, psz));
    IF_FAILEXIT(hr = HrSafeToEncodeToCP(pwsz, cpDest));

exit:
    MemFree(pwsz);
    return hr;
}


#if 0
HRESULT HrIStreamWToInetCset(LPSTREAM pstmW, HCHARSET hCharset, LPSTREAM *ppstmOut)
{
    IMimeBody   *pBody;
    HRESULT     hr;

    hr = MimeOleCreateBody(&pBody);
    if (!FAILED(hr))
        {
        hr = pBody->InitNew();
        if (!FAILED(hr))
            {
            hr = pBody->SetData(IET_UNICODE, STR_CNT_TEXT, STR_SUB_HTML, IID_IStream, pstmW);
            if (!FAILED(hr))
                {
                hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
                if (!FAILED(hr))
                    hr =  pBody->GetData(IET_INETCSET, ppstmOut);
                }
            }
        pBody->Release();
        }
    return hr;
}
#endif

#if 0
HRESULT HrCopyHeader(LPMIMEMESSAGE pMsg, HBODY hBodyDest, HBODY hBodySrc, LPCSTR pszName)
{
    LPSTR   lpszProp;
    HRESULT hr;

    hr = MimeOleGetBodyPropA(pMsg, hBodySrc, pszName, NOFLAGS, &lpszProp);
    if (!FAILED(hr))
        {
        hr = MimeOleSetBodyPropA(pMsg, hBodyDest, pszName, NOFLAGS, lpszProp);
        SafeMimeOleFree(lpszProp);
        }
    return hr;
}
#endif



#if 0
HRESULT HrFindUrlInMsg(LPMIMEMESSAGE pMsg, LPSTR lpszUrl, LPSTREAM *ppstm)
{
    HBODY   hBody;
    HRESULT hr = E_FAIL;

    if (MimeOleGetRelatedSection(pMsg, FALSE, &hBody, NULL)==S_OK && hBody)
        {
        if (!FAILED(hr = pMsg->ResolveURL(hBody, NULL, lpszUrl, 0, &hBody)))
            hr = pMsg->BindToObject(hBody, IID_IStream, (LPVOID *)ppstm);
        }
    return hr;
}


HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt)
{
    BYTE    pb[4096];
    LPWSTR  lpszW;
    TCHAR   rgch[MAX_PATH];

    if (!FAILED(pstm->Read(&pb, 4096, NULL)))
        {
        if (!FAILED(FindMimeFromData(NULL, NULL, pb, 4096, NULL, NULL, &lpszW, 0)))
            {
            WideCharToMultiByte(CP_ACP, 0, lpszW, -1, rgch, MAX_PATH, NULL, NULL);
            return MimeOleGetContentTypeExt(rgch, lplpszExt);
            }
        }
    return S_FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\mru.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     find.cpp
//
//  PURPOSE:    
//

#include "pch.hxx"
#include "mru.h"


#define NTHSTRING(p, n)         (*((LPTSTR FAR *)((LPBYTE)p) + n))
#define NTHDATA(p, n)           (*((LPBYTE FAR *)((LPBYTE)p) + n))
#define NUM_OVERHEAD            3
#define MAX_MRU_INDEXSTR        15

// For Binary data, we stick the size of the data at the beginning and store
// the whole thing in one go.

// Use this macro to get the original size of the data
#define DATASIZE(p)    (*((LPDWORD) p))

// Use this macro to get a pointer to the original data
#define DATAPDATA(p)   (p + sizeof(DWORD))
#define DATAPDATAEX(p) ((LPDWORD)(((DWORD_PTR) p) + sizeof(DWORD)))


#define MAX_CHAR    126
#define BASE_CHAR   TEXT('a')


CMRUList::CMRUList()
{
    m_uMax = 0;
    m_fFlags = 0;
    m_pszSubKey = 0;
    m_hKey = 0;
    m_rgpszMRU = NULL;
    m_pszOrder = NULL;
}

CMRUList::~CMRUList()
{
    SafeMemFree(m_pszSubKey);
    SafeMemFree(m_pszOrder);
    if (m_hKey)
        RegCloseKey(m_hKey);
    FreeList();    
}

const TCHAR c_szRegMRU[] = _T("MRU List");

//
//  FUNCTION:   CMRUList::CreateList()
//
//  PURPOSE:    Creates and initializes the MRUL list
//
//  PARAMETERS: 
//      UINT uMaxEntries
//      UINT fFlags
//      LPCSTR pszSubKey
//
//  RETURN VALUE:
//      BOOL 
//
BOOL CMRUList::CreateList(UINT uMaxEntries, UINT fFlags, LPCSTR pszSubKey)
{
    TraceCall("CMRUList::CreateList");
    return (CreateListLazy(uMaxEntries, fFlags, pszSubKey, NULL, 0, NULL));
}


//
//  FUNCTION:   CreateListLazy()
//
//  PURPOSE:    Initializes the MRU list by telling the class how many entries
//              to store, where they are stored, and some flags.
//
//  PARAMETERS: 
//      [in] uMaxEntries
//      [in] fFlags
//      [in] pszSubKey
//
//  RETURN VALUE:
//      BOOL 
//
BOOL CMRUList::CreateListLazy(UINT uMaxEntries, UINT fFlags, LPCSTR pszSubKey, 
                              const void *pData, UINT cbData, LPINT piSlot)
{
    TCHAR      szOrder[126];
    DWORD      dwType;
    DWORD      cb;
    LPTSTR     pszNewOrder;
    LPTSTR     pszTemp;
    TCHAR      sz[10];
    LPBYTE     pVal;
    DWORD      dwDisp = 0;

    TraceCall("CreateList");

    // Save some of this
    m_uMax      = uMaxEntries;
    m_fFlags    = fFlags;
    m_pszSubKey = PszDupA(pszSubKey);

    // Make sure uMax is < 126 so we don't use extended chars
    if (m_uMax > MAX_CHAR - BASE_CHAR)
        m_uMax = MAX_CHAR - BASE_CHAR;

    // Open the registry
    if (ERROR_SUCCESS != AthUserCreateKey(pszSubKey, KEY_ALL_ACCESS, &m_hKey, &dwDisp))
        goto exit;

    // Do we already have a stored MRU Index?
    cb = ARRAYSIZE(szOrder);
    if (ERROR_SUCCESS != RegQueryValueEx(m_hKey, c_szRegMRU, NULL, &dwType, (LPBYTE) szOrder, &cb))
    {
        // If we didn't find it then do this to initialize the list to be empty.
        *szOrder = 0;
    }

    // Uppercase is not allowed
    CharLower(szOrder);

    // Allocate room for the order list and the list of strings.
    if (!MemAlloc((LPVOID *) &m_rgpszMRU, uMaxEntries * sizeof(LPTSTR)))
        goto exit;
    ZeroMemory(m_rgpszMRU, uMaxEntries * sizeof(LPTSTR));

    // Allocate the order list
    if (!MemAlloc((LPVOID *) &m_pszOrder, sizeof(TCHAR) * (m_uMax + 1)))
        goto exit;
    ZeroMemory(m_pszOrder, (m_uMax + 1) * sizeof(TCHAR));

    // Traverse through the MRU list, adding strings to the end of the list.
    for (pszTemp = szOrder, pszNewOrder = m_pszOrder; ; ++pszTemp)
    {
        // Stop when we get to the end of the list
        sz[0] = *pszTemp;
        sz[1] = 0;
        if (!sz[0])
            break;

        // Check if in range and if we already have used this letter
        if ((UINT) (sz[0] - BASE_CHAR) >= m_uMax || m_rgpszMRU[sz[0] - BASE_CHAR])
            continue;
        
        // Get the value from the registry
        cb = 0;

        // First find the size
        if ((RegQueryValueEx(m_hKey, sz, NULL, &dwType, NULL, &cb) != ERROR_SUCCESS)
            || (dwType != REG_SZ))
            continue;

        cb *= sizeof(TCHAR);
        if (!MemAlloc((LPVOID *) &pVal, cb))
            continue;

        // Now really get it
        if (RegQueryValueEx(m_hKey, sz, NULL, &dwType, (LPBYTE) pVal, &cb) != ERROR_SUCCESS)
            continue;

        // Note that blank elements are not allowed in the list
        if (*((LPTSTR) pVal))
        {
            m_rgpszMRU[sz[0] - BASE_CHAR] = (LPTSTR) pVal;
            *pszNewOrder++ = sz[0];
        }
        else
            MemFree(pVal);
    }

    // NULL terminate the order list
    *pszNewOrder = '\0';

    if (pData && piSlot)
    {
        // If we failed to find it, put -1 in it
        if (!(m_fFlags & MRU_LAZY))
        {
            *piSlot = -1;
        }
    }

exit:
    if (!m_rgpszMRU && m_hKey)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    return (TRUE);
}


BOOL CMRUList::_IsSameData(BYTE FAR *pVal, const void FAR *pData, UINT cbData)
{
    int cbUseSize;

    // If there's something other than a mem compare, don't require the sizes
    // to be equal in order to complete.
    if (m_fFlags & MRU_BINARY)
    {
        if (DATASIZE(pVal) != cbData)
            return (FALSE);

        return (0 == _IMemCmp(pData, DATAPDATA(pVal), cbData));
    }
    else
    {
        return (0 == lstrcmpi((LPCSTR) pData, (LPCSTR) DATAPDATA(pVal)));
    }
}

int CDECL CMRUList::_IMemCmp(const void *pBuf1, const void *pBuf2, size_t cb)
{
    UINT i;
    const BYTE *lpb1, *lpb2;

    Assert(pBuf1);
    Assert(pBuf2);

    lpb1 = (const BYTE *)pBuf1; lpb2 = (const BYTE *)pBuf2;

    for (i=0; i < cb; i++)
    {
        if (*lpb1 > *lpb2)
            return 1;
        else if (*lpb1 < *lpb2)
            return -1;

        lpb1++;
        lpb2++;
    }

    return 0;
}



//
//  FUNCTION:   CMRUList::FreeList()
//
//  PURPOSE:    
//
//  PARAMETERS: 
//      void
//
//  RETURN VALUE:
//      void 
//
void CMRUList::FreeList(void)
{
    int     i;
    LPBYTE *pTemp;

    TraceCall("CMRUList::FreeList");

    if (m_fFlags & MRU_BINARY)
        pTemp = &NTHDATA(m_rgpszMRU, 0);
    else
        pTemp = (LPBYTE *) &NTHSTRING(m_rgpszMRU, 0);

    if (m_fFlags & MRU_ORDERDIRTY)
    {
        // _SaveOrder();
    }

    for (i = m_uMax - 1; i >= 0; --i, ++pTemp)
    {
        SafeMemFree(*pTemp);
    }

    SafeMemFree(m_rgpszMRU);
}


//
//  FUNCTION:   CMRUList::AddString()
//
//  PURPOSE:    Writes the specified string into the MRU list
//
//  PARAMETERS: 
//      [in] pszString - string to add
//
//  RETURN VALUE:
//      Returns -1 if it was not inserted.
//
int CMRUList::AddString(LPCSTR pszString)
{
    TCHAR   cFirst;
    int     iSlot = -1;
    LPTSTR *ppszTemp;
    LPTSTR  pszTemp = 0;
    int     i;
    BOOL    fShouldWrite;

    TraceCall("CMRUList::AddString");

    fShouldWrite = !(m_fFlags & MRU_CACHEWRITE);

    // Check to see if the string already exists in the list
    for (i = 0, ppszTemp = m_rgpszMRU; (UINT) i < m_uMax; i++, ppszTemp++)
    {
        if (*ppszTemp)
        {
            if (0 == lstrcmpi(pszString, (LPCTSTR) *ppszTemp))
            {
                // Found it, so don't do the write
                cFirst = i + BASE_CHAR;
                iSlot = i;
                goto found;
            }
        }
    }

    // Attempt to find an unsed entry.  Count up the used entries at the same
    // time.
    for (i = 0, ppszTemp = m_rgpszMRU; ; i++, ppszTemp++)
    {
        // If we hit the end of the list
        if ((UINT) i >= m_uMax)
        {
            // Use the entry at the end of the order array
            cFirst = m_pszOrder[m_uMax - 1];
            ppszTemp = &(m_rgpszMRU[cFirst - BASE_CHAR]);
            break;
        }

        // Is the entry empty?
        if (!*ppszTemp)
        {
            cFirst = i + BASE_CHAR;
            break;
        }
    }

    // Copy the string
    if (_SetPtr(ppszTemp, pszString))
    {
        TCHAR szTemp[2];

        iSlot = (int) (cFirst - BASE_CHAR);

        szTemp[0] = cFirst;
        szTemp[1] = '\0';

        RegSetValueEx(m_hKey, szTemp, 0L, REG_SZ, (CONST BYTE *) pszString,
                      sizeof(TCHAR) * (lstrlen(pszString) + 1));

        fShouldWrite = TRUE;
    }

found:
    // Remove any previous reference to cFirst
    pszTemp = StrChr(m_pszOrder, cFirst);
    if (pszTemp)
    {
        lstrcpy(pszTemp, pszTemp + 1);
    }

    // If we moved or inserted, update the order array
    if (iSlot != -1)
    {
        // Shift everything over and put cFirst at the front
        MoveMemory(m_pszOrder + 1, m_pszOrder, m_uMax * sizeof(TCHAR));
        m_pszOrder[0] = cFirst;
    }

    // If we need to write, do it
    if (fShouldWrite)
    {
        RegSetValueEx(m_hKey, c_szRegMRU, 0L, REG_SZ, (CONST BYTE *) m_pszOrder,
                      sizeof(TCHAR) * (lstrlen(m_pszOrder) + 1));
        m_fFlags &= ~MRU_ORDERDIRTY;
    }
    else
    {
        m_fFlags |= MRU_ORDERDIRTY;
    }

    return (iSlot);
}

//
//  FUNCTION:   CMRUList::RemoveString()
//
//  PURPOSE:    Removes the specified string from the MRU list
//
//  PARAMETERS: 
//      [in] pszString - string to remove
//
//  RETURN VALUE:
//      Returns -1 if it was not removed.
//
int CMRUList::RemoveString(LPCSTR pszString)
{
    INT         iRet = -1;
    BOOL        fShouldWrite = FALSE;
    int         i = 0;
    LPTSTR *    ppszTemp = NULL;
    TCHAR       cFirst = '\0';
    LPTSTR      pszTemp = 0;
    TCHAR       szTemp[2];

    TraceCall("CMRUList::RemoveString");

    if (NULL == pszString)
    {
        iRet = -1;
        goto exit;
    }
    
    fShouldWrite = !(m_fFlags & MRU_CACHEWRITE);

    // See if the string is in the MRU list
    for (i = 0, ppszTemp = m_rgpszMRU; (UINT) i < m_uMax; i++, ppszTemp++)
    {
        if (*ppszTemp)
        {
            if (0 == lstrcmpi(pszString, (LPCTSTR) *ppszTemp))
            {
                // Found it, so don't do the write
                cFirst = i + BASE_CHAR;
                iRet = i;
                break;
            }
        }
    }

    // We didn't find anything
    if ((UINT) i >= m_uMax)
    {
        iRet = -1;
        goto exit;
    }
    
    // Remove any previous reference to cFirst
    pszTemp = StrChr(m_pszOrder, cFirst);
    if (pszTemp)
    {
        lstrcpy(pszTemp, pszTemp + 1);
    }

    // Copy the string
    if (_SetPtr(ppszTemp, NULL))
    {
        szTemp[0] = cFirst;
        szTemp[1] = '\0';

        RegDeleteValue(m_hKey, szTemp);

        fShouldWrite = TRUE;
    }

    
    // If we need to write, do it
    if (fShouldWrite)
    {
        RegSetValueEx(m_hKey, c_szRegMRU, 0L, REG_SZ, (CONST BYTE *) m_pszOrder,
                      sizeof(TCHAR) * (lstrlen(m_pszOrder) + 1));
        m_fFlags &= ~MRU_ORDERDIRTY;
    }
    else
    {
        m_fFlags |= MRU_ORDERDIRTY;
    }
    
exit:
    return (iRet);
}

int CMRUList::EnumList(int nItem, LPTSTR psz, UINT uLen)
{
    int    nItems = -1;
    LPTSTR pszTemp;
    LPBYTE pData;

    if (m_rgpszMRU)
    {
        nItems = lstrlen(m_pszOrder);

        if (nItems < 0 || !psz)
            return (nItems);

        if (nItem < nItems)
        {
            pszTemp = m_rgpszMRU[m_pszOrder[nItem] - BASE_CHAR];
            if (!pszTemp)
                return (-1);

            lstrcpyn(psz, pszTemp, uLen);
            nItems = lstrlen(pszTemp);
        }
        else
        {
            nItems = -1;
        }
    }

    return (nItems);
}

BOOL CMRUList::_SetPtr(LPSTR * ppszCurrent, LPCSTR pszNew)
{
    int cchLength;
    LPSTR pszOld;
    LPSTR pszNewCopy = NULL;

    if (pszNew)
    {
        cchLength = lstrlenA(pszNew);

        // alloc a new buffer w/ room for the null terminator
        MemAlloc((LPVOID *) &pszNewCopy, ((cchLength + 1) * sizeof(TCHAR)));

        if (!pszNewCopy)
            return FALSE;

        lstrcpynA(pszNewCopy, pszNew, cchLength + 1);
    }

    pszOld = (LPSTR) InterlockedExchangePointer((LPVOID *)ppszCurrent, (LPVOID *)pszNewCopy);

    if (pszOld)
        MemFree(pszOld);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\menuutil.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     menuutil.cpp
//
//  PURPOSE:    Reusable menu & menu command handling code
//

#include "pch.hxx"
#include "resource.h"
#include "menuutil.h"
#include "imnact.h"
#include "strconst.h"
#include "fldrprop.h"
#include "mailutil.h"
#include "mimeutil.h"
#include "inetcfg.h"
#include "newfldr.h"
#include "browser.h"
#include "instance.h"
#include "statbar.h"
#include "storutil.h"
#include "subscr.h"
#include "demand.h"
#include "menures.h"
#include "statnery.h"
#include "store.h"
#include <storecb.h>
#include <range.h>
#include <newsdlgs.h>
#include "acctutil.h"

static const UINT c_rgidNewsNoShow[] =
    { ID_NEW_FOLDER, ID_RENAME, ID_DELETE_FOLDER, SEP_MAILFOLDER };

static const UINT c_rgidSubNoShow[] =
    { ID_SUBSCRIBE, ID_UNSUBSCRIBE, SEP_SUBSCRIBE };

static const UINT c_rgidSyncNoShow[] =
    { ID_POPUP_SYNCHRONIZE, SEP_SYNCHRONIZE };

static const UINT c_rgidCatchUpNoShow[] =
    { ID_CATCH_UP, SEP_CATCH_UP };

void DeleteMenuItems(HMENU hMenu, const UINT *rgid, UINT cid)
{
    Assert(rgid != NULL);
    Assert(cid != 0);

    for ( ; cid > 0; cid--, rgid++)
        DeleteMenu(hMenu, *rgid, MF_BYCOMMAND);
}

//
//  FUNCTION:   MenuUtil_GetContextMenu()
//
//  PURPOSE:    Returns a handle to the context menu that is appropriate for
//              the folder type passed in pidl.  The correct menu items will
//              be enabled, disabled, bolded, etc.
//
//  PARAMETERS:
//      <in>  pidl   - PIDL that points to the folder that the caller needs a 
//                     context menu for.
//      <out> phMenu - Returns the handle to a popup menu.
//
//  RETURN VALUE:
//      S_OK         - phMenu contains a valid hMenu for the folder
//      E_UNEXPECTED - Either there was a problem loading the menu or the 
//                     folder type was unrecognized.
//      E_FAIL       - The folder type doesn't support a menu.
//
HRESULT MenuUtil_GetContextMenu(FOLDERID idFolder, IOleCommandTarget *pTarget, HMENU *phMenu)
    {
    HRESULT hr;
    TCHAR sz[CCHMAX_STRINGRES];
    FOLDERINFO Folder;
    HMENU hMenu;
    int idMenu;

    // Get folder INfo
    hr = g_pStore->GetFolderInfo(idFolder, &Folder);
    if (FAILED(hr))
        return hr;
   
    // Root ?    
    if (FOLDERID_ROOT == idFolder || ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        idMenu = IDR_SERVER_POPUP;
    else
        idMenu = IDR_FOLDER_POPUP;

    if (0 == (hMenu = LoadPopupMenu(idMenu)))
        {
        g_pStore->FreeRecord(&Folder);
        return (E_OUTOFMEMORY);
        }

    // Bold the default menu items
    MENUITEMINFO mii;
    if (!(MF_GRAYED & GetMenuState(hMenu, ID_OPEN_FOLDER, MF_BYCOMMAND)))
        {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask  = MIIM_STATE;
        mii.fState = MFS_DEFAULT;
        SetMenuItemInfo(hMenu, ID_OPEN_FOLDER, FALSE, &mii);
        }

    if (idMenu == IDR_SERVER_POPUP)
    {
        if (Folder.tyFolder != FOLDER_IMAP)
            DeleteMenu(hMenu, ID_IMAP_FOLDERS, MF_BYCOMMAND);

        if (Folder.tyFolder != FOLDER_NEWS)
            DeleteMenu(hMenu, ID_NEWSGROUPS, MF_BYCOMMAND);
    }
    else
    {
        if (Folder.tyFolder == FOLDER_IMAP)
        {
            AthLoadString(idsShowFolderCmd, sz, ARRAYSIZE(sz));
            ModifyMenu(hMenu, ID_SUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_SUBSCRIBE, sz);
            AthLoadString(idsHideFolderCmd, sz, ARRAYSIZE(sz));
            ModifyMenu(hMenu, ID_UNSUBSCRIBE, MF_BYCOMMAND | MF_STRING, ID_UNSUBSCRIBE, sz);
        }

        if (FOLDER_DELETED != Folder.tySpecial)
            DeleteMenu(hMenu, ID_EMPTY_WASTEBASKET, MF_BYCOMMAND);

        if (FOLDER_JUNK != Folder.tySpecial)
            DeleteMenu(hMenu, ID_EMPTY_JUNKMAIL, MF_BYCOMMAND);

        if (Folder.tyFolder == FOLDER_NEWS)
            DeleteMenuItems(hMenu, c_rgidNewsNoShow, ARRAYSIZE(c_rgidNewsNoShow));

        if (Folder.tyFolder != FOLDER_NEWS &&
            Folder.tyFolder != FOLDER_IMAP)
            DeleteMenuItems(hMenu, c_rgidSubNoShow, ARRAYSIZE(c_rgidSubNoShow));

        if (Folder.tyFolder == FOLDER_LOCAL)
            DeleteMenuItems(hMenu, c_rgidSyncNoShow, ARRAYSIZE(c_rgidSyncNoShow));

        if (Folder.tyFolder != FOLDER_NEWS)
            DeleteMenuItems(hMenu, c_rgidCatchUpNoShow, ARRAYSIZE(c_rgidCatchUpNoShow));
    }

    // Enable / disable
    MenuUtil_EnablePopupMenu(hMenu, pTarget);

    // Return
    *phMenu = hMenu;
    
    g_pStore->FreeRecord(&Folder);

    return (S_OK); 
    }

void MenuUtil_OnSubscribeGroups(HWND hwnd, FOLDERID *pidFolder, DWORD cFolder, BOOL fSubscribe)
{
    CStoreCB *pCB;
    HRESULT hr;
    DWORD iFolder;
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    FOLDERINFO info;

    Assert(hwnd != NULL);
    Assert(pidFolder != NULL);
    Assert(cFolder > 0);

    ZeroMemory(&info, sizeof(FOLDERINFO));
    pCB = NULL;

    for (iFolder = 0; iFolder < cFolder; iFolder++, pidFolder++)
    {
        hr = g_pStore->GetFolderInfo(*pidFolder, &info);
        if (FAILED(hr))
            break;

        if (iFolder == 0)
        {
            if (!fSubscribe)
            {
                if (cFolder == 1)
                {
                    AthLoadString(info.tyFolder == FOLDER_NEWS ? idsWantToUnSubscribe : idsWantToHideFolder, szRes, ARRAYSIZE(szRes));
                    wsprintf(szBuf, szRes, info.pszName);
                }
                else
                {
                    AthLoadString(info.tyFolder == FOLDER_NEWS ? idsWantToUnSubscribeN : idsWantToHideFolderN, szBuf, ARRAYSIZE(szBuf));
                }

                if (IDOK != DoDontShowMeAgainDlg(hwnd,
                                    info.tyFolder == FOLDER_NEWS ? c_szRegUnsubscribe : c_szRegHide,
                                    MAKEINTRESOURCE(idsAthena), szBuf, MB_OKCANCEL))
                {
                    break;
                }
            }

            if (info.tyFolder == FOLDER_IMAP)
            {
                pCB = new CStoreCB;
                if (pCB == NULL)
                    break;

                hr = pCB->Initialize(hwnd,
                            fSubscribe ? MAKEINTRESOURCE(idsShowingFolders) : MAKEINTRESOURCE(idsHidingFolders),
                            FALSE);
                if (FAILED(hr))
                    break;
            }
        }

        if (info.tySpecial == FOLDER_NOTSPECIAL &&
            ISFLAGSET(info.dwFlags, FOLDER_SUBSCRIBED) ^ fSubscribe)
        {
            if (pCB != NULL)
                pCB->Reset();

            hr = g_pStore->SubscribeToFolder(*pidFolder, fSubscribe, (IStoreCallback *)pCB);
            if (hr == E_PENDING)
            {
                Assert(info.tyFolder == FOLDER_IMAP);
                Assert(pCB != NULL);
                hr = pCB->Block();
            }

            if (FAILED(hr))
                break;
        }

        g_pStore->FreeRecord(&info);
    }

    g_pStore->FreeRecord(&info);

    if (pCB != NULL)
    {
        pCB->Close();
        pCB->Release();
    }
}

void MenuUtil_DeleteFolders(HWND hwnd, FOLDERID *pidFolder, DWORD cFolder, BOOL fNoTrash)
{
    CStoreCB *pCB;
    HRESULT hr;
    DWORD iFolder, dwFlags;
    FOLDERID idDeleted, idServer;
    char szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES], szFolder[CCHMAX_FOLDER_NAME];
    FOLDERID *pidFolderT;
    FOLDERINFO info;
    BOOL fPermDelete, fCallback;

    Assert(hwnd != NULL);
    Assert(pidFolder != NULL);
    Assert(cFolder > 0);

    pCB = NULL;
    fCallback = FALSE;
    *szFolder = 0;

    if (fNoTrash)
    {
        dwFlags = DELETE_FOLDER_RECURSIVE | DELETE_FOLDER_NOTRASHCAN;
        fPermDelete = TRUE;
    }
    else
    {
        dwFlags = DELETE_FOLDER_RECURSIVE;
        fPermDelete = FALSE;

        for (iFolder = 0, pidFolderT = pidFolder; iFolder < cFolder; iFolder++, pidFolderT++)
        {
            hr = g_pStore->GetFolderInfo(*pidFolderT, &info);
            if (FAILED(hr))
                return;

            // Skip deletion of any special folders
            if (info.tySpecial == FOLDER_NOTSPECIAL)
            {
                if (iFolder == 0 && cFolder == 1)
                    lstrcpyn(szFolder, info.pszName, ARRAYSIZE(szFolder));

                if (info.tyFolder == FOLDER_IMAP ||
                    info.tyFolder == FOLDER_HTTPMAIL)
                {
                    fPermDelete = TRUE;
                    fCallback = TRUE;
                }
                else if (S_OK == IsParentDeletedItems(*pidFolderT, &idDeleted, &idServer))
                {
                    fPermDelete = TRUE;
                }
            }

            g_pStore->FreeRecord(&info);

            if (fPermDelete)
                break;
        }
    }

    if (fPermDelete)
    {
        if (cFolder == 1 && *szFolder != 0)
        {
            AthLoadString(idsWarnDeleteFolder, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, szFolder);
        }
        else
        {
            AthLoadString(idsWarnDeleteFolderN, szBuf, ARRAYSIZE(szBuf));
        }
    }
    else
    {
        if (cFolder == 1 && *szFolder != 0)
        {
            AthLoadString(idsPromptDeleteFolder, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, szFolder);
        }
        else
        {
            AthLoadString(idsPromptDeleteFolderN, szBuf, ARRAYSIZE(szBuf));
        }
    }

    if (IDYES != AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szBuf, 0, MB_ICONEXCLAMATION  | MB_YESNO | MB_DEFBUTTON2))
        return;

    if (fCallback)
    {
        pCB = new CStoreCB;
        if (pCB == NULL)
            return;

        hr = pCB->Initialize(hwnd, MAKEINTRESOURCE(idsDeletingFolder), FALSE);
        if (FAILED(hr))
        {
            pCB->Release();
            return;
        }
    }

    for (iFolder = 0, pidFolderT = pidFolder; iFolder < cFolder; iFolder++, pidFolderT++)
    {
        hr = g_pStore->GetFolderInfo(*pidFolderT, &info);
        if (FAILED(hr))
            break;

        // Skip deletion of any special folders
        if (info.tySpecial == FOLDER_NOTSPECIAL)
        {
            if (pCB != NULL)
                pCB->Reset();

            hr = g_pStore->DeleteFolder(*pidFolderT, dwFlags, (IStoreCallback *)pCB);
            if (hr == E_PENDING)
            {
                Assert(info.tyFolder == FOLDER_IMAP || info.tyFolder == FOLDER_HTTPMAIL);
                Assert(pCB != NULL);
                hr = pCB->Block();
            }
        }

        g_pStore->FreeRecord(&info);

        if (FAILED(hr))
            break;
    }

    if (pCB != NULL)
    {
        pCB->Close();
        pCB->Release();
    }
}

void MenuUtil_SyncThisNow(HWND hwnd, FOLDERID idFolder)
{
    UPDATENEWSGROUPINFO uni;
    HRESULT hr;
    DWORD dwFlags;
    FOLDERINFO info;
    char szAcctId[CCHMAX_ACCOUNT_NAME];
    BOOL fNews, fMarked;
	
    if (g_pSpooler)
    {
        hr = g_pStore->GetFolderInfo(idFolder, &info);
        if (SUCCEEDED(hr))
        {
            Assert(info.tyFolder == FOLDER_NEWS || info.tyFolder == FOLDER_IMAP || info.tyFolder == FOLDER_HTTPMAIL);    
			
			if((info.tyFolder == FOLDER_NEWS) || 
                    (!g_pConMan->IsAccountDisabled((LPSTR)info.pszAccountId)))
			{
				
				fNews = (info.tyFolder == FOLDER_NEWS);
				
				dwFlags = fNews ? DELIVER_NEWS_TYPE : DELIVER_IMAP_TYPE;
				
				//Tells the spooler that this is a sync operation and not Send&Receive
				dwFlags |= DELIVER_OFFLINE_SYNC | DELIVER_WATCH | DELIVER_NOSKIP;
				
				if (!!(info.dwFlags & FOLDER_SERVER))
				{
					// TODO: review these flags to make sure they are correct
					//dwFlags |= DELIVER_POLL | DELIVER_NEWS_SEND | DELIVER_NEWSIMAP_NOSKIP | DELIVER_NEWSIMAP_OFFLINE;
					dwFlags |= DELIVER_POLL | DELIVER_SEND | DELIVER_OFFLINE_FLAGS;
					g_pSpooler->StartDelivery(hwnd, info.pszAccountId, FOLDERID_INVALID, dwFlags);
				}
				else
				{
					hr = GetFolderAccountId(&info, szAcctId);
					if (SUCCEEDED(hr))
					{          
						hr = HasMarkedMsgs(idFolder, &fMarked);
						if (SUCCEEDED(hr))
						{
							uni.fNews = fNews;
							uni.dwGroupFlags = info.dwFlags;
							
							uni.cMarked = fMarked;
							uni.idCmd = dwFlags;
							
							// Display the dialog to find what get thing to get
							DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddUpdateNewsgroup), hwnd, UpdateNewsgroup, (LPARAM)&uni);
							
							// Check to see if the user canceled
							if (uni.idCmd != -1)
								g_pSpooler->StartDelivery(hwnd, szAcctId, idFolder, uni.idCmd);
						}
					}
				}
			}
            
            g_pStore->FreeRecord(&info);
        }
    }
}

//
//  FUNCTION:   MenuUtil_OnDelete()
//
//  PURPOSE:    Deletes the folder designated by the pidl.
//
//  PARAMETERS:
//      <in> hwnd   - Handle of the window to display UI over
//      <in> pidl   - PIDL of the folder to browse to
//      <in> pStore - Pointer to the store to delete folders from
//
void MenuUtil_OnDelete(HWND hwnd, FOLDERID idFolder, BOOL fNoTrash)
{
    TCHAR szRes[CCHMAX_STRINGRES], szBuf[CCHMAX_STRINGRES];
    FOLDERINFO Folder;  
    IImnAccount *pAcct;
    
    // Get Folder Info
    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return;
    
    // Is a server
    if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
    {
        Assert(g_pAcctMan);
        if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Folder.pszAccountId, &pAcct)))
        {
            AthLoadString(idsWarnDeleteAccount, szRes, ARRAYSIZE(szRes));
            wsprintf(szBuf, szRes, Folder.pszName);
            
            if (IDYES == AthMessageBox(hwnd, MAKEINTRESOURCE(idsAthena), szBuf,
                0, MB_ICONEXCLAMATION  | MB_YESNO | MB_DEFBUTTON2))
            {
                pAcct->Delete();
            }
            
            pAcct->Release();
        }        
    }
    else
    {
        if (Folder.tyFolder == FOLDER_NEWS)
        {
            MenuUtil_OnSubscribeGroups(hwnd, &idFolder, 1, FALSE);
        }
        else
        {
            MenuUtil_DeleteFolders(hwnd, &idFolder, 1, fNoTrash);
        }
    }
    
    g_pStore->FreeRecord(&Folder);
}

//
//  FUNCTION:   MenuUtil_OnProperties()
//
//  PURPOSE:    Displays properties for the folder designated by the pidl
//
//  PARAMETERS:
//      <in> hwnd - Handle of the window to parent the properties
//      <in> pidl - PIDL of the folder to browse to
//
void MenuUtil_OnProperties(HWND hwnd, FOLDERID idFolder)
{   
    IImnAccount *pAcct;
    FOLDERINFO Folder;

    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
    {
        if (ISFLAGSET(Folder.dwFlags, FOLDER_SERVER))
        {
            if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Folder.pszAccountId, &pAcct)))
            {
                HRESULT hr;

                Assert(pAcct != NULL);
                DWORD dwFlags = ACCTDLG_SHOWIMAPSPECIAL | ACCTDLG_INTERNETCONNECTION | ACCTDLG_OE;
                if((DwGetOption(OPT_REVOKE_CHECK) != 0) && !g_pConMan->IsGlobalOffline())
                    dwFlags |= ACCTDLG_REVOCATION;

                //We want to use the new dialog for the properties, hence the new flag internetconnection
                hr = pAcct->ShowProperties(hwnd, dwFlags);
                if (S_OK == hr)
                    // User hit "OK" to exit, not "Cancel"
                    CheckIMAPDirty(Folder.pszAccountId, hwnd, idFolder, NOFLAGS);

                pAcct->Release();
            }
        }
        else if (FOLDER_NEWS == Folder.tyFolder)
        {
            GroupProp_Create(hwnd, idFolder);
        }
        else
        {
            FolderProp_Create(hwnd, idFolder);
        }

        g_pStore->FreeRecord(&Folder);
    }
}

void MenuUtil_OnSetDefaultServer(FOLDERID idFolder)
    {
    TCHAR *sz;
    IImnAccount *pAcct = 0;
    FOLDERINFO Folder;

    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return;

    Assert(ISFLAGSET(Folder.dwFlags, FOLDER_SERVER));

    if (SUCCEEDED(g_pAcctMan->FindAccount(AP_ACCOUNT_ID, Folder.pszAccountId, &pAcct)))
        {
        pAcct->SetAsDefault();
        pAcct->Release();
        }

    g_pStore->FreeRecord(&Folder);
    }

void MenuUtil_OnMarkNewsgroups(HWND hwnd, int id, FOLDERID idFolder)
    {
    FOLDERINFO Folder;

    if (FAILED(g_pStore->GetFolderInfo(idFolder, &Folder)))
        return;

    Folder.dwFlags &= ~(FOLDER_DOWNLOADHEADERS | FOLDER_DOWNLOADNEW | FOLDER_DOWNLOADALL);

    if (id == ID_MARK_RETRIEVE_FLD_NEW_HDRS)
        Folder.dwFlags |= FOLDER_DOWNLOADHEADERS;
    else if (id == ID_MARK_RETRIEVE_FLD_ALL_MSGS)
        Folder.dwFlags |= FOLDER_DOWNLOADALL;
    else if (id == ID_MARK_RETRIEVE_FLD_NEW_MSGS)
        Folder.dwFlags |= FOLDER_DOWNLOADNEW;

    g_pStore->UpdateRecord(&Folder);

    g_pStore->FreeRecord(&Folder);
    }

 // BUG #41686 Catchup Implementation
void MenuUtil_OnCatchUp(FOLDERID idFolder)
{
    FOLDERINFO Folder;
    BOOL fFreeRange;
    CRangeList *pRange;
    IMessageFolder *pFolder;
    ADJUSTFLAGS flags;
    HCURSOR hcur;

    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (SUCCEEDED(g_pStore->OpenFolder(idFolder, NULL, NOFLAGS, &pFolder)))
    {
        flags.dwAdd = ARF_READ;
        flags.dwRemove = ARF_DOWNLOAD;
        pFolder->SetMessageFlags(NULL, &flags, NULL, NULL);

        pFolder->Release();
    }

    if (SUCCEEDED(g_pStore->GetFolderInfo(idFolder, &Folder)))
    {
        fFreeRange = FALSE;

        if (Folder.dwServerHigh > 0)
        {
            Folder.dwClientHigh = Folder.dwServerHigh;

            pRange = new CRangeList;
            if (pRange != NULL)
            {
                if (Folder.Requested.cbSize > 0)
                    pRange->Load(Folder.Requested.pBlobData, Folder.Requested.cbSize);

                pRange->AddRange(0, Folder.dwServerHigh);

                fFreeRange = pRange->Save(&Folder.Requested.pBlobData, &Folder.Requested.cbSize);

                pRange->Release();
            }
        }
        else
        {
            Folder.dwServerLow = 0;
            Folder.dwServerHigh = 0;
            Folder.dwServerCount = 0;
        }   

        Folder.dwNotDownloaded = 0;

        g_pStore->UpdateRecord(&Folder);

        if (fFreeRange)
            MemFree(Folder.Requested.pBlobData);

        g_pStore->FreeRecord(&Folder);
    }

    SetCursor(hcur);
}

UINT GetMenuItemPos(HMENU hmenu, UINT cmd)
{
    MENUITEMINFO mii;
    UINT cItem, ipos;
    
    cItem = GetMenuItemCount(hmenu);
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID;    
    for (ipos = 0; ipos < cItem; ipos++)
    {
        SideAssert(GetMenuItemInfo(hmenu, ipos, TRUE, &mii));
        if (mii.wID == cmd)
            break;
    }
    
    Assert(ipos != cItem);
    
    return(ipos);
}

BOOL MergeMenus(HMENU hmenuSrc, HMENU hmenuDst, int iPos, UINT uFlags)
{
    MENUITEMINFO mii;
    UINT uState, i, cMerge;
    int cItem;
    BOOL fSepPre, fSepPost, fPopup, fCommand;
    BYTE rgch[CCHMAX_STRINGRES];
    HMENU hmenuPopup;
    
    cMerge = GetMenuItemCount(hmenuSrc);
    if (cMerge == 0)
        return(TRUE);
    
    cItem = GetMenuItemCount(hmenuDst);
    
    if (iPos == MMPOS_REPLACE)
    {
        // destroy all menus
        while (RemoveMenu(hmenuDst, 0, MF_BYPOSITION));
        cItem = 0;
        iPos = 0;
    }
    
    if (iPos == MMPOS_APPEND)
        iPos = cItem;
    
    fCommand = ((uFlags & MMF_BYCOMMAND) != 0);
    if (fCommand)
        iPos = GetMenuItemPos(hmenuDst, (UINT)iPos);
    
    if (iPos > cItem)
        iPos = cItem;
    
    fSepPre = FALSE;
    fSepPost = FALSE;
    if (uFlags & MMF_SEPARATOR)
    {
        if (iPos == 0)
        {
            // prepending, so stick in a separator after all the items
            // ASSUMES: never a separator as the last item in a menu
            if (cItem > 0)
                fSepPost = TRUE;
        }
        else if (iPos == cItem)
        {
            // appending, so stick in a separator before all the items
            // ASSUMES: never a separator as the first item in a menu
            fSepPre = TRUE;
        }
        else
        {
            // merging stuff into the middle of the menu, so need to check before and after
            uState = GetMenuState(hmenuDst, iPos - 1, MF_BYPOSITION);
            if (!(uState & MF_SEPARATOR))
                fSepPre = TRUE;
            uState = GetMenuState(hmenuDst, iPos, MF_BYPOSITION);
            if (!(uState & MF_SEPARATOR))
                fSepPost = TRUE;
        }
    }
    
    if (fSepPre)
    {
        InsertMenu(hmenuDst, (UINT)iPos, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);
        iPos++;
    }
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
    
    for (i = 0; i < cMerge; i++)
    {
        mii.dwTypeData = (LPSTR)rgch;
        mii.cch = sizeof(rgch);
        mii.fType = 0;
        GetMenuItemInfo(hmenuSrc, i, TRUE, &mii);
        fPopup = (mii.hSubMenu != NULL);
        
        if (!fPopup && (mii.fType & MFT_SEPARATOR))
        {
            InsertMenuItem(hmenuDst, (UINT)iPos, TRUE, &mii);
        }
        else
        {
            if (fPopup)
            {
                // its a popup submenu item
                hmenuPopup = CreateMenu();
                
                MergeMenus(mii.hSubMenu, hmenuPopup, 0, 0);
                mii.hSubMenu = hmenuPopup;
            }
            
            InsertMenuItem(hmenuDst, (UINT)iPos, TRUE, &mii);
        }
        
        iPos++;
    }
    
    if (fSepPost)
    {
        InsertMenu(hmenuDst, (UINT)iPos, MF_SEPARATOR | MF_BYPOSITION, 0, NULL);
        iPos++;
    }
    
    return(TRUE);
}
    
//
// REVIEW: We need this function because current version of USER.EXE does
//  not support pop-up only menu.
//
HMENU LoadPopupMenu(UINT id)
{
    HMENU hmenuParent = LoadMenu(g_hLocRes, MAKEINTRESOURCE(id));
    
    if (hmenuParent) {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }
    
    return NULL;
}

// walks a menu recursively, calling pfn for each item that isn't a separator
void WalkMenu(HMENU hMenu, WALKMENUFN pfn, LPVOID lpv)
{
    MENUITEMINFO    mii;
    int             i, cItems;
    
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
    
    cItems = GetMenuItemCount(hMenu);
    for (i=0; i<cItems; i++)
    {
        mii.dwTypeData = 0;
        mii.cch = 0;
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
        {
            if (!(mii.fType & MFT_SEPARATOR))
                (*pfn)(hMenu, mii.wID, lpv);
            
            if (mii.hSubMenu)
                WalkMenu(mii.hSubMenu, pfn, lpv);
        }
    }
}


void MenuUtil_BuildMenuIDList(HMENU hMenu, OLECMD **prgCmds, ULONG *pcStart, ULONG *pcCmds)
{
    ULONG        cItems = 0;
    MENUITEMINFO mii;

    if(!IsMenu(hMenu))
    return;
    // Start by getting the count of items on this menu
    cItems = GetMenuItemCount(hMenu);
    if (!cItems)
        return;        

    // Realloc the array to be cItems elements bigger
    if (!MemRealloc((LPVOID *) prgCmds, sizeof(OLECMD) * (cItems + (*pcCmds))))
        return;

    *pcCmds += cItems;

    // Walk this menu and add our items to it
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    for (ULONG i = 0; i < cItems; i++)
    {
        if (GetMenuItemInfo(hMenu, i, TRUE, &mii))
        {
            // Make sure this isn't a separator
            if (mii.wID != -1 && mii.wID != 0)
            {
                // Add the ID to our array
                (*prgCmds)[*pcStart].cmdID = mii.wID;
                (*prgCmds)[*pcStart].cmdf = 0;
                (*pcStart)++;

                // See if we need to recurse
                if (mii.hSubMenu)
                {
                    MenuUtil_BuildMenuIDList(mii.hSubMenu, prgCmds, pcStart, pcCmds);
                }
            }
        }
    }

    return;
}


//
//  FUNCTION:   MenuUtil_EnablePopupMenu()
//
//  PURPOSE:    Walks the given menu and takes care of enabling and
//              disabling each item via the provided commnand target.
//
//  PARAMETERS: 
//      [in] hPopup
//      [in] *pTarget
//
HRESULT MenuUtil_EnablePopupMenu(HMENU hPopup, IOleCommandTarget *pTarget)
{
    HRESULT             hr = S_OK;
    int                 i;
    int                 cItems;
    OLECMD             *rgCmds = NULL;
    ULONG               cStart = 0;
    ULONG               cCmds = 0;
    MENUITEMINFO        mii = {0};

    Assert(hPopup && pTarget);

    // Build the array of menu ids
    MenuUtil_BuildMenuIDList(hPopup, &rgCmds, &cCmds, &cStart);

    // Ask our parent for the state of the commands
    if (SUCCEEDED(hr = pTarget->QueryStatus(&CMDSETID_OutlookExpress, cCmds, rgCmds, NULL)))
    {
        mii.cbSize = sizeof(MENUITEMINFO);

        // Now loop through the menu and apply the state
        for (i = 0; i < (int) cCmds; i++)
        {
            // The default thing we're going to update is the state
            mii.fMask = MIIM_STATE;

            // Enabled or Disabled
            if (rgCmds[i].cmdf & OLECMDF_ENABLED)
                mii.fState = MFS_ENABLED;
            else
                mii.fState = MFS_GRAYED;
                
            // Checked?
            if (rgCmds[i].cmdf & OLECMDF_LATCHED)
                mii.fState |= MFS_CHECKED;


            // Set the item state
            BOOL f;
            f = SetMenuItemInfo(hPopup, rgCmds[i].cmdID, FALSE, &mii);

            // Radio Check?
            if ((rgCmds[i].cmdf & OLECMDF_NINCHED) && rgCmds[i].cmdID != (-1))
            {
                CheckMenuRadioItem(hPopup, rgCmds[i].cmdID, rgCmds[i].cmdID, rgCmds[i].cmdID, MF_BYCOMMAND);
                // mii.fMask |= MIIM_TYPE;
                // mii.fType = MFT_RADIOCHECK;
                // mii.fState |= MFS_CHECKED;
            }
            // Assert(f);
        }
    }

    SafeMemFree(rgCmds);

    return (hr);
}


void HandleMenuSelect(CStatusBar *pStatus, WPARAM wParam, LPARAM lParam)
{
    UINT    fuFlags, uItem;
    HMENU   hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
    
    if (!pStatus)
        return;

    uItem = (UINT) LOWORD(wParam);
    fuFlags = (UINT) HIWORD(wParam);

    if (fuFlags & MF_POPUP)
    {
        MENUITEMINFO mii = { sizeof(MENUITEMINFO), MIIM_ID, 0 };
    
        if (hmenu && IsMenu(hmenu))
        {
            // Windows 98 seems to pass the command ID for popup items instead
            // of the documented position.  So, if uItem is less than 40000 then
            // we can assume this is a menu position otherwise we assume it's
            // a command ID.
            if (GetMenuItemInfo(hmenu, uItem, (uItem < ID_FIRST), &mii))
            {
                // change the parameters to simulate a normal menu item
                uItem = mii.wID;
                fuFlags = 0;
            }
        }
    }         

    if (0 == (fuFlags & (MF_SYSMENU | MF_POPUP)))
    {
        TCHAR szMenu[256], szRes[CCHMAX_STRINGRES], szTemp[CCHMAX_STRINGRES + 256];
        
        if (uItem >= ID_SORT_MENU_FIRST && uItem <= ID_SORT_MENU_LAST)
        {
            MENUITEMINFO mii = {0};

            *szMenu = '\0';
            *szRes  = '\0';
            *szTemp = '\0';

            // must be a sort menu command! pull the menu name from the menu
            mii.cbSize     = sizeof(MENUITEMINFO);
            mii.fMask      = MIIM_TYPE;
            mii.dwTypeData = (LPSTR)szMenu;
            mii.cch        = ARRAYSIZE(szMenu);

            if (GetMenuItemInfo((HMENU)lParam, uItem, FALSE, &mii))
            {
                AthLoadString(idsSortMenuHelpControl, szRes, sizeof(szRes));
                wsprintf(szTemp, szRes, szMenu);
                pStatus->ShowSimpleText(szTemp);
            }
        }
        else if (uItem >= ID_FIRST && uItem <= ID_LAST)
        {
            uItem = uItem - ID_FIRST;

            pStatus->ShowSimpleText(MAKEINTRESOURCE(uItem));            
        }
        else if ((uItem >= ID_VIEW_FILTER_FIRST) && (uItem <= ID_VIEW_FILTER_LAST))
        {
            if ((uItem >= ID_VIEW_CURRENT) && (uItem <= ID_VIEW_RECENT_4))
            {
                MENUITEMINFO mii = {0};

                *szMenu   = '\0';
                *szRes    = '\0';
                *szTemp   = '\0';

                // must be a sort menu command! pull the menu name from the menu
                mii.cbSize     = sizeof(MENUITEMINFO);
                mii.fMask      = MIIM_TYPE;
                mii.dwTypeData = (LPSTR)szMenu;
                mii.cch        = ARRAYSIZE(szMenu);

                if (GetMenuItemInfo((HMENU)lParam, uItem, FALSE, &mii))
                {
                    AthLoadString(idsViewMenuHelpControl, szRes, sizeof(szRes));
                    wsprintf(szTemp, szRes, szMenu);
                    pStatus->ShowSimpleText(szTemp);
                }
            }
            else
            {
                uItem = uItem - ID_FIRST;
                pStatus->ShowSimpleText(MAKEINTRESOURCE(uItem));
            }
        }
        else if ((uItem >= ID_MESSENGER_FIRST) && (uItem<= ID_MESSENGER_LAST))
        {
            TCHAR szBuf[CCHMAX_STRINGRES] = "";

            AthLoadString(uItem  - ID_FIRST, szBuf, ARRAYSIZE(szBuf));
            MenuUtil_BuildMessengerString(szBuf);
            pStatus->ShowSimpleText(szBuf);
        }
        else
        {
            if (uItem >= ID_ACCOUNT_FIRST && uItem <= ID_ACCOUNT_LAST)
                pStatus->ShowSimpleText(MAKEINTRESOURCE(idsSRAccountMenuHelp));
            else
                pStatus->ShowSimpleText(0);
        }
    }
    else if (fuFlags == 0xffff && ((HMENU)lParam) == NULL)
    {
        pStatus->HideSimpleText();
    }
}

//
//  FUNCTION:   MenuUtil_SetPopupDefault()
//
//  PURPOSE:    Bolds the default item in a context menu 
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
void MenuUtil_SetPopupDefault(HMENU hPopup, UINT idDefault)
{
    MENUITEMINFO    mii;

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STATE;

    if (GetMenuItemInfo(hPopup, idDefault, FALSE, &mii))
        {
        mii.fState |= MFS_DEFAULT;

        SetMenuItemInfo(hPopup, idDefault, FALSE , &mii);
        }
}


//
//  FUNCTION:   MenuUtil_ReplaceHelpMenu
//
//  PURPOSE:    Populates the ID_POPUP_HELP menu
//
void MenuUtil_ReplaceHelpMenu(HMENU hMenu)
{
    MENUITEMINFO    mii;

    if (mii.hSubMenu = LoadPopupMenu(IDR_HELP_POPUP))
        {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_SUBMENU;
        SetMenuItemInfo(hMenu, ID_POPUP_HELP, FALSE, &mii); 
        }
}


//
//  FUNCTION:   MenuUtil_ReplaceNewMsgMenu
//
//  PURPOSE:    Populates the ID_POPUP_HELP menu
//
void MenuUtil_ReplaceNewMsgMenus(HMENU hMenu)
{
    MENUITEMINFO    mii;

    if (mii.hSubMenu = LoadPopupMenu(IDR_NEW_MSG_POPUP))
    {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_SUBMENU;
        SetMenuItemInfo(hMenu, ID_POPUP_NEW_MSG, FALSE, &mii); 
    }
}

//
//  FUNCTION:   MenuUtil_ReplaceMessengerMenus
//
//  PURPOSE:    Customizes the Messenger menus with IEAK Messenger names...
//
void MenuUtil_ReplaceMessengerMenus(HMENU hMenu)
{
    ULONG ulMenuItem;
    MENUITEMINFO mii;
    TCHAR szName[CCHMAX_STRINGRES];

    for(ulMenuItem=ID_MESSENGER_FIRST;ulMenuItem<ID_MESSENGER_LAST;ulMenuItem++)
    {
        ZeroMemory(&mii, sizeof(MENUITEMINFO));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE;
        mii.dwTypeData = szName;
        mii.cch = CCHMAX_STRINGRES;

        if(GetMenuItemInfo(hMenu, ulMenuItem, FALSE, &mii))
        {
            if(MenuUtil_BuildMessengerString(szName))
            {
                mii.cbSize = sizeof(MENUITEMINFO);                
                mii.fMask = MIIM_TYPE;                
                mii.fType = MFT_STRING;
                mii.dwTypeData = szName;

                SetMenuItemInfo(hMenu, ulMenuItem, FALSE, &mii);
            }
        }
    }
}

BOOL MenuUtil_BuildMessengerString(LPTSTR szMesStr)
{
    static TCHAR s_szCustName[51] = ""; //We know the name is less than 50 chars
    TCHAR szNewMesStr[CCHMAX_STRINGRES];
    HKEY hkey = NULL;
    DWORD cb;
    BOOL fReplaced=FALSE;

    Assert(szMesStr);

    if(s_szCustName[0] == 0)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\MessengerService", 0, KEY_READ, &hkey))
        {
            cb = sizeof(s_szCustName);
            RegQueryValueEx(hkey, "", NULL, NULL, (LPBYTE)s_szCustName, &cb);
            RegCloseKey(hkey);
        }
    
        if(s_szCustName[0] == 0)
            AthLoadString(idsServiceName, s_szCustName, ARRAYSIZE(s_szCustName));
            
    }    

    fReplaced = (NULL != StrStr(szMesStr, "%s"));

    //HACK!  For strings needing multiple replacement...
    if (fReplaced)
    {
        wsprintf(szNewMesStr, szMesStr, s_szCustName, s_szCustName, s_szCustName, s_szCustName);
        StrCpy(szMesStr, szNewMesStr);
    }

    return fReplaced;
}

void GetDefaultFolderID(BOOL fMail, FOLDERID *pFolderID)
{
    IImnAccount        *pAcct = NULL;
    CHAR                szAccountId[CCHMAX_ACCOUNT_NAME];
    IEnumerateFolders  *pEnumFolders = NULL;
    FOLDERINFO          rFolder;
    BOOL                fFound = FALSE;
    ACCTTYPE            acctType = ACCT_NEWS;
    DWORD               dwServerTypes = 0;

    *pFolderID = FOLDERID_INVALID;

    if (FAILED(g_pAcctMan->GetDefaultAccount(fMail?ACCT_MAIL:ACCT_NEWS, &pAcct)))
        goto Exit;

    if (FAILED(pAcct->GetAccountType(&acctType)))
        goto Exit;

    if ((ACCT_NEWS != acctType) && SUCCEEDED(pAcct->GetServerTypes(&dwServerTypes)) && (dwServerTypes & SRV_POP3))
    {
        *pFolderID = FOLDERID_LOCAL_STORE;
        goto Exit;
    }

    *szAccountId = 0;

    if (FAILED(pAcct->GetPropSz(AP_ACCOUNT_ID, szAccountId, ARRAYSIZE(szAccountId))))
        goto Exit;

    if (FAILED(g_pStore->EnumChildren(FOLDERID_ROOT, TRUE, &pEnumFolders)))
        goto Exit;

    AssertSz(pAcct, "How did we succeed and not get a pAcct?");
    AssertSz(pEnumFolders, "How did we succeed and not get a pEnumFolders?");

    while (!fFound && (S_OK == pEnumFolders->Next(1, &rFolder, NULL)))
    {
        fFound = (0 == lstrcmp(szAccountId, rFolder.pszAccountId));
        if (fFound)
            *pFolderID = rFolder.idFolder;
        g_pStore->FreeRecord(&rFolder);
    }

Exit:
    ReleaseObj(pAcct);
    ReleaseObj(pEnumFolders);

}

//
//  FUNCTION:       MenuUtil_HandleNewMessageIDs
//
//  PURPOSE:        Handles creation of notes from an ID
//
//  RETURN VALUE:   Returns TRUE if event was handled
//
BOOL MenuUtil_HandleNewMessageIDs(DWORD id, HWND hwnd, FOLDERID folderID, BOOL fMail, BOOL fModal, IUnknown *pUnkPump)
{
    switch (id)
    {
        case ID_NEW_NEWS_MESSAGE:
        case ID_NEW_MAIL_MESSAGE:
        case ID_NEW_MSG_DEFAULT:
        {
            FOLDERINFO rInfo = {0};
            
            if (id != ID_NEW_MSG_DEFAULT)
                fMail = (id == ID_NEW_MAIL_MESSAGE);

            if (SUCCEEDED(g_pStore->GetFolderInfo(folderID, &rInfo)))
            {
                BOOL fFolderIsMail = (rInfo.tyFolder != FOLDER_NEWS);
                if (fFolderIsMail != fMail)
                    GetDefaultFolderID(fMail, &folderID);
                g_pStore->FreeRecord(&rInfo);
            }

            if (DwGetOption(fMail ? OPT_MAIL_USESTATIONERY : OPT_NEWS_USESTATIONERY))
            {
                WCHAR   wszFile[MAX_PATH];
                if (SUCCEEDED(GetDefaultStationeryName(fMail, wszFile)) && 
                    SUCCEEDED(HrNewStationery(hwnd, 0, wszFile, fModal, fMail, folderID, FALSE, NSS_DEFAULT, pUnkPump, NULL)))
                {
                    return TRUE;
                }
                // If HrNewStationery fails, go ahead and try opening a blank note without stationery.
            }
            FNewMessage(hwnd, fModal, !DwGetOption(fMail ? OPT_MAIL_SEND_HTML : OPT_NEWS_SEND_HTML), !fMail, folderID, pUnkPump);
            return TRUE;
        }

        case ID_STATIONERY_RECENT_0:
        case ID_STATIONERY_RECENT_1:
        case ID_STATIONERY_RECENT_2:
        case ID_STATIONERY_RECENT_3:
        case ID_STATIONERY_RECENT_4:
        case ID_STATIONERY_RECENT_5:
        case ID_STATIONERY_RECENT_6:
        case ID_STATIONERY_RECENT_7:
        case ID_STATIONERY_RECENT_8:
        case ID_STATIONERY_RECENT_9:
            HrNewStationery(hwnd, id, NULL, fModal, fMail, folderID, TRUE, NSS_MRU, pUnkPump, NULL);
            return TRUE;

        case ID_STATIONERY_MORE:
            HrMoreStationery(hwnd, fModal, fMail, folderID, pUnkPump);
            return TRUE;

        case ID_STATIONERY_NONE:
            FNewMessage(hwnd, fModal, TRUE, !fMail, folderID, pUnkPump);
            return TRUE;

        case ID_WEB_PAGE:
            HrSendWebPage(hwnd, fModal, fMail, folderID, pUnkPump);
            return TRUE;

    }
    return FALSE;
}

HRESULT MenuUtil_NewMessageIDsQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText, BOOL fMail)
{
    DWORD cMailServer = 0;
    DWORD cNewsServer = 0;
    DWORD cDefServer = 0;
    DWORD dwDefFlags;

    // For right now, NULL is acceptable.
    if (pguidCmdGroup && !IsEqualGUID(CMDSETID_OutlookExpress, *pguidCmdGroup))
        return S_OK;

    g_pAcctMan->GetAccountCount(ACCT_NEWS, &cMailServer);
    g_pAcctMan->GetAccountCount(ACCT_MAIL, &cNewsServer);
    cDefServer = fMail ? cMailServer : cNewsServer;

    // If there is at least one server and we are not mail in news only mode
    if (!fMail || (0 == (g_dwAthenaMode & MODE_NEWSONLY)))
        dwDefFlags = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
    else
        dwDefFlags = OLECMDF_SUPPORTED;

    for (UINT i = 0; i < cCmds; i++)
    {
        if (prgCmds[i].cmdf == 0)
        {
            switch (prgCmds[i].cmdID)
            {
                case ID_POPUP_NEW_MSG:
                case ID_NEW_MSG_DEFAULT:
                case ID_STATIONERY_RECENT_0:
                case ID_STATIONERY_RECENT_1:
                case ID_STATIONERY_RECENT_2:
                case ID_STATIONERY_RECENT_3:
                case ID_STATIONERY_RECENT_4:
                case ID_STATIONERY_RECENT_5:
                case ID_STATIONERY_RECENT_6:
                case ID_STATIONERY_RECENT_7:
                case ID_STATIONERY_RECENT_8:
                case ID_STATIONERY_RECENT_9:
                case ID_STATIONERY_MORE:
                case ID_STATIONERY_NONE:
                    prgCmds[i].cmdf = dwDefFlags;
                    break;

                case ID_WEB_PAGE:
                    // If is enabled, then better make sure that we are on line.
                    if ((dwDefFlags & OLECMDF_ENABLED) && g_pConMan->IsGlobalOffline())
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    else
                        prgCmds[i].cmdf = dwDefFlags;
                    break;

                case ID_NEW_MAIL_MESSAGE:
                    if (!(g_dwAthenaMode & MODE_NEWSONLY))
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    else
                        prgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    break;

                case ID_NEW_NEWS_MESSAGE:
                    prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                    break;
            }
        }
    }
    
    return S_OK;
}

HRESULT MenuUtil_EnableMenu(HMENU hMenu, IOleCommandTarget *pTarget)
{
    int         Count;
    HMENU       hMenuSub;
    HRESULT     hr = S_OK;

    Count = GetMenuItemCount(hMenu);
    if (Count != -1)
    {
        while (--Count >= 0)
        {
            hMenuSub = GetSubMenu(hMenu, Count);
            hr = MenuUtil_EnablePopupMenu(hMenuSub, pTarget);
        }
    }
    else
        hr = E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\multlang.cpp ===
// =================================================================================
// MultLang.cpp
// Multilanguage support for OE.
// Created at 10/12/98 by YST
// Copyright (c)1993-1998 Microsoft Corporation, All Rights Reserved
// =================================================================================
#include "pch.hxx"
#include "multlang.h"
#include "fonts.h"
#include "shared.h"
#include "mimeutil.h"
                          
void GetMimeCharsetForTitle(HCHARSET hCharset, LPINT pnIdm, LPTSTR lpszString, int nSize, BOOL fReadNote)
{
    UINT uiCodePage = 0 ;
    INETCSETINFO CsetInfo ;
    int i =0;

    if (lpszString)
        lpszString[0] = '\0';
    if ( hCharset == NULL )
        return ;

    // get CodePage from HCHARSET 
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    uiCodePage = CsetInfo.cpiInternet ;

    // bug # 45377 - message language title
    for(i = 0; OENonStdCPs[i].Codepage != 0; i++)
    {
        if(OENonStdCPs[i].Codepage == uiCodePage)
        {
            if(OENonStdCPs[i].cpReadTitle)
                uiCodePage = OENonStdCPs[i].cpReadTitle;
            break;
        }
    }

    _GetMimeCharsetLangString(FALSE, GetMapCP(uiCodePage, fReadNote), pnIdm, lpszString, nSize);

    return ;
}                                                            

BOOL fCheckEncodeMenu(UINT uiCodePage, BOOL fReadNote)
{
    BOOL fReturn = TRUE;
    int i =0;
    BOOL  fUseSIO = SUCCEEDED(g_lpIFontCache->GetJP_ISOControl(&fUseSIO));

    for(i = 0; OENonStdCPs[i].Codepage != 0; i++)
    {
        if(OENonStdCPs[i].Codepage == uiCodePage)
        {
            if(fReadNote)
            {
                if(!OENonStdCPs[i].cpReadMenu)
                    return(FALSE);
                else if(OENonStdCPs[i].UseSIO)
                {
                    if((OENonStdCPs[i].UseSIO == 1) && fUseSIO)
                        return(FALSE);
                    if((OENonStdCPs[i].UseSIO == 2) && !fUseSIO)
                        return(FALSE);
                }
            }
            else            // Send note
            {
                if(!OENonStdCPs[i].cpSendMenu)
                    return(FALSE);
            }

        }
        
    }
    return(fReturn);
}

// Map one code page to another
UINT GetMapCP(UINT uiCodePage, BOOL fReadNote)
{
    int i =0;
    INETCSETINFO    CsetInfo ;

    for(i = 0; OENonStdCPs[i].Codepage != 0; i++)
    {
        if(OENonStdCPs[i].Codepage == uiCodePage)
        {
            if(fReadNote)
            {
                if(OENonStdCPs[i].cpRead)
                    return(OENonStdCPs[i].cpRead);
                else
                {
                    HCHARSET hCharset = NULL;

                    if(SUCCEEDED(HGetDefaultCharset(&hCharset)) && SUCCEEDED(MimeOleGetCharsetInfo(hCharset, &CsetInfo)))
                        return(CsetInfo.cpiInternet);
                }
            }
            else        // Send note
            {
                if(OENonStdCPs[i].cpSend)
                    return(OENonStdCPs[i].cpSend);
                else
                {
                    if(SUCCEEDED(MimeOleGetCharsetInfo(g_hDefaultCharsetForMail,&CsetInfo)))
                        return(CsetInfo.cpiInternet);                    
                }
            }
        }
    }

    return(uiCodePage);
}

// depending on registry setting, return correct hCharset for iso-2022-jp encoding
HCHARSET GetJP_ISOControlCharset(void)
{
    BOOL fUseSIO;
    Assert(g_lpIFontCache);
    HRESULT hr = g_lpIFontCache->GetJP_ISOControl(&fUseSIO);
    if (FAILED(hr))
        fUseSIO = FALSE;

    if (fUseSIO)
        return GetMimeCharsetFromCodePage(50222); // _iso-2022-jp$SIO
    else
        return GetMimeCharsetFromCodePage(50221); // _iso-2022-jp$ESC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\multlang.h ===
// =================================================================================
// MultLang.h
// Multilanguage support for OE.
// Created at 10/12/98 by YST
// Copyright (c)1993-1998 Microsoft Corporation, All Rights Reserved
// =================================================================================
#ifndef __MULTILANG_H
#define __MULTILANG_H


void GetMimeCharsetForTitle(HCHARSET hCharset, LPINT pnIdm, LPTSTR lpszString, int nSize, BOOL fReadNote);
HCHARSET GetJP_ISOControlCharset(void);
BOOL fCheckEncodeMenu(UINT uiCodePage, BOOL fReadNote);
UINT GetMapCP(UINT uiCodePage, BOOL fReadNote);

#endif // __MULTILANG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\mru.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (C) 1993-1998  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:     mru.h
//
//  PURPOSE:    
//

#pragma once

class CMRUList;

/////////////////////////////////////////////////////////////////////////////
// Types

// Flags
#define MRU_CACHEWRITE          0x0002
#define MRU_ANSI                0x0004
#define MRU_ORDERDIRTY          0x0008
#define MRU_LAZY                0x8000

/////////////////////////////////////////////////////////////////////////////
// class MRU List definition
//
class CMRUList
{
public:
    /////////////////////////////////////////////////////////////////////////
    // Construction and Initialization
    //
    CMRUList();
    ~CMRUList();

    /////////////////////////////////////////////////////////////////////////
    // public MRU List functions
    //
    BOOL CreateList(UINT uMaxEntries, UINT fFlags, LPCSTR pszSubKey);
    void FreeList(void);
    int  AddString(LPCSTR psz);
    int  RemoveString(LPCSTR psz);
    int  EnumList(int nItem, LPTSTR psz, UINT uLen);
    int  AddData(const void *pData, UINT cbData);
    int  FindData(const void *pData, UINT cbData, LPINT piSlot);
    BOOL CreateListLazy(UINT uMaxEntries, UINT fFlags, LPCSTR pszSubKey, const void *pData, UINT cbData, LPINT piSlot);

private:
    /////////////////////////////////////////////////////////////////////////
    // Utility Functions
    //
    void _GetIndexStrFromIndex(DWORD dwIndex, LPTSTR pszIndexStr, DWORD cchIndexStrSize)
    {
        wsprintf(pszIndexStr, TEXT("%d"), dwIndex);
    }

    int CDECL _IMemCmp(const void *pBuf1, const void *pBuf2, size_t cb);
    BOOL _IsSameData(BYTE FAR *pVal, const void FAR *pData, UINT cbData);
    LPDWORD _GetMRUValue(HKEY hkeySubKey, LPCTSTR pszRegValue);
    HRESULT _SetMRUValue(HKEY hkeySubKey, LPCTSTR pszRegValue, LPDWORD pData);
    BOOL _SetPtr(LPSTR * ppszCurrent, LPCSTR pszNew);


private:
    /////////////////////////////////////////////////////////////////////////
    // Class data
    //
    UINT                m_uMax;             // Maxiumum number of entries in the MRU list
    UINT                m_fFlags;           // Flags 
    HKEY                m_hKey;             // Reg key where we write
    LPSTR               m_pszSubKey;        // Sub key where the MRU data is stashed
    LPTSTR             *m_rgpszMRU;         // List of entries
    LPTSTR              m_pszOrder;         // Order array

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\oetag.h ===
/*
 *    o e t a g . h
 *    
 *    Purpose:
 *        Implements a DHTML behavior for the OE application object
 *
 *  History
 *      August '98: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
 */

#ifndef _OETAG_H
#define _OETAG_H

interface IAthenaBrowser;
interface IBodyObj2;

class COETag :
    public IElementBehavior,
    public IDatabaseNotify,
    public IImnAdviseAccount,
    public IDispatch,
    public IIdentityChangeNotify
{
public:
    COETag(IAthenaBrowser *pBrowser, IBodyObj2 *pFrontPage);
    virtual ~COETag();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IElementBehavior ***
    virtual HRESULT STDMETHODCALLTYPE Init(IElementBehaviorSite *pBehaviorSite);
    virtual HRESULT STDMETHODCALLTYPE Notify(LONG lEvent, VARIANT *pVar);
    virtual HRESULT STDMETHODCALLTYPE Detach(void) {return E_NOTIMPL;}

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // *** IIDatabaseNotify ***
    STDMETHODIMP OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB);

    // ImnAdviseAccount
    virtual HRESULT STDMETHODCALLTYPE AdviseAccount(DWORD dwAdviseType, ACTX *pAcctCtx);

    // *** IIdentityChangeNotify ***
    virtual HRESULT STDMETHODCALLTYPE QuerySwitchIdentities();
    virtual HRESULT STDMETHODCALLTYPE SwitchIdentities();
    virtual HRESULT STDMETHODCALLTYPE IdentityInformationChanged(DWORD dwType);

    HRESULT OnFrontPageClose();

private:
    ULONG                   m_cRef;
    IElementBehaviorSite    *m_pSite;
    DWORD                   m_dwAdvise;
    BOOL                    m_fDoneRegister;
    FOLDERID                m_idFolderInbox;
    IAthenaBrowser          *m_pBrowser;
    DWORD                   m_cTips;
    DWORD                   *m_rgidsTips;
    DWORD                   m_dwIdentCookie;
    IBodyObj2               *m_pFrontPage;
    ULONG                   m_ulMessengerTipStart, m_culMessengerTips;

    HRESULT _RegisterEvents(BOOL fRegister);
    HRESULT _FireEvent(DWORD idEvent);
    HRESULT _UpdateFolderInfo(BOOL fNotify);
    HRESULT _BuildTipTable();
    HRESULT _IsBuddyEnabled();
    HRESULT _IsMultiUserEnabled();
};

#endif // _OETAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\oleutil.cpp ===
/*
 *    o l e u t i l . c p p
 *    
 *    Purpose:
 *        OLE utilities
 *
 *  History
 *      Feb '97: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <resource.h>
#include <oleutil.h>
#include <mimeole.h>
#include <richedit.h>
#include <richole.h>

ASSERTDATA

#define HIMETRIC_PER_INCH       2540    // number HIMETRIC units per inch
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)



HRESULT HrGetDataStream(LPUNKNOWN pUnk, CLIPFORMAT cf, LPSTREAM *ppstm)
{
    LPDATAOBJECT            pDataObj=0;
    HRESULT                 hr;
    FORMATETC               fetc={cf, 0, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    STGMEDIUM               stgmed;

    ZeroMemory(&stgmed, sizeof(STGMEDIUM));

    if (!pUnk || !ppstm)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObj);
    if(FAILED(hr))
        goto error;

    hr=pDataObj->GetData(&fetc, &stgmed);
    if(FAILED(hr))
        goto error;

    Assert(stgmed.pstm);
    *ppstm = stgmed.pstm;
    (*ppstm)->AddRef();

    // addref the pUnk as it will be release in releasestgmed
    if(stgmed.pUnkForRelease)
        stgmed.pUnkForRelease->AddRef();
    ReleaseStgMedium(&stgmed);

error:
    ReleaseObj(pDataObj);
    return hr;
}


HRESULT HrInitNew(LPUNKNOWN pUnk)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->InitNew();

error:
    ReleaseObj(ppsi);
    return hr;
}


HRESULT HrIPersistFileSave(LPUNKNOWN pUnk, LPSTR pszFile)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszFile = NULL;

    Assert(pUnk);
    Assert(lstrlen(pszFile) <= MAX_PATH);

    if ((NULL == pszFile) || (0 == *pszFile))
        return E_INVALIDARG;

    IF_NULLEXIT(pwszFile = PszToUnicode(CP_ACP, pszFile));

    hr = HrIPersistFileSaveW(pUnk, pwszFile);

exit:
    MemFree(pwszFile);

    return hr;
}

HRESULT HrIPersistFileSaveW(LPUNKNOWN pUnk, LPWSTR pwszFile)
{
    HRESULT         hr;
    LPPERSISTFILE   ppf=0;

    Assert(pUnk);
    Assert(lstrlenW(pwszFile) <= MAX_PATH);

    if ((NULL == pwszFile) || (NULL == *pwszFile))
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto error;

    hr=ppf->Save(pwszFile, FALSE);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(ppf);
    return hr;
}


HRESULT HrIPersistFileLoad(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    LPWSTR lpwszFile;
    HRESULT hr = S_OK;

    if (lpszFile == NULL || *lpszFile == NULL)
        return E_INVALIDARG;

    IF_NULLEXIT(lpwszFile = PszToUnicode(CP_ACP, lpszFile));

    hr = HrIPersistFileLoadW(pUnk, lpwszFile);

exit:
    MemFree(lpwszFile);

    return hr;
}

HRESULT HrIPersistFileLoadW(LPUNKNOWN pUnk, LPWSTR lpwszFile)
{
    HRESULT         hr;
    LPPERSISTFILE   ppf=0;
    WCHAR           szFileW[MAX_PATH];

    Assert(lstrlenW(lpwszFile) <= MAX_PATH);

    if (lpwszFile == NULL || *lpwszFile == NULL)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto error;

    hr=ppf->Load(lpwszFile, STGM_READ|STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(ppf);
    return hr;
}

#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN Debug Code
//

void DbgPrintInterface(REFIID riid, char *szPrefix, int iLevel)
{
    LPOLESTR    pszW=0;
    char        szGuid[MAX_PATH];
    char        szTmp[MAX_PATH];
    char        szOut[MAX_PATH];
    LONG        cb=MAX_PATH;
    HKEY        hk=0;

    AssertSz(szPrefix, "ButtMunch! Atleast pass a null string!");

    StringFromIID(riid, &pszW);

    WideCharToMultiByte(CP_ACP, 0, pszW, -1, szGuid, MAX_PATH, NULL, NULL);
        
    lstrcpy(szTmp, "SOFTWARE\\Classes\\Interface\\");
    lstrcat(szTmp, szGuid);
    
    if((RegOpenKey(HKEY_LOCAL_MACHINE, szTmp, &hk)==ERROR_SUCCESS) &&
        RegQueryValue(hk, NULL, szTmp, &cb)==ERROR_SUCCESS)
        {
        wsprintf(szOut, "%s: {%s}", szPrefix, szTmp);
        }
    else    
        {
        wsprintf(szOut, "%s: [notfound] %s", szPrefix, szGuid);
        }

    DOUTL(iLevel, szOut);

    if(hk)
        RegCloseKey(hk);
    if(pszW)
        CoTaskMemFree(pszW);
}

//
//  END Debug Code
//
/////////////////////////////////////////////////////////////////////////////
#endif  // DEBUG



// OLE Utilities:
void XformSizeInPixelsToHimetric(HDC hDC, LPSIZEL lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    BOOL    fSystemDC=FALSE;

    if(!hDC||!GetDeviceCaps(hDC, LOGPIXELSX))
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got pixel units, convert them to logical HIMETRIC along the display
    lpSizeInHiMetric->cx = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cx, iXppli);
    lpSizeInHiMetric->cy = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cy, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return;
}

void XformSizeInHimetricToPixels(   HDC hDC,
                                    LPSIZEL lpSizeInHiMetric,
                                    LPSIZEL lpSizeInPix)
{
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC ||
        GetDeviceCaps(hDC, LOGPIXELSX) == 0)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got logical HIMETRIC along the display, convert them to pixel units
    lpSizeInPix->cx = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric->cx, iXppli);
    lpSizeInPix->cy = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric->cy, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);
}


void DoNoteOleVerb(int iVerb)
{
    HWND            hwndRE=GetFocus();
    HRESULT         hr;
    POINT           pt;
    RECT            rc;
    REOBJECT        reobj={0};
    LPRICHEDITOLE   preole = NULL;

    if(!hwndRE)
        return;

    reobj.cbStruct = sizeof(REOBJECT);
    
    // ~~~~ Might be able to go off of the PHCI object tied to the RichEdit
    if(!SendMessage(hwndRE, EM_GETOLEINTERFACE, 0, (LPARAM) &preole))
        return;

    Assert(preole);

    AssertSz(SendMessage(hwndRE, EM_SELECTIONTYPE, 0, 0) == SEL_OBJECT, "MORE THAN ONE OLEOBJECT SELECTED, How did we get here??");

    hr=preole->GetObject(REO_IOB_SELECTION, &reobj, REO_GETOBJ_POLEOBJ|REO_GETOBJ_POLESITE);
    if(FAILED(hr))
        goto Cleanup;

    SendMessage(hwndRE, EM_POSFROMCHAR, (WPARAM) &pt, reobj.cp);

    // BUGBUG: $brettm is this really necessary???
    XformSizeInHimetricToPixels(NULL, &reobj.sizel, &reobj.sizel);

    rc.left = rc.top = 0;
    rc.right = (INT) reobj.sizel.cx;
    rc.bottom = (INT) reobj.sizel.cy;
    OffsetRect(&rc, pt.x, pt.y);

    hr= reobj.poleobj->DoVerb(iVerb, NULL, reobj.polesite, 0, hwndRE, &rc);

Cleanup:
    ReleaseObj(reobj.poleobj);
    ReleaseObj(reobj.polesite);
    ReleaseObj(preole);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\oleutil.h ===
/*
 *    o l e u t i l . h
 *    
 *    Purpose:
 *        OLE utilities
 *
 *  History
 *      Feb '97: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _OLEUTIL_H
#define _OLEUTIL_H

HRESULT HrInitNew(LPUNKNOWN pUnk);
HRESULT HrGetDataStream(LPUNKNOWN pUnk, CLIPFORMAT cf, LPSTREAM *ppstm);
HRESULT HrIPersistStreamLoad(LPUNKNOWN pUnk, LPSTREAM pstm);

HRESULT HrIPersistFileSave(LPUNKNOWN pUnk, LPSTR pszFile);
HRESULT HrIPersistFileSaveW(LPUNKNOWN pUnk, LPWSTR pwszFile);
HRESULT HrIPersistFileLoad(LPUNKNOWN pUnk, LPSTR pszFile);
HRESULT HrIPersistFileLoadW(LPUNKNOWN pUnk, LPWSTR pwszFile);

void XformSizeInHimetricToPixels(HDC hDC,LPSIZEL lpSizeInHiMetric,LPSIZEL lpSizeInPix);
void XformSizeInPixelsToHimetric(HDC hDC, LPSIZEL lpSizeInPix, LPSIZEL lpSizeInHiMetric);
void DoNoteOleVerb(int iVerb);

#ifdef DEBUG
void DbgPrintInterface(REFIID riid, char *szPrefix, int iLevel);
#else
#define DbgPrintInterface       1 ? (void)0 : (void)
#endif

#endif //_OLEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\oetag.cpp ===
/*
 *    o e t a g . c p p
 *    
 *    Purpose:
 *        Implements a DHTML behavior for the OE application object
 *
 *  History
 *      August '98: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
 */

#include <pch.hxx>
#include <resource.h>
#include "browser.h"
#include <mshtml.h>
#include <instance.h>
#include "oetag.h"
#include "htmlstr.h"
#include "storutil.h"
#include "multiusr.h"
#include "ibodyobj.h"
#include "bllist.h"
#include "menuutil.h"

#define DISPID_FRONTPAGE_TIP                65301
#define DISPID_FRONTPAGE_NEWS_ACCOUNTS      65302
#define DISPID_FRONTPAGE_MAIL_ACCOUNTS      65303
#define DISPID_FRONTPAGE_USER_NAME          65304
#define DISPID_FRONTPAGE_UNREAD_MAIL        65305
#define DISPID_FRONTPAGE_TIP_ARRAY          65306
#define DISPID_FRONTPAGE_TIP_COUNT          65307
#define DISPID_FRONTPAGE_GOTO_INBOX         65308
#define DISPID_FRONTPAGE_LOAD_COMPLETE      65309
#define DISPID_FRONTPAGE_MULTIUSER_ENABLED  65310
#define DISPID_FRONTPAGE_HOTMAIL_ENABLED    65311
#define DISPID_FRONTPAGE_USER_COUNT         65312

#define EVENTID_NEW_MAIL                    65500
#define EVENTID_ACCOUNT_CHANGE              65501

static const struct 
{
    LPCWSTR pszCmd;
    DISPID  dispid;
} s_rgDispIdLookup[] = 
{
    { L"optShowTips",       DISPID_FRONTPAGE_TIP },
    { L"newsAccounts",      DISPID_FRONTPAGE_NEWS_ACCOUNTS  },
    { L"mailAccounts",      DISPID_FRONTPAGE_MAIL_ACCOUNTS  },
    { L"userName",          DISPID_FRONTPAGE_USER_NAME  },
    { L"unreadMail",        DISPID_FRONTPAGE_UNREAD_MAIL},
    { L"tips",              DISPID_FRONTPAGE_TIP_ARRAY}, 
    { L"tipCount",          DISPID_FRONTPAGE_TIP_COUNT},
    { L"optGotoInbox",      DISPID_FRONTPAGE_GOTO_INBOX},
    { L"loadComplete",      DISPID_FRONTPAGE_LOAD_COMPLETE},
    { L"multiuserEnabled",  DISPID_FRONTPAGE_MULTIUSER_ENABLED},
    { L"hotmailEnabled",    DISPID_FRONTPAGE_HOTMAIL_ENABLED},
    { L"userCount",         DISPID_FRONTPAGE_USER_COUNT},
    
};


COETag::COETag(IAthenaBrowser *pBrowser, IBodyObj2 *pFrontPage)
{
    m_cRef = 1;
    m_pSite = NULL;
    m_dwAdvise = NULL;
    m_fDoneRegister = FALSE;
    m_idFolderInbox = FOLDERID_INVALID;
    m_cTips=0;
    m_rgidsTips=NULL;
    m_dwIdentCookie = 0;

    Assert (pBrowser);
    m_pBrowser = pBrowser;
    pBrowser->AddRef();
    m_pFrontPage = pFrontPage;
    pFrontPage->AddRef();
}

COETag::~COETag()
{
    SafeMemFree(m_rgidsTips);
    SafeRelease(m_pSite);
    SafeRelease(m_pBrowser);
    SafeRelease(m_pFrontPage);
}


HRESULT COETag::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    TraceCall("CBody::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (IUnknown *)(IElementBehavior *)this;
    else if (IsEqualIID(riid, IID_IElementBehavior))
        *lplpObj = (IElementBehavior *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (IDispatch*) this;
    else if (IsEqualIID(riid, IID_IIdentityChangeNotify))
        *lplpObj = (IIdentityChangeNotify *) this;
    else
        return E_NOINTERFACE;
        
    AddRef();
    return S_OK;
}

ULONG COETag::AddRef()
{
    return ++m_cRef;
}

ULONG COETag::Release()
{
    if (--m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// *** IElementBehavior ***
HRESULT COETag::Init(IElementBehaviorSite *pBehaviorSite)
{
    IElementBehaviorSiteOM  *pSiteOM;
    LONG                    lCookie;

    ReplaceInterface(m_pSite, pBehaviorSite);

    if (pBehaviorSite && 
        pBehaviorSite->QueryInterface(IID_IElementBehaviorSiteOM, (LPVOID *)&pSiteOM)==S_OK)
    {
        pSiteOM->RegisterEvent((LPWSTR)c_bstr_OnNewMail, 0, &lCookie);
        pSiteOM->RegisterEvent((LPWSTR)c_bstr_OnAccountChange, 0, &lCookie);
        pSiteOM->Release();
    }
    _UpdateFolderInfo(FALSE);
    _RegisterEvents(TRUE);
    return S_OK;
}

HRESULT COETag::_FireEvent(DWORD idEvent)
{
    IElementBehaviorSiteOM  *pSiteOM;
    IHTMLEventObj           *pEvent;
    LONG                    lCookie;

    if (m_pSite && 
        m_pSite->QueryInterface(IID_IElementBehaviorSiteOM, (LPVOID *)&pSiteOM)==S_OK)
    {
        if (pSiteOM->CreateEventObject(&pEvent)==S_OK)
        {
            pSiteOM->GetEventCookie((LPWSTR)(idEvent == EVENTID_NEW_MAIL ? c_bstr_OnNewMail:c_bstr_OnAccountChange), &lCookie);
            pSiteOM->FireEvent(lCookie, pEvent);
            pEvent->Release();
        }
        pSiteOM->Release();
    }
    return S_OK;
}


HRESULT COETag::Notify(LONG lEvent, VARIANT *pVar)
{
    return S_OK;
}

// *** IDispatch ***
HRESULT COETag::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

HRESULT COETag::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

HRESULT COETag::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
    if (cNames == 1)
    {
        for (int i = 0; i < ARRAYSIZE(s_rgDispIdLookup); i++)
        {
            if (StrCmpIW(s_rgDispIdLookup[i].pszCmd, rgszNames[0])==0)
            {
                rgDispId[0] = s_rgDispIdLookup[i].dispid;
                return S_OK;
            }
        }
    }
    return DISP_E_UNKNOWNNAME;
}

HRESULT COETag::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    IImnEnumAccounts    *pEnum;
    IImnAccount         *pAccount;
    TCHAR               szName[CCHMAX_DISPLAY_NAME];
    LPCSTR              pszIdentityName;
    FOLDERINFO          Folder;
    TCHAR               rgch[CCHMAX_STRINGRES];
    DWORD               cTip;

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (!pVarResult)
            return E_INVALIDARG;

        switch (dispIdMember)
        {
        case DISPID_FRONTPAGE_TIP_COUNT:
            if (m_cTips == 0)
                _BuildTipTable();

            pVarResult->vt = VT_I4;
            pVarResult->lVal = m_cTips;
            return S_OK;

        case DISPID_FRONTPAGE_TIP_ARRAY:
            if (pDispParams && pDispParams->cArgs == 1 &&
                pDispParams->rgvarg && 
                pDispParams->rgvarg[0].vt == VT_I4)
            {
                if (m_cTips == 0)
                    _BuildTipTable();

                if (m_rgidsTips == NULL || m_cTips == 0)
                    return E_OUTOFMEMORY;

                cTip = pDispParams->rgvarg[0].lVal;
                if (cTip >= m_cTips)
                    return DISP_E_BADINDEX;

                if (!LoadString(g_hLocRes, m_rgidsTips[cTip], rgch, ARRAYSIZE(rgch)))
                    return E_OUTOFMEMORY;

                if (m_culMessengerTips && (cTip>=m_ulMessengerTipStart) && (cTip<=(m_ulMessengerTipStart+m_culMessengerTips)))
                    MenuUtil_BuildMessengerString(rgch);

                if (HrLPSZToBSTR(rgch, &pVarResult->bstrVal)!=S_OK)
                    return E_OUTOFMEMORY;

                pVarResult->vt = VT_BSTR;
                return S_OK;
            }
            return E_INVALIDARG;

        case DISPID_FRONTPAGE_USER_COUNT:
            pVarResult->vt = VT_I4;
            pVarResult->lVal = MU_CountUsers();
            return S_OK;

        case DISPID_FRONTPAGE_HOTMAIL_ENABLED:
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = HideHotmail() ? VARIANT_FALSE : VARIANT_TRUE;
            return S_OK;

        case DISPID_FRONTPAGE_MULTIUSER_ENABLED:
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = (_IsMultiUserEnabled() == S_OK)? VARIANT_TRUE : VARIANT_FALSE;
            return S_OK;

        case DISPID_FRONTPAGE_GOTO_INBOX:
            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = DwGetOption(OPT_LAUNCH_INBOX)? VARIANT_TRUE : VARIANT_FALSE;
            return S_OK;
        
        case DISPID_FRONTPAGE_TIP:
            BOOL    fTip;

            fTip = TRUE;
            if (m_pBrowser)
                m_pBrowser->GetViewLayout(DISPID_MSGVIEW_TIPOFTHEDAY, 0, &fTip, 0, 0);

            pVarResult->vt = VT_BOOL;
            pVarResult->boolVal = fTip ? VARIANT_TRUE : VARIANT_FALSE;
            return S_OK;

        case DISPID_FRONTPAGE_NEWS_ACCOUNTS:
        case DISPID_FRONTPAGE_MAIL_ACCOUNTS:
            pVarResult->lVal = 0;
            pVarResult->vt = VT_I4;
            
            if (g_pAcctMan->Enumerate(dispIdMember == DISPID_FRONTPAGE_MAIL_ACCOUNTS ? SRV_MAIL:SRV_NNTP, &pEnum)==S_OK)
            {
                pEnum->GetCount((ULONG *)&pVarResult->lVal);
                pEnum->Release();
            }
            return S_OK;

        case DISPID_FRONTPAGE_USER_NAME:
            pVarResult->vt = VT_BSTR;
            pVarResult->bstrVal = NULL;
            GetOEUserName(&pVarResult->bstrVal);
            return S_OK;
        
        case DISPID_FRONTPAGE_UNREAD_MAIL:
            pVarResult->vt = VT_I4;
            pVarResult->lVal = 0;

            if (SUCCEEDED(g_pStore->GetFolderInfo(m_idFolderInbox, &Folder)))
            {
                pVarResult->lVal = Folder.cUnread;
                g_pStore->FreeRecord(&Folder);
            }
            return S_OK;

        }

    }
    else if (wFlags & DISPATCH_PROPERTYPUT)
    {
        switch (dispIdMember)
        {
        case DISPID_FRONTPAGE_TIP:
            if (pDispParams && pDispParams->cArgs == 1 &&
                pDispParams->rgvarg && 
                pDispParams->rgvarg[0].vt == VT_BOOL && 
                m_pBrowser)
            {
                m_pBrowser->SetViewLayout(DISPID_MSGVIEW_TIPOFTHEDAY, LAYOUT_POS_NA, pDispParams->rgvarg[0].boolVal == VARIANT_TRUE, 0, 0);
                return S_OK;
            }
            else
                return E_INVALIDARG;

        case DISPID_FRONTPAGE_GOTO_INBOX:
            if (pDispParams && pDispParams->cArgs == 1 &&
                pDispParams->rgvarg && 
                pDispParams->rgvarg[0].vt == VT_BOOL)
            {
                SetDwOption(OPT_LAUNCH_INBOX, pDispParams->rgvarg[0].boolVal == VARIANT_TRUE, 0, 0);
                return S_OK;            
            }
            else
                return E_INVALIDARG;
        }
    
    }
    else if (wFlags & DISPATCH_METHOD)
    {
        if (dispIdMember == DISPID_FRONTPAGE_LOAD_COMPLETE)
        {
            // front-page has completed loading, we can now show the front-page
            m_pFrontPage->HrShow(TRUE);
            return S_OK;
        }
    }    
    return DISP_E_MEMBERNOTFOUND;
}

HRESULT COETag::OnTransaction(HTRANSACTION hTransaction, DWORD_PTR dwCookie, IDatabase *pDB)
{
    TRANSACTIONTYPE     tyTransaction;
    FOLDERINFO          Folder1={0};
    FOLDERINFO          Folder2={0};
    ORDINALLIST         Ordinals;
    INDEXORDINAL        iIndex;
    
    // Walk Through Notifications
    while (hTransaction)
    {
        if(FAILED(pDB->GetTransaction(&hTransaction, &tyTransaction, &Folder1, &Folder2, &iIndex, &Ordinals)))
            break;

        // the the inbox folders get an unread count change, fire the notification
        if (TRANSACTION_UPDATE == tyTransaction &&
            Folder1.idFolder == m_idFolderInbox &&
            Folder1.cUnread != Folder2.cUnread)
            _FireEvent(EVENTID_NEW_MAIL);
    }
    pDB->FreeRecord(&Folder1);
    pDB->FreeRecord(&Folder2);
    return S_OK;
}


HRESULT COETag::_RegisterEvents(BOOL fRegister)
{
    if (g_pStore == NULL || g_pAcctMan == NULL)
        return TraceResult(E_FAIL);

    if (fRegister)
    {
        if (!m_fDoneRegister)
        {
            g_pStore->RegisterNotify(IINDEX_SUBSCRIBED, REGISTER_NOTIFY_NOADDREF, 0, (IDatabaseNotify *)this);
            g_pAcctMan->Advise((IImnAdviseAccount *)this, &m_dwAdvise);
            SideAssert(SUCCEEDED(MU_RegisterIdentityNotifier((IUnknown *)(IIdentityChangeNotify *)this, &m_dwIdentCookie)));
            m_fDoneRegister = TRUE;
        }
    }
    else
    {
        if (m_fDoneRegister)
        {
            g_pStore->UnregisterNotify((IDatabaseNotify *)this);
            g_pAcctMan->Unadvise(m_dwAdvise);
            if (m_dwIdentCookie != 0)
            {
                MU_UnregisterIdentityNotifier(m_dwIdentCookie);
                m_dwIdentCookie = 0;
            }
            m_fDoneRegister = FALSE;
        }
    }
    return S_OK;
}


HRESULT COETag::OnFrontPageClose()
{
    _RegisterEvents(FALSE);
    SafeRelease(m_pBrowser);
    return S_OK;
}



HRESULT COETag::_UpdateFolderInfo(BOOL fNotify)
{
    FOLDERID            idStore;
    FOLDERINFO          Folder;

    // Find store ID of default mail account
    if (FAILED(GetDefaultServerId(ACCT_MAIL, &idStore)))
        idStore = FOLDERID_LOCAL_STORE;

    if (g_pStore && 
        SUCCEEDED(g_pStore->GetSpecialFolderInfo(idStore, FOLDER_INBOX, &Folder)))
    {
        // if inbox changes, fire newmail notification
        if (m_idFolderInbox != Folder.idFolder)
        {
            m_idFolderInbox = Folder.idFolder;
            if (fNotify)
                _FireEvent(EVENTID_NEW_MAIL);
        }
        g_pStore->FreeRecord(&Folder);
    }
    else
    {
        // might have selected an IMAP folder that we have not downloaded the
        // folder-list for
        m_idFolderInbox = FOLDERID_INVALID;
        _FireEvent(EVENTID_NEW_MAIL);
    }

    return S_OK;
}


HRESULT COETag::AdviseAccount(DWORD dwAdviseType, ACTX *pAcctCtx)
{
    switch (dwAdviseType)
    {
    case AN_DEFAULT_CHANGED:
        // call update folder info incase the default inbox changed
        // and fire and account update to the page
        _UpdateFolderInfo(TRUE);
        break;

    case AN_ACCOUNT_DELETED:        // account removed
        _UpdateFolderInfo(TRUE);    // if deleting last IMAP account, we don't get a def-change

        // fall thro'
    case AN_ACCOUNT_ADDED:          // account added
    case AN_ACCOUNT_CHANGED:        // account changed - maybe update name
        // fire and account-notify update to the page
        _FireEvent(EVENTID_ACCOUNT_CHANGE);
        break;
    }
    return S_OK;
}



#define TIPF_GENERAL       0x01
#define TIPF_NEWS          0x02
#define TIPF_IMAP          0x04
#define TIPF_BUDDY         0x08
#define TIPF_HOTMAIL       0x10
#define TIPF_NO_JUNKMAIL   0x20
#define TIPF_NO_IDENTITIES 0x40

HRESULT COETag::_BuildTipTable()
{
    DWORD               dwTips=0,
                        i;
    ULONG               cAccounts=0;
    LPDWORD             pidsTip;
    IImnEnumAccounts    *pEnum;

    m_cTips = 0;
    m_ulMessengerTipStart = 0;
    m_culMessengerTips = 0;
    SafeMemFree(m_rgidsTips);

    if (g_dwAthenaMode & MODE_NEWSONLY)
        dwTips = TIPF_NEWS;
    else
    {
        dwTips = TIPF_GENERAL|TIPF_NEWS;

        if (0 == (g_dwAthenaMode & MODE_JUNKMAIL))
            dwTips |= TIPF_NO_JUNKMAIL;

        // check if identities are enabled
        if (_IsMultiUserEnabled() == S_FALSE)
            dwTips |= TIPF_NO_IDENTITIES;

        if (g_pAcctMan->Enumerate(SRV_IMAP, &pEnum)==S_OK)
        {
            if (pEnum->GetCount(&cAccounts) && cAccounts)
                dwTips |= TIPF_IMAP;

            pEnum->Release();
        }

        // if hotmail is not disabled by policy, and http accounts then show tip
        if (!HideHotmail() && 
            g_pAcctMan->Enumerate(SRV_HTTPMAIL, &pEnum)==S_OK)
        {
            if (SUCCEEDED(pEnum->GetCount(&cAccounts)) && cAccounts)
                dwTips |= TIPF_HOTMAIL;

            pEnum->Release();
        }

        // test to see if buddylist is installed
        if (_IsBuddyEnabled() == S_OK)
            dwTips |= TIPF_BUDDY;
    }
    
    // allocate the tip-array
    if (dwTips & TIPF_GENERAL)
    {
        m_cTips += IDS_TIPS_GENERAL_LAST - IDS_TIPS_GENERAL_FIRST + 1;

        if (dwTips & TIPF_NO_JUNKMAIL)
            m_cTips-=2;

        // some of the tips are for identities... need to remove them
        if (dwTips & TIPF_NO_IDENTITIES)
            m_cTips-=4;
    }

    if (dwTips & TIPF_NEWS)
        m_cTips += IDS_TIPS_NEWS_LAST - IDS_TIPS_NEWS_FIRST + 1;

    if (dwTips & TIPF_IMAP)
        m_cTips += IDS_TIPS_IMAP_LAST - IDS_TIPS_IMAP_FIRST + 1;

    if (dwTips & TIPF_BUDDY)
        m_cTips += IDS_TIPS_MMS_LAST - IDS_TIPS_MMS_FIRST + 1;

    if (dwTips & TIPF_HOTMAIL)
    {
        m_cTips += IDS_TIPS_HM_LAST - IDS_TIPS_HM_FIRST + 1;

        // some of the tips are for identities... need to remove them
        if (dwTips & TIPF_NO_IDENTITIES)
            m_cTips-=1;
    }

    if (!MemAlloc((LPVOID *)&m_rgidsTips, sizeof(DWORD) * m_cTips))
    {
        m_cTips = 0;
        return E_OUTOFMEMORY;
    }

    pidsTip = m_rgidsTips;
    // copy the tips into the array
    if (dwTips & TIPF_GENERAL)
    {
        for (i=IDS_TIPS_GENERAL_FIRST; i<IDS_TIPS_GENERAL_LAST+1; i++, pidsTip++)
        {
            if ((((IDS_TIPS_GENERAL_26 == i) || (IDS_TIPS_GENERAL_29 == i)) 
                    && (dwTips & TIPF_NO_JUNKMAIL)) ||
                ((dwTips & TIPF_NO_IDENTITIES) && (IDS_TIPS_GENERAL_41 == i)))
            {
                pidsTip--;
                continue;
            }
            if ((dwTips & TIPF_NO_IDENTITIES) && (IDS_TIPS_GENERAL_2 == i))
            {
                i+=2;
                pidsTip--;
                continue;
            }

            *pidsTip = i;
        }
    }
        
    if (dwTips & TIPF_NEWS)
    {
        for (i=IDS_TIPS_NEWS_FIRST; i<IDS_TIPS_NEWS_LAST+1; i++, pidsTip++)
            *pidsTip = i;
    }

    if (dwTips & TIPF_IMAP)
    {
        for (i=IDS_TIPS_IMAP_FIRST; i<IDS_TIPS_IMAP_LAST+1; i++, pidsTip++)
            *pidsTip = i;
    }

    if (dwTips & TIPF_BUDDY)
    {
        m_ulMessengerTipStart = (int)(pidsTip - m_rgidsTips);        

        for (i=IDS_TIPS_MMS_FIRST; i<IDS_TIPS_MMS_LAST+1; i++, pidsTip++, m_culMessengerTips++)
            *pidsTip = i;        
    }

    if (dwTips & TIPF_HOTMAIL)
    {
        for (i=IDS_TIPS_HM_FIRST; i<IDS_TIPS_HM_LAST+1; i++, pidsTip++)
        {
            if ((dwTips & TIPF_NO_IDENTITIES) && (IDS_TIPS_HM_4 == i))
            {
                pidsTip--;
                continue;
            }
            *pidsTip = i;
        }
    }

    Assert ((DWORD)(pidsTip - m_rgidsTips) == m_cTips);
    return S_OK;
}

HRESULT COETag::QuerySwitchIdentities()
{
    return S_OK;
}

HRESULT COETag::SwitchIdentities()
{
    return S_OK;
}

HRESULT COETag::IdentityInformationChanged(DWORD dwType)
{
    // Refresh for adds, delete, or current identity changed
    // since adding could require that the name show up,
    // deleteing could require that it go away and changed 
    // should be reflected immediately.
    if (dwType != IIC_IDENTITY_CHANGED)
    {
        MU_IdentityChanged();
        _FireEvent(EVENTID_ACCOUNT_CHANGE);
    }
    return S_OK;
}

HRESULT COETag::_IsBuddyEnabled()
{
    CMsgrList *pList;
    
    // YURI says this is the best way to see if buddy is on the
    // machine or not
    pList = OE_OpenMsgrList();
    if (pList)
    {
        OE_CloseMsgrList(pList);
        return S_OK;
    }
    return S_FALSE;
}

HRESULT COETag::_IsMultiUserEnabled()
{
    return MU_IdentitiesDisabled() ? S_FALSE : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\optbckt.h ===
#ifndef _INC_OPTBCKT_H
#define _INC_OPTBCKT_H

#include <msoeopt.h>

class CPropertyBucket;

#define CKEYMAX     4

class COptionBucket : public IOptionBucketEx
    {
    public:
        // ----------------------------------------------------------------------------
        // Construction
        // ----------------------------------------------------------------------------
        COptionBucket(void);
        ~COptionBucket(void);

        // -------------------------------------------------------------------
        // IUnknown Members
        // -------------------------------------------------------------------
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // -------------------------------------------------------------------
        // IPropertyBucket Members
        // -------------------------------------------------------------------
        STDMETHODIMP GetProperty(LPCSTR pszProp, LPPROPVARIANT pProp, DWORD dwReserved);
        STDMETHODIMP SetProperty(LPCSTR pszProp, LPCPROPVARIANT pProp, DWORD dwReserved);

        // -------------------------------------------------------------------
        // IOptionBucket Members
        // -------------------------------------------------------------------
        STDMETHODIMP ValidateProperty(PROPID id, LPCPROPVARIANT pProp, DWORD dwReserved);
        STDMETHODIMP GetPropertyDefault(PROPID id, LPPROPVARIANT pProp, DWORD dwReserved);
        STDMETHODIMP GetPropertyInfo(PROPID id, PROPINFO *pInfo, DWORD dwReserved);

        // -------------------------------------------------------------------
        // IOptionBucketEx Members
        // -------------------------------------------------------------------
        STDMETHODIMP Initialize(LPCOPTBCKTINIT pInit);
        STDMETHODIMP ISetProperty(HWND hwnd, LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwFlags);
        STDMETHODIMP SetNotification(IOptionBucketNotify *pNotify);
        STDMETHODIMP EnableNotification(BOOL fEnable);

        STDMETHODIMP_(LONG) GetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD *ptype, LPBYTE pb, DWORD *pcb);
        STDMETHODIMP_(LONG) SetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD type, LPBYTE pb, DWORD cb);

    private:
        LONG                m_cRef;
        CPropertyBucket    *m_pProp;
        IOptionBucketNotify *m_pNotify;
        BOOL                m_fNotify;
        PROPID              m_idNotify;

        LPCOPTIONINFO       m_rgInfo;
        int                 m_cInfo;
        
        HKEY                m_hkey;
        LPSTR               m_pszRegKeyBase;

        LPSTR               m_rgpszRegKey[CKEYMAX];
        int                 m_cpszRegKey;
        
        LPCOPTIONINFO GetOptionInfo(LPCSTR pszProp);
    };

#endif // _INC_OPTBCKT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\mailnews\common\optbckt.cpp ===
#include <pch.hxx>
#include <shlwapi.h>
#include <shlwapip.h>
#include "propbckt.h"
#include "optbckt.h"
#include "demand.h"

MSOEACCTAPI CreateOptionBucketEx(IOptionBucketEx **ppOptBckt)
{
    COptionBucket *pBckt;
    
    Assert(ppOptBckt != NULL);
    
    pBckt = new COptionBucket;
    
    *ppOptBckt = (IOptionBucketEx *)pBckt;
    
    return(pBckt == NULL ? E_OUTOFMEMORY : S_OK);
}

COptionBucket::COptionBucket(void)
{
    m_cRef = 1;
    m_pProp = NULL;
    m_pNotify = NULL;
    m_fNotify = TRUE;
    m_idNotify = 0;
    
    m_rgInfo = NULL;
    m_cInfo = 0;
    
    m_cpszRegKey = 0;
    
    m_pszRegKeyBase = NULL;
}

COptionBucket::~COptionBucket(void)
{
    int i;
    
    if (m_pProp != NULL)
        m_pProp->Release();
    if (m_pNotify != NULL)
        m_pNotify->Release();
    
    Assert(m_cpszRegKey <= CKEYMAX);
    for (i = 0; i < m_cpszRegKey; i++)
        MemFree(m_rgpszRegKey[i]);
    
    if (m_pszRegKeyBase != NULL)
        MemFree(m_pszRegKeyBase);
}

STDMETHODIMP COptionBucket::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (ppv == NULL)
        return(E_INVALIDARG);
    
    if (IID_IUnknown == riid)
    {
        *ppv = (IUnknown *)this;
    }
    else if (IID_IOptionBucketEx == riid)
    {
        *ppv = (IOptionBucketEx *)this;
    }
    else if (IID_IOptionBucket == riid)
    {
        *ppv = (IOptionBucket *)this;
    }
    else if (IID_IPropertyBucket == riid)
    {
        *ppv = (IPropertyBucket *)this;
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
    
    ((IUnknown *)*ppv)->AddRef();
    
    return(S_OK);
}

STDMETHODIMP_(ULONG) COptionBucket::AddRef(void)
{
    return((ULONG)InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) COptionBucket::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return((ULONG)cRef);
}

#define REG_INVALID     0xffffffff

DWORD RegTypeFromVarType(VARTYPE vt)
{
    DWORD type;

    switch (vt)
    {
        case VT_UI4:
            type = REG_DWORD;
            break;

        case VT_LPSTR:
        case VT_LPWSTR:
            type = REG_SZ;
            break;

        case VT_BLOB:
            type = REG_BINARY;
            break;

        default:
            Assert(FALSE);
            type = REG_INVALID;
            break;
    }

    return(type);
}

STDMETHODIMP COptionBucket::GetProperty(LPCSTR pszProp, LPPROPVARIANT pVar, DWORD dwReserved)
{
    HRESULT         hr;
    LPCOPTIONINFO   pInfo;
    DWORD           cb, 
                    type = REG_INVALID, 
                    dw;
    LPBYTE          pbT = NULL;
    LPCSTR          pszKey, 
                    pszValue;
    LPWSTR          pwszValue = NULL;
    HKEY            hkey = 0;
    BOOL            fSucceeded = FALSE;
    
    if (pszProp == NULL || pVar == NULL || dwReserved != 0)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    Assert(m_pProp != NULL);
    
    hr = m_pProp->GetProperty(pszProp, pVar, dwReserved);
    if (hr == E_PROP_NOT_FOUND) // the property hasn't been set yet
    {
        hr = S_OK;
        pbT = NULL;
        pInfo = NULL;
        
        pInfo = GetOptionInfo(pszProp);
        if (pInfo == NULL)
            IF_FAILEXIT(hr = E_PROP_NOT_FOUND);

        Assert(pInfo->iszRegKey < m_cpszRegKey);
#pragma prefast(enable:11, "noise")
        pszKey = m_rgpszRegKey[pInfo->iszRegKey];
        pszValue = pInfo->pszRegValue;

        if (pszValue && (ERROR_SUCCESS == RegOpenKeyEx(m_hkey, pszKey, 0, KEY_READ, &hkey)))
        {
            if (VT_LPWSTR == pInfo->vt)
            {
#pragma prefast(enable:11, "noise")
                IF_NULLEXIT(pwszValue = PszToUnicode(CP_ACP, pszValue));
                if (ERROR_SUCCESS == RegQueryValueExWrapW(hkey, pwszValue, NULL, &type, NULL, &cb))
                {
                    Assert(cb > 0);
                    IF_NULLEXIT(MemAlloc((void **)&pbT, cb));
                    fSucceeded = (ERROR_SUCCESS == RegQueryValueExWrapW(hkey, pwszValue, NULL, &type, pbT, &cb));
                }
            }
            else
            {
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, pszValue, NULL, &type, NULL, &cb))
                {
                    Assert(cb > 0);
                    IF_NULLEXIT(MemAlloc((void **)&pbT, cb));
                    fSucceeded = (ERROR_SUCCESS == RegQueryValueEx(hkey, pszValue, NULL, &type, pbT, &cb));
                }
            }
            
            if (fSucceeded)
            {
                if (pInfo != NULL && pInfo->vt == VT_UI4 && type == REG_BINARY)
                {
                    // values set via the INF file may have type REG_BINARY instead of REG_DWORD
                    // but we need them to be REG_DWORD. the next time the value is set in the registry
                    // it will be set as REG_DWORD and everything will be cool from that point on...
                    Assert(cb >= 4);
                    pVar->vt = VT_UI4;
                }
                else
                {
                    // Either we didn't find the entry, or the regtypes match.
                    Assert(type == RegTypeFromVarType(pInfo->vt));
                    pVar->vt = pInfo->vt;
                }
                
                if (pVar->vt == VT_ILLEGAL)
                    IF_FAILEXIT(hr = E_INVALID_PROP_TYPE);
            }
            else if (pInfo) // the property isn't set in the registry yet so grab default
            {
                IF_FAILEXIT(hr = GetPropertyDefault(SzToPropId(pszProp), pVar, dwReserved));
                goto exit;
            }
        }

        if (!fSucceeded)
        {
            hr = E_PROP_NOT_FOUND;
            goto exit;
        }

        switch (pVar->vt)
        {
            case VT_UI4:
                pVar->ulVal = *((DWORD *)pbT);
                break;

            case VT_LPSTR:
                pVar->pszVal = (LPSTR)pbT;
                break;

            case VT_LPWSTR:
                pVar->pwszVal = (LPWSTR)pbT;
                break;

            case VT_BLOB:
                pVar->blob.cbSize = cb;
                pVar->blob.pBlobData = pbT;
                break;

            default:
                Assert(FALSE);
                IF_FAILEXIT(hr = E_INVALID_PROP_TYPE);
                break;
        }
        
        IF_FAILEXIT(hr = m_pProp->SetProperty(pszProp, pVar, 0));
        if (pVar->vt != VT_UI4)
        {
            // we're handing this memory off to the caller, so don't free it
            pbT = NULL;
        }
    }
    else
        IF_FAILEXIT(hr);
     
exit:
    MemFree(pbT);
    MemFree(pwszValue);
    if (hkey)
        RegCloseKey(hkey);
    return(hr);
}

STDMETHODIMP COptionBucket::SetProperty(LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwReserved)
{
    if (pszProp == NULL || pVar == NULL || dwReserved != 0)
        return(E_INVALIDARG);
    
    return(ISetProperty(NULL, pszProp, pVar, 0));
}

STDMETHODIMP COptionBucket::ISetProperty(HWND hwnd, LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwFlags)
{
    HRESULT         hr;
    DWORD           type, 
                    cb;
    LPBYTE          pb;
    LPCSTR          pszKey, 
                    pszValue;
    LPWSTR          pwszValue = NULL;
    LPCOPTIONINFO   pInfo;
    LONG            lRet;
    HKEY            hkey = 0;
    
    if (pszProp == NULL || pVar == NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    type = RegTypeFromVarType(pVar->vt);
    if (type == REG_INVALID)
        IF_FAILEXIT(hr = E_INVALID_PROP_TYPE);
    
    Assert(m_pProp != NULL);
    
    IF_FAILEXIT(hr = m_pProp->SetProperty(pszProp, pVar, 0));

    if (hr != S_NO_CHANGE)
    {
        pInfo = GetOptionInfo(pszProp);
        Assert(pInfo != NULL);
        
        Assert(pInfo->iszRegKey < m_cpszRegKey);
        pszKey = m_rgpszRegKey[pInfo->iszRegKey];
        pszValue = pInfo->pszRegValue;
    
        switch (pVar->vt)
        {
            case VT_UI4:
                pb = (BYTE *)&pVar->ulVal;
                cb = sizeof(DWORD);
                break;

            case VT_LPSTR:
                pb = (BYTE *)pVar->pszVal;
                cb = lstrlen(pVar->pszVal) + 1;
                break;

            case VT_LPWSTR:
                pb = (BYTE *)pVar->pwszVal;
                cb = (lstrlenW(pVar->pwszVal) + 1) * sizeof(WCHAR);
                break;

            case VT_BLOB:
                pb = pVar->blob.pBlobData;
                cb = pVar->blob.cbSize;
                break;

            default:
                Assert(FALSE);
                break;
        }
        
        if (pszValue != NULL)
        {
            if ((REG_BINARY == type) && (0 == cb))
            {
                SHDeleteValue(m_hkey, pszKey, pszValue);
                lRet = ERROR_SUCCESS;   // failure on delete is probably just NOT_FOUND
            }
            else
            {
                lRet= RegOpenKeyEx(m_hkey, pszKey, 0, KEY_WRITE, &hkey);
                if (ERROR_SUCCESS == lRet)
                {
                    if (VT_LPWSTR == pVar->vt)
                    {
                        IF_NULLEXIT(pwszValue = PszToUnicode(CP_ACP, pszValue));
                        lRet = RegSetValueExWrapW(hkey, pwszValue, NULL, type, pb, cb);
                    }
                    else
                    {
                        lRet = RegSetValueEx(hkey, pszValue, NULL, type, pb, cb);
                    }
                }
            }
            if (ERROR_SUCCESS == lRet)
            {
                Assert(IsPropId(pszProp));
                
                if (m_pNotify != NULL)
                {
                    if (m_fNotify)
                    {
                        m_pNotify->DoNotification((IOptionBucketEx *)this, hwnd, SzToPropId(pszProp));
                    }
                    else
                    {
                        if (m_idNotify == 0)
                            m_idNotify = SzToPropId(pszProp);
                        else
                            m_idNotify = 0xffffffff;
                    }
                }
            }
            else
                IF_FAILEXIT(hr = E_FAIL);
        }
    }
    
exit:
    if (hkey)
        RegCloseKey(hkey);
    MemFree(pwszValue);
    return(hr);
}

STDMETHODIMP COptionBucket::ValidateProperty(PROPID id, LPCPROPVARIANT pVar, DWORD dwReserved)
{
    HRESULT hr;
    LPCOPTIONINFO pInfo;
    
    if (pVar == NULL || dwReserved != 0)
        return(E_INVALIDARG);
    
    pInfo = GetOptionInfo(MAKEPROPSTRING(id));
    if (pInfo == NULL)
        hr = E_PROP_NOT_FOUND;
    else if (pInfo->vt != pVar->vt)
        hr = E_INVALID_PROP_TYPE;
    else if (pInfo->pfnValid != NULL)
        hr = pInfo->pfnValid(id, pVar);
    else if (pVar->vt == VT_UI4 &&
        (pInfo->dwMin != 0 || pInfo->dwMax != 0))
        hr = (pVar->ulVal >= pInfo->dwMin && pVar->ulVal <= pInfo->dwMax) ? S_OK : E_INVALID_PROP_VALUE;
    else
        hr = S_OK;
    
    return(hr);
}

STDMETHODIMP COptionBucket::GetPropertyDefault(PROPID id, LPPROPVARIANT pVar, DWORD dwReserved)
{
    LPCOPTIONINFO   pInfo;
    HRESULT         hr = S_OK;
    LPBYTE          pb = NULL;
    DWORD           cb = 0;
    
    if (NULL == pVar || 0 != dwReserved)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    pInfo = GetOptionInfo(MAKEPROPSTRING(id));
    if (NULL == pInfo)
        IF_FAILEXIT(hr = E_PROP_NOT_FOUND);

    pVar->vt = pInfo->vt;
    
    if (pVar->vt == VT_UI4)
    {
        pVar->ulVal = (DWORD)PtrToUlong(pInfo->pszDef);
    }
    else
    {
        if (pInfo->pszDef)
        {
            switch (pVar->vt)
            {
                case VT_LPSTR:
                    cb = lstrlen(pInfo->pszDef) + 1;
                    break;

                case VT_LPWSTR:
                    cb = (lstrlenW((LPWSTR)pInfo->pszDef) + 1) * sizeof(WCHAR);
                    break;

                case VT_BLOB:
                    cb = pInfo->cbDefBinary;
                    break;

                default:
                    Assert(FALSE);
                    break;
            }

            IF_NULLEXIT(MemA