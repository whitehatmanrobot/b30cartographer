820, 821 }, { 822, 823 }, 
    { 824, 825 }, { 826, 827 }, { 828, 829 }, { 830, 831 }, 
    { 832, 833 }, { 834, 835 }, { 836, 837 }, { 838, 839 }, 
    { 840, 841 }, { 842, 843 }, { 844, 845 }, { 846, 847 }, 
    { 848, 849 }, { 850, 851 }, { 852, 853 }, { 854, 855 }, 
    { 856, 857 }, { 858, 859 }, { 860, 861 }, { 862, 863 }, 
    { 864, 865 }, { 866, 867 }, { 868, 869 }, { 870, 871 }, 
    { 872, 873 }, { 874, 875 }, { 876, 877 }, { 878, 879 }, 
    { 880, 881 }, { 882, 883 }, { 884, 885 }, { 886, 887 }, 
    { 888, 889 }, { 890, 891 }, { 892, 893 }, { 894, 895 }, 
    { 896, 897 }, { 898, 899 }, { 900, 901 }, { 902, 903 }, 
    { 904, 905 }, { 906, 907 }, { 908, 909 }, { 910, 911 }, 
    { 912, 913 }, { 914, 915 }, { 916, 917 }, { 918, 919 }, 
    { 920, 921 }, { 922, 923 }, { 924, 925 }, { 926, 927 }, 
    { 928, 929 }, { 930, 931 }, { 932, 933 }, { 934, 935 }, 
    { 936, 937 }, { 938, 939 }, { 940, 941 }, { 942, 943 }, 
    { 944, 945 }, { 946, 947 }, { 948, 949 }, { 950, 951 }, 
    { 952, 953 }, { 954, 955 }, { 956, 957 }, { 958, 959 }, 
    { 960, 961 }, { 962, 963 }, { 964, 965 }, { 966, 967 }, 
    { 968, 969 }, { 970, 971 }, { 972, 973 }, { 974, 975 }, 
    { 976, 977 }, { 978, 979 }, { 980, 981 }, { 982, 983 }, 
    { 984, 985 }, { 986, 987 }, { 988, 989 }, { 990, 991 }, 
    { 992, 993 }, { 994, 995 }, { 996, 997 }, { 998, 999 }, 
    { 1000, 1001 }, { 1002, 1003 }, { 1004, 1005 }, { 1006, 1007 }, 
    { 1008, 1009 }, { 1010, 1011 }, { 1012, 1013 }, { 1014, 1015 }, 
    { 1016, 1017 }, { 1018, 1019 }, { 1020, 1021 }, { 1022, 1023 }, 
    };

D3DLINE LineStripPrecomp[] = {
    { 0, 1 }, { 1, 2 }, { 2, 3 }, { 3, 4 }, 
    { 4, 5 }, { 5, 6 }, { 6, 7 }, { 7, 8 }, 
    { 8, 9 }, { 9, 10 }, { 10, 11 }, { 11, 12 }, 
    { 12, 13 }, { 13, 14 }, { 14, 15 }, { 15, 16 }, 
    { 16, 17 }, { 17, 18 }, { 18, 19 }, { 19, 20 }, 
    { 20, 21 }, { 21, 22 }, { 22, 23 }, { 23, 24 }, 
    { 24, 25 }, { 25, 26 }, { 26, 27 }, { 27, 28 }, 
    { 28, 29 }, { 29, 30 }, { 30, 31 }, { 31, 32 }, 
    { 32, 33 }, { 33, 34 }, { 34, 35 }, { 35, 36 }, 
    { 36, 37 }, { 37, 38 }, { 38, 39 }, { 39, 40 }, 
    { 40, 41 }, { 41, 42 }, { 42, 43 }, { 43, 44 }, 
    { 44, 45 }, { 45, 46 }, { 46, 47 }, { 47, 48 }, 
    { 48, 49 }, { 49, 50 }, { 50, 51 }, { 51, 52 }, 
    { 52, 53 }, { 53, 54 }, { 54, 55 }, { 55, 56 }, 
    { 56, 57 }, { 57, 58 }, { 58, 59 }, { 59, 60 }, 
    { 60, 61 }, { 61, 62 }, { 62, 63 }, { 63, 64 }, 
    { 64, 65 }, { 65, 66 }, { 66, 67 }, { 67, 68 }, 
    { 68, 69 }, { 69, 70 }, { 70, 71 }, { 71, 72 }, 
    { 72, 73 }, { 73, 74 }, { 74, 75 }, { 75, 76 }, 
    { 76, 77 }, { 77, 78 }, { 78, 79 }, { 79, 80 }, 
    { 80, 81 }, { 81, 82 }, { 82, 83 }, { 83, 84 }, 
    { 84, 85 }, { 85, 86 }, { 86, 87 }, { 87, 88 }, 
    { 88, 89 }, { 89, 90 }, { 90, 91 }, { 91, 92 }, 
    { 92, 93 }, { 93, 94 }, { 94, 95 }, { 95, 96 }, 
    { 96, 97 }, { 97, 98 }, { 98, 99 }, { 99, 100 }, 
    { 100, 101 }, { 101, 102 }, { 102, 103 }, { 103, 104 }, 
    { 104, 105 }, { 105, 106 }, { 106, 107 }, { 107, 108 }, 
    { 108, 109 }, { 109, 110 }, { 110, 111 }, { 111, 112 }, 
    { 112, 113 }, { 113, 114 }, { 114, 115 }, { 115, 116 }, 
    { 116, 117 }, { 117, 118 }, { 118, 119 }, { 119, 120 }, 
    { 120, 121 }, { 121, 122 }, { 122, 123 }, { 123, 124 }, 
    { 124, 125 }, { 125, 126 }, { 126, 127 }, { 127, 128 }, 
    { 128, 129 }, { 129, 130 }, { 130, 131 }, { 131, 132 }, 
    { 132, 133 }, { 133, 134 }, { 134, 135 }, { 135, 136 }, 
    { 136, 137 }, { 137, 138 }, { 138, 139 }, { 139, 140 }, 
    { 140, 141 }, { 141, 142 }, { 142, 143 }, { 143, 144 }, 
    { 144, 145 }, { 145, 146 }, { 146, 147 }, { 147, 148 }, 
    { 148, 149 }, { 149, 150 }, { 150, 151 }, { 151, 152 }, 
    { 152, 153 }, { 153, 154 }, { 154, 155 }, { 155, 156 }, 
    { 156, 157 }, { 157, 158 }, { 158, 159 }, { 159, 160 }, 
    { 160, 161 }, { 161, 162 }, { 162, 163 }, { 163, 164 }, 
    { 164, 165 }, { 165, 166 }, { 166, 167 }, { 167, 168 }, 
    { 168, 169 }, { 169, 170 }, { 170, 171 }, { 171, 172 }, 
    { 172, 173 }, { 173, 174 }, { 174, 175 }, { 175, 176 }, 
    { 176, 177 }, { 177, 178 }, { 178, 179 }, { 179, 180 }, 
    { 180, 181 }, { 181, 182 }, { 182, 183 }, { 183, 184 }, 
    { 184, 185 }, { 185, 186 }, { 186, 187 }, { 187, 188 }, 
    { 188, 189 }, { 189, 190 }, { 190, 191 }, { 191, 192 }, 
    { 192, 193 }, { 193, 194 }, { 194, 195 }, { 195, 196 }, 
    { 196, 197 }, { 197, 198 }, { 198, 199 }, { 199, 200 }, 
    { 200, 201 }, { 201, 202 }, { 202, 203 }, { 203, 204 }, 
    { 204, 205 }, { 205, 206 }, { 206, 207 }, { 207, 208 }, 
    { 208, 209 }, { 209, 210 }, { 210, 211 }, { 211, 212 }, 
    { 212, 213 }, { 213, 214 }, { 214, 215 }, { 215, 216 }, 
    { 216, 217 }, { 217, 218 }, { 218, 219 }, { 219, 220 }, 
    { 220, 221 }, { 221, 222 }, { 222, 223 }, { 223, 224 }, 
    { 224, 225 }, { 225, 226 }, { 226, 227 }, { 227, 228 }, 
    { 228, 229 }, { 229, 230 }, { 230, 231 }, { 231, 232 }, 
    { 232, 233 }, { 233, 234 }, { 234, 235 }, { 235, 236 }, 
    { 236, 237 }, { 237, 238 }, { 238, 239 }, { 239, 240 }, 
    { 240, 241 }, { 241, 242 }, { 242, 243 }, { 243, 244 }, 
    { 244, 245 }, { 245, 246 }, { 246, 247 }, { 247, 248 }, 
    { 248, 249 }, { 249, 250 }, { 250, 251 }, { 251, 252 }, 
    { 252, 253 }, { 253, 254 }, { 254, 255 }, { 255, 256 },
    { 256, 257 }, { 257, 258 }, { 258, 259 }, { 259, 260 }, 
    { 260, 261 }, { 261, 262 }, { 262, 263 }, { 263, 264 }, 
    { 264, 265 }, { 265, 266 }, { 266, 267 }, { 267, 268 }, 
    { 268, 269 }, { 269, 270 }, { 270, 271 }, { 271, 272 }, 
    { 272, 273 }, { 273, 274 }, { 274, 275 }, { 275, 276 }, 
    { 276, 277 }, { 277, 278 }, { 278, 279 }, { 279, 280 }, 
    { 280, 281 }, { 281, 282 }, { 282, 283 }, { 283, 284 }, 
    { 284, 285 }, { 285, 286 }, { 286, 287 }, { 287, 288 }, 
    { 288, 289 }, { 289, 290 }, { 290, 291 }, { 291, 292 }, 
    { 292, 293 }, { 293, 294 }, { 294, 295 }, { 295, 296 }, 
    { 296, 297 }, { 297, 298 }, { 298, 299 }, { 299, 300 }, 
    { 300, 301 }, { 301, 302 }, { 302, 303 }, { 303, 304 }, 
    { 304, 305 }, { 305, 306 }, { 306, 307 }, { 307, 308 }, 
    { 308, 309 }, { 309, 310 }, { 310, 311 }, { 311, 312 }, 
    { 312, 313 }, { 313, 314 }, { 314, 315 }, { 315, 316 }, 
    { 316, 317 }, { 317, 318 }, { 318, 319 }, { 319, 320 }, 
    { 320, 321 }, { 321, 322 }, { 322, 323 }, { 323, 324 }, 
    { 324, 325 }, { 325, 326 }, { 326, 327 }, { 327, 328 }, 
    { 328, 329 }, { 329, 330 }, { 330, 331 }, { 331, 332 }, 
    { 332, 333 }, { 333, 334 }, { 334, 335 }, { 335, 336 }, 
    { 336, 337 }, { 337, 338 }, { 338, 339 }, { 339, 340 }, 
    { 340, 341 }, { 341, 342 }, { 342, 343 }, { 343, 344 }, 
    { 344, 345 }, { 345, 346 }, { 346, 347 }, { 347, 348 }, 
    { 348, 349 }, { 349, 350 }, { 350, 351 }, { 351, 352 }, 
    { 352, 353 }, { 353, 354 }, { 354, 355 }, { 355, 356 }, 
    { 356, 357 }, { 357, 358 }, { 358, 359 }, { 359, 360 }, 
    { 360, 361 }, { 361, 362 }, { 362, 363 }, { 363, 364 }, 
    { 364, 365 }, { 365, 366 }, { 366, 367 }, { 367, 368 }, 
    { 368, 369 }, { 369, 370 }, { 370, 371 }, { 371, 372 }, 
    { 372, 373 }, { 373, 374 }, { 374, 375 }, { 375, 376 }, 
    { 376, 377 }, { 377, 378 }, { 378, 379 }, { 379, 380 }, 
    { 380, 381 }, { 381, 382 }, { 382, 383 }, { 383, 384 }, 
    { 384, 385 }, { 385, 386 }, { 386, 387 }, { 387, 388 }, 
    { 388, 389 }, { 389, 390 }, { 390, 391 }, { 391, 392 }, 
    { 392, 393 }, { 393, 394 }, { 394, 395 }, { 395, 396 }, 
    { 396, 397 }, { 397, 398 }, { 398, 399 }, { 399, 400 }, 
    { 400, 401 }, { 401, 402 }, { 402, 403 }, { 403, 404 }, 
    { 404, 405 }, { 405, 406 }, { 406, 407 }, { 407, 408 }, 
    { 408, 409 }, { 409, 410 }, { 410, 411 }, { 411, 412 }, 
    { 412, 413 }, { 413, 414 }, { 414, 415 }, { 415, 416 }, 
    { 416, 417 }, { 417, 418 }, { 418, 419 }, { 419, 420 }, 
    { 420, 421 }, { 421, 422 }, { 422, 423 }, { 423, 424 }, 
    { 424, 425 }, { 425, 426 }, { 426, 427 }, { 427, 428 }, 
    { 428, 429 }, { 429, 430 }, { 430, 431 }, { 431, 432 }, 
    { 432, 433 }, { 433, 434 }, { 434, 435 }, { 435, 436 }, 
    { 436, 437 }, { 437, 438 }, { 438, 439 }, { 439, 440 }, 
    { 440, 441 }, { 441, 442 }, { 442, 443 }, { 443, 444 }, 
    { 444, 445 }, { 445, 446 }, { 446, 447 }, { 447, 448 }, 
    { 448, 449 }, { 449, 450 }, { 450, 451 }, { 451, 452 }, 
    { 452, 453 }, { 453, 454 }, { 454, 455 }, { 455, 456 }, 
    { 456, 457 }, { 457, 458 }, { 458, 459 }, { 459, 460 }, 
    { 460, 461 }, { 461, 462 }, { 462, 463 }, { 463, 464 }, 
    { 464, 465 }, { 465, 466 }, { 466, 467 }, { 467, 468 }, 
    { 468, 469 }, { 469, 470 }, { 470, 471 }, { 471, 472 }, 
    { 472, 473 }, { 473, 474 }, { 474, 475 }, { 475, 476 }, 
    { 476, 477 }, { 477, 478 }, { 478, 479 }, { 479, 480 }, 
    { 480, 481 }, { 481, 482 }, { 482, 483 }, { 483, 484 }, 
    { 484, 485 }, { 485, 486 }, { 486, 487 }, { 487, 488 }, 
    { 488, 489 }, { 489, 490 }, { 490, 491 }, { 491, 492 }, 
    { 492, 493 }, { 493, 494 }, { 494, 495 }, { 495, 496 }, 
    { 496, 497 }, { 497, 498 }, { 498, 499 }, { 499, 500 }, 
    { 500, 501 }, { 501, 502 }, { 502, 503 }, { 503, 504 }, 
    { 504, 505 }, { 505, 506 }, { 506, 507 }, { 507, 508 }, 
    { 508, 509 }, { 509, 510 }, { 510, 511 }, { 511, 512 }, 
    };

D3DTRIANGLE TriangleListPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 4, 5, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 10, 11, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 16, 17, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 22, 23, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 28, 29, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 34, 35, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 40, 41, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 46, 47, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 52, 53, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 58, 59, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 64, 65, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 70, 71, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 76, 77, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 82, 83, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 88, 89, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 94, 95, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 100, 101, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 106, 107, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 112, 113, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 118, 119, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 124, 125, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 130, 131, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 136, 137, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 142, 143, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 148, 149, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 154, 155, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 160, 161, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 166, 167, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 172, 173, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 178, 179, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 184, 185, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 190, 191, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 196, 197, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 202, 203, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 208, 209, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 214, 215, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 220, 221, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 226, 227, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 232, 233, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 238, 239, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 244, 245, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 250, 251, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 256, 257, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 258, 259, 260, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 261, 262, 263, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 264, 265, 266, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 267, 268, 269, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 270, 271, 272, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 273, 274, 275, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 276, 277, 278, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 279, 280, 281, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 282, 283, 284, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 285, 286, 287, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 288, 289, 290, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 291, 292, 293, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 294, 295, 296, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 297, 298, 299, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 300, 301, 302, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 303, 304, 305, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 306, 307, 308, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 309, 310, 311, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 312, 313, 314, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 315, 316, 317, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 318, 319, 320, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 321, 322, 323, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 324, 325, 326, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 327, 328, 329, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 330, 331, 332, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 333, 334, 335, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 336, 337, 338, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 339, 340, 341, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 342, 343, 344, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 345, 346, 347, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 348, 349, 350, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 351, 352, 353, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 354, 355, 356, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 357, 358, 359, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 360, 361, 362, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 363, 364, 365, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 366, 367, 368, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 369, 370, 371, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 372, 373, 374, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 375, 376, 377, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 378, 379, 380, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 381, 382, 383, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 384, 385, 386, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 387, 388, 389, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 390, 391, 392, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 393, 394, 395, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 396, 397, 398, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 399, 400, 401, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 402, 403, 404, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 405, 406, 407, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 408, 409, 410, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 411, 412, 413, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 414, 415, 416, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 417, 418, 419, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 420, 421, 422, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 423, 424, 425, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 426, 427, 428, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 429, 430, 431, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 432, 433, 434, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 435, 436, 437, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 438, 439, 440, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 441, 442, 443, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 444, 445, 446, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 447, 448, 449, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 450, 451, 452, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 453, 454, 455, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 456, 457, 458, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 459, 460, 461, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 462, 463, 464, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 465, 466, 467, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 468, 469, 470, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 471, 472, 473, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 474, 475, 476, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 477, 478, 479, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 480, 481, 482, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 483, 484, 485, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 486, 487, 488, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 489, 490, 491, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 492, 493, 494, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 495, 496, 497, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 498, 499, 500, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 501, 502, 503, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 504, 505, 506, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 507, 508, 509, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 510, 511, 512, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 513, 514, 515, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 516, 517, 518, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 519, 520, 521, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 522, 523, 524, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 525, 526, 527, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 528, 529, 530, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 531, 532, 533, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 534, 535, 536, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 537, 538, 539, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 540, 541, 542, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 543, 544, 545, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 546, 547, 548, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 549, 550, 551, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 552, 553, 554, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 555, 556, 557, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 558, 559, 560, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 561, 562, 563, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 564, 565, 566, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 567, 568, 569, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 570, 571, 572, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 573, 574, 575, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 576, 577, 578, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 579, 580, 581, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 582, 583, 584, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 585, 586, 587, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 588, 589, 590, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 591, 592, 593, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 594, 595, 596, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 597, 598, 599, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 600, 601, 602, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 603, 604, 605, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 606, 607, 608, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 609, 610, 611, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 612, 613, 614, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 615, 616, 617, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 618, 619, 620, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 621, 622, 623, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 624, 625, 626, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 627, 628, 629, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 630, 631, 632, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 633, 634, 635, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 636, 637, 638, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 639, 640, 641, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 642, 643, 644, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 645, 646, 647, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 648, 649, 650, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 651, 652, 653, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 654, 655, 656, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 657, 658, 659, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 660, 661, 662, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 663, 664, 665, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 666, 667, 668, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 669, 670, 671, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 672, 673, 674, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 675, 676, 677, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 678, 679, 680, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 681, 682, 683, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 684, 685, 686, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 687, 688, 689, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 690, 691, 692, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 693, 694, 695, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 696, 697, 698, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 699, 700, 701, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 702, 703, 704, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 705, 706, 707, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 708, 709, 710, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 711, 712, 713, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 714, 715, 716, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 717, 718, 719, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 720, 721, 722, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 723, 724, 725, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 726, 727, 728, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 729, 730, 731, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 732, 733, 734, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 735, 736, 737, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 738, 739, 740, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 741, 742, 743, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 744, 745, 746, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 747, 748, 749, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 750, 751, 752, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 753, 754, 755, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 756, 757, 758, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 759, 760, 761, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 762, 763, 764, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 765, 766, 767, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

D3DTRIANGLE TriangleStripPrecomp[] = {
    { 0, 1, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 1, 3, 2, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 2, 3, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 3, 5, 4, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 4, 5, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 5, 7, 6, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 6, 7, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 7, 9, 8, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 8, 9, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 9, 11, 10, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 10, 11, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 11, 13, 12, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 12, 13, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 13, 15, 14, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 14, 15, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 15, 17, 16, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 16, 17, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 17, 19, 18, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 18, 19, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 19, 21, 20, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 20, 21, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 21, 23, 22, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 22, 23, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 23, 25, 24, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 24, 25, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 25, 27, 26, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 26, 27, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 27, 29, 28, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 28, 29, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 29, 31, 30, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 30, 31, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 31, 33, 32, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 32, 33, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 33, 35, 34, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 34, 35, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 35, 37, 36, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 36, 37, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 37, 39, 38, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 38, 39, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 39, 41, 40, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 40, 41, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 41, 43, 42, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 42, 43, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 43, 45, 44, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 44, 45, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 45, 47, 46, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 46, 47, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 47, 49, 48, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 48, 49, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 49, 51, 50, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 50, 51, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 51, 53, 52, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 52, 53, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 53, 55, 54, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 54, 55, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 55, 57, 56, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 56, 57, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 57, 59, 58, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 58, 59, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 59, 61, 60, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 60, 61, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 61, 63, 62, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 62, 63, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 63, 65, 64, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 64, 65, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 65, 67, 66, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 66, 67, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 67, 69, 68, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 68, 69, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 69, 71, 70, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 70, 71, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 71, 73, 72, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 72, 73, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 73, 75, 74, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 74, 75, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 75, 77, 76, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 76, 77, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 77, 79, 78, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 78, 79, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 79, 81, 80, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 80, 81, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 81, 83, 82, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 82, 83, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 83, 85, 84, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 84, 85, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 85, 87, 86, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 86, 87, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 87, 89, 88, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 88, 89, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 89, 91, 90, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 90, 91, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 91, 93, 92, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 92, 93, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 93, 95, 94, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 94, 95, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 95, 97, 96, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 96, 97, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 97, 99, 98, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 98, 99, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 99, 101, 100, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 100, 101, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 101, 103, 102, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 102, 103, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 103, 105, 104, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 104, 105, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 105, 107, 106, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 106, 107, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 107, 109, 108, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 108, 109, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 109, 111, 110, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 110, 111, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 111, 113, 112, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 112, 113, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 113, 115, 114, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 114, 115, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 115, 117, 116, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 116, 117, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 117, 119, 118, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 118, 119, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 119, 121, 120, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 120, 121, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 121, 123, 122, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 122, 123, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 123, 125, 124, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 124, 125, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 125, 127, 126, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 126, 127, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 127, 129, 128, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 128, 129, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 129, 131, 130, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 130, 131, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 131, 133, 132, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 132, 133, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 133, 135, 134, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 134, 135, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 135, 137, 136, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 136, 137, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 137, 139, 138, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 138, 139, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 139, 141, 140, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 140, 141, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 141, 143, 142, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 142, 143, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 143, 145, 144, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 144, 145, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 145, 147, 146, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 146, 147, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 147, 149, 148, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 148, 149, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 149, 151, 150, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 150, 151, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 151, 153, 152, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 152, 153, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 153, 155, 154, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 154, 155, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 155, 157, 156, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 156, 157, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 157, 159, 158, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 158, 159, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 159, 161, 160, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 160, 161, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 161, 163, 162, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 162, 163, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 163, 165, 164, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 164, 165, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 165, 167, 166, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 166, 167, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 167, 169, 168, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 168, 169, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 169, 171, 170, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 170, 171, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 171, 173, 172, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 172, 173, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 173, 175, 174, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 174, 175, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 175, 177, 176, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 176, 177, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 177, 179, 178, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 178, 179, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 179, 181, 180, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 180, 181, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 181, 183, 182, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 182, 183, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 183, 185, 184, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 184, 185, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 185, 187, 186, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 186, 187, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 187, 189, 188, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 188, 189, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 189, 191, 190, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 190, 191, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 191, 193, 192, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 192, 193, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 193, 195, 194, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 194, 195, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 195, 197, 196, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 196, 197, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 197, 199, 198, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 198, 199, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 199, 201, 200, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 200, 201, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 201, 203, 202, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 202, 203, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 203, 205, 204, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 204, 205, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 205, 207, 206, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 206, 207, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 207, 209, 208, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 208, 209, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 209, 211, 210, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 210, 211, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 211, 213, 212, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 212, 213, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 213, 215, 214, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 214, 215, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 215, 217, 216, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 216, 217, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 217, 219, 218, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 218, 219, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 219, 221, 220, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 220, 221, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 221, 223, 222, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 222, 223, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 223, 225, 224, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 224, 225, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 225, 227, 226, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 226, 227, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 227, 229, 228, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 228, 229, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 229, 231, 230, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 230, 231, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 231, 233, 232, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 232, 233, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 233, 235, 234, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 234, 235, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 235, 237, 236, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 236, 237, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 237, 239, 238, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 238, 239, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 239, 241, 240, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 240, 241, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 241, 243, 242, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 242, 243, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 243, 245, 244, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 244, 245, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 245, 247, 246, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 246, 247, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 247, 249, 248, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 248, 249, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 249, 251, 250, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 250, 251, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 251, 253, 252, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 252, 253, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 253, 255, 254, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    { 254, 255, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, { 255, 257, 256, D3DTRIFLAG_EDGEENABLETRIANGLE }, 
    };

D3DTRIANGLE TriangleFanPrecomp[] = {
    { 1, 2, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 2, 3, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 3, 4, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 4, 5, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 5, 6, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 6, 7, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 7, 8, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 8, 9, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 9, 10, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 10, 11, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 11, 12, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 12, 13, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 13, 14, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 14, 15, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 15, 16, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 16, 17, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 17, 18, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 18, 19, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 19, 20, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 20, 21, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 21, 22, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 22, 23, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 23, 24, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 24, 25, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 25, 26, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 26, 27, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 27, 28, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 28, 29, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 29, 30, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 30, 31, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 31, 32, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 32, 33, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 33, 34, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 34, 35, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 35, 36, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 36, 37, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 37, 38, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 38, 39, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 39, 40, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 40, 41, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 41, 42, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 42, 43, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 43, 44, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 44, 45, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 45, 46, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 46, 47, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 47, 48, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 48, 49, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 49, 50, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 50, 51, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 51, 52, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 52, 53, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 53, 54, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 54, 55, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 55, 56, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 56, 57, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 57, 58, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 58, 59, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 59, 60, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 60, 61, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 61, 62, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 62, 63, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 63, 64, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 64, 65, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 65, 66, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 66, 67, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 67, 68, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 68, 69, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 69, 70, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 70, 71, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 71, 72, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 72, 73, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 73, 74, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 74, 75, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 75, 76, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 76, 77, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 77, 78, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 78, 79, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 79, 80, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 80, 81, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 81, 82, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 82, 83, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 83, 84, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 84, 85, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 85, 86, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 86, 87, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 87, 88, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 88, 89, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 89, 90, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 90, 91, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 91, 92, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 92, 93, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 93, 94, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 94, 95, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 95, 96, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 96, 97, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 97, 98, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 98, 99, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 99, 100, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 100, 101, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 101, 102, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 102, 103, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 103, 104, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 104, 105, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 105, 106, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 106, 107, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 107, 108, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 108, 109, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 109, 110, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 110, 111, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 111, 112, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 112, 113, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 113, 114, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 114, 115, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 115, 116, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 116, 117, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 117, 118, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 118, 119, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 119, 120, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 120, 121, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 121, 122, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 122, 123, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 123, 124, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 124, 125, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 125, 126, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 126, 127, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 127, 128, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 128, 129, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 129, 130, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 130, 131, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 131, 132, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 132, 133, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 133, 134, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 134, 135, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 135, 136, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 136, 137, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 137, 138, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 138, 139, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 139, 140, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 140, 141, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 141, 142, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 142, 143, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 143, 144, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 144, 145, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 145, 146, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 146, 147, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 147, 148, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 148, 149, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 149, 150, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 150, 151, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 151, 152, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 152, 153, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 153, 154, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 154, 155, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 155, 156, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 156, 157, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 157, 158, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 158, 159, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 159, 160, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 160, 161, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 161, 162, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 162, 163, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 163, 164, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 164, 165, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 165, 166, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 166, 167, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 167, 168, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 168, 169, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 169, 170, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 170, 171, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 171, 172, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 172, 173, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 173, 174, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 174, 175, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 175, 176, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 176, 177, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 177, 178, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 178, 179, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 179, 180, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 180, 181, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 181, 182, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 182, 183, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 183, 184, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 184, 185, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 185, 186, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 186, 187, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 187, 188, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 188, 189, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 189, 190, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 190, 191, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 191, 192, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 192, 193, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 193, 194, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 194, 195, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 195, 196, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 196, 197, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 197, 198, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 198, 199, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 199, 200, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 200, 201, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 201, 202, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 202, 203, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 203, 204, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 204, 205, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 205, 206, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 206, 207, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 207, 208, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 208, 209, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 209, 210, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 210, 211, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 211, 212, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 212, 213, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 213, 214, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 214, 215, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 215, 216, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 216, 217, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 217, 218, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 218, 219, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 219, 220, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 220, 221, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 221, 222, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 222, 223, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 223, 224, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 224, 225, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 225, 226, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 226, 227, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 227, 228, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 228, 229, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 229, 230, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 230, 231, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 231, 232, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 232, 233, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 233, 234, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 234, 235, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 235, 236, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 236, 237, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 237, 238, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 238, 239, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 239, 240, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 240, 241, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 241, 242, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 242, 243, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 243, 244, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 244, 245, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 245, 246, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 246, 247, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 247, 248, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 248, 249, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 249, 250, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 250, 251, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 251, 252, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 252, 253, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 253, 254, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 254, 255, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
    { 255, 256, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },{ 256, 257, 0, D3DTRIFLAG_EDGEENABLETRIANGLE },
};

/* This can be (and should be) replaced by LineListPrecomp */
WORD TriangleListPrecompDP[][3] = {
    { 0, 1, 2 }, { 3, 4, 5 },
    { 6, 7, 8 }, { 9, 10, 11 },
    { 12, 13, 14 }, { 15, 16, 17 },
    { 18, 19, 20 }, { 21, 22, 23 },
    { 24, 25, 26 }, { 27, 28, 29 },
    { 30, 31, 32 }, { 33, 34, 35 },
    { 36, 37, 38 }, { 39, 40, 41 },
    { 42, 43, 44 }, { 45, 46, 47 },
    { 48, 49, 50 }, { 51, 52, 53 },
    { 54, 55, 56 }, { 57, 58, 59 },
    { 60, 61, 62 }, { 63, 64, 65 },
    { 66, 67, 68 }, { 69, 70, 71 },
    { 72, 73, 74 }, { 75, 76, 77 },
    { 78, 79, 80 }, { 81, 82, 83 },
    { 84, 85, 86 }, { 87, 88, 89 },
    { 90, 91, 92 }, { 93, 94, 95 },
    { 96, 97, 98 }, { 99, 100, 101 },
    { 102, 103, 104 }, { 105, 106, 107 },
    { 108, 109, 110 }, { 111, 112, 113 },
    { 114, 115, 116 }, { 117, 118, 119 },
    { 120, 121, 122 }, { 123, 124, 125 },
    { 126, 127, 128 }, { 129, 130, 131 },
    { 132, 133, 134 }, { 135, 136, 137 },
    { 138, 139, 140 }, { 141, 142, 143 },
    { 144, 145, 146 }, { 147, 148, 149 },
    { 150, 151, 152 }, { 153, 154, 155 },
    { 156, 157, 158 }, { 159, 160, 161 },
    { 162, 163, 164 }, { 165, 166, 167 },
    { 168, 169, 170 }, { 171, 172, 173 },
    { 174, 175, 176 }, { 177, 178, 179 },
    { 180, 181, 182 }, { 183, 184, 185 },
    { 186, 187, 188 }, { 189, 190, 191 },
    { 192, 193, 194 }, { 195, 196, 197 },
    { 198, 199, 200 }, { 201, 202, 203 },
    { 204, 205, 206 }, { 207, 208, 209 },
    { 210, 211, 212 }, { 213, 214, 215 },
    { 216, 217, 218 }, { 219, 220, 221 },
    { 222, 223, 224 }, { 225, 226, 227 },
    { 228, 229, 230 }, { 231, 232, 233 },
    { 234, 235, 236 }, { 237, 238, 239 },
    { 240, 241, 242 }, { 243, 244, 245 },
    { 246, 247, 248 }, { 249, 250, 251 },
    { 252, 253, 254 }, { 255, 256, 257 },
    { 258, 259, 260 }, { 261, 262, 263 },
    { 264, 265, 266 }, { 267, 268, 269 },
    { 270, 271, 272 }, { 273, 274, 275 },
    { 276, 277, 278 }, { 279, 280, 281 },
    { 282, 283, 284 }, { 285, 286, 287 },
    { 288, 289, 290 }, { 291, 292, 293 },
    { 294, 295, 296 }, { 297, 298, 299 },
    { 300, 301, 302 }, { 303, 304, 305 },
    { 306, 307, 308 }, { 309, 310, 311 },
    { 312, 313, 314 }, { 315, 316, 317 },
    { 318, 319, 320 }, { 321, 322, 323 },
    { 324, 325, 326 }, { 327, 328, 329 },
    { 330, 331, 332 }, { 333, 334, 335 },
    { 336, 337, 338 }, { 339, 340, 341 },
    { 342, 343, 344 }, { 345, 346, 347 },
    { 348, 349, 350 }, { 351, 352, 353 },
    { 354, 355, 356 }, { 357, 358, 359 },
    { 360, 361, 362 }, { 363, 364, 365 },
    { 366, 367, 368 }, { 369, 370, 371 },
    { 372, 373, 374 }, { 375, 376, 377 },
    { 378, 379, 380 }, { 381, 382, 383 },
    { 384, 385, 386 }, { 387, 388, 389 },
    { 390, 391, 392 }, { 393, 394, 395 },
    { 396, 397, 398 }, { 399, 400, 401 },
    { 402, 403, 404 }, { 405, 406, 407 },
    { 408, 409, 410 }, { 411, 412, 413 },
    { 414, 415, 416 }, { 417, 418, 419 },
    { 420, 421, 422 }, { 423, 424, 425 },
    { 426, 427, 428 }, { 429, 430, 431 },
    { 432, 433, 434 }, { 435, 436, 437 },
    { 438, 439, 440 }, { 441, 442, 443 },
    { 444, 445, 446 }, { 447, 448, 449 },
    { 450, 451, 452 }, { 453, 454, 455 },
    { 456, 457, 458 }, { 459, 460, 461 },
    { 462, 463, 464 }, { 465, 466, 467 },
    { 468, 469, 470 }, { 471, 472, 473 },
    { 474, 475, 476 }, { 477, 478, 479 },
    { 480, 481, 482 }, { 483, 484, 485 },
    { 486, 487, 488 }, { 489, 490, 491 },
    { 492, 493, 494 }, { 495, 496, 497 },
    { 498, 499, 500 }, { 501, 502, 503 },
    { 504, 505, 506 }, { 507, 508, 509 },
    { 510, 511, 512 }, { 513, 514, 515 },
    { 516, 517, 518 }, { 519, 520, 521 },
    { 522, 523, 524 }, { 525, 526, 527 },
    { 528, 529, 530 }, { 531, 532, 533 },
    { 534, 535, 536 }, { 537, 538, 539 },
    { 540, 541, 542 }, { 543, 544, 545 },
    { 546, 547, 548 }, { 549, 550, 551 },
    { 552, 553, 554 }, { 555, 556, 557 },
    { 558, 559, 560 }, { 561, 562, 563 },
    { 564, 565, 566 }, { 567, 568, 569 },
    { 570, 571, 572 }, { 573, 574, 575 },
    { 576, 577, 578 }, { 579, 580, 581 },
    { 582, 583, 584 }, { 585, 586, 587 },
    { 588, 589, 590 }, { 591, 592, 593 },
    { 594, 595, 596 }, { 597, 598, 599 },
    { 600, 601, 602 }, { 603, 604, 605 },
    { 606, 607, 608 }, { 609, 610, 611 },
    { 612, 613, 614 }, { 615, 616, 617 },
    { 618, 619, 620 }, { 621, 622, 623 },
    { 624, 625, 626 }, { 627, 628, 629 },
    { 630, 631, 632 }, { 633, 634, 635 },
    { 636, 637, 638 }, { 639, 640, 641 },
    { 642, 643, 644 }, { 645, 646, 647 },
    { 648, 649, 650 }, { 651, 652, 653 },
    { 654, 655, 656 }, { 657, 658, 659 },
    { 660, 661, 662 }, { 663, 664, 665 },
    { 666, 667, 668 }, { 669, 670, 671 },
    { 672, 673, 674 }, { 675, 676, 677 },
    { 678, 679, 680 }, { 681, 682, 683 },
    { 684, 685, 686 }, { 687, 688, 689 },
    { 690, 691, 692 }, { 693, 694, 695 },
    { 696, 697, 698 }, { 699, 700, 701 },
    { 702, 703, 704 }, { 705, 706, 707 },
    { 708, 709, 710 }, { 711, 712, 713 },
    { 714, 715, 716 }, { 717, 718, 719 },
    { 720, 721, 722 }, { 723, 724, 725 },
    { 726, 727, 728 }, { 729, 730, 731 },
    { 732, 733, 734 }, { 735, 736, 737 },
    { 738, 739, 740 }, { 741, 742, 743 },
    { 744, 745, 746 }, { 747, 748, 749 },
    { 750, 751, 752 }, { 753, 754, 755 },
    { 756, 757, 758 }, { 759, 760, 761 },
    { 762, 763, 764 }, { 765, 766, 767 },
};

WORD TriangleStripPrecompDP[][3] = {
    { 0, 1, 2 }, { 1, 3, 2 },
    { 2, 3, 4 }, { 3, 5, 4 },
    { 4, 5, 6 }, { 5, 7, 6 },
    { 6, 7, 8 }, { 7, 9, 8 },
    { 8, 9, 10 }, { 9, 11, 10 },
    { 10, 11, 12 }, { 11, 13, 12 },
    { 12, 13, 14 }, { 13, 15, 14 },
    { 14, 15, 16 }, { 15, 17, 16 },
    { 16, 17, 18 }, { 17, 19, 18 },
    { 18, 19, 20 }, { 19, 21, 20 },
    { 20, 21, 22 }, { 21, 23, 22 },
    { 22, 23, 24 }, { 23, 25, 24 },
    { 24, 25, 26 }, { 25, 27, 26 },
    { 26, 27, 28 }, { 27, 29, 28 },
    { 28, 29, 30 }, { 29, 31, 30 },
    { 30, 31, 32 }, { 31, 33, 32 },
    { 32, 33, 34 }, { 33, 35, 34 },
    { 34, 35, 36 }, { 35, 37, 36 },
    { 36, 37, 38 }, { 37, 39, 38 },
    { 38, 39, 40 }, { 39, 41, 40 },
    { 40, 41, 42 }, { 41, 43, 42 },
    { 42, 43, 44 }, { 43, 45, 44 },
    { 44, 45, 46 }, { 45, 47, 46 },
    { 46, 47, 48 }, { 47, 49, 48 },
    { 48, 49, 50 }, { 49, 51, 50 },
    { 50, 51, 52 }, { 51, 53, 52 },
    { 52, 53, 54 }, { 53, 55, 54 },
    { 54, 55, 56 }, { 55, 57, 56 },
    { 56, 57, 58 }, { 57, 59, 58 },
    { 58, 59, 60 }, { 59, 61, 60 },
    { 60, 61, 62 }, { 61, 63, 62 },
    { 62, 63, 64 }, { 63, 65, 64 },
    { 64, 65, 66 }, { 65, 67, 66 },
    { 66, 67, 68 }, { 67, 69, 68 },
    { 68, 69, 70 }, { 69, 71, 70 },
    { 70, 71, 72 }, { 71, 73, 72 },
    { 72, 73, 74 }, { 73, 75, 74 },
    { 74, 75, 76 }, { 75, 77, 76 },
    { 76, 77, 78 }, { 77, 79, 78 },
    { 78, 79, 80 }, { 79, 81, 80 },
    { 80, 81, 82 }, { 81, 83, 82 },
    { 82, 83, 84 }, { 83, 85, 84 },
    { 84, 85, 86 }, { 85, 87, 86 },
    { 86, 87, 88 }, { 87, 89, 88 },
    { 88, 89, 90 }, { 89, 91, 90 },
    { 90, 91, 92 }, { 91, 93, 92 },
    { 92, 93, 94 }, { 93, 95, 94 },
    { 94, 95, 96 }, { 95, 97, 96 },
    { 96, 97, 98 }, { 97, 99, 98 },
    { 98, 99, 100 }, { 99, 101, 100 },
    { 100, 101, 102 }, { 101, 103, 102 },
    { 102, 103, 104 }, { 103, 105, 104 },
    { 104, 105, 106 }, { 105, 107, 106 },
    { 106, 107, 108 }, { 107, 109, 108 },
    { 108, 109, 110 }, { 109, 111, 110 },
    { 110, 111, 112 }, { 111, 113, 112 },
    { 112, 113, 114 }, { 113, 115, 114 },
    { 114, 115, 116 }, { 115, 117, 116 },
    { 116, 117, 118 }, { 117, 119, 118 },
    { 118, 119, 120 }, { 119, 121, 120 },
    { 120, 121, 122 }, { 121, 123, 122 },
    { 122, 123, 124 }, { 123, 125, 124 },
    { 124, 125, 126 }, { 125, 127, 126 },
    { 126, 127, 128 }, { 127, 129, 128 },
    { 128, 129, 130 }, { 129, 131, 130 },
    { 130, 131, 132 }, { 131, 133, 132 },
    { 132, 133, 134 }, { 133, 135, 134 },
    { 134, 135, 136 }, { 135, 137, 136 },
    { 136, 137, 138 }, { 137, 139, 138 },
    { 138, 139, 140 }, { 139, 141, 140 },
    { 140, 141, 142 }, { 141, 143, 142 },
    { 142, 143, 144 }, { 143, 145, 144 },
    { 144, 145, 146 }, { 145, 147, 146 },
    { 146, 147, 148 }, { 147, 149, 148 },
    { 148, 149, 150 }, { 149, 151, 150 },
    { 150, 151, 152 }, { 151, 153, 152 },
    { 152, 153, 154 }, { 153, 155, 154 },
    { 154, 155, 156 }, { 155, 157, 156 },
    { 156, 157, 158 }, { 157, 159, 158 },
    { 158, 159, 160 }, { 159, 161, 160 },
    { 160, 161, 162 }, { 161, 163, 162 },
    { 162, 163, 164 }, { 163, 165, 164 },
    { 164, 165, 166 }, { 165, 167, 166 },
    { 166, 167, 168 }, { 167, 169, 168 },
    { 168, 169, 170 }, { 169, 171, 170 },
    { 170, 171, 172 }, { 171, 173, 172 },
    { 172, 173, 174 }, { 173, 175, 174 },
    { 174, 175, 176 }, { 175, 177, 176 },
    { 176, 177, 178 }, { 177, 179, 178 },
    { 178, 179, 180 }, { 179, 181, 180 },
    { 180, 181, 182 }, { 181, 183, 182 },
    { 182, 183, 184 }, { 183, 185, 184 },
    { 184, 185, 186 }, { 185, 187, 186 },
    { 186, 187, 188 }, { 187, 189, 188 },
    { 188, 189, 190 }, { 189, 191, 190 },
    { 190, 191, 192 }, { 191, 193, 192 },
    { 192, 193, 194 }, { 193, 195, 194 },
    { 194, 195, 196 }, { 195, 197, 196 },
    { 196, 197, 198 }, { 197, 199, 198 },
    { 198, 199, 200 }, { 199, 201, 200 },
    { 200, 201, 202 }, { 201, 203, 202 },
    { 202, 203, 204 }, { 203, 205, 204 },
    { 204, 205, 206 }, { 205, 207, 206 },
    { 206, 207, 208 }, { 207, 209, 208 },
    { 208, 209, 210 }, { 209, 211, 210 },
    { 210, 211, 212 }, { 211, 213, 212 },
    { 212, 213, 214 }, { 213, 215, 214 },
    { 214, 215, 216 }, { 215, 217, 216 },
    { 216, 217, 218 }, { 217, 219, 218 },
    { 218, 219, 220 }, { 219, 221, 220 },
    { 220, 221, 222 }, { 221, 223, 222 },
    { 222, 223, 224 }, { 223, 225, 224 },
    { 224, 225, 226 }, { 225, 227, 226 },
    { 226, 227, 228 }, { 227, 229, 228 },
    { 228, 229, 230 }, { 229, 231, 230 },
    { 230, 231, 232 }, { 231, 233, 232 },
    { 232, 233, 234 }, { 233, 235, 234 },
    { 234, 235, 236 }, { 235, 237, 236 },
    { 236, 237, 238 }, { 237, 239, 238 },
    { 238, 239, 240 }, { 239, 241, 240 },
    { 240, 241, 242 }, { 241, 243, 242 },
    { 242, 243, 244 }, { 243, 245, 244 },
    { 244, 245, 246 }, { 245, 247, 246 },
    { 246, 247, 248 }, { 247, 249, 248 },
    { 248, 249, 250 }, { 249, 251, 250 },
    { 250, 251, 252 }, { 251, 253, 252 },
    { 252, 253, 254 }, { 253, 255, 254 },
    { 254, 255, 256 }, { 255, 257, 256 },
};

WORD TriangleFanPrecompDP[][3] = {
    { 1, 2, 0 }, { 2, 3, 0 },
    { 3, 4, 0 }, { 4, 5, 0 },
    { 5, 6, 0 }, { 6, 7, 0 },
    { 7, 8, 0 }, { 8, 9, 0 },
    { 9, 10, 0 }, { 10, 11, 0 },
    { 11, 12, 0 }, { 12, 13, 0 },
    { 13, 14, 0 }, { 14, 15, 0 },
    { 15, 16, 0 }, { 16, 17, 0 },
    { 17, 18, 0 }, { 18, 19, 0 },
    { 19, 20, 0 }, { 20, 21, 0 },
    { 21, 22, 0 }, { 22, 23, 0 },
    { 23, 24, 0 }, { 24, 25, 0 },
    { 25, 26, 0 }, { 26, 27, 0 },
    { 27, 28, 0 }, { 28, 29, 0 },
    { 29, 30, 0 }, { 30, 31, 0 },
    { 31, 32, 0 }, { 32, 33, 0 },
    { 33, 34, 0 }, { 34, 35, 0 },
    { 35, 36, 0 }, { 36, 37, 0 },
    { 37, 38, 0 }, { 38, 39, 0 },
    { 39, 40, 0 }, { 40, 41, 0 },
    { 41, 42, 0 }, { 42, 43, 0 },
    { 43, 44, 0 }, { 44, 45, 0 },
    { 45, 46, 0 }, { 46, 47, 0 },
    { 47, 48, 0 }, { 48, 49, 0 },
    { 49, 50, 0 }, { 50, 51, 0 },
    { 51, 52, 0 }, { 52, 53, 0 },
    { 53, 54, 0 }, { 54, 55, 0 },
    { 55, 56, 0 }, { 56, 57, 0 },
    { 57, 58, 0 }, { 58, 59, 0 },
    { 59, 60, 0 }, { 60, 61, 0 },
    { 61, 62, 0 }, { 62, 63, 0 },
    { 63, 64, 0 }, { 64, 65, 0 },
    { 65, 66, 0 }, { 66, 67, 0 },
    { 67, 68, 0 }, { 68, 69, 0 },
    { 69, 70, 0 }, { 70, 71, 0 },
    { 71, 72, 0 }, { 72, 73, 0 },
    { 73, 74, 0 }, { 74, 75, 0 },
    { 75, 76, 0 }, { 76, 77, 0 },
    { 77, 78, 0 }, { 78, 79, 0 },
    { 79, 80, 0 }, { 80, 81, 0 },
    { 81, 82, 0 }, { 82, 83, 0 },
    { 83, 84, 0 }, { 84, 85, 0 },
    { 85, 86, 0 }, { 86, 87, 0 },
    { 87, 88, 0 }, { 88, 89, 0 },
    { 89, 90, 0 }, { 90, 91, 0 },
    { 91, 92, 0 }, { 92, 93, 0 },
    { 93, 94, 0 }, { 94, 95, 0 },
    { 95, 96, 0 }, { 96, 97, 0 },
    { 97, 98, 0 }, { 98, 99, 0 },
    { 99, 100, 0 }, { 100, 101, 0 },
    { 101, 102, 0 }, { 102, 103, 0 },
    { 103, 104, 0 }, { 104, 105, 0 },
    { 105, 106, 0 }, { 106, 107, 0 },
    { 107, 108, 0 }, { 108, 109, 0 },
    { 109, 110, 0 }, { 110, 111, 0 },
    { 111, 112, 0 }, { 112, 113, 0 },
    { 113, 114, 0 }, { 114, 115, 0 },
    { 115, 116, 0 }, { 116, 117, 0 },
    { 117, 118, 0 }, { 118, 119, 0 },
    { 119, 120, 0 }, { 120, 121, 0 },
    { 121, 122, 0 }, { 122, 123, 0 },
    { 123, 124, 0 }, { 124, 125, 0 },
    { 125, 126, 0 }, { 126, 127, 0 },
    { 127, 128, 0 }, { 128, 129, 0 },
    { 129, 130, 0 }, { 130, 131, 0 },
    { 131, 132, 0 }, { 132, 133, 0 },
    { 133, 134, 0 }, { 134, 135, 0 },
    { 135, 136, 0 }, { 136, 137, 0 },
    { 137, 138, 0 }, { 138, 139, 0 },
    { 139, 140, 0 }, { 140, 141, 0 },
    { 141, 142, 0 }, { 142, 143, 0 },
    { 143, 144, 0 }, { 144, 145, 0 },
    { 145, 146, 0 }, { 146, 147, 0 },
    { 147, 148, 0 }, { 148, 149, 0 },
    { 149, 150, 0 }, { 150, 151, 0 },
    { 151, 152, 0 }, { 152, 153, 0 },
    { 153, 154, 0 }, { 154, 155, 0 },
    { 155, 156, 0 }, { 156, 157, 0 },
    { 157, 158, 0 }, { 158, 159, 0 },
    { 159, 160, 0 }, { 160, 161, 0 },
    { 161, 162, 0 }, { 162, 163, 0 },
    { 163, 164, 0 }, { 164, 165, 0 },
    { 165, 166, 0 }, { 166, 167, 0 },
    { 167, 168, 0 }, { 168, 169, 0 },
    { 169, 170, 0 }, { 170, 171, 0 },
    { 171, 172, 0 }, { 172, 173, 0 },
    { 173, 174, 0 }, { 174, 175, 0 },
    { 175, 176, 0 }, { 176, 177, 0 },
    { 177, 178, 0 }, { 178, 179, 0 },
    { 179, 180, 0 }, { 180, 181, 0 },
    { 181, 182, 0 }, { 182, 183, 0 },
    { 183, 184, 0 }, { 184, 185, 0 },
    { 185, 186, 0 }, { 186, 187, 0 },
    { 187, 188, 0 }, { 188, 189, 0 },
    { 189, 190, 0 }, { 190, 191, 0 },
    { 191, 192, 0 }, { 192, 193, 0 },
    { 193, 194, 0 }, { 194, 195, 0 },
    { 195, 196, 0 }, { 196, 197, 0 },
    { 197, 198, 0 }, { 198, 199, 0 },
    { 199, 200, 0 }, { 200, 201, 0 },
    { 201, 202, 0 }, { 202, 203, 0 },
    { 203, 204, 0 }, { 204, 205, 0 },
    { 205, 206, 0 }, { 206, 207, 0 },
    { 207, 208, 0 }, { 208, 209, 0 },
    { 209, 210, 0 }, { 210, 211, 0 },
    { 211, 212, 0 }, { 212, 213, 0 },
    { 213, 214, 0 }, { 214, 215, 0 },
    { 215, 216, 0 }, { 216, 217, 0 },
    { 217, 218, 0 }, { 218, 219, 0 },
    { 219, 220, 0 }, { 220, 221, 0 },
    { 221, 222, 0 }, { 222, 223, 0 },
    { 223, 224, 0 }, { 224, 225, 0 },
    { 225, 226, 0 }, { 226, 227, 0 },
    { 227, 228, 0 }, { 228, 229, 0 },
    { 229, 230, 0 }, { 230, 231, 0 },
    { 231, 232, 0 }, { 232, 233, 0 },
    { 233, 234, 0 }, { 234, 235, 0 },
    { 235, 236, 0 }, { 236, 237, 0 },
    { 237, 238, 0 }, { 238, 239, 0 },
    { 239, 240, 0 }, { 240, 241, 0 },
    { 241, 242, 0 }, { 242, 243, 0 },
    { 243, 244, 0 }, { 244, 245, 0 },
    { 245, 246, 0 }, { 246, 247, 0 },
    { 247, 248, 0 }, { 248, 249, 0 },
    { 249, 250, 0 }, { 250, 251, 0 },
    { 251, 252, 0 }, { 252, 253, 0 },
    { 253, 254, 0 }, { 254, 255, 0 },
    { 255, 256, 0 }, { 256, 257, 0 },
    { 257, 258, 0 },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\testprov.cpp ===
//----------------------------------------------------------------------------
//
// testprov.cpp
//
// Test HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop
                       
//#ifdef DEBUG_PIPELINE

#include "testprov.h"
#include "testfile.h"
#include "stdio.h"

// Real rasterizer data
static D3DHALPROVIDER_INTERFACEDATA CurInterfaceData;
static IHalProvider    *pCurHalProvider;    // Real HAL provider

// Test provider data
static CTestHalProvider g_TestHalProvider;
static D3DHALPROVIDER_INTERFACEDATA TestInterfaceData;
static D3DHAL_CALLBACKS  TestCallbacks;
static D3DHAL_CALLBACKS2 TestCallbacks2;
static D3DHAL_CALLBACKS3 TestCallbacks3;
static char szFileName[_MAX_PATH] = "";     // Output file name
static FILE *fout = NULL;                   // Output file
DWORD g_dwTestHalFlags = 0;                   // Could be set from debugger

// Bits for g_dwTestHalFlags
const DWORD __TESTHAL_OUTPUTFILE    = 1;    // If need output to test file
const DWORD __TESTHAL_NORENDER      = 2;    // If no rendering needed

//---------------------------------------------------------------------
// Provides access to DIRECTDRAWSURFACE memory;
// In the constructor the surface is locked.
// In the destructor it is unlocked.
// LPBYTE() or LPVOID() casts will get pointer to the surface bits.
//
class CLockedDDSurface
{
public:
    CLockedDDSurface(LPDIRECTDRAWSURFACE surface);
    ~CLockedDDSurface();
    operator LPVOID() {return descr.lpSurface;}
    operator LPBYTE() {return (LPBYTE)descr.lpSurface;}
protected:
    DDSURFACEDESC descr;
    LPDIRECTDRAWSURFACE pSurface;
};

CLockedDDSurface::CLockedDDSurface(LPDIRECTDRAWSURFACE surface)
{
    pSurface = surface;
    memset (&descr, 0, sizeof(descr));
    descr.dwSize = sizeof(descr);
    surface->Lock(NULL, &descr,  0, NULL);
}

CLockedDDSurface::~CLockedDDSurface()
{
    if (descr.lpSurface) 
        pSurface->Unlock(descr.lpSurface);
}
//---------------------------------------------------------------------
void PutHeader(DWORD id, DWORD size)
{
    if (fout)
    {
        fwrite(&id, sizeof(DWORD), 1, fout);
        fwrite(&size, sizeof(DWORD), 1, fout);
    }
}
//---------------------------------------------------------------------
DWORD GetCurrentPosition()
{
    if (fout)
        return ftell(fout);
    else
        return 0;
}
//---------------------------------------------------------------------
void SetCurrentPosition(DWORD offset)
{
    if (fout)
        fseek(fout, offset, SEEK_SET);
}
//---------------------------------------------------------------------
void PutBuffer(LPVOID buffer, DWORD size)
{
    if (fout)
    {
        fwrite(buffer, 1, size, fout);
    }
}
//---------------------------------------------------------------------
// Implementation of test callbacks
//
DWORD __stdcall
TestDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA data)
{   
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEPRIMITIVE rec;
        PutHeader(TFID_DRAWONEPRIMITIVE, 
                  sizeof(rec) + data->dwNumVertices*sizeof(D3DTLVERTEX));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);  
    }

    if (CurInterfaceData.pCallbacks2->DrawOnePrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOnePrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWONEINDEXEDPRIMITIVE rec;
        PutHeader(TFID_DRAWONEINDEXEDPRIMITIVE, 
                  sizeof(rec) + 
                  data->dwNumVertices*sizeof(D3DTLVERTEX) +
                  data->dwNumIndices*sizeof(WORD));
        rec.primitiveType = data->PrimitiveType;
        rec.vertexCount = data->dwNumVertices;
        rec.vertexType = data->VertexType;
        rec.dwFlags = data->dwFlags;
        rec.indexCount = data->dwNumIndices;
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(data->lpvVertices, sizeof(D3DTLVERTEX)*data->dwNumVertices);  
        PutBuffer(data->lpwIndices, sizeof(WORD)*data->dwNumIndices);  
    }

    if (CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawOneIndexedPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        DWORD endPos = 0;
        LPVOID header = data->lpvData;
        PutHeader(0,0);     // Dummy header. Will be filled later
        DWORD startPos = GetCurrentPosition();
        for (;;)
        {
            DWORD nStates = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumStateChanges;
            DWORD nVertices = ((D3DHAL_DRAWPRIMCOUNTS*)header)->wNumVertices;
            DWORD size;
        // Primitive header
            PutBuffer(header, sizeof(D3DHAL_DRAWPRIMCOUNTS));
            header = (char*)header + sizeof(D3DHAL_DRAWPRIMCOUNTS);
        // States
            size = nStates * sizeof(WORD);
            PutBuffer(header, size);
            header = (char*)header + size; 
            header = (LPVOID)(((ULONG_PTR)header + 31) & ~31);  //32 bytes aligned
        // Vertices
            if (!nVertices)
                break;
            size = nVertices * sizeof(D3DTLVERTEX);
            PutBuffer(header, size);

        }
        // Write record header
        endPos = GetCurrentPosition();
        SetCurrentPosition(startPos - sizeof(TF_HEADER));
        PutHeader(TFID_DRAWPRIMITIVES, endPos - startPos);
        SetCurrentPosition(endPos);
    }

    if (CurInterfaceData.pCallbacks2->DrawPrimitives &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks2->DrawPrimitives(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        TFREC_DRAWPRIMITIVES2 rec;
        rec.dwFlags = 0;
        PutBuffer(&rec, sizeof(rec));
        PutHeader(TFID_DRAWPRIMITIVES, sizeof(rec));
    }

    if (CurInterfaceData.pCallbacks3->DrawPrimitives2 &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks3->DrawPrimitives2(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderState(LPD3DHAL_RENDERSTATEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem should be destroyed before calling to real driver to unlock
        // the surface
        CLockedDDSurface mem(data->lpExeBuf);
        LPD3DSTATE	pState;
        pState = (LPD3DSTATE)(LPBYTE(mem) + data->dwOffset);
        PutHeader(TFID_RENDERSTATE, sizeof(DWORD) + data->dwCount*sizeof(D3DSTATE));
        PutBuffer(&data->dwCount, sizeof(DWORD));
        for (DWORD i = 0; i < data->dwCount; i++) 
        {
            PutBuffer(&pState, sizeof(D3DSTATE));
	        pState++;
        }
    }

    if (CurInterfaceData.pCallbacks->RenderState)
        return CurInterfaceData.pCallbacks->RenderState(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA data)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        // mem and tlmem should be destroyed before calling the real driver
        // to unlock the surface
        CLockedDDSurface mem(data->lpExeBuf);
        CLockedDDSurface tlmem(data->lpTLBuf);
        LPBYTE        lpPrimData;
        LPD3DTLVERTEX lpTLData;	
        DWORD         i;
        DWORD         primitiveDataSize;
        DWORD         count = data->diInstruction.wCount;
        TFREC_RENDERPRIMITIVE rec;

        // Find the pointer to the first primitive structure
        lpPrimData = (LPBYTE)mem + data->dwOffset;

        // Find the pointer to the vertex data
        // Find the pointer to the first TL vertex
        lpTLData = (LPD3DTLVERTEX)((LPBYTE)tlmem + data->dwTLOffset);

        rec.status = data->dwStatus;
        rec.vertexType = D3DVT_TLVERTEX;
        // Find out number of vertices, primitive type and
        // size of primitive data
        switch (data->diInstruction.bOpcode) 
        {
        case D3DOP_POINT:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DPOINT);
	        break;
        case D3DOP_LINE:
            rec.primitiveType = D3DPT_LINELIST;
            rec.vertexCount = count*2;
            primitiveDataSize = count*sizeof(D3DLINE);
	        break;
        case D3DOP_SPAN:
            rec.primitiveType = D3DPT_POINTLIST;
            rec.vertexCount = count;
            primitiveDataSize = count*sizeof(D3DSPAN);
	        break;
        case D3DOP_TRIANGLE:
            rec.primitiveType = D3DPT_TRIANGLELIST;
            rec.vertexCount = count*3;
            primitiveDataSize = count*sizeof(D3DTRIANGLE);
	        break;
        }

        PutHeader(TFID_RENDERPRIMITIVE,
                  sizeof(D3DINSTRUCTION) +
                  sizeof(rec) + rec.vertexCount*sizeof(D3DTLVERTEX) +
                  primitiveDataSize);
        PutBuffer(&rec, sizeof(rec));
        PutBuffer(&data->diInstruction, sizeof(D3DINSTRUCTION));

        // Parse the structures based on the instruction
        switch (data->diInstruction.bOpcode) 
        {
        case D3DOP_POINT:
        {
	        LPD3DPOINT lpPoint = (LPD3DPOINT)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpPoint, sizeof(D3DPOINT));
                PutBuffer(&lpTLData[lpPoint->wFirst], 
                          lpPoint->wCount*sizeof(D3DTLVERTEX));
                lpPoint++;
	        }
	        break;
        }
        case D3DOP_LINE:
        {
	        LPD3DLINE lpLine = (LPD3DLINE)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpLine, sizeof(D3DLINE));
                PutBuffer(&lpTLData[lpLine->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpLine->v2], sizeof(D3DTLVERTEX));
                lpLine++;
	        }
	        break;
        }
        case D3DOP_SPAN:
        {
	        LPD3DSPAN lpSpan = (LPD3DSPAN)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpSpan, sizeof(D3DSPAN));
                PutBuffer(&lpTLData[lpSpan->wFirst], 
                          lpSpan->wCount*sizeof(D3DTLVERTEX));
                lpSpan++;
	        }
	        break;
        }
        case D3DOP_TRIANGLE:
        {
	        LPD3DTRIANGLE lpTri = (LPD3DTRIANGLE)lpPrimData;
	        for (i = 0; i < count; i++) 
            {
                PutBuffer(lpTri, sizeof(D3DTRIANGLE));
                PutBuffer(&lpTLData[lpTri->v1], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v2], sizeof(D3DTLVERTEX));
                PutBuffer(&lpTLData[lpTri->v3], sizeof(D3DTLVERTEX));
                lpTri++;
	        }
	        break;
        }
        }
    }

    if (CurInterfaceData.pCallbacks->RenderPrimitive &&
        !(g_dwTestHalFlags & __TESTHAL_NORENDER))
        return CurInterfaceData.pCallbacks->RenderPrimitive(data);
    else
        return DDHAL_DRIVER_HANDLED;
}

DWORD __stdcall
TestSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        PutHeader(TFID_SCENECAPTURE, sizeof(DWORD));
        PutBuffer(&pData->dwFlag, sizeof(DWORD));
        fflush(fout);
    }

    if (CurInterfaceData.pCallbacks->SceneCapture)
        return CurInterfaceData.pCallbacks->SceneCapture(pData);
    else
        return DDHAL_DRIVER_HANDLED;
}
//----------------------------------------------------------------------------
//
// TestHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP CTestHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CTestHalProvider::Release(THIS)
{
    if (fout)
    {
        fclose(fout);
        fout = NULL;
    }
    return pCurHalProvider->Release();
}
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to 
//      the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlagsInp  - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//
// Notes:
//      Only one instance of the test HAL is handled correctly.
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid, 
                          DDRAWI_DIRECTDRAW_GBL *GlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider, 
                          DWORD dwFlagsInp)
{
    *ppHalProvider = &g_TestHalProvider;
    pCurHalProvider = pCurrentHalProvider;

    g_dwTestHalFlags |= __TESTHAL_NORENDER;
    if (GetD3DRegValue(REG_SZ, "TestHalFile", &szFileName, _MAX_PATH) &&
        szFileName[0] != 0)
    {
        g_dwTestHalFlags |= __TESTHAL_OUTPUTFILE;
    }
    DWORD dwValue;
    if (GetD3DRegValue(REG_DWORD, "TestHalDoRender", &dwValue, sizeof(DWORD)) &&
        dwValue != 0)
    {
        g_dwTestHalFlags &= ~__TESTHAL_NORENDER;
    }
// Get interface from the current hal provider to call to it
    pCurrentHalProvider->GetInterface(GlobalData, &CurInterfaceData, 3);

    TestInterfaceData = CurInterfaceData;
    TestInterfaceData.pCallbacks  = &TestCallbacks;
    TestInterfaceData.pCallbacks2 = &TestCallbacks2;
    TestInterfaceData.pCallbacks3 = &TestCallbacks3;

// Initialize callbacks we do not care of

    TestCallbacks  = *CurInterfaceData.pCallbacks;
    TestCallbacks2 = *CurInterfaceData.pCallbacks2;
    TestCallbacks3 = *CurInterfaceData.pCallbacks3;

// Initialize callbacks that we want to intersept

    TestCallbacks.RenderState = &TestRenderState;
    TestCallbacks.RenderPrimitive = &TestRenderPrimitive;
    TestCallbacks.SceneCapture = &TestSceneCapture;

    TestCallbacks2.DrawOnePrimitive = &TestDrawOnePrimitive;
    TestCallbacks2.DrawOneIndexedPrimitive = &TestDrawOneIndexedPrimitive;
    TestCallbacks2.DrawPrimitives = &TestDrawPrimitives;

    TestCallbacks3.DrawPrimitives2 = &TestDrawPrimitives2;

    fout = NULL;
    if (g_dwTestHalFlags & __TESTHAL_OUTPUTFILE)
    {
        fout = fopen(szFileName, "wb");
        if (!fout)
            return DDERR_GENERIC;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CTestHalProvider::GetInterface
//
// Returns  test provider interface and real rasterizer global data.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTestHalProvider::GetInterface(THIS_
                               LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                               LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                               DWORD dwVersion)
{
    *pInterfaceData = TestInterfaceData;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// TestHalProvider::GetCaps
//
// Returns real rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CTestHalProvider::GetCaps(THIS_
                          LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                          LPD3DDEVICEDESC pHwDesc,
                          LPD3DDEVICEDESC pHelDesc,
                          DWORD dwVersion)
{
    return pCurHalProvider->GetCaps(pDdGbl, pHwDesc, pHelDesc, dwVersion);
}

//#endif //DEBUG_PIPELINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\texiunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    texiunk.c
*  Content: Direct3DTexture IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* If we are built with aggregation enabled then we actually need two
* different Direct3D QueryInterface, AddRef and Releases. One which
* does the right thing on the Direct3DTexture object and one which
* simply punts to the owning interface.
*/

/*
* D3DTextIUnknown_QueryInterface
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::QueryInterface"

HRESULT D3DAPI CDirect3DTextureUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DWORD_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;
    
    if(IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown.
         * NOTE: Must AddRef through the interface being returned.
         */
        pTexI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(this));
    }
    else if (IsEqualIID(riid, IID_IDirect3DTexture))
    {
        /*
         * Asking for the actual IDirect3DTexture interface
         * NOTE: Must AddRef throught the interface being returned.
         */
        pTexI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DTEXTURE>(pTexI));
    }
    else if (IsEqualIID(riid, IID_IDirect3DTexture2))
    {
        /*
         * Asking for the actual IDirect3DTexture2 interface
         * NOTE: Must AddRef throught the interface being returned.
         */
        pTexI->AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DTEXTURE2>(pTexI));
    }
    else
    {
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* D3DTextIUnknown_QueryInterface */

/*
  * D3DTextIUnknown_AddRef
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::AddRef"

ULONG D3DAPI CDirect3DTextureUnk::AddRef()
{
    DWORD                     rcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DWORD_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    this->refCnt++;
    rcnt = this->refCnt;
    
    D3D_INFO(3, "Direct3DTexture IUnknown AddRef: Reference count = %d", rcnt);
    
    return (rcnt);
} /* D3DTextIUnknown_AddRef */

/*
  * D3DTextIUnknown_Release
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Release"

ULONG D3DAPI CDirect3DTextureUnk::Release()
{
    DWORD           lastrefcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DWORD_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;
    
    D3D_INFO(3, "Direct3DTexture IUnknown Release: Reference count = %d", lastrefcnt);
    
    if (lastrefcnt == 0)
    {
        delete pTexI; // Delete Parent object
        return 0;
    }
    
    return lastrefcnt;
} /* D3DTextIUnknown_Release */

DIRECT3DTEXTUREI::~DIRECT3DTEXTUREI()
{
    /*
     * just in case someone comes back in with this pointer, set
     * an invalid vtbl.  Once we do that, it is safe to leave
     * the protected area...
        */
    while (LIST_FIRST(&this->blocks)) {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->blocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }

    if (lpTMBucket)
    {	//need to release the private lpDDS if any
        lpDDS1Tex->Release();
        lpDDS->Release();
        lpTMBucket->lpD3DTexI=NULL;
    }

}

/*
  * D3DText_QueryInterface
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::QueryInterface"

HRESULT D3DAPI DIRECT3DTEXTUREI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid IDirect3DTexture pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if( !VALID_OUTPTR( ppvObj ) )
        {
            D3D_ERR( "Invalid obj ptr" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    
    /*
     * Punt to the owning interface.
     */
    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
    return ret;
}

/*
  * D3DText_AddRef
*/
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::AddRef"

ULONG D3DAPI DIRECT3DTEXTUREI::AddRef()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->AddRef();
    
    return ret;
} /* D3DText_AddRef */

/*
  * D3DText_Release
  */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture::Release"

ULONG D3DAPI DIRECT3DTEXTUREI::Release()
{
    ULONG ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DTEXTURE2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DTexture pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    
    /*
     * Punt to owning interface.
     */
    ret = this->lpOwningIUnknown->Release();
    
    return ret;
} /* D3DText_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\texman.cpp ===
#include "pch.cpp"
#pragma hdrstop
#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager"

TextureCacheManager::TextureCacheManager(LPDIRECT3DI lpD3DI)
{
    for(int i = 0; i < MAXLOGTEXSIZE; tcm_bucket[i++] = NULL);
    tcm_ticks = 0;
    numvidtex = 0;
    lpDirect3DI=lpD3DI;
}

TextureCacheManager::~TextureCacheManager()
{
    for(int i = 0; i < MAXLOGTEXSIZE;i++){
        LPD3DBUCKET	bucket=tcm_bucket[i];
        while(bucket){
            tcm_bucket[i]=bucket->next;
            if (bucket->lpD3DTexI)  remove(bucket);
            D3DFreeBucket(lpDirect3DI,bucket);
            bucket=tcm_bucket[i];
        }
    }
}

BOOL TextureCacheManager::freeNode(LPD3DI_TEXTUREBLOCK lpBlock, LPD3DBUCKET* lplpBucket)
{
    // Starting from the current size, find the LRU texture and remove it.
    unsigned int oldest = tcm_ticks;
    LPD3DBUCKET	bucket,last,target=NULL;
    int     k=lpBlock->lpD3DTextureI->LogTexSize;
    DWORD   dwTextureStage=lpBlock->lpD3DTextureI->ddsd.dwTextureStage;
    BOOL    bSingleMemory = !(lpBlock->lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES);
    D3D_INFO(8,"freeing size %d bSingleMemory=%d",k,bSingleMemory);
    for(int i = k; i < MAXLOGTEXSIZE; ++i) {
        for(bucket=tcm_bucket[i],last=NULL; bucket;){
	    if (!bucket->lpD3DTexI){	//invalidated by Tex3I destructors ?
                LPD3DBUCKET	temp=bucket->next;
                D3DFreeBucket(lpDirect3DI,bucket);
                bucket=temp;
                if (last){	// Yes, but is this the first node on the list
                    last->next=bucket;
                }
                else
                {
                    tcm_bucket[i]=bucket;
                }
                continue;
            }
            if(bucket->ticks < oldest && 
                (bSingleMemory || (bucket->lpD3DTexI->ddsd.dwTextureStage == dwTextureStage)) && 
                !bucket->lpD3DTexI->bInUse) 
            {
                oldest = bucket->ticks;
                target = bucket;
            }
            last=bucket;
            bucket=last->next;
        }
        if (oldest != tcm_ticks)
        {
            if (i==k && 
                !(lpBlock->lpD3DTextureI->ddsd.ddsCaps.dwCaps2 & 
                (DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)  
                ) &&
                !(target->lpD3DTexI->ddsd.ddsCaps.dwCaps2 & 
                (DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)  
                ) &&
                !(!(lpBlock->lpD3DTextureI->ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP) && (target->lpD3DTexI->ddsd.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
                ) &&
                !((DDPF_PALETTEINDEXED1 | 
                DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8) 
                & lpBlock->lpD3DTextureI->ddsd.ddpfPixelFormat.dwFlags)) //workaround of ddraw not updating surface pallete
                *lplpBucket=target; //possible candidate for replace
            else
                remove(target);
            return TRUE;
        }
    }
    // If bigger size texture not found, try smaller sizes.
    for(i = k - 1; i > 0; --i) {
        for(bucket=tcm_bucket[i],last=NULL; bucket;){
            if (!bucket->lpD3DTexI){	//invalidated by TexI destructors ?
                LPD3DBUCKET	temp=bucket->next;
                D3DFreeBucket(lpDirect3DI,bucket);
                bucket=temp;
                if (last){	// Yes, but is this the first node on the list
                    last->next=bucket;
                }
                else
                {
                    tcm_bucket[i]=bucket;
                }
                continue;
            }
            if(bucket->ticks < oldest && 
                (bSingleMemory || (bucket->lpD3DTexI->ddsd.dwTextureStage == dwTextureStage)) && 
                !bucket->lpD3DTexI->bInUse) 
            {
                oldest = bucket->ticks;
                target = bucket;
            }
            last=bucket;
            bucket=last->next;
        }
        if (oldest != tcm_ticks)
        {
            remove(target);
            return TRUE;
        }
    }
    return  FALSE;
}

HRESULT MarkDirtyPointers(LPDIRECT3DTEXTUREI  lpD3DTexI)
{
    // Next, we need to loop thru and set pointers to the dirty
    // bit in the DDraw surfaces
    HRESULT ddrval;
    DDSCAPS2 ddscaps;
    LPDIRECTDRAWSURFACE4 lpDDSTmp, lpDDS = lpD3DTexI->lpDDS, lpDDSSys = lpD3DTexI->lpDDSSys;
    do 
    {
        ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpSurfMore->lpbDirty = &(lpD3DTexI->bDirty);
        ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpSurfMore->lpRegionList = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSys)->lpLcl->lpSurfMore->lpRegionList;
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDS->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        if (lpDDS != lpD3DTexI->lpDDS)  lpDDS->Release();
        lpDDS = lpDDSTmp;
        if (DDERR_NOTFOUND == ddrval)
        {
            if (lpDDSSys != lpD3DTexI->lpDDSSys)  lpDDSSys->Release();
            return  D3D_OK;
        }
        else if(DD_OK != ddrval)
        {
            D3D_ERR("GetAttachedSurface failed unexpectedly in MarkDirtyPointers");
            if (lpDDSSys != lpD3DTexI->lpDDSSys)  lpDDSSys->Release();
            return ddrval;
        }
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        ddrval = lpDDSSys->GetAttachedSurface(&ddscaps, &lpDDSTmp);
        if (lpDDSSys != lpD3DTexI->lpDDSSys)  lpDDSSys->Release();
        lpDDSSys = lpDDSTmp;
    }
    while(ddrval == DD_OK);
    D3D_ERR("GetAttachedSurface failed unexpectedly in MarkDirtyPointers");
    if (lpDDS != lpD3DTexI->lpDDS)  lpDDS->Release();
    return ddrval;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::allocNode"

HRESULT TextureCacheManager::allocNode(LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPD3DBUCKET	    lpCachedTexture=NULL;
    DWORD   pcaps,dwCaps;
    HRESULT ddrval;
    LPDIRECT3DTEXTUREI  lpD3DTexI=lpBlock->lpD3DTextureI;
    DDASSERT(!lpBlock->hTex && lpD3DTexI && lpBlock->lpDevI);
    if (0 == lpD3DTexI->LogTexSize)
    {
        DWORD texsize;  // in the number of half bytes
        // Compute log2 of the texture size. This is the bucket index.
        memset(&lpD3DTexI->ddsd, 0, sizeof(lpD3DTexI->ddsd));
        lpD3DTexI->ddsd.dwSize = sizeof(lpD3DTexI->ddsd);
        if (DD_OK != (ddrval=lpD3DTexI->lpDDSSys->GetSurfaceDesc(&lpD3DTexI->ddsd)))
        {
            D3D_WARN(1,"GetSurfaceDesc failed in TextureCacheManager::allocNode");
            return ddrval;
        }
        if (DDSD_LINEARSIZE & lpD3DTexI->ddsd.dwFlags)
        {
            texsize = lpD3DTexI->ddsd.dwLinearSize*2;
        }
        else 
        {
            texsize = lpD3DTexI->ddsd.dwWidth*lpD3DTexI->ddsd.dwHeight*lpD3DTexI->ddsd.ddpfPixelFormat.dwRGBBitCount/4;
        }
        if (0 != texsize )
        {
            for(; (texsize & 1) == 0; texsize >>= 1) ++lpD3DTexI->LogTexSize;
        }
        else
            lpD3DTexI->LogTexSize=1;

        D3D_INFO(7,"Managed Texture size=%d",lpD3DTexI->LogTexSize);    
        DDASSERT(lpD3DTexI->LogTexSize < MAXLOGTEXSIZE );
        lpD3DTexI->ddsd.dwFlags &= ~DDSD_PITCH;    // DDRAW always give that, but we don't want
        lpD3DTexI->ddsd.ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
        lpD3DTexI->ddsd.ddsCaps.dwCaps2 &= ~(DDSCAPS2_TEXTUREMANAGE);
        lpD3DTexI->ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    }
    // Attempt to allocate a texture. If out of video memory, first try to replace
    // an old texture. If replacement not possible, free old textures using an LRU scheme
    // till enough memory is available.
    do {
        ddrval = lpDirect3DI->lpDD4->CreateSurface(&lpD3DTexI->ddsd, &lpD3DTexI->lpDDS, NULL);
        if (DD_OK== ddrval) { // No problem, there is enough memory. 
            if (D3D_OK != (ddrval=MarkDirtyPointers(lpD3DTexI)))
            {
                lpD3DTexI->lpDDS->Release();
                lpD3DTexI->lpDDS=NULL;
                return ddrval;
            }
            if (D3D_OK != (ddrval=D3DMallocBucket(lpDirect3DI,&lpCachedTexture)))
            {
                lpD3DTexI->lpDDS->Release();
                lpD3DTexI->lpDDS=NULL;
                return ddrval;
            }
            lpCachedTexture->next=tcm_bucket[lpD3DTexI->LogTexSize];
            lpCachedTexture->lpD3DTexI=lpD3DTexI;
            lpCachedTexture->ticks=tcm_ticks;
            tcm_bucket[lpD3DTexI->LogTexSize]=lpCachedTexture;
            ++numvidtex;
        }
        else
        if(ddrval == DDERR_OUTOFVIDEOMEMORY) { // If out of video memory
            if (freeNode(lpBlock,&lpCachedTexture))
            {
                if (lpCachedTexture)
                {   //found a replace candidate
                    replace(lpCachedTexture,lpBlock);
                    if ( lpD3DTexI->ddsd.dwWidth == lpCachedTexture->lpD3DTexI->ddsd.dwWidth 
                        && lpD3DTexI->ddsd.dwHeight == lpCachedTexture->lpD3DTexI->ddsd.dwHeight 
                        && lpD3DTexI->ddsd.ddpfPixelFormat.dwRBitMask == lpCachedTexture->lpD3DTexI->ddsd.ddpfPixelFormat.dwRBitMask 
                        && lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags == lpCachedTexture->lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags 
                        )
                    {
                        lpD3DTexI->lpDDS = lpCachedTexture->lpD3DTexI->lpDDS;
                        if (DD_OK == CopySurface(lpD3DTexI->lpDDS,lpD3DTexI->lpDDSSys,NULL) 
                            && D3D_OK == MarkDirtyPointers(lpD3DTexI) )
                        {
                            lpCachedTexture->lpD3DTexI->lpDDS=NULL;
                            lpD3DTexI->lpTMBucket=lpCachedTexture;
                            lpCachedTexture->lpD3DTexI->lpTMBucket=NULL;
                            lpD3DTexI->lpDDS1Tex = lpCachedTexture->lpD3DTexI->lpDDS1Tex;
                            lpCachedTexture->lpD3DTexI->lpDDS1Tex=NULL;
                            lpCachedTexture->lpD3DTexI=lpD3DTexI;
                            lpCachedTexture->ticks=tcm_ticks;
                            lpD3DTexI->bDirty=FALSE;
                            return D3D_OK;
                        }
                        lpD3DTexI->lpDDS = NULL;
                        D3D_WARN(2,"(%d %d %d) matching replace failed in TextureCacheManager::allocNode lpD3DTexI=%08lx with lpDDS=%08lx",
                                lpD3DTexI->LogTexSize,lpD3DTexI->ddsd.dwWidth,lpD3DTexI->ddsd.dwHeight,lpD3DTexI,lpCachedTexture->lpD3DTexI->lpDDS);
                    }
                    if (lpBlock->hTex)  //copy failed, therefore clear handle also  
                    {
                        CLockD3DST lockObject(lpBlock->lpDevI, DPF_MODNAME, REMIND(""));
                        D3DHAL_TextureDestroy(lpBlock);                        
                    }
                    remove(lpCachedTexture);
                    lpCachedTexture=NULL;
                }
            }
            else
            {
                D3D_ERR("all Freed no further video memory available");
#if DBG
                D3D_INFO(4,"freeing size %d dwTextureStage=%d tcm_ticks=%08lx dwCaps =%08lx failed",
                    lpD3DTexI->LogTexSize,lpD3DTexI->ddsd.dwTextureStage,tcm_ticks,lpD3DTexI->ddsd.ddsCaps.dwCaps);
                for(int i = 0; i < MAXLOGTEXSIZE; ++i) 
                {
                    if (tcm_bucket[i])  D3D_INFO(5,"List of size %d",i);
                    for(LPD3DBUCKET bucket=tcm_bucket[i];bucket;bucket=bucket->next)
                    {
                        if (bucket->lpD3DTexI)
                            D3D_INFO(5,"ticks=%08lx lpD3DTexI=%08lx InUse=%08lx dwTextureStage=%d",
                            bucket->ticks,bucket->lpD3DTexI, 
                            bucket->lpD3DTexI->bInUse,
                            bucket->lpD3DTexI->ddsd.dwTextureStage);
                    }
                }
#endif
                return	DDERR_OUTOFVIDEOMEMORY;	//nothing left
            }
        }
        else{
                D3D_ERR("Unexpected error got in allocNode");
                return	ddrval;
        }
    }while(ddrval == DDERR_OUTOFVIDEOMEMORY);
    if (lpD3DTexI->ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4)) {
        LPDIRECTDRAWPALETTE	lpDDPal;
        if (DD_OK != (ddrval=lpD3DTexI->lpDDSSys->GetPalette(&lpDDPal))) {
            lpD3DTexI->lpDDS->Release();
            lpD3DTexI->lpDDS=NULL;
            lpCachedTexture->lpD3DTexI=NULL;
            D3D_ERR("failed to check for palette on texture");
            return ddrval;
        } 
        if (DD_OK != (ddrval=lpD3DTexI->lpDDS->SetPalette(lpDDPal))){
            lpD3DTexI->lpDDS->Release();
            lpD3DTexI->lpDDS=NULL;
            lpCachedTexture->lpD3DTexI=NULL;
            D3D_ERR("SetPalette returned error");
            return ddrval;    
        }
        lpDDPal->Release();
    }
    if (DD_OK != (ddrval=CopySurface(lpD3DTexI->lpDDS,lpD3DTexI->lpDDSSys,NULL))){
        lpD3DTexI->lpDDS->Release();
        lpD3DTexI->lpDDS=NULL;
        lpCachedTexture->lpD3DTexI=NULL;
        D3D_ERR("CopySurface returned error");
        return ddrval;
    }
    lpD3DTexI->bDirty=FALSE;
    lpD3DTexI->lpTMBucket=lpCachedTexture;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::remove"

//remove all HW handles and release surface
void TextureCacheManager::remove(LPD3DBUCKET bucket)
{
    LPDIRECT3DTEXTUREI	lpD3DTexI=bucket->lpD3DTexI;
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&lpD3DTexI->blocks);
    while(tBlock){
        if (tBlock->hTex)
        {
            CLockD3DST lockObject(tBlock->lpDevI, DPF_MODNAME, REMIND(""));
            D3DHAL_TextureDestroy(tBlock);
        }
        tBlock=LIST_NEXT(tBlock,list);
    }
    D3D_INFO(7,"removing lpD3DTexI=%08lx lpDDS=%08lx",lpD3DTexI,lpD3DTexI->lpDDS);
    lpD3DTexI->lpDDS1Tex->Release();
    lpD3DTexI->lpDDS1Tex=NULL;
    lpD3DTexI->lpDDS->Release();
    lpD3DTexI->lpDDS=NULL;
    lpD3DTexI->lpTMBucket=NULL;
    bucket->lpD3DTexI=NULL;
    --numvidtex;
}

#undef DPF_MODNAME
#define DPF_MODNAME "TextureCacheManager::replace"

//remove any HW handle that's not with lpBlock->lpDevI,save lpBlock->hTex,keep surface
void TextureCacheManager::replace(LPD3DBUCKET bucket,LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&bucket->lpD3DTexI->blocks);
    while(tBlock){
        if (tBlock->hTex)
        {	
            if (tBlock->lpDevI == lpBlock->lpDevI)
            {
                lpBlock->hTex=tBlock->hTex;     //save it
                //flush before copy
                LPD3DBUCKET list = reinterpret_cast<LPD3DBUCKET>(((LPDDRAWI_DDRAWSURFACE_INT)(tBlock->lpD3DTextureI->lpDDS))->lpLcl->lpSurfMore->lpD3DDevIList);
                while(list != NULL)
                {
                    if(list->lpD3DDevI == tBlock->lpDevI)
                    {
                        if(tBlock->lpDevI->FlushStates() != D3D_OK)
                        {
                            D3D_ERR("Error trying to render batched commands in TextureCacheManager::replace");
                        }
                        break;
                    }
                    list = list->next;
                }
                tBlock->hTex=0;
            }
            else
            {
                CLockD3DST lockObject(tBlock->lpDevI, DPF_MODNAME, REMIND(""));
                D3DHAL_TextureDestroy(tBlock);
            }
        }
        tBlock=LIST_NEXT(tBlock,list);
    }
    D3D_INFO(7,"replacing lpDDS=%08lx from lpD3DTexI=%08lx",bucket->lpD3DTexI->lpDDS,bucket->lpD3DTexI);
}

void TextureCacheManager::EvictTextures()
{
    for(int i = 0; i < MAXLOGTEXSIZE;i++){
        LPD3DBUCKET	bucket=tcm_bucket[i];
        while(bucket){
            if (bucket->lpD3DTexI)
            {
                remove(bucket);
            }
            bucket=bucket->next;
        }
    }
}

void TextureCacheManager::cleanup()
{
    for(int i = 0; i < MAXLOGTEXSIZE;i++){
        for(LPD3DBUCKET bucket=tcm_bucket[i],last=NULL; bucket;){
            if (!bucket->lpD3DTexI){	//invalidated by Tex3I destructors ?
                LPD3DBUCKET	temp=bucket->next;
                D3DFreeBucket(lpDirect3DI,bucket);
                bucket=temp;
                if (last){	// Yes, but is this the first node on the list
                    last->next=bucket;
                }
                else
                {
                    tcm_bucket[i]=bucket;
                }
            }
            else{
                last=bucket;
                bucket=last->next;
            }   
        }
    }
}

BOOL TextureCacheManager::CheckIfLost()
{
    if(numvidtex)
    {
        for(int i = 0; i < MAXLOGTEXSIZE; ++i)
        {
            for(LPD3DBUCKET bucket = tcm_bucket[i]; bucket; bucket = bucket->next)
            {
                if(bucket->lpD3DTexI)
                {
                    if(((LPDDRAWI_DDRAWSURFACE_INT)(bucket->lpD3DTexI->lpDDS))->lpLcl->dwFlags & DDRAWISURF_INVALID)
                        return TRUE;
                    else
                        return FALSE;
                }
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\vertbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * 
 *  File:    vertbuf.cpp
 *  Content:    Direct3DVertexBuffer implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date    By    Reason
 *   ====    ==    ======
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "d3dfei.h"

const DWORD D3DVOP_RENDER = 1 << 31;
const DWORD D3DVBCAPS_VALID = D3DVBCAPS_SYSTEMMEMORY | 
                              D3DVBCAPS_WRITEONLY |
                              D3DVBCAPS_OPTIMIZED;

void hookVertexBufferToD3D(LPDIRECT3DI lpDirect3DI,
                                 LPDIRECT3DVERTEXBUFFERI lpVBufI)
{

    LIST_INSERT_ROOT(&lpDirect3DI->vbufs, lpVBufI, list);
    lpVBufI->lpDirect3DI = lpDirect3DI;

    lpDirect3DI->numVBufs++;
}

/*
 * Direct3DVertexBuffer::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::QueryInterface"

HRESULT D3DAPI CDirect3DVertexBuffer::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
#if DBG    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
        *ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
#endif    
    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DVertexBuffer) )
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3DVERTEXBUFFER>(this));
        return(D3D_OK);
    }
    else
    {
        D3D_ERR( "Don't know this riid" );
        return (E_NOINTERFACE);
    }
} /* CDirect3DVertexBuffer::QueryInterface */

/*
 * Direct3DVertexBuffer::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::AddRef"

ULONG D3DAPI CDirect3DVertexBuffer::AddRef()
{
    DWORD        rcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
#if DBG    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif    
    this->refCnt++;
    rcnt = this->refCnt;
    
    return (rcnt);
    
} /* Direct3DVertexBuffer::AddRef */

/*
  * Direct3DVertexBuffer::Release
  *
*/
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Release"

ULONG D3DAPI CDirect3DVertexBuffer::Release()
{
    DWORD            lastrefcnt;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
#if DBG    
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;
    
    if( lastrefcnt == 0 )
    {
        delete this;
        return 0;
    }
    
    return lastrefcnt;
    
} /* D3DTex3_Release */
//---------------------------------------------------------------------
// Internal version.
// No D3D lock, no checks
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBufferI"

HRESULT DIRECT3DI::CreateVertexBufferI(LPD3DVERTEXBUFFERDESC lpDesc, 
                                              LPDIRECT3DVERTEXBUFFER* lplpVBuf,
                                              DWORD dwFlags)
{
    CDirect3DVertexBuffer*     lpVBufI;
    HRESULT ret = D3D_OK;

    *lplpVBuf = NULL;

    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(new CDirect3DVertexBuffer(this));
    if (!lpVBufI) {
        D3D_ERR("failed to allocate space for vertex buffer");
        return (DDERR_OUTOFMEMORY);
    }

    if ((ret=lpVBufI->Init(this, lpDesc, dwFlags))!=D3D_OK)
    {
        D3D_ERR("Failed to initialize the vertex buffer object");
        delete lpVBufI;
        return ret;
    }
    *lplpVBuf = (LPDIRECT3DVERTEXBUFFER)lpVBufI;

    return(D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::CreateVertexBuffer"

HRESULT D3DAPI DIRECT3DI::CreateVertexBuffer(LPD3DVERTEXBUFFERDESC lpDesc, LPDIRECT3DVERTEXBUFFER* lplpVBuf,
        DWORD dwFlags, LPUNKNOWN pUnkOuter)
{
    if(pUnkOuter != NULL) {
        D3D_ERR("Unknown pointer should be NULL");
        return CLASS_E_NOAGGREGATION;
    }

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
#if DBG
    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpVBuf)) {
        D3D_ERR( "Invalid pointer to pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }
    if ((lpDesc->dwCaps & D3DVBCAPS_VALID) != lpDesc->dwCaps)
    {
        D3D_ERR("Invalid caps");
        return DDERR_INVALIDCAPS;
    }
    if (dwFlags & ~D3DDP_DONOTCLIP)
    {
        D3D_ERR("Invalid dwFlags");
        return DDERR_INVALIDPARAMS;
    }
#endif
    return CreateVertexBufferI(lpDesc, lplpVBuf, dwFlags);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::constructor"

CDirect3DVertexBuffer::CDirect3DVertexBuffer(LPDIRECT3DI lpD3DI)
{
    refCnt = 1;
    /*
     * Put this vertex buffer in the list of those owned by the
     * Direct3D object
     */
    hookVertexBufferToD3D(lpD3DI, this);
    srcVOP = dstVOP = dwPVFlags = position.dwStride = dwLockCnt = 0;
    legacyVertexType = (D3DVERTEXTYPE)0;
    position.lpvData = NULL;
    clipCodes = NULL;
    lpDDSVB = NULL;
    dwCaps = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::destructor"

CDirect3DVertexBuffer::~CDirect3DVertexBuffer()
{
    /*
    * Remove ourselves from the Direct3D object
    */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numVBufs--;
    delete [] clipCodes;
    if (lpDDSVB)
    {
        lpDDSVB->Release();
        lpDDS1VB->Release();
    }
}

/* Calculates the per vertex size in bytes based on the vertex ID
 * This function ignores the CLIPFLAGS field since it is allocated
 * separatly. 
 */
DWORD calcVertexSize(DWORD fvf)
{
    DWORD vertSize=0;
    static const BYTE nibble1[]={0, 0, 
                                  12, 12, 
                                  16, 16,
                                  0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    static const BYTE nibble2[]={0, 12, 4, 16, 4, 16, 8, 20, 4, 16, 8, 20, 8, 20, 12, 24};
#if DBG    
    if (fvf & D3DFVF_XYZ)
        vertSize += 12;
    else if (fvf & D3DFVF_XYZRHW)
        vertSize += 16;
    if (fvf & D3DFVF_NORMAL)
        vertSize += 12;
    if (fvf & D3DFVF_RESERVED1)
        vertSize += 4;
    if (fvf & D3DFVF_DIFFUSE)
        vertSize += 4;
    if (fvf & D3DFVF_SPECULAR)
        vertSize += 4;
#else
    vertSize = nibble1[fvf&0xf] + nibble2[(fvf>>4)&0xf];
#endif
    vertSize += ((fvf >> 8) & 0xf) << 3; // 8 * #textures
    return vertSize;
}
//---------------------------------------------------------------------
//
// Create the vertex memory buffer through DirectDraw
//
// Notes:
//    this->dwMemType should be set before calling this function
//    this->dwCaps should be set too.
//    this->dwMemType is set to DDSCAPS_VIDEOMEMORY is the VB was driver allocated
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::CreateMemoryBuffer"
HRESULT CDirect3DVertexBuffer::CreateMemoryBuffer(
    LPDIRECT3DI lpD3DI,
    LPDIRECTDRAWSURFACE4 *lplpSurface4,
    LPDIRECTDRAWSURFACE  *lplpSurface,
    LPVOID *lplpMemory,
    DWORD dwBufferSize,
    DWORD dwFlags)
{
    HRESULT ret;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = dwBufferSize; 
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
    ddsd.ddsCaps.dwCaps2 = this->dwMemType;

    // The meaning of DDSCAPS_VIDEOMEMORY and DDSCAPS_SYSTEMEMORY are
    // slightly different in case of VBs. the former only means that
    // the buffer is drivers allocated and could be in any memory type.
    // The latter means that the driver did not care to allocate VBs
    // hence they are always in DDraw allocated system memory.

    // The reason we try video memory followed by system memory 
    // (rather than simply not specifying the memory type) is for
    // drivers which do not care to do any special VB allocations, we
    // do not DDraw to take the Win16 lock for locking system memory
    // surfaces.

    if ((dwCaps & D3DVBCAPS_SYSTEMMEMORY) || !FVF_TRANSFORMED(fvf))
    {
        // This VB cannot reside in driver friendly memory for one of the following reasons:
        // 1. The app explicitly specified system memory
        // 2. The vertex buffer is untransformed - the driver will never see this VB
        D3D_INFO(8, "Trying to create a sys mem vertex buffer");
        ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ret = lpD3DI->lpDD4->CreateSurface(&ddsd, lplpSurface4, NULL);
        if (ret != DD_OK) 
        {
            D3D_ERR("Could not allocate the Vertex buffer.");
            return ret;
        }
    }
    else
    {
        // Try explicit video memory first
        ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        if (dwFlags & D3DDP_DONOTCLIP)
            ddsd.ddsCaps.dwCaps |= dwCaps & DDSCAPS_WRITEONLY;
        D3D_INFO(8, "Trying to create a vid mem vertex buffer");
        if (lpD3DI->lpDD4->CreateSurface(&ddsd, lplpSurface4, NULL) != DD_OK)
        {
            // If that failed, or user requested sys mem, try explicit system memory
            D3D_INFO(6, "Trying to create a sys mem vertex buffer");
            ddsd.ddsCaps.dwCaps &= ~(DDSCAPS_VIDEOMEMORY | DDSCAPS_WRITEONLY);
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            ret = lpD3DI->lpDD4->CreateSurface(&ddsd, lplpSurface4, NULL);
            if (ret != DD_OK) 
            {
                D3D_ERR("Could not allocate the Vertex buffer.");
                return ret;
            }
        }
        else
        {
            // Mark VB as REALLY in vid mem for Lock / Unlock optimizations
            this->dwMemType = DDSCAPS_VIDEOMEMORY;
        }
    }
    *lplpMemory = NULL;
    if (!(this->dwMemType & DDSCAPS_VIDEOMEMORY))
    {
        ret = (*lplpSurface4)->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock system memory Vertex Buffer.");
            return ret;
        }
        *lplpMemory = ddsd.lpSurface;
    }
    ret = lpDDSVB->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)lplpSurface);
    if (ret != DD_OK) 
    {
        D3D_ERR("failed to QI for DDS1");
        return ret;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::init"

HRESULT CDirect3DVertexBuffer::Init(LPDIRECT3DI lpD3DI, LPD3DVERTEXBUFFERDESC lpDesc, DWORD dwFlags)
{
    HRESULT ret;
    
    bReallyOptimized = FALSE;
    dwCaps = lpDesc->dwCaps;
    fvf = lpDesc->dwFVF;
    dwNumVertices = lpDesc->dwNumVertices;
    if (dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("Direct3D for DirectX 6.0 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    if (lpDesc->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("D3DVBCAPS_OPTIMIZED flag should not be set");
        return DDERR_INVALIDPARAMS;
    }
    if (fvf & 0xfffff000) // Higher order 20 bits must be zero for DX6
    {
        D3D_ERR("Invalid FVF id");
        return D3DERR_INVALIDVERTEXFORMAT;
    }
    nTexCoord = FVF_TEXCOORD_NUMBER(fvf);
    if ((position.dwStride = calcVertexSize(fvf)) == 0)
    {
        D3D_ERR("Vertex size is zero according to the FVF id");
        return D3DERR_INVALIDVERTEXFORMAT;
    }

    if (dwFlags & D3DVBFLAGS_CREATEMULTIBUFFER)
        dwMemType = 0;
    else
        dwMemType = DDSCAPS2_VERTEXBUFFER;
    ret = CreateMemoryBuffer(lpD3DI, &lpDDSVB, &lpDDS1VB, &position.lpvData, 
                             position.dwStride * dwNumVertices, dwFlags);
    if (ret != D3D_OK)
        return ret;

    /* Classify the operations that can be done using this VB */
    if ((fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZ)
    {
        D3D_INFO(4, "D3DFVF_XYZ set. Can be source VB for Transform");
        srcVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS | D3DVOP_CLIP;
    }
    else if ((fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
    {
        D3D_INFO(4, "D3DFVF_XYZRHW set. Can be dest VB for Transform");
        dstVOP = D3DVOP_TRANSFORM | D3DVOP_EXTENTS;
        srcVOP |= D3DVOP_EXTENTS;
        if ((dwFlags & D3DDP_DONOTCLIP) == 0)
        {
            clipCodes = new D3DFE_CLIPCODE[dwNumVertices];
            if (clipCodes == NULL)
            {
                D3D_ERR("Could not allocate space for clip flags");
                return DDERR_OUTOFMEMORY;
            }
            memset(clipCodes, 0, dwNumVertices * sizeof(D3DFE_CLIPCODE));
            dstVOP |= D3DVOP_CLIP;
        }
    }
    if (fvf & D3DFVF_NORMAL)
    {
        D3D_INFO(4, "D3DFVF_NORMAL set.");
        if (srcVOP & D3DVOP_TRANSFORM)
        {
            D3D_INFO(4, "Can be src VB for lighting.");
            srcVOP |= D3DVOP_LIGHT;
        }
        this->dwPVFlags |= D3DPV_LIGHTING;
    }
    if (fvf & D3DFVF_DIFFUSE)
    {
        D3D_INFO(4, "D3DFVF_DIFFUSE set. Can be dest VB for lighting");
        dstVOP |= D3DVOP_LIGHT;
    }
    if (dstVOP & D3DVOP_TRANSFORM)
    {
        D3D_INFO(4, "VB can be rendered");
        srcVOP |= D3DVOP_RENDER;
    }

    /* Compare with legacy vertex types */
    if (fvf == D3DFVF_VERTEX)
    {
        legacyVertexType = D3DVT_VERTEX;
    }
    else if (fvf == D3DFVF_LVERTEX)
    {
        legacyVertexType = D3DVT_LVERTEX;
    }
    else if (fvf == D3DFVF_TLVERTEX)
    {
        legacyVertexType = D3DVT_TLVERTEX;
    }
    return(D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Lock"

HRESULT D3DAPI CDirect3DVertexBuffer::Lock(DWORD dwFlags, LPVOID* lplpData, DWORD* lpdwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
    HRESULT ret;
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (IsBadWritePtr( lplpData, sizeof(LPVOID))) {
            D3D_ERR( "Invalid lpData pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (lpdwSize)
            if (IsBadWritePtr( lpdwSize, sizeof(DWORD))) {
                D3D_ERR( "Invalid lpData pointer" );
                return DDERR_INVALIDPARAMS;
            }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif
    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("Cannot lock optimized vertex buffer");
        return(D3DERR_VERTEXBUFFEROPTIMIZED);
    }

    return this->LockI(dwFlags, lplpData, lpdwSize);

}
//---------------------------------------------------------------------
// Side effect:
//      position.lpvData is set.
//
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::LockI"

HRESULT D3DAPI CDirect3DVertexBuffer::LockI(DWORD dwFlags, LPVOID* lplpData, 
                                            DWORD* lpdwSize)
{
    HRESULT ret;

    if (lpdwSize)
        *lpdwSize = position.dwStride * dwNumVertices;

    if (position.lpvData)
    {
        *lplpData = position.lpvData;
    }
    else
    {
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ret = lpDDSVB->Lock(NULL, &ddsd, dwFlags | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock vertex buffer.");
            return ret;
        }
        *lplpData = ddsd.lpSurface;
        position.lpvData = ddsd.lpSurface;
    }
    dwLockCnt++;
    D3D_INFO(6, "VB Lock: %lx Lock Cnt =%d", this, dwLockCnt);
    if (lpDevIBatched && !(dwFlags & DDLOCK_READONLY))
    {
        ret = lpDevIBatched->FlushStates();
        lpDevIBatched = NULL;
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not flush batch referring to VB during Lock");
            return ret;
        }
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::Unlock"

HRESULT D3DAPI CDirect3DVertexBuffer::Unlock()
{
    if (dwLockCnt)
    {
        dwLockCnt--;
        if ((dwMemType & DDSCAPS_VIDEOMEMORY) && (dwLockCnt == 0))
        {
            position.lpvData = NULL;
            D3D_INFO(6, "VB Unlock: %lx Lock Cnt =%d", this, dwLockCnt);
            return lpDDSVB->Unlock(NULL);
        }
    }
    D3D_INFO(6, "VB Unlock: %lx Lock Cnt =%d", this, dwLockCnt);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::GetVertexBufferDesc"

HRESULT D3DAPI CDirect3DVertexBuffer::GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC lpDesc)
{
#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (IsBadWritePtr( lpDesc, lpDesc->dwSize)) {
            D3D_ERR( "Invalid lpData pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (! VALID_D3DVERTEXBUFFERDESC_PTR(lpDesc) )
        {
            D3D_ERR( "Invalid D3DVERTEXBUFFERDESC" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
#endif
    lpDesc->dwCaps = dwCaps;
    lpDesc->dwFVF = fvf;
    lpDesc->dwNumVertices = this->dwNumVertices;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DVertexBuffer::ProcessVertices"

HRESULT D3DAPI CDirect3DVertexBuffer::ProcessVertices(DWORD vertexOP, DWORD dwDstIndex, DWORD dwCount, 
                                                      LPDIRECT3DVERTEXBUFFER lpSrc, 
                                                      DWORD dwSrcIndex, 
                                                      LPDIRECT3DDEVICE3 lpDevice, DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpSrcI;
    LPDIRECT3DDEVICEI lpDevI;

#if DBG
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpSrc)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
        if (!VALID_DIRECT3DDEVICE3_PTR(lpDevice)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (dwFlags != 0 ||
        (dwDstIndex + dwCount) > this->dwNumVertices ||
        (dwSrcIndex + dwCount) > lpSrcI->dwNumVertices)
    {
        D3D_ERR( "Invalid parameters" );
        return DDERR_INVALIDPARAMS;
    }

    /* Validate Src & Dst Vertex Formats */
    if ((lpSrcI->srcVOP & vertexOP) != vertexOP)
    {
        D3D_ERR("Source VB cannot support this operation");
        return D3DERR_INVALIDVERTEXFORMAT;
    }
    if (!(vertexOP & D3DVOP_TRANSFORM))
    {
        D3D_ERR("D3DVOP_TRANSFORM flag should be set");
        return DDERR_INVALIDPARAMS;
    }

    if ((dstVOP & vertexOP) != vertexOP)
    {
        D3D_ERR("Destination VB cannot support this operation");
        return D3DERR_INVALIDVERTEXFORMAT;
    }

    if (this->fvf & D3DFVF_NORMAL)
    {

        D3D_ERR("The destination vertex buffer cannot have normals");
        return D3DERR_INVALIDVERTEXFORMAT;
    }
#else
    lpSrcI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpSrc);
    lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
#endif

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    // Fill the D3DFE_PROCESSVERTICES structure
    // STRIDE and SOA flags
    lpDevI->dwFlags = lpSrcI->dwPVFlags & D3DPV_SOA;
    // LIGHTING, EXTENTS and CLIP flags (note extents and clip flags are inverted)
    // Currently transform is always done
    lpDevI->dwFlags |= (vertexOP ^ (D3DVOP_CLIP | D3DVOP_EXTENTS)) | D3DVOP_TRANSFORM;

    HRESULT ret;

    // Download viewport ??
    if (lpDevI->v_id != lpDevI->lpCurrentViewport->v_id)
    {
        ret = downloadView(lpDevI->lpCurrentViewport);
        if (ret != D3D_OK)
            return ret;
    }

    // Num vertices
    lpDevI->dwNumVertices = dwCount;

    // Lock the VBs
    LPVOID lpVoid;
    ret = LockI(DDLOCK_WAIT, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }
    ret = lpSrcI->LockI(DDLOCK_WAIT | DDLOCK_READONLY, &lpVoid, NULL);
    if (ret != D3D_OK)
    {
        D3D_ERR("Could not lock the vertex buffer");
        return ret;
    }

    // Output
    lpDevI->lpvOut = LPVOID(LPBYTE(position.lpvData) + dwDstIndex * position.dwStride);
    lpDevI->lpClipFlags = clipCodes + dwDstIndex;
    lpDevI->dwVIDIn = lpSrcI->fvf;
    lpDevI->dwVIDOut = fvf;

    if (lpSrcI->legacyVertexType && legacyVertexType)
    { // AOS Legacy
        /* We can use the legacy FE codepaths which might
         * be faster
         */
        lpDevI->position.lpvData = LPVOID(LPBYTE(lpSrcI->position.lpvData) + dwSrcIndex * lpSrcI->position.dwStride);
        lpDevI->nTexCoord = 1;
        lpDevI->position.dwStride = lpSrcI->position.dwStride;
        lpDevI->dwOutputSize = position.dwStride;
    }
    else
    {
        lpDevI->nTexCoord = min(nTexCoord, lpSrcI->nTexCoord);
        if (lpSrcI->bReallyOptimized)
        { // SOA
          // Assume that SOA.lpvData is the same as position.lpvData
            lpDevI->SOA.lpvData = lpSrcI->position.lpvData;
            lpDevI->SOA.dwStride = lpSrcI->dwNumVertices;
            lpDevI->dwSOAStartVertex = dwSrcIndex;
            lpDevI->dwOutputSize = position.dwStride;
        }
        else
        { // AOS FVF
            lpDevI->dwOutputSize = position.dwStride;
            lpDevI->position.lpvData = LPVOID(LPBYTE(lpSrcI->position.lpvData) + dwSrcIndex * lpSrcI->position.dwStride);
            lpDevI->position.dwStride = lpSrcI->position.dwStride;
        }
    }
    lpDevI->dwFlags |= D3DPV_VBCALL;
    D3DFE_ProcessVertices(lpDevI);
    if (!(lpDevI->dwFlags & D3DDP_DONOTCLIP))
        D3DFE_UpdateClipStatus(lpDevI);
    // Unlock the VBs
    Unlock();
    lpSrcI->Unlock();
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IDirect3DDevice3::DrawIndexedPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType, 
                                                       LPDIRECT3DVERTEXBUFFER lpVBuf, 
                                                       LPWORD lpwIndices, DWORD dwIndexCount, 
                                                       DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
    HRESULT ret;
#if DBG
    /* 
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpVBuf)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (!IsDPFlagsValid(dwFlags))
    {
        D3D_ERR("Invalid Flags in dwFlags field");
        return DDERR_INVALIDPARAMS;
    }
    if (!(IS_HW_DEVICE(this) || (lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY)))
    {
        D3D_ERR("Cannot use vid mem vertex buffers with SW devices");
        return DDERR_INVALIDPARAMS;
    }
    if (lpVBufI->dwLockCnt)
    {
        D3D_ERR("Cannot render using a locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (this->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater that 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }

    Profile(PROF_DRAWINDEXEDPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#else
    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = lpVBufI->dwNumVertices;
    this->dwNumIndices = dwIndexCount;
    this->lpwIndices = lpwIndices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE; // Need to call UpdateTextures()
    if (lpVBufI->srcVOP & D3DVOP_RENDER)
    { // TLVERTEX
#if DBG
        if (lpVBufI->fvf & D3DFVF_NORMAL)
        {

            D3D_ERR("The vertex buffer cannot be processed");
            D3D_ERR("It has XYZRHW position type and normals");
            return DDERR_INVALIDPARAMS;
        }
#endif
        this->dwOutputSize = lpVBufI->position.dwStride;
        this->dwVIDOut = lpVBufI->fvf;
        this->dwVIDIn = lpVBufI->fvf;
        // needed for legacy drivers' DrawIndexPrim code
        this->lpvOut = lpVBufI->position.lpvData;
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, 0);
            lpVBufI->lpDevIBatched = this;
             if (ret != D3D_OK)
                return ret;
        }
        else
        {
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, TRUE);
        }
        if (dwFlags & D3DDP_DONOTCLIP)
        {
            return DrawIndexPrim();
        }
        else
        {
            this->lpClipFlags = lpVBufI->clipCodes;
            this->dwClipUnion = ~0; // Force clipping
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = ddsd.lpSurface;

                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret = CheckDrawIndexedPrimitive(this);
                if (ret == D3D_OK)
                    ret = DoDrawIndexedPrimitive(this);
#else
                ret = DoDrawIndexedPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret = CheckDrawIndexedPrimitive(this);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawIndexedPrimitive(this);
            }
        }
    }
    else
    { 
        this->dwVIDIn = lpVBufI->fvf;
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = 0;
        }
        else
        {
            this->position = lpVBufI->position;
        }
        ComputeOutputFVF(this);
#if DBG    
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
            return ret;
#endif
        return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM); 
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice3::DrawPrimitiveVB"

HRESULT D3DAPI DIRECT3DDEVICEI::DrawPrimitiveVB(D3DPRIMITIVETYPE dptPrimitiveType, 
                                                LPDIRECT3DVERTEXBUFFER lpVBuf, 
                                                DWORD dwStartVertex, DWORD dwNumVertices, 
                                                DWORD dwFlags)
{
    LPDIRECT3DVERTEXBUFFERI lpVBufI;

    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock
    HRESULT ret;
#if DBG
    /* 
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(lpVBuf)) {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
        if (!VALID_DIRECT3DDEVICE3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (!IsDPFlagsValid(dwFlags) ||
        (dwStartVertex + dwNumVertices) > lpVBufI->dwNumVertices)
        return DDERR_INVALIDPARAMS;
    if (!(IS_HW_DEVICE(this) || (lpVBufI->dwCaps & D3DVBCAPS_SYSTEMMEMORY)))
    {
        D3D_ERR("Cannot use vid mem vertex buffers with SW devices");
        return DDERR_INVALIDPARAMS;
    }
    if (lpVBufI->dwLockCnt)
    {
        D3D_ERR("Cannot render using a locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
    if (dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }
    Profile(PROF_DRAWPRIMITIVEVB,dptPrimitiveType,lpVBufI->fvf);
#else
    lpVBufI = static_cast<LPDIRECT3DVERTEXBUFFERI>(lpVBuf);
#endif
    this->dwFlags = dwFlags | lpVBufI->dwPVFlags;
    this->primType = dptPrimitiveType;
    this->dwNumVertices = dwNumVertices;
    this->dwNumIndices = 0;
    this->lpwIndices = NULL;
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats
    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE; // Need to call UpdateTextures()
    if (lpVBufI->srcVOP & D3DVOP_RENDER)
    { // TLVERTEX
#if DBG
        if (lpVBufI->fvf & D3DFVF_NORMAL)
        {

            D3D_ERR("The vertex buffer cannot be processed");
            D3D_ERR("It has XYZRHW position type and normals");
            return DDERR_INVALIDPARAMS;
        }
#endif
        this->dwOutputSize = lpVBufI->position.dwStride;
        this->dwVIDOut = lpVBufI->fvf;
        // needed for legacy drivers' DrawPrim code
        this->lpvOut = (BYTE*)(lpVBufI->position.lpvData) + 
                       dwStartVertex * this->dwOutputSize;
        if (IS_DP2HAL_DEVICE(this))
        {
            this->nTexCoord = lpVBufI->nTexCoord;
            CDirect3DDeviceIDP2 *dev = static_cast<CDirect3DDeviceIDP2*>(this);
            ret = dev->StartPrimVB(lpVBufI, dwStartVertex);
            lpVBufI->lpDevIBatched = this;
            if (ret != D3D_OK)
                return ret;
        }
        else
        {
            ComputeTCI2CopyLegacy(this, lpVBufI->nTexCoord, TRUE);
        }
        if (dwFlags & D3DDP_DONOTCLIP)
        {
            return DrawPrim();
        }
        else
        {
            this->lpClipFlags = lpVBufI->clipCodes + dwStartVertex;
            this->dwClipUnion = ~0; // Force clipping
            // If lpvData is NULL, it is a driver allocated buffer which
            // means IS_DPHAL_DEVICE() is true.
            // We need to lock such a buffer only if we need to clip
            if (!lpVBufI->position.lpvData)
            {
                // Lock VB
                DDSURFACEDESC2 ddsd;
                memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
                ddsd.dwSize = sizeof(DDSURFACEDESC2);
                ret = lpVBufI->lpDDSVB->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_READONLY | DDLOCK_NOSYSLOCK, NULL);
                if (ret != DD_OK)
                {
                    D3D_ERR("Could not lock vertex buffer.");
                    return ret;
                }
                this->lpvOut = (BYTE*)(ddsd.lpSurface) + 
                               dwStartVertex * this->dwOutputSize;

                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret=CheckDrawPrimitive(this);
                if (ret == D3D_OK)
                    ret = DoDrawPrimitive(this);
#else
                ret = DoDrawPrimitive(this);
#endif
                // Unlock VB
                if (ret == D3D_OK)
                    return lpVBufI->lpDDSVB->Unlock(NULL);
                else
                    lpVBufI->lpDDSVB->Unlock(NULL);
                return ret;
            }
            else
            {
                // Draw with clipping
#if DBG
                // To Do: Check vertices & clip flags against current viewport
                this->position.lpvData = this->lpvOut;  // Otherwise the check will fail
                ret=CheckDrawPrimitive(this);
                if (ret != D3D_OK)
                    return ret;
#endif
                return DoDrawPrimitive(this);
            }
        }
    }
    else
    { 
        this->dwVIDIn = lpVBufI->fvf;
        if (lpVBufI->bReallyOptimized)
        {
           // Assume that SOA.lpvData is the same as position.lpvData
            this->SOA.lpvData = lpVBufI->position.lpvData;
            this->SOA.dwStride = lpVBufI->dwNumVertices;
            this->dwSOAStartVertex = dwStartVertex;
        }
        else
        {
            this->position.lpvData = (BYTE*)(lpVBufI->position.lpvData) + 
                                     dwStartVertex * lpVBufI->position.dwStride;
            this->position.dwStride = lpVBufI->position.dwStride;
        }
        ComputeOutputFVF(this);
#if DBG    
        ret=CheckDrawPrimitive(this);
        if (ret != D3D_OK)
            return ret;
#endif
        return this->ProcessPrimitive(); 
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DVertexBuffer::Optimize"

HRESULT D3DAPI CDirect3DVertexBuffer::Optimize(LPDIRECT3DDEVICE3 lpDevice, DWORD dwFlags)
{
    HRESULT ret;
    LPDIRECT3DDEVICEI lpDevI;

// Validate parms
//
    TRY
    {
        if (!VALID_DIRECT3DVERTEXBUFFER_PTR(this)) 
        {
            D3D_ERR( "Invalid Direct3DVertexBuffer pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DIRECT3DDEVICE3_PTR(lpDevice)) 
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }
        lpDevI = static_cast<LPDIRECT3DDEVICEI>(lpDevice);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }
    if (dwFlags != 0)
    {
        D3D_ERR("dwFlags should be zero");
        return DDERR_INVALIDPARAMS;
    }

    CLockD3DMT lockObject(lpDevI, DPF_MODNAME, REMIND(""));  

    if (this->dwCaps & D3DVBCAPS_OPTIMIZED)
    {
        D3D_ERR("The vertex buffer already optimized");
        return D3DERR_VERTEXBUFFEROPTIMIZED;
    }
    if (this->dwLockCnt != 0)
    {
        D3D_ERR("Could not optimize locked vertex buffer");
        return D3DERR_VERTEXBUFFERLOCKED;
    }
// Do nothing for transformed vertices 
    if ((this->fvf & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
    {
        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
        return D3D_OK;
    }
// Get the buffer size to allocate
    DWORD bufferSize = lpDevI->pGeometryFuncs->ComputeOptimizedVertexBufferSize
                                                (this->fvf, this->position.dwStride, 
                                                 dwNumVertices);
// Create new surfaces for optimized vertex buffer
    if (bufferSize == 0)
    {
        this->dwCaps |= D3DVBCAPS_OPTIMIZED;
        return D3D_OK;
    }
    LPDIRECTDRAWSURFACE4 lpSurface4; 
    LPDIRECTDRAWSURFACE  lpSurface; 
    LPVOID lpMemory;

    ret = CreateMemoryBuffer(lpDevI->lpDirect3DI, &lpSurface4, &lpSurface, 
                             &lpMemory, bufferSize, 
                             clipCodes ? 0 : D3DDP_DONOTCLIP);
    if (ret != D3D_OK)
        return ret;
// Try to optimize
// If optimized vertex buffer are not supported by the implementation
// it returns E_NOTIMPL. In this case we still set D3DVBCAPS_OPTIMIZED to prevent
// locking of the vertex buffer. But bReallyOptimized is set to FALSE, to use 
// the original buffer.
    ret = lpDevI->pGeometryFuncs->OptimizeVertexBuffer
        (fvf, dwNumVertices, position.dwStride, position.lpvData, 
         lpMemory, dwFlags);

    if (ret)
    {
        lpSurface4->Release();
        lpSurface->Release();
        if (ret == E_NOTIMPL)
        {
            this->dwCaps |= D3DVBCAPS_OPTIMIZED;
            return D3D_OK;
        }
        else
        {
            D3D_ERR("Failed to optimize vertex buffer");
            return ret;
        }
    }
    bReallyOptimized = TRUE;
    legacyVertexType = (D3DVERTEXTYPE)0;
    this->dwPVFlags |= D3DPV_SOA;
    this->dwCaps |= D3DVBCAPS_OPTIMIZED;
// Destroy old surfaces
    lpDDSVB->Release();
    lpDDS1VB->Release();
// And use new ones
    lpDDSVB = lpSurface4;
    lpDDS1VB = lpSurface;
    position.lpvData = lpMemory;
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\vwiunk.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   texiunk.c
 *  Content:    Direct3DViewport IUnknown implementation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DVwp_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::QueryInterface"

HRESULT D3DAPI DIRECT3DVIEWPORTI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(ppvObj)) {
            D3D_ERR( "Invalid pointer to pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *ppvObj = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IDirect3DViewport) ||
       IsEqualIID(riid, IID_IDirect3DViewport2) ||
       IsEqualIID(riid, IID_IDirect3DViewport3))
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        ret = D3D_OK;
    }
    else
        ret = E_NOINTERFACE;
    return ret;
} /* D3DVwp_QueryInterface */

/*
 * D3DVwp_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::AddRef"

ULONG D3DAPI DIRECT3DVIEWPORTI::AddRef()
{
    DWORD       rcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    this->refCnt++;
    rcnt = this->refCnt;

    return (rcnt);
} /* D3DVwp_AddRef */

/*
 * D3DVwp_Release
 *
 */
ULONG D3DAPI DIRECT3DVIEWPORTI::Release()
{
    DWORD           lastrefcnt;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return 0;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return 0;
    }

    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    lastrefcnt = this->refCnt;

    if( lastrefcnt == 0 ) {
        delete this;
        return 0;
    }
    return lastrefcnt;
} /* D3DVwp_Release */

DIRECT3DVIEWPORTI::~DIRECT3DVIEWPORTI()
{
    LPDIRECT3DLIGHTI lpLightI;

    /*
     * Drop all the lights currently associated with the viewport.
     */
    while ((lpLightI = CIRCLE_QUEUE_FIRST(&this->lights)) &&
           (lpLightI != (LPDIRECT3DLIGHTI)&this->lights)) {
        DeleteLight((LPDIRECT3DLIGHT)lpLightI);
    }

    /*
     * Deallocate rects used for clearing.
     */
    if (this->clrRects) {
        D3DFree(this->clrRects);
    }

    // remove us from our device
    if (this->lpDevI) 
        this->lpDevI->DeleteViewport(this);

    /* remove us from the Direct3D object list of viewports */
    LIST_DELETE(this, list);
    this->lpDirect3DI->numViewports--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\vwport.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vwport.c
 *  Content:    Direct3D viewport functions
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: vwport.c,v 1.25 1995/12/04 11:29:49 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3DViewport object
 */

#include "d3dfei.h"
#include "drawprim.hpp"

extern void UpdateViewportCache(LPDIRECT3DDEVICEI device, D3DVIEWPORT2 *data);

//---------------------------------------------------------------------
//
// Compute inverse Mclip matrix
//
void updateInverseMclip(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_VIEWPORTCACHE& VPORT = lpDevI->vcache;
    VPORT.imclip11 = D3DVAL(1)/VPORT.mclip11;
    VPORT.imclip41 = - VPORT.imclip11 * VPORT.mclip41;
    VPORT.imclip22 = D3DVAL(1)/VPORT.mclip22;
    VPORT.imclip42 = - VPORT.imclip22 * VPORT.mclip42;
    VPORT.imclip33 = D3DVAL(1)/VPORT.mclip33;
    VPORT.imclip43 = VPORT.imclip33 * VPORT.mclip43;
}
//---------------------------------------------------------------------
HRESULT downloadView(LPDIRECT3DVIEWPORTI lpViewI)
{
    HRESULT     err;

    if (!lpViewI->v_data_is_set)
    {
        D3D_ERR("SetViewport not called for viewport yet");
        return D3DERR_VIEWPORTDATANOTSET;
    }

    LPDIRECT3DDEVICEI lpDevI = lpViewI->lpDevI;

        // Update front-end data
    UpdateViewportCache(lpDevI, &lpViewI->v_data);

    // Download viewport data
    if ((err = lpDevI->UpdateDrvViewInfo(&lpViewI->v_data)) != DD_OK)
    {
        return err;
    }

    lpViewI->bLightsChanged = TRUE;         // Force setLights call
    lpDevI->v_id = lpViewI->v_id;

    return (D3D_OK);
}
//---------------------------------------------------------------------
// Viewport ID could be different from Device->v_id, because during Execute call
// Device->v_id is changed to whatever viewport is used as a parameter.
// So we have to make sure that we use the right viewport.
//
inline HRESULT ValidateViewport(LPDIRECT3DDEVICEI lpDevI,
                                LPDIRECT3DVIEWPORTI lpView)
{
#if DBG
    if (!VALID_DIRECT3DDEVICE3_PTR(lpDevI)) {
        D3D_ERR( "Viewport not attached to Device" );
        return D3DERR_VIEWPORTHASNODEVICE;
    }
#endif

    if (lpDevI->v_id != lpView->v_id)
    {
        return downloadView(lpView);
    }
    else
        return D3D_OK;
}

HRESULT hookViewportToD3D(LPDIRECT3DI lpDirect3DI,
                                 LPDIRECT3DVIEWPORTI lpD3DView)
{

    LIST_INSERT_ROOT(&lpDirect3DI->viewports, lpD3DView, list);
    lpD3DView->lpDirect3DI = lpDirect3DI;

    lpDirect3DI->numViewports++;

    return (D3D_OK);
}

HRESULT D3DAPI DIRECT3DVIEWPORTI::Initialize(LPDIRECT3D lpD3D)
{
    return DDERR_ALREADYINITIALIZED;
}

/*
 * Light Management
 */
HRESULT hookLightToViewport(LPDIRECT3DVIEWPORTI lpD3DViewI,
                                   LPDIRECT3DLIGHTI lpD3DLight)
{

    CIRCLE_QUEUE_INSERT_END(&lpD3DViewI->lights, DIRECT3DLIGHTI, lpD3DLight,
                            light_list);
    lpD3DLight->lpD3DViewportI = lpD3DViewI;

    lpD3DViewI->numLights++;

    return (D3D_OK);
}

HRESULT setLights(LPDIRECT3DVIEWPORTI lpView)
{
    LPDIRECT3DDEVICEI   lpDevI;
    LPDIRECT3DLIGHTI    lpD3DLightI;
    int         i;

    lpDevI = lpView->lpDevI;

    lpD3DLightI = (LPDIRECT3DLIGHTI)CIRCLE_QUEUE_FIRST(&lpView->lights);

    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    LIGHTING.activeLights = NULL;

    // Set lights in the device
    for (i = 0; i < lpView->numLights; i++)
    {
        if (lpD3DLightI->diLightData.valid &&
            lpD3DLightI->diLightData.flags & D3DLIGHT_ACTIVE)
        {
            lpD3DLightI->diLightData.next = LIGHTING.activeLights;
            LIGHTING.activeLights = &lpD3DLightI->diLightData;
        }
        lpD3DLightI = CIRCLE_QUEUE_NEXT(&lpView->lights,lpD3DLightI,light_list);
    }
    lpDevI->dwFEFlags |= (D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_LIGHTS_DIRTY);

    return (D3D_OK);
}

/*
 * Create the Viewport
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateViewport"

HRESULT D3DAPI DIRECT3DI::CreateViewport(LPDIRECT3DVIEWPORT* lplpD3DView,
                                         IUnknown *pUnkOuter)
{
    return CreateViewport((LPDIRECT3DVIEWPORT3*)lplpD3DView, NULL);
}

HRESULT D3DAPI DIRECT3DI::CreateViewport(LPDIRECT3DVIEWPORT2* lplpD3DView2,
                                         IUnknown *pUnkOuter)
{
    return CreateViewport((LPDIRECT3DVIEWPORT3*)lplpD3DView2, NULL);
}

HRESULT D3DAPI DIRECT3DI::CreateViewport(LPDIRECT3DVIEWPORT3* lplpD3DView,
                                         IUnknown *pUnkOuter)
{
    LPDIRECT3DVIEWPORTI     lpView;
    HRESULT ret = D3D_OK;

    if(pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    if (!VALID_DIRECT3D3_PTR(this)) {
        D3D_ERR( "Invalid Direct3D pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpD3DView)) {
        D3D_ERR( "Invalid pointer to pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3DView = NULL;

    lpView = new DIRECT3DVIEWPORTI(this);

    if (!lpView) {
        D3D_ERR("failed to allocate space for object");
        return (DDERR_OUTOFMEMORY);
    }

    /*
     * Put this device in the list of those owned by the
     * Direct3D object
     */
    ret = hookViewportToD3D(this, lpView);
    if (ret != D3D_OK) {
        D3D_ERR("failed to associate viewport to Direct3D");
        delete lpView;
        return (ret);
    }
    *lplpD3DView = (LPDIRECT3DVIEWPORT3)lpView;

    return (D3D_OK);
}

DIRECT3DVIEWPORTI::DIRECT3DVIEWPORTI(LPDIRECT3DI lpD3DI)
{
    /*
     * setup the object
     */
    /*** Object Data ***/
    memset(&v_data, 0, sizeof(D3DVIEWPORT2));
    v_data_is_set = FALSE;
    bHaveBackgndMat=FALSE;
    hBackgndMat=NULL;
    lpDDSBackgndDepth=NULL;
    clrCount=0;
    clrRects=NULL;

    refCnt = 1;
    lpDevI=NULL;
    v_id = lpD3DI->v_next++;

    /*
     * Initialise lights
     */
    numLights = 0;
    CIRCLE_QUEUE_INITIALIZE(&lights, DIRECT3DLIGHTI);

    /*
     * Make sure that lights are always downloaded the first time
     */
    bLightsChanged = TRUE;

}

/*
 * IDirect3DViewport members
 */

/*
 * Transform
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetViewport"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetViewport(LPD3DVIEWPORT lpData)
{
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    D3DVIEWPORT2 v;
    if (lpData->dvScaleX == 0.0f || lpData->dvScaleY == 0.0f)
    {
        D3D_ERR( "Invalid viewport data" );
        v.dvClipWidth = 0.0f;
        v.dvClipHeight = 0.0f;
    }
    else
    {
        v.dvClipWidth = lpData->dwWidth / lpData->dvScaleX;
        v.dvClipHeight = lpData->dwHeight / lpData->dvScaleY;
    }
    /* Convert D3DVIEWPORT to D3DVIEWPORT2 */
    v.dwSize = sizeof(D3DVIEWPORT2);
    v.dwX = lpData->dwX;
    v.dwY = lpData->dwY;
    v.dwWidth = lpData->dwWidth;
    v.dwHeight = lpData->dwHeight;
    v.dvClipX = -v.dvClipWidth/2.0f;
    v.dvClipY = v.dvClipHeight/2.0f;
    v.dvMinZ = 0.0f;
    v.dvMaxZ = 1.0f;
    ret = SetViewport2(&v);
    return ret;
}

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetViewport2(LPD3DVIEWPORT2 lpData)
{
    HRESULT err;
    DWORD uSurfWidth,uSurfHeight;
    LPDIRECTDRAWSURFACE lpDDS;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport2 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT2 pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!VALID_DIRECT3DDEVICE3_PTR(this->lpDevI)) {
        D3D_ERR( "Viewport not attached to Device" );
        return D3DERR_VIEWPORTHASNODEVICE;
    }

    if (IS_DX5_COMPATIBLE_DEVICE(this->lpDevI))
    { /* we're called directly by dx5 app, so validate params */
        if (lpData->dvClipWidth == 0.0f || lpData->dvClipHeight == 0.0f ||
            lpData->dvMinZ == lpData->dvMaxZ)
        {
            D3D_ERR( "Invalid viewport data" );
            return DDERR_INVALIDPARAMS;
        }

        lpDDS = this->lpDevI->lpDDSTarget;

        uSurfWidth=    ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
        uSurfHeight=   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;

        if (lpData->dwX > uSurfWidth ||
            lpData->dwY > uSurfHeight ||
            lpData->dwX + lpData->dwWidth > uSurfWidth ||
            lpData->dwY + lpData->dwHeight > uSurfHeight)
        {
            D3D_ERR("Viewport outside the render target surface");
            return DDERR_INVALIDPARAMS;
        }
    }

    this->v_data = *lpData;
    this->v_data_is_set = TRUE;
    // If this is the last rendered viewport, update its device
    if (this->v_id == this->lpDevI->v_id)
    {
        err = downloadView(this);
        if (err != D3D_OK)
        {
            return err;
        }
    }

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetViewport"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetViewport(LPD3DVIEWPORT lpData)
{
    HRESULT ret;
    D3DVIEWPORT2 v;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }
    v.dwSize = sizeof(D3DVIEWPORT2);
    ret = GetViewport2(&v);
    /* Convert D3DVIEWPORT2 to D3DVIEWPORT */
    lpData->dwSize = sizeof(D3DVIEWPORT);
    lpData->dwX = v.dwX;
    lpData->dwY = v.dwY;
    lpData->dwWidth = v.dwWidth;
    lpData->dwHeight = v.dwHeight;
    lpData->dvMinZ = 0.0f;
    lpData->dvMaxZ = 1.0f;
    lpData->dvScaleX = v.dwWidth / v.dvClipWidth;
    lpData->dvScaleY = v.dwHeight / v.dvClipHeight;
    lpData->dvMaxX = v.dvClipX + v.dvClipWidth;
    lpData->dvMaxY = v.dvClipY;
    return ret;
}


HRESULT D3DAPI DIRECT3DVIEWPORTI::GetViewport2(LPD3DVIEWPORT2 lpData)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DVIEWPORT2_PTR(lpData)) {
            D3D_ERR( "Invalid D3DVIEWPORT2 pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!this->v_data_is_set)
    {
        D3D_ERR("SetViewport not called for viewport yet");
        return D3DERR_VIEWPORTDATANOTSET;
    }

    *lpData = this->v_data;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::TransformVertices"

HRESULT D3DAPI DIRECT3DVIEWPORTI::TransformVertices(DWORD dwVertexCount,
                                                    LPD3DTRANSFORMDATA lpData,
                                                    DWORD dwFlags,
                                                    LPDWORD lpOffScreen)
{
    HRESULT     err;
    D3DTRANSFORMDATAI data;
    LPDIRECT3DVIEWPORTI lpViewOld;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DTRANSFORMDATA_PTR(lpData)) {
            D3D_ERR( "Invalid D3DTRANSFORMDATA pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DWORD_PTR(lpOffScreen)) {
            D3D_ERR( "Invalid DWORD pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    dwFlags &= (D3DTRANSFORM_CLIPPED | D3DTRANSFORM_UNCLIPPED);
    if (!dwFlags)
    {
        D3D_ERR("invalid flags");
        return (DDERR_INVALIDPARAMS);
    }
    /*
     * Make sure the correct viewport is set up in the driver.
     */
    err = ValidateViewport(this->lpDevI, this);
    if (err != D3D_OK)
    {
        D3D_ERR("failed to set viewport");
        return err;
    }

    lpViewOld = this->lpDevI->lpCurrentViewport;
    lpDevI->lpCurrentViewport = this;

    data = *(LPD3DTRANSFORMDATAI)lpData;
    data.drExtent.x1 = D3DVAL(lpData->drExtent.x1);
    data.drExtent.y1 = D3DVAL(lpData->drExtent.y1);
    data.drExtent.x2 = D3DVAL(lpData->drExtent.x2);
    data.drExtent.y2 = D3DVAL(lpData->drExtent.y2);

    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
        updateTransform(lpDevI);

    if (dwFlags == D3DTRANSFORM_CLIPPED)
    {
        if (lpDevI->dwFEFlags & D3DFE_INVERSEMCLIP_DIRTY)
        {
            updateInverseMclip(lpDevI);
            lpDevI->dwFEFlags &= ~D3DFE_INVERSEMCLIP_DIRTY;
        }
        lpDevI->dwFlags &= ~D3DDP_DONOTCLIP;
    }
    else
        lpDevI->dwFlags |= D3DDP_DONOTCLIP;

    *lpOffScreen = lpDevI->pGeometryFuncs->TransformVertices(lpDevI, dwVertexCount, &data);

    *lpData = *(D3DTRANSFORMDATA*)&data;
    D3DFE_ConvertExtent(this->lpDevI, &data.drExtent, &lpData->drExtent);

    this->lpDevI->lpCurrentViewport = lpViewOld;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::LightElements"

HRESULT D3DAPI DIRECT3DVIEWPORTI::LightElements(DWORD dwElementCount,
                                                LPD3DLIGHTDATA lpData)
{
    return E_NOTIMPL;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetBackground"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetBackground(D3DMATERIALHANDLE hMat)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (!hMat) {
        D3D_ERR("invalid material handle");
        return (DDERR_INVALIDPARAMS);
    }

    this->bHaveBackgndMat = (hMat!=0);
    this->hBackgndMat = hMat;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetBackground"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetBackground(LPD3DMATERIALHANDLE lphMat,
                                                LPBOOL lpValid)
{
    HRESULT err;

    err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_D3DMATERIALHANDLE_PTR(lphMat)) {
            D3D_ERR( "Invalid D3DMATERIALHANDLE pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_BOOL_PTR(lpValid)) {
            D3D_ERR( "Invalid BOOL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->bHaveBackgndMat) {
        *lpValid = TRUE;
        *lphMat = this->hBackgndMat;
    } else {
        *lphMat = 0;
        *lpValid = FALSE;
    }

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetBackgroundDepth"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetBackgroundDepth(LPDIRECTDRAWSURFACE lpDDS) {

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT2_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        // passing NULL is OK
        if ((lpDDS!=NULL) && !VALID_D3D_DIRECTDRAWSURFACE_PTR((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)) {
            D3D_ERR( "Invalid DirectDrawSurface pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if(this->lpDDSBackgndDepth!=NULL) {
      this->lpDDSBackgndDepth->Release();
    }

    this->lpDDSBackgndDepth=lpDDS;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::SetBackgroundDepth2"

HRESULT D3DAPI DIRECT3DVIEWPORTI::SetBackgroundDepth2(LPDIRECTDRAWSURFACE4 lpDDS4)
{
    LPDIRECTDRAWSURFACE lpDDS;
    HRESULT ret;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }

        // passing NULL is OK
        if ((lpDDS4!=NULL) && !VALID_D3D_DIRECTDRAWSURFACE4_PTR((LPDDRAWI_DDRAWSURFACE_INT)lpDDS4)) {
            D3D_ERR( "Invalid DirectDrawSurface4 pointer" );
            return DDERR_INVALIDOBJECT;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    lpDDS=NULL;
    if(lpDDS4!=NULL) {
        // QI for DDS interface.  This constitutes an AddRef, which is different from previous DX5 behavior
        ret = lpDDS4->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);
        if(FAILED(ret))
           return ret;
    }

    if(this->lpDDSBackgndDepth)
      this->lpDDSBackgndDepth->Release();

    this->lpDDSBackgndDepth = lpDDS;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetBackgroundDepth2"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetBackgroundDepth2(LPDIRECTDRAWSURFACE4* lplpDDS,
                                                     LPBOOL lpValid)
{
    LPDIRECTDRAWSURFACE lpDDS;
    HRESULT ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDDS)) {
            D3D_ERR( "Invalid ptr to LPDIRECTDRAWSURFACE4" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_BOOL_PTR(lpValid)) {
            D3D_ERR( "Invalid BOOL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS=NULL;

    if(this->lpDDSBackgndDepth!=NULL) {
      // QI for DDS interface.  This constitutes an AddRef, which is different from previous DX5 behavior
      ret = this->lpDDSBackgndDepth->QueryInterface(IID_IDirectDrawSurface4, (LPVOID*)lplpDDS);
    }

    *lpValid = (*lplpDDS!=NULL);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::GetBackgroundDepth"

HRESULT D3DAPI DIRECT3DVIEWPORTI::GetBackgroundDepth(LPDIRECTDRAWSURFACE* lplpDDS,
                                                     LPBOOL lpValid)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDDS)) {
            D3D_ERR( "Invalid ptr to LPDIRECTDRAWSURFACE" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_BOOL_PTR(lpValid)) {
            D3D_ERR( "Invalid BOOL pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    // no AddRef taken (this was a DX3 bug)
    *lplpDDS = this->lpDDSBackgndDepth;
    *lpValid = (this->lpDDSBackgndDepth!=NULL);

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::Clear (ProcessRects)"

HRESULT ProcessRects(DIRECT3DVIEWPORTI *pViewport, DWORD dwCount, LPD3DRECT rects) {
    RECT vwport;
    DWORD i,j;

    /*
     * Rip through the rects and validate that they
     * are within the viewport.
     */

#if DBG
    if(dwCount == 0)
    {
        return D3D_OK;
    }
    if(rects == NULL)
    {
        D3D_ERR("invalid clear rectangle parameter rects == NULL");
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (dwCount > pViewport->clrCount) {
        if (D3DRealloc((void**)&pViewport->clrRects, dwCount * sizeof(D3DRECT)) != DD_OK) {
            pViewport->clrCount = 0;
            pViewport->clrRects = NULL;
            D3D_ERR("failed to allocate space for rects");
            return DDERR_OUTOFMEMORY;
        }
    }
    if (IS_DX5_COMPATIBLE_DEVICE(pViewport->lpDevI))
    {
        vwport.left = pViewport->v_data.dwX;
        vwport.top = pViewport->v_data.dwY;
        vwport.right = pViewport->v_data.dwX + pViewport->v_data.dwWidth;
        vwport.bottom = pViewport->v_data.dwY + pViewport->v_data.dwHeight;
    }
    else
    {
        LPDIRECTDRAWSURFACE lpDDS;

        lpDDS = pViewport->lpDevI->lpDDSTarget;

        vwport.right  =   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
        vwport.bottom =   ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;

        vwport.left = 0;
        vwport.top = 0;

    }
    j=0;
    for (i = 0; i < dwCount; i++) {
        if (IntersectRect((LPRECT)(pViewport->clrRects + j), &vwport, (LPRECT)(rects + i)))
            j++;
    }
    pViewport->clrCount = j;

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::Clear2"

HRESULT D3DAPI DIRECT3DVIEWPORTI::Clear2(DWORD dwCount, LPD3DRECT rects, DWORD dwFlags,
                                         D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil)
{
    LPDIRECT3DVIEWPORTI lpTempVwport;
    HRESULT err;
    BOOL bDoRGBClear,bDoZClear,bDoStencilClear;
    LPDDPIXELFORMAT pZPixFmt=NULL;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_DIRECT3DDEVICE3_PTR(this->lpDevI)) {
            D3D_ERR( "Viewport not attached to Device" );
            return D3DERR_VIEWPORTHASNODEVICE;
        }
#if DBG
        if (IsBadWritePtr(rects, dwCount * sizeof(D3DRECT))) {
            D3D_ERR( "Invalid rects pointer" );
            return DDERR_INVALIDPARAMS;
        }
#endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    bDoRGBClear=((dwFlags & D3DCLEAR_TARGET)!=0);
    bDoZClear=((dwFlags & D3DCLEAR_ZBUFFER)!=0);
    bDoStencilClear=((dwFlags & D3DCLEAR_STENCIL)!=0);

    if (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
    {
        if (!(lpDevI->lpD3DHALCallbacks3->Clear2) &&
            !(IS_DX7HAL_DEVICE(lpDevI)))
        {
            if (bDoStencilClear)
            {
                D3D_ERR("Invalid flag D3DCLEAR_STENCIL: this ZBUFFERLESSHSR device doesn't support Clear2()");
                return D3DERR_ZBUFFER_NOTPRESENT;
            }
            if (bDoZClear)
            {
                if (!(lpDevI->lpD3DHALCallbacks2->Clear) || (dvZ!=1.0))
                {
                    D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since this ZBUFFERLESSHSR device doesn't even support Clear() or Z!=1");
                    dwFlags &= ~(D3DCLEAR_ZBUFFER);
                    bDoZClear = FALSE;
                }
            }
        }
    }
    else
    {
        if((this->lpDevI->lpDDSZBuffer==NULL)&&(bDoStencilClear||bDoZClear)) {
            // unlike Clear(), specifying a Zbuffer-clearing flag without a zbuffer will
            // be considered an error

            if(bDoZClear) {
                D3D_ERR("Invalid flag D3DCLEAR_ZBUFFER: no zbuffer is associated with device");
            }
            if(bDoStencilClear) {
                D3D_ERR("Invalid flag D3DCLEAR_STENCIL: no zbuffer is associated with device");
            }
            return D3DERR_ZBUFFER_NOTPRESENT;
        }

        if(bDoStencilClear) {
            pZPixFmt=&((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
            if(!(pZPixFmt->dwFlags & DDPF_STENCILBUFFER)) {
                D3D_ERR("Invalid flag D3DCLEAR_STENCIL; current zbuffer's pixel format doesnt support stencil bits");
                return D3DERR_STENCILBUFFER_NOTPRESENT;
            }
        }
    }

    if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))) {
        D3D_ERR("no valid flags passed to Clear2");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

#if DBG
// bad clear values just cause wacky results but no crashes, so OK to allow in retail bld

    if(bDoZClear && ((dvZ<0.0) || (dvZ>1.0))) {
        D3D_ERR("clear2 Z value outside legal range (0.0-1.0)");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

    if(bDoStencilClear && pZPixFmt && (dwStencil > (DWORD)((1<<pZPixFmt->dwStencilBitDepth)-1))) {
        D3D_ERR("clear2 stencil value larger than max allowed stencil value for zbuf pixelfmt");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }
#endif

    // leave this check in retail build since DDFE_Clear keys off lpDDSBackgndDepth to do textured backg. clrs

    if(bDoZClear && (this->lpDDSBackgndDepth!=NULL)) {
        D3D_ERR("Background Depth Buffer not allowed to be used with Clear2");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

#if DBG
// dont bother with this check for retail, since we can easily ignore existing background material
    if(this->bHaveBackgndMat && bDoRGBClear) {
        D3DMATERIAL dmMat;
        err = D3DHAL_MaterialGetData(this->lpDevI, this->hBackgndMat, &dmMat);
        if (err != D3D_OK) {
            D3D_ERR("Failed to find material from current viewport background material handle");
            goto early_out;
        }
        if(dmMat.hTexture!=0) {
             D3D_ERR("Textured background materials not allowed to be used with Clear2");
             err=DDERR_INVALIDPARAMS;
             goto early_out;
        }
        D3D_WARN(3,"Ignoring current Background Material Color, Clear2 dwColor arg overrides it");
    }
#endif

    // Make sure the correct viewport is set up in the driver.
    err = ValidateViewport(this->lpDevI, this);
    if (err != D3D_OK)
    {
        D3D_ERR("failed to set viewport");
        goto early_out;
    }

    if((err=ProcessRects(this,dwCount,rects))!=D3D_OK)
       goto early_out;

    /* Make sure this viewport is the current viewport for the duration of this call */
    lpTempVwport = this->lpDevI->lpCurrentViewport;
    this->lpDevI->lpCurrentViewport = this;
    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        static_cast<CDirect3DDeviceIDP2*>(lpDevI)->ClearI(dwFlags, clrCount, clrRects, dwColor, dvZ, dwStencil);
    }
    else
    {
        err = D3DFE_Clear2(this->lpDevI, dwFlags, this->clrCount, this->clrRects,
                       dwColor, dvZ, dwStencil);
    }
    /* Restore the original current viewport of the device */
    this->lpDevI->lpCurrentViewport = lpTempVwport;

early_out:
    return err;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::Clear"
extern void TriFillRectsTex(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect,D3DTEXTUREHANDLE hTex);

HRESULT D3DAPI DIRECT3DVIEWPORTI::Clear(DWORD dwCount,
                                        LPD3DRECT rects,
                                        DWORD dwFlags)
{
    LPDIRECT3DVIEWPORTI lpTempVwport;
    HRESULT err;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_DIRECT3DDEVICE3_PTR(this->lpDevI)) {
            D3D_ERR( "Viewport not attached to Device" );
            return D3DERR_VIEWPORTHASNODEVICE;
        }
#if DBG
        if (IsBadWritePtr(rects, dwCount * sizeof(D3DRECT))) {
            D3D_ERR( "Invalid rects pointer" );
            return DDERR_INVALIDPARAMS;
        }
#endif
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if((dwFlags & D3DCLEAR_ZBUFFER) && (this->lpDevI->lpDDSZBuffer==NULL)) {
        // this is not an error for legacy app compatibility--DX5 allowed this flag
        // to be set even if no ZBuffer exists
        if (!(this->lpDevI->lpD3DHALGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & D3DPRASTERCAPS_ZBUFFERLESSHSR)
            || !(this->lpDevI->lpD3DHALCallbacks2->Clear || this->lpDevI->lpD3DHALCallbacks3->Clear2
                 || (IS_DX7HAL_DEVICE(lpDevI)))
        )
        {
            D3D_WARN(3,"Ignoring D3DCLEAR_ZBUFFER since no zbuffer associated with device");
            dwFlags &= ~(D3DCLEAR_ZBUFFER);
            if (! dwFlags)
            {
                D3D_WARN(3, "Viewport::Clear: Nothing to do");
                err = D3D_OK;
                goto early_out;
            }
        }
    }

#if DBG
    if (dwFlags & D3DCLEAR_ZBUFFER)
    {
        LPDDPIXELFORMAT pZPixFmt =
            &((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl->lpGbl->ddpfSurface;
        if (pZPixFmt->dwFlags & DDPF_STENCILBUFFER) {
            D3D_ERR("Can't use Clear() on Z buffer with stencil planes. Use Clear2()");
            // No change to execution path.
        }
    }
#endif

    // leave this check until after checks that turn off flags
    if (!(dwFlags & (D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER))) {
        D3D_ERR("no valid flags were passed to Clear");
        err=DDERR_INVALIDPARAMS;
        goto early_out;
    }

    // Make sure the correct viewport is set up in the driver.
    err = ValidateViewport(this->lpDevI, this);
    if (err != D3D_OK)
    {
        D3D_ERR("failed to set viewport");
        goto early_out;
    }

    if((err=ProcessRects(this,dwCount,rects))!=D3D_OK)
       goto early_out;

    D3DMATERIAL dmMat;

    if(this->bHaveBackgndMat) {
        err = D3DHAL_MaterialGetData(lpDevI, this->hBackgndMat, &dmMat);
        if(err != D3D_OK) {
            D3D_ERR("Failed to find material from current background material handle");
            goto early_out;
        }
    } else {
        // DX5 legacy apps expect to Clear to Black if Background not initialized
        dmMat.diffuse.r=dmMat.diffuse.g=dmMat.diffuse.b=dmMat.diffuse.a=0;
        dmMat.hTexture=0;
        D3D_WARN(3,"Background Material is NULL!!  Setting color to black, but please set a valid background");
    }

    /* Make sure this viewport is the current viewport for the duration of this call */
    lpTempVwport = this->lpDevI->lpCurrentViewport;
    this->lpDevI->lpCurrentViewport = this;

    if (IS_DX7HAL_DEVICE(lpDevI))
    {
        if (0 != dmMat.hTexture && (D3DCLEAR_TARGET & dwFlags))
        {
            err = lpDevI->FlushStates();
            if (err != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in Clear");
                goto early_out;
            }
            TriFillRectsTex(lpDevI, clrCount, clrRects, dmMat.hTexture);
            dwFlags &= ~D3DCLEAR_TARGET;
        }
        if ((D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER) & dwFlags)
        {
            static_cast<CDirect3DDeviceIDP2*>(lpDevI)->ClearI(dwFlags, clrCount, clrRects, CVAL_TO_RGBA(dmMat.diffuse), 1.0, 0);
        }
    }
    else
    {
        err = D3DFE_Clear(this->lpDevI, dwFlags, this->clrCount, this->clrRects,
                      &dmMat.diffuse, dmMat.hTexture);
    }
    /* Restore the original current viewport of the device */
    this->lpDevI->lpCurrentViewport = lpTempVwport;

early_out:
    return err;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::AddLight"

HRESULT D3DAPI DIRECT3DVIEWPORTI::AddLight(LPDIRECT3DLIGHT lpD3DLight)
{
    LPDIRECT3DLIGHTI lpLightI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        lpLightI = (LPDIRECT3DLIGHTI)lpD3DLight;

        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DLIGHT_PTR(lpLightI)) {
            D3D_ERR( "Invalid DIRECT3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpLightI->lpD3DViewportI) {
        D3D_ERR("light already associated with a viewport");
        return (D3DERR_LIGHTHASVIEWPORT);
    }

    err = hookLightToViewport(this, lpLightI);
    if (err != D3D_OK) {
        D3D_ERR("failed to add light to viewport");
        return (err);
    }

    this->bLightsChanged = TRUE;

    /*
     * AddRef the light
     */
    lpD3DLight->AddRef();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::DeleteLight"

HRESULT D3DAPI DIRECT3DVIEWPORTI::DeleteLight(LPDIRECT3DLIGHT lpD3DLight)
{
    LPDIRECT3DLIGHTI lpLightI;
    HRESULT err = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        lpLightI = (LPDIRECT3DLIGHTI)lpD3DLight;
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DIRECT3DLIGHT_PTR(lpLightI)) {
            D3D_ERR( "Invalid DIRECT3DLIGHT pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    if (lpLightI->lpD3DViewportI != this) {
        D3D_ERR("Light is not associated with this viewport");
        return (D3DERR_LIGHTNOTINTHISVIEWPORT);
    }

    /*
     * Remove this light from the viewport.
     */
    CIRCLE_QUEUE_DELETE(&this->lights, lpLightI, light_list);
    this->numLights--;

    lpLightI->lpD3DViewportI = NULL;

    this->bLightsChanged = TRUE;

    /*
     * Release the light
     */
    lpD3DLight->Release();

    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DViewport::NextLight"

HRESULT D3DAPI DIRECT3DVIEWPORTI::NextLight(LPDIRECT3DLIGHT lpD3DLight,
                                            LPDIRECT3DLIGHT* lplpLight,
                                            DWORD dwFlags)
{
    LPDIRECT3DLIGHTI lpLightI;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    /*
     * validate parms
     */
    TRY
    {
        if (!VALID_OUTPTR(lplpLight)) {
            D3D_ERR( "Invalid output pointer to LPDIRECT3DLIGHT" );
            return DDERR_INVALIDPARAMS;
        }

        *lplpLight = NULL;

        lpLightI = (LPDIRECT3DLIGHTI)lpD3DLight;
        if (!VALID_DIRECT3DVIEWPORT3_PTR(this)) {
            D3D_ERR( "Invalid Direct3DViewport pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (dwFlags & D3DNEXT_NEXT) {
            if (!VALID_DIRECT3DLIGHT_PTR(lpLightI)) {
                D3D_ERR( "Invalid Direct3DLight pointer" );
                return DDERR_INVALIDPARAMS;
            }

            if (lpLightI && lpLightI->lpD3DViewportI != this) {
                D3D_ERR("light not associated with this viewport");
                return (D3DERR_LIGHTNOTINTHISVIEWPORT);
            }
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        D3D_ERR( "Exception encountered validating parameters" );
        return DDERR_INVALIDPARAMS;
    }

    switch (dwFlags) {
    case D3DNEXT_NEXT:
        *lplpLight = (LPDIRECT3DLIGHT)CIRCLE_QUEUE_NEXT(this,lpLightI,light_list);
        break;
    case D3DNEXT_HEAD:
        *lplpLight = (LPDIRECT3DLIGHT)CIRCLE_QUEUE_FIRST(&this->lights);
        break;
    case D3DNEXT_TAIL:
        *lplpLight = (LPDIRECT3DLIGHT)CIRCLE_QUEUE_LAST(&this->lights);
        break;
    default:
        D3D_ERR("invalid flags");
        return (DDERR_INVALIDPARAMS);
    }
    if (*lplpLight == (LPDIRECT3DLIGHT)&this->lights) {
        *lplpLight = NULL;
    }

    /*
     * Must AddRef the returned object
     */
    if (*lplpLight)
        (*lplpLight)->AddRef();

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\d3dcom.h ===
/*
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//  History:    02-7-94   terryru           Created.
//
//----------------------------------------------------------------------------
*/
/*
 * Taken from objbase.h
 */
#ifndef _D3DCOM_H
#define _D3DCOM_H

#include "subwtype.h"

#ifndef WIN32
#define __export
#define __stdcall
#endif /* WIN32 */

typedef void    IUnknown;
#ifndef WINAPI
#define WINAPI
#endif
#define FAR
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | \
            ((unsigned long)(fac)<<16) | \
             ((unsigned long)(code))))

/* Component Object Model defines, and macros */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef WIN32

/* Win32 doesn't support __export */

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

/* The 'V' versions allow Variable Argument lists. */

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
/*#define interface               struct FAR */
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct


#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif

#endif /* _D3DCOM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\d3dpr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dpr.h
 *  Content:    Direct3D private include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   23/11/95   colinmc Made various Direct3D interfaces queryable off
 *                      DirectDraw.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef _D3DPR_H_
#define _D3DPR_H_
#include "d3di.hpp"
#include "texman.hpp"
#include "dpf.h"

/*
 * Texture Manipulation Utils
 */
extern void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK);
extern void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK);

extern DWORD BitDepthToDDBD(int bpp);
extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS pCallbacks);
extern void FreeDeviceI(LPDIRECT3DDEVICEI pDevI);

extern HRESULT D3DBufFreeBufferMemory(LPDIRECT3DEXECUTEBUFFERI lpBuf, DWORD dwWhere);
extern HRESULT D3DBufAllocateBufferMemory(LPDIRECT3DEXECUTEBUFFERI lpBuf, DWORD dwWhere);
extern HRESULT D3DBufHookBufferToDevice(LPDIRECT3DDEVICEI lpDev, LPDIRECT3DEXECUTEBUFFERI lpBuf);
extern HRESULT HookD3DDeviceToSurface(LPDIRECT3DDEVICEI,LPDDRAWI_DDRAWSURFACE_LCL);
extern void UnHookD3DDeviceFromSurface(LPDIRECT3DDEVICEI,LPDDRAWI_DDRAWSURFACE_LCL);
#define D3DBUCKETBUFFERSIZE 32  //make buffer byte size 2*D3DBUCKETBUFFERSIZE*4
extern HRESULT D3DMallocBucket(LPDIRECT3DI, LPD3DBUCKET *);
extern void D3DFreeBucket(LPDIRECT3DI, LPD3DBUCKET);
extern LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI,LPDIRECT3DDEVICEI);
extern HRESULT CopySurface(LPDIRECTDRAWSURFACE4,LPDIRECTDRAWSURFACE4,LPDIRECTDRAWCLIPPER);
extern HRESULT GetTextureDDIHandle(LPDIRECT3DTEXTUREI,LPDIRECT3DDEVICEI,LPD3DI_TEXTUREBLOCK*);

__inline void
BatchTextureToDevice(LPDIRECT3DDEVICEI lpDevI, LPDDRAWI_DDRAWSURFACE_LCL lpLcl) {
        LPD3DBUCKET   lpTextureBatched;
    if ( D3D_OK != HookD3DDeviceToSurface(lpDevI,lpLcl)) {
        return;
    }
    if (D3DMallocBucket(lpDevI->lpDirect3DI,&lpTextureBatched) != D3D_OK)
    {   //this is left often to happen
        UnHookD3DDeviceFromSurface(lpDevI, lpLcl);
        return;
    }
    lpTextureBatched->lpLcl=lpLcl;
    lpTextureBatched->next=lpDevI->lpTextureBatched;
    lpDevI->lpTextureBatched=lpTextureBatched;
        return;
}

__inline void
FlushTextureFromDevice(LPDIRECT3DDEVICEI lpDevI) 
{
    LPD3DBUCKET   current=lpDevI->lpTextureBatched;
    DWORD   dwStage;
    while(current)
    {
        LPD3DBUCKET   temp;
        temp=current->next;
        UnHookD3DDeviceFromSurface(lpDevI,current->lpLcl);
        D3DFreeBucket(lpDevI->lpDirect3DI,current);
        current=temp;
    }
    lpDevI->lpTextureBatched=NULL;
    if (lpDevI->lpDDSZBuffer && (1==lpDevI->dwVersion))
    {
        if (!lpDevI->lpDDSZBuffer_DDS4) // DDRAW zeroed it ?
        {
            UnHookD3DDeviceFromSurface(lpDevI,((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSZBuffer)->lpLcl);
            lpDevI->lpDDSZBuffer=NULL;
        }
    }
    for (dwStage=0;dwStage < lpDevI->dwMaxTextureBlendStages; dwStage++)
    {
        LPD3DI_TEXTUREBLOCK lpBlock = lpDevI->lpD3DMappedBlock[dwStage];
        LPDIRECT3DTEXTUREI  lpTexI = lpDevI->lpD3DMappedTexI[dwStage];
        if (NULL != lpTexI
            && NULL != lpBlock
            && 0 != lpBlock->hTex)
        {
            if(lpTexI->lpDDS != NULL)
            {
                BatchTextureToDevice(lpDevI, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDS)->lpLcl);
            }
            else
            {
                BatchTextureToDevice(lpDevI, ((LPDDRAWI_DDRAWSURFACE_INT) lpTexI->lpDDSSys)->lpLcl);
            }
        }
    }
    return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "VerifyTextureCaps"
__inline HRESULT
VerifyTextureCaps(LPDIRECT3DDEVICEI lpDev, LPDDRAWI_DDRAWSURFACE_INT lpDDS)
{
    DWORD texcap;
    WORD width, height;
    DDASSERT(lpDDS != NULL);
    /* first verify the dimensions */
    if (lpDev->d3dHWDevDesc.dwFlags & D3DDD_TRICAPS)
        texcap = lpDev->d3dHWDevDesc.dpcTriCaps.dwTextureCaps;
    else
        texcap = lpDev->d3dHELDevDesc.dpcTriCaps.dwTextureCaps;
    width = lpDDS->lpLcl->lpGbl->wWidth;
    height = lpDDS->lpLcl->lpGbl->wHeight;
    if (texcap & D3DPTEXTURECAPS_POW2)
    {
        if (width & (width - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture width not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture width not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
        if (height & (height - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture height not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture height not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
    }
    if (texcap & D3DPTEXTURECAPS_SQUAREONLY)
    {
        if (width != height)
        {
            D3D_ERR("Texture not square");
            return D3DERR_TEXTURE_BADSIZE;
        }
    }
    return  D3D_OK;
}

#if _D3D_FORCEDOUBLE
class CD3DForceFPUDouble
{
private:
    WORD    wFPUCW;
    WORD    wSaved;
public:
    __inline
    CD3DForceFPUDouble(CDirect3DDeviceIHW * lpDevI)
    {
        wSaved=FALSE;
        if (lpDevI->dwDebugFlags & D3DDEBUG_FORCEDOUBLE)
        {
            WORD    wTemp;
            __asm   fstcw   wTemp
            if (!(wTemp & 0x0200))
            {
                wSaved=TRUE;
                wFPUCW=wTemp;
                wTemp=wFPUCW | 0x0200;  //Enforce Double Precision bit
                __asm   fldcw  wTemp
            }
        }
    }
    __inline
    ~CD3DForceFPUDouble()
    {
        if (wSaved)
        {
            WORD    wTemp = wFPUCW;
            __asm   fldcw  wTemp
        }
    }
};
#endif  //_D3D_FORCEDOUBLE

//---------------------------------------------------------------------
// The CSetD3DFPstate is used to facilitate the changing of FPU settings.
// In the constructor the optimal FPU state is set. In the destructor the
// old state is restored.
//
class CD3DFPstate
{
public:
    CD3DFPstate()
        {
        #ifdef _X86_
            WORD wTemp, wSave;
            wSavedFP = FALSE;
            // Disable floating point exceptions and go to single mode
                __asm fstcw wSave
                if (wSave & 0x300 ||            // Not single mode
                    0x3f != (wSave & 0x3f) ||   // Exceptions enabled
                    wSave & 0xC00)              // Not round to nearest mode
                {
                    __asm {
                        mov ax, wSave
                        and ax, not 300h    ;; single mode
                        or  ax, 3fh         ;; disable all exceptions
                        and ax, not 0xC00   ;; round to nearest mode
                        mov wTemp, ax
                        fldcw   wTemp
                    }
                    wSavedFP = TRUE;
                }
                wSaveFP = wSave;
        #endif
        }
    ~CD3DFPstate()
        {
        #ifdef _X86_
            WORD wSave = wSaveFP;
            if (wSavedFP)
                __asm {
                    fnclex
                    fldcw   wSave
                }
        #endif
        }
protected:
#ifdef _X86_
    WORD wSaveFP;
    WORD wSavedFP;  // WORD-sized to make the data an even DWORD
#endif
};

/*
 * State flushing functions
 */
extern HRESULT FlushStatesHW(LPDIRECT3DDEVICEI);
extern HRESULT FlushStatesDP(LPDIRECT3DDEVICEI);
extern HRESULT FlushStatesCB(LPDIRECT3DDEVICEI);

/*
 * These are used to draw primitives which come out of the clipper
 */
extern HRESULT DrawPrimitivesDP(LPDIRECT3DDEVICEI, LPD3DTLVERTEX lpTLBuf, LPVOID lpTBuf, LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType);
extern HRESULT DrawPrimitiveLegacyHalCall(LPDIRECT3DDEVICEI, LPD3DTLVERTEX lpVertices, LPVOID lpvData, LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType);
extern HRESULT DrawPrimitivesCB(LPDIRECT3DDEVICEI, LPD3DTLVERTEX lpVertices, LPVOID lpvData, LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType);

/*
 * Critical section code.
 * Coarse locking.  All actions require this section.
 * Defined in d3dcreat.c
 */
/*
 * On WINNT critical sections can't be used because synchronization must
 * occur cross process.   DDraw and D3D must share this synchronization so
 * DDraw exports private functions for synchronization that NT D3D must use.
 */
#ifdef WIN95
extern LPCRITICAL_SECTION       lpD3DCSect;
#endif

extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
};
#if DBG
    extern int iD3DCSCnt;
    #define INCD3DCSCNT() iD3DCSCnt++;
    #define INITD3DCSCNT() iD3DCSCnt = 0;
    #define DECD3DCSCNT() iD3DCSCnt--;
#else
    #define INCD3DCSCNT()
    #define INITD3DCSCNT()
    #define DECD3DCSCNT()
#endif

#ifdef WIN95
#define ENTER_D3D() \
    EnterCriticalSection( lpD3DCSect ); \
    INCD3DCSCNT(); \

#define LEAVE_D3D() \
    DECD3DCSCNT() \
    LeaveCriticalSection( lpD3DCSect );
#else
#define ENTER_D3D() \
        AcquireDDThreadLock(); \
        INCD3DCSCNT(); \

#define LEAVE_D3D() \
        DECD3DCSCNT() \
        ReleaseDDThreadLock();
#endif

// This class is designed to simplify ENTER_D3D() LEAVE_D3D() logic
// If object of this class is instantiated, then internal lock will be taken.
// As soon as object is destroyed lock will be released
//
class CLockD3D
{
public:
    CLockD3D(char *moduleName, char *fileName)
    {
        ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
        D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
    }
    ~CLockD3D()
    {
        LEAVE_D3D();
        D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
    }
};

class CLockD3DST
{
private:
    bool bEnter;
public:
    CLockD3DST(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if (! IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DST()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

class CLockD3DMT
{
private:
    bool bEnter;
public:
    CLockD3DMT(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if ( IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DMT()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

#define ENTER_CBCSECT(device) EnterCriticalSection(&(device)->CommandBufferCSect)
#define LEAVE_CBCSECT(device) LeaveCriticalSection(&(device)->CommandBufferCSect)

/*
 * Legacy structure sizes
 */
#define D3DFINDDEVICERESULTSIZE_V1 (sizeof(D3DFINDDEVICERESULT)-2*(D3DDEVICEDESCSIZE-D3DDEVICEDESCSIZE_V1) )
#define D3DFINDDEVICERESULTSIZE_V2 (sizeof(D3DFINDDEVICERESULT)-2*(D3DDEVICEDESCSIZE-D3DDEVICEDESCSIZE_V2) )

/*
 * Macros for validating parameters.
 * Only implement those not available in ddrawpr.h.
 */

#define VALID_OUTPTR(x) ((x) && VALID_PTR_PTR(x))

// FAST_CHECKING macro is defined in ddrawpr.h
// so in make sure that ddrawpr.h is always included
// before this header.

#ifndef FAST_CHECKING

#define VALID_DIRECT3D_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3D2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3D3_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3DDEVICE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DIRECT3DDEVICE2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DIRECT3DDEVICE3_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DIRECT3DVIEWPORT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DVIEWPORTI )))
#define VALID_DIRECT3DVIEWPORT2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DVIEWPORTI )))
#define VALID_DIRECT3DVIEWPORT3_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DVIEWPORTI )))
#define VALID_DIRECT3DMATERIAL_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DMATERIALI )))
#define VALID_DIRECT3DMATERIAL2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DMATERIALI )))
#define VALID_DIRECT3DTEXTURE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTUREI )))
#define VALID_DIRECT3DTEXTURE2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTUREI )))
#define VALID_DIRECT3DLIGHT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DLIGHTI )))
#define VALID_DIRECT3DEXECUTEBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DEXECUTEBUFFERI )))
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( CDirect3DVertexBuffer )))

#define VALID_D3DEXECUTEBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DEXECUTEBUFFERDESC ) ) && \
    (ptr->dwSize == sizeof( D3DEXECUTEBUFFERDESC )) )
#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVERTEXBUFFERDESC ) ) && \
    (ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC )) )
#define VALID_D3DEXECUTEDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DEXECUTEDATA ) ) && \
    (ptr->dwSize == sizeof( D3DEXECUTEDATA )) )
#define VALID_D3DMATERIALHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATERIALHANDLE ) ) )
#define VALID_D3DSTATS_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DSTATS ) ) && \
    (ptr->dwSize == sizeof( D3DSTATS )) )
#define VALID_D3DDEVICEDESC_PTR( ptr ) \
    ( (! IsBadWritePtr(ptr, 4) ) && \
      (ptr->dwSize == D3DDEVICEDESCSIZE     || \
       ptr->dwSize == D3DDEVICEDESCSIZE_V1  || \
       ptr->dwSize == D3DDEVICEDESCSIZE_V2) && \
      (! IsBadWritePtr(ptr, ptr->dwSize) ) )
#define VALID_D3DMATRIXHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATRIXHANDLE ) ))
#define VALID_D3DPICKRECORD_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DPICKRECORD ) ))
#define VALID_D3DRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DRECT ) ))
#define VALID_D3DMATRIX_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATRIX ) ))
#define VALID_D3DLIGHT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHT ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHT )) )
#define VALID_D3DLIGHT2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHT2 ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHT2 )) )
#define VALID_D3DMATERIAL_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DMATERIAL ) ) && \
    (ptr->dwSize == sizeof( D3DMATERIAL )) )
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTEXTUREHANDLE ) ) )
#define VALID_D3DLIGHTDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHTDATA ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHTDATA )) )
#define VALID_D3DVIEWPORT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVIEWPORT ) ) && \
    (ptr->dwSize == sizeof( D3DVIEWPORT )) )
#define VALID_D3DVIEWPORT2_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVIEWPORT2 ) ) && \
    (ptr->dwSize == sizeof( D3DVIEWPORT2 )) )
#define VALID_D3DTRANSFORMDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTRANSFORMDATA ) ) && \
    (ptr->dwSize == sizeof( D3DTRANSFORMDATA )) )
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DFINDDEVICESEARCH ) ) && \
    (ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ) ) )
#define VALID_D3DFINDDEVICERESULT_PTR( ptr ) \
        ( (! IsBadWritePtr( ptr, 4)) &&                  \
          (ptr->dwSize == sizeof(D3DFINDDEVICERESULT) || \
           ptr->dwSize == D3DFINDDEVICERESULTSIZE_V1 || \
           ptr->dwSize == D3DFINDDEVICERESULTSIZE_V2) && \
          (! IsBadWritePtr( ptr, ptr->dwSize) ) )

// Note: these macros are replacements for the VALID_DIRECTDRAWSURFACE_PTR ddraw macros
// because those macros need access to the ddCallbacks ddraw globals.
// At some point these could be replaced with a ddraw exported fn that actually
// verifies the callback table type

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))
#define VALID_D3D_DIRECTDRAWSURFACE4_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))

#else /* !FAST_CHECKING */

#define VALID_DIRECT3D_PTR( ptr ) (ptr)
#define VALID_DIRECT3D2_PTR( ptr ) (ptr)
#define VALID_DIRECT3D3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVIEWPORT_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVIEWPORT2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVIEWPORT3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DMATERIAL_PTR( ptr ) (ptr)
#define VALID_DIRECT3DMATERIAL2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURE_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURE2_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURE3_PTR( ptr ) (ptr)
#define VALID_DIRECT3DLIGHT_PTR( ptr ) (ptr)
#define VALID_DIRECT3DEXECUTEBUFFER_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) (ptr)

#define VALID_D3DEXECUTEBUFFERDESC_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DEXECUTEBUFFERDESC ))
#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC ))
#define VALID_D3DEXECUTEDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DEXECUTEDATA ))
#define VALID_D3DMATERIALHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DSTATS_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DSTATS ))
#define VALID_D3DDEVICEDESC_PTR( ptr ) ((ptr) &&                                \
                                        (ptr->dwSize == D3DDEVICEDESCSIZE ||    \
                                         ptr->dwSize == D3DDEVICEDESCSIZE_V1 || \
                                         ptr->dwSize == D3DDEVICEDESCSIZE_V2))
#define VALID_D3DMATRIXHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DPICKRECORD_PTR( ptr ) (ptr)
#define VALID_D3DRECT_PTR( ptr ) (ptr)
#define VALID_D3DMATRIX_PTR( ptr ) (ptr)
#define VALID_D3DLIGHT_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHT ))
#define VALID_D3DLIGHT2_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHT2 ))
#define VALID_D3DMATERIAL_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DMATERIAL ))
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DLIGHTDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHTDATA ))
#define VALID_D3DVIEWPORT_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVIEWPORT ))
#define VALID_D3DVIEWPORT2_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVIEWPORT2 ))
#define VALID_D3DTRANSFORMDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DTRANSFORMDATA ))
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ))
#define VALID_D3DFINDDEVICERESULT_PTR( ptr ) \
        ((ptr) && (ptr->dwSize == sizeof( D3DFINDDEVICERESULT ) || \
                   ptr->dwSize == D3DFINDDEVICERESULTSIZE_V1    || \
                   ptr->dwSize == D3DFINDDEVICERESULTSIZE_V2 ) )

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (ptr)    // see comment above
#define VALID_D3D_DIRECTDRAWSURFACE4_PTR(ptr) (ptr)

#endif /* !FAST_CHECKING */
#define CVAL_TO_RGBA(rgb) RGBA_MAKE((DWORD)(255.0 * (rgb).r),    \
                                    (DWORD)(255.0 * (rgb).g),    \
                                    (DWORD)(255.0 * (rgb).b),    \
                                    (DWORD)(255.0 * (rgb).a))

#endif /* _D3DPR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\dpgen.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpgen.h
 *  Content:    Generate some functions for Draw Primitive 
 *
 ***************************************************************************/

#ifdef __DRAWPRIMFUNC

//---------------------------------------------------------------------
// Draws indexed and non-indexed primitives which do not require clipping
//
#ifdef  __DRAWPRIMINDEX
HRESULT CDirect3DDeviceIDP::DrawIndexPrim()
{
    D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumIndices;
#else
HRESULT CDirect3DDeviceIDP::DrawPrim()
{
    D3DHAL_DRAWONEPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumVertices;
#endif
    const WORD vertexType = D3DVT_TLVERTEX;    // XXX While we do not have DDI
    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        UpdateTextures();
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    
    if (dwNumElements < LOWVERTICESNUMBER && 
        this->dwCurrentBatchVID == this->dwVIDOut)
    {
        LPD3DHAL_DRAWPRIMCOUNTS lpPC;
        lpPC = this->lpDPPrimCounts;
        if (lpPC->wNumVertices)
        {
            if ((lpPC->wPrimitiveType!=(WORD) this->primType) ||
                (lpPC->wVertexType != vertexType) ||
                (this->primType==D3DPT_TRIANGLESTRIP) ||
                (this->primType==D3DPT_TRIANGLEFAN) ||
                (this->primType==D3DPT_LINESTRIP))
            {
                lpPC = this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)
                       ((LPBYTE)this->lpwDPBuffer + this->dwDPOffset);
                memset( (char *)lpPC, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));
                // preserve 32 bytes alignment for vertices
                this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
                ALIGN32(this->dwDPOffset);
            }
        }
        else
        {
            // 32-byte align offset pointer, just in case states have been
            // recorded.
            ALIGN32(this->dwDPOffset);
        }
        ULONG ByteCount;
        if (FVF_DRIVERSUPPORTED(this))
            ByteCount = dwNumElements * this->dwOutputSize;
        else
            ByteCount = dwNumElements << 5;   // D3DTLVERTEX
        if (this->dwDPOffset + ByteCount  > this->dwDPMaxOffset)
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));  // Takes D3D lock (ST only).
            //DPF(0,"overflowed ByteCount=%08lx",ByteCount);
            HRESULT ret;
            ret = this->FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in Draw*Prim");
                return ret;
            }
            lpPC = this->lpDPPrimCounts;
            ALIGN32(this->dwDPOffset);
        }
        lpPC->wPrimitiveType = (WORD)this->primType;
        lpPC->wVertexType = (WORD)vertexType;
        lpPC->wNumVertices += (WORD)dwNumElements;
        BYTE *lpVertex = (BYTE*)((char *)this->lpwDPBuffer + this->dwDPOffset);
#ifdef __DRAWPRIMINDEX
        DWORD  i;
        BYTE *pV = (BYTE*)this->lpvOut;
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            for (i=0; i < this->dwNumIndices; i++)
            {
                memcpy(lpVertex, pV + this->lpwIndices[i] * this->dwOutputSize,
                       this->dwOutputSize);
                lpVertex += this->dwOutputSize;
            }
        else
            for (i=0; i < this->dwNumIndices; i++)
            {
                MapFVFtoTLVertex1(this, (D3DTLVERTEX*)lpVertex, 
                                  (DWORD*)(pV + this->lpwIndices[i] * 
                                           this->dwOutputSize));
                lpVertex += sizeof(D3DTLVERTEX);
            }
#else // !__DRAWPRIMINDEX
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpVertex, this->lpvOut, ByteCount);
        else
            MapFVFtoTLVertex(this, lpVertex);
#endif //__DRAWPRIMINDEX
        this->dwDPOffset += ByteCount;
        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        HRESULT ret;
        ret = this->FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in Draw*Prim");
            return ret;
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  this->dwFlags;
        dpData.PrimitiveType = this->primType;
        if (FVF_DRIVERSUPPORTED(this))
        {
            dpData.dwFVFControl = this->dwVIDOut;
            dpData.lpvVertices = this->lpvOut;
        }
        else
        {
            if (this->dwVIDOut == D3DFVF_TLVERTEX)
                dpData.lpvVertices = this->lpvOut;
            else
            {
                HRESULT ret;
                if ((ret = MapFVFtoTLVertex(this, NULL)) != D3D_OK)
                    return ret;
                dpData.lpvVertices = this->TLVbuf.GetAddress();
            }
            dpData.VertexType = (D3DVERTEXTYPE)vertexType;
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
        }
        dpData.dwNumVertices = this->dwNumVertices;
        dpData.ddrval = D3D_OK;
#ifdef __DRAWPRIMINDEX
        dpData.lpwIndices = this->lpwIndices;
        dpData.dwNumIndices = this->dwNumIndices;
#endif
        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
            DWORD dwRet;
        #ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                return (dwRet);
            }
        #endif //WIN95
#ifdef __DRAWPRIMINDEX
            CALL_HAL2ONLY(dwRet, this, DrawOneIndexedPrimitive, &dpData);
#else
            CALL_HAL2ONLY(dwRet, this, DrawOnePrimitive, &dpData);
#endif
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawOnePrimitive" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }

        } while ( (this->dwFlags & D3DDP_WAIT) && (dpData.ddrval == DDERR_WASSTILLDRAWING) );
    }
    return dpData.ddrval;
}

#endif //__DRAWPRIMFUNC

#undef __DRAWPRIMFUNC
#undef __DRAWPRIMINDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\object.h ===
/*
 * $Id: object.h,v 1.2 1995/06/21 12:38:55 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef _OBJECT_H_
#define _OBJECT_H_

#include <stdlib.h>

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#include "d3dcom.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Data structures
 */
#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct ID3DObject;
typedef struct ID3DObject   *LPD3DOBJECT;

#else

typedef struct ID3DObject   *LPD3DOBJECT;

#endif

/*
 * ID3DObject
 */
#undef INTERFACE
#define INTERFACE ID3DObject
DECLARE_INTERFACE(ID3DObject)
{
    /*
     * ID3DObject methods
     */
    STDMETHOD(Initialise) (THIS_ LPVOID arg) PURE;
    STDMETHOD(Destroy) (THIS_ LPVOID arg) PURE;
};

#ifdef __cplusplus
};
#endif

#endif /* _OBJECT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\hwprov.h ===
//----------------------------------------------------------------------------
//
// hwprov.h
//
// Base hardware HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HWPROV_H_
#define _HWPROV_H_

//----------------------------------------------------------------------------
//
// HwHalProvider
//
// Implements the base HAL provider for hardware renderers.
//
//----------------------------------------------------------------------------

class HwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
};

#endif // #ifndef _HWPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\subwtype.h ===
#if !defined(_SUBWTYPE_H_) && !defined(__wtypes_h__)
#define _SUBWTYPE_H_

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
			/* size is 1 */
typedef unsigned char BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
			/* size is 2 */
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
			/* size is 4 */
typedef /* [transmit] */ unsigned int UINT;

			/* size is 4 */
typedef /* [transmit] */ int INT;

			/* size is 4 */
typedef long BOOL, *LPBOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
			/* size is 4 */
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
			/* size is 4 */
typedef UINT WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
			/* size is 4 */
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
			/* size is 4 */
typedef LONG LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
			/* size is 4 */
typedef LONG LRESULT;

#endif // !_LRESULT_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
			/* size is 4 */
typedef WORD *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
			/* size is 4 */
typedef DWORD *LPDWORD;

#endif // !_LPDWORD_DEFINED
			/* size is 4 */
typedef void*	LPVOID;
typedef void	VOID;

typedef /* [string] */ char *LPSTR;

			/* size is 4 */
typedef /* [string] */ const char *LPCSTR;

			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 2 */
typedef short SHORT;

			/* size is 2 */
typedef unsigned short USHORT;

			/* size is 4 */
typedef DWORD ULONG;

			/* size is 4 */
typedef LONG HRESULT;

#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED
#if !defined( __LPGUID_DEFINED__ )
#define __LPGUID_DEFINED__
			/* size is 4 */
typedef GUID *LPGUID;

#endif // !__LPGUID_DEFINED__
#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
			/* size is 20 */
typedef struct  _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    }	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if !defined( __IID_DEFINED__ )
#define __IID_DEFINED__
			/* size is 16 */
typedef GUID IID;

			/* size is 4 */
typedef IID *LPIID;

#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
			/* size is 16 */
typedef GUID CLSID;

			/* size is 4 */
typedef CLSID *LPCLSID;

#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID &
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID &
#endif // !_REFCLSID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID * const
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID * const
#endif // !_REFCLSID_DEFINED
#endif // !__cplusplus
#endif // !__IID_DEFINED__

#endif /* _SUBWTYPE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\testprov.h ===
//----------------------------------------------------------------------------
//
// testprov.h
//
// Test HAL provider class.
//
// Test HAL provider is an itermediate object between D3DIM and 
// real HAL provider. Itis used to print some data sent to a driver to a 
// file. After that the real HAL driver is called.
// Test HAL provider is enabled by specifying non-empty string key "TestFile"
// under DIRECT3D key in the registry. The specified string is the name for 
// a binary file to output data to. File format is described in TESTFILE.H
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTPROV_H_
#define _TESTPROV_H_

class CTestHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};
//----------------------------------------------------------------------------
//
// GetTestProvider
//
// Input:
//      riid and pCurrentHalProvider are equal to the currently selected provider.
//      GlobalData  - data provided by DDraw
//      fileName    - output file name
//      dwFlags     - currently not used
//
// Returns:
//      the test HAL provider in ppHalProvider.
//      D3D_OK if success
//
//----------------------------------------------------------------------------
STDAPI GetTestHalProvider(REFIID riid, 
                          DDRAWI_DIRECTDRAW_GBL *pGlobalData,
                          IHalProvider **ppHalProvider,
                          IHalProvider * pCurrentHalProvider,
                          DWORD dwFlags);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifndef _DRAWPRIM_H_
#define _DRAWPRIM_H_

#define MAX_DX6_PRIMCOUNT   ((1<<16) - 1)
#define MAX_DX6_VERTICES    MAX_DX6_PRIMCOUNT

extern HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT downloadView(LPDIRECT3DVIEWPORTI);
extern HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI);
extern HRESULT CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI);

// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
extern HRESULT MapFVFtoTLVertex(LPDIRECT3DDEVICEI lpDevI, LPVOID lpAddress);
//---------------------------------------------------------------------
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_DRIVERSUPPORTED(lpDevI) (lpDevI->dwDeviceFlags & D3DDEV_FVF)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
//---------------------------------------------------------------------
// Input:
//    type      - FVF control word
//
// Returns D3D_OK, if the control word is valid.
// DDERR_INVALIDPARAMS otherwise
//
#undef  DPF_MODNAME
#define DPF_MODNAME "ValidateFVF"

__inline HRESULT ValidateFVF(DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;
    // Texture type fields should be 0
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if (type & 0xFFFF0000 ||
        type & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) ||
        (type & D3DFVF_RESERVED1 && !(type & D3DFVF_LVERTEX)) ||
        !(vertexType == D3DFVF_XYZRHW || vertexType == D3DFVF_XYZ)
        )
        goto error;

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
        goto error;
    return D3D_OK;
error:
    D3D_ERR("ValidateFVF() returns DDERR_INVALIDPARAMS");
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
// Computes vertex size in bytes from the vertex ID
//
__inline DWORD GetVertexSizeFVF(DWORD fvf)
{
    DWORD size = 3;
    if (FVF_TRANSFORMED(fvf))
        size++;
    if (fvf & D3DFVF_NORMAL)
        size += 3;
    if (fvf & D3DFVF_RESERVED1)
        size++;
    size += FVF_TEXCOORD_NUMBER(fvf) << 1;

    if (fvf & D3DFVF_DIFFUSE)
        size++;
    if (fvf & D3DFVF_SPECULAR)
        size++;
    return (size << 2);
}
//---------------------------------------------------------------------
__inline BOOL TextureStageEnabled(LPDIRECT3DDEVICEI lpDevI, DWORD dwStage)
{
    return (lpDevI->tsstates[dwStage][D3DTSS_COLOROP] != D3DTOP_DISABLE &&
            lpDevI->lpD3DMappedTexI[dwStage] != NULL);
}
//---------------------------------------------------------------------
// Computes nTexCoord and dwTextureIndexToCopy in case when a pre-DX6
// driver is used.
__inline void ComputeTCI2CopyLegacy(LPDIRECT3DDEVICEI lpDevI,
                                    DWORD dwNumInpTexCoord,
                                    BOOL bVertexTransformed)
{
    if (lpDevI->dwDeviceFlags & D3DDEV_LEGACYTEXTURE)
    {
        lpDevI->dwTextureIndexToCopy = 0;
        if (dwNumInpTexCoord)
            lpDevI->nTexCoord = 1;
        else
        {
            lpDevI->nTexCoord = 0;
            D3D_WARN(1, "Texture is enabled but vertex has no texture coordinates");
        }
    }
    else
    {
        if (TextureStageEnabled(lpDevI, 0))
        {
            if (lpDevI->tsstates[0][D3DTSS_TEXCOORDINDEX] >= dwNumInpTexCoord)
            {
                lpDevI->nTexCoord = 0;
                lpDevI->dwTextureIndexToCopy = 0;
                D3D_WARN(1, "Texture index in a texture stage is greater than number of texture coord in vertex");
            }
            else
            {
                lpDevI->dwTextureIndexToCopy = lpDevI->tsstates[0][D3DTSS_TEXCOORDINDEX];
                if (bVertexTransformed)
                {
                    // In case of clipping we need to clip as many texture
                    // coordinates as set in the texture stage state.
                    lpDevI->nTexCoord = min(dwNumInpTexCoord,
                                            lpDevI->dwTextureIndexToCopy+1);
                }
                else
                {
                    // Number of output texture coordinates is 1 because we will
                    // build the output buffer in the inner transform & lihgting
                    // loop.
                    lpDevI->nTexCoord = 1;
                }
            }
        }
        else
        {
            lpDevI->nTexCoord = 0;
            lpDevI->dwTextureIndexToCopy = 0;
        }
    }
}
//---------------------------------------------------------------------
// Computes output FVF id, based on input FVF id and device settingd
// Also computes nTexCoord field
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF sould
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "ComputeOutputFVF"
__inline void ComputeOutputFVF(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwVIDIn == lpDevI->dwFVFLastIn)
    {
        lpDevI->dwVIDOut = lpDevI->dwFVFLastOut;
        lpDevI->dwOutputSize = lpDevI->dwFVFLastOutputSize;
        lpDevI->nTexCoord = lpDevI->dwFVFLastTexCoord;
        return;
    }
    DWORD dwNumInpTexCoord = FVF_TEXCOORD_NUMBER(lpDevI->dwVIDIn);
    // Compute how many texture coordinates to copy
    if (lpDevI->dwMaxTextureIndices == 0)
        lpDevI->nTexCoord = 0;
    else
    if (!(lpDevI->dwDeviceFlags & D3DDEV_FVF))
    {
        ComputeTCI2CopyLegacy(lpDevI, dwNumInpTexCoord, FVF_TRANSFORMED(lpDevI->dwVIDIn));
    }
    else
    {
        if (lpDevI->dwDeviceFlags & D3DDEV_LEGACYTEXTURE)
            lpDevI->nTexCoord = 1;
        else
        {
        // Find the max used index
            if (!(lpDevI->dwFEFlags & D3DFE_TSSINDEX_DIRTY))
                lpDevI->nTexCoord = lpDevI->dwMaxUsedTextureIndex;
            else
            {
                lpDevI->dwMaxUsedTextureIndex = 0;
                for (DWORD i=0; i < lpDevI->dwMaxTextureBlendStages; i++)
                {
                    if (lpDevI->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
                        break;

                    if (lpDevI->lpD3DMappedTexI[i] != NULL)
                    {
                        DWORD dwNewMaxTexCoord = lpDevI->tsstates[i][D3DTSS_TEXCOORDINDEX] + 1;
                        if (lpDevI->dwMaxUsedTextureIndex < dwNewMaxTexCoord)
                        {
                            lpDevI->dwMaxUsedTextureIndex = dwNewMaxTexCoord;
                        }
                    }
                }
                lpDevI->nTexCoord = lpDevI->dwMaxUsedTextureIndex;
                lpDevI->dwFEFlags &= ~D3DFE_TSSINDEX_DIRTY;
            }
        }
        if (lpDevI->nTexCoord > dwNumInpTexCoord)
        {
            lpDevI->nTexCoord = dwNumInpTexCoord;
            D3D_WARN(1, "Texture index in a texture stage is greater than number of texture coord in vertex");
        }
    }
    if (!(lpDevI->dwDeviceFlags & D3DDEV_FVF))
    {
        lpDevI->dwVIDOut = D3DFVF_TLVERTEX;
        lpDevI->dwOutputSize = sizeof(D3DTLVERTEX);
    }
    else
    {
        if (lpDevI->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
        {   // In this case diffuse, specular and at least one texture
            // should present
            lpDevI->dwVIDOut = D3DFVF_XYZRHW | D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
            if (lpDevI->nTexCoord == 0)
                lpDevI->dwVIDOut |= 1 << D3DFVF_TEXCOUNT_SHIFT;
            else
                lpDevI->dwVIDOut |= lpDevI->nTexCoord << D3DFVF_TEXCOUNT_SHIFT;
        }
        else
        {
            lpDevI->dwVIDOut = D3DFVF_XYZRHW;
            // If normal present we have to compute specular and duffuse
            // Otherwise set these bits the same as input.
            // Not that normal should not be present for XYZRHW position type
            if (lpDevI->dwVIDIn & D3DFVF_NORMAL)
                lpDevI->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
            else
                lpDevI->dwVIDOut |= lpDevI->dwVIDIn &
                                    (D3DFVF_DIFFUSE | D3DFVF_SPECULAR);
            // Always set specular flag if fog is enabled
            if (lpDevI->rstates[D3DRENDERSTATE_FOGENABLE])
                lpDevI->dwVIDOut |= D3DFVF_SPECULAR;
            else
            // Clear specular flag if specular disabled
            if (!lpDevI->rstates[D3DRENDERSTATE_SPECULARENABLE])
                lpDevI->dwVIDOut &= ~D3DFVF_SPECULAR;
            lpDevI->dwVIDOut |= lpDevI->nTexCoord << D3DFVF_TEXCOUNT_SHIFT;
        }
        lpDevI->dwOutputSize = GetVertexSizeFVF(lpDevI->dwVIDOut);
    }
    lpDevI->dwFVFLastIn = lpDevI->dwVIDIn;
    lpDevI->dwFVFLastOut = lpDevI->dwVIDOut;
    lpDevI->dwFVFLastOutputSize = lpDevI->dwOutputSize;
    lpDevI->dwFVFLastTexCoord = lpDevI->nTexCoord;
    return;
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CheckDeviceSettings"
inline HRESULT CheckDeviceSettings(LPDIRECT3DDEVICEI lpDevI)
{
    LPDIRECT3DVIEWPORTI lpView = lpDevI->lpCurrentViewport;
#if DBG
    if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE) && IS_DX5_COMPATIBLE_DEVICE(lpDevI))
    {
        D3D_ERR( "Not in scene" );
        return D3DERR_SCENE_NOT_IN_SCENE;
    }

    if (!lpView)
    {
        D3D_ERR( "Current viewport not set" );
        return D3DERR_INVALIDCURRENTVIEWPORT;
    }

    if (!lpView->v_data_is_set)
    {
        D3D_ERR("Viewport data is not set yet");
        return D3DERR_VIEWPORTDATANOTSET;
    }

    if (lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INBEGIN)
    {
        D3D_ERR( "Illegal call between Begin/End" );
        return D3DERR_INBEGIN;
    }
#endif
    // Viewport ID could be different from Device->v_id, because during Execute call
    // Device->v_id is changed to whatever viewport is used as a parameter.
    // So we have to make sure that we use the right viewport.
    //
    if (lpDevI->v_id != lpView->v_id)
    {
        return downloadView(lpView);
    }
    else
        return D3D_OK;
}
//---------------------------------------------------------------------
// Computes the number of primtives and also updates the stats accordingly
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         lpDevI->D3DStats
//         return value = dwNumPrimitives
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrim"

inline DWORD GetNumPrim(LPDIRECT3DDEVICEI lpDevI, DWORD dwNumVertices)
{
    lpDevI->dwNumPrimitives = 0;
    switch (lpDevI->primType)
    {
    case D3DPT_POINTLIST:
        lpDevI->D3DStats.dwPointsDrawn += lpDevI->dwNumPrimitives = dwNumVertices;
        break;
    case D3DPT_LINELIST:
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives = dwNumVertices >> 1;
        break;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return 0;
        lpDevI->D3DStats.dwLinesDrawn += lpDevI->dwNumPrimitives = dwNumVertices - 1;
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return 0;
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives = dwNumVertices - 2;
        break;
    case D3DPT_TRIANGLELIST:
#ifdef _X86_
        {
            DWORD tmp;
            __asm
            {
                mov  eax, 0x55555555    // fractional part of 1.0/3.0
                mul  dwNumVertices
                add  eax, 0x80000000    // Rounding
                adc  edx, 0
                mov  tmp, edx
            }
            lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives = tmp;
        }
#else
        lpDevI->D3DStats.dwTrianglesDrawn += lpDevI->dwNumPrimitives = dwNumVertices / 3;
#endif
        break;
    }
    return lpDevI->dwNumPrimitives;
}
//---------------------------------------------------------------------
// Sets front-end flags every time fog state is changed
//
inline void SetFogFlags(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->lighting.fog_mode != D3DFOG_NONE &&
        lpDevI->rstates[D3DRENDERSTATE_FOGENABLE])
    {
        lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY | D3DFE_FOGENABLED;
    }
    else
        lpDevI->dwFEFlags &= ~D3DFE_FOGENABLED;
    lpDevI->dwFVFLastIn = 0; // Force re-computing of FVF id
}
//---------------------------------------------------------------------
// Validates DrawPrimitive flags
//
inline BOOL IsDPFlagsValid(DWORD dwFlags)
{
    BOOL ret = ((dwFlags & ~(D3DDP_DONOTCLIP | D3DDP_DONOTUPDATEEXTENTS |
                             D3DDP_WAIT | D3DDP_DONOTLIGHT)
                ) == 0);
    if (!ret)
    {
        D3D_ERR( "Invalid bit set in DrawPrimitive flags" );
    }
    return ret;
}
//---------------------------------------------------------------------
// Allocate memory to hold vertex data, assume all vertices are
// of same size
inline HRESULT CheckVertexBatch(LPDIRECT3DDEVICEI lpDevI)
{
    if (!lpDevI->lpvVertexBatch)
    {
        if (D3DMalloc((void**) &lpDevI->lpvVertexBatch,
                       BEGIN_DATA_BLOCK_MEM_SIZE))
        {
            D3D_ERR( "Out of memory" );
            return DDERR_OUTOFMEMORY;
        }
        // Allocate memory to hold index data
        if (D3DMalloc((void**) &lpDevI->lpIndexBatch,
                      BEGIN_DATA_BLOCK_SIZE * sizeof(WORD) * 16))
        {
            D3DFree( lpDevI->lpvVertexBatch );
            D3D_ERR( "Out of memory" );
            return DDERR_OUTOFMEMORY;
        }
    }
    return D3D_OK;
}

#endif _DRAWPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\texman.hpp ===
#ifndef TEXMAN_INCLUDED
#define TEXMAN_INCLUDED

#define MAXLOGTEXSIZE 25
typedef class TextureCacheManager *LPTextureCacheManager;

/* 
   The texture cache manager does all cache management. The data structure used is
   a hash table with the hash variable being the log (base 2) of the total size of 
   the texture in pixels. Each bucket corresponding to a texture size is a list of 
   CacheInfos. The LRU algorithm works as follows:
     1. Is the texture corresponding to the GL handle in the cache?
     2. If it is, increment the timestamp and return the D3D handle.
     3. If not, attempt to allocate a DirectDraw surface. If there is no memory,
        we need to free some texture and try again (see step 4), else add a CacheInfo 
        corresponding to this newly allocated DirectDraw surface, QI it for a texture 
        object and return the D3D handle.
     4. We have to reuse some old textures, so try to find the oldest texture of the 
        same size. If we find such a texture, just Blt the new texture onto the old.
        If a texture of the same size is not available, we freeup some bigger textures
        and go to step 3.
*/

class TextureCacheManager {

  LPD3DBUCKET tcm_bucket[MAXLOGTEXSIZE];
  unsigned int tcm_ticks, numvidtex;
  LPDIRECT3DI	lpDirect3DI;
  // Replace a texture of size k with a new texture corresponding to glhandle
  //LPD3DBUCKET replace(int k, LPDIRECT3DTEXTUREI lpD3DTexI);

  // Free the oldest texture of same size as lpD3DTexI 
  BOOL freeNode(LPD3DI_TEXTUREBLOCK lpBlock, LPD3DBUCKET* lplpBucket);

  //remove any HW handle that's not with lpBlock->lpDevI,save lpBlock->hTex,keep surface
  void replace(LPD3DBUCKET bucket,LPD3DI_TEXTUREBLOCK lpBlock);  
  
public:
  HRESULT allocNode(LPD3DI_TEXTUREBLOCK lpBlock);
  TextureCacheManager(LPDIRECT3DI lpD3DI);
  ~TextureCacheManager();
  //remove all HW handles and release surface
  void remove(LPD3DBUCKET bucket);  

  // Empty the entire cache
  void EvictTextures();
  void cleanup();	// clean up invalidated nodes by destructors of texture/texture3
  BOOL CheckIfLost(); // check if any of the managed textures are lost
  inline void TimeStamp(LPD3DBUCKET bucket){bucket->ticks=tcm_ticks++;}
  inline void TimeStamp(){++tcm_ticks;}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\lists.hpp ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef _LISTS_H
#define _LISTS_H

#define LIST_ROOT(name, type) struct name {type *Root;}

#define LIST_MEMBER(type) struct { type **Prev; type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
    (root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    if ((element)->field.Prev)\
    {\
        *(element)->field.Prev = (element)->field.Next;\
        (element)->field.Prev = 0;\
    }\
    (element)->field.Next = 0;\
}

#define LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   type *First;\
    type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   type *Next;\
    type **Prev;    /* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   type *Last;\
    type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   type *Prev;\
    type *Next;\
}

#define CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
    (root)->Last->field.Next = (element);\
    else\
    (root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
    (root)->First->field.Prev = (element);\
    else\
    (root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
    (current_element)->field.Prev->field.Next = (element);\
    else\
    (root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
    (element)->field.Prev->field.Next = (element)->field.Next;\
    else\
    (root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.hpp"

void TestList(void)
{
    struct Foo
    {
    int a;
    LIST_MEMBER(Foo) ListStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
    int a;
    TAIL_QUEUE_MEMBER(Foo) TQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
    int a;
    CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
    int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
    CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
    switch(WhichInsert)
    {
    case END:
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        WhichInsert = ROOT;
        break;
    case ROOT:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        WhichInsert = PREVIOUS;
        break;
    case PREVIOUS:
        CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
        CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
        WhichInsert = DONE;
        break;
    default:
        assert(0);
    }

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

    pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
    pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
    assert(pFoo == &MyFoo3);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
    assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */


#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dim\inc\tlhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       tlhal.h
 *  Content:    Support code for HALs with hardware transform & light
 *
 ***************************************************************************/
#ifndef _TLHAL_H_
#define _TLHAL_H_


//  transform, viewport, light set
HRESULT D3DHALTLTransformSetData( LPDIRECT3DDEVICEI lpDevI, D3DTRANSFORMSTATETYPE dtsType, LPD3DMATRIX lpMatrix );
HRESULT D3DHALTLViewportSetData( LPDIRECT3DDEVICEI lpDevI, D3DVIEWPORT2* pViewport2 );
HRESULT D3DHALTLViewportSetData( LPDIRECT3DDEVICEI lpDevI, D3DVIEWPORT2* pViewport2 );
HRESULT D3DHALTLLightSetData( LPDIRECT3DDEVICEI lpDevI, DWORD dwLightOffset, BOOL bLastLight, D3DLIGHT2* pLight2 );

//  clip status set/get
HRESULT D3DHALTLClipStatusSetData( LPDIRECT3DDEVICEI lpDevI, LPD3DCLIPSTATUS lpClipStatus );
HRESULT D3DHALTLClipStatusGetData( LPDIRECT3DDEVICEI lpDevI, LPD3DCLIPSTATUS lpClipStatus );

//  material management utilities
DWORD   D3DHALTLMaterialCreate( LPDIRECT3DDEVICEI lpDevI );
void    D3DHALTLMaterialDestroy( LPDIRECT3DDEVICEI lpDevI, DWORD hMat );
HRESULT D3DHALTLMaterialSetData( LPDIRECT3DDEVICEI lpDevI, DWORD hMat, D3DMATERIAL* pMat );
DWORD   D3DHALTLMaterialRemapHandle( LPDIRECT3DDEVICEI lpDevI, DWORD hMat );

#endif /* _TLHAL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\cppdbg.cpp ===
//----------------------------------------------------------------------------
//
// cppdbg.cpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

#ifdef _ALPHA_
// On Alpha va_list is a structure so it's not compatible with NULL.
static va_list NULLVA;
#else
#define NULLVA NULL
#endif

static DebugModuleFlags g_FailureFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_FAILURE, BREAK),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, OUTPUT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, PROMPT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, FILENAME_ONLY),
    0, NULL,
};

static DebugModuleFlags g_OutputFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, SUPPRESS),
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, ALL_MATCH),
    0, NULL,
};

static char *g_pFlagNames[] =
{
    "AssertFlags",
    "HrFlags",
    "OutputFlags",
    "OutputMask",
    "UserFlags"
};

//----------------------------------------------------------------------------
//
// DebugModule::DebugModule
//
//----------------------------------------------------------------------------

DebugModule::DebugModule(char *pModule, char *pPrefix,
                         DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                         DebugModuleFlags *pUserFlags, UINT uUserFlags)
{
    m_pModule = pModule;
    m_iModuleStartCol = strlen(m_pModule) + 2;
    m_pPrefix = pPrefix;

    m_pModFlags[DBG_ASSERT_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_HR_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_OUTPUT_FLAGS] = g_OutputFlags;
    m_pModFlags[DBG_OUTPUT_MASK] = pOutputMasks;
    m_pModFlags[DBG_USER_FLAGS] = pUserFlags;

    m_uFlags[DBG_ASSERT_FLAGS] = DBG_FAILURE_OUTPUT | DBG_FAILURE_BREAK |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_HR_FLAGS] = DBG_FAILURE_OUTPUT | 
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_OUTPUT_FLAGS] = 0;
    m_uFlags[DBG_OUTPUT_MASK] = uOutputMask;
    m_uFlags[DBG_USER_FLAGS] = uUserFlags;
    
    ReadReg();
}

//----------------------------------------------------------------------------
//
// DebugModule::OutVa
//
// Base debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::OutVa(UINT uMask, char *pFmt, va_list Args)
{
    if (m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_SUPPRESS)
    {
        return;
    }
    
    if ((uMask & DBG_MASK_NO_PREFIX) == 0)
    {
        OutputDebugStringA(m_pModule);
        OutputDebugStringA(": ");
    }

    char chMsg[1024];

    _vsnprintf(chMsg, sizeof(chMsg), pFmt, Args);
    OutputDebugStringA(chMsg);
}

//----------------------------------------------------------------------------
//
// DebugModule::Out
//
// Always-output debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::Out(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    OutVa(0, pFmt, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedVa
//
// Handles assertion failure output and interface.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine)
{
    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        if (OutPathFile("Assertion failed", m_uFlags[DBG_ASSERT_FLAGS]))
        {
            OutVa(DBG_MASK_NO_PREFIX, ":\n    ", NULLVA);
        }
        else
        {
            OutVa(DBG_MASK_NO_PREFIX, ": ", NULLVA);
        }
        
        OutVa(DBG_MASK_NO_PREFIX, pFmt, Args);
        if (bNewLine)
        {
            OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        }
    }

    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailed
//
// Handles simple expression assertion failures.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailed(char *pExp)
{
    AssertFailedVa(pExp, NULLVA, TRUE);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedMsg
//
// Handles assertion failures with arbitrary debug output.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedMsg(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    AssertFailedVa(pFmt, Args, FALSE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::HrFailure
//
// Handles HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrFailure(HRESULT hr, char *pPrefix)
{
    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        OutPathFile(pPrefix, m_uFlags[DBG_HR_FLAGS]);
        OutMask(DBG_MASK_FORCE_CONT, ": %s\n", HrString(hr));
    }

    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_BREAK)
    {
#if DBG
        DebugBreak();
#endif
    }
    else if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::HrStmtFailed
//
// Handles statement-style HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrStmtFailed(HRESULT hr)
{
    HrFailure(hr, "HR test fail");
}

//----------------------------------------------------------------------------
//
// DebugModule::ReturnHr
//
// Handles expression-style HRESULT failures.
//
//----------------------------------------------------------------------------

HRESULT DebugModule::HrExpFailed(HRESULT hr)
{
    HrFailure(hr, "HR expr fail");
    return hr;
}

//----------------------------------------------------------------------------
//
// DebugModule::Prompt
//
// Allows control over debug options via interactive input.
//
//----------------------------------------------------------------------------

void DebugModule::Prompt(char *pFmt, ...)
{
    va_list Args;

    if (pFmt != NULL)
    {
        va_start(Args, pFmt);
        OutVa(0, pFmt, Args);
        va_end(Args);
    }

#ifdef WINNT
    char szInput[512];
    char *pIdx;
    int iIdx;
    static char szFlagCommands[] = "ahomu";

    for (;;)
    {
        ULONG uLen;
        
        uLen = DbgPrompt("[bgaAFhHmMoOrRuU] ", szInput, sizeof(szInput) - 1);
        if (uLen < 2)
        {
            Out("DbgPrompt failed\n");
#if DBG
            DebugBreak();
#endif
            return;
        }

        // ATTENTION - Currently DbgPrompt returns a length that is two
        // greater than the actual number of characters.  Presumably this
        // is an artifact of the Unicode/ANSI conversion and should
        // really only be one greater, so attempt to handle both.

        uLen -= 2;
        if (szInput[uLen] != 0)
        {
            uLen++;
            szInput[uLen] = 0;
        }

        if (uLen < 1)
        {
            Out("Empty command ignored\n");
            continue;
        }
        
        switch(szInput[0])
        {
        case 'b':
#if DBG
            DebugBreak();
#endif
            break;
        case 'g':
            return;
            
        case 'r':
            WriteReg();
            break;
        case 'R':
            ReadReg();
            break;

        case 'a':
        case 'A':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            char chLower;

            if (szInput[0] >= 'A' && szInput[0] <= 'Z')
            {
                chLower = szInput[0] - 'A' + 'a';
            }
            else
            {
                chLower = szInput[0];
            }

            pIdx = strchr(szFlagCommands, chLower);
            if (pIdx == NULL)
            {
                // Should never happen.
                break;
            }

            iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
            if (szInput[0] == chLower)
            {
                // Set.
                m_uFlags[iIdx] = ParseUint(szInput + 1, m_pModFlags[iIdx]);
            }

            // Set or Get.
            OutUint(g_pFlagNames[iIdx], m_pModFlags[iIdx], m_uFlags[iIdx]);
            break;
            
        case 'F':
            if (uLen < 2)
            {
                Out("'F' must be followed by a flag group specifier\n");
                break;
            }
            
            pIdx = strchr(szFlagCommands, szInput[1]);
            if (pIdx == NULL)
            {
                Out("Unknown flag group '%c'\n", szInput[1]);
            }
            else
            {
                iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
                ShowFlags(g_pFlagNames[iIdx], m_pModFlags[iIdx]);
            }
            break;

        default:
            Out("Unknown command '%c'\n", szInput[0]);
            break;
        }
    }
#else
    OutUint("OutputMask", m_pModFlags[DBG_OUTPUT_MASK],
            m_uFlags[DBG_OUTPUT_MASK]);
    Out("Prompt not available\n");
#if DBG
    DebugBreak();
#endif
#endif
}

//----------------------------------------------------------------------------
//
// DebugModule::OpenDebugKey
//
// Opens the Direct3D\Debug\m_pModule key.
//
//----------------------------------------------------------------------------

HKEY DebugModule::OpenDebugKey(void)
{
    HKEY hKey;
    char szKeyName[128];

    strcpy(szKeyName, "Software\\Microsoft\\Direct3D\\Debug\\");
    strcat(szKeyName, m_pModule);
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS,
                      &hKey) != ERROR_SUCCESS)
    {
        return NULL;
    }
    else
    {
        return hKey;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::GetRegUint
//
// Gets a UINT value from the given key.
//
//----------------------------------------------------------------------------

UINT DebugModule::GetRegUint(HKEY hKey, char *pValue, UINT uDefault)
{
    DWORD dwType, dwSize;
    DWORD dwVal;

    dwSize = sizeof(dwVal);
    if (RegQueryValueExA(hKey, pValue, NULL, &dwType, (BYTE *)&dwVal,
                         &dwSize) != ERROR_SUCCESS ||
        dwType != REG_DWORD)
    {
        return uDefault;
    }
    else
    {
        return (UINT)dwVal;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::SetRegUint
//
// Sets a UINT value for the given key.
//
//----------------------------------------------------------------------------

BOOL DebugModule::SetRegUint(HKEY hKey, char *pValue, UINT uValue)
{
    return RegSetValueExA(hKey, pValue, NULL, REG_DWORD, (BYTE *)&uValue,
                          sizeof(uValue)) == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
// DebugModule::ReadReg
//
// Reads settings from the registry.
//
//----------------------------------------------------------------------------

void DebugModule::ReadReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            m_uFlags[iIdx] = GetRegUint(hKey, g_pFlagNames[iIdx],
                                        m_uFlags[iIdx]);
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::WriteReg
//
// Writes values to the registry.
//
//----------------------------------------------------------------------------

void DebugModule::WriteReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            if (!SetRegUint(hKey, g_pFlagNames[iIdx], m_uFlags[iIdx]))
            {
                OutputDebugStringA("Error writing registry information\n");
            }
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ParseUint
//
// Parses a string for a numeric value or a set of flag strings.
//
//----------------------------------------------------------------------------

UINT DebugModule::ParseUint(char *pString, DebugModuleFlags *pFlags)
{
    UINT uVal;

    uVal = 0;

    for (;;)
    {
        while (*pString != 0 &&
               (*pString == ' ' || *pString == '\t'))
        {
            pString++;
        }

        if (*pString == 0)
        {
            break;
        }

        char *pEnd;
        int iStepAfter;

        pEnd = pString;
        while (*pEnd != 0 && *pEnd != ' ' && *pEnd != '\t')
        {
            pEnd++;
        }
        iStepAfter = *pEnd != 0 ? 1 : 0;
        *pEnd = 0;
        
        if (*pString >= '0' && *pString <= '9')
        {
            uVal |= strtoul(pString, &pString, 0);
            if (*pString != 0 && *pString != ' ' && *pString != '\t')
            {
                Out("Unrecognized characters '%s' after number\n", pString);
            }
        }
        else if (pFlags != NULL)
        {
            DebugModuleFlags *pFlag;
            
            for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
            {
                if (!_stricmp(pString, pFlag->pName))
                {
                    break;
                }
            }

            if (pFlag->uFlag == 0)
            {
                Out("Unrecognized flag string '%s'\n", pString);
            }
            else
            {
                uVal |= pFlag->uFlag;
            }
        }
        else
        {
            Out("No flag definitions, unable to convert '%s'\n", pString);
        }

        pString = pEnd + iStepAfter;
    }

    return uVal;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutUint
//
// Displays a UINT as a set of flag strings.
//
//----------------------------------------------------------------------------

void DebugModule::OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue)
{
    if (pFlags == NULL || uValue == 0)
    {
        Out("%s: 0x%08X\n", pName, uValue);
        return;
    }

    Out("%s:", pName);
    m_iStartCol = m_iModuleStartCol + strlen(pName) + 1;
    m_iCol = m_iStartCol;
    
    while (uValue != 0)
    {
        DebugModuleFlags *pFlag;

        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            if ((pFlag->uFlag & uValue) == pFlag->uFlag)
            {
                AdvanceCols(strlen(pFlag->pName) + 1);
                OutMask(DBG_MASK_FORCE_CONT, " %s", pFlag->pName);
                uValue &= ~pFlag->uFlag;
                break;
            }
        }

        if (pFlag->uFlag == 0)
        {
            AdvanceCols(11);
            OutMask(DBG_MASK_FORCE_CONT, " 0x%X", uValue);
            uValue = 0;
        }
    }

    OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
}

//----------------------------------------------------------------------------
//
// DebugModule::AdvanceCols
//
// Determines if there's enough space on the current line for
// the given number of columns.  If not, a new line is started.
//
//----------------------------------------------------------------------------

void DebugModule::AdvanceCols(int iCols)
{
    static char szSpaces[] = "                                ";

    m_iCol += iCols;
    if (m_iCol >= 79)
    {
        int iSpace;
            
        OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        // Force a prefix to be printed to start the line.
        Out("");
        
        m_iCol = m_iModuleStartCol;
        while (m_iCol < m_iStartCol)
        {
            iSpace = (int)min(sizeof(szSpaces) - 1, m_iStartCol - m_iCol);
            OutMask(DBG_MASK_FORCE_CONT, "%.*s", iSpace, szSpaces);
            m_iCol += iSpace;
        }
    }
}   

//----------------------------------------------------------------------------
//
// DebugModule::ShowFlags
//
// Shows the given flag set.
//
//----------------------------------------------------------------------------

void DebugModule::ShowFlags(char *pName, DebugModuleFlags *pFlags)
{
    DebugModuleFlags *pFlag;

    Out("%s:\n", pName);
    if (pFlags == NULL)
    {
        Out("    None defined\n");
    }
    else
    {
        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            Out("    0x%08X - %s\n", pFlag->uFlag, pFlag->pName);
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::PathFile
//
// Returns the trailing filename component or NULL if the path is
// only a filename.
//
//----------------------------------------------------------------------------

char *DebugModule::PathFile(char *pPath)
{
    char *pFile, *pSlash, *pBack, *pColon;
            
    pBack = strrchr(pPath, '\\');
    pSlash = strrchr(pPath, '/');
    pColon = strrchr(pPath, ':');

    pFile = pBack;
    if (pSlash > pFile)
    {
        pFile = pSlash;
    }
    if (pColon > pFile)
    {
        pFile = pColon;
    }

    return pFile != NULL ? pFile + 1 : NULL;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutPathFile
//
// Outputs the given string plus a path and filename.
// Returns whether the full path was output or not.
//
//----------------------------------------------------------------------------

BOOL DebugModule::OutPathFile(char *pPrefix, UINT uFailureFlags)
{
    char *pFile;
        
    if (uFailureFlags & DBG_FAILURE_FILENAME_ONLY)
    {
        pFile = PathFile(m_pFile);
    }
    else
    {
        pFile = NULL;
    }
        
    if (pFile == NULL)
    {
        Out("%s %s(%d)", pPrefix, m_pFile, m_iLine);
        return TRUE;
    }
    else
    {
        Out("%s <>\\%s(%d)", pPrefix, pFile, m_iLine);
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_ONCE(Global, G, NULL, 0, NULL, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <span.h>

DBG_DECLARE_FILE();

// Declare TextureDiff as an out-of-line function.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    GDPF(("!! DebugBreakFn called.  Leaving this function may destroy\n"));
    GDPF(("   the stack frame. !!\n"));
#if DBG
    DebugBreak();
#endif
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#define COVERAGE_AVERAGE 1
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLESTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLEEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGTABLEDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    GASSERTMSG(FALSE, ("ComputeTableFog unreachable\n"));
    return 0;
}

//----------------------------------------------------------------------------
//
// pVecNormalize2
//
// Normalizes the given D3DVECTOR.  Supports in-place operation.
//
//----------------------------------------------------------------------------

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes)
{
    FLOAT fLen;

    fLen = pVecLenSq(pVec);
    if (FLOAT_CMP_POS(fLen, <=, g_fNearZero))
    {
        pVecSet(pRes, 0.0f, 0.0f, 0.0f);
        return;
    }
    fLen = ISQRTF(fLen);
    pVecScale(pVec, fLen, pRes);
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3, D3DVECTORH *plane)
{
    D3DVECTOR a;
    D3DVECTOR b;

    pVecSub(v2, v1, &a);
    pVecSub(v3, v1, &b);

    plane->x = a.y*b.z - a.z*b.y;
    plane->y = a.z*b.x - a.x*b.z;
    plane->z = a.x*b.y - a.y*b.x;
    plane->w = - pVecDot(v1, plane);

    double tmp = pVecDot(plane, plane);
    if (tmp <= 0)
        return -1;
    tmp = 1.0/sqrt(tmp);

    plane->x = (D3DVALUE)(plane->x * tmp);
    plane->y = (D3DVALUE)(plane->y * tmp);
    plane->z = (D3DVALUE)(plane->z * tmp);
    plane->w = (D3DVALUE)(plane->w * tmp);
    return 0;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        dwStride += sizeof(D3DVALUE) * 2 * iTexCount;
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return D3D_OK;
}
//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\cppdbg.hpp ===
//----------------------------------------------------------------------------
//
// cppdbg.hpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _CPPDBG_HPP_
#define _CPPDBG_HPP_

#if DBG

#include <stdarg.h>

typedef unsigned int UINT;
        
//
// Mask bits common to all modules.
//

#define DBG_MASK_NO_PREFIX              0x80000000
#define DBG_MASK_FORCE                  0x40000000

// Mask bits checked against output mask.
#define DBG_MASK_CHECK                  (~(DBG_MASK_NO_PREFIX | \
                                           DBG_MASK_FORCE))

// Forced continuation mask.
#define DBG_MASK_FORCE_CONT             (DBG_MASK_NO_PREFIX | DBG_MASK_FORCE)

//
// Failure control bits for assert and HRESULT failures.
//

#define DBG_FAILURE_BREAK               0x00000001
#define DBG_FAILURE_OUTPUT              0x00000002
#define DBG_FAILURE_PROMPT              0x00000004
#define DBG_FAILURE_FILENAME_ONLY       0x00000008

//
// Overall output control bits.
//

#define DBG_OUTPUT_SUPPRESS             0x00000001
#define DBG_OUTPUT_ALL_MATCH            0x00000002

//----------------------------------------------------------------------------
//
// DebugModule
//
//----------------------------------------------------------------------------

struct DebugModuleFlags
{
    UINT uFlag;
    char *pName;
};

// Declares a DebugModuleFlags entry.
#define DBG_DECLARE_MODFLAG(Group, Name) \
    Group ## _ ## Name, #Name

enum
{
    DBG_ASSERT_FLAGS,
    DBG_HR_FLAGS,
    DBG_OUTPUT_FLAGS,
    DBG_OUTPUT_MASK,
    DBG_USER_FLAGS,
    DBG_FLAGS_COUNT
};

class DebugModule
{
public:
    DebugModule(char *pModule, char *pPrefix,
                DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                DebugModuleFlags *pUserFlags, UINT uUserFlags);

    void Out(char *pFmt, ...);

    void OutMask(UINT uMask, char *pFmt, ...)
    {
        if ((uMask & DBG_MASK_FORCE) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) == uMask) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) == 0 &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) != 0))
        {
            va_list Args;

            va_start(Args, pFmt);
            OutVa(uMask, pFmt, Args);
            va_end(Args);
        }
    }
    
    void AssertFailed(char *pExp);
    void AssertFailedMsg(char *pFmt, ...);

    void HrStmtFailed(HRESULT hr);
    HRESULT HrExpFailed(HRESULT hr);
    
    void SetFileLine(char *pFile, int iLine)
    {
        m_pFile = pFile;
        m_iLine = iLine;
    }

    void Prompt(char *pFmt, ...);

    UINT GetFlags(int iIdx)
    {
        return m_uFlags[iIdx];
    }
    void SetFlags(int iIdx, UINT uValue)
    {
        m_uFlags[iIdx] = uValue;
    }

private:
    void OutVa(UINT uMask, char *pFmt, va_list Args);
    void AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine);

    HKEY OpenDebugKey(void);
    UINT GetRegUint(HKEY hKey, char *pValue, UINT uDefault);
    BOOL SetRegUint(HKEY hKey, char *pValue, UINT uValue);
    void ReadReg(void);
    void WriteReg(void);

    UINT ParseUint(char *pString, DebugModuleFlags *pFlags);
    void OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue);

    void AdvanceCols(int iCols);

    void ShowFlags(char *pName, DebugModuleFlags *pFlags);

    char *PathFile(char *pPath);
    BOOL OutPathFile(char *pPrefix, UINT uFailureFlags);

    void HrFailure(HRESULT hr, char *pPrefix);
    char *HrString(HRESULT hr);
    
    // Module information given.
    char *m_pModule;
    char *m_pPrefix;
    
    // Flag descriptions and values.
    DebugModuleFlags *m_pModFlags[DBG_FLAGS_COUNT];
    UINT m_uFlags[DBG_FLAGS_COUNT];

    // Temporary file and line number storage.
    char *m_pFile;
    int m_iLine;

    // Output column during multiline display.
    int m_iModuleStartCol;
    int m_iCol;
    int m_iStartCol;
};

//----------------------------------------------------------------------------
//
// Support macros.
//
//----------------------------------------------------------------------------

#define DBG_MODULE(Prefix) Prefix ## _Debug

// Put this in one source file.
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags) \
    DebugModule DBG_MODULE(Prefix)(#Module, #Prefix, \
                                   pOutputMasks, uOutputMask, \
                                   pUserFlags, uUserFlags)

// Put this in your derived debugging header.
#define DBG_DECLARE_HEADER(Prefix) \
    extern DebugModule DBG_MODULE(Prefix)

// Put this in every file.
#define DBG_DECLARE_FILE() \
    static char *g_pStaticDebugFile = __FILE__

#define DBG_DECLARE_DPF(Prefix, Args) \
    DBG_MODULE(Prefix).Out Args
#define DBG_DECLARE_DPFM(Prefix, Args) \
    DBG_MODULE(Prefix).OutMask Args

#define DBG_DECLARE_ASSERT(Prefix, Exp) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailed(#Exp); } \
    else 0
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailedMsg Args ; } \
    else 0
#define DBG_DECLARE_VERIFY(Prefix, Exp) \
    DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args)\
    DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)

#define DBG_DECLARE_PROMPT(Prefix, Args) \
    DBG_MODULE(Prefix).Prompt Args

#define DBG_DECLARE_GETFLAGS(Prefix, Idx) \
    DBG_MODULE(Prefix).GetFlags(Idx)
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value) \
    DBG_MODULE(Prefix).SetFlags(Idx, Value)

//
// These macros assume a variable 'hr' exists.
//

// HRESULT test in expression form.
#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    ((hr = (Exp)) != S_OK ? \
      (DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__), \
       DBG_MODULE(Prefix).HrExpFailed(hr)) : hr)

// HRESULT test in if/then form.
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).HrStmtFailed(hr); \
      DoFail; } \
    else hr

#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#else // #if DBG

//
// Empty macros for free builds.
//

#define DBG_MODULE(Prefix) 0
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags)
#define DBG_DECLARE_HEADER(Prefix)
#define DBG_DECLARE_FILE()

#define DBG_DECLARE_DPF(Prefix, Args)
#define DBG_DECLARE_DPFM(Prefix, Args)
#define DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)
#define DBG_DECLARE_PROMPT(Prefix, Args)
#define DBG_DECLARE_GETFLAGS(Prefix, Idx) 0
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value)

//
// Macros which evaluate to code on free builds.
//

#define DBG_DECLARE_VERIFY(Prefix, Exp) (Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args) (Exp)

#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    (hr = (Exp))
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) DoFail; else hr
#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_HEADER(G);

#define GDPF(Args)              DBG_DECLARE_DPF(G, Args)
#define GDPFM(Args)             DBG_DECLARE_DPFM(G, Args)
#define GASSERT(Exp)            DBG_DECLARE_ASSERT(G, Exp)
#define GASSERTMSG(Exp, Args)   DBG_DECLARE_ASSERTMSG(G, Exp, Args)
#define GVERIFY(Exp)            DBG_DECLARE_VERIFY(G, Exp)
#define GVERIFYMSG(Exp)         DBG_DECLARE_VERIFYMSG(G, Exp, Args)
#define GPROMPT(Args)           DBG_DECLARE_PROMPT(G, Args)
#define GGETFLAGS(Idx)          DBG_DECLARE_GETFLAGS(G, Idx)
#define GSETFLAGS(Idx, Value)   DBG_DECLARE_SETFLAGS(G, Idx, Value)
#define GHRCHK(Exp)             DBG_DECLARE_HRCHK(G, Exp)
#define GHRGO(Exp, Label)       DBG_DECLARE_HRGO(G, Exp, Label)
#define GHRERR(Exp)             DBG_DECLARE_HRERR(G, Exp)
#define GHRRET(Exp)             DBG_DECLARE_HRRET(G, Exp)

#endif // #ifndef _CPPDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#include <d3dflt.h>

#ifdef __cplusplus
extern "C" {
#endif

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//
// D3DVECTOR operations.
//

#define pVecLenSq(pVec)                                                       \
    pVecDot(pVec, pVec)
#define pVecLen(pVec)                                                         \
    SQRTF(pVecLenSq(pVec))

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes);

#define pVecNormalize(pVec)             pVecNormalize2(pVec, pVec)
#define VecNormalize(Vec)               pVecNormalize(&(Vec))
#define VecNormalize2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))

#define pVecDot(pVec1, pVec2)                                                 \
    ((pVec1)->x * (pVec2)->x + (pVec1)->y * (pVec2)->y +                      \
     (pVec1)->z * (pVec2)->z)

#define pVecAdd(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x + (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y + (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z + (pVec2)->z)

#define pVecSub(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x - (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y - (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z - (pVec2)->z)

#define pVecScale(pVec, fScale, pRes)                                         \
    ((pRes)->x = (pVec)->x * (fScale),                                        \
     (pRes)->y = (pVec)->y * (fScale),                                        \
     (pRes)->z = (pVec)->z * (fScale))

#define pVecNeg(pVec, pRes)                                                   \
    ((pRes)->x = NEGF((pVec)->x),                                             \
     (pRes)->y = NEGF((pVec)->y),                                             \
     (pRes)->z = NEGF((pVec)->z))

#define pVecSet(pVec, fX, fY, fZ)                                             \
    ((pVec)->x = (fX), (pVec)->y = (fY), (pVec)->z = (fZ))

#define VecLenSq(Vec)                   pVecLenSq(&(Vec))
#define VecLen(Vec)                     pVecLen(&(Vec))

#ifdef _X86_

// Vector normalize through a table
void  FASTCALL TableVecNormalize(float *result, float *normal);
// Vector normalize using Jim Blinn's floating point trick
void  FASTCALL JBVecNormalize(float *result, float *normal);

#define VecNormalizeFast(Vec)          TableVecNormalize((float*)&(Vec), (float*)&(Vec))
#define VecNormalizeFast2(Vec, Res)    TableVecNormalize((float*)&(Res), (float*)&(Vec))
#define pVecNormalizeFast(Vec)         TableVecNormalize((float*)pVec, (float*)pVec)
#define pVecNormalizeFast2(pVec, pRes) TableVecNormalize((float*)pRes, (float*)pVec)

#else

#define VecNormalizeFast(Vec)               pVecNormalize(&(Vec))
#define VecNormalizeFast2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))
#define pVecNormalizeFast(pVec)             pVecNormalize(pVec)
#define pVecNormalizeFast2(pVec, pRes)      pVecNormalize2(pVec, pRes)

#endif // _X86_

#define VecDot(Vec1, Vec2)              pVecDot(&(Vec1), &(Vec2))
#define VecAdd(Vec1, Vec2, Res)         pVecAdd(&(Vec1), &(Vec2), &(Res))
#define VecSub(Vec1, Vec2, Res)         pVecSub(&(Vec1), &(Vec2), &(Res))
#define VecScale(Vec1, fScale, Res)     pVecScale(&(Vec1), fScale, &(Res))
#define VecNeg(Vec, Res)                pVecNeg(&(Vec), &(Res))
#define VecSet(Vec, fX, fY, fZ)         pVecSet(&(Vec), fX, fY, fZ)

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = (D3DVALUE) 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3,
                     D3DVECTORH *plane);
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\hrstr.cpp ===
//----------------------------------------------------------------------------
//
// hrstr.cpp
//
// HRESULT-to-string mapper.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

struct HrStringDef
{
    HRESULT hr;
    char *pString;
};

#define HRDEF(Name) \
    Name, #Name

static HrStringDef g_HrStringDefs[] =
{
    // Put specific codes before generic codes so that specific codes
    // are returned in the cases where the HRESULT is the same.
    HRDEF(D3DERR_BADMAJORVERSION),
    HRDEF(D3DERR_BADMINORVERSION),
    HRDEF(D3DERR_EXECUTE_LOCKED),
    HRDEF(D3DERR_EXECUTE_NOT_LOCKED),
    HRDEF(D3DERR_EXECUTE_CREATE_FAILED),
    HRDEF(D3DERR_EXECUTE_DESTROY_FAILED),
    HRDEF(D3DERR_EXECUTE_LOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_UNLOCK_FAILED),
    HRDEF(D3DERR_EXECUTE_FAILED),
    HRDEF(D3DERR_EXECUTE_CLIPPED_FAILED),
    HRDEF(D3DERR_TEXTURE_NO_SUPPORT),
    HRDEF(D3DERR_TEXTURE_NOT_LOCKED),
    HRDEF(D3DERR_TEXTURE_LOCKED),
    HRDEF(D3DERR_TEXTURE_CREATE_FAILED),
    HRDEF(D3DERR_TEXTURE_DESTROY_FAILED),
    HRDEF(D3DERR_TEXTURE_LOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_UNLOCK_FAILED),
    HRDEF(D3DERR_TEXTURE_LOAD_FAILED),
    HRDEF(D3DERR_MATRIX_CREATE_FAILED),
    HRDEF(D3DERR_MATRIX_DESTROY_FAILED),
    HRDEF(D3DERR_MATRIX_SETDATA_FAILED),
    HRDEF(D3DERR_SETVIEWPORTDATA_FAILED),
    HRDEF(D3DERR_MATERIAL_CREATE_FAILED),
    HRDEF(D3DERR_MATERIAL_DESTROY_FAILED),
    HRDEF(D3DERR_MATERIAL_SETDATA_FAILED),
    HRDEF(D3DERR_LIGHT_SET_FAILED),
    HRDEF(DDERR_ALREADYINITIALIZED),
    HRDEF(DDERR_BLTFASTCANTCLIP),
    HRDEF(DDERR_CANNOTATTACHSURFACE),
    HRDEF(DDERR_CANNOTDETACHSURFACE),
    HRDEF(DDERR_CANTCREATEDC),
    HRDEF(DDERR_CANTDUPLICATE),
    HRDEF(DDERR_CLIPPERISUSINGHWND),
    HRDEF(DDERR_COLORKEYNOTSET),
    HRDEF(DDERR_CURRENTLYNOTAVAIL),
    HRDEF(DDERR_DIRECTDRAWALREADYCREATED),
    HRDEF(DDERR_EXCEPTION),
    HRDEF(DDERR_EXCLUSIVEMODEALREADYSET),
    HRDEF(DDERR_GENERIC),
    HRDEF(DDERR_HEIGHTALIGN),
    HRDEF(DDERR_HWNDALREADYSET),
    HRDEF(DDERR_HWNDSUBCLASSED),
    HRDEF(DDERR_IMPLICITLYCREATED),
    HRDEF(DDERR_INCOMPATIBLEPRIMARY),
    HRDEF(DDERR_INVALIDCAPS),
    HRDEF(DDERR_INVALIDCLIPLIST),
    HRDEF(DDERR_INVALIDDIRECTDRAWGUID),
    HRDEF(DDERR_INVALIDMODE),
    HRDEF(DDERR_INVALIDOBJECT),
    HRDEF(DDERR_INVALIDPARAMS),
    HRDEF(DDERR_INVALIDPIXELFORMAT),
    HRDEF(DDERR_INVALIDPOSITION),
    HRDEF(DDERR_INVALIDRECT),
    HRDEF(DDERR_LOCKEDSURFACES),
    HRDEF(DDERR_NO3D),
    HRDEF(DDERR_NOALPHAHW),
    HRDEF(DDERR_NOBLTHW),
    HRDEF(DDERR_NOCLIPLIST),
    HRDEF(DDERR_NOCLIPPERATTACHED),
    HRDEF(DDERR_NOCOLORCONVHW),
    HRDEF(DDERR_NOCOLORKEY),
    HRDEF(DDERR_NOCOLORKEYHW),
    HRDEF(DDERR_NOCOOPERATIVELEVELSET),
    HRDEF(DDERR_NODC),
    HRDEF(DDERR_NODDROPSHW),
    HRDEF(DDERR_NODIRECTDRAWHW),
    HRDEF(DDERR_NOEMULATION),
    HRDEF(DDERR_NOEXCLUSIVEMODE),
    HRDEF(DDERR_NOFLIPHW),
    HRDEF(DDERR_NOGDI),
    HRDEF(DDERR_NOHWND),
    HRDEF(DDERR_NOMIRRORHW),
    HRDEF(DDERR_NOOVERLAYDEST),
    HRDEF(DDERR_NOOVERLAYHW),
    HRDEF(DDERR_NOPALETTEATTACHED),
    HRDEF(DDERR_NOPALETTEHW),
    HRDEF(DDERR_NORASTEROPHW),
    HRDEF(DDERR_NOROTATIONHW),
    HRDEF(DDERR_NOSTRETCHHW),
    HRDEF(DDERR_NOT4BITCOLOR),
    HRDEF(DDERR_NOT4BITCOLORINDEX),
    HRDEF(DDERR_NOT8BITCOLOR),
    HRDEF(DDERR_NOTAOVERLAYSURFACE),
    HRDEF(DDERR_NOTEXTUREHW),
    HRDEF(DDERR_NOTFLIPPABLE),
    HRDEF(DDERR_NOTFOUND),
    HRDEF(DDERR_NOTLOCKED),
    HRDEF(DDERR_NOTPALETTIZED),
    HRDEF(DDERR_NOVSYNCHW),
    HRDEF(DDERR_NOZBUFFERHW),
    HRDEF(DDERR_NOZOVERLAYHW),
    HRDEF(DDERR_OUTOFCAPS),
    HRDEF(DDERR_OUTOFMEMORY),
    HRDEF(DDERR_OUTOFVIDEOMEMORY),
    HRDEF(DDERR_OVERLAYCANTCLIP),
    HRDEF(DDERR_OVERLAYCOLORKEYONLYONEACTIVE),
    HRDEF(DDERR_OVERLAYNOTVISIBLE),
    HRDEF(DDERR_PALETTEBUSY),
    HRDEF(DDERR_PRIMARYSURFACEALREADYEXISTS),
    HRDEF(DDERR_REGIONTOOSMALL),
    HRDEF(DDERR_SURFACEALREADYATTACHED),
    HRDEF(DDERR_SURFACEALREADYDEPENDENT),
    HRDEF(DDERR_SURFACEBUSY),
    HRDEF(DDERR_SURFACEISOBSCURED),
    HRDEF(DDERR_SURFACELOST),
    HRDEF(DDERR_SURFACENOTATTACHED),
    HRDEF(DDERR_TOOBIGHEIGHT),
    HRDEF(DDERR_TOOBIGSIZE),
    HRDEF(DDERR_TOOBIGWIDTH),
    HRDEF(DDERR_UNSUPPORTED),
    HRDEF(DDERR_UNSUPPORTEDFORMAT),
    HRDEF(DDERR_UNSUPPORTEDMASK),
    HRDEF(DDERR_VERTICALBLANKINPROGRESS),
    HRDEF(DDERR_WASSTILLDRAWING),
    HRDEF(DDERR_WRONGMODE),
    HRDEF(DDERR_XALIGN),
    HRDEF(E_OUTOFMEMORY),
    HRDEF(E_INVALIDARG),
    HRDEF(E_FAIL),
    HRDEF(S_FALSE),
    HRDEF(S_OK),
    0, NULL,
};

//----------------------------------------------------------------------------
//
// DebugModule::HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *DebugModule::HrString(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern DOUBLE g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//   
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef WINNT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <ddrawp.h>

#include <d3dp.h>
#include <d3dhal.h>

#include <d3di.hpp>
#include <cppdbg.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\_memalloc.c ===
#include "stdlib.h"
#define __DXGUSEALLOC 1
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\_dpf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define PROF_SECT "Direct3D"
#define START_STR "Direct3D: "
#include "..\..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\sources.inc ===
TARGETNAME = d3dutil
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = $(INCLUDES);$(D3DROOT)\pipeln\inc
        
SOURCES = \
        ..\cppdbg.cpp\
        ..\d3dflt.cpp\
        ..\d3dutil.cpp\
        ..\_dpf.cpp\
        ..\hrstr.cpp\
        ..\_memalloc.c

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .list

; float __fastcall TableInvSqrt(float value);
;
; void  __fastcall TableVecNormalize(float *resultNormal, floar *normal);
;
;           resultNormal and normal could have the same address
;

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

a1  dd 0.47
a2  dd 1.47

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


__FLOAT_ONE equ 03F800000h

;----------------------------------------------------------------------
;
; float __fastcall JBInvSqrt(float x);
;
; Input:
;   esp + 4 = x
; Output:
;   result is on the floating point stack
; Algorithm:
;   The floating point trick, described in IEEE Computer Graphics and 
;   Applications v.17 number 4 in Jim Blinn's article, is used.
;
;   ONE_AS_INTEGER = 0x3F800000;
;   int   tmp = (ONE_AS_INTEGER << 1 + ONE_AS_INTEGER - *(long*)&x) >> 1;   
;   float y = *(float*)&tmp;                                             
;   result = y*(1.47f - 0.47f*x*y*y);
;
@JBInvSqrt@4 PROC NEAR
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    sub     eax, [esp+4]
    sub     esp, 4                      ; place for temporary variable "y"
    sar     eax, 1
    mov     [esp], eax                  ; y
    fld     a1
    fmul    DWORD PTR [esp+8]           ; x*0.47
    fld     DWORD PTR [esp]
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y 1.47-x*0.47*y*y
    fmulp   st(1), st(0)                ; result
    add     esp, 4
    ret     4
@JBInvSqrt@4 endp
;----------------------------------------------------------------------
; void __fastcall JBInvSqrt(float *result, float *nomal);
;
; Input:
;   ecx = address of the result
;   edx = address of the normal
;
;
@JBVecNormalize@8 PROC NEAR
    fld     DWORD PTR [edx]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 4]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 8]
    fmul    st(0), st(0)                ; z y x
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len
    sub     esp, 4                      ; Place for temporary variable "y"
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     DWORD PTR [esp]             ; Vector length
    sub     eax, [esp]
    sar     eax, 1
    mov     [esp], eax                  ; y
    fmul    a1                          ; x*0.47
    fld     DWORD PTR [esp]             ; y x*0.47
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y aaa       
    fmulp   st(1), st(0)                ; 1/sqrt(len)
    fld     DWORD PTR [edx]             ; Start normalizing the normal
    fmul    st, st(1)
    fld     DWORD PTR [edx + 4]
    fmul    st, st(2)
    fld     DWORD PTR [edx + 8]
    fmulp   st(3), st(0)                ; y x z
    fxch    st(1)
    add     esp, 4
    fstp    DWORD PTR [ecx]
    fstp    DWORD PTR [ecx + 4]
    fstp    DWORD PTR [ecx + 8]
	ret	
@JBVecNormalize@8 endp
;----------------------------------------------------------------------
; Input:
;     [esp+4] = x
;
;
x 	    equ DWORD PTR [esp + 12]
num 	equ DWORD PTR [esp]

@TableInvSqrt@4 PROC NEAR
    mov     eax, [esp + 4]          ; x
    push    ecx
    mov     ecx, eax
	sub	    esp, 4                  ; Place for num
    shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
    and     eax, CLAMP_MASK		    ;; clamp number to [0.5, 2.0]
    and     ecx, TABLE_MASK		    ;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+ecx]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, x                  ;; divide exponent by 2
    fadd    [invSqrtTab+ecx+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent
    add     esp, 4
    pop     ecx
	ret     4
@TableInvSqrt@4 endp
;----------------------------------------------------------------------
;
len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@TableVecNormalize@8 PROC NEAR
	push	ebp
	mov	    ebp, esp
	sub	    esp, 8
	fld	    DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	    DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	    DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
    mov     edi, eax
    shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
    and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
    and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+edi]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, len                ;; divide exponent by 2
    fadd    [invSqrtTab+edi+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent

	fld	    DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	    DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	    DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@TableVecNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\d3dvec.inl ===
/****************************************************************** 
 *                                                                *
 *   D3DVec.inl                                                   *
 *                                                                *
 *   Float-valued 3D vector class for Direct3D.                   *
 *                                                                *
 *   Copyright (c) 1996-1998 Microsoft Corp. All rights reserved. *
 *                                                                *
 ******************************************************************/

#include <math.h>

// =====================================
// Constructors
// =====================================

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE f)
{
    x = y = z = f;
}

inline
_D3DVECTOR::_D3DVECTOR(D3DVALUE _x, D3DVALUE _y, D3DVALUE _z)
{
    x = _x; y = _y; z = _z;
}

inline
_D3DVECTOR::_D3DVECTOR(const D3DVALUE f[3])
{
    x = f[0]; y = f[1]; z = f[2];
}

// =====================================
// Access grants
// =====================================

inline const D3DVALUE&
_D3DVECTOR::operator[](int i) const
{
    return (&x)[i];
}

inline D3DVALUE&
_D3DVECTOR::operator[](int i)
{
    return (&x)[i];
}


// =====================================
// Assignment operators
// =====================================

inline _D3DVECTOR&
_D3DVECTOR::operator += (const _D3DVECTOR& v)
{
   x += v.x;   y += v.y;   z += v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator -= (const _D3DVECTOR& v)
{
   x -= v.x;   y -= v.y;   z -= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (const _D3DVECTOR& v)
{
   x *= v.x;   y *= v.y;   z *= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (const _D3DVECTOR& v)
{
   x /= v.x;   y /= v.y;   z /= v.z;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator *= (D3DVALUE s)
{
   x *= s;   y *= s;   z *= s;
   return *this;
}

inline _D3DVECTOR&
_D3DVECTOR::operator /= (D3DVALUE s)
{
   x /= s;   y /= s;   z /= s;
   return *this;
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v)
{
   return v;
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v)
{
   return _D3DVECTOR(-v.x, -v.y, -v.z);
}

inline _D3DVECTOR
operator + (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
}

inline _D3DVECTOR
operator - (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR(v1.x/v2.x, v1.y/v2.y, v1.z/v2.z);
}

inline int
operator < (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] < v2[0] && v1[1] < v2[1] && v1[2] < v2[2];
}

inline int
operator <= (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1[0] <= v2[0] && v1[1] <= v2[1] && v1[2] <= v2[2];
}

inline _D3DVECTOR
operator * (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator * (D3DVALUE s, const _D3DVECTOR& v)
{
   return _D3DVECTOR(s*v.x, s*v.y, s*v.z);
}

inline _D3DVECTOR
operator / (const _D3DVECTOR& v, D3DVALUE s)
{
   return _D3DVECTOR(v.x/s, v.y/s, v.z/s);
}

inline int
operator == (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x==v2.x && v1.y==v2.y && v1.z == v2.z;
}

inline D3DVALUE
Magnitude (const _D3DVECTOR& v)
{
   return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline D3DVALUE
SquareMagnitude (const _D3DVECTOR& v)
{
   return v.x*v.x + v.y*v.y + v.z*v.z;
}

inline _D3DVECTOR
Normalize (const _D3DVECTOR& v)
{
   return v / Magnitude(v);
}

inline D3DVALUE
Min (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (v.y < ret) ret = v.y;
   if (v.z < ret) ret = v.z;
   return ret;
}

inline D3DVALUE
Max (const _D3DVECTOR& v)
{
   D3DVALUE ret = v.x;
   if (ret < v.y) ret = v.y;
   if (ret < v.z) ret = v.z;
   return ret;
}

inline _D3DVECTOR
Minimize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] < v2[0] ? v1[0] : v2[0],
                   v1[1] < v2[1] ? v1[1] : v2[1],
                   v1[2] < v2[2] ? v1[2] : v2[2]);
}

inline _D3DVECTOR
Maximize (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return _D3DVECTOR( v1[0] > v2[0] ? v1[0] : v2[0],
                   v1[1] > v2[1] ? v1[1] : v2[1],
                   v1[2] > v2[2] ? v1[2] : v2[2]);
}

inline D3DVALUE
DotProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
   return v1.x*v2.x + v1.y * v2.y + v1.z*v2.z;
}

inline _D3DVECTOR
CrossProduct (const _D3DVECTOR& v1, const _D3DVECTOR& v2)
{
	_D3DVECTOR result;

	result[0] = v1[1] * v2[2] - v1[2] * v2[1];
	result[1] = v1[2] * v2[0] - v1[0] * v2[2];
	result[2] = v1[0] * v2[1] - v1[1] * v2[0];

	return result;
}

inline _D3DMATRIX
operator* (const _D3DMATRIX& a, const _D3DMATRIX& b)
{
    _D3DMATRIX ret;
    for (int i=0; i<4; i++) {
        for (int j=0; j<4; j++) {
            ret(i, j) = 0.0f;
            for (int k=0; k<4; k++) {
                ret(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\commdrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       commdrv.h
 *  Content:    Common driver structures
 *
 ***************************************************************************/

#ifndef _COMMDRV_H_
#define _COMMDRV_H_

#include "haldrv.hpp"

extern int      GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI );
extern LPD3DTLVERTEX    GenGetExtraVerticesPointer( LPDIRECT3DDEVICEI lpDevI );
extern HRESULT DrawPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrim(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimLegacy(LPDIRECT3DDEVICEI);
extern HRESULT DrawPrimCB(LPDIRECT3DDEVICEI);
extern HRESULT DrawIndexPrimCB(LPDIRECT3DDEVICEI);
//---------------------------------------------------------------------
// This class builds a DDRAWSURFACE around memory bits
//
class CDDSurfaceFromMem
{
public:
    CDDSurfaceFromMem(LPVOID lpvMemory)
        {
            gblTL.fpVidMem = (ULONG_PTR)lpvMemory;
            lclTL.lpGbl = &gblTL;
            exeTL.lpLcl = &lclTL;
        }
    ~CDDSurfaceFromMem() {};
    LPDIRECTDRAWSURFACE GetSurface() {return (LPDIRECTDRAWSURFACE) &exeTL;}
    void SetBits(LPVOID lpvMemory)   {gblTL.fpVidMem = (ULONG_PTR)lpvMemory;}
protected:
    DDRAWI_DDRAWSURFACE_INT exeTL;
    DDRAWI_DDRAWSURFACE_LCL lclTL;
    DDRAWI_DDRAWSURFACE_GBL gblTL;
};
#endif /* _COMMDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\d3dutil\texdiff.h ===
//----------------------------------------------------------------------------
//
// texdiff.h
//
// TextureDiff base code for inclusion as an inline function or
// regular function from common code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------

{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\d3dfe.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfe.hpp
 *  Content:    Direct3D internal include file
 *              for geometry pipeline implementations
 *
 ***************************************************************************/
#ifndef _D3DFE_H

// this is not available for alpha or IA64
#ifndef LONG_MAX
#define LONG_MAX      2147483647L   /* maximum (signed) long value */
#endif

//--------------------------------------------------------------------
// Base definitions
//

// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD __DEFAULT_DIFFUSE = 0xFFFFFFFF;
const DWORD __DEFAULT_SPECULAR = 0;


typedef WORD D3DFE_CLIPCODE;

//---------------------------------------------------------------------
typedef struct _RECTV
{
    union
    {
        D3DVALUE x1;
        D3DVALUE dvX1;
    };
    union
    {
        D3DVALUE y1;
        D3DVALUE dvY1;
    };
    union
    {
        D3DVALUE x2;
        D3DVALUE dvX2;
    };
    union
    {
        D3DVALUE y2;
        D3DVALUE dvY2;
    };
} D3DRECTV, *LPD3DRECTV;
//---------------------------------------------------------------------
/*
 * Transform defines
 */
/*
 * Internal version of D3DTRANSFORMDATA
 * The difference is that drExtent is D3DRECTV instead of D3DRECT
 */
typedef struct _D3DTRANSFORMDATAI
{
    DWORD        dwSize;
    LPVOID       lpIn;           /* Input vertices */
    DWORD        dwInSize;       /* Stride of input vertices */
    LPVOID       lpOut;          /* Output vertices */
    DWORD        dwOutSize;      /* Stride of output vertices */
    LPD3DHVERTEX lpHOut;         /* Output homogeneous vertices */
    DWORD        dwClip;         /* Clipping hint */
    DWORD        dwClipIntersection;
    DWORD        dwClipUnion;    /* Union of all clip flags */
    D3DRECTV     drExtent;       /* Extent of transformed vertices */
} D3DTRANSFORMDATAI, *LPD3DTRANSFORMDATAI;
//---------------------------------------------------------------------
typedef enum _D3MATRIXTYPEI
{
    D3DIMatrixIdentity,
    D3DIMatrixTranslate,
    D3DIMatrixRotateTranslate,
    D3DIMatrixAffine,
    D3DIMatrixGeneral
} D3DMATRIXTYPEI;
//---------------------------------------------------------------------
// "link" member should be the last, because we copy the structure using
// offsetof(D3DMATRIXI, link)
//
typedef struct _D3DMATRIXI
{
    D3DVALUE            _11, _12, _13, _14;
    D3DVALUE            _21, _22, _23, _24;
    D3DVALUE            _31, _32, _33, _34;
    D3DVALUE            _41, _42, _43, _44;
    D3DMATRIXTYPEI      type;
    LIST_MEMBER(_D3DMATRIXI) link;
} D3DMATRIXI, *LPD3DMATRIXI;
//---------------------------------------------------------------------
struct _D3DFE_LIGHTING;
typedef struct _D3DFE_LIGHTING D3DFE_LIGHTING;

struct _D3DI_LIGHT;
typedef struct _D3DI_LIGHT D3DI_LIGHT;

class D3DFE_PROCESSVERTICES;
typedef class D3DFE_PROCESSVERTICES* LPD3DFE_PROCESSVERTICES;

extern "C"
{
typedef void (*LIGHT_VERTEX_FUNC)(LPD3DFE_PROCESSVERTICES pv,
                                  D3DI_LIGHT *light,
                                  D3DLIGHTINGELEMENT *in);
}
//---------------------------------------------------------------------
/*
 * Lighting defines
 */
typedef struct _SpecularTable
{
    LIST_MEMBER(_SpecularTable) list;
    float   power;          /* shininess power */
    float   table[260];     /* space for overflows */
} SpecularTable;

typedef struct {D3DVALUE r,g,b;} D3DFE_COLOR;
//---------------------------------------------------------------------
// Internal version of lightdata and constants for flags
//
#define D3DLIGHTI_ATT0_IS_NONZERO   (0x00010000)
#define D3DLIGHTI_ATT1_IS_NONZERO   (0x00020000)
#define D3DLIGHTI_ATT2_IS_NONZERO   (0x00040000)
#define D3DLIGHTI_LINEAR_FALLOFF    (0x00080000)
#define D3DLIGHTI_UNIT_SCALE        (0x00100000)
#define D3DLIGHTI_LIGHT_AT_EYE      (0x00200000)
#define D3DLIGHTI_COMPUTE_SPECULAR  (0x00400000)
//--------------------------------------------------------------------
// Members of this structure should be aligned as stated
typedef struct _D3DI_LIGHT
{
    // Should be QWORD aligned
    D3DVECTOR       model_position;
    D3DLIGHTTYPE    type;
    // Should be QWORD aligned
    D3DVECTOR       model_direction;
    DWORD           version;        // matches number on D3DLIGHT struct
    // Should be QWORD aligned
    D3DVECTOR       model_eye;      // direction from eye in model space
    DWORD           flags;
    // Should be QWORD aligned
    D3DVECTOR       model_scale;    // model scale for proper range computations
    D3DVALUE        falloff;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DVALUE        local_diffR;    // Material diffuse times light color
    D3DVALUE        local_diffG;
    D3DVALUE        local_diffB;
    BOOL            valid;
    // Should be QWORD aligned. R,G,B should be adjacent
    D3DVALUE        local_specR;    // Material specular times light color
    D3DVALUE        local_specG;
    D3DVALUE        local_specB;
    D3DVALUE        inv_theta_minus_phi;
    // Should be QWORD aligned
    D3DVECTOR       halfway;
    struct _D3DI_LIGHT *next;           // Next in the active light list
    // Should be QWORD aligned
    D3DVALUE        red, green, blue, shade;

    LIGHT_VERTEX_FUNC lightVertexFunc;  // Function to light a D3DVERTEX

    D3DVALUE        range_squared;
    D3DVALUE        attenuation0;
    D3DVALUE        attenuation1;
    D3DVALUE        attenuation2;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVECTOR       position;
    D3DVECTOR       direction;
    D3DVALUE        range;
} D3DI_LIGHT, *LPD3DI_LIGHT;
//---------------------------------------------------------------------
// Members of this structure should be aligned as stated
//
typedef struct _D3DFE_LIGHTING
{
// Temporary data used when computing lighting
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse;
    int               alpha;          // Alpha to use for output vertex color
                                      // (could be overriden by vertex difuse
                                      // color) (0-255) shifted left by 24 bits
    // Should be QWORD aligned
    D3DFE_COLOR       diffuse0;       // Ca*Cma + Cme
    float            *currentSpecTable;
    // Should be QWORD aligned
    D3DFE_COLOR       specular;
    DWORD             outDiffuse;     // Result of lighting
    // Should be QWORD aligned
    D3DFE_COLOR       vertexDiffuse;  // Provided with a vertex
    DWORD             outSpecular;    // Result of lighting
    // Should be QWORD aligned
    D3DFE_COLOR       vertexSpecular; // Provided with a vertex
    BOOL              specularComputed;
// End of temporary data
    D3DI_LIGHT       *activeLights;
    D3DMATERIAL       material;
    D3DMATERIALHANDLE hMat;
    D3DVALUE          ambient_red;    // Scaled to 0 - 255
    D3DVALUE          ambient_green;  // Scaled to 0 - 255
    D3DVALUE          ambient_blue;   // Scaled to 0 - 255
    int               fog_mode;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)
    D3DVALUE          fog_factor_ramp;// 1 / (fog_end - fog_start)
    D3DVALUE          specThreshold;  // If a dot product less than this value,
                                      // specular factor is zero
    D3DCOLORMODEL     color_model;
    DWORD             ambient_save;   // Original unscaled color
    int               materialAlpha;  // Current material alpha (0-255) shifted
                                      // left by 24 bits
} D3DFE_LIGHTING;
//---------------------------------------------------------------------
// Some data precomputed for a current viewport
// ATTENTION: If you want to add or re-arrange data, contact IOURIT or ANUJG
//
typedef struct _D3DFE_VIEWPORTCACHE
{
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleX;            // dvWidth/2
    D3DVALUE scaleY;            // dvHeight/2
    D3DVALUE offsetX;           // dvX + scaleX
    D3DVALUE offsetY;           // dvY + scaleY
// Min and max window values with gaurd band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;
// Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY
// Coefficients to transform a vertex to perform the guard band clipping
// x*gb11 + w*gb41
// y*gb22 + w*gb42
//
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;
// Coefficients to apply clipping rules for the guard band clipping
// They are used by clipping routins
// w*Kgbx1 < x < w*Kgbx2
// w*Kgby1 < y < w*Kgby2
//
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight
// Coefficients to compute screen coordinates from normalized window
// coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
// Min and max values for viewport window in pixels (integer version)
    int      minXi;             // offsetX - scaleX
    int      minYi;             // offsetY - scaleY
    int      maxXi;             // offsetX + scaleX
    int      maxYi;             // offsetY + scaleY
// Mclip matrix. mclip44=1. Other Mclip(i,j)=0
    D3DVALUE mclip11;           // 2/dvClipWidth
    D3DVALUE mclip41;           // -(1+2*dvClipX/dvClipWidth)
    D3DVALUE mclip22;           // 2/dvClipHeight
    D3DVALUE mclip42;           // (1-2*dvClipY/dvClipHeight)
    D3DVALUE mclip33;           // 1/(dvMaxZ-dvMinZ)
    D3DVALUE mclip43;           // -dvMinZ*mclip33
// Inverse Mclip matrix. We need this matrix to transform vertices from clip
// space to homogineous space (after Mproj). We need this when user calls
// Transform Vertices. This matrix is computed only when it is needed.
    D3DVALUE imclip11;
    D3DVALUE imclip41;
    D3DVALUE imclip22;
    D3DVALUE imclip42;
    D3DVALUE imclip33;
    D3DVALUE imclip43;
} D3DFE_VIEWPORTCACHE;
//---------------------------------------------------------------------
// Process vertices interface
//
// Bits for process vertices flags
// 8 bits are reserved for Draw Primitive flags
//
// D3DPV_STRIDE D3DPV_SOA
//      0         1       position.dwStride = number of vertices in SOA
//      0         0       position.dwStride = contiguous vertex size
//      1         0       vertex is not contiguous, all dwStride fields are used
//      1         1       reserved
//      1         1       reserved
//
const DWORD D3DPV_FOG            = 1 << 8;  // Need to apply fog
const DWORD D3DPV_AFFINEMATRIX   = 1 << 9;  // Last matrix column is (0,0,1,x)
const DWORD D3DPV_LIGHTING       = 1 << 10; // Need to apply lighting
const DWORD D3DPV_SOA            = 1 << 12; // SOA structure is used
const DWORD D3DPV_STRIDE         = 1 << 13; // Strides are used
const DWORD D3DPV_COLORVERTEX    = 1 << 14; // Diffuse color vertex
const DWORD D3DPV_COLORVERTEXS   = 1 << 15; // Specular color vertex
// These two flags should NOT be used. Use D3DDEV_.. instead
const DWORD D3DPV_TRANSFORMDIRTY = 1 << 16; // Transform matrix has been changed
const DWORD D3DPV_LIGHTSDIRTY    = 1 << 17; // Lights have been changed

const DWORD D3DPV_COMPUTESPECULAR= 1 << 18; // Specular highlights are enabled
const DWORD D3DPV_RANGEBASEDFOG  = 1 << 19; // Do range based fog
const DWORD D3DPV_GOODPROJMATRIX = 1 << 20; // "Good" projection matrix (All
                                            // members except M11 M22 M33 M43
                                            // M34 are zero)
const DWORD D3DPV_CLIPPERPRIM    = 1 << 21; // This indicates that the primitive
                                            // was generated by clipping. This allows
                                            // DP2HAL to inline the primitive. Can
                                            // only by tri fan or line list.
const DWORD D3DPV_RESERVED1      = 1 << 22;
const DWORD D3DPV_RESERVED2      = 1 << 23;
const DWORD D3DPV_RESERVED3      = 1 << 24;
// This indicates that the primitive is non clipped, but we pretend that it is
// clipped to generate DP2HAL inline primitive. Can only be set by tri fan.
const DWORD D3DPV_NONCLIPPED     = 1 << 25;
// Propagated from dwFEFlags
const DWORD D3DPV_FRUSTUMPLANES_DIRTY = 1 << 26;
// Set if the geometry loop is called from VertexBuffer::ProcessVertices.
// Processing is different because the output buffer FVF format is defined by
// user, not by ComputeOutputFVF function.
const DWORD D3DPV_VBCALL         = 1 << 27;
const DWORD D3DPV_RAMPSPECULAR   = 1 << 28; // whether ramp map was made with specular
const DWORD D3DPV_TLVCLIP        = 1 << 29; // To mark whether we are doing TLVERTEX clipping or not
// Bits for dwDeviceFlags
//
const DWORD D3DDEV_GUARDBAND     = 1 << 1;  // Use guard band clipping
const DWORD D3DDEV_PREDX5DEVICE  = 1 << 2;  // Device version is older than DX5
const DWORD D3DDEV_RAMP          = 1 << 3;  // Ramp mode is used
const DWORD D3DDEV_FVF           = 1 << 4;  // FVF supported
const DWORD D3DDEV_PREDX6DEVICE  = 1 << 5;  // Device version is older than DX6
const DWORD D3DDEV_DONOTSTRIPELEMENTS = 1 << 6; // Copy of D3DFVFCAPS_DONOTSTRIPELEMENTS

// These are bits in dwDeviceFlags that could be changed, but not
// necessary per every primitive.

// If D3DRENDERSTATE_TEXTUREHANDLE was set by API to not NULL
const DWORD D3DDEV_LEGACYTEXTURE  = 1 << 16;
// These flags should be used instead of D3DPV_...
const DWORD D3DDEV_TRANSFORMDIRTY = 1 << 17; // Transform matrix has been changed
const DWORD D3DDEV_LIGHTSDIRTY    = 1 << 18; // Lights have been changed
//--------------------------------------------------------------------
// Clipper defines
//

// Six standard clipping planes plus six user defined clipping planes.
// See rl\d3d\d3d\d3dtypes.h.
//

#define MAX_CLIPPING_PLANES 12

// Space for vertices generated/copied while clipping one triangle

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

const DWORD MAX_FVF_TEXCOORD = 8;

typedef struct _CLIP_TEXTURE
{
    D3DVALUE u, v;
} CLIP_TEXTURE;

typedef struct _ClipVertex
{
    D3DCOLOR     color;
    D3DCOLOR     specular;
    D3DVALUE     sx;
    D3DVALUE     sy;
    D3DVALUE     sz;
    D3DVALUE     hx;
    D3DVALUE     hy;
    D3DVALUE     hz;
    D3DVALUE     hw;
    CLIP_TEXTURE tex[MAX_FVF_TEXCOORD];
    int     clip;
} ClipVertex;

typedef struct _ClipTriangle
{
    ClipVertex  *v[3];
    unsigned short flags;
} ClipTriangle;

typedef struct _D3DI_CLIPSTATE
{
    ClipVertex  *clip_vbuf1[MAX_CLIP_VERTICES];
    ClipVertex  *clip_vbuf2[MAX_CLIP_VERTICES];
    ClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    ClipVertex  clip_vertices[MAX_CLIP_VERTICES];
    CBufferDDS   clipBuf;      // Used for TL vertices, generated by the clipper
    CBufferDDS   clipBufPrim;  // Used for primitives, generated by the clipper
                              // for execute buffers
    int         clip_vertices_used;
    DWORD       clip_color;
    DWORD       clip_specular;
    LPDIRECTDRAWSURFACE lpDDExeBuf; // Current user execute buffer
    LPVOID      lpvExeBufMem;       // Current memory for user execute buffer
} D3DI_CLIPSTATE, *LPD3DI_CLIPSTATE;
//---------------------------------------------------------------------
// Visible states, input and output data
//
class D3DFE_PROCESSVERTICES
{
public:
// State
    DWORD    dwRampBase;            // Parameters to compute ramp color. They are
    D3DVALUE dvRampScale;           // constant for a material.
    LPVOID   lpvRampTexture;
    // Should be 32 bytes aligned
    D3DMATRIXI mCTM;                // Current Transformation Matrix
    DWORD dwMaxTextureIndices;      // Max number of texture coord sets
                                    // supported by driver
    // Should be QWORD aligned
    D3DFE_LIGHTING lighting;        // Lighting state
    D3DVALUE dvExtentsAdjust;       // Replicated here from device caps
    // Should be QWORD aligned
    D3DFE_VIEWPORTCACHE vcache;     // Data, computed fromto viewport settings
    DWORD   dwClipUnion;            // OR of all vertex clip flags
    DWORD   dwClipIntersection;     // AND of all vertex clip flags
    union
    {
    DWORD   dwTextureIndexToCopy;   // Used for not FVF devices. Used by PSGP
    DWORD   dwMaxUsedTextureIndex;  // Used for FVF devices. PSGP do not use it.
    };

    // Current texture stage vector
    LPVOID   *pD3DMappedTexI;
    D3DI_CLIPSTATE  ClipperState;   // State for triangle/line clipper
    union {
        D3DDP_PTRSTRIDE normal;
        DWORD dwSOAStartVertex;
    };
    D3DDP_PTRSTRIDE diffuse;
    D3DDP_PTRSTRIDE specular;
// Cache line starts here
    // Location of the first vertex in the vertex buffer (DP2 DDI)
    // ATTENTION May be we can get rid of it?
    DWORD dwVertexBase;

// Input
    DWORD   dwDeviceFlags;          // Flags that are constant per device
                                    // D3DPV_.. and primitive flags are combined
    LPVOID  lpvOut;                 // Output pointer (output always packed)
    D3DFE_CLIPCODE* lpClipFlags;          // Clip flags to output
    DWORD   dwNumIndices;           // 0 for non-indexed primitive
    LPWORD  lpwIndices;
    union {
        D3DDP_PTRSTRIDE position;   // dwStride should always be set !!!
        D3DDP_PTRSTRIDE SOA;
    };
// Cache line starts here
    DWORD   dwFlags;                // Flags word describing what to do
    DWORD   dwNumVertices;          // Number of vertices to process
    DWORD   dwNumPrimitives;
    D3DPRIMITIVETYPE primType;
    DWORD   dwVIDIn;                // Vertex ID of input vertices
    DWORD   dwVIDOut;               // Vertex ID of output vertices
    DWORD   dwOutputSize;           // Size of output vertices
    DWORD   nTexCoord;              // Number of the texture coordinate sets
// Cache line starts here
    D3DDP_PTRSTRIDE textures[D3DDP_MAXTEXCOORD];
// Cache line starts here
// Output
    LPDWORD  lpdwRStates;           // Current render state vector
    D3DRECTV rExtents;              // Extents rectangle to update, if required
    D3DMATRIXI mWV;                 // Transforms to camera space (Mworld*Mview)
    virtual HRESULT DrawPrim()=0;             // Use to pass non-indexed primitives to the driver
    virtual HRESULT DrawIndexPrim()=0;      // Use to pass indexed primitives to driver
};
// Prototype for the function to be written for a given processor implementation
//
// Returns clip intersection.
//

class ID3DFE_PVFUNCS
{
public:
    virtual ~ID3DFE_PVFUNCS() { };
    virtual DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES)=0;
    virtual HRESULT OptimizeVertexBuffer
        (DWORD  dwFVFID,            // Vertex type. XYZ position is allowed
         DWORD  dwNumVertices,      // Number of vertices
         DWORD  dwVertexSize,       // Vertex size in bytes
         LPVOID lpSrcBuffer,        // Source buffer.
         LPVOID lpDstBuffer,        // Output buffer.
         DWORD  dwFlags)            // Should be zero for now
        {return E_NOTIMPL;}
    // Returns number of bytes to allocate for an optimized vertex buffer
    // This function is called before OptimizeVertexBuffer
    virtual DWORD  ComputeOptimizedVertexBufferSize
        (DWORD dwFVF,               // Vertex type
         DWORD dwVertexSize,        // Vertex size in bytes
         DWORD dwNumVertices)       // Number of vertices
        {return 0;}
    // This function could be used if PSGP doesn't want to implement complete
    // clipping pipeline
    // Parameters:
    //      pv  - state data
    //      tri - triangle to clip
    //      interpolate - interpolation flags
    //      clipVertexPointer - pointer to an array of pointers to
    //                          generated vertices
    // Returns:
    //      Number of vertices in clipped triangle
    //      0, if the triangle is off screen
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer,
                                   int interpolate) = 0;
    virtual HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues) = 0;
    // Used to generate clip flags for transformed and lit vertices
    // Computes clip status and returns clip intersection code
    virtual DWORD GenClipFlags(D3DFE_PROCESSVERTICES *pv);
    // Used to implement viewport->TransformVertices
    // Returns clip intersection code
    virtual DWORD TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                    DWORD vertexCount, 
                                    D3DTRANSFORMDATAI* data);
};

typedef ID3DFE_PVFUNCS *LPD3DFE_PVFUNCS;

//---------------------------------------------------------------------
// Direct3D implementation of PVFUNCS
//
class D3DFE_PVFUNCS : public ID3DFE_PVFUNCS
{
public:
    DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES);
    virtual int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                   ClipTriangle *tri,
                                   ClipVertex ***clipVertexPointer,
                                   int interpolate);
    virtual HRESULT ComputeSphereVisibility( LPD3DFE_PROCESSVERTICES pPV,
                                             LPD3DVECTOR lpCenters,
                                             LPD3DVALUE lpRadii,
                                             DWORD dwNumSpheres,
                                             DWORD dwFlags,
                                             LPDWORD lpdwReturnValues);
    // Used to generate clip flags for transformed and lit vertices
    // Computes clip status and returns clip intersection code
    virtual DWORD GenClipFlags(D3DFE_PROCESSVERTICES *pv);
    // Used to implement viewport->TransformVertices
    virtual DWORD TransformVertices(D3DFE_PROCESSVERTICES *pv, 
                                    DWORD vertexCount, 
                                    D3DTRANSFORMDATAI* data);
};

// GeometrySetup function takes a DWORD describing the dirty bits and the new state vector
// and passes back the 3 new leaf routines to use.
typedef HRESULT (D3DAPI *LPD3DFE_CONTEXTCREATE)(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);

// Global pointer to Processor specific PV setup routine
// This is defined in dlld3d.cpp
extern LPD3DFE_CONTEXTCREATE pfnFEContextCreate;

#endif // _D3DFE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\d3ditype.h ===
//----------------------------------------------------------------------------
//
// d3ditype.h
//
// Standard types and supporting declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DITYPE_H_
#define _D3DITYPE_H_

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

// Sized types.
#ifndef _BASETSD_H_
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
#endif

// Basic float types.
typedef float                   FLOAT, *PFLOAT;
typedef double                  DOUBLE, *PDOUBLE;

typedef struct _D3DVECTORH
{
    D3DVALUE x;
    D3DVALUE y;
    D3DVALUE z;
    D3DVALUE w;
} D3DVECTORH, *LPD3DVECTORH;

#endif // #ifndef _D3DITYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\dditypes.hpp ===
/*
 * $Id: dditypes.h,v 1.28 1995/11/21 14:46:07 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __DDITYPES_H__
#define __DDITYPES_H__

#include "d3di.hpp"


#endif /* dditypes.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef __D3DFLOAT__
#define __D3DFLOAT__

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((int)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];

__inline int QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(int *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((float)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec) ((float) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec) ((float)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#if defined(i386)
#include <limits.h>
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX	   \
				 ? LONG_MAX				           \
				 : (f) < LONG_MIN			       \
				 ? LONG_MIN				           \
                                 : (int)(f))
#else
#define SAFE_FLOAT_TO_INT(f)    ((int)(f))
#endif

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3di.hpp
 *  Content:    Direct3D internal include file
 *
 *  $Id:
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *
 ***************************************************************************/

#ifndef _D3DI_HPP
#define _D3DI_HPP

#include "ddrawp.h"
#include "d3dp.h"
#include "d3dmem.h"

#if !defined(BUILD_DDDDK)
extern "C" {
#include "ddrawi.h"
};
#include "object.h"
#include "lists.hpp"

#include <d3ditype.h>
#include <d3dutil.h>

#include <d3dfe.hpp>

//--------------------------------------------------------------------
const DWORD __INIT_VERTEX_NUMBER = 1024;// Initial number of vertices in TL and
                                        // clip flag buffers
const DWORD __MAX_VERTEX_SIZE = 128;    // Max size of FVF vertex in bytes
//--------------------------------------------------------------------
/*
 * Registry defines
 */
#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

extern HINSTANCE hGeometryDLL;

/*
 * CPU family and features flags
 */
extern DWORD dwCPUFamily, dwCPUFeatures;
extern char szCPUString[];

// MMX available
#define D3DCPU_MMX          0x00000001L

// FCOMI and CMOV are both supported
#define D3DCPU_FCOMICMOV    0x00000002L

// Reads block until satisfied
#define D3DCPU_BLOCKINGREAD 0x00000004L

// Extended 3D support available
#define D3DCPU_X3D          0x00000008L

// Pentium II CPU
#define D3DCPU_PII          0x000000010L

// Katmai CPU
#define D3DCPU_KATMAI       0x000000020L


#define IS_OVERRIDE(type)   ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)  ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define MAX_STATE   D3DSTATE_OVERRIDE_BIAS

#define DEFAULT_GAMMA   DTOVAL(1.4)

/*
    INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
    to deterimine if the number of primitives being drawn is small
    relative to the number of vertices being passed.  If it is then
    the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE   2

#endif // BUILD_DDDDK

typedef ULONG_PTR D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

// AnanKan: This should ideally reside in d3dtypes.h, but since we are
// pulling out OptSurface support in DX6 I kept it here (to keep the code
// alive)
typedef HRESULT (WINAPI* LPD3DENUMOPTTEXTUREFORMATSCALLBACK)(LPDDSURFACEDESC2 lpDdsd2, LPDDOPTSURFACEDESC lpDdOsd, LPVOID lpContext);

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;     /* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;       /* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;


#if !defined(BUILD_DDDDK)

class DIRECT3DDEVICEI;
class DIRECT3DVIEWPORTI;

typedef class DIRECT3DI *LPDIRECT3DI;
typedef class DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef class DIRECT3DEXECUTEBUFFERI *LPDIRECT3DEXECUTEBUFFERI;
typedef class DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef class DIRECT3DMATERIALI *LPDIRECT3DMATERIALI;
typedef class DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef class DIRECT3DVIEWPORTI *LPDIRECT3DVIEWPORTI;
typedef class CDirect3DVertexBuffer *LPDIRECT3DVERTEXBUFFERI;

class CDirect3DUnk : public IUnknown
{
public:
    unsigned refCnt;    /* Reference count object */
public:
    LPDIRECT3DI pD3DI;
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
};

class CDirect3D : public IDirect3D
{
public:
    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID);
    virtual HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD)=0;
    HRESULT D3DAPI FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT);
    virtual HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD)=0;
};

class CDirect3D2 : public IDirect3D2
{
public:
    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID);
    virtual HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD)=0;
    HRESULT D3DAPI FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT);
    virtual HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD)=0;
};

class CDirect3D3 : public IDirect3D3
{
public:
    HRESULT D3DAPI EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID);
    virtual HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD)=0;
    HRESULT D3DAPI FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT);
    virtual HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD)=0;
};

class DIRECT3DI :  public CDirect3D,
                   public CDirect3D2,
                   public CDirect3D3,
                   public CD3DAlloc
{
public: //Private Data

    /*** Object Relations ***/

    /* Devices */
    int             numDevs;/* Number of devices */
    struct _devices { DIRECT3DDEVICEI* Root;} devices;
    /* Associated IDirect3DDevices */

    /* Viewports */
    int             numViewports; /* Number of viewports */
    LIST_ROOT(_viewports, DIRECT3DVIEWPORTI) viewports;
    /* Created IDirect3DViewports */

    /* Lights */
    int             numLights; /* Number of lights */
    LIST_ROOT(_lights, DIRECT3DLIGHTI) lights;
    /* Created IDirect3DLights */

    /* Materials */
    int             numMaterials; /* Number of materials */
    LIST_ROOT(_materials, DIRECT3DMATERIALI) materials;
    /* Created IDirect3DMaterials */

    /* Vertex Buffers */
    int             numVBufs; /* Number of vertex buffers */
    LIST_ROOT(_vbufs, CDirect3DVertexBuffer) vbufs;
    /* Created IDirect3DVertexBuffers */

    /*** Object Data ***/

    CDirect3DUnk mD3DUnk;

    unsigned long       v_next; /* id of next viewport to be created */

    //RLDDIRegistry*      lpReg;  /* Registry */
    struct _D3DBUCKET  *lpFreeList; /* Free linked list  */
    struct _D3DBUCKET  *lpBufferList;/* link list of headers of big chunks allocated*/
    class TextureCacheManager   *lpTextureManager;
    /*
     * DirectDraw Interface
     */
    LPDIRECTDRAW lpDD;
    LPDIRECTDRAW4 lpDD4;    /* needed for CreateSurface to get LPDIRECTDRAWSURFACE4 */

    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.   But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)
    // More disgusting still: These need to be large enough to hold ddrawex interface structs

    DDRAWI_DIRECTDRAW_INT DDInt_DD1;
    DDRAWI_DIRECTDRAW_INT DDInt_DD4;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */

public: //Private methods
    DIRECT3DI(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt); // Constructor called Direct3DCreate()
    ~DIRECT3DI(); // Destructor called by CDirect3DUnk::Release()
    HRESULT EnumDevices(LPD3DENUMDEVICESCALLBACK, LPVOID, DWORD, DWORD);
    HRESULT FindDevice(LPD3DFINDDEVICESEARCH, LPD3DFINDDEVICERESULT, DWORD);
    // Internal CreateVertexBuffer
    HRESULT CreateVertexBufferI(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER*, DWORD);
    // Device flushing
    HRESULT FlushDevicesExcept(LPDIRECT3DDEVICEI pDev);
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3D Methods
    HRESULT D3DAPI Initialize(REFCLSID);
    HRESULT D3DAPI CreateLight(LPDIRECT3DLIGHT*, IUnknown*);
    HRESULT D3DAPI CreateMaterial(LPDIRECT3DMATERIAL*, IUnknown*);
    HRESULT D3DAPI CreateViewport(LPDIRECT3DVIEWPORT*, IUnknown*);
    //IDirect3D2 Methods
    HRESULT D3DAPI CreateMaterial(LPDIRECT3DMATERIAL2*, IUnknown*);
    HRESULT D3DAPI CreateViewport(LPDIRECT3DVIEWPORT2*, IUnknown*);
    HRESULT D3DAPI CreateDevice(REFCLSID, LPDIRECTDRAWSURFACE, LPDIRECT3DDEVICE2*);
    //IDirect3D3 Methods
    HRESULT D3DAPI CreateMaterial(LPDIRECT3DMATERIAL3*, LPUNKNOWN);
    HRESULT D3DAPI CreateViewport(LPDIRECT3DVIEWPORT3*, LPUNKNOWN);
    HRESULT D3DAPI CreateDevice(REFCLSID, LPDIRECTDRAWSURFACE4, LPDIRECT3DDEVICE3*, LPUNKNOWN);
    HRESULT D3DAPI CreateVertexBuffer(LPD3DVERTEXBUFFERDESC, LPDIRECT3DVERTEXBUFFER*, DWORD, LPUNKNOWN);
    HRESULT D3DAPI EnumZBufferFormats(REFCLSID, LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI EnumOptTextureFormats(REFCLSID, LPD3DENUMOPTTEXTUREFORMATSCALLBACK, LPVOID);  // not exposed by API (yet)
    HRESULT D3DAPI EvictManagedTextures();
};

typedef DIRECT3DI* LPDIRECT3DI;

#include "d3dhal.h"
#include "halprov.h"

//---------------------------------------------------------------------
typedef HRESULT (*PFNDRVSETRENDERTARGET)(LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4,
                                         LPDIRECTDRAWPALETTE, LPDIRECT3DDEVICEI);
typedef HRESULT (*PFNDOFLUSHBEGINEND)(LPDIRECT3DDEVICEI);
typedef HRESULT (*PFNDRAWPRIM)(LPDIRECT3DDEVICEI);

typedef struct _D3DBUCKET
{
    struct _D3DBUCKET *next;
    union
    {
    LPVOID  lpD3DDevI;
    LPDDRAWI_DDRAWSURFACE_LCL lpLcl;
    LPVOID  lpBuffer;
    LPDIRECT3DTEXTUREI lpD3DTexI;
    };
    unsigned int ticks;
    LPDIRECTDRAWSURFACE *lplpDDSZBuffer;    //if not NULL, points to lpDDSZBuffer in Direct3DDeviceI
} D3DBUCKET,*LPD3DBUCKET;

typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) list;
    /* Next block in IDirect3DTexture */
    LIST_MEMBER(_D3DI_TEXTUREBLOCK) devList;
    /* Next block in IDirect3DDevice */

    LPDIRECT3DDEVICEI           lpDevI;

    /*  this texture block refers to either an
     * IDirect3DTexture/IDirect3DTexture2, so one of these pointers will
     * always be NULL
     */
    LPDIRECT3DTEXTUREI          lpD3DTextureI;
    /* pointer to internal struct for IDirect3DTexture/IDirect3DTexture2 */

    D3DTEXTUREHANDLE            hTex;
    /* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

typedef struct _D3DI_MATERIALBLOCK
{
    LIST_MEMBER(_D3DI_MATERIALBLOCK)    list;
    /* Next block in IDirect3DMaterial */
    LIST_MEMBER(_D3DI_MATERIALBLOCK)    devList;
    /* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI   lpDevI;
    LPDIRECT3DMATERIALI lpD3DMaterialI;
    D3DMATERIALHANDLE   hMat;
    /* material handle */
    DWORD               hMatDDI;
    /* driver handle (for hardware transform & light) */
} D3DI_MATERIALBLOCK;
typedef struct _D3DI_MATERIALBLOCK *LPD3DI_MATERIALBLOCK;

typedef struct _D3DFE_MATERIAL
{
    LIST_MEMBER(_D3DFE_MATERIAL) link;
    D3DMATERIAL         mat;
    // RampRast material if necessary
    LPVOID              pRmMat;
} D3DFE_MATERIAL, *LPD3DFE_MATERIAL;

// Function to compute lighting
//
typedef struct _LIGHT_VERTEX_FUNC_TABLE
{
    LIGHT_VERTEX_FUNC   directional1;
    LIGHT_VERTEX_FUNC   directional2;
    LIGHT_VERTEX_FUNC   spot1;
    LIGHT_VERTEX_FUNC   spot2;
    LIGHT_VERTEX_FUNC   point1;
    LIGHT_VERTEX_FUNC   point2;
} LIGHT_VERTEX_FUNC_TABLE;
//---------------------------------------------------------------------
//
// Bits for D3DFRONTEND flags (dwFEFlags in DIRECT3DDEVICEI)
//
const DWORD D3DFE_VALID                 = 1 << 1;
const DWORD D3DFE_TLVERTEX              = 1 << 2;
const DWORD D3DFE_REALHAL               = 1 << 3;
const DWORD D3DFE_VIEWPORT_DIRTY        = 1 << 4;
const DWORD D3DFE_PROJMATRIX_DIRTY      = 1 << 5;
const DWORD D3DFE_VIEWMATRIX_DIRTY      = 1 << 6;
const DWORD D3DFE_WORLDMATRIX_DIRTY     = 1 << 7;
const DWORD D3DFE_INVERSEMCLIP_DIRTY    = 1 << 8;
const DWORD D3DFE_MCLIP_IDENTITY        = 1 << 9;
const DWORD D3DFE_PROJ_PERSPECTIVE      = 1 << 10;
const DWORD D3DFE_AFFINE_WORLD          = 1 << 11;
const DWORD D3DFE_AFFINE_VIEW           = 1 << 12;
const DWORD D3DFE_AFFINE_WORLD_VIEW     = 1 << 13;
const DWORD D3DFE_NEED_TRANSFORM_LIGHTS = 1 << 14;
const DWORD D3DFE_MATERIAL_DIRTY        = 1 << 15;
const DWORD D3DFE_NEED_TRANSFORM_EYE    = 1 << 16;
const DWORD D3DFE_FOG_DIRTY             = 1 << 17;
const DWORD D3DFE_LIGHTS_DIRTY          = 1 << 18;
// Set if D3DLIGHTSTATE_COLORVERTEX is TRUE
const DWORD D3DFE_COLORVERTEX           = 1 << 19;
// Set if the Current Transformation Matrix has been changed
// Reset when frustum planes in the model space have been computed
const DWORD D3DFE_FRUSTUMPLANES_DIRTY   = 1 << 20;
const DWORD D3DFE_WORLDVIEWMATRIX_DIRTY = 1 << 21;
// This bit is set if fog mode is not FOG_NONE and fog is enabled
const DWORD D3DFE_FOGENABLED            = 1 << 22;
// This bit set if UpdateManagedTextures() needs to be called
const DWORD D3DFE_NEED_TEXTURE_UPDATE   = 1 << 23;
// This bit set if mapping DX6 texture blend modes to renderstates is desired
const DWORD D3DFE_MAP_TSS_TO_RS         = 1 << 24;
// This bit set if we have to compute specular highlights
const DWORD D3DFE_COMPUTESPECULAR       = 1 << 26;
const DWORD D3DFE_LOSTSURFACES          = 1 << 27;
// This bit set if texturing is disabled
const DWORD D3DFE_DISABLE_TEXTURES      = 1 << 28;
// This bit set when D3DTSS_TEXCOORDINDEX is changed
const DWORD D3DFE_TSSINDEX_DIRTY        = 1 << 29;

const DWORD D3DFE_TRANSFORM_DIRTY = D3DFE_VIEWPORT_DIRTY |
                                    D3DFE_PROJMATRIX_DIRTY |
                                    D3DFE_VIEWMATRIX_DIRTY |
                                    D3DFE_WORLDMATRIX_DIRTY;
//---------------------------------------------------------------------
//
// Bits for dwDebugFlags
//
// Set if DisableFVF key is not 0 in registry and driver supports FVF
const DWORD D3DDEBUG_DISABLEFVF = 1 << 0;
// Disable Draw Primitive DDI
const DWORD D3DDEBUG_DISABLEDP  = 1 << 1;
// Disable Draw Primitive 2 DDI
const DWORD D3DDEBUG_DISABLEDP2 = 1 << 2;

#ifdef  WIN95
#define _D3D_FORCEDOUBLE    1
#else   //WIN95
#define _D3D_FORCEDOUBLE    0
#endif  //WIN95
#if _D3D_FORCEDOUBLE
// Set if ForceDouble key is not 0 in the registry and driver is pre-DX6 REALHAL
const DWORD D3DDEBUG_FORCEDOUBLE= 1 << 2;
#endif  //_D3D_FORCEDOUBLE

//---------------------------------------------------------------------
// Bits for transform.dwFlags
//

// Frastum plane equations are valid
const DWORD D3DTRANS_VALIDFRUSTUM   = 1 << 2;
//---------------------------------------------------------------------
typedef struct _D3DFE_TRANSFORM
{
    LIST_ROOT(matlist, _D3DMATRIXI) matrices;
    D3DMATRIXI      proj;
    D3DMATRIXI      view;
    D3DMATRIXI      world;
    D3DMATRIXI      mPC;        // Mproj * Mclip
    D3DMATRIXI      mVPC;       // Mview * PC
    D3DMATRIXHANDLE hProj;
    D3DMATRIXHANDLE hView;
    D3DMATRIXHANDLE hWorld;
    D3DMATRIXI      mCTMI;      // Inverse current transformation matrix
    D3DVECTORH      frustum[6]; // Normalized plane equations for viewing frustum
                                // in the model space
    DWORD           dwFlags;
} D3DFE_TRANSFORM;

typedef void (*D3DFEDestroyProc)(LPDIRECT3DDEVICEI lpD3DDevI);

#define D3D_RSTATEBUF_SIZE 128

#define D3D_MAX_MMX_VERTICES 1024

extern DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
extern DWORD dwHWBufferSize, dwHWMaxTris;
extern DWORD dwHWFewVertices;

typedef struct _D3DHAL_DRAWPRIMCOUNTS *LPD3DHAL_DRAWPRIMCOUNTS;

// Legacy HAL batching is done with these structs.
typedef struct _D3DI_HWCOUNTS {
    WORD wNumStateChanges;      // Number of state changes batched
    WORD wNumVertices;          // Number of vertices in tri list
    WORD wNumTriangles;         // Number of triangles in tri list
} D3DI_HWCOUNTS, *LPD3DI_HWCOUNTS;

typedef struct _D3DHAL_EXDATA
{
    LIST_MEMBER(_D3DHAL_EXDATA) link;
    D3DEXECUTEBUFFERDESC        debDesc;
    LPDIRECTDRAWSURFACE         lpDDS;
} D3DHAL_EXDATA;
typedef D3DHAL_EXDATA *LPD3DHAL_EXDATA;

/*
 * Picking stuff.
 */
typedef struct _D3DI_PICKDATA
{
    D3DI_EXECUTEDATA*   exe;
    D3DPICKRECORD*  records;
    int         pick_count;
    D3DRECT     pick;
} D3DI_PICKDATA, *LPD3DI_PICKDATA;

#define DWORD_BITS      32
#define DWORD_SHIFT     5

typedef struct _D3DFE_STATESET
{
    DWORD    bits[MAX_STATE >> DWORD_SHIFT];
} D3DFE_STATESET;

#define STATESET_MASK(set, state)       \
    (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
    STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
    STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
    STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

class CDirect3DDeviceUnk : public IUnknown
{
public:
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
public:
    /* Reference count object */
    unsigned refCnt;
    /* Our Device type */
    LPDIRECT3DDEVICEI pDevI;
};

class CDirect3DDevice : public IDirect3DDevice
{
public:
    HRESULT D3DAPI GetCaps(LPD3DDEVICEDESC, LPD3DDEVICEDESC);
    virtual HRESULT GetCapsI(LPD3DDEVICEDESC, LPD3DDEVICEDESC)=0;
public:
    DWORD   dwVersion;   // represents the version the device was created as  (3==IDirect3DDevice3, etc)
};

typedef enum {
    D3DDEVTYPE_OLDHAL,
    D3DDEVTYPE_DPHAL,
    D3DDEVTYPE_DP2HAL,
    D3DDEVTYPE_DX7HAL
} D3DDEVICETYPE;
//---------------------------------------------------------------------
typedef HRESULT (DIRECT3DDEVICEI::*PFN_DRAWPRIM)();

//---------------------------------------------------------------------
// This type is used to define operation for ProcessPrimitive
//
typedef enum
{
    __PROCPRIMOP_INDEXEDPRIM,       // Process indexed primitive
    __PROCPRIMOP_NONINDEXEDPRIM,    // Process non-indexed primitive
    __PROCPRIMOP_PROCVERONLY,       // Process vertices only
} __PROCPRIMOP;
//---------------------------------------------------------------------
#ifdef _IA64_   // Removes IA64 compiler alignment warnings
  #pragma pack(16)
#endif

#ifdef _AXP64_   // Removes AXP64 compiler alignment warnings
  #pragma pack(16)
#endif

class DIRECT3DDEVICEI : public CDirect3DDevice,
                        public IDirect3DDevice2,
                        public IDirect3DDevice3,
                        public CD3DAlloc,
                        public D3DFE_PROCESSVERTICES
{
public: // Private Data

    HRESULT (*pfnFlushStates)(LPDIRECT3DDEVICEI);

#define D3DDEVBOOL_HINTFLAGS_INSCENE             (0x00000001L)  // Are we between Begin/End?
#define D3DDEVBOOL_HINTFLAGS_INBEGIN             (0x00000002L)  // Are we in a scene?
#define D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH (0x00000004L)  // Set when first flush occurs
// Set when indexed begin/end primitive is flushed several times
#define D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM    (0x00000020L)
#define D3DDEVBOOL_HINTFLAGS_INBEGIN_ALL         (D3DDEVBOOL_HINTFLAGS_INBEGIN | \
                                                  D3DDEVBOOL_HINTFLAGS_INBEGIN_FIRST_FLUSH | \
                                                  D3DDEVBOOL_HINTFLAGS_INBEGIN_BIG_PRIM)
#define D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END  (0x00000008L)  // Is this an internal (tex fill)
                                                                // begin/end
#define D3DDEVBOOL_HINTFLAGS_MULTITHREADED       (0x00000010L)  // multithreaded device
/* Should be cache line aligned. Now it is not !!! 0f04*/
    DWORD             dwHintFlags;
    // Cache last input->output FVF mapping
    DWORD               dwFVFLastIn;
    DWORD               dwFVFLastOut;
    DWORD               dwFVFLastTexCoord;
    DWORD               dwFVFLastOutputSize;
    DWORD               dwFVFLastInSize;
    DWORD               dwFEFlags;
/*Should be cache line aligned. Now it is not*/
    // Pointer to the PV funcs that we need to call
    LPD3DFE_PVFUNCS pGeometryFuncs;
    // buffers for TL and H vertices
    CAlignedBuffer32  HVbuf;        // Used for clip flags
    CBufferVB         TLVbuf;

/*Should be cache line aligned. Now it is not*/
    PFN_DRAWPRIM            pfnDrawPrim;        // Used by clipper to call HAL
    PFN_DRAWPRIM            pfnDrawIndexedPrim; // Used by clipper to call HAL
    /* Viewports */
    unsigned long       v_id;   /* ID of last viewport rendered */
    /* Associated IDirect3DViewports */
    LPDIRECT3DVIEWPORTI lpCurrentViewport;
    /* Device Type */
    D3DDEVICETYPE deviceType;

    D3DSTATS            D3DStats;

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* parent */
    LIST_MEMBER(DIRECT3DDEVICEI)list;   /* Next device IDirect3D */

    /* Textures */
    LIST_ROOT(_dmtextures, _D3DI_TEXTUREBLOCK) texBlocks;
    /* Ref to created IDirect3DTextures */

    /* Execute buffers */
    LIST_ROOT(_buffers, DIRECT3DEXECUTEBUFFERI) buffers;
    /* Created IDirect3DExecuteBuffers */

    /* Viewports */
    int             numViewports;
    CIRCLE_QUEUE_ROOT(_dviewports, DIRECT3DVIEWPORTI) viewports;

    /* Materials */
    LIST_ROOT(_dmmaterials, _D3DI_MATERIALBLOCK) matBlocks;
    /* Ref to associated IDirect3DMaterials */

    /*** Object Data ***/
    CDirect3DDeviceUnk mDevUnk;

    // for DX3-style devices aggregated onto ddraw, guid should be IID_IDirect3DRGBDevice,
    // IID_IDirect3DHALDevice, etc.  for DX5 and beyond, guid is IID_IDirect3DDevice,
    // IID_IDirect3DDevice2, etc
    GUID        guid;

    LPD3DHAL_CALLBACKS      lpD3DHALCallbacks; /* HW specific */
    LPD3DHAL_GLOBALDRIVERDATA   lpD3DHALGlobalDriverData; /* HW specific */
    LPD3DHAL_CALLBACKS2         lpD3DHALCallbacks2;    /* HW specific */
    LPD3DHAL_CALLBACKS3         lpD3DHALCallbacks3; /* DX6 DDI */

    /* DirectDraw objects that we are holding references to */

    LPDIRECTDRAW lpDD;    // DirectDraw object
    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    //
    LPDIRECTDRAWSURFACE lpDDSTarget;    // Render target
    LPDIRECTDRAWSURFACE lpDDSZBuffer;   // Z buffer
    LPDIRECTDRAWPALETTE lpDDPalTarget;  // Palette for render target (if any)

    // these are saved for use by new GetRenderTarget and anything else that requires DDS4 functionality
    LPDIRECTDRAWSURFACE4 lpDDSTarget_DDS4;
    LPDIRECTDRAWSURFACE4 lpDDSZBuffer_DDS4;

    DWORD               dwWidth, dwHeight;  // dimensions of render target

    // Front end data
    D3DFE_TRANSFORM         transform;

    ULONG_PTR               dwhContext;
    LIST_ROOT(eblist, _D3DHAL_EXDATA) bufferHandles;

// RenderTarget/ZBuf bit depth info used by Clear to Blt
     DWORD                 red_mask;
     DWORD                 red_scale;
     DWORD                 red_shift;
     DWORD                 green_mask;
     DWORD                 green_scale;
     DWORD                 green_shift;
     DWORD                 blue_mask;
     DWORD                 blue_scale;
     DWORD                 blue_shift;
     DWORD                 zmask_shift,stencilmask_shift;
     BOOL                  bDDSTargetIsPalettized;  // true if 4 or 8 bit rendertarget

// Picking info.
    D3DI_PICKDATA       pick_data;
    LPBYTE              lpbClipIns_base;
    DWORD               dwClipIns_offset;

// Pipeline state info
    D3DFE_STATESET      renderstate_overrides;
    D3DFE_STATESET      transformstate_overrides;
    D3DFE_STATESET      lightstate_overrides;
    int                 iClipStatus;

    DWORD               dwDebugFlags;       // See debug bits above

#ifndef WIN95
    ULONG_PTR           hSurfaceTarget;
#else
    DWORD               hSurfaceTarget;
#endif

#ifdef TRACK_HAL_CALLS
    DWORD hal_calls;
#endif


    //--------------- Lights start -----------------------
    int             numLights;  // This indicates the maximum number of lights
                                // that have been set in the device.
    LIST_ROOT(name10,_SpecularTable) specular_tables;
    SpecularTable*    specular_table;
    LIST_ROOT(mtllist, _D3DFE_MATERIAL) materials;
    LIGHT_VERTEX_FUNC_TABLE *lightVertexFuncTable;
    //--------------- Lights end -----------------------

    /* Provider backing this driver */
    IHalProvider*       pHalProv;
    HINSTANCE           hDllProv;

    /*
     * Pointers to functions used by DrawPrim&Begin/End
     */

    PFNDOFLUSHBEGINEND pfnDoFlushBeginEnd;

    /* Device description */
    D3DDEVICEDESC   d3dHWDevDesc;
    D3DDEVICEDESC   d3dHELDevDesc;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */

    /*
     *  Pointer to texture objects for currently installed textures.  NULL indicates
     *  that the texture is either not set (rstate NULL) or that the handle to tex3 pointer
     *  mapping is not done.  This mapping is expensive, so it is deferred until needed.
     *
     *  This is needed for finding the WRAPU,V mode for texture index clipping (since
     *  the WRAPU,V state is part of the device).
     */
    LPDIRECT3DTEXTUREI          lpD3DMappedTexI[D3DHAL_TSS_MAXSTAGES];
    LPD3DI_TEXTUREBLOCK         lpD3DMappedBlock[D3DHAL_TSS_MAXSTAGES];
    LPDIRECTDRAWCLIPPER         lpClipper;

     //---------- Begin-End data start --------------
    char             *lpcCurrentPtr;        // Current ptr to place next vertex
    CRITICAL_SECTION  BeginEndCSect;

    // max number of vertices
#define BEGIN_DATA_BLOCK_SIZE   256
    // size of internal vertex memory pool
#define BEGIN_DATA_BLOCK_MEM_SIZE  BEGIN_DATA_BLOCK_SIZE*__MAX_VERTEX_SIZE

    LPVOID  lpvVertexBatch;
    WORD    *lpIndexBatch;
    LPVOID  lpvVertexData;      // if lpvVertexData is non-NULL if we are
                                // insize Begin-End and indexed.
    DWORD   dwBENumVertices;
    DWORD   dwMaxVertexCount;   // current number of vertices there is space for
    WORD    *lpVertexIndices;
    DWORD   dwBENumIndices;
    DWORD   dwMaxIndexCount;    // current number of indices there is space for
    WORD    wFlushed;
     //---------- Begin-End data end --------------

    /*
     * DrawPrimitives batching
     */


    // Buffer to put DrawPrimitives stuff into
    // Used for both legacy and DrawPrimitive HALs
    struct _D3DBUCKET   *lpTextureBatched;
    WORD *lpwDPBuffer;
    WORD *lpwDPBufferAlloced;
#ifndef WIN95
    DWORD dwDPBufferSize;
#endif
    DWORD dwCurrentBatchVID;        // Current FVF type in the batch buffer


    /* Legacy HALs */
    // pointer to current prim counts struct
    LPD3DHAL_DRAWPRIMCOUNTS lpDPPrimCounts;

    // Buffer of counts structures that keep track of the
    // number of render states and vertices buffered
    LPD3DI_HWCOUNTS lpHWCounts;

    // Buffer of triangle structures.
    LPD3DTRIANGLE lpHWTris;

    // Buffer of interleaved render states and primitives.
    LPD3DTLVERTEX lpHWVertices;

    // Byte offset into lpHWVertices. This gets incremented
    // by 8 when a render state is batched and by 32*dwNumVertices
    // when a primitive is batched.
    DWORD dwHWOffset;

    // Max value of dwHWOffset. Used to decide whether to flush.
    DWORD dwHWMaxOffset;

    // Index into lpHWTris.
    DWORD dwHWTriIndex;

    // Number of counts structures used so far. This actually
    // gives the number of primitives batched and the index of
    // the counts structure to batch render states into.
    DWORD dwHWNumCounts;

    /* DrawPrimitive-aware HALs */

    // Byte offset into buffer (we are currently
    // using the device's wTriIndex)
    DWORD dwDPOffset;

    // Maximum offset. If dwDPOffset exceeds this, it is
    // time to flush.
    DWORD dwDPMaxOffset;

    WORD *wTriIndex;

    LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps;  /* HW specific */
    LPDWORD rstates;

    // Runtime copy of texture stage states
    DWORD tsstates[D3DHAL_TSS_MAXSTAGES][D3DHAL_TSS_STATESPERSTAGE];

    DWORD dwMaxTextureBlendStages; // Max number of blend stages supported by a driver

    // This is a function provided by ramp rasterizer. It is called to inform
    // ramp about any material changes. The function pointer and service types
    // are defined in halprov.h
    // It should be NULL except for ramp rasterizer.
    PFN_RASTRAMPSERVICE pfnRampService;

    // This is a function provided by sw rasterizers.
    // Currently, its only function is to provide an RGB8 clear color.
    // It should be non-NULL for anything that supports an 8 bit RGB output
    // type.
    PFN_RASTSERVICE pfnRastService;

    //
    // Begin DP2 HAL section
    //


    //
    // End DP2 HAL section
    //

public: // methods
    virtual ~DIRECT3DDEVICEI() { }; // Dummy virtual destructor to ensure the real one gets called
    HRESULT GetCapsI(LPD3DDEVICEDESC, LPD3DDEVICEDESC);
    HRESULT stateInitialize(BOOL bZEnable);
    HRESULT checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid);
    HRESULT hookDeviceToD3D(LPDIRECT3DI lpD3DI);
    HRESULT unhookDeviceFromD3D();
    void DIRECT3DDEVICEI::DestroyDevice();
    virtual HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion);
    HRESULT hookViewportToDevice(LPDIRECT3DVIEWPORTI lpD3DView);
    virtual HRESULT DrawPrim()=0;       // Use to pass non-indexed primitives to the driver
    virtual HRESULT DrawIndexPrim()=0;  // Use to pass indexed primitives to driver
    virtual HRESULT FlushStates()=0;    // Use to flush current batch to the driver
    virtual HRESULT ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD flags)=0;
    virtual HRESULT DrawExeBuf() { return D3D_OK; };
    virtual HRESULT ProcessPrimitive(__PROCPRIMOP op = __PROCPRIMOP_NONINDEXEDPRIM);
    virtual HRESULT CheckSurfaces();    // Check if the surfaces necessary for rendering are lost
    HRESULT PickExeBuf();       // Called by the clipper for execute buffer API
    HRESULT UpdateTextures();

    // Function to download viewport info to the driver
    virtual HRESULT UpdateDrvViewInfo(LPD3DVIEWPORT2 lpVwpData) { return D3D_OK; };
    virtual HRESULT UpdateDrvWInfo() { return D3D_OK; };

#if DBG
#define PROF_EXECUTE                        0x0000
#define PROF_BEGIN                          0x0001
#define PROF_BEGININDEXED                   0x0002
#define PROF_DRAWPRIMITIVEDEVICE2           0x0003
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE2    0x0004
#define PROF_DRAWPRIMITIVESTRIDED           0x0005
#define PROF_DRAWINDEXEDPRIMITIVESTRIDED    0x0006
#define PROF_DRAWPRIMITIVEDEVICE3           0x0007
#define PROF_DRAWINDEXEDPRIMITIVEDEVICE3    0x0008
#define PROF_DRAWPRIMITIVEVB                0x0009
#define PROF_DRAWINDEXEDPRIMITIVEVB         0x000a
    DWORD   dwCaller;
    DWORD   dwPrimitiveType[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType1[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    DWORD   dwVertexType2[PROF_DRAWINDEXEDPRIMITIVEVB+1];
    void    Profile(DWORD, D3DPRIMITIVETYPE, DWORD);
#else
    #define Profile(a,b,c)
#endif
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DDevice Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D, LPGUID, LPD3DDEVICEDESC);
    HRESULT D3DAPI GetCaps(LPD3DDEVICEDESC, LPD3DDEVICEDESC);
    HRESULT D3DAPI SwapTextureHandles(LPDIRECT3DTEXTURE, LPDIRECT3DTEXTURE);
    HRESULT D3DAPI CreateExecuteBuffer(LPD3DEXECUTEBUFFERDESC, LPDIRECT3DEXECUTEBUFFER*, IUnknown*);
    HRESULT D3DAPI GetStats(LPD3DSTATS);
    HRESULT D3DAPI Execute(LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD);
    HRESULT D3DAPI AddViewport(LPDIRECT3DVIEWPORT);
    HRESULT D3DAPI DeleteViewport(LPDIRECT3DVIEWPORT);
    HRESULT D3DAPI NextViewport(LPDIRECT3DVIEWPORT, LPDIRECT3DVIEWPORT*, DWORD);
    HRESULT D3DAPI Pick(LPDIRECT3DEXECUTEBUFFER, LPDIRECT3DVIEWPORT, DWORD, LPD3DRECT);
    HRESULT D3DAPI GetPickRecords(LPDWORD, LPD3DPICKRECORD);
    HRESULT D3DAPI EnumTextureFormats(LPD3DENUMTEXTUREFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI CreateMatrix(LPD3DMATRIXHANDLE);
    HRESULT D3DAPI SetMatrix(D3DMATRIXHANDLE, const LPD3DMATRIX);
    HRESULT D3DAPI GetMatrix(D3DMATRIXHANDLE, LPD3DMATRIX);
    HRESULT D3DAPI DeleteMatrix(D3DMATRIXHANDLE);
    HRESULT D3DAPI BeginScene();
    HRESULT D3DAPI EndScene();
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D*);

    // IDirect3DDevice2 Methods
    HRESULT D3DAPI SwapTextureHandles(LPDIRECT3DTEXTURE2, LPDIRECT3DTEXTURE2);
    HRESULT D3DAPI AddViewport(LPDIRECT3DVIEWPORT2);
    HRESULT D3DAPI DeleteViewport(LPDIRECT3DVIEWPORT2);
    HRESULT D3DAPI NextViewport(LPDIRECT3DVIEWPORT2, LPDIRECT3DVIEWPORT2*, DWORD);
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D2*);
    HRESULT D3DAPI SetCurrentViewport(LPDIRECT3DVIEWPORT2);
    HRESULT D3DAPI GetCurrentViewport(LPDIRECT3DVIEWPORT2 *);
    HRESULT D3DAPI SetRenderTarget(LPDIRECTDRAWSURFACE, DWORD);
    HRESULT D3DAPI GetRenderTarget(LPDIRECTDRAWSURFACE *);
    HRESULT D3DAPI Begin(D3DPRIMITIVETYPE, D3DVERTEXTYPE, DWORD);
    HRESULT D3DAPI BeginIndexed(D3DPRIMITIVETYPE, D3DVERTEXTYPE, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI Vertex(LPVOID);
    HRESULT D3DAPI Index(WORD);
    HRESULT D3DAPI End(DWORD);
    HRESULT D3DAPI GetRenderState(D3DRENDERSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetRenderState(D3DRENDERSTATETYPE, DWORD);
    virtual HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD) = 0;
    HRESULT D3DAPI GetLightState(D3DLIGHTSTATETYPE, LPDWORD);
    HRESULT D3DAPI SetLightState(D3DLIGHTSTATETYPE, DWORD);
    HRESULT D3DAPI SetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI GetTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI MultiplyTransform(D3DTRANSFORMSTATETYPE, LPD3DMATRIX);
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE, D3DVERTEXTYPE, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, D3DVERTEXTYPE, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI SetClipStatus(LPD3DCLIPSTATUS);
    HRESULT D3DAPI GetClipStatus(LPD3DCLIPSTATUS);

    // IDirect3DDevice3 Methods
    HRESULT D3DAPI AddViewport(LPDIRECT3DVIEWPORT3);
    HRESULT D3DAPI DeleteViewport(LPDIRECT3DVIEWPORT3);
    HRESULT D3DAPI NextViewport(LPDIRECT3DVIEWPORT3, LPDIRECT3DVIEWPORT3*, DWORD);
    HRESULT D3DAPI EnumTextureFormats(LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);
    HRESULT D3DAPI GetDirect3D(LPDIRECT3D3*);
    HRESULT D3DAPI SetCurrentViewport(LPDIRECT3DVIEWPORT3);
    HRESULT D3DAPI GetCurrentViewport(LPDIRECT3DVIEWPORT3 *);
    HRESULT D3DAPI SetRenderTarget(LPDIRECTDRAWSURFACE4, DWORD);
    HRESULT D3DAPI GetRenderTarget(LPDIRECTDRAWSURFACE4 *);
    HRESULT D3DAPI DrawPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveStrided(D3DPRIMITIVETYPE, DWORD, LPD3DDRAWPRIMITIVESTRIDEDDATA, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitive(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI Begin(D3DPRIMITIVETYPE, DWORD, DWORD);
    HRESULT D3DAPI BeginIndexed(D3DPRIMITIVETYPE, DWORD, LPVOID, DWORD, DWORD);
    HRESULT D3DAPI DrawPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER, DWORD, DWORD, DWORD);
    HRESULT D3DAPI DrawIndexedPrimitiveVB(D3DPRIMITIVETYPE, LPDIRECT3DVERTEXBUFFER, LPWORD, DWORD, DWORD);
    HRESULT D3DAPI ComputeSphereVisibility(LPD3DVECTOR, LPD3DVALUE, DWORD, DWORD, LPDWORD);
    HRESULT D3DAPI GetTexture(DWORD, LPDIRECT3DTEXTURE2 *);
    HRESULT D3DAPI SetTexture(DWORD, LPDIRECT3DTEXTURE2);
    HRESULT D3DAPI GetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        LPDWORD pdwValue);
    virtual HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                                D3DTEXTURESTAGESTATETYPE dwState,
                                                DWORD dwValue) = 0;
    virtual HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses) = 0;
};

class CDirect3DDeviceIHW : public DIRECT3DDEVICEI
{
private: // Data
    /* data members of DIRECT3DDEVICEI that are specific to DX3 Legacy HAL drivers
       should go here */
public:
    inline CDirect3DDeviceIHW() { deviceType = D3DDEVTYPE_OLDHAL; }
    inline ~CDirect3DDeviceIHW() { DestroyDevice(); }; // Called by CDirect3DDeviceUnk::Release()
    HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT FlushStates();
    HRESULT DrawExeBuf();       // Called by the clipper for execute buffer API
    HRESULT ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD flags);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT MapTSSToRS();
};

class CDirect3DDeviceIDP : public CDirect3DDeviceIHW
{
private: // Data
    /* data members of DIRECT3DDEVICEI that are specific to DX5 DrawPrimitive HAL drivers
       should go here */
public:
    CDirect3DDeviceIDP() { deviceType = D3DDEVTYPE_DPHAL; }
    HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT FlushStates();
};

// Flags passed by the runtime to the DDI batching code via PV structure
// to enable new DDI batching to be done efficiently. These flags are
// marked as reserved in d3dfe.hpp
const DWORD D3DPV_WITHINPRIMITIVE = D3DPV_RESERVED1; // This flags that the flush has occured
                                                     // within an primitive. This indicates
                                                     // that we should not flush the vertex buffer

// If execute buffer is currently processed
const DWORD D3DPV_INSIDEEXECUTE  = D3DPV_RESERVED2;
// If the vertices are in user memory
const DWORD D3DPV_USERMEMVERTICES = D3DPV_RESERVED3;
//---------------------------------------------------------------------
class CDirect3DDeviceIDP2 : public DIRECT3DDEVICEI
{
public: // data
    static const DWORD dwD3DDefaultVertexBatchSize;
    static const DWORD dwD3DDefaultCommandBatchSize;
    // The buffer we currently batch into
    LPDIRECTDRAWSURFACE4 lpDDSCB1;
    // Pointer to the actual data in CB1
    LPVOID lpvDP2Commands;
    //Pointer to the current position the CB1 buffer
    LPD3DHAL_DP2COMMAND lpDP2CurrCommand;
    D3DHAL_DRAWPRIMITIVES2DATA dp2data;
    DWORD dwDP2CommandLength;
    DWORD dwDP2CommandBufSize;
    BYTE bDP2CurrCmdOP;  // Mirror of Opcode of the current command
    WORD wDP2CurrCmdCnt; // Mirror of Count field if the current command

    // Flags specific to DP2 device
    DWORD dwDP2Flags;
private: // methods
    inline void CDirect3DDeviceIDP2::ClearBatch();
    HRESULT Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice, DWORD dwVersion);
    HRESULT GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize);
public:
    CDirect3DDeviceIDP2() { deviceType = D3DDEVTYPE_DP2HAL; }

    ~CDirect3DDeviceIDP2(); // Called by CDirect3DDeviceUnk::Release()
    HRESULT FlushStates();
    HRESULT FlushStates(DWORD dwReqSize);
    HRESULT D3DAPI SetRenderStateI(D3DRENDERSTATETYPE, DWORD);
    HRESULT DrawPrim();
    HRESULT DrawIndexPrim();
    HRESULT ExecuteI(LPD3DI_EXECUTEDATA lpExData, DWORD flags);
    HRESULT D3DAPI SetTextureStageState(DWORD dwStage,
                                        D3DTEXTURESTAGESTATETYPE dwState,
                                        DWORD dwValue);
    HRESULT D3DAPI ValidateDevice(LPDWORD lpdwNumPasses);
    HRESULT SetTSSI(DWORD, D3DTEXTURESTAGESTATETYPE, DWORD);
    // Called from DrawPrimitiveVB if a vertex buffer or TL buffer is used for rendering
    HRESULT StartPrimVB(LPDIRECT3DVERTEXBUFFERI vb, DWORD dwStartVertex);
    // Called if user memory buffer is used for rendering
    HRESULT StartPrimUserMem(LPVOID memory);
    // Called if TL buffer of used memory was used for rendering
    HRESULT EndPrim(DWORD dwVertexPoolSize);

    HRESULT CheckSurfaces();

    // This is the VB interface corresponding to the dp2data.lpDDVertex
    // This is kept so that the VB can be released when done
    // which cannot be done from just the LCL pointer which is lpDDVertex
    CDirect3DVertexBuffer* lpDP2CurrBatchVBI;

    HRESULT UpdateDrvViewInfo(LPD3DVIEWPORT2 lpVwpData);
    HRESULT UpdateDrvWInfo();
    HRESULT UpdatePalette(DWORD,DWORD,DWORD,LPPALETTEENTRY);
    HRESULT SetPalette(DWORD,DWORD,DWORD);
    void SetRenderTargetI(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE);
    void ClearI(DWORD, DWORD, LPD3DRECT, D3DCOLOR, D3DVALUE, DWORD);
};

//  macros to characterize device

#define IS_DP2HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DP2HAL)
#define IS_DX7HAL_DEVICE(lpDevI) ((lpDevI)->deviceType >= D3DDEVTYPE_DX7HAL)
#define IS_DX5_COMPATIBLE_DEVICE(lpDevI) ((lpDevI)->dwVersion >= 2)
#define IS_PRE_DX5_DEVICE(lpDevI) ((lpDevI)->dwVersion < 2)
#define IS_MT_DEVICE(lpDevI) ( (lpDevI)->dwHintFlags & D3DDEVBOOL_HINTFLAGS_MULTITHREADED )
#define IS_HW_DEVICE(lpDevI) ((lpDevI)->dwFEFlags & D3DFE_REALHAL)

/*
 * Internal version of Direct3DExecuteBuffer object;
 * it has data after the vtable
 */
class DIRECT3DEXECUTEBUFFERI : public IDirect3DExecuteBuffer,
                               public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DDEVICEI       lpDevI; /* Parent */
    LIST_MEMBER(DIRECT3DEXECUTEBUFFERI)list;
    /* Next buffer in IDirect3D */

    /*** Object Data ***/
    DWORD           pid;    /* Process locking execute buffer */
    D3DEXECUTEBUFFERDESC    debDesc;
    /* Description of the buffer */
    D3DEXECUTEDATA      exData; /* Execute Data */
    bool            locked; /* Is the buffer locked */

    D3DI_BUFFERHANDLE       hBuf; /* Execute buffer handle */
public:
    DIRECT3DEXECUTEBUFFERI();
    ~DIRECT3DEXECUTEBUFFERI();
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DExecuteBuffer Methods
    HRESULT D3DAPI Initialize(LPDIRECT3DDEVICE, LPD3DEXECUTEBUFFERDESC);
    HRESULT D3DAPI Lock(LPD3DEXECUTEBUFFERDESC);
    HRESULT D3DAPI Unlock();
    HRESULT D3DAPI SetExecuteData(LPD3DEXECUTEDATA);
    HRESULT D3DAPI GetExecuteData(LPD3DEXECUTEDATA);
    HRESULT D3DAPI Validate(LPDWORD, LPD3DVALIDATECALLBACK, LPVOID, DWORD);
    HRESULT D3DAPI Optimize(DWORD);
};

/*
 * Internal version of Direct3DLight object;
 * it has data after the vtable
 */

class DIRECT3DLIGHTI : public IDirect3DLight,
                       public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI         lpDirect3DI; /* Parent */
    LIST_MEMBER(DIRECT3DLIGHTI)list;
    /* Next light in IDirect3D */

    LPDIRECT3DVIEWPORTI lpD3DViewportI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(DIRECT3DLIGHTI)light_list;
    /* Next light in IDirect3DViewport */

    /*** Object Data ***/
    D3DLIGHT2           dlLight;        // Data describing light
    D3DI_LIGHT          diLightData;    // Internal representation of light
public:
    DIRECT3DLIGHTI();
    ~DIRECT3DLIGHTI();
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DLight Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D);
    HRESULT D3DAPI SetLight(LPD3DLIGHT);
    HRESULT D3DAPI GetLight(LPD3DLIGHT);
};


/*
 * Internal version of Direct3DMaterial object;
 * it has data after the vtable
 */
class DIRECT3DMATERIALI : public IDirect3DMaterial,
                          public IDirect3DMaterial2,
                          public IDirect3DMaterial3,
                          public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* Parent */
    LIST_MEMBER(DIRECT3DMATERIALI)list;
    /* Next MATERIAL in IDirect3D */

    LIST_ROOT(_mblocks, _D3DI_MATERIALBLOCK)blocks;
    /* devices we're associated with */

    /*** Object Data ***/
    D3DMATERIAL         dmMaterial; /* Data describing material */
    bool            bRes;   /* Is this material reserved in the driver */
public:
    DIRECT3DMATERIALI();
    ~DIRECT3DMATERIALI();
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DMaterial Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D);
    HRESULT D3DAPI SetMaterial(LPD3DMATERIAL);
    HRESULT D3DAPI GetMaterial(LPD3DMATERIAL);
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE, LPD3DMATERIALHANDLE);
    HRESULT D3DAPI Reserve();
    HRESULT D3DAPI Unreserve();

    // IDirect3DMaterial2 Methods
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE2, LPD3DMATERIALHANDLE);

    // IDirect3DMaterial3 Methods
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE3, LPD3DMATERIALHANDLE);
};

/*
 * If we have an aggreate Direct3DTexture we need a structure
 * to represent an unknown interface distinct from the underlying
 * object. This is that structure.
 */

class CDirect3DTextureUnk : public IUnknown
{
public:
    /* Reference count object */
    unsigned refCnt;
public:
    LPDIRECT3DTEXTUREI pTexI;
public:
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();
};

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
class DIRECT3DTEXTUREI : public IDirect3DTexture,
                         public IDirect3DTexture2,
                         public CD3DAlloc
{
public:
    /*** Object Relations ***/
    LIST_ROOT(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    /* Devices we're associated with */

    /*** Object Data ***/
    CDirect3DTextureUnk mTexUnk;

    DDRAWI_DDRAWSURFACE_INT DDSInt4;
    LPDIRECTDRAWSURFACE     lpDDS1Tex;  //we need to keep the legacy
    LPDIRECTDRAWSURFACE4    lpDDS;
    LPDIRECTDRAWSURFACE     lpDDSSys1Tex;  //we need to keep the legacy
    LPDIRECTDRAWSURFACE4    lpDDSSys;
    struct _D3DBUCKET       *lpTMBucket;
    DDSURFACEDESC2          ddsd;
    int                     LogTexSize;
    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN       lpOwningIUnknown; /* The owning IUnknown    */
    bool            bIsPalettized;
    bool            bInUse;
    BOOL            bDirty;
public:
    DIRECT3DTEXTUREI(LPUNKNOWN);
    ~DIRECT3DTEXTUREI();
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DTexture Methods
    HRESULT D3DAPI Initialize(LPDIRECT3DDEVICE, LPDIRECTDRAWSURFACE);
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE, LPD3DTEXTUREHANDLE);
    HRESULT D3DAPI PaletteChanged(DWORD, DWORD);
    HRESULT D3DAPI Load(LPDIRECT3DTEXTURE);
    HRESULT D3DAPI Unload();

    // IDirect3DTexture2 Methods
    HRESULT D3DAPI GetHandle(LPDIRECT3DDEVICE2, LPD3DTEXTUREHANDLE);
    HRESULT D3DAPI Load(LPDIRECT3DTEXTURE2);
};

/*
 * Internal version of Direct3DViewport object; it has data after the vtable
 */
class DIRECT3DVIEWPORTI : public IDirect3DViewport3,
                          public CD3DAlloc
{
public:
    int             refCnt; /* Reference count */

    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(DIRECT3DVIEWPORTI)list;
    /* Next viewport in IDirect3D */

    LPDIRECT3DDEVICEI       lpDevI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(DIRECT3DVIEWPORTI) vw_list;
    /* Next viewport in IDirect3DDevice */

    /* Lights */
    int             numLights;
    CIRCLE_QUEUE_ROOT(_dlights, DIRECT3DLIGHTI) lights;
    /* Associated IDirect3DLights */

    /*** Object Data ***/
    unsigned long       v_id;   /* Id for this viewport */
    D3DVIEWPORT2        v_data;
    BOOL                v_data_is_set;

    // Background Material
    BOOL                    bHaveBackgndMat;
    D3DMATERIALHANDLE       hBackgndMat;

    // Background Depth Surface
    LPDIRECTDRAWSURFACE     lpDDSBackgndDepth;

    // need to save this version of interface for DX6 GetBackgroundDepth
    LPDIRECTDRAWSURFACE4    lpDDSBackgndDepth_DDS4;

    /* Have the lights changed since they
       were last collected? */
    BOOL            bLightsChanged;

    DWORD           clrCount; /* Number of rects allocated */
    LPD3DRECT           clrRects; /* Rects used for clearing */

public:
    DIRECT3DVIEWPORTI(LPDIRECT3DI lpD3DI);
    ~DIRECT3DVIEWPORTI();
public:
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DViewport Methods
    HRESULT D3DAPI Initialize(LPDIRECT3D);
    HRESULT D3DAPI GetViewport(LPD3DVIEWPORT);
    HRESULT D3DAPI SetViewport(LPD3DVIEWPORT);
    HRESULT D3DAPI TransformVertices(DWORD, LPD3DTRANSFORMDATA, DWORD, LPDWORD);
    HRESULT D3DAPI LightElements(DWORD, LPD3DLIGHTDATA);
    HRESULT D3DAPI SetBackground(D3DMATERIALHANDLE);
    HRESULT D3DAPI GetBackground(LPD3DMATERIALHANDLE, LPBOOL);
    HRESULT D3DAPI SetBackgroundDepth(LPDIRECTDRAWSURFACE);
    HRESULT D3DAPI GetBackgroundDepth(LPDIRECTDRAWSURFACE*, LPBOOL);
    HRESULT D3DAPI SetBackgroundDepth2(LPDIRECTDRAWSURFACE4);
    HRESULT D3DAPI GetBackgroundDepth2(LPDIRECTDRAWSURFACE4*, LPBOOL);
    HRESULT D3DAPI Clear(DWORD, LPD3DRECT, DWORD);
    HRESULT D3DAPI AddLight(LPDIRECT3DLIGHT);
    HRESULT D3DAPI DeleteLight(LPDIRECT3DLIGHT);
    HRESULT D3DAPI NextLight(LPDIRECT3DLIGHT, LPDIRECT3DLIGHT*, DWORD);

    // IDirect3DViewport2 Methods
    HRESULT D3DAPI GetViewport2(LPD3DVIEWPORT2);
    HRESULT D3DAPI SetViewport2(LPD3DVIEWPORT2);

    // IDirect3DViewport3 Methods
    HRESULT D3DAPI Clear2(DWORD, LPD3DRECT, DWORD, D3DCOLOR, D3DVALUE, DWORD);
};

// Internal VB create flag:
#define D3DVBFLAGS_CREATEMULTIBUFFER    0x80000000L

class CDirect3DVertexBuffer : public IDirect3DVertexBuffer,
                              public CD3DAlloc
{
private:
    HRESULT CreateMemoryBuffer(LPDIRECT3DI lpD3DI,
                               LPDIRECTDRAWSURFACE4 *lplpSurface4,
                               LPDIRECTDRAWSURFACE  *lplpS,
                               LPVOID *lplpMemory,
                               DWORD dwBufferSize,
                               DWORD dwFlags);
    int             refCnt; /* Reference count */

    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(CDirect3DVertexBuffer)list;  /* Next vertex buffer in IDirect3D */

    // Internal data
    DWORD dwCaps;
    DWORD dwNumVertices;
    DWORD dwLockCnt;
    DWORD dwMemType;
    DWORD srcVOP, dstVOP;
    D3DVERTEXTYPE legacyVertexType;
    DWORD dwPVFlags;
    DWORD nTexCoord;
    /* position.lpData = start of vertex buffer data
     * position.dwStride = Number of bytes per vertex
     */
    union {
        D3DDP_PTRSTRIDE position;
        D3DDP_PTRSTRIDE SOA;
    };
    DWORD fvf; // Used in Input and Output
    D3DFE_CLIPCODE* clipCodes;
    LPDIRECTDRAWSURFACE4 lpDDSVB; // DDraw Surface containing the actual VB memory
    LPDIRECTDRAWSURFACE lpDDS1VB; // same dds, legacy interface for legacy hal.
    BOOL bReallyOptimized;        // VB could have OPTIMIZED caps set, but be
                                  // not optimized
    LPDIRECT3DDEVICEI lpDevIBatched; // Is this VB batched in a device ? If so we need to flush the device
                                     // on Lock
    // Friends
    friend void hookVertexBufferToD3D(LPDIRECT3DI, LPDIRECT3DVERTEXBUFFERI);
    friend class DIRECT3DDEVICEI;
public:
    CDirect3DVertexBuffer(LPDIRECT3DI);
    ~CDirect3DVertexBuffer();
    HRESULT Init(LPDIRECT3DI, LPD3DVERTEXBUFFERDESC, DWORD);
    LPDIRECTDRAWSURFACE GetDDS() { return lpDDS1VB; }
    HRESULT Restore() { return lpDDSVB->Restore(); }
    // IUnknown Methods
    HRESULT D3DAPI QueryInterface(REFIID riid, LPVOID* ppvObj);
    ULONG D3DAPI AddRef();
    ULONG D3DAPI Release();

    // IDirect3DVertexBuffer Methods
    HRESULT D3DAPI Lock(DWORD, LPVOID*, LPDWORD);
    HRESULT D3DAPI Unlock();
    HRESULT D3DAPI ProcessVertices(DWORD, DWORD, DWORD, LPDIRECT3DVERTEXBUFFER, DWORD, LPDIRECT3DDEVICE3, DWORD);
    HRESULT D3DAPI GetVertexBufferDesc(LPD3DVERTEXBUFFERDESC);
    HRESULT D3DAPI Optimize(LPDIRECT3DDEVICE3 lpDevI, DWORD dwFlags);
protected:
    // Internal Lock
    HRESULT D3DAPI LockI(DWORD, LPVOID*, LPDWORD);
};

// Now that LPDIRECT3DVERTEXBUFFERI is defined...
inline CDirect3DVertexBuffer* CBufferVB::GetVBI()
{
    return static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
}

inline LPDIRECTDRAWSURFACE CBufferVB::GetDDS()
{
    return GetVBI()->GetDDS();
}

// The instance of the class providing a guaranteed implementation
// This is defined / instantiated in pipeln\helxfrm.cpp
extern D3DFE_PVFUNCS GeometryFuncsGuaranteed;

extern void
D3DDeviceDescConvert(LPD3DDEVICEDESC lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt);

#endif
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\genlight.h ===
#ifndef __GENLIGHT_H__
#define __GENLIGHT_H__

typedef struct _SpecularTable 
{
    LIST_MEMBER(_SpecularTable) list;
    float          power;          /* shininess power */
    unsigned char   table[260]; /* space for overflows */
} SpecularTable;

void RLDDI_DoLights(D3DVALUE ar, D3DVALUE ag, D3DVALUE ab, int count,
                    D3DLIGHTINGELEMENT* elements, size_t in_size,
                    unsigned long *out, size_t out_size, int lightc, 
                    D3DI_LIGHT* lightv, D3DMATERIAL* mat, D3DVALUE gain, 
                    SpecularTable* tab);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\d3dmem.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dmem.h
 *  Content:    Direct3D memory access include file
 *
 ***************************************************************************/
#ifndef _D3DMEM_H_
#define _D3DMEM_H_

 class DIRECT3DDEVICEI;

 /*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI      D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI      D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI     D3DFree(LPVOID p);

HRESULT MallocAligned(void** p_return, size_t size);
void FreeAligned(void* p);
HRESULT ReallocAligned(void** p_inout, size_t size);

/* Base class for all D3D classes to use our special allocation functions everywhere */
class CD3DAlloc
{
public:
    void* operator new(size_t s)
    {
        void *p;
        MallocAligned(&p,s);
        return p;
    };
    void operator delete(void* p)
    {
        FreeAligned(p);
    };
};
//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//
class CAlignedBuffer32
{
public:
    CAlignedBuffer32()  {size = 0; allocatedBuf = 0; alignedBuf = 0;}
    ~CAlignedBuffer32() {if (allocatedBuf) D3DFree(allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(dwSize + 1024);
            else
                return D3D_OK;
        }
protected:
    LPVOID allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
};

// Forward declarations
class DIRECT3DDEVICEI;
class CDirect3DVertexBuffer;
class CDirect3DDeviceIDP2;
//----------------------------------------------------------------------
// This class manages a growing buffer using DDraw Surfaces.
class CBufferDDS
{
protected:
    LPDIRECTDRAWSURFACE allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size;
public:
    CBufferDDS()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
    }
    ~CBufferDDS()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf;
    }
    // Returns aligned buffer size
    DWORD GetSize()
    {
        return size;
    }
    LPDIRECTDRAWSURFACE GetDDS()
    {
        return allocatedBuf;
    }
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
    {
        if (dwSize > size)
            return Grow(lpDevI, dwSize + 1024);
        else
            return D3D_OK;
    }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    // define these later on in this file after CDirect3DVertexBuffer is defined
};
//----------------------------------------------------------------------
// This class manages a growing vertex buffer.
// Allocate it in driver friendly memory.
// Do not use except for DP2 DDI
class CBufferVB
{
protected:
    LPDIRECT3DVERTEXBUFFER allocatedBuf;
    LPVOID alignedBuf;
    DWORD  size, base;
public:
    CBufferVB()
    {
        size = 0;
        allocatedBuf = 0;
        alignedBuf = 0;
        base = 0;
    }
    ~CBufferVB()
    {
        if (allocatedBuf)
            allocatedBuf->Release();
    }
    // Returns aligned buffer address
    LPVOID GetAddress()
    {
        return (LPBYTE)alignedBuf + base;
    }
    // Returns aligned buffer size
    DWORD GetSize() { return size - base; }
    HRESULT Grow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize);
    DWORD& Base() { return base; }
    // define these later on in this file after CDirect3DVertexBuffer is defined
    inline CDirect3DVertexBuffer* GetVBI();
    inline LPDIRECTDRAWSURFACE GetDDS();
    HRESULT CheckAndGrow(DIRECT3DDEVICEI *lpDevI, DWORD dwSize)
        {
            if (dwSize > size)
                return Grow(lpDevI, dwSize + 1024);
            else
                return D3D_OK;
        }
    friend CDirect3DDeviceIDP2;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\haldrv.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL driver include file
 *
 ***************************************************************************/

#ifndef _HALDRV_H_
#define _HALDRV_H_

#undef DPF_MODNAME
#define DPF_MODNAME     "Direct3D HAL"

#define SURFACE_MEMORY(surf) \
(LPVOID)(((LPDDRAWI_DDRAWSURFACE_INT)(surf))->lpLcl->lpGbl->fpVidMem)

#ifdef TRACK_HAL_CALLS
#define RESET_HAL_CALLS(lpDevI) ((lpDevI)->hal_calls = 0)
#define TRACK_HAL_CALL(lpDevI) ((lpDevI)->hal_calls++)
#else
#define RESET_HAL_CALLS(lpDevI)
#define TRACK_HAL_CALL(lpDevI)
#endif


#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) "):" str


#ifdef WIN95

extern void _stdcall    GetpWin16Lock( LPVOID FAR *);
extern void _stdcall    _EnterSysLevel( LPVOID );
extern void _stdcall    _LeaveSysLevel( LPVOID );
extern LPVOID           lpWin16Lock;

#define LOCK_HAL(ret, lpDevI)                                           \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _EnterSysLevel(lpWin16Lock);                                    \
    }                                                                   \
    ret = D3D_OK;                                                       \
}

#define UNLOCK_HAL(lpDevI)                                              \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        _LeaveSysLevel(lpWin16Lock);                                    \
    }                                                                   \
}

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI);
void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI);

#define LOCK_DIBENGINE(ret, lpDevI)                                     \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        ret = D3DHAL_LockDibEngine(lpDevI);                             \
    }                                                                   \
    else    {                                                           \
        ret = D3D_OK;                                                   \
    }                                                                   \
}

#define UNLOCK_DIBENGINE(lpDevI)                                        \
{                                                                       \
    if (lpDevI->dwFEFlags & D3DFE_REALHAL)  {                           \
        D3DHAL_UnlockDibEngine(lpDevI);                                 \
    }                                                                   \
}

#else // WIN95

#define LOCK_HAL(ret, lpDevI) ret = DD_OK
#define UNLOCK_HAL(lpDevI)
#define LOCK_DIBENGINE(ret, lpDevI) ret = DD_OK
#define UNLOCK_DIBENGINE(lpDevI)

#endif // WIN95


#define CALL_HALONLY_NOLOCK(ret, lpDevI, call, data)                          \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks->call) {                                    \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks->call)(data);                   \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks2->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks2->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data)                        \
{                                                                             \
    if (lpDevI->lpD3DHALCommandBufferCallbacks->call) {                       \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCommandBufferCallbacks->call)(data);      \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}

#define CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data)                         \
{                                                                             \
    if (lpDevI->lpD3DHALCallbacks3->call) {                                   \
        LOCK_DIBENGINE(ret, lpDevI);                                          \
        if (ret != DD_OK) {                                                   \
            D3D_ERR("dibengine was busy, not calling HAL");                   \
        } else {                                                              \
            ret = (*lpDevI->lpD3DHALCallbacks3->call)(data);                  \
            TRACK_HAL_CALL(lpDevI)                                            \
            UNLOCK_DIBENGINE(lpDevI);                                         \
        }                                                                     \
    } else {                                                                  \
        D3D_ERR("No HAL call available");                                     \
        ret = DDHAL_DRIVER_NOTHANDLED;                                        \
    }                                                                         \
}


#define CALL_HALONLY(ret, lpDevI, call, data)                           \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALONLY_NOLOCK(ret, lpDevI, call, data);                   \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HALCBONLY(ret, lpDevI, call, data)                         \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HALCBONLY_NOLOCK(ret, lpDevI, call, data);                 \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

#define CALL_HAL2ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL2ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}
//-----------------------------------------------------------------------
// Call for callbacks that are not required to be implemented
//
#define CALL_HAL3ONLY_OPTIONAL(ret, lpDevI, call, data)                 \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    if (lpDevI->lpD3DHALCallbacks3->call)                               \
    {                                                                   \
        CALL_HAL3ONLY(ret, lpDevI, call, data);                         \
    }                                                                   \
}
//-----------------------------------------------------------------------
#define CALL_HAL3ONLY(ret, lpDevI, call, data)                          \
{                                                                       \
    BOOL locked;                                                        \
    ret = DD_OK;                                                        \
    LOCK_HAL(ret, lpDevI);                                              \
    if (ret == DD_OK)                                                   \
        locked = TRUE;                                                  \
    if (ret == DD_OK) {                                                 \
        CALL_HAL3ONLY_NOLOCK(ret, lpDevI, call, data);                  \
    }                                                                   \
    if (locked) {                                                       \
        UNLOCK_HAL(lpDevI);                                             \
    }                                                                   \
}

HRESULT D3DHAL_AllocateBuffer(LPDIRECT3DDEVICEI, LPD3DI_BUFFERHANDLE, LPD3DEXECUTEBUFFERDESC, LPDIRECTDRAWSURFACE*);
HRESULT D3DHAL_DeallocateBuffer(LPDIRECT3DDEVICEI, D3DI_BUFFERHANDLE);
HRESULT D3DHAL_DeallocateBuffers(LPDIRECT3DDEVICEI);
HRESULT D3DHAL_LockBuffer(LPDIRECT3DDEVICEI, D3DI_BUFFERHANDLE, LPD3DEXECUTEBUFFERDESC, LPDIRECTDRAWSURFACE*);
HRESULT D3DHAL_UnlockBuffer(LPDIRECT3DDEVICEI, D3DI_BUFFERHANDLE);
HRESULT D3DHAL_ExecuteClipped(LPDIRECT3DDEVICEI, LPD3DI_EXECUTEDATA);
HRESULT D3DHAL_ExecuteUnclipped(LPDIRECT3DDEVICEI, LPD3DI_EXECUTEDATA);
HRESULT D3DHAL_ExecutePick(LPDIRECT3DDEVICEI, LPD3DI_PICKDATA);
HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI, LPD3DTEXTUREHANDLE, LPDIRECTDRAWSURFACE);
HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK);
HRESULT D3DHAL_TextureSwap(LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE, D3DTEXTUREHANDLE);
__declspec(dllexport) HRESULT D3DHAL_TextureGetSurf(LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE, LPDIRECTDRAWSURFACE*);
HRESULT D3DHAL_MatrixCreate(LPDIRECT3DDEVICEI, LPD3DMATRIXHANDLE);
HRESULT D3DHAL_MatrixDestroy(LPDIRECT3DDEVICEI, D3DMATRIXHANDLE);
HRESULT D3DHAL_MatrixSetData(LPDIRECT3DDEVICEI, D3DMATRIXHANDLE, LPD3DMATRIX);
HRESULT D3DHAL_MatrixGetData(LPDIRECT3DDEVICEI, D3DMATRIXHANDLE, LPD3DMATRIX);
HRESULT D3DFE_SetViewportData(LPDIRECT3DDEVICEI, DWORD, LPD3DVIEWPORT2);
HRESULT D3DHAL_MaterialCreate(LPDIRECT3DDEVICEI, LPD3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_MaterialDestroy(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE);
HRESULT D3DHAL_MaterialSetData(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_MaterialGetData(LPDIRECT3DDEVICEI, D3DMATERIALHANDLE, LPD3DMATERIAL);
HRESULT D3DHAL_LightSet(LPDIRECT3DDEVICEI, DWORD, LPD3DI_LIGHT);
HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI, BOOL);

HRESULT D3DHAL_GetState(LPDIRECT3DDEVICEI, DWORD, LPD3DSTATE);

/*********************
 * HEL Calls
 *********************/

/*
 * Calls to emulate instructions.
 */
extern HRESULT D3DHELInst_D3DOP_STATELIGHT(LPDIRECT3DDEVICEI, DWORD, LPD3DSTATE);
extern HRESULT D3DHELInst_D3DOP_TEXTURELOAD(LPDIRECT3DDEVICEI, DWORD, LPD3DTEXTURELOAD);


extern HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                            LPDIRECTDRAW lpDD,
                            LPDIRECTDRAWSURFACE lpDDS,
                            LPDIRECTDRAWSURFACE lpZ,
                            LPDIRECTDRAWPALETTE lpPal);
extern void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI);

/*
 * Transform calls.
 */
extern HRESULT D3DFE_TransformUnclippedVp(D3DFE_PROCESSVERTICES*, DWORD, D3DTRANSFORMDATAI*);
extern HRESULT D3DFE_TransformClippedVp(D3DFE_PROCESSVERTICES*, DWORD, D3DTRANSFORMDATAI*);

/*
 * Lighting calls.
 */
extern HRESULT D3DFE_InitRGBLighting(LPDIRECT3DDEVICEI);
extern void D3DFE_DestroyRGBLighting(LPDIRECT3DDEVICEI);

DWORD   D3DFE_QueryTextureFormat (LPDIRECT3DDEVICEI, LPDDSURFACEDESC*);
HRESULT D3DFE_UpdateTexture (LPDIRECT3DDEVICEI, DWORD, D3DTEXTUREHANDLE);
HRESULT D3DFE_Clear(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags, DWORD numRect, LPD3DRECT lpRect, D3DCOLORVALUE *pFillColor, D3DTEXTUREHANDLE dwTexture);
HRESULT D3DFE_Clear2(LPDIRECT3DDEVICEI lpDevI, DWORD dwFlags,DWORD numRect, LPD3DRECT lpRect, D3DCOLOR dwColor, D3DVALUE dvZ, DWORD dwStencil);

HRESULT D3DFE_SetMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_SetMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_SetMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_MultMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_MultMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);
HRESULT D3DFE_MultMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat);

//---------------------------------------------------------------------
// This function is called from HALEXE.CPP and from device::SetRenderState
// Always use this function to update RSTATES.
//
HRESULT
SetDeviceRenderState(LPDIRECT3DDEVICEI lpDevI, D3DRENDERSTATETYPE type, 
                     DWORD value);

#ifndef WIN95
__inline HRESULT CheckContextSurface(LPDIRECT3DDEVICEI lpDevI)
{
    if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;
        HRESULT ret;

        rtData.dwhContext = lpDevI->dwhContext;
        if (lpDevI->dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDevI->lpDDSTarget)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpDevI->lpDDSZBuffer)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
        }
        else
        {
            rtData.lpDDS = lpDevI->lpDDSTarget;
            rtData.lpDDSZ = lpDevI->lpDDSZBuffer;
        }
  
        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, lpDevI, SetRenderTarget, &rtData);
        if (ret != DDHAL_DRIVER_HANDLED)
        {
            D3D_ERR ( "Driver did not handle SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the lpDevI stuck in here.
            return rtData.ddrval;
        }
        lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
    }
    return(D3D_OK);
}

__inline HRESULT CheckContextSurfaceNOLOCK (LPDIRECT3DDEVICEI lpDevI)
{
    if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;
        HRESULT ret;

        rtData.dwhContext = lpDevI->dwhContext;
        if (lpDevI->dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDevI->lpDDSTarget)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;
            
            if (lpDevI->lpDDSZBuffer)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSZBuffer)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;
            
        }
        else
        {
            rtData.lpDDS = lpDevI->lpDDSTarget;
            rtData.lpDDSZ = lpDevI->lpDDSZBuffer;
        }
        rtData.ddrval = 0;
        CALL_HAL2ONLY_NOLOCK(ret, lpDevI, SetRenderTarget, &rtData);
        if (ret != DDHAL_DRIVER_HANDLED)
        {
            D3D_ERR( "Driver did not handle SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the lpDevI stuck in here.
            return rtData.ddrval;
        }
        lpDevI->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
    }
    return(D3D_OK);
}
#endif //WIN95

// This struct is used for FindLightingRange RampService
typedef struct tagRAMP_RANGE_INFO
{
    DWORD base;
    DWORD size;
    LPVOID pTexRampMap;
    BOOL specular;
}RAMP_RANGE_INFO;

// This inline is for calling RastService when nothing special is required.
inline HRESULT CallRastService(LPDIRECT3DDEVICEI lpDevI,
                               RastServiceType ServiceType,
                               DWORD arg1,
                               LPVOID arg2)
{
    if (lpDevI->pfnRastService != NULL)
    {
        return lpDevI->pfnRastService(lpDevI->dwhContext,
                                     ServiceType, arg1, arg2);
    }
    else
    {
        return D3D_OK;
    }
}

// This inline is for calling RampService.
// bFlush is set to TRUE  when DrawPrims needs to be flushed.
// Right now, it is set for SetMat and LightState-SetMat.
inline HRESULT CallRampService(LPDIRECT3DDEVICEI lpDevI,
                               RastRampServiceType ServiceType,
                               ULONG_PTR arg1,
                               LPVOID arg2,
                               BOOL bFlush = FALSE)
{
    if (lpDevI->pfnRampService != NULL)
    {
        if (bFlush)
        {
            //time to flush DrawPrimitives
            (*lpDevI->pfnFlushStates)( lpDevI );
        }
        // Call the service
        return lpDevI->pfnRampService(lpDevI->dwhContext,
                                     ServiceType, arg1, arg2);
    }
    else
    {
        return D3D_OK;
    }
}

#endif /* _HALDRV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\genpick.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   genpick.h
 *  Content:    Generic picking function prototypes
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: commdrv.h,v 1.2 1995/12/04 11:30:59 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   17/05/96   v-jonsh Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _GENPICK_H_
#define _GENPICK_H_

#include "commdrv.hpp"

extern int  GenPickTriangle(LPDIRECT3DDEVICEI lpDevI,
                            D3DTLVERTEX*   base,
                            D3DTRIANGLE*   tri,
                            D3DRECT*   rect,
                            D3DVALUE*  result);

extern HRESULT  GenPickTriangles(LPDIRECT3DDEVICEI lpDevI,
                                 LPDIRECTDRAWSURFACE lpDDExeBuf,
                                 LPBYTE      lpData,
                                 D3DINSTRUCTION* ins,
                                 D3DTRIANGLE*    tri,
                                 LPD3DRECTV      extent,
                                 D3DRECT*    pick_region);

extern HRESULT  GenAddPickRecord(LPDIRECT3DDEVICEI lpDevI,
                                 D3DOPCODE op,
                                 int offset,
                                 float result);

extern HRESULT  GenGetPickRecords(LPDIRECT3DDEVICEI lpDevI,
                                  D3DI_PICKDATA* pdata);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\halprov.h ===
//----------------------------------------------------------------------------
//
// halprov.h
//
// Defines the IHalProvider interface.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HALPROV_H_
#define _HALPROV_H_

// The following stuff is for Ramp Rasterizer.
typedef enum _RastRampServiceType
{
    RAMP_SERVICE_CREATEMAT              = 0,
    RAMP_SERVICE_DESTORYMAT             = 1,
    RAMP_SERVICE_SETMATDATA             = 2,
    RAMP_SERVICE_SETLIGHTSTATE          = 3,
    // This returns base, size, and a texture ramp.
    // Arg1 is a pointer to RAMP_RANGE_INFO.
    RAMP_SERVICE_FIND_LIGHTINGRANGE     = 4,
    // This service only calls BeginSceneHook. Both arg1 and arg2 are ignored.
    RAMP_SERVICE_CLEAR                  = 5,
    // Arg1 is a D3DMATERIALHANDLE, arg2 is a DWORD* to get the pixel value.
    RAMP_SERVICE_MATERIAL_TO_PIXEL      = 6,
    // Arg1 is 0 if end scene, != 0 if begin scene
    RAMP_SERVICE_SCENE_CAPTURE          = 8,
    // Arg1 is hTex
    RAMP_SERVICE_PALETTE_CHANGED        = 9,
    // Arg1 is hMat, Arg2 is RECT*
    RAMP_SERVICE_CLEAR_TEX_RECT        = 10,
} RastRampServiceType;

typedef enum _RastServiceType
{
    // Arg1 is a D3DCOLOR, and Arg2 is a DWORD* to get the pixel value
    RAST_SERVICE_RGB8COLORTOPIXEL              = 0,
} RastServiceType;

typedef HRESULT (*PFN_RASTRAMPSERVICE)
    (ULONG_PTR dwCtx, RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2);

typedef HRESULT (*PFN_RASTSERVICE)
    (ULONG_PTR dwCtx, RastServiceType srvType, DWORD arg1, LPVOID arg2);

typedef struct _D3DHALPROVIDER_INTERFACEDATA
{
    DWORD                       dwSize;
    LPD3DHAL_GLOBALDRIVERDATA   pGlobalData;
    LPD3DHAL_D3DEXTENDEDCAPS    pExtCaps;
    LPD3DHAL_CALLBACKS          pCallbacks;
    LPD3DHAL_CALLBACKS2         pCallbacks2;
    LPD3DHAL_CALLBACKS3         pCallbacks3;

    // This function pointer should be NULL except for ramp rasterizer.
    PFN_RASTRAMPSERVICE         pfnRampService;

    PFN_RASTSERVICE             pfnRastService;

} D3DHALPROVIDER_INTERFACEDATA, *LPD3DHALPROVIDER_INTERFACEDATA;


#undef INTERFACE
#define INTERFACE IHalProvider

DECLARE_INTERFACE_(IHalProvider, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion) PURE;
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion) PURE;
};

STDAPI GetHwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll, LPDDRAWI_DIRECTDRAW_GBL pDdGbl);
STDAPI GetSwHalProvider(REFCLSID riid,
                        IHalProvider **ppHalProvider, HINSTANCE *phDll);

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

#endif // #ifndef _HALPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\testfile.h ===
//----------------------------------------------------------------------------
//
// testfile.h
//
// Defines for file with test data.
//
// File format:
//      File contains chunks of data. Each chunk has four-byte ID, four-byte data size field and
//      "size" number of bytes of data.
//      Chunks:
//          ID          Meaning           Data
//          1       Scene capture       DWORD flags
//          2       Render state        DWORD states count
//                                      States (D3DSTATE*count)
//          3       Render primitive    DWORD status
//                                      D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      D3DINSTRUCTION
//                                        Primitive record (D3DPOINT, D3DLINE ...)
//                                        Primitive vertices (TLVERTEX)
//                                        ...
//          4       Draw one primitive  D3DPRIMITIVETYPE primitive type
//                                      DWORD number of vertices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//          5       Draw one indexed    D3DPRIMITIVETYPE primitive type
//                      primitive       DWORD number of vertices
//                                      DWORD number of indices
//                                      D3DVERTEXTYPE vertex type
//                                      Vertices
//                                      Indices (WORD)
//          6       Draw primitives     The same as DDI data, but without 32 byte
//                                      alignment.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#ifndef _TESTFILE_H_
#define _TESTFILE_H_

// TF stands for "TestFile"
typedef struct
{
    DWORD id;           // record ID
    DWORD size;         // size of data in bytes (exclude size of REC_HEADER)
} TF_HEADER;

// ID for test file records
const DWORD TFID_SCENECAPTURE               = 1;
const DWORD TFID_RENDERSTATE                = 2;
const DWORD TFID_RENDERPRIMITIVE            = 3;
const DWORD TFID_DRAWONEPRIMITIVE           = 4;
const DWORD TFID_DRAWONEINDEXEDPRIMITIVE    = 5;
const DWORD TFID_DRAWPRIMITIVES             = 6;
const DWORD TFID_DRAWPRIMITIVES2            = 7;

// Fixed size record headers
typedef struct
{
    DWORD               status;
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
} TFREC_RENDERPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               dwFlags;
} TFREC_DRAWONEPRIMITIVE;

typedef struct
{
    D3DPRIMITIVETYPE    primitiveType;
    DWORD               vertexCount;
    D3DVERTEXTYPE       vertexType;
    DWORD               indexCount;
    DWORD               dwFlags;
} TFREC_DRAWONEINDEXEDPRIMITIVE;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES;

typedef struct
{
    DWORD               dwFlags;
} TFREC_DRAWPRIMITIVES2;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\dpclip.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpclip.c
 *  Content:    DrawPrimitive clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipfunc.h"
#include "drawprim.hpp"

//---------------------------------------------------------------------
inline HRESULT DRAW_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType, 
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;                                    
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    // PSGP implementation should not implement INSIDEEXECUTE should do
    // ret = pv->DrawPrim();  !!!
    HRESULT ret = (((LPDIRECT3DDEVICEI)pv)->*(((LPDIRECT3DDEVICEI)pv)->pfnDrawPrim))();                                  
    return ret;   
}
//---------------------------------------------------------------------
inline HRESULT DRAW_INDEX_PRIM(D3DFE_PROCESSVERTICES *pv, 
                               D3DPRIMITIVETYPE primitiveType, 
                               LPWORD startIndex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpwIndices = startIndex;                                     
    pv->primType = primitiveType;                                    
    pv->dwNumIndices = vertexCount;                                  
    pv->dwNumPrimitives = numPrim;                                   
    // PSGP implementation should not implement INSIDEEXECUTE. It should do
    // ret = pv->DrawIndexPrim();  !!!
    HRESULT ret = (((LPDIRECT3DDEVICEI)pv)->*(((LPDIRECT3DDEVICEI)pv)->pfnDrawIndexedPrim))();                                  
    return ret;
}
//----------------------------------------------------------------------
__inline HRESULT Clip(D3DFE_PROCESSVERTICES *pv, 
                      int interpolate, 
                      ClipVertex *cv,
                      WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE)
{
    ClipTriangle newtri;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    newtri.v[0] = &cv[0];
    newtri.v[1] = &cv[1];
    newtri.v[2] = &cv[2];
    newtri.flags = wFlags;

    int count;
    ClipVertex** ver;
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    if (count = lpDevI->pGeometryFuncs->ClipSingleTriangle(
                                   pv, &newtri, &ver, interpolate))
    {
        int i;
        HRESULT ret;
        BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
        BYTE *p = pTLV;

        for (i = 0; i < count; i++) 
        {
            MAKE_TL_VERTEX_FVF(pv, p, ver[i]);
            p += pv->dwOutputSize;
        }
        pv->dwFlags |= D3DPV_CLIPPERPRIM; // Mark this call as gen by clipper
        ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pTLV, count, count-2);
        pv->dwFlags &= ~D3DPV_CLIPPERPRIM;
        if (ret)
            return ret;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//------------------------------------------------------------------------------
HRESULT ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    BYTE   *p1;
    DWORD   f1;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    BYTE       *startVertex;                                
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = (BYTE*)pv->lpvOut;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    f1 = clipCode[0];
    p1 = vertex;
    clipCode++;
    vertex += vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], p1, f1, vertexTransformed, clipMaskOffScreen);
    for (i = pv->dwNumVertices-2; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        f2 = clipCode[0];
        f3 = clipCode[1];

        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                BYTE tmp[__MAX_VERTEX_SIZE];
                BYTE *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart -= vertexSize;
                    memcpy (tmp, pStart, vertexSize);
                    memcpy (pStart, p1, vertexSize);
                }
                // Mark this call as gen by clipper, but set non clipped bit
                pv->dwFlags |= D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED; 
                ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                            vertexCount);
                pv->dwFlags &= ~(D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED);
                if (ret)
                    return ret;
                if (startVertex != p1)
                    memcpy (pStart, tmp, vertexSize);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = vertex + vertexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex;
                BYTE *p3 = vertex + vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed, clipMaskOffScreen);

                ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } else 
            vertexCount++;
        clipCode++;
        vertex += vertexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        BYTE tmp[__MAX_VERTEX_SIZE];
        BYTE *pStart = startVertex;
        if (startVertex != p1)
        {
            pStart -= vertexSize;
            memcpy(tmp, pStart, vertexSize);
            memcpy(pStart, p1, vertexSize);
        }
        // Mark this call as gen by clipper
        pv->dwFlags |= D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED; 
        ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        pv->dwFlags &= ~(D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED);
        if (ret)
            return ret;

        if (startVertex != p1)
            memcpy(pStart, tmp, vertexSize);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    WORD        *p1;
    DWORD        f1;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    LPWORD       startVertex;                               
    LPWORD index = pv->lpwIndices;                               \
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = pv->lpwIndices;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    f1 = clipCode[index[0]];
    p1 = index;
    index++;
    BYTE *ver = vertex + p1[0]*vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], ver, f1, vertexTransformed, clipMaskOffScreen);
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        WORD  v1, v2;
        v1 = index[0];
        v2 = index[1];
        f2 = clipCode[v1];
        f3 = clipCode[v2];
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                WORD tmp;
                WORD *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart--;
                    tmp = *pStart;  // Save old value to restore later
                    *pStart = *p1;
                }
                ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                  vertexCount);
                if (ret)
                    return ret;
                if (startVertex != p1)
                    *pStart = tmp;   // Restore old value
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = &index[1];

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex + v1*vertexSize;
                BYTE *p3 = vertex + v2*vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed, clipMaskOffScreen);

                ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } 
        else 
            vertexCount++;
        index++;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        WORD tmp;
        WORD *pStart = startVertex;
        if (startVertex != p1)
        {
            pStart--;
            tmp = *pStart;  // Save old value to restore later
            *pStart = *p1;
        }
        ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        if (ret)
            return ret;
        if (startVertex != p1)
            *pStart = tmp;   // Restore old value
        if (ret)
            return ret;
    }
    return D3D_OK;
} 

#define __PROCESS_LINE_NAME ProcessClippedLine
#define __PROCESS_TRI_LIST_NAME ProcessClippedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedTriangleStrip
#include "clipprim.h"

#define __INDEX_PRIM
#define __PROCESS_TRI_LIST_NAME ProcessClippedIndexedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedIndexedTriangleStrip
#define __PROCESS_LINE_NAME ProcessClippedIndexedLine
#include "clipprim.h"

//---------------------------------------------------------------------
HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    DWORD dwVertexBaseOrg = pv->dwVertexBase;
    for (i=0; i < nVertices; i++) 
    {
        if (clipCode[i]) 
        {       // if this point is clipped
            pv->dwVertexBase = dwVertexBaseOrg + i - count;
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
        } 
        else 
        {
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        pv->dwVertexBase = dwVertexBaseOrg + nVertices - count;
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\handle.hpp ===
/*
 * $Id: handle.hpp,v 1.5 1995/10/24 14:06:26 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef _HANDLE_H_
#define _HANDLE_H_

#include "lists.hpp"

typedef DWORD RLDDIHandle;

typedef void (*RLDDIHandleCallback)(void* lpArg);

typedef struct _RLDDIHandleEntry 
{
    LIST_MEMBER(_RLDDIHandleEntry) link;
    DWORD       hArg;
    RLDDIHandleCallback lpFunc;
    void*       lpArg;
} RLDDIHandleEntry;

typedef struct _handle_chunk 
{
    LIST_MEMBER(_handle_chunk)      link;
} handle_chunk;

typedef struct _handle_pool 
{
    LIST_ROOT(_h, _RLDDIHandleEntry)    free;
    RLDDIHandleEntry*           unallocated;
    int                 num_unallocated;
    LIST_ROOT(_ch, _handle_chunk)   chunks;
} handle_pool;

#define HANDLE_MAX      ((1 << 16) - 1)
#define HANDLE_HASHNUM  251
#define HANDLE_HASH(x)  (x % HANDLE_HASHNUM)

typedef struct _RLDDIHandleTable 
{
    LIST_ROOT(_rthe, _RLDDIHandleEntry) hash[HANDLE_HASHNUM];
    handle_pool pool;
    int next;
} RLDDIHandleTable;

RLDDIHandleTable* RLDDICreateHandleTable(void);
void RLDDIDestroyHandleTable(RLDDIHandleTable*);
RLDDIHandle RLDDIHandleTableCreateHandle(RLDDIHandleTable* table,
                                         void* lpArg,
                                         RLDDIHandleCallback lpFunc);
void*   RLDDIHandleTableFindHandle(RLDDIHandleTable* table,
                                   RLDDIHandle hArg);
BOOL    RLDDIHandleTableReplaceHandle(RLDDIHandleTable* table,
                                      RLDDIHandle hArg,
                                      LPVOID lpArg);
void    RLDDIHandleTableDeleteHandle(RLDDIHandleTable* table,
                                     RLDDIHandle hArg);

#endif /* _HANDLE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\gensym.cpp ===
/*
 * $Id: gensym.cpp,v 1.7 1995/11/21 14:45:51 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include <stdio.h>
#include "d3di.hpp"

#define DEFINE(type, member) \
    printf(#type "_" #member "  equ 0%xh\n", ((LONG)(&((type *)0)->member)))

#define MACRO(name) \
    printf(#name "  equ 0%xh\n", name)

// pcomment prints a comment.

#define pcomment(s)  printf("; %s\n",s)

// pequate prints an equate statement.

#define pequate(name, value) printf("%s equ 0%lXH\n",name,value);

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     printf("\n")

#define printVCACHE(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, vcache.##name)); \
} 

#define printD3DI_LIGHT(name)   \
{                               \
    printf("%-30s equ 0%LXH\n", "D3DI_LIGHT_"#name, OFFSET(D3DI_LIGHT, name)); \
} 

#define printD3DFE_LIGHTING(name)  \
{                               \
    printf("%-30s equ 0%LXH\n", "PV_LIGHTING_"#name, OFFSET(D3DFE_PROCESSVERTICES, lighting.##name)); \
} 

#define printDevice(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", "DEVI_"#name, OFFSET(DIRECT3DDEVICEI, name)); \
} 

#define printDeviceDP2(name)   \
{                           \
    printf("%-30s equ 0%LXH\n", #name, OFFSET(CDirect3DDeviceIDP2, name)); \
} 

int main()
{
pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: offsets.asm");
    pcomment("");
    pcomment(" Defines D3D assembly-language structures.");
    pcomment(" This file is generated");
    pcomment("");
    pcomment(" Copyright (c) 1998, 1995 Microsoft Corporation");
pcomment("------------------------------------------------------------------");
    pblank();
    pblank();

    DEFINE(D3DINSTRUCTION, wCount);
    DEFINE(D3DINSTRUCTION, bSize);
    DEFINE(D3DINSTRUCTION, bOpcode);
    
    DEFINE(D3DVERTEX, x);
    DEFINE(D3DVERTEX, y);
    DEFINE(D3DVERTEX, z);
    DEFINE(D3DVERTEX, tu);
    DEFINE(D3DVERTEX, tv);

    DEFINE(D3DLVERTEX, color);
    DEFINE(D3DLVERTEX, specular);

    DEFINE(D3DTLVERTEX, sx);
    DEFINE(D3DTLVERTEX, sy);
    DEFINE(D3DTLVERTEX, sz);
    DEFINE(D3DTLVERTEX, rhw);
    DEFINE(D3DTLVERTEX, color);
    DEFINE(D3DTLVERTEX, specular);
    DEFINE(D3DTLVERTEX, tu);
    DEFINE(D3DTLVERTEX, tv);
    printf("D3DTLVERTEX_size    equ %d\n", sizeof(D3DTLVERTEX));

    DEFINE(D3DHVERTEX, dwFlags);
    DEFINE(D3DHVERTEX, hx);
    DEFINE(D3DHVERTEX, hy);
    DEFINE(D3DHVERTEX, hz);
    printf("D3DHVERTEX_size equ %d\n", sizeof(D3DHVERTEX));
    
    DEFINE(D3DTRIANGLE, v1);
    DEFINE(D3DTRIANGLE, v2);
    DEFINE(D3DTRIANGLE, v3);
    DEFINE(D3DTRIANGLE, wFlags);
    printf("D3DTRIANGLE_size equ %d\n", sizeof(D3DTRIANGLE));

    DEFINE(D3DMATRIXI, _11);
    DEFINE(D3DMATRIXI, _12);
    DEFINE(D3DMATRIXI, _13);
    DEFINE(D3DMATRIXI, _14);
    DEFINE(D3DMATRIXI, _21);
    DEFINE(D3DMATRIXI, _22);
    DEFINE(D3DMATRIXI, _23);
    DEFINE(D3DMATRIXI, _24);
    DEFINE(D3DMATRIXI, _31);
    DEFINE(D3DMATRIXI, _32);
    DEFINE(D3DMATRIXI, _33);
    DEFINE(D3DMATRIXI, _34);
    DEFINE(D3DMATRIXI, _41);
    DEFINE(D3DMATRIXI, _42);
    DEFINE(D3DMATRIXI, _43);
    DEFINE(D3DMATRIXI, _44);
    DEFINE(D3DMATRIXI, type);

    DEFINE(D3DLIGHTINGELEMENT, dvPosition);
    DEFINE(D3DLIGHTINGELEMENT, dvNormal);
    printf("D3DMATRIXI_size equ %d\n", sizeof(D3DMATRIXI));
    printf("D3DFE_LIGHTING_size equ %d\n", sizeof(D3DFE_LIGHTING));
    printf("D3DFE_VIEWPORTCACHE_size equ %d\n", sizeof(D3DFE_VIEWPORTCACHE));

    MACRO(D3DOP_TRIANGLE);

    MACRO(D3DCLIP_LEFT);
    MACRO(D3DCLIP_RIGHT);
    MACRO(D3DCLIP_TOP);
    MACRO(D3DCLIP_BOTTOM);
    MACRO(D3DCLIP_FRONT);
    MACRO(D3DCLIP_BACK);

    MACRO(D3DTBLEND_COPY);
    MACRO(D3DSHADE_FLAT);

    MACRO(D3DCMP_LESSEQUAL);
    MACRO(D3DCMP_GREATEREQUAL);
    MACRO(D3DCMP_ALWAYS);

    MACRO(D3DSTATUS_ZNOTVISIBLE);
    MACRO(D3DDP_DONOTUPDATEEXTENTS);

// Geometry pipeline
pcomment("-------------------- VCACHE ------------------------------------");
    printVCACHE(scaleX);
    printVCACHE(scaleY);
    printVCACHE(offsetX);
    printVCACHE(offsetY);
    printVCACHE(minXgb);
    printVCACHE(minYgb);
    printVCACHE(maxXgb);
    printVCACHE(maxYgb);
    printVCACHE(minX);
    printVCACHE(minY);
    printVCACHE(maxX);
    printVCACHE(maxY);
    printVCACHE(gb11);
    printVCACHE(gb22);
    printVCACHE(gb41);
    printVCACHE(gb42);
    printVCACHE(Kgbx1);
    printVCACHE(Kgby1);
    printVCACHE(Kgbx2);
    printVCACHE(Kgby2);
    printVCACHE(dvX);
    printVCACHE(dvY);
    printVCACHE(dvWidth);
    printVCACHE(dvHeight);
    printVCACHE(scaleXi);
    printVCACHE(scaleYi);
    printVCACHE(minXi);
    printVCACHE(minYi);
    printVCACHE(maxXi);
    printVCACHE(maxYi);
    printVCACHE(mclip11);
    printVCACHE(mclip41);
    printVCACHE(mclip22);
    printVCACHE(mclip42);
    printVCACHE(mclip33);
    printVCACHE(mclip43);
pcomment("---------------- D3DFE_LIGHTING ------------------------------------");
    printD3DFE_LIGHTING(diffuse);
    printD3DFE_LIGHTING(alpha);
    printD3DFE_LIGHTING(diffuse0);
    printD3DFE_LIGHTING(currentSpecTable);
    printD3DFE_LIGHTING(specular);
    printD3DFE_LIGHTING(outDiffuse);
    printD3DFE_LIGHTING(vertexDiffuse);
    printD3DFE_LIGHTING(outSpecular);
    printD3DFE_LIGHTING(vertexSpecular);
    printD3DFE_LIGHTING(specularComputed);
    printD3DFE_LIGHTING(activeLights);
    printD3DFE_LIGHTING(material);
    printD3DFE_LIGHTING(hMat);
    printD3DFE_LIGHTING(ambient_red);
    printD3DFE_LIGHTING(ambient_green);
    printD3DFE_LIGHTING(ambient_blue);
    printD3DFE_LIGHTING(fog_mode);
    printD3DFE_LIGHTING(fog_density);
    printD3DFE_LIGHTING(fog_start);
    printD3DFE_LIGHTING(fog_end);
    printD3DFE_LIGHTING(fog_factor);
    printD3DFE_LIGHTING(fog_factor_ramp);
    printD3DFE_LIGHTING(specThreshold);
    printD3DFE_LIGHTING(color_model);
    printD3DFE_LIGHTING(ambient_save);
pcomment("---------------- D3DI_LIGHT ------------------------------------");
    printD3DI_LIGHT(model_position);
    printD3DI_LIGHT(type);
    printD3DI_LIGHT(model_direction);
    printD3DI_LIGHT(version);
    printD3DI_LIGHT(model_eye);
    printD3DI_LIGHT(flags);
    printD3DI_LIGHT(model_scale);
    printD3DI_LIGHT(falloff);
    printD3DI_LIGHT(local_diffR);
    printD3DI_LIGHT(local_diffG);
    printD3DI_LIGHT(local_diffB);
    printD3DI_LIGHT(valid);
    printD3DI_LIGHT(local_specR);
    printD3DI_LIGHT(local_specG);
    printD3DI_LIGHT(local_specB);
    printD3DI_LIGHT(inv_theta_minus_phi);
    printD3DI_LIGHT(halfway);
    printD3DI_LIGHT(next);
    printD3DI_LIGHT(red);
    printD3DI_LIGHT(green);
    printD3DI_LIGHT(blue);
    printD3DI_LIGHT(shade);
    printD3DI_LIGHT(range_squared);
    printD3DI_LIGHT(attenuation0);
    printD3DI_LIGHT(attenuation1);
    printD3DI_LIGHT(attenuation2);
    printD3DI_LIGHT(cos_theta_by_2);
    printD3DI_LIGHT(cos_phi_by_2);
    printD3DI_LIGHT(position);
    printD3DI_LIGHT(direction);
    printD3DI_LIGHT(range);
  
pcomment("---------------- DIRECT3DDEVICEI ------------------------------------");
    printDevice(dwVersion);
    printDevice(dwRampBase);
    printDevice(dvRampScale);
    printDevice(lpvRampTexture);
    printDevice(mCTM);
    printDevice(dwMaxTextureIndices);
    printDevice(lighting);
    printDevice(vcache);
    printDevice(dvExtentsAdjust);
    printDevice(lpdwRStates);
    printDevice(pD3DMappedTexI);
    printDevice(ClipperState);
    printDevice(dwVertexBase);
    printDevice(dwFlags);
    printDevice(dwDeviceFlags);
    printDevice(dwNumVertices);
    printDevice(dwNumPrimitives);
    printDevice(dwNumIndices);
    printDevice(lpwIndices);
    printDevice(primType);
    printDevice(nTexCoord);
    printDevice(position);
    printDevice(normal);
    printDevice(diffuse);
    printDevice(specular);
    printDevice(textures);
    printDevice(dwVIDIn);
    printDevice(dwVIDOut);
    printDevice(dwOutputSize);
    printDevice(lpvOut);
    printDevice(lpClipFlags);
    printDevice(rExtents);
    printDevice(dwClipUnion);
    printDevice(dwClipIntersection);
    printDevice(pfnFlushStates            );
    printDevice(deviceType                );
    printDevice(lpDirect3DI               );
    printDevice(list                      );
    printDevice(texBlocks                 );
    printDevice(buffers                   );
    printDevice(numViewports              );
    printDevice(viewports                 );
    printDevice(lpCurrentViewport         );
    printDevice(matBlocks                 );
    printDevice(mDevUnk                   );
    printDevice(guid                      );
    printDevice(matBlocks                 );
    printDevice(mDevUnk                   );
    printDevice(guid                      );
    printDevice(lpD3DHALCallbacks         );
    printDevice(lpD3DHALGlobalDriverData  );
    printDevice(lpD3DHALCallbacks2        );
    printDevice(lpD3DHALCallbacks3        );
    printDevice(lpDD                      );
    printDevice(lpDDGbl                   );
    printDevice(lpDDSTarget               );
    printDevice(lpDDSZBuffer              );
    printDevice(lpDDPalTarget             );
    printDevice(lpDDSTarget_DDS4          );
    printDevice(lpDDSZBuffer_DDS4         );
    printDevice(dwWidth                   );
    printDevice(dwHeight                  );
    printDevice(transform                 );
    printDevice(dwhContext                );
    printDevice(bufferHandles             );
    printDevice(pfnDrawPrim               );
    printDevice(pfnDrawIndexedPrim        );
    printDevice(red_mask                  );
    printDevice(red_scale                 );
    printDevice(red_shift                 );
    printDevice(green_mask);
    printDevice(green_scale);
    printDevice(green_shift);
    printDevice(blue_mask);
    printDevice(blue_scale);
    printDevice(blue_shift);
    printDevice(zmask_shift);
    printDevice(stencilmask_shift);
    printDevice(bDDSTargetIsPalettized);
    printDevice(pick_data);
    printDevice(lpbClipIns_base);
    printDevice(dwClipIns_offset);
    printDevice(renderstate_overrides);
    printDevice(transformstate_overrides);
    printDevice(lightstate_overrides);
    printDevice(iClipStatus);
    printDevice(D3DStats);
    printDevice(dwFVFLastIn);
    printDevice(dwFVFLastOut);
    printDevice(dwFVFLastTexCoord);
    printDevice(dwFVFLastOutputSize);
    printDevice(dwFEFlags);
    printDevice(dwDebugFlags);
    printDevice(v_id);
    printDevice(numLights);
    printDevice(specular_tables);
    printDevice(specular_table);
    printDevice(materials);
    printDevice(lightVertexFuncTable);
    printDevice(pHalProv);
    printDevice(hDllProv);
    printDevice(pfnDoFlushBeginEnd);
    printDevice(d3dHWDevDesc);
    printDevice(d3dHELDevDesc);
    printDevice(lpOwningIUnknown);
    printDevice(lpD3DMappedTexI);
    printDevice(lpD3DMappedBlock);
    printDevice(lpClipper);
    printDevice(dwHintFlags);
    printDevice(lpcCurrentPtr);
    printDevice(BeginEndCSect);
    printDevice(lpvVertexBatch);
    printDevice(lpIndexBatch);
    printDevice(lpvVertexData);
    printDevice(dwBENumVertices);
    printDevice(dwMaxVertexCount);
    printDevice(lpVertexIndices);
    printDevice(dwBENumIndices);
    printDevice(dwMaxIndexCount);
    printDevice(wFlushed);
    printDevice(lpTextureBatched);
    printDevice(lpwDPBuffer);
    printDevice(dwCurrentBatchVID);
    printDevice(lpDPPrimCounts);
    printDevice(lpHWCounts);
    printDevice(lpHWTris);
    printDevice(lpHWVertices);
    printDevice(dwHWOffset);
    printDevice(dwHWMaxOffset);
    printDevice(dwHWTriIndex);
    printDevice(dwHWNumCounts);
    printDevice(dwDPOffset);
    printDevice(dwDPMaxOffset);
    printDevice(wTriIndex);
    printDevice(TLVbuf);
    printDevice(HVbuf);
    printDevice(lpD3DExtendedCaps);
    printDevice(rstates);
    printDevice(tsstates);
    printDevice(pfnRampService);
    printDevice(pfnRastService);
    printDevice(pGeometryFuncs);
    printDevice(mWV);
pcomment("---------------- CDirect3DDeviceIDP2 ----------------------");
    printDeviceDP2(lpDDSCB1);
    printDeviceDP2(lpvDP2Commands);
    printDeviceDP2(lpDP2CurrCommand);
    printDeviceDP2(dp2data);
    printDeviceDP2(dwDP2CommandLength);
    printDeviceDP2(dwDP2CommandBufSize);
    printDeviceDP2(bDP2CurrCmdOP);
    printDeviceDP2(wDP2CurrCmdCnt);
    printDeviceDP2(dwDP2Flags);
pcomment("---------------- MISC ------------------------------------");
    /*                                     
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    pequate("DEVI_                              ", OFFSET(DIRECT3DDEVICEI, ));
    */
    pequate("_R_", 0);
    pequate("_G_", 4);
    pequate("_B_", 8);

    pequate("_X_", 0);
    pequate("_Y_", 4);
    pequate("_Z_", 8);
    pequate("_W_", 12);
    pequate("D3DLIGHTI_COMPUTE_SPECULAR ", D3DLIGHTI_COMPUTE_SPECULAR);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\inc\span.h ===
//----------------------------------------------------------------------------
//
// span.h
//
// Structures which define the interface between the edge walker to the
// span interpolator.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPAN_H_
#define _SPAN_H_

#include <d3ditype.h>
#include <d3dhal.h>

#ifdef __cplusplus
extern "C" {
#endif

// TBD make this machine independent
// don't leave any space between the elements of these structures
// currently smallest element is a UINT16, may have to change this to pack(1)
// if UINT8's are used.
#include <pshpack2.h>

// Limits, shifts and scaling factors for RASTSPAN and RASTPRIM data.
// C_*_LIMIT is the constant integer form of the limit for cases where
// direct integer comparisons can be done.
#define Z_LIMIT         g_fTwoPow31
#define C_Z_LIMIT       0x4f000000
#define Z16_FRAC_SHIFT  15
#define Z16_FRAC_SCALE  g_fTwoPow15
#define OO_Z16_FRAC_SCALE g_fOoTwoPow15
#define Z16_SHIFT       31
#define Z16_SCALE       g_fNearTwoPow31
#define OO_Z16_SCALE    g_fOoNearTwoPow31
#define Z32_FRAC_SHIFT  0
#define Z32_FRAC_SCALE  g_fOne
#define OO_Z32_FRAC_SCALE g_fOoNearTwoPow31
#define Z32_SHIFT       31
#define Z32_SCALE       g_fNearTwoPow31
#define OO_Z32_SCALE    g_fOoNearTwoPow31

#define TEX_LIMIT       g_fTwoPow31
#define C_TEX_LIMIT     0x4f000000
#define TEX_SHIFT       20
#define TEX_SCALE       g_fTwoPow20
#define OO_TEX_SCALE    g_fOoTwoPow20

#define COLOR_LIMIT     g_fTwoPow15
#define C_COLOR_LIMIT   0x47000000
#define COLOR_SHIFT     8
#define COLOR_SCALE     g_fTwoPow8

#define INDEX_COLOR_LIMIT   g_fTwoPow30
#define C_INDEX_COLOR_LIMIT 0x4e800000
#define INDEX_COLOR_SHIFT   16
#define INDEX_COLOR_SCALE   g_fTwoPow16
#define INDEX_COLOR_VERTEX_SHIFT 8
// Shift to go from fixed-point value in vertex color to proper shift.
#define INDEX_COLOR_FIXED_SHIFT (INDEX_COLOR_SHIFT - INDEX_COLOR_VERTEX_SHIFT)

#define LOD_LIMIT       g_fTwoPow15
#define C_LOD_LIMIT     0x47000000
#define LOD_SHIFT       11
#define LOD_SCALE       g_fTwoPow11
#define LOD_MIN         (-15)

#define OOW_LIMIT       g_fTwoPow31
#define C_OOW_LIMIT     0x4f000000
#define OOW_SHIFT       31
#define OOW_SCALE       g_fNearTwoPow31
#define OO_OOW_SCALE    g_fOoNearTwoPow31
#define W_SHIFT         16
#define W_SCALE         g_fTwoPow16
#define OO_W_SCALE      g_fOoTwoPow16
#define OOW_W_SHIFT     (OOW_SHIFT + W_SHIFT)
#define OOW_W_SCALE     g_fTwoPow47

#define FOG_LIMIT       g_fTwoPow15
#define C_FOG_LIMIT     0x47000000
#define FOG_SHIFT       8
#define FOG_SCALE       g_fTwoPow8
#define FOG_ONE_SCALE   g_fTwoPow16
#define FOG_255_SCALE   g_fTwoPow8

#define TEX_FINAL_SHIFT 16
#define TEX_FINAL_FRAC_MASK (0xffff)
#define TEX_TO_FINAL_SHIFT (TEX_SHIFT - TEX_FINAL_SHIFT)
// Multiply with span W so that [U|V]oW times resulting W is in the
// final shift position.  1 / (W_SHIFT + TEX_TO_FINAL_SHIFT).
#define TEX_UVW_TO_FINAL_SCALE g_fOoTwoPow20
// Divide by span OoW so that [U|V]oW times resulting W is in the
// final shift position.  OOW_SHIFT - TEX_TO_FINAL_SHIFT.
#define TEX_OOW_TO_FINAL_SCALE g_fTwoPow27

#define RAST_DIRTYBITS_SIZE     ((D3DHAL_MAX_RSTATES_AND_STAGES >> 3) + 1)

/*
 * Macro to compute D3DRENDERSTATE offset for a particular per-stage state.
 * It's moved here after texture3 removal.
 */
#define D3DHAL_TSS_OFFSET( _Stage, _State ) \
    ((D3DRENDERSTATETYPE) \
     (D3DHAL_TSS_RENDERSTATEBASE + \
      ((_Stage) * D3DHAL_TSS_STATESPERSTAGE) + (_State)))

/*
 * Convenience texture map offsets for stages.
 */
#define D3DHAL_TSS_TEXTUREMAP0  D3DHAL_TSS_OFFSET(0, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP1  D3DHAL_TSS_OFFSET(1, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP2  D3DHAL_TSS_OFFSET(2, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP3  D3DHAL_TSS_OFFSET(3, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP4  D3DHAL_TSS_OFFSET(4, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP5  D3DHAL_TSS_OFFSET(5, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP6  D3DHAL_TSS_OFFSET(6, D3DTSS_TEXTUREMAP)
#define D3DHAL_TSS_TEXTUREMAP7  D3DHAL_TSS_OFFSET(7, D3DTSS_TEXTUREMAP)

// General per span data.  This structure is designed to be qword aligned.
typedef struct tagD3DI_RASTSPAN
{
    // Space separated things are quad words and are intended to be
    // quad word aligned.
    UINT16 uPix;            // count of pixels to render
    INT16 iDFog;            // 1.7.8 delta fog
    UINT16 uX;              // 16.0 start X
    UINT16 uY;              // 16.0 start Y

    INT16 iLOD;             // 1.4.11 start LOD
    INT16 iDLOD;            // 1.4.11 delta LOD (so piecewise linear LOD interp
                            //                  is possible)
    union
    {
        UINT32 uZ;          // 16.15 start Z
        FLOAT fZ;
    };

    // If texture stuff (iOoW, iUoW1, etc.) is 32 bits (even if we iterate
    // them at 16 bits under MMX sometimes)
    union
    {
        INT32 iW;           // 1.15.16 first inverted W of span
        FLOAT fW;
    };
    union
    {
        INT32 iOoW;         // 1.31 start 1/W (signed since they are target
                            //                 of MMX multiply)
        FLOAT fOoW;
    };

    union
    {
        INT32 iUoW1;        // 1.11.20 first texture coordinates
        FLOAT fUoW1;
    };
    union
    {
        INT32 iVoW1;        // 1.11.20 first texture coordinates
        FLOAT fVoW1;
    };

    union
    {
        struct
        {
            UINT16 uB, uG, uR, uA;  // 8.8 start colors
        };
        struct
        {
            INT32 iIdx, iIdxA;      // 1.8.16 ramp start color and alpha
        };
    };

    UINT16 uBS, uGS, uRS;  // 8.8 start specular colors
    // Specular alpha is fog.  This prevents specular color from
    // being unioned with the texture 2 coordinates below.
    UINT16 uFog;           // 1.7.8 start fog value

    union
    {
        INT32 iUoW2;    // 1.11.20 second texture coordinates
        FLOAT fUoW2;
    };
    union
    {
        INT32 iVoW2;    // 1.11.20 second texture coordinates
        FLOAT fVoW2;
    };

    // Pointers into surface and Z buffers interpolated by the edge walker.
    PUINT8 pSurface;
    PUINT8 pZ;

#ifdef _IA64_
    UINT8 Padding[24];
#endif // _IA64_

} D3DI_RASTSPAN, *PD3DI_RASTSPAN;   // sizeof(D3DI_RASTSPAN) == 64
typedef CONST D3DI_RASTSPAN *PCD3DI_RASTSPAN;

// D3DI_RASTPRIM uFlags
#define D3DI_RASTPRIM_X_DEC     (0x00000001L)   // Else X increments.

// General per primitive for edge walking and span scanning.
// Can be expanded to suit the edge walker.
// The information the span rasterizer needs is sensitive to qwords for
// the MMX rasterizers.
typedef struct tagD3DI_RASTPRIM
{
    UINT32 uFlags;
    UINT16 uSpans;              // count of spans
    UINT16 uResvd1;             // perhaps we want to expand uSpans to 32 bits,
                                // or perhaps 16 flag bits are enough

    // X gradients
    union
    {
        INT32 iDZDX;            // 1.16.15
        FLOAT fDZDX;
    };
    union
    {
        INT32 iDOoWDX;          // 1.31
        FLOAT fDOoWDX;
    };

    union
    {
        INT32 iDUoW1DX;         // 1.11.20
        FLOAT fDUoW1DX;
    };
    union
    {
        INT32 iDVoW1DX;         // 1.11.20
        FLOAT fDVoW1DX;
    };

    union
    {
        struct
        {
            INT16 iDBDX, iDGDX, iDRDX, iDADX;   // 1.7.8
        };
        struct
        {
            FLOAT fDBDX, fDGDX, fDRDX, fDADX;
        };
        struct
        {
            INT32 iDIdxDX, iDIdxADX;            // 1.8.16
        };
    };

    struct
    {
        union
        {
            struct
            {
                INT16 iDBSDX, iDGSDX, iDRSDX; // 1.7.8
            };
            struct
            {
                FLOAT fDBSDX, fDGSDX, fDRSDX;
                FLOAT fPad; // Padding to keep this set of attributes
                            // an even multiple of quadwords.
            };
        };
    };

    struct
    {
        union
        {
            INT32 iDUoW2DX; // 1.11.20
            FLOAT fDUoW2DX;
        };
        union
        {
            INT32 iDVoW2DX; // 1.11.20
            FLOAT fDVoW2DX;
        };
    };

    // Y gradients for some attributes so that span routines
    // can do per-pixel mipmapping.
    union
    {
        INT32 iDUoW1DY; // 1.11.20
        FLOAT fDUoW1DY;
    };
    union
    {
        INT32 iDVoW1DY; // 1.11.20
        FLOAT fDVoW1DY;
    };

    union
    {
        INT32 iDUoW2DY; // 1.11.20
        FLOAT fDUoW2DY;
    };
    union
    {
        INT32 iDVoW2DY; // 1.11.20
        FLOAT fDVoW2DY;
    };

    union
    {
        INT32 iDOoWDY;          // 1.31
        FLOAT fDOoWDY;
    };

    struct tagD3DI_RASTPRIM *pNext;

    // Pad to an even multiple of 32 bytes for cache alignment.
    DWORD uPad[2];

    // Anything else needed

#ifdef _IA64_
    UINT8 Padding[28];
#endif // _IA64_

} D3DI_RASTPRIM, *PD3DI_RASTPRIM;
typedef CONST D3DI_RASTPRIM *PCD3DI_RASTPRIM;

// D3DI_SPANTEX uFlags
#define D3DI_SPANTEX_HAS_TRANSPARENT    (0x00000001L)
#define D3DI_SPANTEX_SURFACES_LOCKED    (0x00000002L)
#define D3DI_SPANTEX_MAXMIPLEVELS_DIRTY (0x00000004L)
// Palette with alpha
#define D3DI_SPANTEX_ALPHAPALETTE       (0x00000008L)
#define D3DI_SPANTEX_NON_POWER_OF_2     (0x00000010L)

//  D3DI_SPANTEX uFormat - NOTE: these enumerations match the sequence in the
//  array of DDPIXELFORMAT structures defined for matching in texture creation
//
//  NOTE: these must be kept consistent with the RRPixelFormats for the reference rasterizer
typedef enum _D3DI_SPANTEX_FORMAT
{
    D3DI_SPTFMT_NULL     = 0,
    D3DI_SPTFMT_B8G8R8   = 1,
    D3DI_SPTFMT_B8G8R8A8 = 2,
    D3DI_SPTFMT_B8G8R8X8 = 3,
    D3DI_SPTFMT_B5G6R5   = 4,
    D3DI_SPTFMT_B5G5R5   = 5,
    D3DI_SPTFMT_PALETTE4 = 6,
    D3DI_SPTFMT_PALETTE8 = 7,
    D3DI_SPTFMT_B5G5R5A1 = 8,
    D3DI_SPTFMT_B4G4R4   = 9,
    D3DI_SPTFMT_B4G4R4A4 =10,
    D3DI_SPTFMT_L8       =11,       /* 8 bit luminance-only */
    D3DI_SPTFMT_L8A8     =12,       /* 16 bit alpha-luminance */
    D3DI_SPTFMT_U8V8     =13,       /* 16 bit bump map format */
    D3DI_SPTFMT_U5V5L6   =14,       /* 16 bit bump map format with luminance */
    D3DI_SPTFMT_U8V8L8   =15,       /* 24 bit bump map format with luminance */

    D3DI_SPTFMT_UYVY     =16,       /* UYVY format for PC98 compliance */
    D3DI_SPTFMT_YUY2     =17,       /* YUY2 format for PC98 compliance */
    D3DI_SPTFMT_DXT1    =18,       /* S3 texture compression technique 1 */
    D3DI_SPTFMT_DXT2    =19,       /* S3 texture compression technique 2 */
    D3DI_SPTFMT_DXT3    =20,       /* S3 texture compression technique 3 */
    D3DI_SPTFMT_DXT4    =21,       /* S3 texture compression technique 4 */
    D3DI_SPTFMT_DXT5    =22,       /* S3 texture compression technique 5 */
    D3DI_SPTFMT_B2G3R3   =23,       /* 8 bit RGB texture format */

    D3DI_SPTFMT_Z16S0    =32,
    D3DI_SPTFMT_Z24S8    =33,
    D3DI_SPTFMT_Z15S1    =34,
    D3DI_SPTFMT_Z32S0    =35,

    D3DI_SPTFMT_FORCE_DWORD = 0x7fffffff, /* force 32-bit size enum */
} D3DI_SPANTEX_FORMAT;


// This encompasses all needed info about a chain of DD surfaces being used
// as a potentially mipmapped texture.
#define SPANTEX_MAXCLOD   11        // up to 2kx2k texture, all we can do with MMX INT16
                                    // U's and V's
typedef struct tagD3DI_SPANTEX
{
    UINT32  dwSize;

    INT32   iGeneration;            // incremented when the texture changes
    UINT32  uFlags;                 // perspective, etc.
    D3DI_SPANTEX_FORMAT  Format;    // pixel format of the texture
    D3DTEXTUREADDRESS TexAddrU, TexAddrV; // texture address mode
    D3DTEXTUREMAGFILTER  uMagFilter;// TEX3 style filter information
    D3DTEXTUREMINFILTER  uMinFilter;// ATTENTION we could express this information more compactly
    D3DTEXTUREMIPFILTER  uMipFilter;
    D3DCOLOR BorderColor;           // border color for the texture
                                    // (for D3DTADDRESS_BORDER)
    D3DCOLOR TransparentColor;      // color key on texture read

    FLOAT fLODBias;                 // Texture3 LOD bias value.

    PUINT8  pBits[SPANTEX_MAXCLOD]; // pointer for each LOD
#if (SPANTEX_MAXCLOD & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT16   iPitchPad;
#endif
    PUINT32 pRampmap;               // set by ramp rasterizer, if necessary
    PUINT32 pPalette;               // pointer to palette, if necessary
    INT32   iPaletteSize;           // size of palette
    INT32   cLOD;                   // contains count of levels - 1 (0 means 1 level)
                                    // to use
    INT32   cLODTex;                // contains count of levels - 1 (0 means 1 level)
                                    // that are actually in the texture
                                    // cLODTex >= cLOD is always true
    INT32   iMaxMipLevel;           // index of largest mip map to use.  0 means use largest.
    INT     iMaxScaledLOD;          // ((cLOD + 1) scaled by LOD_SCALE) - 1.
    INT16   iSizeU, iSizeV;         // LOD 0 size (only support power of 2
                                    // textures)
    INT16   iShiftU, iShiftV;       // LOD 0 log2 size (valid for power-of-2
                                    // size only)
    INT16   iShiftPitch[SPANTEX_MAXCLOD]; // log2 pitch for each LOD
    UINT16  uMaskU, uMaskV;         // LOD 0 (1<<log2(size))-1
    // Variables for arithmetic address computation.  Computed by DoTexAddrSetup.
    INT16   iFlipMaskU, iFlipMaskV;
    INT16   iClampMinU, iClampMinV;
    INT16   iClampMaxU, iClampMaxV;
    INT16   iClampEnU, iClampEnV;

    LPDIRECTDRAWSURFACE pSurf[SPANTEX_MAXCLOD]; // Added for TextureGetSurf
                                                // and Lock/Unlock Texture

} D3DI_SPANTEX, *PD3DI_SPANTEX;

// Color structure for blending etc. with enough room for 8.8 colors.
// Even for 8 bit colors, this is convenient for lining up the colors
// as we desire in MMX for 16 bit multiplies
typedef struct tagD3DI_RASTCOLOR
{
    UINT16 uB, uG, uR, uA;
} D3DI_RASTCOLOR, *PD3DI_RASTCOLOR;

// This structure has all the temporary storage needed for all the iterated
// values to route the span information between the layers.
// TBD there is lots more to add here, do texture mapping first
typedef struct tagD3DI_SPANITER
{
    // make the colors use the same order as RASTCOLOR above
    UINT16 uBB, uBG, uBR, uBA;  // 8.8 blended color
    UINT16 uFogB, uFogG, uFogR, uFog;   // 8.8 fog color, 0.16 fog value
    INT16  iFogBDX, iFogGDX, iFogRDX, iDFog;  // 1.7.8 fog color deltas
    UINT32 uZDeferred;          // storage for Z for deferred Z write
    union
    {
        INT32 iU1;           // 1.15.16
        FLOAT fU1;
    };
    union
    {
        INT32 iV1;           // 1.15.16
        FLOAT fV1;
    };
    union
    {
        INT32 iU2;           // 1.15.16
        FLOAT fU2;
    };
    union
    {
        INT32 iV2;           // 1.15.16
        FLOAT fV2;
    };
    D3DCOLOR    TexCol[2];  // [Texture]
    INT32 iDW;              // to remember last delta W in
    UINT16 uDitherOffset;
    INT16  iXStep;          // 1 or -1
    INT16 iSpecialW;        // negative for first or last 3 pixels of span
    INT16 bStencilPass;     // 1 if stencil test passed, otherwise 0
    union
    {
        INT32 iOoW;         // previous OoW to pass between texaddr stages
        FLOAT fOoW;
    };
} D3DI_SPANITER, *PD3DI_SPANITER;

// Z compare macro
// This does depend on the result of a compare being 0 or 1 (for the final XOR, since C
// doesn't have a logical XOR), but this has been true on all processors and
// compilers for some time.
#define ZCMP16(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Assumes the most significant bit of Z is 0 (31 bit Z)
#define ZCMP32(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iZAndMask) - (p)->iZNeg) >= 0) ^ (p)->iZXorMask)

// Alpha Test compare macro
#define ACMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iAAndMask) - (p)->iANeg) >= 0) ^ (p)->iAXorMask)

// Stencil Test compare macro
#define SCMP(p, g, b)  \
((((((INT32)(g) - (INT32)(b)) & (p)->iSAndMask) - (p)->iSNeg) >= 0) ^ (p)->iSXorMask)


// Helper macro that converts [0, 0xff] to [0, 5], linearly
#define RGB8_CHANNEL(rgb)   ((((rgb) * 5) + 0x80) >> 8)

// Defines conversion from 24 bit RGB to 8 bit palette index.  Each color has 6 values
// resulting in 6**3 == 216 required colors in the palette.
#define MAKE_RGB8(r, g, b) (RGB8_CHANNEL(r) * 36       \
                 + RGB8_CHANNEL(g) * 6                 \
                 + RGB8_CHANNEL(b))

// forward declaration of D3DI_RASTCTX
struct tagD3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX          D3DI_RASTCTX;
typedef struct tagD3DI_RASTCTX         *PD3DI_RASTCTX;
typedef CONST struct tagD3DI_RASTCTX   *PCD3DI_RASTCTX;

// typedef for old ramp assembly monolithics
typedef void (CDECL *PFNRAMPOLD)(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins,
              D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

// typedef for entry point for old ramp assembly monolithics
typedef HRESULT (CDECL *PFNRAMPOLDTRI)(PD3DI_RASTCTX pCtx,
                   LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2);

// typedef for each rendering layer
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef void (CDECL *PFNSPANLAYER)(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                                   PD3DI_RASTSPAN pS);

// typedef texture read functions
// this is an actual function so it can be called multiple times
// note that the RASTCTX is changed because of the D3DI_SPANITER values
typedef D3DCOLOR (CDECL *PFNTEXREAD)(INT32 iU, INT32 iV, INT32 iShiftU,
                                     PUINT8 pBits, PD3DI_SPANTEX pTex);

// Typedef for span rendering function pointers.
typedef HRESULT (CDECL *PFNRENDERSPANS)(PD3DI_RASTCTX pCtx);

// typedef for alpha blending functions.
typedef void (CDECL *PFNBLENDFUNC)(PUINT16 pR, PUINT16 pG, PUINT16 pB,
                                   PUINT16 pA, D3DCOLOR DestC,
                                   PD3DI_RASTCTX pCtx);

// typedef for buffer read functions.
typedef D3DCOLOR (CDECL *PFNBUFREAD)(PUINT8 pBits);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDGET)(PD3DI_RASTCOLOR pArg1,
                                     PD3DI_RASTCOLOR pArg2,
                                     PD3DI_RASTCOLOR pInput,
                                     PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                     INT32 iTex);

// typedef for texture blend get functions.
typedef void (CDECL *PFNTEXBLENDOP)(PD3DI_RASTCOLOR pOut,
                                    PD3DI_RASTCOLOR pArg1,
                                    PD3DI_RASTCOLOR pArg2,
                                    PD3DI_RASTCTX pCtx, PD3DI_RASTSPAN pS,
                                    INT32 iTex);

// Prototype for set of bead selections.
typedef enum tagD3DI_BEADSET
{
    D3DIBS_CMMX = 1,        // C emulation of MMX beads
    D3DIBS_MMX = 2,         // MMX beads
    D3DIBS_C = 3,           // C beads
    D3DIBS_RAMP = 4,        // Ramp beads
    D3DIBS_MMXASRGB = 5,    // MMX selected for RGB rasterizer
} D3DI_BEADSET;

typedef struct tagD3DI_FILLPARAMS
{
    DWORD   dwWrapU;
    DWORD   dwWrapV;
    DWORD   dwCullCCW;
    DWORD   dwCullCW;
} D3DI_FILLPARAMS, *PD3DI_FILLPARAMS;

// General span scanning context
struct tagD3DI_RASTCTX
{
    UINT32   dwSize;

    //////////////////////////////////////////////////////////////////////
    // Temporary storage for span rendering routines.  Could be global.
    // Not set by caller, and not changed by SpanInit.
    //

    D3DI_SPANITER SI;

    //////////////////////////////////////////////////////////////////////
    // Data that must be set by caller before a SpanInit.
    //

    // we may want to put a pointer to a DDSURFACEDESC or something like it
    // instead of this
    PUINT8 pSurfaceBits;
    INT iSurfaceStride;
    INT iSurfaceStep;
    INT iSurfaceBitCount;
    INT iSurfaceType;     // or however we end up expressing this
    PUINT32 pRampMap;     // pointer to ramp map, if necessary
    LPDIRECTDRAWSURFACE pDDS;

    PUINT8 pZBits;
    INT iZStride;
    INT iZStep;
    INT iZBitCount;
    LPDIRECTDRAWSURFACE pDDSZ;

    // Clip area.
    RECT Clip;

    // Sign of face area that should be culled.  Zero is clockwise,
    // one is CCW and everything else means no culling.
    UINT uCullFaceSign;

    union
    {
        DWORD pdwRenderState[D3DHAL_MAX_RSTATES_AND_STAGES];
        FLOAT pfRenderState[D3DHAL_MAX_RSTATES_AND_STAGES];
    };

    // Since we are adjusting the order of texIdx in the vertex to suit that
    // defined in state TEXCOORDINDEX, we need a copy of adjusted WRAP state.
    // This is declared immediately after pdwRenderState so that we can share
    // a register with it in the assembly code.
    // WARNING WARNING - THIS ABSOLUTELY NEEDS TO BE FOLLOWING pdwRenderState
    // IMMEDIATELY. ASM CODE DEPENDS ON THIS.
    DWORD pdwWrap[2];

    // first texture object contains information for texture for first pair
    // of texture coordinates, second contains texture for second pair of
    // texture coordinates, etc.
    PD3DI_SPANTEX pTexture[2];
    // Number of active textures. 0 - texture off; 1 - pTexture[0] is valid
    // 2 - both pTexture[0] and pTexture[1] are valid
    UINT cActTex;

    // Dirty bits for render states.
    // ATTENTION - We can reduce the size  to have one bit for each group of
    // states when we implement the light weighted beed chooser.
    // Right now, it's set by SetRenderState and cleared after SpanInit is
    // called. The bit corresponding to D3DHAL_MAX_RSTATES_AND_STAGES is set
    // whenever a state is changed.
    UINT8 StatesDirtyBits[RAST_DIRTYBITS_SIZE];

#if (RAST_DIRTYBITS_SIZE & 1) != 0
    // Pad following fields to a DWORD boundary.
    INT8   StatesDirtyBitsPad0;
#endif
#if (RAST_DIRTYBITS_SIZE & 2) != 0
    // Pad following fields to a DWORD boundary.
    INT16   StatesDirtyBitsPad1;
#endif

    // Version# of the D3DDevice corresponding to this Context
    UINT32  uDevVer;

    //////////////////////////////////////////////////////////////////////
    // Data is set by SpanInit given the input above.
    //

    // Triangle entry points for old DX5/DX3 style ramp monolithics
    PFNRAMPOLDTRI   pfnRampOldTri;
    PFNRAMPOLD      pfnRampOld;

    // Span rendering entry point.
    PFNRENDERSPANS  pfnRenderSpans;

    // function pointers for the beads
    PFNSPANLAYER    pfnBegin;
    PFNSPANLAYER    pfnLoopEnd;
    PFNSPANLAYER    pfnTestPassEnd;
    PFNSPANLAYER    pfnTestFailEnd;

    PFNSPANLAYER    pfnTex1AddrEnd;
    PFNTEXREAD      pfnTexRead[2];
    PFNSPANLAYER    pfnTex2AddrEnd;
    PFNSPANLAYER    pfnTexBlendEnd;
    PFNTEXBLENDGET  pfnTexBlendGetColor[2];
    PFNTEXBLENDGET  pfnTexBlendGetAlpha[2];
    PFNTEXBLENDOP   pfnTexBlendOpColor[2];
    PFNTEXBLENDOP   pfnTexBlendOpAlpha[2];

    PFNSPANLAYER    pfnColorGenEnd;
    PFNSPANLAYER    pfnAlphaTestPassEnd;
    PFNSPANLAYER    pfnAlphaTestFailEnd;
    PFNBLENDFUNC    pfnSrcBlend;
    PFNBLENDFUNC    pfnDestBlend;
    PFNBUFREAD      pfnBufRead;
    PFNSPANLAYER    pfnColorBlendEnd;

    // Optional bead that can be called after every pixel for rasterizers
    // which loop beads rather than returning.
    PFNSPANLAYER    pfnPixelEnd;

    // Optional bead that can be called after every span for rasterizers
    // which loop spans rather than returning.
    PFNSPANLAYER    pfnSpanEnd;

    // arithmetic Z variables
    INT32 iZAndMask, iZNeg, iZXorMask;

    // arithmetic Alpha test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iAAndMask, iANeg, iAXorMask;
    // 8.8 Alpha reference value
    INT32 iARef;

    // arithmetic stencil test variables.  These could be 16 bits, if we ever really want
    // to save space
    INT32 iSAndMask, iSNeg, iSXorMask;

    // Pointer to first RASTPRIM.
    PD3DI_RASTPRIM pPrim;

    // Pointer to next context.
    PD3DI_RASTCTX pNext;

    // Current BeadTable to use
    D3DI_BEADSET BeadSet;

    // Bit 0 set disables ml1, etc.
#define MMX_FP_DISABLE_MASK_NUM 1
    DWORD dwMMXFPDisableMask[MMX_FP_DISABLE_MASK_NUM];

    // RampLightingDriver, should be NULL except for RampRast and 8 bit palettized RGB
    // output surface cases.
    LPVOID pRampDrv;
    // RAMP_RANGE_INFO RampInfo;
    DWORD RampBase;
    DWORD RampSize;
    PUINT32 pTexRampMap;
    BOOL bRampSpecular;

    PD3DI_FILLPARAMS pFillParams;
    D3DI_FILLPARAMS FillParams;

    DWORD uFlags;   // misc. flags

#ifdef DBG
#define NAME_LEN    128
    char    szTest[NAME_LEN];
    char    szTestFail[NAME_LEN];
    char    szTex1Addr[NAME_LEN];
    char    szTexRead[2][NAME_LEN];
    char    szTex2Addr[NAME_LEN];
    char    szTexBlend[NAME_LEN];
    char    szColorGen[NAME_LEN];
    char    szAlphaTest[NAME_LEN];
    char    szColorBlend[NAME_LEN];
    char    szSrcBlend[NAME_LEN];
    char    szDestBlend[NAME_LEN];
    char    szBufRead[NAME_LEN];
    char    szBufWrite[NAME_LEN];
#undef  NAME_LEN
#endif
};

#define RASTCTXFLAGS_APPHACK_MSGOLF 0x00000001

// Data passed to the span rendering functions looks like this:
//
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   |   RASTSPAN (as many as RASTPRIM.uSpans says there are)
// |   RASTPRIM
// |   |   RASTSPAN
// |   NULL
// RASTCTX
// |-> RASTPRIM
// |   |   RASTSPAN
// |   NULL
// NULL
//
// The given RASTCTX is the head of a list of contexts.  Each context
// points to a list of RASTPRIMs.  Each RASTPRIM structure is immediately
// followed by RASTPRIM.uSpans RASTSPAN structures.

// Prototype for state validation call.
HRESULT SpanInit(PD3DI_RASTCTX pCtx);

// This is used to pack a FVF vertex into one understand by OptRast so it
// does not need to figure out where to get the data it needs. This struct
// can be modified to accommodate more data and it can be broken into more
// specilized and smalled structs.
// Right now, it is an extension of D3DTLVERTEX, and the extra uv is at the
// very end so that OptRast can treat it as a D3DTLVERTEX if only the first
// part of the data needs to be accessed.
typedef struct _RAST_GENERIC_VERTEX {
    union {
    D3DVALUE    sx;             /* Screen coordinates */
    D3DVALUE    dvSX;
    };
    union {
    D3DVALUE    sy;
    D3DVALUE    dvSY;
    };
    union {
    D3DVALUE    sz;
    D3DVALUE    dvSZ;
    };
    union {
    D3DVALUE    rhw;            /* Reciprocal of homogeneous w */
    D3DVALUE    dvRHW;
    };
    union {
    D3DCOLOR    color;          /* Vertex color */
    D3DCOLOR    dcColor;
    };
    union {
    D3DCOLOR    specular;       /* Specular component of vertex */
    D3DCOLOR    dcSpecular;
    };
    union {
    D3DVALUE    tu;             /* Texture coordinates */
    D3DVALUE    dvTU;
    };
    union {
    D3DVALUE    tv;
    D3DVALUE    dvTV;
    };
    union {
    D3DVALUE    tu2;            /* second Texture coordinates */
    D3DVALUE    dvTU2;
    };
    union {
    D3DVALUE    tv2;
    D3DVALUE    dvTV2;
    };
}RAST_GENERIC_VERTEX, *PRAST_GENERIC_VERTEX;

// Vertex types supported by OptRast
typedef enum _RAST_VERTEX_TYPE
{
    RAST_TLVERTEX       = 1,    /* (Legacy) TL vertex */
    RAST_GENVERTEX      = 2,    /* Generic FVF vertex */
    RAST_FORCE_DWORD    = 0x7fffffff, /* force 32-bit size enum */
}RAST_VERTEX_TYPE;

#include <poppack.h>

//-----------------------------------------------------------------------------
//
// Surface types for rendering surfaces and textures.  Different subsets are
// supported for render targets and for textures.
//
//-----------------------------------------------------------------------------
typedef enum _RRSurfaceType
{
    RR_STYPE_NULL     = 0,
    RR_STYPE_B8G8R8   = 1,
    RR_STYPE_B8G8R8A8 = 2,
    RR_STYPE_B8G8R8X8 = 3,
    RR_STYPE_B5G6R5   = 4,
    RR_STYPE_B5G5R5   = 5,
    RR_STYPE_PALETTE4 = 6,
    RR_STYPE_PALETTE8 = 7,
    RR_STYPE_B5G5R5A1 = 8,
    RR_STYPE_B4G4R4   = 9,
    RR_STYPE_B4G4R4A4 =10,
    RR_STYPE_L8       =11,          // 8 bit luminance-only
    RR_STYPE_L8A8     =12,          // 16 bit alpha-luminance
    RR_STYPE_U8V8     =13,          // 16 bit bump map format
    RR_STYPE_U5V5L6   =14,          // 16 bit bump map format with luminance
    RR_STYPE_U8V8L8   =15,          // 24 bit bump map format with luminance
    RR_STYPE_UYVY     =16,          // UYVY format (PC98 compliance)
    RR_STYPE_YUY2     =17,          // YUY2 format (PC98 compliance)
    RR_STYPE_DXT1    =18,          // S3 texture compression technique 1
    RR_STYPE_DXT2    =19,          // S3 texture compression technique 2
    RR_STYPE_DXT3    =20,          // S3 texture compression technique 3
    RR_STYPE_DXT4    =21,          // S3 texture compression technique 4
    RR_STYPE_DXT5    =22,          // S3 texture compression technique 5
    RR_STYPE_B2G3R3   =23,          // 8 bit RGB texture format

    RR_STYPE_Z16S0    =32,
    RR_STYPE_Z24S8    =33,
    RR_STYPE_Z15S1    =34,
    RR_STYPE_Z32S0    =35,

} RRSurfaceType;

#ifdef __cplusplus
}
#endif

#endif // _SPAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\clipper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.c
 *  Content:    Clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "clipper.h"
#include "d3dfei.h"

#define GET_NEW_CLIP_VERTEX \
&pv->ClipperState.clip_vertices[pv->ClipperState.clip_vertices_used++];
//---------------------------------------------------------------------
int SetInterpolationFlags(D3DFE_PROCESSVERTICES *pv)
{
    // Figure out which pieces need to be interpolated in new vertices.
    int interpolate = 0;
    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD) 
    {
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            interpolate |= INTERPOLATE_RCOLOR;
        }
        else
        {
            interpolate |= INTERPOLATE_COLOR;
            if (pv->lpdwRStates[D3DRENDERSTATE_SPECULARENABLE] ||
                pv->lpdwRStates[D3DRENDERSTATE_FOGENABLE]) 
            {
                interpolate |= INTERPOLATE_SPECULAR;
            }
        }
    }
    if (pv->dwDeviceFlags & D3DDEV_LEGACYTEXTURE) 
    {
        interpolate |= INTERPOLATE_TEXTUREL;
    }
    else
    for(DWORD i = 0; i < pv->dwMaxTextureIndices; ++i)
    {
        if(pv->pD3DMappedTexI[i])
        {
            interpolate |= INTERPOLATE_TEXTURE3;
            return interpolate;
        } 
    }
    return interpolate;
}
//---------------------------------------------------------------------
__inline void 
InterpolateColor(ClipVertex *p,
                 ClipVertex *p1,
                 ClipVertex *p2,
                 D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->color);
    g1 = RGBA_GETGREEN(p1->color);
    b1 = RGBA_GETBLUE(p1->color);
    a1 = RGBA_GETALPHA(p1->color);
    r2 = RGBA_GETRED(p2->color);
    g2 = RGBA_GETGREEN(p2->color);
    b2 = RGBA_GETBLUE(p2->color);
    a2 = RGBA_GETALPHA(p2->color);
    p->color = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                         (WORD)(g1 + (g2 - g1) * num_denom),
                         (WORD)(b1 + (b2 - b1) * num_denom),
                         (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
void InterpolateRampColor(ClipVertex* p,
                          ClipVertex* p1,
                          ClipVertex* p2,
                          D3DVALUE num_denom )
{
    int a, c, c1, c2;
    int a1, a2;

    c1 = CI_MASKALPHA(p1->color);
    a1 = CI_GETALPHA(p1->color);
    c2 = CI_MASKALPHA(p2->color);
    a2 = CI_GETALPHA(p2->color);

    c = (int)(c1 + (c2 - c1) * num_denom);
    a = (int)(a1 + (a2 - a1) * num_denom);

    p->color = CI_MAKE( a, CI_GETINDEX(c), CI_GETFRACTION(c) );
}
//---------------------------------------------------------------------
__inline void
InterpolateSpecular(ClipVertex *p,
                    ClipVertex *p1,
                    ClipVertex *p2,
                    D3DVALUE num_denom )
{
    int r1, g1, b1, a1;
    int r2, g2, b2, a2;

    r1 = RGBA_GETRED(p1->specular);
    g1 = RGBA_GETGREEN(p1->specular);
    b1 = RGBA_GETBLUE(p1->specular);
    a1 = RGBA_GETALPHA(p1->specular);
    r2 = RGBA_GETRED(p2->specular);
    g2 = RGBA_GETGREEN(p2->specular);
    b2 = RGBA_GETBLUE(p2->specular);
    a2 = RGBA_GETALPHA(p2->specular);
    p->specular = RGBA_MAKE((WORD)(r1 + (r2 - r1) * num_denom),
                            (WORD)(g1 + (g2 - g1) * num_denom),
                            (WORD)(b1 + (b2 - b1) * num_denom),
                            (WORD)(a1 + (a2 - a1) * num_denom));
}
//---------------------------------------------------------------------
__inline D3DVALUE
InterpolateTexture(D3DVALUE t1, 
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if (!bWrap)
        return ((t2 - t1) * num_denom + t1);
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if (t > 1.0f)
            t -= 1.0f;
        return t;
    }
}
//---------------------------------------------------------------------
void
Interpolate(D3DFE_PROCESSVERTICES *pv,
            ClipVertex *p, 
            ClipVertex *p1,
            ClipVertex *p2,
            int code,
            int interpolate,
            D3DVALUE num, D3DVALUE denom)
{
    D3DVALUE num_denom = num / denom;

    p->clip = (((int)p1->clip & (int)p2->clip) & ~CLIPPED_ENABLE) | code;
    p->hx = p1->hx + (p2->hx - p1->hx) * num_denom;
    p->hy = p1->hy + (p2->hy - p1->hy) * num_denom;
    p->hz = p1->hz + (p2->hz - p1->hz) * num_denom;
    p->hw = p1->hw + (p2->hw - p1->hw) * num_denom;
    p->color = pv->ClipperState.clip_color;
    p->specular = pv->ClipperState.clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if (interpolate & INTERPOLATE_COLOR) 
    {
        InterpolateColor(p, p1, p2, num_denom);
    } 
    else 
        if (interpolate & INTERPOLATE_RCOLOR) 
        {
            InterpolateRampColor(p, p1, p2, num_denom);
        }

    if (interpolate & INTERPOLATE_SPECULAR) 
    {
        InterpolateSpecular(p, p1, p2, num_denom);
    }

    if (interpolate & INTERPOLATE_TEXTUREL) 
    {
        p->tex[0].u = InterpolateTexture(p1->tex[0].u, p2->tex[0].u, 
                                         num_denom,
                                         pv->lpdwRStates[D3DRENDERSTATE_WRAPU]); 
        p->tex[0].v = InterpolateTexture(p1->tex[0].v, p2->tex[0].v, 
                                         num_denom,
                                         pv->lpdwRStates[D3DRENDERSTATE_WRAPV]); 
    }
    else
    if (interpolate & INTERPOLATE_TEXTURE3) 
    {
        // Assume that D3DRENDERSTATE_WRAPi are sequential
        for (DWORD i = 0; i < pv->nTexCoord; i++)
        {
            DWORD wrapState = pv->lpdwRStates[D3DRENDERSTATE_WRAP0 + i];
            p->tex[i].u = InterpolateTexture(p1->tex[i].u, p2->tex[i].u,
                                             num_denom, wrapState & D3DWRAP_U);
            p->tex[i].v = InterpolateTexture(p1->tex[i].v, p2->tex[i].v, 
                                             num_denom, wrapState & D3DWRAP_V);
        }
    }
}
//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD hz
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD hz
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD hx
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD hx
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD hy
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD hy
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void ComputeScreenCoordinates(D3DFE_PROCESSVERTICES *pv, 
                              ClipVertex **inv, 
                              int count, D3DRECTV *extent)
{
    int i;
    BOOL updateExtent = !(pv->dwFlags & D3DDP_DONOTUPDATEEXTENTS);
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;

    for (i = 0; i < count; i++) 
    {
        ClipVertex *p;
        p = inv[i];

        /*
         * Catch any vertices that need screen co-ordinates generated.
         * There are two possibilities
         * 	1) Vertices generated during interpolation
         *	2) Vertices marked for clipping by the transform but
         *		not clipped here due to the finite precision
         *		of the floating point unit.
         */

        if (p->clip & ~CLIPPED_ENABLE) 
        {
            D3DVALUE w;

            w = D3DVAL(1.0)/p->hw;
            switch ((int)p->clip & (CLIPPED_LEFT|CLIPPED_RIGHT)) 
            {
            case CLIPPED_LEFT:  p->sx = VPORT.minXgb; break;
            case CLIPPED_RIGHT: p->sx = VPORT.maxXgb; break;
            default:   
                p->sx = p->hx * VPORT.scaleX * w + VPORT.offsetX;
				if (p->sx < VPORT.minXgb)
					p->sx = VPORT.minXgb;
				if (p->sx > VPORT.maxXgb)
					p->sx = VPORT.maxXgb;
            }
            switch ((int)p->clip & (CLIPPED_TOP|CLIPPED_BOTTOM)) 
            {
            case CLIPPED_BOTTOM: p->sy = VPORT.maxYgb; break;
            case CLIPPED_TOP:    p->sy = VPORT.minYgb; break;
            default:
                p->sy = p->hy * VPORT.scaleY * w + VPORT.offsetY;
				if (p->sy < VPORT.minYgb)
					p->sy = VPORT.minYgb;
				if (p->sy > VPORT.maxYgb)
					p->sy = VPORT.maxYgb;
            }
            p->sz = p->hz * w;
            if (updateExtent)
            {
                if (p->sx < extent->x1)
                    extent->x1 = p->sx;
                if (p->sy < extent->y1)
                    extent->y1 = p->sy;
                if (p->sx  > extent->x2)
                    extent->x2 = p->sx;
                if (p->sy > extent->y2)
                    extent->y2 = p->sy;
            }
        }
    }
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCodeGB(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (p->hx < p->hw * pv->vcache.Kgbx1)
        clip |= __D3DCLIPGB_LEFT;
    if (p->hx > p->hw * pv->vcache.Kgbx2)
        clip |= __D3DCLIPGB_RIGHT;
    if (p->hy < p->hw * pv->vcache.Kgby1)
        clip |= __D3DCLIPGB_BOTTOM;
    if (p->hy > p->hw * pv->vcache.Kgby2)
        clip |= __D3DCLIPGB_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//---------------------------------------------------------------------
inline DWORD ComputeClipCode(D3DFE_PROCESSVERTICES *pv, ClipVertex *p)
{
    DWORD clip = 0;
    if (FLOAT_LTZ(p->hx))
        clip |= D3DCLIP_LEFT;
    if (p->hx > p->hw)
        clip |= D3DCLIP_RIGHT;
    if (FLOAT_LTZ(p->hy))
        clip |= D3DCLIP_BOTTOM;
    if (p->hy > p->hw)
        clip |= D3DCLIP_TOP;
    if (p->hz > p->hw)
        clip |= D3DCLIP_BACK;
    p->clip = (p->clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}
//***********************************************************************
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleTriangle"

int D3DFE_PVFUNCS::ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                                      ClipTriangle *tri,
                                      ClipVertex ***clipVertexPointer,
                                      int interpolate)
{
    int accept;
    int i;
    int count;
    ClipVertex **inv;
    ClipVertex **outv;
    ClipVertex *p;
    ULONG_PTR swapv;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = tri->v[0]->color;        
        D3DCOLOR specular = tri->v[0]->specular;        
        tri->v[1]->color= diffuse;
        tri->v[1]->specular = specular;
        tri->v[2]->color = diffuse;
        tri->v[2]->specular = specular;
    }
    accept = (tri->v[0]->clip | tri->v[1]->clip | tri->v[2]->clip);

    inv = tri->v;

    if (tri->flags & D3DTRIFLAG_EDGEENABLE1)
        tri->v[0]->clip |= CLIPPED_ENABLE;
    if (tri->flags & D3DTRIFLAG_EDGEENABLE2)
        tri->v[1]->clip |= CLIPPED_ENABLE;
    if (tri->flags & D3DTRIFLAG_EDGEENABLE3)
        tri->v[2]->clip |= CLIPPED_ENABLE;

    count = 3;
    outv = pv->ClipperState.clip_vbuf1;
    pv->ClipperState.clip_color = tri->v[0]->color;
    pv->ClipperState.clip_specular = tri->v[0]->specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)pv->ClipperState.clip_vbuf1;
        tmp2 = (ULONG_PTR)pv->ClipperState.clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    pv->ClipperState.clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (ClipVertex**) (swapv - (ULONG_PTR) outv)

    if (accept & D3DCLIP_FRONT) 
    {
        count = ClipFront(pv, inv, outv, count, interpolate);
        if (count < 3)
            goto out_of_here;
        SWAP(inv, outv);
    }
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            accept = 0;
            for (i = 0; i < count; i++) 
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & CLIPPED_FRONT)
                    accept |= ComputeClipCodeGB(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK) 
        {
            count = ClipBack(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_LEFT) 
        {
            count = ClipLeftGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_RIGHT) 
        {
            count = ClipRightGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_BOTTOM) 
        {
            count = ClipBottomGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & __D3DCLIPGB_TOP) 
        {
            count = ClipTopGB(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            accept = 0;
            for (i = 0; i < count; i++) 
            {
                ClipVertex *p;
                p = inv[i];
                if (p->clip & (CLIPPED_FRONT))
                    accept |= ComputeClipCode(pv, p);
                else
                    accept |= p->clip;
            }
        }
        if (accept & D3DCLIP_BACK) 
        {
            count = ClipBack(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_LEFT) 
        {
            count = ClipLeft(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_RIGHT) 
        {
            count = ClipRight(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_BOTTOM) 
        {
            count = ClipBottom(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
        if (accept & D3DCLIP_TOP) 
        {
            count = ClipTop(pv, inv, outv, count, interpolate);
            if (count < 3)
                goto out_of_here;
            SWAP(inv, outv);
        }
    }

#undef SWAP

    ComputeScreenCoordinates(pv, inv, count, &pv->rExtents);

    *clipVertexPointer = inv;
    pv->ClipperState.current_vbuf = inv;
    return count;
out_of_here:
    *clipVertexPointer = NULL;
    return 0;
}
//*************************************************************************
//
#undef DPF_MODNAME
#define DPF_MODNAME "ClipSingleLine"

int
ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
               ClipTriangle *line,
               D3DRECTV *extent,
               int interpolate)
{
    int         accept;
    D3DVALUE    in1, in2;

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    accept = (line->v[0]->clip | line->v[1]->clip);

    pv->ClipperState.clip_color = line->v[0]->color;
    pv->ClipperState.clip_specular = line->v[0]->specular;

    if (accept & D3DCLIP_FRONT) 
        if (ClipLineFront(pv, line, interpolate))
            goto out_of_here;
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCodeGB(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK) 
            if (ClipLineBack(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_LEFT) 
            if (ClipLineLeftGB(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_RIGHT) 
            if (ClipLineRightGB(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_TOP) 
            if (ClipLineTopGB(pv, line, interpolate))
                goto out_of_here;
        if (accept & __D3DCLIPGB_BOTTOM) 
            if (ClipLineBottomGB(pv, line, interpolate))
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if (accept & D3DCLIP_FRONT) 
        {
            ClipVertex * p;
            accept = 0;
            p = line->v[0];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
            p = line->v[1];
            if (p->clip & CLIPPED_FRONT)
                accept |= ComputeClipCode(pv, p);
            else
                accept |= p->clip;
        }
        if (accept & D3DCLIP_BACK) 
            if (ClipLineBack(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_LEFT) 
            if (ClipLineLeft(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_RIGHT) 
            if (ClipLineRight(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_TOP) 
            if (ClipLineTop(pv, line, interpolate))
                goto out_of_here;
        if (accept & D3DCLIP_BOTTOM) 
            if (ClipLineBottom(pv, line, interpolate))
                goto out_of_here;
    }

    ComputeScreenCoordinates(pv, line->v, 2, extent);

    return 1;
out_of_here:
    return 0;
} // ClipSingleLine
//----------------------------------------------------------------------
//    GenClipFlags()  Generates clip flags for a set of FVF 
//
#undef DPF_MODNAME
#define DPF_MODNAME "GenClipFlags"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv)
{
    DWORD clip_intersection, clip_union;
    float left   = pv->vcache.minX;
    float top    = pv->vcache.minY;
    float right  = pv->vcache.maxX;
    float bottom = pv->vcache.maxY;
    float leftgb  ;         // Guard band window
    float topgb   ;
    float rightgb ;
    float bottomgb;
    DWORD clipZF, clipZB;
    DWORD stride = pv->position.dwStride;

    clipZF = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_FRONT : 0;
    clipZB = pv->lpdwRStates[D3DRENDERSTATE_ZENABLE] ? D3DCLIP_BACK : 0;

    clip_intersection = (DWORD)~0;
    clip_union = (DWORD)0;

    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        leftgb   = pv->vcache.minXgb;
        topgb    = pv->vcache.minYgb;
        rightgb  = pv->vcache.maxXgb;
        bottomgb = pv->vcache.maxYgb;
    }
    if (pv->dwFlags & D3DDP_DONOTUPDATEEXTENTS)
    { /* Only generate clip flags */
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        DWORD i;
        for (i = pv->dwNumVertices; i; i--) 
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left) 
                clip |= D3DCLIP_LEFT;
            else 
            if (x >= right) 
                clip |= D3DCLIP_RIGHT;

            if (y < top) 
                clip |= D3DCLIP_TOP;
            else 
            if (y >= bottom) 
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f) 
                clip |= clipZF;
            else 
            if (z >= 1.0f) 
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb) 
                    clip |= __D3DCLIPGB_LEFT;
                else 
                if (x >= rightgb) 
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb) 
                    clip |= __D3DCLIPGB_TOP;
                else 
                if (y >= bottomgb) 
                    clip |= __D3DCLIPGB_BOTTOM;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
    } 
    else
    { /* Generate Clip Flags and Update Extents */
        DWORD i;
        float minx = pv->rExtents.x1;
        float miny = pv->rExtents.y1;
        float maxx = pv->rExtents.x2;
        float maxy = pv->rExtents.y2;
        D3DTLVERTEX *lpVertices = (D3DTLVERTEX*)pv->position.lpvData;
        D3DFE_CLIPCODE *clipCode = pv->lpClipFlags;
        for (i = pv->dwNumVertices; i; i--) 
        {
            DWORD clip = 0;
            D3DVALUE x,y,z;
            if (lpVertices->rhw < 0)
            {
                x = -lpVertices->sx;
                y = -lpVertices->sy;
                z = -lpVertices->sz;
            }
            else
            {
                x = lpVertices->sx;
                y = lpVertices->sy;
                z = lpVertices->sz;
            }

            if (x < left)
                clip |= D3DCLIP_LEFT;
            else 
            if (x >= right)
                clip |= D3DCLIP_RIGHT;

            if (y < top)
                clip |= D3DCLIP_TOP;
            else 
            if (y >= bottom)
                clip |= D3DCLIP_BOTTOM;

            if (z < 0.0f)
                clip |= clipZF;
            else 
            if (z >= 1.0f)
                clip |= clipZB;

            if (pv->dwDeviceFlags & D3DDEV_GUARDBAND && clip)
            {
                if (x < leftgb) 
                    clip |= __D3DCLIPGB_LEFT;
                else 
                if (x >= rightgb) 
                    clip |= __D3DCLIPGB_RIGHT;

                if (y < topgb) 
                    clip |= __D3DCLIPGB_TOP;
                else 
                if (y >= bottomgb) 
                    clip |= __D3DCLIPGB_BOTTOM;
            }
            // Update extents only if the vertex is inside
            if (clip == 0 || 
                ((pv->dwDeviceFlags & D3DDEV_GUARDBAND) && 
                 ((clip & ~__D3DCLIP_INGUARDBAND) == 0)))
            {
                if (x < minx)
                    minx = x;
                if (x > maxx)
                    maxx = x;
                if (y < miny)
                    miny = y;
                if (y > maxy)
                    maxy = y;
            }

            clip_intersection &= clip;
            clip_union |= clip;
            *clipCode++ = (D3DFE_CLIPCODE)clip;
            lpVertices = (D3DTLVERTEX*)((char*)lpVertices + stride);
        }
        pv->rExtents.x1 = minx;
        pv->rExtents.y1 = miny;
        pv->rExtents.x2 = maxx;
        pv->rExtents.y2 = maxy;
    }

    pv->dwClipIntersection = clip_intersection;
    pv->dwClipUnion = clip_union;

    return clip_intersection;
}   // end of GenClipFlags()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\haltrans.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   haltrans.cpp
 *  Content:    Direct3D HAL transform handler
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Update pre-computed constants related to viewport
//
// This functions should be called every time the viewport parameters are
// changed
//
// Notes:
//      1. scaleY and offsetY are computed to flip Y axes from up to down.
//      2. Mclip matrix is computed multiplied by Mshift matrix
//
const D3DVALUE SMALL_NUMBER = 0.000001f;

void UpdateViewportCache(LPDIRECT3DDEVICEI device, D3DVIEWPORT2 *data)
{
    // Bail if we are going to cause any divide by zero exceptions.
    // The likely reason is that we have a bogus viewport set by
    // TLVertex execute buffer app.
    if(data->dwWidth == 0 ||
        data->dwHeight == 0 ||
        FLOAT_EQZ(data->dvClipWidth) ||
        FLOAT_EQZ(data->dvClipHeight) ||
        data->dvMaxZ - data->dvMinZ == D3DVAL(0.f))
        return;
    D3DFE_VIEWPORTCACHE *cache = &device->vcache;
    cache->dvX = D3DVAL(data->dwX);
    cache->dvY = D3DVAL(data->dwY);
    cache->dvWidth = D3DVAL(data->dwWidth);
    cache->dvHeight = D3DVAL(data->dwHeight);
    cache->mclip11 = D3DVAL(1.0) / data->dvClipWidth;
    cache->mclip41 = - cache->mclip11 * data->dvClipX;
    cache->mclip22 = D3DVAL(1) / data->dvClipHeight;
    cache->mclip42 = D3DVAL(1) - cache->mclip22 * data->dvClipY;
    cache->mclip33 = D3DVAL(1) / (data->dvMaxZ - data->dvMinZ);
    cache->mclip43 = - data->dvMinZ * cache->mclip33;
    cache->scaleX  = cache->dvWidth;
    cache->scaleY  = - cache->dvHeight;
    cache->offsetX = cache->dvX;
    cache->offsetY = cache->dvY + cache->dvHeight;
    // Small offset is added to prevent generation of negative screen
    // coordinates (this could happen because of precision errors).
    // Not needed (or wanted) for devices which do guardband.
    if (IS_HW_DEVICE(device))
    {
        cache->offsetX += SMALL_NUMBER;
        cache->offsetY += SMALL_NUMBER;
    }
    device->dwFEFlags |= D3DFE_VIEWPORT_DIRTY | D3DFE_INVERSEMCLIP_DIRTY;
    cache->scaleXi = D3DVAL(1) / cache->scaleX;
    cache->scaleYi = D3DVAL(1) / cache->scaleY;
    cache->minX = cache->dvX;
    cache->maxX = cache->dvX + cache->dvWidth;
    cache->minY = cache->dvY;
    cache->maxY = cache->dvY + cache->dvHeight;
    cache->minXi = FTOI(cache->minX);
    cache->maxXi = FTOI(cache->maxX);
    cache->minYi = FTOI(cache->minY);
    cache->maxYi = FTOI(cache->maxY);
    if (device->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        LPD3DHAL_D3DEXTENDEDCAPS lpCaps = device->lpD3DExtendedCaps;

        // Because we clip by guard band window we have to use its extents
        cache->minXgb = lpCaps->dvGuardBandLeft;
        cache->maxXgb = lpCaps->dvGuardBandRight;
        cache->minYgb = lpCaps->dvGuardBandTop;
        cache->maxYgb = lpCaps->dvGuardBandBottom;

        D3DVALUE w = 2.0f / cache->dvWidth;
        D3DVALUE h = 2.0f / cache->dvHeight;
        D3DVALUE ax1 = -lpCaps->dvGuardBandLeft   * w + 1.0f;
        D3DVALUE ax2 =  lpCaps->dvGuardBandRight  * w - 1.0f;
        D3DVALUE ay1 =  lpCaps->dvGuardBandBottom * h - 1.0f;
        D3DVALUE ay2 = -lpCaps->dvGuardBandTop * h + 1.0f;
        cache->gb11 = 2.0f / (ax1 + ax2);
        cache->gb41 = cache->gb11 * (ax1 - 1.0f) * 0.5f;
        cache->gb22 = 2.0f / (ay1 + ay2);
        cache->gb42 = cache->gb22 * (ay1 - 1.0f) * 0.5f;

        cache->Kgbx1 = 0.5f * (1.0f - ax1);
        cache->Kgbx2 = 0.5f * (1.0f + ax2);
        cache->Kgby1 = 0.5f * (1.0f - ay1);
        cache->Kgby2 = 0.5f * (1.0f + ay2);
    }
    else
    {
        cache->minXgb = cache->minX;
        cache->maxXgb = cache->maxX;
        cache->minYgb = cache->minY;
        cache->maxYgb = cache->maxY;
    }
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixCreate(LPDIRECT3DDEVICEI lpDevI, LPD3DMATRIXHANDLE lphMat)
{
    LPD3DMATRIXI lpMat;
    HRESULT ret;

    if ((ret = D3DMalloc((void**)&lpMat, sizeof(D3DMATRIXI))) != DD_OK)
    {
        return ret;
    }

    setIdentity(lpMat);

    LIST_INSERT_ROOT(&lpDevI->transform.matrices, lpMat, link);
    *lphMat = (DWORD)((ULONG_PTR)lpMat);

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixDestroy(LPDIRECT3DDEVICEI lpDevI, D3DMATRIXHANDLE hMat)
{
    LPD3DMATRIXI lpMat = (LPD3DMATRIXI)ULongToPtr(hMat);
    LIST_DELETE(lpMat, link);
    D3DFree(lpMat);

    return D3D_OK;
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixSetData(LPDIRECT3DDEVICEI lpDevI, D3DMATRIXHANDLE hMat,
                     LPD3DMATRIX lpMat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;

    LPD3DMATRIXI lpDstMat;

    lpDstMat = HANDLE_TO_MAT(lpDevI, hMat);

    if (!lpDstMat)
    {
        return D3DERR_MATRIX_SETDATA_FAILED;
    }

    *(D3DMATRIX*)lpDstMat = *lpMat;

    if (hMat == TRANSFORM.hWorld)
        D3DFE_SetMatrixWorld(lpDevI, lpMat);
    else
        if (hMat == TRANSFORM.hView)
            D3DFE_SetMatrixView(lpDevI, lpMat);
        else
            if (hMat == TRANSFORM.hProj)
                D3DFE_SetMatrixProj(lpDevI, lpMat);

    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT
D3DHAL_MatrixGetData(LPDIRECT3DDEVICEI lpDevI, D3DMATRIXHANDLE hMat,
                     LPD3DMATRIX lpMat)
{
    LPD3DMATRIXI lpSrcMat = HANDLE_TO_MAT(lpDevI, hMat);

    if (!lpSrcMat)
        return D3DERR_MATRIX_GETDATA_FAILED;

    *lpMat = *(D3DMATRIX*)lpSrcMat;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\helxfrm.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       helxfrm.c
 *  Content:    Direct3D front-end transform and process vertices
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"

void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b);

D3DFE_PVFUNCS GeometryFuncsGuaranteed; // Our implementation

DWORD   debugFlags = 0;

void SetDebugRenderState(DWORD value)
{
    debugFlags = value;
}
//---------------------------------------------------------------------
void setIdentity(D3DMATRIXI * m)
{
    m->type = D3DIMatrixIdentity;

    m->_11 = D3DVAL(1.0); m->_12 = D3DVAL(0.0); m->_13 = D3DVAL(0.0); m->_14 = D3DVAL(0.0);
    m->_21 = D3DVAL(0.0); m->_22 = D3DVAL(1.0); m->_23 = D3DVAL(0.0); m->_24 = D3DVAL(0.0);
    m->_31 = D3DVAL(0.0); m->_32 = D3DVAL(0.0); m->_33 = D3DVAL(1.0); m->_34 = D3DVAL(0.0);
    m->_41 = D3DVAL(0.0); m->_42 = D3DVAL(0.0); m->_43 = D3DVAL(0.0); m->_44 = D3DVAL(1.0);
}
//---------------------------------------------------------------------
HRESULT D3DFE_InitTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM *transform = &lpDevI->transform;

    LIST_INITIALIZE(&transform->matrices);

    lpDevI->rExtents.x1 = 0;
    lpDevI->rExtents.y1 = 0;
    lpDevI->rExtents.x2 = 0;
    lpDevI->rExtents.y2 = 0;

    setIdentity(&lpDevI->mCTM);
    setIdentity(&transform->proj);
    setIdentity(&transform->world);
    setIdentity(&transform->view);

    STATESET_INIT(lpDevI->transformstate_overrides);

    return (D3D_OK);
}
//---------------------------------------------------------------------
void D3DFE_DestroyTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM *transform = &lpDevI->transform;

    while (LIST_FIRST(&transform->matrices)) {
        LPD3DMATRIXI lpMat;
        lpMat = LIST_FIRST(&transform->matrices);
        LIST_DELETE(lpMat, link);
        D3DFree(lpMat);
    }
}
//---------------------------------------------------------------------
/*
 * Combine all matrices.
 */
void updateTransform(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_VIEWPORTCACHE& VPORT = lpDevI->vcache;
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    if (lpDevI->dwFEFlags & (D3DFE_VIEWPORT_DIRTY | D3DFE_PROJMATRIX_DIRTY))
    { // Update Mproj*Mclip
        if (lpDevI->dwFEFlags & D3DFE_PROJ_PERSPECTIVE)
        {
            TRANSFORM.mPC._11 = TRANSFORM.proj._11*VPORT.mclip11;
            TRANSFORM.mPC._12 = D3DVAL(0);
            TRANSFORM.mPC._13 = D3DVAL(0);
            TRANSFORM.mPC._14 = D3DVAL(0);
            TRANSFORM.mPC._21 = D3DVAL(0);
            TRANSFORM.mPC._22 = TRANSFORM.proj._22*VPORT.mclip22;
            TRANSFORM.mPC._23 = D3DVAL(0);
            TRANSFORM.mPC._24 = D3DVAL(0);
            TRANSFORM.mPC._31 = VPORT.mclip41;
            TRANSFORM.mPC._32 = VPORT.mclip42;
            TRANSFORM.mPC._33 = TRANSFORM.proj._33*VPORT.mclip33 +
                TRANSFORM.proj._34*VPORT.mclip43;
            TRANSFORM.mPC._34 = D3DVAL(1);
            TRANSFORM.mPC._41 = TRANSFORM.proj._41*VPORT.mclip11;
            TRANSFORM.mPC._42 = TRANSFORM.proj._42*VPORT.mclip22;
            TRANSFORM.mPC._43 = TRANSFORM.proj._43*VPORT.mclip33;
            TRANSFORM.mPC._44 = TRANSFORM.proj._44;
        }
        else
        {
            TRANSFORM.mPC._11 = TRANSFORM.proj._11*VPORT.mclip11 +
                TRANSFORM.proj._14*VPORT.mclip41;
            TRANSFORM.mPC._12 = TRANSFORM.proj._12*VPORT.mclip22 +
                TRANSFORM.proj._14*VPORT.mclip42;
            TRANSFORM.mPC._13 = TRANSFORM.proj._13*VPORT.mclip33 +
                TRANSFORM.proj._14*VPORT.mclip43;
            TRANSFORM.mPC._14 = TRANSFORM.proj._14;
            TRANSFORM.mPC._21 = TRANSFORM.proj._21*VPORT.mclip11 +
                TRANSFORM.proj._24*VPORT.mclip41;
            TRANSFORM.mPC._22 = TRANSFORM.proj._22*VPORT.mclip22 +
                TRANSFORM.proj._24*VPORT.mclip42;
            TRANSFORM.mPC._23 = TRANSFORM.proj._23*VPORT.mclip33 +
                TRANSFORM.proj._24*VPORT.mclip43;
            TRANSFORM.mPC._24 = TRANSFORM.proj._24;
            TRANSFORM.mPC._31 = TRANSFORM.proj._31*VPORT.mclip11 +
                TRANSFORM.proj._34*VPORT.mclip41;
            TRANSFORM.mPC._32 = TRANSFORM.proj._32*VPORT.mclip22 +
                TRANSFORM.proj._34*VPORT.mclip42;
            TRANSFORM.mPC._33 = TRANSFORM.proj._33*VPORT.mclip33 +
                TRANSFORM.proj._34*VPORT.mclip43;
            TRANSFORM.mPC._34 = TRANSFORM.proj._34;
            TRANSFORM.mPC._41 = TRANSFORM.proj._41*VPORT.mclip11 +
                TRANSFORM.proj._44*VPORT.mclip41;
            TRANSFORM.mPC._42 = TRANSFORM.proj._42*VPORT.mclip22 +
                TRANSFORM.proj._44*VPORT.mclip42;
            TRANSFORM.mPC._43 = TRANSFORM.proj._43*VPORT.mclip33 +
                TRANSFORM.proj._44*VPORT.mclip43;
            TRANSFORM.mPC._44 = TRANSFORM.proj._44;
        }
    }
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_VIEWPORT_DIRTY |
                             D3DFE_PROJMATRIX_DIRTY))
    { // Update Mview*Mproj*Mclip
        MatrixProduct(&TRANSFORM.mVPC, &TRANSFORM.view, &TRANSFORM.mPC);
    }

    MatrixProduct(&lpDevI->mCTM, &TRANSFORM.world, &TRANSFORM.mVPC);

    if ((lpDevI->dwFEFlags & (D3DFE_AFFINE_WORLD | D3DFE_AFFINE_VIEW)) ==
        (D3DFE_AFFINE_WORLD | D3DFE_AFFINE_VIEW))
        lpDevI->dwFEFlags |= D3DFE_AFFINE_WORLD_VIEW;
    else
        lpDevI->dwFEFlags &= ~D3DFE_AFFINE_WORLD_VIEW;

    // Set dirty bit for world*view matrix (needed for fog)
    if (lpDevI->dwFEFlags & (D3DFE_VIEWMATRIX_DIRTY |
                             D3DFE_WORLDMATRIX_DIRTY))
        lpDevI->dwFEFlags |= D3DFE_WORLDVIEWMATRIX_DIRTY;
    // All matrices are set up
    lpDevI->dwFEFlags &= ~D3DFE_TRANSFORM_DIRTY;
    // Set dirty bit for lighting
    lpDevI->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS |
                         D3DFE_INVERSEMCLIP_DIRTY |
                         D3DFE_FRUSTUMPLANES_DIRTY;
    lpDevI->dwFlags |= D3DPV_TRANSFORMDIRTY;
    lpDevI->dwDeviceFlags |= D3DDEV_TRANSFORMDIRTY;
}
//---------------------------------------------------------------------
void UpdateMatrixProj(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    lpDevI->dwFEFlags &= ~D3DFE_PROJ_PERSPECTIVE;
    if (FLOAT_EQZ(TRANSFORM.proj._12) &&
        FLOAT_EQZ(TRANSFORM.proj._13) &&
        FLOAT_EQZ(TRANSFORM.proj._14) &&
        FLOAT_EQZ(TRANSFORM.proj._21) &&
        FLOAT_EQZ(TRANSFORM.proj._23) &&
        FLOAT_EQZ(TRANSFORM.proj._24) &&
        FLOAT_EQZ(TRANSFORM.proj._31) &&
        FLOAT_EQZ(TRANSFORM.proj._32) &&
        FLOAT_CMP_PONE(TRANSFORM.proj._34, ==))
    {
        lpDevI->dwFEFlags |= D3DFE_PROJ_PERSPECTIVE;
    }
    lpDevI->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY;
}
//---------------------------------------------------------------------
void UpdateMatrixView(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    lpDevI->dwFEFlags &= ~D3DFE_AFFINE_VIEW;
    if (FLOAT_EQZ(TRANSFORM.view._14) &&
        FLOAT_EQZ(TRANSFORM.view._24) &&
        FLOAT_EQZ(TRANSFORM.view._34) &&
        FLOAT_CMP_PONE(TRANSFORM.view._44, ==))
    {
        lpDevI->dwFEFlags |= D3DFE_AFFINE_VIEW;
    }
    lpDevI->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY;
}
//---------------------------------------------------------------------
void UpdateMatrixWorld(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    lpDevI->dwFEFlags &= ~D3DFE_AFFINE_WORLD;

    if (FLOAT_EQZ(TRANSFORM.world._14) &&
        FLOAT_EQZ(TRANSFORM.world._24) &&
        FLOAT_EQZ(TRANSFORM.world._34) &&
        FLOAT_CMP_PONE(TRANSFORM.world._44, ==))
    {
        lpDevI->dwFEFlags |= D3DFE_AFFINE_WORLD;
    }
    lpDevI->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY;
}
//---------------------------------------------------------------------
HRESULT D3DFE_SetMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    *(D3DMATRIX*)&TRANSFORM.proj = *mat;
    UpdateMatrixProj(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_SetMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    *(D3DMATRIX*)&TRANSFORM.view = *mat;
    UpdateMatrixView(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_SetMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    *(D3DMATRIX*)&TRANSFORM.world = *mat;
    UpdateMatrixWorld(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_MultMatrixProj(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    MatrixProduct(&TRANSFORM.proj, (D3DMATRIXI*)mat, &TRANSFORM.proj);
    UpdateMatrixProj(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_MultMatrixView(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    MatrixProduct(&TRANSFORM.view, (D3DMATRIXI*)mat, &TRANSFORM.view);
    UpdateMatrixView(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
HRESULT D3DFE_MultMatrixWorld(LPDIRECT3DDEVICEI lpDevI, D3DMATRIX *mat)
{
    D3DFE_TRANSFORM& TRANSFORM = lpDevI->transform;
    MatrixProduct(&TRANSFORM.world, (D3DMATRIXI*)mat, &TRANSFORM.world);
    UpdateMatrixWorld(lpDevI);
    return (D3D_OK);
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIXI *result, D3DMATRIXI *a, D3DMATRIXI *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//--------------------------------------------------------------------------
// Transform vertices for viewport
//
#define _PV_NAME D3DFE_TransformClippedVp
#define _PV_VIEWPORT
#define _PV_CLIP
#define _PV_EXTENT
#include "procver.h"
#undef _PV_NAME
#undef _PV_CLIP
#undef _PV_EXTENT
#undef _PV_VIEWPORT

#define _PV_NAME D3DFE_TransformUnclippedVp
#define _PV_VIEWPORT
#define _PV_EXTENT
#include "procver.h"
#undef _PV_NAME
#undef _PV_EXTENT
#undef _PV_VIEWPORT
//---------------------------------------------------------------------------
void D3DFE_UpdateFog(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    if (LIGHTING.fog_end == LIGHTING.fog_start)
    {
        LIGHTING.fog_factor = D3DVAL(0.0);
        LIGHTING.fog_factor_ramp = D3DVAL(0.0);
    }
    else
    {
        LIGHTING.fog_factor = D3DVAL(255) / (LIGHTING.fog_end - LIGHTING.fog_start);
        if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
            LIGHTING.fog_factor_ramp = D3DVAL(1.0/255.0) * LIGHTING.fog_factor;
    }
    lpDevI->dwFEFlags &= ~D3DFE_FOG_DIRTY;
}
//----------------------------------------------------------------------------
void UpdateXfrmLight(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFEFlags & D3DFE_TRANSFORM_DIRTY)
        updateTransform(lpDevI);

    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
    {
        RAMP_RANGE_INFO rampInfo;
        CallRampService(lpDevI, RAMP_SERVICE_FIND_LIGHTINGRANGE,
                           (ULONG_PTR)&rampInfo, 0);
        lpDevI->dwRampBase  = rampInfo.base;
        lpDevI->dvRampScale = D3DVAL(max(min((INT32)rampInfo.size - 1, 0x7fff), 0));
        lpDevI->lpvRampTexture = rampInfo.pTexRampMap;
        if (rampInfo.specular)
            lpDevI->dwFlags |= D3DPV_RAMPSPECULAR;
        else
            lpDevI->dwFlags &= ~D3DPV_RAMPSPECULAR;
    }

    if ((lpDevI->dwFlags & D3DPV_LIGHTING) &&
        lpDevI->dwFEFlags & (D3DFE_NEED_TRANSFORM_LIGHTS |
                             D3DFE_LIGHTS_DIRTY |
                             D3DFE_MATERIAL_DIRTY))
    {
        D3DFE_UpdateLights(lpDevI);
        lpDevI->dwFlags |= D3DPV_LIGHTSDIRTY;
        lpDevI->dwDeviceFlags |= D3DDEV_LIGHTSDIRTY;
    }

    if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
    {
        lpDevI->dwFlags |= D3DPV_FOG;

        if (lpDevI->rstates[D3DRENDERSTATE_RANGEFOGENABLE])
            lpDevI->dwFlags |= D3DPV_RANGEBASEDFOG;

        if (lpDevI->dwFEFlags & D3DFE_FOG_DIRTY)
            D3DFE_UpdateFog(lpDevI);

        if (lpDevI->dwFEFlags & D3DFE_WORLDVIEWMATRIX_DIRTY)
        {
            MatrixProduct(&lpDevI->mWV, &lpDevI->transform.world,
                                        &lpDevI->transform.view);
            lpDevI->dwFEFlags &= ~D3DFE_WORLDVIEWMATRIX_DIRTY;
        }
    }
}
//---------------------------------------------------------------------
// Convert extents from floating point to integer.
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_ConvertExtent"

void D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to)
{
    to->x1 = FTOI(from->x1) - 1;
    to->y1 = FTOI(from->y1) - 1;
    to->x2 = FTOI(from->x2) + 1;
    to->y2 = FTOI(from->y2) + 1;
    if (to->x1 < lpDevI->vcache.minXi)
        to->x1 = lpDevI->vcache.minXi;
    if (to->y1 < lpDevI->vcache.minYi)
        to->y1 = lpDevI->vcache.minYi;
    if (to->x2 > lpDevI->vcache.maxXi)
        to->x2 = lpDevI->vcache.maxXi;
    if (to->y2 > lpDevI->vcache.maxYi)
        to->y2 = lpDevI->vcache.maxYi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\pch.cpp ===
#include "ddrawpr.h"
#include <windows.h>
#include <assert.h>
#include <math.h>
#include "d3dpr.hpp"
#include "haldrv.hpp"
#include "fltval.h"
#include "d3dfei.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\rgblt.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   rgblt.cpp
 *  Content:    Direct3D lighting
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "light.h"
#include "drawprim.hpp"

extern "C"
{
void Directional2(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void PointSpot2(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void Directional1C(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void PointSpot1C(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in);
void PointSpotXCRamp(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in);

//#define _USE_ASM_
#ifdef _X86_
#ifdef _USE_ASM_

void Directional2P5S(LPD3DFE_PROCESSVERTICES pv,
                     D3DI_LIGHT *light,
                     D3DLIGHTINGELEMENT *in);
void Directional2P5(LPD3DFE_PROCESSVERTICES pv,
                    D3DI_LIGHT *light,
                    D3DLIGHTINGELEMENT *in);

#endif _X86_
#endif _USE_ASM_
}

static LIGHT_VERTEX_FUNC_TABLE lightVertexTable =
{
    Directional1C,
    Directional2,
    PointSpot1C,
    PointSpot2,
    PointSpot1C,
    PointSpot2
};

HRESULT D3DFE_InitRGBLighting(LPDIRECT3DDEVICEI lpDevI)
{
    LIST_INITIALIZE(&lpDevI->specular_tables);
    lpDevI->specular_table = NULL;

    LIST_INITIALIZE(&lpDevI->materials);

    STATESET_INIT(lpDevI->lightstate_overrides);
    lpDevI->lightVertexFuncTable = &lightVertexTable;

    lpDevI->lighting.activeLights = NULL;

    return (D3D_OK);
}

void D3DFE_DestroyRGBLighting(LPDIRECT3DDEVICEI lpDevI)
{
    SpecularTable *spec;
    SpecularTable *spec_next;

    for (spec = LIST_FIRST(&lpDevI->specular_tables); spec; spec = spec_next)
    {
        spec_next = LIST_NEXT(spec,list);
        D3DFree(spec);
    }

    while (LIST_FIRST(&lpDevI->materials))
    {
        LPD3DFE_MATERIAL lpMat;
        lpMat = LIST_FIRST(&lpDevI->materials);
        LIST_DELETE(lpMat, link);
        D3DFree(lpMat);
    }
}

HRESULT D3DHEL_ApplyFog(D3DFE_LIGHTING* driver, int count, D3DLIGHTDATA* data)
{
    D3DTLVERTEX *v;
    size_t v_size;
    D3DVALUE fog_start = driver->fog_start;
    D3DVALUE fog_end = driver->fog_end;
    D3DVALUE fog_length = RLDDIFInvert16(fog_end - fog_start);
    int i;

    v = (D3DTLVERTEX*)data->lpOut;
    v_size = data->dwOutSize;

    for (i = count; i; i--)
    {
        D3DVALUE w;
        int f;
        if ((v->rhw < D3DVAL(1)) &&  (v->rhw > 0))
            w = RLDDIFInvert24(v->rhw);
        else
            w = v->rhw;
        if (w < fog_start)
            f = 255;
        else if (w >= fog_end)
            f = 0;
        else
            f = VALTOFXP(DECPREC(RLDDIFMul16(fog_end - w, fog_length), 8), 8);
        if (f > 255) f = 255;
        if (f < 0) f = 0;
        v->specular = RGBA_SETALPHA(v->specular, f);
        v = (D3DTLVERTEX*)((char*)v + v_size);
    }
    return D3D_OK;
}

static void inverseRotateVector(D3DVECTOR* d,
                                D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

static void inverseTransformVector(D3DVECTOR* d,
                                   D3DVECTOR* v, D3DMATRIXI* M)
{
    D3DVALUE vx = v->x;
    D3DVALUE vy = v->y;
    D3DVALUE vz = v->z;
    vx -= M->_41; vy -= M->_42; vz -= M->_43;
    d->x = RLDDIFMul16(vx, M->_11) + RLDDIFMul16(vy, M->_12) + RLDDIFMul16(vz, M->_13);
    d->y = RLDDIFMul16(vx, M->_21) + RLDDIFMul16(vy, M->_22) + RLDDIFMul16(vz, M->_23);
    d->z = RLDDIFMul16(vx, M->_31) + RLDDIFMul16(vy, M->_32) + RLDDIFMul16(vz, M->_33);
}

/*
 * Every time the world matrix is modified the lighting vectors have to
 * change to match the model space of the new data to be rendered
 */

#define SMALLISH    (1e-2)
#define ONEISH(v)   (fabs(v - 1.0f) < SMALLISH)

static int getMatrixScale(D3DMATRIXI* m, D3DVECTOR* s)
{
    s->x = (m->_11 * m->_11 + m->_12 * m->_12 + m->_13 * m->_13);
    s->y = (m->_21 * m->_21 + m->_22 * m->_22 + m->_23 * m->_23);
    s->z = (m->_31 * m->_31 + m->_32 * m->_32 + m->_33 * m->_33);

    if (ONEISH(s->x) && ONEISH(s->y) && ONEISH(s->z))
        return FALSE;
    else
    {
        s->x = (D3DVALUE)(1.0f / s->x);
        s->y = (D3DVALUE)(1.0f / s->y);
        s->z = (D3DVALUE)(1.0f / s->z);
        return TRUE;
    }
}

static int
getMatrixScale2(D3DMATRIXI *m, D3DVECTOR *s)
{
    float det;

    s->x = (float)sqrt(m->_11*m->_11 + m->_12*m->_12 + m->_13*m->_13);
    s->y = (float)sqrt(m->_21*m->_21 + m->_22*m->_22 + m->_23*m->_23);
    s->z = (float)sqrt(m->_31*m->_31 + m->_32*m->_32 + m->_33*m->_33);

    if (ONEISH(s->x) && ONEISH(s->y) && ONEISH(s->z))
    {
        return FALSE;
    }
    else
    {
        det = m->_11*(m->_22*m->_33 - m->_23*m->_32)
            - m->_12*(m->_21*m->_33 - m->_23*m->_31)
            + m->_13*(m->_21*m->_32 - m->_22*m->_31);

        if (det<0.0)
        {
            s->x = (-s->x);
            s->y = (-s->y);
            s->z = (-s->z);
        }

        // prevent 0 scales from sneaking through
        if (fabs(s->x) < 0.0001)
            s->x = 0.0001f;
        if (fabs(s->y) < 0.0001)
            s->y = 0.0001f;
        if (fabs(s->z) < 0.0001)
            s->z = 0.0001f;

        return TRUE;
    }
}   // end of getMatrixScale2()

//-----------------------------------------------------------------------
// Every time the world matrix is modified or lights data is changed the
// lighting vectors have to change to match the model space of the new data
// to be rendered.
// Every time light data is changed or material data is changed or lighting
// state is changed, some pre-computed lighting values sould be updated
//
void D3DFE_UpdateLights(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    D3DI_LIGHT  *light = LIGHTING.activeLights;
    D3DVECTOR   t;
    D3DMATRIXI  *world;
    D3DMATRIXI  *camera;
    D3DMATERIAL *mat;
    D3DVECTOR   cameraModel;
    D3DVECTOR   cameraWorld;
    D3DVECTOR   cameraModelNorm;        // Normalized
    D3DVECTOR   scale1;
    D3DVECTOR   scale2;
    D3DVECTOR   oneOverScale;
    BOOL        cameraModelNormComputed = FALSE;
    BOOL        scale1Computed = FALSE; // For light 1
    BOOL        scale2Computed = FALSE; // For light 2
    BOOL        need_scale1;
    BOOL        need_scale2;
    BOOL        specular;       // TRUE, if specular component sould be computed


    if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
    {
        D3DVECTOR t;

        world  = &lpDevI->transform.world;
        camera = &lpDevI->transform.view;
        t.x = -camera->_41;
        t.y = -camera->_42;
        t.z = -camera->_43;

        // transform the eye into world coords.
        inverseRotateVector(&cameraWorld, &t, camera);

        // now transform eye into model space
        inverseTransformVector(&cameraModel, &cameraWorld, world);
    }

    if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
    {
        mat = &LIGHTING.material;
        if (lpDevI->specular_table &&
            lpDevI->rstates[D3DRENDERSTATE_SPECULARENABLE])
        {
            specular = TRUE;
            lpDevI->dwFEFlags |= D3DFE_COMPUTESPECULAR;
        }
        else
        {
            specular = FALSE;
            lpDevI->dwFEFlags &= ~D3DFE_COMPUTESPECULAR;
        }

        LIGHTING.materialAlpha = FTOI(D3DVAL(255) * mat->diffuse.a);
        if (LIGHTING.materialAlpha < 0)
            LIGHTING.materialAlpha = 0;
        else
            if (LIGHTING.materialAlpha > 255)
                LIGHTING.materialAlpha = 255 << 24;
            else LIGHTING.materialAlpha <<= 24;

        LIGHTING.currentSpecTable = lpDevI->specular_table->table;

        if (!(lpDevI->dwDeviceFlags & D3DDEV_RAMP))
        {
            LIGHTING.diffuse0.r = LIGHTING.ambient_red   * mat->ambient.r +
                mat->emissive.r * D3DVAL(255);
            LIGHTING.diffuse0.g = LIGHTING.ambient_green * mat->ambient.g +
                mat->emissive.g * D3DVAL(255);
            LIGHTING.diffuse0.b = LIGHTING.ambient_blue  * mat->ambient.b +
                mat->emissive.b * D3DVAL(255);
        }
    }

    while (light)
    {
        if (lpDevI->dwFEFlags & D3DFE_NEED_TRANSFORM_LIGHTS)
        {
            if (light->type != D3DLIGHT_DIRECTIONAL)
            {
                // Transform light position to the model space
                t.x = light->position.x - world->_41;
                t.y = light->position.y - world->_42;
                t.z = light->position.z - world->_43;
                inverseRotateVector(&light->model_position, &t, world);
            }

            if (light->version == 1)
            {
                if (!scale1Computed)
                {
                    need_scale1 = getMatrixScale(world, &scale1);
                    scale1Computed = TRUE;
                }
                if (!need_scale1)
                    light->flags |= D3DLIGHTI_UNIT_SCALE;
                else
                {
                    if (light->type != D3DLIGHT_DIRECTIONAL)
                    {
                        light->model_position.x *= scale1.x;
                        light->model_position.y *= scale1.y;
                        light->model_position.z *= scale1.z;
                    }
                }
            }
            else
            {
                if (!scale2Computed)
                {
                    need_scale2 = getMatrixScale2(world, &scale2);
                    scale2Computed = TRUE;
                }
                if (!need_scale2)
                    light->flags |= D3DLIGHTI_UNIT_SCALE;
                else
                {
                    light->model_scale.x = scale2.x;
                    light->model_scale.y = scale2.y;
                    light->model_scale.z = scale2.z;
                    oneOverScale.x = D3DVAL(1)/scale2.x;
                    oneOverScale.y = D3DVAL(1)/scale2.y;
                    oneOverScale.z = D3DVAL(1)/scale2.z;
                    light->flags &= ~D3DLIGHTI_UNIT_SCALE;
                }
            }

            if (light->type != D3DLIGHT_POINT)
            {
                if (light->type == D3DLIGHT_PARALLELPOINT)
                {
                    light->model_direction = light->model_position;
                }
                else
                {
                    // Transform light direction to the model space
                    inverseRotateVector(&light->model_direction,
                                        &light->direction, world);
                    VecNeg(light->model_direction, light->model_direction);
                }
                if (light->version != 1 && need_scale2)
                {
                    // apply scale here before normalizing
                    light->model_direction.x *= oneOverScale.x;
                    light->model_direction.y *= oneOverScale.y;
                    light->model_direction.z *= oneOverScale.z;
                }
                if (need_scale1 || need_scale2 ||
                    light->type == D3DLIGHT_PARALLELPOINT)
                    VecNormalizeFast(light->model_direction);
            }

            if (light->version == 1)
            {
                if (!cameraModelNormComputed)
                {
                    VecNormalizeFast2(cameraModel, cameraModelNorm);
                    cameraModelNormComputed = TRUE;
                }

                if (light->type == D3DLIGHT_DIRECTIONAL)
                {
                    t = light->model_direction;
                }
                else
                {
                    t = light->model_position;
                }
                // calc halfway vector
                VecNormalizeFast(t);
                VecAdd(t, cameraModelNorm, light->halfway);
                VecNormalizeFast(light->halfway);
            }
            else
            {
                // We want to compare cameraWorld position with the light to
                // see if they match
                if (fabs(light->position.x-cameraWorld.x) < 0.0001 &&
                    fabs(light->position.y-cameraWorld.y) < 0.0001 &&
                    fabs(light->position.z-cameraWorld.z) < 0.0001)
                {
                    light->flags |= D3DLIGHTI_LIGHT_AT_EYE;
                }
                else
                {
                    light->flags &= ~D3DLIGHTI_LIGHT_AT_EYE;
                }

                // store location of eye in model space
                if (light->flags & D3DLIGHTI_UNIT_SCALE)
                {
                    light->model_eye = cameraModel;
                }
                else
                {
                    light->model_eye.x = cameraModel.x * oneOverScale.x;
                    light->model_eye.y = cameraModel.y * oneOverScale.y;
                    light->model_eye.z = cameraModel.z * oneOverScale.z;
                    if (light->type == D3DLIGHT_POINT ||
                        light->type == D3DLIGHT_SPOT)
                    {
                        light->model_position.x *= oneOverScale.x;
                        light->model_position.y *= oneOverScale.y;
                        light->model_position.z *= oneOverScale.z;
                    }
                }
            }
        }

        if (lpDevI->dwFEFlags & (D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY))
        {
            if (!(lpDevI->dwDeviceFlags & D3DDEV_RAMP))
            {
                light->local_diffR = D3DVAL(255) * mat->diffuse.r * light->red;
                light->local_diffG = D3DVAL(255) * mat->diffuse.g * light->green;
                light->local_diffB = D3DVAL(255) * mat->diffuse.b * light->blue;

                light->local_specR = D3DVAL(255) * mat->specular.r * light->red;
                light->local_specG = D3DVAL(255) * mat->specular.g * light->green;
                light->local_specB = D3DVAL(255) * mat->specular.b * light->blue;
            }
            else
            {
                light->local_diffR = light->shade;
                light->local_specR = light->shade;
            }

            if (specular && !(light->flags & D3DLIGHT_NO_SPECULAR))
                light->flags |= D3DLIGHTI_COMPUTE_SPECULAR;
            else
                light->flags &= ~D3DLIGHTI_COMPUTE_SPECULAR;
        }

        if (lpDevI->dwFEFlags & D3DFE_LIGHTS_DIRTY)
        {
            light->lightVertexFunc = NULL;
            if (light->version == 1)
            {
                switch (light->type)
                {
                case D3DLIGHT_PARALLELPOINT:
                case D3DLIGHT_DIRECTIONAL:
                    light->lightVertexFunc =
                        lpDevI->lightVertexFuncTable->directional1;
                    break;
                case D3DLIGHT_POINT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->point1;
                    }
                    break;
                case D3DLIGHT_SPOT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->spot1;
                    }
                    break;
                }
            }
            else
            {
                switch (light->type)
                {
                case D3DLIGHT_PARALLELPOINT:
                case D3DLIGHT_DIRECTIONAL:
                {
#ifdef _X86_
#ifdef _USE_ASM_
                    if (light->flags & D3DLIGHTI_UNIT_SCALE &&
                        !(lpDevI->dwDeviceFlags & D3DDEV_RAMP) &&
                        !(lpDevI->dwFEFlags & D3DFE_COLORVERTEX))
                    {
                        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
                            light->lightVertexFunc = Directional2P5S;
                        else
                            light->lightVertexFunc = Directional2P5;
                    }
                    else
#endif _USE_ASM_
#endif // _X86_
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->directional2;
                    break;
                }
                case D3DLIGHT_POINT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->point2;
                    }
                    break;
                case D3DLIGHT_SPOT:
                    if (lpDevI->dwDeviceFlags & D3DDEV_RAMP)
                    {
                        light->lightVertexFunc = PointSpotXCRamp;
                    }
                    else
                    {
                        light->lightVertexFunc =
                            lpDevI->lightVertexFuncTable->spot2;
                    }
                    break;
                }
            }
        }

        light = light->next;
    }

    lpDevI->dwFEFlags &= ~(D3DFE_MATERIAL_DIRTY |
                    D3DFE_NEED_TRANSFORM_LIGHTS |
                    D3DFE_LIGHTS_DIRTY);
}   // end of updateLights()
//---------------------------------------------------------------------
inline D3DVALUE COMPUTE_DOT_POW(D3DFE_LIGHTING *ldrv, D3DVALUE dot)
{
    ldrv->specularComputed = TRUE;
    if (dot < 1.0f)
    {
        int     indx;
        float   v;
        dot *= 255.0f;
        indx = (int)dot;
        dot -= indx;
        v = ldrv->currentSpecTable[indx];
        return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
    }
    else
        return 1.0f;
}
//---------------------------------------------------------------------
inline void COMPUTE_SPECULAR(LPD3DFE_PROCESSVERTICES pv,
                             D3DVALUE dot,
                             D3DI_LIGHT *light)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))
    {
        D3DVALUE power;
        power = COMPUTE_DOT_POW(&ldrv, dot);
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.specular.r += light->shade * power;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEXS))
        {
            ldrv.specular.r += light->local_specR * power;
            ldrv.specular.g += light->local_specG * power;
            ldrv.specular.b += light->local_specB * power;
        }
        else
        {
            ldrv.specular.r += light->red   * ldrv.vertexSpecular.r * power;
            ldrv.specular.g += light->green * ldrv.vertexSpecular.g * power;
            ldrv.specular.b += light->blue  * ldrv.vertexSpecular.b * power;
        }
    }
}
//---------------------------------------------------------------------
inline void COMPUTE_SPECULAR_ATT(LPD3DFE_PROCESSVERTICES pv,
                                 D3DVALUE dot,
                                 D3DI_LIGHT *light,
                                 D3DVALUE att)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))
    {
        D3DVALUE power;
        power = COMPUTE_DOT_POW(&ldrv, dot);
        power *= att;
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.specular.r += light->shade * power;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEXS))
        {
            ldrv.specular.r += light->local_specR * power;
            ldrv.specular.g += light->local_specG * power;
            ldrv.specular.b += light->local_specB * power;
        }
        else
        {
            ldrv.specular.r += light->red   * ldrv.vertexSpecular.r * power;
            ldrv.specular.g += light->green * ldrv.vertexSpecular.g * power;
            ldrv.specular.b += light->blue  * ldrv.vertexSpecular.b * power;
        }
    }
}
//-------------------------------------------------------------------------
void Directional2(LPD3DFE_PROCESSVERTICES pv,
                  D3DI_LIGHT *light,
                  D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVALUE dot;
    dot = VecDot(light->model_direction, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEX))
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }
        else
        {
            ldrv.diffuse.r += light->red   * ldrv.vertexDiffuse.r * dot;
            ldrv.diffuse.g += light->green * ldrv.vertexDiffuse.g * dot;
            ldrv.diffuse.b += light->blue  * ldrv.vertexDiffuse.b * dot;
        }

        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            D3DVECTOR h;      // halfway vector
            D3DVECTOR eye;    // incident vector ie vector from eye
            // calc incident vector
            if (light->flags & D3DLIGHTI_UNIT_SCALE)
            {
                VecSub(in->dvPosition, light->model_eye, eye);
            }
            else
            {
                // note that model_eye has already been divided by scale
                // in setup
                eye.x = in->dvPosition.x*light->model_scale.x -
                        light->model_eye.x;
                eye.y = in->dvPosition.y*light->model_scale.y -
                        light->model_eye.y;
                eye.z = in->dvPosition.z*light->model_scale.z -
                        light->model_eye.z;
            }
            // normalize
            VecNormalizeFast(eye);

            // calc halfway vector
            VecSub(light->model_direction, eye, h);

            dot = VecDot(h, in->dvNormal);

            if (FLOAT_GTZ(dot))
            {
                dot *= ISQRTF(VecLenSq(h));
                COMPUTE_SPECULAR(pv, dot, light);
            }
        }
    }
}
//-------------------------------------------------------------------------
void PointSpot2(LPD3DFE_PROCESSVERTICES pv,
                D3DI_LIGHT *light,
                D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVALUE dot;
    D3DVALUE dist;  // Distance from light to the vertex
    D3DVALUE dist2;
    D3DVECTOR d;    // Direction to light
    D3DVALUE att;

    if (light->flags & D3DLIGHTI_UNIT_SCALE)
    {
        VecSub(light->model_position, in->dvPosition, d);
    }
    else
    {
        d.x = light->model_position.x - in->dvPosition.x * light->model_scale.x;
        d.y = light->model_position.y - in->dvPosition.y * light->model_scale.y;
        d.z = light->model_position.z - in->dvPosition.z * light->model_scale.z;
    }

    // early out if out of range or exactly on the vertex
    dist2 = d.x*d.x + d.y*d.y + d.z*d.z;
    if (FLOAT_CMP_POS(dist2, >=, light->range_squared) || FLOAT_EQZ(dist2))
        return;

    // Calc dot product of light dir with normal.  Note that since we
    // didn't normalize the direction the result is scaled by the distance.
    dot = VecDot(d, in->dvNormal);

    if (FLOAT_GTZ(dot))
    {
        // ok, so now we actually need the real dist
        dist = SQRTF(dist2);

        // calc attenuation
        att = 0.0f;
        if (light->flags & D3DLIGHTI_ATT0_IS_NONZERO)
        {
            att += light->attenuation0;
        }
        if (light->flags & (D3DLIGHTI_ATT1_IS_NONZERO | D3DLIGHTI_ATT2_IS_NONZERO))
        {
            float att1 = (light->range - dist) / light->range;

            if (light->flags & D3DLIGHTI_ATT1_IS_NONZERO)
            {
                att += light->attenuation1 * att1;
            }
            if (light->flags & D3DLIGHTI_ATT2_IS_NONZERO)
            {
                att += light->attenuation2 * att1 * att1;
            }
        }

        dist = D3DVAL(1)/dist;

        if (light->type == D3DLIGHT_SPOT)
        {
            D3DVALUE cone_dot;
            // Calc dot product of direction to light with light direction to
            // be compared anganst the cone angles to see if we are in the light.
            // Note that cone_dot is still scaled by dist
            cone_dot = VecDot(d, light->model_direction);

            cone_dot*= dist;        // Normalizing
            if (FLOAT_CMP_POS(cone_dot, <=, light->cos_phi_by_2))
                return;

            // modify att if in the region between phi and theta
            if (FLOAT_CMP_POS(cone_dot, <, light->cos_theta_by_2))
            {
                D3DVALUE val;
                val = (cone_dot - light->cos_phi_by_2) * light->inv_theta_minus_phi;
                if (!(light->flags & D3DLIGHTI_LINEAR_FALLOFF))
                {
                    val = POWF(val, light->falloff);
                }
                att *= val;
            }
        }

        dot *= dist*att;

        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        if (!(pv->dwFlags & D3DPV_COLORVERTEX))
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }
        else
        {
            ldrv.diffuse.r += light->red   * ldrv.vertexDiffuse.r * dot;
            ldrv.diffuse.g += light->green * ldrv.vertexDiffuse.g * dot;
            ldrv.diffuse.b += light->blue  * ldrv.vertexDiffuse.b * dot;
        }

        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            D3DVECTOR eye;
            D3DVECTOR h;
            // normalize light direction
            d.x *= dist;
            d.y *= dist;
            d.z *= dist;

            if (light->flags & D3DLIGHTI_LIGHT_AT_EYE)
            {
                h = d;
            }
            else
            {
                // calc incident vector
                if (light->flags & D3DLIGHTI_UNIT_SCALE)
                {
                    VecSub(in->dvPosition, light->model_eye, eye);
                }
                else
                {
                    // note that model_eye has already been divided by scale in setup
                    eye.x = in->dvPosition.x*light->model_scale.x -
                        light->model_eye.x;
                    eye.y = in->dvPosition.y*light->model_scale.y -
                        light->model_eye.y;
                    eye.z = in->dvPosition.z*light->model_scale.z -
                        light->model_eye.z;
                }
                // normalize
                VecNormalizeFast(eye);

                // calc halfway vector
                VecSub(d, eye, h);
                VecNormalizeFast(h);
            }
            dot = VecDot(h, in->dvNormal);

            COMPUTE_SPECULAR_ATT(pv, dot, light, att);
        }
    }
}       // end of Point2()
//-------------------------------------------------------------------------
void Directional1C(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVALUE dot;
    dot = VecDot(light->model_direction, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }
        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            dot = VecDot(light->halfway, in->dvNormal);
            COMPUTE_SPECULAR(pv, dot, light);
        }
    }
}
//-------------------------------------------------------------------------
void PointSpot1C(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVECTOR d;
    D3DVALUE  dot;
    VecSub(light->model_position, in->dvPosition, d);
    dot = VecDot(d, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        D3DVALUE dist2;
        D3DVALUE dist;
        D3DVALUE att;
        D3DVALUE big = D3DVAL(1000);    // if 1/att < 0.001 do not compute color

        dist2 = VecDot(d, d);
        if (FLOAT_EQZ(dist2))
            return;
        dist = SQRTF(dist2);
        att = light->attenuation0 +
              light->attenuation1 * dist +
              light->attenuation2 * dist2;

        if (FLOAT_CMP_POS(att, >, big))
            return;

        if (FLOAT_CMP_PONE(att, >))
            att *= dist;
        else
            att = dist;
        att = D3DVAL(1) / att;
        if (light->type == D3DLIGHT_SPOT)
        {
            D3DVALUE cone_dot;
            // Calc dot product of direction to light with light direction to
            // be compared anganst the cone angles to see if we are in the light.
            // Note that cone_dot is still scaled by dist
            cone_dot = VecDot(d, light->model_direction);
            cone_dot /= dist;

            if (FLOAT_CMP_POS(cone_dot, <=, light->cos_phi_by_2))
                return;

            if (FLOAT_CMP_POS(cone_dot, <, light->cos_theta_by_2))
            {
                att *= D3DVAL(1)-(light->cos_theta_by_2-cone_dot)*light->falloff;
            }
        }

        dot *= att;

        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }

        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            dot = VecDot(light->halfway, in->dvNormal);
            COMPUTE_SPECULAR_ATT(pv, dot, light, att);
        }
    }
}
//-------------------------------------------------------------------------
void PointSpotXCRamp(LPD3DFE_PROCESSVERTICES pv,
                 D3DI_LIGHT *light,
                 D3DLIGHTINGELEMENT *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DVECTOR d;
    D3DVALUE  dot;
    VecSub(light->model_position, in->dvPosition, d);
    dot = VecDot(d, in->dvNormal);
    if (FLOAT_GTZ(dot))
    {
        D3DVALUE dist2;
        D3DVALUE dist;
        D3DVALUE att;
        D3DVALUE big = D3DVAL(1000);    // if 1/att < 0.001 do not compute color

        dist2 = VecDot(d, d);
        if (FLOAT_EQZ(dist2))
            return;
        dist = SQRTF(dist2);
        if (light->version == 1)
        {
            att = light->attenuation0 +
                  light->attenuation1 * dist +
                  light->attenuation2 * dist2;

            if (FLOAT_CMP_PONE(att, >))
                att *= dist;
            else
                att = dist;
            att = D3DVAL(1) / att;
        }
        else
        {
            // dist is normalized to light range
            float att1 = (light->range-dist)/light->range;
            att = light->attenuation0 +
                  light->attenuation1 * att1 +
                  light->attenuation2 * att1*att1;
        }

        if (light->type == D3DLIGHT_SPOT)
        {
            D3DVALUE cone_dot;
            // Calc dot product of direction to light with light direction to
            // be compared anganst the cone angles to see if we are in the light.
            // Note that cone_dot is still scaled by dist
            cone_dot = VecDot(d, light->model_direction);
            cone_dot /= dist;

            if (FLOAT_CMP_POS(cone_dot, <=, light->cos_phi_by_2))
                return;

            if (FLOAT_CMP_POS(cone_dot, <, light->cos_theta_by_2))
            {
                att *= D3DVAL(1)-(light->cos_theta_by_2-cone_dot)*light->falloff;
            }
        }

        dot *= att;

        if (pv->dwDeviceFlags & D3DDEV_RAMP)
        {
            ldrv.diffuse.r += light->shade * dot;
        }
        else
        {
            ldrv.diffuse.r += light->local_diffR * dot;
            ldrv.diffuse.g += light->local_diffG * dot;
            ldrv.diffuse.b += light->local_diffB * dot;
        }

        if (light->version == 1)
        {
            // no attenuation of specular for ramp for version == 1
            att = 1.0F;
        }
        if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)
        {
            dot = VecDot(light->halfway, in->dvNormal);
            COMPUTE_SPECULAR_ATT(pv, dot, light, att);
        }
    }
}
//-------------------------------------------------------------------------
SpecularTable* CreateSpecularTable(D3DVALUE power)
{
    SpecularTable* spec;
    int     i;
    float  delta = 1.0f/255.0f;
    float  v;

    D3DMalloc((void**)&spec, sizeof(SpecularTable));

    if (spec == NULL)
        return NULL;

    spec->power = power;

    v = 0.0f;
    for (i = 0; i < 256; i++)
    {
        spec->table[i] = powf(v, power);
        v += delta;
    }

    for (; i < 260; i++)
        spec->table[i] = 1.0f;

    return spec;
}

HRESULT SetMaterial(LPDIRECT3DDEVICEI lpDevI, D3DMATERIALHANDLE hMat)
{
    LPD3DFE_MATERIAL lpMat;
    lpMat = (LPD3DFE_MATERIAL) ULongToPtr(hMat);

    if (!lpMat)
    {
        lpDevI->lighting.hMat = NULL;
        return D3D_OK;
    }

#if DBG
// check for non-null bogus material handle
    TRY
      {
          if (IsBadReadPtr(lpMat,sizeof(D3DFE_MATERIAL)) || (lpMat->mat.dwSize!=sizeof(D3DMATERIAL))) {
              D3D_ERR( "SetLightState: Invalid Material handle" );
              return DDERR_INVALIDPARAMS;
          }
      }
      EXCEPT( EXCEPTION_EXECUTE_HANDLER )
      {
          D3D_ERR( "Exception encountered validating SetLightState material handle" );
          return DDERR_INVALIDPARAMS;
      }
#endif

    D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
    LIGHTING.material = lpMat->mat;
    LIGHTING.hMat = hMat;
    lpDevI->dwFEFlags |= D3DFE_MATERIAL_DIRTY;

    if (lpMat->mat.power > D3DVAL(0.001))
    {
        SpecularTable* spec;

        for (spec = LIST_FIRST(&lpDevI->specular_tables);
             spec;
             spec = LIST_NEXT(spec,list))
        {
            if (spec->power == lpMat->mat.power)
                break;
        }
        if (spec == NULL)
        {
            spec = CreateSpecularTable(lpMat->mat.power);
            if (spec == NULL)
                return DDERR_INVALIDPARAMS;
            LIST_INSERT_ROOT(&lpDevI->specular_tables, spec, list);
        }
        lpDevI->specular_table = spec;
        LIGHTING.specThreshold = D3DVAL(pow(0.001, 1.0/lpMat->mat.power));
    }
    else
        lpDevI->specular_table = NULL;

    return D3D_OK;
}

/*
 * Instruction emulation.
 */
HRESULT D3DHELInst_D3DOP_STATELIGHT(LPDIRECT3DDEVICEI lpDevI, DWORD dwCount,
                                    LPD3DSTATE lpLset)
{
    DWORD i;

    for (i = 0; i < dwCount; i++)
    {
        DWORD type = (DWORD) lpLset[i].dlstLightStateType;
        HRESULT hr = D3D_OK;

        D3D_INFO(9, "HEL D3DOP_STATELIGHT: state = %d", type);
        if (IS_OVERRIDE(type))
        {
            DWORD override = GET_OVERRIDE(type);
            if (lpLset[i].dwArg[0])
            {
                D3D_INFO(9, "HEL D3DOP_STATELIGHT: setting override for state %d",
                    override);
                STATESET_SET(lpDevI->lightstate_overrides, override);
            }
            else
            {
                D3D_INFO(9, "HEL D3DOP_STATELIGHT: clearing override for state %d",
                    override);
                STATESET_CLEAR(lpDevI->lightstate_overrides, override);
            }
            continue;
        }

        if (STATESET_ISSET(lpDevI->lightstate_overrides, type))
        {
            D3D_INFO(9, "HEL D3DOP_STATELIGHT: state %d is overridden, ignoring",
                type);
            continue;
        }

        D3DFE_LIGHTING& LIGHTING = lpDevI->lighting;
        switch (type)
        {
        case D3DLIGHTSTATE_MATERIAL:
        {
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_MATERIAL found");
            D3DMATERIALHANDLE hMat = (D3DMATERIALHANDLE)lpLset[i].dwArg[0];
            if (hMat != lpDevI->lighting.hMat)
            {
                hr = SetMaterial(lpDevI, hMat);
                if (hr != D3D_OK)
                    return hr;
                // Update ramp rasterizer if necessary
                if(lpDevI->pfnRampService != NULL)
                {
                    hr = CallRampService(lpDevI, RAMP_SERVICE_SETLIGHTSTATE,
                                        (DWORD)type, &(lpLset[i].dvArg[0]), TRUE);
                    if (hr != D3D_OK)
                        return hr;
                }
            }
            continue;
        }
        case D3DLIGHTSTATE_AMBIENT:
        {
            DWORD color = lpLset[i].dwArg[0];
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_AMBIENT found");

            LIGHTING.ambient_red   = D3DVAL(RGBA_GETRED(color));
            LIGHTING.ambient_green = D3DVAL(RGBA_GETGREEN(color));
            LIGHTING.ambient_blue  = D3DVAL(RGBA_GETBLUE(color));
            LIGHTING.ambient_save  = lpLset[i].dwArg[0];
            lpDevI->dwFEFlags |= D3DFE_MATERIAL_DIRTY;
            break;
        }
        case D3DLIGHTSTATE_FOGMODE:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_MODE found");
            LIGHTING.fog_mode = (D3DFOGMODE)lpLset[i].dwArg[0];
            SetFogFlags(lpDevI);
            break;
        case D3DLIGHTSTATE_FOGSTART:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_START found");
            LIGHTING.fog_start = lpLset[i].dvArg[0];
            if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
                lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY;
            break;
        case D3DLIGHTSTATE_FOGEND:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_END found");
            LIGHTING.fog_end = lpLset[i].dvArg[0];
            if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
                lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY;
            break;
        case D3DLIGHTSTATE_FOGDENSITY:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_FOG_DENSITY found");
            LIGHTING.fog_density = lpLset[i].dvArg[0];
            if (lpDevI->dwFEFlags & D3DFE_FOGENABLED)
                lpDevI->dwFEFlags |= D3DFE_FOG_DIRTY;
            break;
        case D3DLIGHTSTATE_COLORMODEL:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_COLORMODEL found");
            LIGHTING.color_model = (D3DCOLORMODEL)lpLset[i].dwArg[0];
            break;
        case D3DLIGHTSTATE_COLORVERTEX:
            D3D_INFO(6, "in HEL D3DOP_STATELIGHT. D3DLIGHTSTATE_COLORVERTEX found");
            if (lpLset[i].dwArg[0])
                lpDevI->dwFEFlags |= D3DFE_COLORVERTEX;
            else
                lpDevI->dwFEFlags &= ~D3DFE_COLORVERTEX;
            break;

        default:
            D3D_WARN(1, "in HEL D3DOP_STATELIGHT. Invalid state type %d",
                lpLset[i].dlstLightStateType);
            return (DDERR_INVALIDPARAMS);
        }

        // Update ramp rasterizer if necessary
        hr = CallRampService(lpDevI, RAMP_SERVICE_SETLIGHTSTATE,
                          (DWORD) type, &(lpLset[i].dvArg[0]));
        if (hr != D3D_OK)
        {
            return hr;
        }
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\sources.inc ===
MAJORCOMP=d3dim
MINORCOMP=pipeln
TARGETNAME=pipeln
TARGETPATH=obj
TARGETTYPE=LIBRARY

USE_MSVCRT=1

INCLUDES=..;$(_OBJ_DIR)\$(TARGET_DIRECTORY);$(D3DDX6)\pipeln\inc;$(INCLUDES)

C_DEFINES = $(C_DEFINES)

ASM_DEFINES = -DNT=1 -DMICROSOFT_NT -DSTACK_CALL  -DD3D -DOTHER_SEG=0 -DWANT_DLL

NTTARGETFILE0= \
             $O\pvvid.cpp \

SOURCES= \
    ..\clipper.cpp   \
    ..\dpclip.cpp   \
    ..\haltrans.cpp  \
    ..\helxfrm.cpp   \
    ..\rgblt.cpp     \
    $O\pvvid.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\bc9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWIN95 
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

OFFSETS = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\offsets.asm

GENSYMFLAGS = -DWIN32 -D_WIN32 -DD3D -Zp -D__DD_OPT_SURFACE $(GENSYMFLAGS) -DIS_32
GENSYMBASE = $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gensym
GENSYMEXE = $(GENSYMBASE).exe
GENSYMSOURCE = ..\gensym.cpp
GENSYMINCS =

!if $(AXP64)
GENSYMFLAGS = /Ap64 $(GENSYMFLAGS)
!endif

INCPATHS = \
        -I$(BASEDIR)\public\sdk\inc\
        -I$(BASEDIR)\public\sdk\inc\crt\
        -I$(BASEDIR)\public\oak\inc\
        -I$(INCLUDES:;= -I)


$(GENTGT)\pvvid.cpp: ..\pvvid.mcp $(RAST_STD_M4)

$(OFFSETS): $(GENSYMSOURCE) $(GENSYMINCS)
    set PASS0ONLY=
   $(TARGET_CPP) -c $(INCPATHS) $(GENSYMFLAGS) -Fo$(GENSYMBASE).obj $(GENSYMSOURCE)
    -link -out:$(GENSYMEXE) @<<
-machine:$(TARGET_DIRECTORY)
-base:@$(BASEDIR)\PUBLIC\SDK\LIB\coffbase.txt,usermode
-subsystem:console
-entry:mainCRTStartup
-ignore:4078,2001
-force:unresolved
-nodefaultlib
$(GENSYMBASE).obj
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\msvcrt.lib
$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\kernel32.lib
$(PERFLIBS)
<<
    -$(GENSYMEXE) > $(OFFSETS)
#    -erase $(GENSYMBASE).obj
#    -erase $(GENSYMEXE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\bcnt\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWINNT -DNT
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\ftrans.asm ===
; $Id: ftrans.asm,v 1.3 1995/10/20 15:14:41 james Exp $
;
; Up to 165K from 143K
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994, 1995
; Version 1.0
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
; NOTE: Need to set integer pop precision...
;
OPTION NOM510
.386p
;.radix  16
                NAME    transform

                include macros.asm
                include offsets.asm

procstart	macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		proc
	    else
&prefix&xfrm_class		proc
	    endif
	    else
&prefix&xfrm_class&_		proc
	    endif
		endm

procend		macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		endp
	    else
&prefix&xfrm_class		endp
	    endif
	    else
&prefix&xfrm_class&_		endp
	    endif
		endm
		
if GEN_XFRM eq 1
xfrmName	equ	General
else
xfrmName	equ	Affine
endif


;ifndef WINNT
;DGROUP          GROUP   _DATA
;endif

_DATA           SEGMENT PARA PUBLIC USE32 'DATA'

; These two are in the same cache line
tx              dq	0
ty		dq	0

_DATA           ENDS

_TEXT           SEGMENT DWORD PUBLIC USE32 'CODE'
;ifdef WINNT
                ASSUME  CS:_TEXT ,DS:_DATA,SS:_DATA
;else
;               ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
;endif

FDROP   macro
        fstp    st(0)
        endm

fmat	macro	op,row,col
	op	dword ptr [ebp + 4 * ((4 * row) + col)]
	endm

column	macro	i,depth
	fld	dword ptr [esi + D3DVERTEX_x]	; [1]	x

	fmat	fmul,0,i			; [2]	x

	fld	dword ptr [esi + D3DVERTEX_y]	; [3]	y	x

	fmat	fmul,1,i			; [4]	y	x

	fld	dword ptr [esi + D3DVERTEX_z]	; [5]	z	y	x

	fmat	fmul,2,i			; [6]	z	y	x
	fxch	st(2)				; 	x	y	z

	fmat	fadd,3,i			; [7]	x	y	z
	endm
		
	procstart	RLDDITransformUnclippedLoop,%xfrmName

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, m, in_size, out_size, z_scale, z_offset>
	defargs	<minx, maxx, miny, maxy>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        endif

	mov     ebx,[esp + count]
	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov     edi,[esp + vout]

	mov	ebp,[esp + m]

	;	eax	ebx	ecx	edx
	;	minx	maxx	miny	maxy

	; Need to do first loop iteration
	column	0,0
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z' x y z
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; tx
	
	column	1,1		;	x'	y'	z'	x
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			;	x'+y'	z'	tx
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx
	
if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count + 8],1
	je	dontscan
	mov	eax,[esi + 32]
	mov	ebx,[edi + 32]
dontscan:
	pop	ebx
	pop	eax

	fxch	st(3)		; tx tz ty 1/tz

	fmul	st,st(3)	; tx/w tz ty 1/tz
	fxch	st(2)		; ty tz tx/w 1/tz

	fmul	st,st(3)	; ty/w tz tx/w 1/tz
	fxch	st(2)		; tx/w tz ty/w 1/tz

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tz
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tz
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tz
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif
	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz

	fmul	st,st(1)
	fxch	st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]

	fstp	dword ptr [edi + D3DTLVERTEX_sz]

	add	edi,32
	add	esi,32

	dec	dword ptr [esp + count]
	jnz	transloop

	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformUnclippedLoop,%xfrmName


cpick	macro	dst,c0,c1			; NO CARRY	CARRY
	sbb	dst,dst				; 0		~0
	and	dst,c0 xor c1			; 0		c0^c1
	xor	dst,c0				; c0		c1
	endm

;************************************************************************

		
	procstart	RLDDITransformClippedLoop,%xfrmName
		

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, hout, m, in_size, out_size, z_scale, z_offset>
	defargs	<x_bound, y_bound, r_scale_x, r_scale_y>
	defargs	<minx, maxx, miny, maxy>
	defargs	<clip_intersection, clip_union>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        else
		mov     ebx,[esp + count]
		mov     ecx,[esp + vout]
        endif

	fldpi

	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov	ebp,[esp + m]
	mov	edi,[esp + vout]

	; Need to do first loop iteration

	column	0,0		; 2 cycle wait here
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z'
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; x'+y'+z'
	
	column	1,1		; 2 cycle wait here
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			; x'+y' z'
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	; Now set up the clip flags in ebp
	xor	ebp,ebp
	fld	dword ptr [esp + 8 + x_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(3+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	x1		; Skip this if (tmp > tx)
	or	ebp,D3DCLIP_RIGHT
x1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(3+GEN_XFRM)	; (tw) tz ty tx
	fnstsw	ax
	sahf
	jbe	xpasses		; Skip this if (-tmp <= tx)
	or	ebp,D3DCLIP_LEFT
xpasses:
	fld	dword ptr [esp + 8 + y_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	y1		; Skip this if (tmp > ty)
	or	ebp,D3DCLIP_TOP
y1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	jbe	ypasses		; Skip this if (-tmp <= ty)
	or	ebp,D3DCLIP_BOTTOM
ypasses:
	fst	[ty]		; ty will hold tw for a while...
	
	; if GEN_XFRM eq 0 then tw == tz
	; if GEN_XFRM eq 1 then tw != tz in general, so we
	; calculate a true 1/tw and then drop the extra tw
	; off the FP stack

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx

if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count],1
	je	dontscan
	mov	eax,[esp + in_size + 8]
	mov	ebx,[esp + out_size + 8]
	mov	eax,[esi + eax]
	mov	ebx,[edi + ebx]
dontscan:
	pop	ebx
	pop	eax

	mov	[esp + vout],edi		
	mov	edi,[esp + hout]
				; 1/tw tz ty tx
	fxch	st(3)		; tx tz ty 1/tw

	fld	dword ptr [esp + r_scale_x]
	fmul	st,st(1)	; hx tx tz ty 1/tw
	fld	dword ptr [esp + r_scale_y]
	fmul	st,st(4)	; hy hx tx tz ty 1/tw
	fxch	st(1)		; hx hy tx tz ty 1/tw

	fstp	dword ptr [edi + D3DHVERTEX_hx]
	fstp	dword ptr [edi + D3DHVERTEX_hy]

	fmul	st,st(3)	; tx/w tz ty 1/tw
	fxch	st(2)		; ty tz tx/w 1/tw

	fmul	st,st(3)	; ty/w tz tx/w 1/tw
	fxch	st(2)		; tx/w tz ty/w 1/tw

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tw
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tw
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tw
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif

	; Last clipping flags
	fst	dword ptr [edi + D3DHVERTEX_hz]
	test	byte ptr [edi + D3DHVERTEX_hz + 3],80h
	jz	nofront
	or	ebp,D3DCLIP_FRONT
nofront:
	fcom	[ty]
	push	eax		;[
	fnstsw	ax
	sahf
	pop	eax		;]
	jb	noback
	or	ebp,D3DCLIP_BACK
noback:
	mov	[edi + D3DHVERTEX_dwFlags],ebp
	mov	edi,[esp + clip_intersection]
	and	[edi],ebp
	mov	edi,[esp + clip_union]
	or	[edi],ebp

	test	ebp,ebp
	jnz	outofplay

	mov	edi,[esp + vout]

	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz y

	fmul	st,st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_sz]
				; 1/tz y

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]
				; y

	add	esi,[esp + in_size]

	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp
	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jnz	transloop
	jmp	cleanup

outofplay:				; tz sx sy 1/tz
	FDROP				; sx sy 1/tz
	FDROP				; sy 1/tz y
	FDROP				; 1/tz y
	mov	edi,[esp + vout]
	fstp	dword ptr [edi + D3DTLVERTEX_rhw]	

	add	esi,[esp + in_size]
	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp

	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jz	calcminmax

	column	0,0		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	jmp	smaxy


cleanup:
	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

calcminmax:
	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

	FDROP

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformClippedLoop,%xfrmName

		
if GEN_XFRM
_Rdtsc	proc
	db	0fh,31h
	shrd	eax,edx,10
	ret
	
_Rdtsc	endp
endif

_TEXT           ENDS

        extrn	_g_fOne:dword
        extrn	_g_fOoTwoPow16:dword
	extrn	_g_dSnap:qword

                END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWINNT -DNT
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\light.asm ===
.486p

.model flat

include offsets.asm

.data

one DWORD   3f800000h

a1      dd 0.47                 ; Constants to compute inverse square root
a2      dd 1.47
v255    dd 65280.0              ; 255*256
v1_256  dd 0.00390625           ; 1/255
.code

PUBLIC  _Directional2P5S        ; Pentium optimized, specular, unit scale
PUBLIC  _Directional2P5         ; Pentium optimized, no specular, unit scale
;-------------------------------------------------------------------------
; Jim Blinn's method is used to compute inverse square root s = 1/sqrt(x):
;   ONE_AS_INTEGER = 0x3F800000
;   float y;
;   int tmp = ((ONE_AS_INTEGER << 1 + ONE_AS_INTEGER)  - *(long*)&x) >> 1;   
;   y = *(float*)&tmp;  
;   s = y*(1.47f - 0.47f*x*y*y);
; Input:
;   st(0)   = vector length
;   y, len  = should be defined as DWORD PTR
;   a1, a2  = 0.27 and 1.47
; Output:
;   st(0)   = 1/sqrt(vector length)
;
COMPUTE_ISQRT MACRO
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     len                         ; Vector length (x = len)
    sub     eax, len
    sar     eax, 1
    mov     y, eax                      ; y
    fmul    a1                          ; len*0.47  x y z
    fld     y                           ; y len*0.47 x y z
    fld     st(0)                       ; y y len*0.47 x y z
    fmul    st(0), st(1)                ; y*y y len*0.47 x y z
    fld     a2                          ; 1.47 y*y y len*0.47 x y z
    fxch    st(3)                       ; len*0.47 y*y y 1.47 x y z
    fmulp   st(1), st(0)                ; len*0.47*y*y y 1.47 x y z
    fsubp   st(2), st(0)                ; y aaa x y z
    fmulp   st(1), st(0)                ; 1/sqrt(len) x y z
ENDM
;-------------------------------------------------------------------------
; Exit from the function
;
EXIT_FUNC   MACRO
    pop     edx
    pop     ebx
    pop     ecx
    mov     esp, ebp
    pop     ebp
    ret
ENDM
;-------------------------------------------------------------------------
; void Directional2P5S(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Specular is always computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse and pv.lighting.specular are updated
;   pv.lighting.specularComputed is set to 1, if there is specular component
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5S PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit1

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

; if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)

;    test    DWORD PTR [ecx + D3DI_LIGHT_flags], D3DLIGHTI_COMPUTE_SPECULAR
;    jz      exit

; VecSub(in->dvPosition, light->model_eye, eye);

    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _X_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _X_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Y_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Y_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Z_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Z_]    ; z y x
    fxch    st(2)                                           ; x y z

; VecNormalizeFast(eye);
;

; Compute vector length. Leave vector on the FPU stack, because we will use it
;
    fld     st(1)                       ; x x y z
    fmul    st(0), st(0)                ; x*x x y z
    fld     st(2)
    fmul    st(0), st(0)                ; y*y x*x x y z
    fld     st(4)
    fmul    st(0), st(0)                ; z*z y*y x*x x y z
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len x y z

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

; Start normalizing the eye vector
    fmul    st(1), st(0)
    fmul    st(2), st(0)
    fmulp   st(3), st(0)                ; x y z  Normalized "eye" vector

; Calc halfway vector
; VecSub(light->model_direction, eye, h);
;
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fxch    st(1)                       ; y x z
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fxch    st(2)                       ; z x y 
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fxch    st(1)                       ; x z y 

; dot = VecDot(h, in->dvNormal);

    fld     st(0)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     st(3)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     st(3)                       ; z*Nz y*Ny x*Nx x z y
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_]
    fxch    st(2)
    faddp   st(1), st(0)
    faddp   st(1), st(0)                ; dot x z y
    fstp    dot                         ; x z y

; if (FLOAT_GTZ(dot)) 

    cmp     dot, 0
    jle     exit2

; dot *= ISQRTF(VecLenSq(h));
;
    fmul    st(0), st(0)                ; x*x y z
    fxch    st(1)                       ; y x*x z
    fmul    st(0), st(0)                ; y*y x*x z
    fxch    st(2)
    fmul    st(0), st(0)                ; z*z y*y x*x
    fxch    st(2)			            ; 
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

    fmul    dot                         ; dot
    mov     eax, [edx + PV_LIGHT_specThreshold]
    fst     dot

; if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))

    cmp     dot, eax
    jle     exit1

; power = COMPUTE_DOT_POW(&ldrv, dot);
;    int     indx;                
;    float   v;
;    dot *= 255.0f;
;    indx = (int)dot;
;    dot -= indx;                                            
;    ldrv->specularComputed = TRUE;                          
;    v = ldrv->currentSpecTable[indx];
;    return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
;
    fmul    v255            ; dot*255*256
    push    ebx
    fistp   dot             ; indx << 8. 8 bits used to compute dot fraction
    mov     ebx, dot        ; 
    and     dot, 0FFh       ; fractional part of dot
    shr     ebx, 8          ; Table index
    mov     eax, [edx + PV_LIGHT_currentSpecTable]
    lea     eax, [eax + ebx*4]
    fild    dot             ; fractional part of dot
    fmul    v1_256          ; dot*1/256 -> integer fraction to floating point
    fld     DWORD PTR [eax + 4]     ; currentSpecTable[indx+1]
    fsub    DWORD PTR [eax]         ; currentSpecTable[indx]
    fmulp   st(1), st(0)            ; dot*(v2-v1)
    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
    pop     ebx
    fadd    DWORD PTR [eax]

; power = COMPUTE_DOT_POW(&ldrv, dot);
; This is an alternative method to compute x power y.
; Jim Blinn's method is used:
; int tmp = (int)(power*(*(long*)&dot - ONE_AS_INTEGER)) + ONE_AS_INTEGER;
; dot ^ power = *(float*)&tmp;                                           
;
;    sub     dot, 03F800000h
;    fstp    st(0)                       ; Remove dot
;    fld     DWORD PTR [edx + PV_LIGHT_material_power]
;    fimul   dot
;    fistp   dot
;    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
;    add     dot, 03F800000h
;    fld     dot

; ldrv.specular.r += light->local_specR * power;
; ldrv.specular.g += light->local_specG * power;
; ldrv.specular.b += light->local_specB * power;
;
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specB]
    fmulp   st(3), st(0)                ; g r b
    fxch    st(1)                       ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fxch    st(1)                       ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(2)                       ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(1)                       ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _G_]
exit:
    EXIT_FUNC
exit1:
    fstp    st(0)
    EXIT_FUNC
exit2:
    fstp    st(0)
    fstp    st(0)
    fstp    st(0)
    EXIT_FUNC

_Directional2P5S ENDP
;-------------------------------------------------------------------------
; void Directional2P5(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Only diffuse component is computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse is updated
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5 PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit3

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

    EXIT_FUNC
exit3:
    fstp    st(0)
    EXIT_FUNC

_Directional2P5 ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\_ftransa.asm ===
GEN_XFRM = 0
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\_ftransg.asm ===
GEN_XFRM = 1
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\tclipp6.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.data

gD3DCLIP_LEFT   dd  01h
gD3DCLIP_RIGHT  dd  02h
gD3DCLIP_TOP    dd  04h
gD3DCLIP_BOTTOM dd  08h
gD3DCLIP_FRONT  dd  10h
gD3DCLIP_BACK   dd  20h

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul6

_matmul6  PROC

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;

        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;

        fxch    st(3)                           ; x1 y1 w1 z1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x2 y1 w1 z1
        fxch    st(2)                           ; w1 y1 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w2 y1 x2 z1
        fxch    st(1)                           ; y1 w2 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y2 w2 x2 z1
        fxch    st(3)                           ; z1 w2 x2 y2
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 w2 x2 y2

        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;

        fxch    st(3)       ; y*_21 y*_22 y*_24 y*_23 z2 w2 x2 y2
        faddp   st(6),st    ; y*_22 y*_24 y*_23 z2 w2 x3 y2
        fxch    st(1)       ; y*_24 y*_22 y*_23 z2 w2 x3 y2
        faddp   st(4),st    ; y*_22 y*_23 z2 w3 x3 y2
        faddp   st(5),st    ; y*_23 z2 w3 x3 y3
        faddp   st(1),st    ; z3 w3 x3 y3

        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;

        fxch    st(3)       ; z*_31 z*_32 z*_34 z*_33 z3 w3 x3 y3
        faddp   st(6),st    ; z*_32 z*_34 z*_33 z3 w3 x4 y3
        fxch    st(1)       ; z*_34 z*_32 z*_33 z3 w3 x4 y3
        faddp   st(4),st    ; z*_32 z*_33 z3 w4 x4 y3
        faddp   st(5),st    ; z*_33 z3 w4 x4 y4
        faddp   st(1),st    ; z4 w4 x4 y4

        fldz                ; 0 z4 w4 x4 y4
        fxch    st(4)       ; y4 z4 w4 x4 0
        fxch    st(3)       ; x4 z4 w4 y4 0
        xor     eax,eax     ;
        xor     ebx,ebx     ;
        xor     ecx,ecx     ;
        xor     edx,edx     ;
        fcomi   st,st(4)    ;
        cmovb   eax,gD3DCLIP_LEFT
        fcomi   st,st(2)    ;
        cmovnb  ebx,gD3DCLIP_RIGHT
        fxch    st(3)       ; y4 z4 w4 x4 0
        or      eax,ebx
        xor     ebx,ebx
        fcomi   st,st(4)    ;
        cmovb   ecx,gD3DCLIP_BOTTOM
        fcomi   st,st(2)    ;
        cmovnb  edx,gD3DCLIP_TOP
        or      eax,ecx
        xor     ecx,ecx
        fxch    st(1)       ; z4 y4 w4 x4 0
        fcomi   st,st(4)    ;
        or      edx,edx
        cmovb   ebx,gD3DCLIP_FRONT
        fcomi   st,st(2)    ;
        cmovnb  ecx,gD3DCLIP_BACK
        or      eax,ebx
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv
        or      eax,ecx
        mov     ebx,pmat                ;
        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;
        fxch    st(4)   ; 0 y4 w4 x4 z4
        fstp    st      ; y4 w4 x4 z4

;; Now compute the clipcodes.

;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

;; actually the flags have not been touched since the final OR so we don't 
;; need to test this explicitly
;;      test    eax,eax
        jnz     ClipNonzero             ; jump if clip flags nonzero

        fld1                ; 1 y w x z
        fdivrp  st(2),st    ; y w x z

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx

        ; y w x z
        fabs
        fxch    st(2)
        fabs
        fxch    st(2)

        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(2)   ;
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fxch    st(2)   ; y w x z
        fmul    st,st(1)
        fxch    st(2)   ; x w y z
        fmul    st,st(1) ;
        fxch    st(2)   ; y w x z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fxch    st(2)   ; x w y z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(3)   ; z w y x
        fmul    st,st(1)
        fxch    st(3)   ; x w y z

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; minx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fcomi   st,st(1)
        fcmovnb st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]

    ; maxx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fcomi   st,st(1)
        fcmovb  st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]

    ; miny x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fcomi   st,st(3)
        fcmovnb st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]

    ; maxy x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fcomi   st,st(3)
        fcmovb  st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]

NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        jmp     short Return

_matmul6  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

	ifdef INTEL
func	macro	name
	public	name
name:
	endm
	else
func	macro	name
	public	_&name
name:			;lay down both labels so I have one I know will
_&name:			;always be available for asm to call.
	endm
	endif

push_all	macro
	irp	z,<edi,esi,edx,ecx,ebx,eax>
	push	z
	endm
	endm

pop_all		macro
	irp	z,<eax,ebx,ecx,edx,esi,edi>
	pop	z
	endm
	endm

push_m	macro	list
	irp	z,<list>
	push	z
	endm
	endm
	
pop_m	macro	list
	irp	z,<list>
	pop	z
	endm
	endm

byte_eax	equ	al
byte_ebx	equ	bl
byte_ecx	equ	cl
byte_edx	equ	dl

word_eax	equ	ax
word_ebx	equ	bx
word_ecx	equ	cx
word_edx	equ	dx
word_edi	equ	di
word_esi	equ	si
word_ebp	equ	bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 017H
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 018h
	shl	eax, 008h
	idiv	divisor
nodivide:
	endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 0fH
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 010h
	shl	eax, 010h
	idiv	divisor
nodivide:
	endm

ES_PREFIX	macro
    ifndef	NT
	db	26h
    endif
	endm

beginargs macro
	align	4
stack	=	4	;return address
vars	=	0	;no vars yet
args	=	0	;no args yet
	endm

endargs	macro
	sub	esp, vars
	endm

savereg	macro	arg
	push	arg
stack	=	stack + 4
	endm

saveregs macro	arglist
	irp	z,<arglist>
	savereg	z
	endm
	endm

defvar  macro	name
name	=	vars
vars	=	vars + 4
stack	=	stack + 4
	endm

defvars	macro	arglist
	irp	z,<arglist>
	defvar	z
	endm
	endm

defarg	macro	name
name	=	stack + args
args	=	args + 4
	endm

defargs	macro	arglist
	irp	z,<arglist>
	defarg	z
	endm
	endm

regarg	macro	name
	ifdef	STACK_CALL
	defarg	name
	else
	defvar	name
	endif
	endm

regargs	macro	arglist
	irp	z,<arglist>
	regarg	z
	endm
	endm

return	macro
	ifdef	STACK_CALL
	ret
	else
	ret	args
	endif
	endm

    ifdef	BCC		;{

beginproc macro	prefix,GF,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	if DEPTH eq 0
prefix&name	equ	_&prefix&GF&Tr&Te&name
	else
	  if DEPTH eq 8
prefix&name	equ	_&prefix&8&GF&Tr&Te&name
	  else
prefix&name	equ	_&prefix&16&GF&Tr&Te&name
	  endif
	endif
	public	prefix&name
prefix&name proc
	endm			;}

    else			;} ifndef BCC {

beginproc macro	prefix,GF,Z,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	ifdef	STACK_CALL	;{
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Z&Tr&Te&name
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8_&GF&Z&Tr&Te&name
	    else
prefix&name	equ	prefix&16_&GF&Z&Tr&Te&name
	    endif
	endif
	else			;} else {
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Tr&Te&name&_
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8&GF&Tr&Te&name&_
	    else
prefix&name	equ	prefix&16&GF&Tr&Te&name&_
	    endif
	endif
	endif			;}
	public	prefix&name
prefix&name proc
	endm			;}
    endif		;}

    ifdef	BCC	;{
endproc	macro prefix,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	if	DEPTH eq 8
_&prefix&name endp
	else
_&prefix&name endp
	endif
	endm			;}

    else		;} ifndef BCC {

endproc	macro prefix,GF,Z,Te,Tr,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	ifdef	STACK_CALL
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name endp
	    else
	    if	DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
	    else
prefix&16_&GF&Z&Tr&Te&name endp
	    endif
	    endif
	else
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
	    else
	    if	DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
	    else
prefix&16&GF&Tr&Te&name&_ endp
	    endif
	    endif
	endif
	endm			;}

    endif		;}

; ************************************************************************
itoval	macro	reg
	shl	reg,10h
	endm

FDUP	macro
	fld	st(0)
	endm

FDROP	macro
	fstp	st(0)
	endm

FRECIPROCAL	macro
	fld1
	fdivrp	st(1),st
	endm

; MASM 6.11d used in NT has native support for fcomi so this macro can't be
; called fcomi

MACRO_FCOMI macro v
	fcom	v
	fnstsw	ax
	sahf
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\i386\tclipp5.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul5

_matmul5  PROC    

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;


        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;


; notation in comments on stack gives the progress on the element.
; x, y, z mean input x y z
; x1-4 means x*_11, x*_11+y*_21, x*_11+y*_21+z*_31, x*_11+y*_21+z*_31+_41
; Some intermediate results x*_11+_41 and y*_21+z*_31 are denoted as x2

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31 y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fxch    st(2)                           ; y*_21 y*_24 z*_31 w1 x1
        faddp   st(4),st                        ; y*_24 z*_31 w1 x2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34 y*_24 z*_31 w1 x2
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fxch    st(1)                           ; y*_24 z*_34 z*_31 w1 x2
        faddp   st(3),st                        ; z*_34 z*_31 w2 x2
        fxch    st(1)                           ; z*_31 z*_34 w2 x2
        faddp   st(3),st                        ; z*_34 w2 x3
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 z*_34 w2 x3
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fxch    st(1)                           ; z*_34 y1 w2 x3
        faddp   st(2),st                        ; y1 w3 x3
        fxch    st(2)                           ; x3 w3 y1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x4 w3 y1
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23 y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;
        fxch    st(4)                           ; w3 y*_22 z1 x4 y*_23 y1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w4 y*_22 z1 x4 y*_23 y1
        fxch    st(3)                           ; x4 y*_22 z1 w4 y*_23 y1
        fst     dword ptr [ebp]                 ;
        fxch    st(1)                           ; y*_22 x4 z1 w4 y*_23 y1
        faddp   st(5),st                        ; x4 z1 w4 y*_23 y2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33 z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;
        fxch    st(6)                           ; y2 z*_32 x4 z1 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y3 z*_32 x4 z1 w4 y*_23 z*_33
        fxch    st(3)                           ; z1 z*_32 x4 y3 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 z*_32 x4 y3 w4 y*_23 z*_33
        fxch    st(5)                           ; y*_23 z*_32 x4 y3 w4 z2 z*_33
        faddp   st(6),st                        ; z*_32 x4 y3 w4 z2 z2
        faddp   st(2),st                        ; x4 y4 w4 z2 z2

;;
        fsubr   st,st(2)                        ; xx y4 w4 z2 z2
        fxch    st(4)                           ; z2 y4 w4 z2 xx
        faddp   st(3),st                        ; y4 w4 z4 xx
        fld     st                              ; y4 y4 w4 z4 xx
        fsubr   st,st(2)                        ; yy y4 w4 z4 xx
        fxch    st(1)                           ; y4 yy w4 z4 xx
        fstp    dword ptr [ebp+4]               ; yy w4 z4 xx
        fxch    st(3)                           ; xx w4 z4 yy
        fstp    tempxx                          ; w4 z4 yy
        fxch    st(1)                           ; z4 w4 yy
        fst     dword ptr [ebp+8]               ;
        fsubr   st,st(1)                        ; zz w4 yy
        fxch    st(2)                           ; yy w4 zz
        fstp    tempyy                          ; w4 zz
        fxch    st(1)                           ; zz w4
        fstp    tempzz                          ;

        fld1                                    ; 1 w4
        fdiv	st,st(1)                        ; 1/w w

;; Now compute the clipcodes.


;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK

        mov     eax,dword ptr [ebp]     ; Get x
        mov     ebx,dword ptr [ebp+4]   ; Get y

        and     eax,esi                 ;
        and     ebx,esi                 ;

        shr     eax,32-1                ; D3DCLIP_LEFT
        mov     ecx,dword ptr [ebp+8]   ; Get z

        shr     ebx,32-4		; D3DCLIP_BOTTOM
        mov     edx,tempxx		;

        or      eax,ebx			; OR together clip flags
        and     ecx,esi			;

        shr     ecx,32-5		; D3DCLIP_FRONT
        and     edx,esi                 ;

        shr     edx,32-2                ; D3DCLIP_RIGHT
        mov     ebx,tempyy		;

        or      eax,ecx                 ;
        and     ebx,esi                 ;

        shr     ebx,32-3                ; D3DCLIP_TOP
        or      eax,edx                 ;

        mov     edx,tempzz
        or      eax,ebx                 ;

        and     edx,esi                 ;

        shr     edx,32-6                ; D3DCLIP_BACK
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv

        or      eax,edx                 ; Finish clip flag generation
        mov     ebx,pmat                ;

        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;

        test    eax,eax                 ; Bail if clip!=0
        jnz     ClipNonzero             ;

        push    eax                     ; Save clip flags
                                        ; ax gets trashed by fstsw in min/max calcs

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx


        fxch    st(1)                   ; we w
        fstp    st                      ;
                                        ; w
        fld     dword ptr [ebp]         ; x w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fld     dword ptr [ebp+4]       ; y x*scaleX w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(1)                   ; x*scaleX y*scaleY w
        fmul    st,st(2)                ; x*w*scaleX y*scaleY w
        fxch    st(1)                   ; y*scaleY x*w*scaleX w
        fmul    st,st(2)                ; y*w*scaleY x*w*scaleX w
        fxch    st(1)                   ; x*w*scaleX y*w*scaleY w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(1)                   ; y x w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fld     dword ptr [ebp+8]       ; z y x w
        fmul    st,st(3)                ; z y x w
        fxch    st(2)                   ; x y z w

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; x y z w
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
@@:     fxch    st(1)
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
@@:     fxch    st(1)
NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]

        pop     eax         ; Get clip flags back
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    st          ; Get rid of 1/w
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw] ; store we
        jmp     short Return

_matmul5  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
__CLIP_NAME(D3DFE_PROCESSVERTICES *pv,
            ClipVertex **inv, 
            ClipVertex **outv,
            int count,
            int interpolate)
{
    int i;
    int out_count = 0;
    ClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->hw * pv->vcache.__CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->hw - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->hw * pv->vcache.__CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->hw - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv,
                            outv[out_count],
                            curr, prev, 
                            (prev->clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            interpolate,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                Interpolate(pv, 
                            outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            interpolate,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int __CLIP_LINE_NAME(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line, 
                     int interpolate)
{
    D3DVALUE in1, in2;
    ClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->hw * pv->vcache.__CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->hw - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->hw - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(pv, &outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, interpolate, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(pv,  &outv, line->v[0], line->v[1],
                        __CLIP_FLAG, interpolate, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clipfunc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipfunc.h
 *  Content:    Clipper functions
 *
 ***************************************************************************/

#ifndef _CLIPFUNC_H_
#define _CLIPFUNC_H_

#include "clipper.h"

int SetInterpolationFlags(D3DFE_PROCESSVERTICES *pv);

int ClipSingleLine(D3DFE_PROCESSVERTICES *pv,
                   ClipTriangle *line,
                   D3DRECTV *extent,
                   int interpolate);

HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleList (D3DFE_PROCESSVERTICES*);
HRESULT ProcessClippedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedLine(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleFan  (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedTriangleList (D3DFE_PROCESSVERTICES *pv);
HRESULT ProcessClippedIndexedLine(D3DFE_PROCESSVERTICES *pv);
DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);

#endif // _CLIPFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clipper.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.h
 *  Content:    Clipper definitions
 *
 ***************************************************************************/
#ifndef _CLIPPER_H_
#define _CLIPPER_H_

#define INTERPOLATE_COLOR       (1<< 0)
#define INTERPOLATE_SPECULAR    (1<< 1)
#define INTERPOLATE_TEXTUREL    (1<< 2) // legacy-related texture
#define INTERPOLATE_RCOLOR      (1<< 3)
#define INTERPOLATE_TEXTURE3    (1<< 4) //  interpolate Texture3

#define CLIPPED_LEFT    (D3DCLIP_GEN5 << 1)
#define CLIPPED_RIGHT   (D3DCLIP_GEN5 << 2)
#define CLIPPED_TOP     (D3DCLIP_GEN5 << 3)
#define CLIPPED_BOTTOM  (D3DCLIP_GEN5 << 4)
#define CLIPPED_FRONT   (D3DCLIP_GEN5 << 5)
#define CLIPPED_BACK    (D3DCLIP_GEN5 << 6)

#define CLIPPED_ENABLE  (D3DCLIP_GEN5 << 7) /* wireframe enable flag */

#define CLIPPED_ALL (CLIPPED_LEFT|CLIPPED_RIGHT     \
             |CLIPPED_TOP|CLIPPED_BOTTOM            \
             |CLIPPED_FRONT|CLIPPED_BACK)
//---------------------------------------------------------------------
// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     D3DCLIP_LEFT bit is set
// if x < -w*ax1           __D3DCLIPGB_LEFT bit is set
//
#define __D3DCLIPGB_LEFT    (D3DCLIP_GEN5 << 1)
#define __D3DCLIPGB_RIGHT   (D3DCLIP_GEN5 << 2)
#define __D3DCLIPGB_TOP     (D3DCLIP_GEN5 << 3)
#define __D3DCLIPGB_BOTTOM  (D3DCLIP_GEN5 << 4)
#define __D3DCLIPGB_ALL (__D3DCLIPGB_LEFT | __D3DCLIPGB_RIGHT | \
                         __D3DCLIPGB_TOP | __D3DCLIPGB_BOTTOM)

// If only these bits are set, then this point is inside the guard band
//
#define __D3DCLIP_INGUARDBAND (D3DCLIP_LEFT | D3DCLIP_RIGHT | \
                               D3DCLIP_TOP  | D3DCLIP_BOTTOM)

//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define D3DCLIP_LEFTBIT     1
#define D3DCLIP_RIGHTBIT    2
#define D3DCLIP_TOPBIT      3
#define D3DCLIP_BOTTOMBIT   4
#define D3DCLIP_FRONTBIT    5
#define D3DCLIP_BACKBIT     6
#define D3DCLIPGB_LEFTBIT   13
#define D3DCLIPGB_RIGHTBIT  14
#define D3DCLIPGB_TOPBIT    15
#define D3DCLIPGB_BOTTOMBIT 16

//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
// clipMask is set to the guard band bits or 0xFFFFFFFFF
//
inline void MAKE_CLIP_VERTEX(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, 
                             D3DTLVERTEX* p1, DWORD clipFlag, 
                             BOOL transformed, DWORD clipMaskOffScreen)
{
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    if (transformed || !(clipFlag & clipMaskOffScreen))         
    {                                                           
        pp1.sx  = p1->sx;                                       
        pp1.sy  = p1->sy;                                       
        pp1.sz  = p1->sz;                                       
        pp1.hw  = 1.0f / p1->rhw;                               
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw *           
                  VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw *           
                  VPORT.scaleYi;                                
        pp1.hz  = pp1.sz * pp1.hw;                              
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = p1->sx;                                        
        pp1.hy = p1->sy;                                        
        pp1.hz = p1->sz;                                        
        pp1.hw = p1->rhw;                                       
    }                                                           
    pp1.color   = p1->color;                                    
    pp1.specular= p1->specular;                                 
    pp1.tex[0].u  = p1->tu;                                     
    pp1.tex[0].v  = p1->tv;                                     
    pp1.clip = clipFlag & D3DSTATUS_CLIPUNIONALL;
}
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
inline void MAKE_TL_VERTEX(D3DTLVERTEX* out, ClipVertex* in)
{
    (out)->sx  = (in)->sx;              
    (out)->sy  = (in)->sy;              
    (out)->sz  = (in)->sz;              
    (out)->rhw = D3DVAL(1)/(in)->hw;    
    (out)->color   = (in)->color;       
    (out)->specular= (in)->specular;    
    (out)->tu   = (in)->tex[0].u;       
    (out)->tv   = (in)->tex[0].v;       
}
//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - DIRECT3DDEVICEI *
// pp1    - clipVertex
// p1     - TL vertex
//
inline void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                            DWORD clipFlag, BOOL transformed, DWORD clipMaskOffScreen)              
{                                                               
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    BYTE *v = (BYTE*)p1;                                               
    if (transformed || !(clipFlag & clipMaskOffScreen))         
    {                                                           
        pp1.sx  = ((D3DVALUE*)v)[0];                            
        pp1.sy  = ((D3DVALUE*)v)[1];                            
        pp1.sz  = ((D3DVALUE*)v)[2];                            
        pp1.hw  = 1.0f / ((D3DVALUE*)v)[3];                     
        pp1.hx  = (pp1.sx - VPORT.offsetX) * pp1.hw *           
                  VPORT.scaleXi;                                
        pp1.hy  = (pp1.sy - VPORT.offsetY) * pp1.hw *           
                  VPORT.scaleYi;                                
        pp1.hz  = pp1.sz * pp1.hw;                              
    }                                                           
    else                                                        
    {                                                           
        pp1.hx = ((D3DVALUE*)v)[0];                             
        pp1.hy = ((D3DVALUE*)v)[1];                             
        pp1.hz = ((D3DVALUE*)v)[2];                             
        pp1.hw = ((D3DVALUE*)v)[3];                             
    }                                                           
    v += sizeof(D3DVALUE) * 4;                                  
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)                   
    {                                                           
        pp1.color   = *(DWORD*)v;                               
        v += sizeof(D3DVALUE);                                  
                                                                
    }                                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)                  
    {                                                           
        pp1.specular= *(DWORD*)v;                               
        v += sizeof(DWORD);                                     
    }                                                           
    for (DWORD ii=0; ii < pv->nTexCoord; ii++)           
    {                                                           
        pp1.tex[ii].u  = *(D3DVALUE*)v;
        v += sizeof(D3DVALUE);                                  
        pp1.tex[ii].v  = *(D3DVALUE*)v;                         
        v += sizeof(D3DVALUE);                                  
    }                                                           
    pp1.clip = clipFlag; // & D3DSTATUS_CLIPUNIONALL;               
}
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - DIRECT3DDEVICEI *
// in    - clipVertex
// out   - TL vertex
//
inline void MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in)
{                                               
    BYTE *v = out;                              
    ((D3DVALUE*)v)[0] = (in)->sx;               
    ((D3DVALUE*)v)[1] = (in)->sy;               
    ((D3DVALUE*)v)[2] = (in)->sz;               
    ((D3DVALUE*)v)[3] = D3DVAL(1)/(in)->hw;     
    v += sizeof(D3DVALUE)*4;                    
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)   
    {                                           
        *(DWORD*)v = (in)->color;               
        v += sizeof(DWORD);                     
    }                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)  
    {                                           
        *(DWORD*)v = (in)->specular;            
        v += sizeof(DWORD);                     
    }                                           
    for (DWORD ii=0; ii < pv->nTexCoord; ii++)
    {                                           
        *(D3DVALUE*)v = (in)->tex[ii].u;        
        v += sizeof(D3DVALUE);                  
        *(D3DVALUE*)v = (in)->tex[ii].v;        
        v += sizeof(D3DVALUE);                  
    }                                           
}
#endif // _CLIPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#



GENSYMFLAGS = -DWIN95 
386_ASSEMBLER_NAME=ml611d
RASTROOT= $(D3DDX6)\rast
!include $(RASTROOT)\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\light.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       light.h
 *  Content:    Direct3D lighting include file
 *
 ***************************************************************************/

#ifndef __LIGHT_H__
#define __LIGHT_H__
//-----------------------------------------------------------------------
inline void LIGHT_VERTEX(LPD3DFE_PROCESSVERTICES pv, void *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DI_LIGHT  *light;
    ldrv.specularComputed = FALSE;
    ldrv.diffuse = ldrv.diffuse0;
    ldrv.specular.r = D3DVAL(0);
    ldrv.specular.g = D3DVAL(0);
    ldrv.specular.b = D3DVAL(0);

    light = ldrv.activeLights;
    while (light)
    {
        (*light->lightVertexFunc)(pv, light, (D3DLIGHTINGELEMENT*)in);
        light = light->next;
    }
    {
        int r = FTOI(ldrv.diffuse.r);
        int g = FTOI(ldrv.diffuse.g);
        int b = FTOI(ldrv.diffuse.b);
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;
        ldrv.outDiffuse =  ldrv.alpha + (r<<16) + (g<<8) + b;
        if (ldrv.specularComputed)
        {
            r = FTOI(ldrv.specular.r);
            g = FTOI(ldrv.specular.g);
            b = FTOI(ldrv.specular.b);
            if (r < 0) r = 0; else if (r > 255) r = 255;
            if (g < 0) g = 0; else if (g > 255) g = 255;
            if (b < 0) b = 0; else if (b > 255) b = 255;
            if (!(pv->dwDeviceFlags & D3DDEV_PREDX6DEVICE))
                ldrv.outSpecular =  (r<<16) + (g<<8) + b;
            else
                // DX5 used to copy diffuse alpha to the specular alpha
                // Nobody knows why, but we have to preserve the behavior
                ldrv.outSpecular =  (r<<16) + (g<<8) + b + ldrv.alpha;
        }
        else
        {
            if (!(pv->dwDeviceFlags & D3DDEV_PREDX6DEVICE))
                ldrv.outSpecular =  0;
            else
                ldrv.outSpecular =  ldrv.alpha;
        }
    }
}
//-----------------------------------------------------------------------
inline void LIGHT_VERTEX_RAMP(LPD3DFE_PROCESSVERTICES pv, void *in)
{
    D3DFE_LIGHTING &ldrv = pv->lighting;
    D3DI_LIGHT  *light;
    ldrv.specularComputed = FALSE;
    ldrv.diffuse.r = D3DVAL(0);
    ldrv.specular.r = D3DVAL(0);

    light = ldrv.activeLights;
    while (light)
    {
        (*light->lightVertexFunc)(pv, light, (D3DLIGHTINGELEMENT*)in);
        light = light->next;
    }
}
//--------------------------------------------------------------------------
#define D3DFE_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
//--------------------------------------------------------------------------
inline void FOG_VERTEX(D3DFE_LIGHTING *ldrv, D3DVALUE z)
{
    int f;
    if (z < ldrv->fog_start)
        D3DFE_SET_ALPHA(ldrv->outSpecular, 255)
    else
    if (z >= ldrv->fog_end)
        D3DFE_SET_ALPHA(ldrv->outSpecular, 0)
    else
    {
        D3DVALUE v = (ldrv->fog_end - z) * ldrv->fog_factor;
        f = FTOI(v);
        D3DFE_SET_ALPHA(ldrv->outSpecular, f)
    }
}
//--------------------------------------------------------------------------
inline void FOG_VERTEX_RAMP(D3DFE_LIGHTING *ldrv, D3DVALUE z)
{
    int f;
    if (z > ldrv->fog_start)
    {
        if (z >= ldrv->fog_end)
        {
            ldrv->specular.r = D3DVAL(0);
            ldrv->diffuse.r = D3DVAL(0);
        }
        else
        {
            D3DVALUE v = (ldrv->fog_end - z) * ldrv->fog_factor_ramp;
            ldrv->specular.r *= v;
            ldrv->diffuse.r *= v;
        }
    }
}
//--------------------------------------------------------------------------
inline void MAKE_VERTEX_COLOR_RAMP(D3DFE_PROCESSVERTICES *pv, D3DTLVERTEX *vertex)
{
    D3DVALUE v;
    if (pv->lighting.diffuse.r > 1.0f)
        pv->lighting.diffuse.r = 1.0f;
    else
    if (FLOAT_LEZ(pv->lighting.diffuse.r))
        pv->lighting.diffuse.r = 0.0f;

    if (pv->dwFlags & D3DPV_RAMPSPECULAR)
    {
        if (pv->lighting.specular.r > 1.0f)
            pv->lighting.specular.r = 1.0f;
        else
        if (FLOAT_LEZ(pv->lighting.specular.r))
            pv->lighting.specular.r = 0.0f;

        v = 0.75f * pv->lighting.diffuse.r * (1.0f - pv->lighting.specular.r) +
            pv->lighting.specular.r;
    }
    else
        v = pv->lighting.diffuse.r;
    // Should be consistent with CI_MAKE macro
    vertex->color = pv->lighting.alpha + (((DWORD)(v * pv->dvRampScale) +
                    pv->dwRampBase) << 8);
    vertex->specular = PtrToUlong(pv->lpvRampTexture);
}
//---------------------------------------------------------------------
inline void MakeColor(D3DFE_COLOR *out, DWORD inputColor)
{
    out->r = (D3DVALUE)RGB_GETRED(inputColor);
    out->g = (D3DVALUE)RGB_GETGREEN(inputColor);
    out->b = (D3DVALUE)RGB_GETBLUE(inputColor);
}

extern void D3DFE_UpdateLights(LPDIRECT3DDEVICEI);

#endif  /* __LIGHT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\d3dfei.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dfei.hpp
 *  Content:    Direct3D frontend internal include file
 *
 ***************************************************************************/
#ifndef _D3DFEI_H_
#define _D3DFEI_H_

#include "clipper.h"

#define HANDLE_TO_MAT(lpDevI, h) ((LPD3DMATRIXI) ULongToPtr(h))

void  setIdentity(D3DMATRIXI * m);

extern void UpdateXfrmLight(LPDIRECT3DDEVICEI lpDevI);
extern void MatrixProduct(D3DMATRIXI *d, D3DMATRIXI *a, D3DMATRIXI *b);
extern void  D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI);
extern void  D3DFE_ConvertExtent(LPDIRECT3DDEVICEI lpDevI, LPD3DRECTV from, LPD3DRECT to);
extern HRESULT D3DFE_InitTransform(LPDIRECT3DDEVICEI lpDevI);
extern void D3DFE_DestroyTransform(LPDIRECT3DDEVICEI lpDevI);

// Goes through all vertices and computes ramp color and texture.
// If pIn == pOut coordinates are not copied
//
extern void ConvertColorsToRamp(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pIn,
                         D3DTLVERTEX *pOut, DWORD count);
//---------------------------------------------------------------------
// Maps legacy vertex formats (D3DVERTEX, D3DTLVERTEX, D3DLVERTEX) to
// FVF vertex ID.
//
extern DWORD d3dVertexToFVF[4];
//---------------------------------------------------------------------
// Computes the Current Transformation Matrix (lpDevI->mCTM) by combining
// all matrices together
//
extern void updateTransform(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
// Clamp extents to viewport window.
// For guard band it is possible that extents are outside viewport window
// after clipping
//
inline void ClampExtents(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND &&
        !(pv->dwFlags & D3DDP_DONOTUPDATEEXTENTS))
    {
        if (pv->rExtents.x1 < pv->vcache.minX)
            pv->rExtents.x1 = pv->vcache.minX;
        if (pv->rExtents.x2 > pv->vcache.maxX)
            pv->rExtents.x2 = pv->vcache.maxX;
        if (pv->rExtents.y1 < pv->vcache.minY)
            pv->rExtents.y1 = pv->vcache.minY;
        if (pv->rExtents.y2 > pv->vcache.maxY)
            pv->rExtents.y2 = pv->vcache.maxY;
    }
}
//---------------------------------------------------------------------
// Returns TRUE if cipping is needed
//
inline BOOL CheckIfNeedClipping(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        if (pv->dwClipUnion & ~__D3DCLIP_INGUARDBAND)
            return  TRUE;
    }
    else
        if (pv->dwClipUnion)
            return  TRUE;
    return FALSE;
}
//---------------------------------------------------------------------
// Updates lighting and computes process vertices flags
//
inline HRESULT DoUpdateState(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->dwFlags & D3DPV_LIGHTING)
    {
        if (!(lpDevI->dwFlags & D3DDP_DONOTLIGHT ||
              lpDevI->lighting.hMat == NULL))
        {
            HRESULT ret;
            extern HRESULT setLights(LPDIRECT3DVIEWPORTI);
            LPDIRECT3DVIEWPORTI lpViewI = (LPDIRECT3DVIEWPORTI)
                                          (lpDevI->lpCurrentViewport);
            // only set up lights if something has changed
            if (lpViewI->bLightsChanged)
            {
                if ((ret = setLights(lpViewI)) != D3D_OK)
                {
                    D3D_ERR("failed to setup lights");
                    return ret;
                }
                lpViewI->bLightsChanged = FALSE;
            }
            lpDevI->dwFlags |= D3DPV_LIGHTING;
            if (lpDevI->dwFEFlags & D3DFE_COMPUTESPECULAR &&
                lpDevI->dwVIDOut & D3DFVF_SPECULAR)
                lpDevI->dwFlags |= D3DPV_COMPUTESPECULAR;
        }
        else
            lpDevI->dwFlags &= ~D3DPV_LIGHTING;
    }
    if (lpDevI->dwFEFlags & D3DFE_COLORVERTEX)
    {
        if (lpDevI->dwVIDIn & D3DFVF_DIFFUSE)
            lpDevI->dwFlags |= D3DPV_COLORVERTEX;
        if (lpDevI->dwVIDIn & D3DFVF_SPECULAR)
            lpDevI->dwFlags |= D3DPV_COLORVERTEXS;
    }

    UpdateXfrmLight(lpDevI);
// In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
// by vertex alpha
    lpDevI->lighting.alpha = lpDevI->lighting.materialAlpha;

    return D3D_OK;
}
//---------------------------------------------------------------------
// The following bits should be set in dwFlags before calling this function:
//
//  D3DPV_STRIDE        - if strides are used
//  D3DPV_SOA           - if SOA is used
//
inline long D3DFE_ProcessVertices(LPDIRECT3DDEVICEI lpDevI)
{
    // Update Lighting and related flags
    DoUpdateState(lpDevI);
    return lpDevI->pGeometryFuncs->ProcessVertices(lpDevI);
}
//---------------------------------------------------------------------
// Updates clip status in the device
//
// We have to mask all guard band bits
//
inline void D3DFE_UpdateClipStatus(LPDIRECT3DDEVICEI lpDevI)
{
    lpDevI->iClipStatus |= lpDevI->dwClipUnion & D3DSTATUS_CLIPUNIONALL;
    lpDevI->iClipStatus &= (~D3DSTATUS_CLIPINTERSECTIONALL |
                         ((lpDevI->dwClipIntersection & D3DSTATUS_CLIPUNIONALL) << 12));
}
#endif // _D3DFEI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\clipprim.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip primitives
 *
 * The following symbol should be defined before included this file:
 * __PROCESS_LINE_NAME  - name for a function to clip triangles
 * __INDEX_PRIM         - name for a function to clip lines
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
#ifdef __INDEX_PRIM
#define __DRAW DRAW_INDEX_PRIM
#else
#define __DRAW DRAW_PRIM
#endif

//*********************************************************************
HRESULT __PROCESS_TRI_LIST_NAME(D3DFE_PROCESSVERTICES *pv)
{
    int vertexSize3;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD      startVertex = pv->lpwIndices;
    LPWORD      index = pv->lpwIndices;
    DWORD       triangleSize;   // 3 for DrawPrimitives, 
                                // 4 for ExecuteBuffers (include wFlags)
    if (pv->dwFlags & D3DPV_INSIDEEXECUTE)
        triangleSize = 4;
    else
        triangleSize = 3;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    vertexSize3 = vertexSize*3;
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
        // PSGP implementation should not implement INSIDEEXECUTE
        if (pv->dwFlags & D3DPV_INSIDEEXECUTE)
            // Offset to the current triangle in the execute buffer
            ((LPDIRECT3DDEVICEI)pv)->dwClipIns_offset = 
                (DWORD)((BYTE*)index - (BYTE*)((LPDIRECT3DDEVICEI)pv)->lpbClipIns_base);
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {// This tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                DWORD vertexCount = primitiveCount*3;
                ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                             vertexCount, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = index + triangleSize;
#else
            pv->dwVertexBase += 3;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize3;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped
            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                p1 = vertex + v1*vertexSize;
                p2 = vertex + v2*vertexSize;
                p3 = vertex + v3*vertexSize;
#else
                p1 = vertex;
                p2 = vertex + vertexSize;
                p3 = p2 + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed, clipMaskOffScreen);

#ifdef __INDEX_PRIM
                if (pv->dwFlags & D3DPV_INSIDEEXECUTE)
                    // Pass triangle flags for execute buffers
                    ret = Clip(pv, interpolate, cv, index[3]);
                else
#endif
                    ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } 
        else 
            primitiveCount++;
#ifdef __INDEX_PRIM
        index += triangleSize;
#else
        clipCode += 3;
        vertex += vertexSize3;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                     primitiveCount*3, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT __PROCESS_TRI_STRIP_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD lastIndex;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int           primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    lastIndex = pv->dwNumPrimitives;
    for (i=0; i < lastIndex; i++) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        v1 = index[0];
        v2 = index[1];
        v3 = index[2];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                             primitiveCount+2, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += primitiveCount;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[1];
#else
            pv->dwVertexBase++;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + vertexSize;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                if (i & 1)
                { // For odd triangles we have to change orientation
                  // First vertex should remain the first, because it defines
                  // the color in FLAT shade mode
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v3*vertexSize;
                    p3 = vertex + v2*vertexSize;
                }
                else
                {
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v2*vertexSize;
                    p3 = vertex + v3*vertexSize;
                }

#else
                p1 = vertex;
                if (i & 1)
                { // For odd triangles we have to change orientation
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p3 = vertex + vertexSize;
                    p2 = p3 + vertexSize;
                }
                else
                {
                    p2 = vertex + vertexSize;
                    p3 = p2 + vertexSize;
                }
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed, clipMaskOffScreen);

                ret = Clip(pv, interpolate, cv);
                if (ret) return ret;
            }
        } 
        else 
        {
            if (primitiveCount == 0 && i & 1)
            { // Triangle strip can not start from an odd triangle
              // Because we use triangle fan, first vertex in the strip
              // should be the second in the fan. 
              // This vertex defines the color in FLAT shading case.
                BYTE tmp[__MAX_VERTEX_SIZE*3];
                BYTE *p = tmp;
#ifdef __INDEX_PRIM
                BYTE *saveVer = (BYTE*)pv->lpvOut;   
                DWORD numVer = pv->dwNumVertices;  
                memcpy (p, vertex + v2*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v1*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v3*vertexSize, vertexSize);
#else
                memcpy(p, vertex + vertexSize, vertexSize);
                p += vertexSize;
                memcpy(p, vertex, vertexSize);
                p += vertexSize;
                memcpy(p, vertex + vertexSize + vertexSize, vertexSize);
#endif
                pv->dwFlags |= D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED; // Mark this call as gen by clipper
                ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, tmp, 3, 1);
                pv->dwFlags &= ~(D3DPV_CLIPPERPRIM | D3DPV_NONCLIPPED);
                if (ret)
                    return ret;
                primitiveCount = 0;
#ifdef __INDEX_PRIM
                startVertex = &index[1];
                pv->lpvOut = saveVer;
                pv->dwNumVertices = numVer;
#else
                pv->dwVertexBase++;
                D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
                startVertex = vertex + vertexSize;
#endif
            }   
            else
                primitiveCount++;
        }
#ifdef __INDEX_PRIM
        index++;
#else
        clipCode++;
        vertex += vertexSize;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                     primitiveCount+2, primitiveCount);
        if (ret)
            return ret;
#ifndef __INDEX_PRIM
        pv->dwVertexBase += primitiveCount;
#endif
    }
    return D3D_OK;
} 
//-----------------------------------------------------------------------------
// The same functions is used for line lists and line strips
//
HRESULT __PROCESS_LINE_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD nextLineOffset;       // How many vertices to skip, when going to 
                                // next primitive (1 for strips, 2 for lists)
    DWORD countAdd;             // Used to compute "real" number of vertices
                                // from the vertexCount
    D3DPRIMITIVETYPE primType;
    int numPrim = 0;
    DWORD clipMaskOffScreen;                                
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    int         interpolate;                                
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPWORD index = pv->lpwIndices;                               
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         vertexCount;    // Primitive count for line strips, 
                                // vertex count for line lists
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    interpolate = SetInterpolationFlags(pv);            
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)               
    {                                                       
        clipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;         
    }                                                       
    else                                                    
    {                                                       
        clipMaskOffScreen = 0xFFFFFFFF;                     
    }

    primType = pv->primType;
    if (primType == D3DPT_LINESTRIP)
    {
        nextLineOffset = 1;
        countAdd = 1;
    }
    else
    {
        nextLineOffset = 2;
        countAdd = 0;
    }
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        WORD f1, f2;
#ifdef __INDEX_PRIM
        WORD v1, v2;
        v1 = index[0];
        v2 = index[1];
        f1 = clipCode[v1];
        f2 = clipCode[v2];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2) 
            offFrustum = TRUE;
        else
        if ((f1 | f2) & clipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {      // if this line does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                pv->dwVertexBase += vertexCount;
#endif
            }
            // reset count and start ptr
            vertexCount = 0;
            numPrim = 0;
#ifdef __INDEX_PRIM
            startVertex = &index[nextLineOffset];
#else
            pv->dwVertexBase += nextLineOffset;
            D3D_INFO(7, "VertexBase:%08lx", pv->dwVertexBase);
            startVertex = vertex + nextLineOffset*vertexSize;
#endif

            // now deal with the single clipped line
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
#ifdef __INDEX_PRIM
                BYTE *p1 = vertex + v1*vertexSize;
                BYTE *p2 = vertex + v2*vertexSize;
#else
                BYTE *p1 = vertex;
                BYTE *p2 = vertex + vertexSize;
#endif
                ClipTriangle newline;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed, clipMaskOffScreen);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed, clipMaskOffScreen);

                newline.v[0] = &cv[0];
                newline.v[1] = &cv[1];

                if (ClipSingleLine(pv, &newline, &pv->rExtents, interpolate))
                {
                    BYTE *pTLV = (BYTE*)pv->ClipperState.clipBuf.GetAddress();
                    BYTE *p = pTLV;
#ifdef __INDEX_PRIM
                    BYTE *saveVer = (BYTE*)pv->lpvOut;  
                    DWORD numVer = pv->dwNumVertices; 
#endif
                    MAKE_TL_VERTEX_FVF(pv, p, newline.v[0]);
                    p += vertexSize;
                    MAKE_TL_VERTEX_FVF(pv, p, newline.v[1]);
                    pv->dwFlags |= D3DPV_CLIPPERPRIM; // Mark this call as gen by clipper
                    ret = DRAW_PRIM(pv, D3DPT_LINELIST, pTLV, 2, 1);
                    pv->dwFlags &= ~D3DPV_CLIPPERPRIM;
                    if (ret)
                        return ret;

#ifdef __INDEX_PRIM
                    pv->lpvOut = saveVer;
                    pv->dwNumVertices = numVer;
#endif
                }
            }
        } 
        else 
        {
            vertexCount += nextLineOffset;
            numPrim++;
        }
#ifdef __INDEX_PRIM
        index += nextLineOffset;
#else
        vertex += nextLineOffset*vertexSize;
        clipCode += nextLineOffset;
#endif
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
        if (ret)
            return ret;
    }
    return D3D_OK;
}

#undef __DRAW
#undef __INDEX_PRIM
#undef __PROCESS_LINE_NAME
#undef __PROCESS_TRI_LIST_NAME
#undef __PROCESS_TRI_STRIP_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\procver.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       procver.h
 *  Content:    Generic implementation for process vertices function
 *
 * This file is included several times with different defines:
 * _PV_NAME     - function name
 * _PV_EXTENT   - if updating extent is required
 * _PV_CLIP     - if clipping is required
 * _PV_VIEWPORT - if the function is used by TransformVertices call
 * _PV_LVERTEX  - if D3DLVERTEX is used as input
 * _PV_APPLY_LIGHT  - if lighting is required
 * _PV_FOG      - if fog is required
 *
 ***************************************************************************/

//--------------------------------------------------------------------------
// Viewport->TransformVertices
// For clipped and unclipped cases
// for unclipped case H vertices should not be written
//
long _PV_NAME(D3DFE_PROCESSVERTICES *pv, DWORD count, LPD3DTRANSFORMDATAI data)
{
    // We use power of 2 because it preserves the mantissa when we multiply
    const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;
    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    D3DLVERTEX* in  = (LPD3DLVERTEX)data->lpIn;
    size_t in_size = data->dwInSize;
    D3DTLVERTEX *out  =(LPD3DTLVERTEX) data->lpOut;
    size_t out_size =  data->dwOutSize;
    DWORD i;
    DWORD flags = pv->dwFlags;
#ifdef _PV_CLIP
    D3DHVERTEX *hout = data->lpHOut;
    int clip_intersection = ~0;
    int clip_union = 0;
#endif // _PV_CLIP
    D3DVALUE minx, maxx, miny, maxy;

    minx = data->drExtent.x1;
    miny = data->drExtent.y1;
    maxx = data->drExtent.x2;
    maxy = data->drExtent.y2;
    D3DFE_VIEWPORTCACHE& VPORT = pv->vcache;
    for (i = count; i; i--) 
    {
#ifdef _PV_CLIP
        int clip;
#endif // _PV_CLIP
        float x, y, z, w, we;

        x = in->x*pv->mCTM._11 + in->y*pv->mCTM._21 + 
            in->z*pv->mCTM._31 + pv->mCTM._41;
        y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + 
            in->z*pv->mCTM._32 + pv->mCTM._42;
        z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + 
            in->z*pv->mCTM._33 + pv->mCTM._43;
        we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + 
            in->z*pv->mCTM._34 + pv->mCTM._44;
#ifdef _PV_CLIP
        hout->hx = x * VPORT.imclip11 + we * VPORT.imclip41;
        hout->hy = y * VPORT.imclip22 + we * VPORT.imclip42;
        hout->hz = z * VPORT.imclip33 + we * VPORT.imclip43;
        {
            D3DVALUE xx = we - x;
            D3DVALUE yy = we - y;
            D3DVALUE zz = we - z;
            clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCLIP_LEFT
                   ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCLIP_BOTTOM
                   ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCLIP_FRONT 
                   ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCLIP_RIGHT
                   ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCLIP_TOP   
                   ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCLIP_BACK
        }

        if (clip == 0) 
#endif // _PV_CLIP
        {
            w = D3DVAL(1)/we;
#ifdef _PV_CLIP
            clip_intersection = 0;
#endif // _PV_CLIP
            x = x * w * VPORT.scaleX + VPORT.offsetX;
            y = y * w * VPORT.scaleY + VPORT.offsetY;
            if (x < minx) minx = x;
            if (x > maxx) maxx = x;
            if (y < miny) miny = y;
            if (y > maxy) maxy = y;
            out->sx = x;
            out->sy = y;
            out->sz = z*w;
            out->rhw = w;
        }
#ifdef _PV_CLIP
        else
        {
            if (!FLOAT_EQZ(we))
                out->rhw = D3DVAL(1)/we;
            else
                out->rhw = __HUGE_PWR2;
            clip_intersection &= clip;
            clip_union |= clip;
        }
        hout->dwFlags = clip;
        hout++;
#endif // !_PV_CLIP

        out->tu = in->tu;
        out->tv = in->tv;
        out->color = in->color;
        out->specular = in->specular;

        in = (D3DLVERTEX*) ((char*) in + in_size);
        out = (D3DTLVERTEX*) ((char*) out + out_size);
    }

    /*
     * extend to cover lines. XXX
     */
    maxx += pv->dvExtentsAdjust;
    maxy += pv->dvExtentsAdjust;
    minx -= pv->dvExtentsAdjust;
    miny -= pv->dvExtentsAdjust;
#ifndef _PV_CLIP
    /* Clamp to viewport */
    /* Clamp for legacy apps */
    if (minx < VPORT.minX || miny < VPORT.minY || 
        maxx > VPORT.maxX || maxy > VPORT.maxY)
#endif // _PV_CLIP
    {
        /* Clamp to viewport */
        if (minx < VPORT.minX)
            minx = VPORT.minX;
        if (miny < VPORT.minY)
            miny = VPORT.minY;
        if (maxx > VPORT.maxX)
            maxx = VPORT.maxX;
        if (maxy > VPORT.maxY)
            maxy = VPORT.maxY;
#ifndef _PV_CLIP
        if(pv->dwDeviceFlags & D3DDEV_PREDX5DEVICE)
        { /* Clamp vertices */
            int i;
            D3D_WARN(4, "Old semantics: Clamping Vertices");
            for (i = count, out = (LPD3DTLVERTEX)data->lpOut; i; i--)
            {
                if (out->sx < VPORT.minX) out->sx = VPORT.minX;
                if (out->sx > VPORT.maxX) out->sx = VPORT.maxX;
                if (out->sy < VPORT.minY) out->sy = VPORT.minY;
                if (out->sy > VPORT.maxY) out->sy = VPORT.maxY;

                out = (D3DTLVERTEX*) ((char*) out + out_size);
            }
        }
#endif // _PV_CLIP
    }
    data->drExtent.x1 = minx;   
    data->drExtent.y1 = miny;
    data->drExtent.x2 = maxx;
    data->drExtent.y2 = maxy;
#ifdef _PV_CLIP
    data->dwClipIntersection = clip_intersection;
    data->dwClipUnion = clip_union;
    return clip_intersection;
#else
    return 0;
#endif // _PVCLIP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\pipeln\inc\pentium2.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993,1994,1995,1996,1997  Intel Corporation. 
;*
;*/

.486P

;RDPMC
rdpmc macro 
		db 0Fh
		db 033h
endm

;UD2
ud2 macro 
		db 0Fh
		db 0Bh
endm

;FCOMI Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fcomi>
fcomi macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DBh
		db 0F0h + freg
y:
endm

;FCOMIP Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fcomip>
fcomip macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DFh
		db 0F0h + freg
y:
endm

;FUCOMI Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fucomi>
fucomi macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DBh
		db 0E8h + freg
y:
endm

;FUCOMIP Compare Real and Set EFLAGS
OPTION NOKEYWORD:<fucomip>
fucomip macro dst:req, src:req
	local x, y
	
	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db 0DFh
		db 0E8h + freg
y:
endm


;FCMOVB FCMOVE FCMOVBE FCMOVU FCMOVNB FCMOVNE FCMOVNBE FCMOVNU
;These instructions are reserved by the assembler but complains if
;you try use them.  Undefine them before we build the macros
OPTION NOKEYWORD:<fcmovb fcmove fcmovbe fcmovu fcmovnb fcmovne fcmovnbe fcmovnu>
Mfcmov macro dst:req, src:req, op1, op2
	local x, y

	IF (OPATTR(src)) AND 00010000y ; register
		freg = @SubStr(src,4,1)
	ELSE
		ERROR INVALID SOURCE REGISTER (src)
	ENDIF

x:
		FADD dst, src
		org x
		db op1
		db op2 + freg
y:
endm

;Need to validate arguments 
MDfcmovd macro op1:req, op2:req, ex1:req
	fcmov&ex1 macro dst:req, src:req
		Mfcmov dst, src, op1, op2
	endm
endm

MDfcmovd 0DAh, 0C0h, b
MDfcmovd 0DAh, 0C8h, e
MDfcmovd 0DAh, 0D0h, be
MDfcmovd 0DAh, 0D8h, u
MDfcmovd 0DBh, 0C0h, nb
MDfcmovd 0DBh, 0C8h, ne
MDfcmovd 0DBh, 0D0h, nbe
MDfcmovd 0DBh, 0D8h, nu


;CMOVxxx
cmovop_   macro   op:req, dst:req, src:req
        local   x, y

	IF (OPATTR(dst)) AND 00010000y ; register
x:
		bsf	dst, src
y:
   		org     x+1
		db	op
		org     y
	ELSE
		ERROR INVALID DESTINATION REGISTER (dst)
	ENDIF
endm

cmovdf_ macro   code:req, ex1:req, ex2, ex3

	cmov&ex1    macro   dst:req, src:req
		cmovop_ code, dst, src
	endm

    ifnb  <ex2>

	cmov&ex2    macro   dst:req, src:req
		cmovop_ code, dst, src
	endm

    endif

    ifnb  <ex3>

	cmov&ex3    macro   dst:req, src:req
		cmovop_ code, dst, src
	endm

    endif

endm

cmovdf_	040h,	o
cmovdf_ 041h,   no
cmovdf_ 042h,   b,	nae,	c
cmovdf_ 043h,   ae,	nb,	nc
cmovdf_ 044h,   e,	z
cmovdf_ 045h,   ne,	nz
cmovdf_ 046h,   be,	na
cmovdf_ 047h,   a,	nbe
cmovdf_ 048h,   s
cmovdf_ 049h,   ns
cmovdf_ 04Ah,   p,	pe
cmovdf_ 04Bh,   np,	po
cmovdf_ 04Ch,   l,	nge
cmovdf_ 04Dh,   ge,	nl
cmovdf_ 04Eh,   le,	ng
cmovdf_ 04Fh,   g,	nle
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\makefile.inc ===
$(GENTGT)\mcrbd_mh.h: ..\mcrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\mcrgn_mh.h: ..\mcrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtest_mh.h: ..\mtest_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtx1a_mh.h: ..\mtx1a_mh.mh ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtx2a_mh.h: ..\mtx2a_mh.mh ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtxbd_mh.h: ..\mtxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtxrd_mh.h: ..\mtxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\mtstf_mh.h: ..\mtstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\matest_mh.h: ..\matest_mh.mh $(RAST_STD_M4)

$(GENTGT)\mbeadtbl.cpp: ..\mbeadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\mclrbld.cpp: ..\mclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\mclrgen.cpp: ..\mclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\mloop.cpp: ..\mloop.mcp ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtest.cpp: ..\mtest.mcp $(RAST_STD_M4)

$(GENTGT)\mtx1addr.cpp: ..\mtx1addr.mcp ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtx2addr.cpp: ..\mtx2addr.mcp ..\mtexaddr.mh $(RAST_STD_M4)

$(GENTGT)\mtxblend.cpp: ..\mtxblend.mcp $(RAST_STD_M4)

$(GENTGT)\mtexread.cpp: ..\mtexread.mcp $(RAST_STD_M4)

$(GENTGT)\matest.cpp: ..\matest.mcp $(RAST_STD_M4)

$(GENTGT)\mtstfail.cpp: ..\mtstfail.mcp ..\mtexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void CMMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void CMMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void CMMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void CMMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void CMMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];

//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0xff);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        0x8000;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | 0x8000;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void CMMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void CMMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void CMMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_B5G5R5A1(PUINT8 pBits)
{
    UINT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format. 
//
//-----------------------------------------------------------------------------
D3DCOLOR CMMX_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will 
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR CMMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR CMMX_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void CMMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnutil.cpp ===
//----------------------------------------------------------------------------
//
// mspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnpars.h ===
//----------------------------------------------------------------------------
//
// mspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT CMMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// CMMX_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT CMMX_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mtexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mspnutil.h ===
//----------------------------------------------------------------------------
//
// mspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\mtexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "mtexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // can be MMX_mulhw's
    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential MMX implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\sources.inc ===
TARGETNAME = rcmxspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\matest.cpp\
        $O\mbeadtbl.cpp\
        ..\mbldfncs.cpp\
        ..\mbufread.cpp\
        ..\mbufwrt.cpp\
        $O\mclrbld.cpp\
        $O\mclrgen.cpp\
        $O\mloop.cpp\
        ..\mspnpars.cpp\
        ..\mspnutil.cpp\
        $O\mtest.cpp\
        $O\mtx1addr.cpp\
        $O\mtx2addr.cpp\
        $O\mtxblend.cpp\
        ..\mtexfilt.cpp\
        $O\mtexread.cpp\
        $O\mtstfail.cpp

NTTARGETFILE0 = \
        $O\matest_mh.h\
        $O\mcrbd_mh.h\
        $O\mcrgn_mh.h\
        $O\mtest_mh.h\
        $O\mtx1a_mh.h\
        $O\mtx2a_mh.h\
        $O\mtxbd_mh.h\
        $O\mtxrd_mh.h\
        $O\mtstf_mh.h\
        $O\mbeadtbl.cpp\
        $O\mclrbld.cpp\
        $O\mclrgen.cpp\
        $O\mloop.cpp\
        $O\mtest.cpp\
        $O\mtx1addr.cpp\
        $O\mtx2addr.cpp\
        $O\mtxblend.cpp\
        $O\mtexread.cpp\
        $O\matest.cpp\
        $O\mtstfail.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "mspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cmmxspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits)
{
    INT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];
//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0x00);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "cbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC)<<8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// C_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\ctexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnutil.cpp ===
//----------------------------------------------------------------------------
//
// cspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnpars.h ===
//----------------------------------------------------------------------------
//
// cspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\cspnutil.h ===
//----------------------------------------------------------------------------
//
// cspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\ctexfilt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "ctexfilt.h"

//-----------------------------------------------------------------------------
//
// TexFiltBilinear
//
// Given the basic bilinear equations
//
// A = C00 + U*(C10 - C00)
// B = C01 + U*(C11 - C01)
// C = A + V*(B-A)
//
// This routine is based on the re-arrangement of this equation into
//
// C = C00*(1-U-V+U*V) + C10*(U-U*V) + C10(V-U*V) + C11*(U*V)
// or
// C = C00*s1 + C10*s2 + C10*s3 + C11*s4
//
//-----------------------------------------------------------------------------
void TexFiltBilinear(D3DCOLOR *pOut, INT32 iU, INT32 iV, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11)
{
#define SIMPLE_BILINEAR 1
#ifdef SIMPLE_BILINEAR
    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    r00 = r00 + ((iU*(r10 - r00)) >> 16);
    g00 = g00 + ((iU*(g10 - g00)) >> 16);
    b00 = b00 + ((iU*(b10 - b00)) >> 16);
    a00 = a00 + ((iU*(a10 - a00)) >> 16);

    r01 = r01 + ((iU*(r11 - r01)) >> 16);
    g01 = g01 + ((iU*(g11 - g01)) >> 16);
    b01 = b01 + ((iU*(b11 - b01)) >> 16);
    a01 = a01 + ((iU*(a11 - a01)) >> 16);

    r00 = r00 + ((iV*(r01 - r00)) >> 16);
    g00 = g00 + ((iV*(g01 - g00)) >> 16);
    b00 = b00 + ((iV*(b01 - b00)) >> 16);
    a00 = a00 + ((iV*(a01 - a00)) >> 16);

#else
    // another potential implementation
    INT32 s1, s2, s3, s4;
    s4 = (iU * iV)>>16;         // (0.16 * 0.16) >> 16 = 0.16
    s3 = iV - s4;
    s2 = iU - s4;
    s1 = 0x10000 - iV - s2;

    INT32 r00, r01, r10, r11;
    INT32 g00, g01, g10, g11;
    INT32 b00, b01, b10, b11;
    INT32 a00, a01, a10, a11;

    r00 = RGBA_GETRED(uTex00);
    r01 = RGBA_GETRED(uTex01);
    r10 = RGBA_GETRED(uTex10);
    r11 = RGBA_GETRED(uTex11);

    g00 = RGBA_GETGREEN(uTex00);
    g01 = RGBA_GETGREEN(uTex01);
    g10 = RGBA_GETGREEN(uTex10);
    g11 = RGBA_GETGREEN(uTex11);

    b00 = RGBA_GETBLUE(uTex00);
    b01 = RGBA_GETBLUE(uTex01);
    b10 = RGBA_GETBLUE(uTex10);
    b11 = RGBA_GETBLUE(uTex11);

    a00 = RGBA_GETALPHA(uTex00);
    a01 = RGBA_GETALPHA(uTex01);
    a10 = RGBA_GETALPHA(uTex10);
    a11 = RGBA_GETALPHA(uTex11);

    // 8.0 * 0.16 == 8.16 >> 16 == 8.0
    r00 = (r00*s1 + r10*s2 + r01*s3 + r11*s4)>>16;
    g00 = (g00*s1 + g10*s2 + g01*s3 + g11*s4)>>16;
    b00 = (b00*s1 + b10*s2 + b01*s3 + b11*s4)>>16;
    a00 = (a00*s1 + a10*s2 + a01*s3 + a11*s4)>>16;
#endif

    *pOut = RGBA_MAKE(r00, g00, b00, a00);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\makefile.inc ===
$(GENTGT)\ccrbd_mh.h: ..\ccrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ccrgn_mh.h: ..\ccrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctest_mh.h: ..\ctest_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctx1a_mh.h: ..\ctx1a_mh.mh ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctx2a_mh.h: ..\ctx2a_mh.mh ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxbd_mh.h: ..\ctxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxrd_mh.h: ..\ctxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctstf_mh.h: ..\ctstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\catest_mh.h: ..\catest_mh.mh $(RAST_STD_M4)

$(GENTGT)\cbeadtbl.cpp: ..\cbeadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\cclrbld.cpp: ..\cclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\cclrgen.cpp: ..\cclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\cloop.cpp: ..\cloop.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctest.cpp: ..\ctest.mcp $(RAST_STD_M4)

$(GENTGT)\ctx1addr.cpp: ..\ctx1addr.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctx2addr.cpp: ..\ctx2addr.mcp ..\ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxblend.cpp: ..\ctxblend.mcp $(RAST_STD_M4)

$(GENTGT)\ctexread.cpp: ..\ctexread.mcp $(RAST_STD_M4)

$(GENTGT)\catest.cpp: ..\catest.mcp $(RAST_STD_M4)

$(GENTGT)\ctstfail.cpp: ..\ctstfail.mcp ..\ctexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "cspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\makefile.inc ===
$(GENTGT)\pmfns_mh.h: ..\pmfns_mh.mh $(RAST_STD_M4)

$(GENTGT)\pmfns.cpp: ..\pmfns.mcp $(RAST_STD_M4)

$(GENTGT)\dprim2.cpp: ..\dprim2.mcp $(RAST_STD_M4)

$(GENTGT)\refif.cpp: ..\refif.mcp $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\d3dif.cpp ===
//----------------------------------------------------------------------------
//
// d3dif.cpp
//
// shared interface functions
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to D3DI_SPANTEX_FORMAT.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt)
{
    if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = D3DI_SPTFMT_Z16S0; break;
        case 0xFFFFFF00: *pFmt = D3DI_SPTFMT_Z24S8; break;
        case 0x0000FFFE: *pFmt = D3DI_SPTFMT_Z15S1; break;
        case 0xFFFFFFFF: *pFmt = D3DI_SPTFMT_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 24:
                *pFmt = D3DI_SPTFMT_U8V8L8;
                break;
            case 16:
                *pFmt = D3DI_SPTFMT_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = D3DI_SPTFMT_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        *pFmt = D3DI_SPTFMT_PALETTE8;
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = D3DI_SPTFMT_PALETTE4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = D3DI_SPTFMT_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = D3DI_SPTFMT_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = D3DI_SPTFMT_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = D3DI_SPTFMT_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = D3DI_SPTFMT_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = D3DI_SPTFMT_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = D3DI_SPTFMT_DXT5;
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = D3DI_SPTFMT_B8G8R8X8;
                break;
            case 24:
                *pFmt = D3DI_SPTFMT_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = D3DI_SPTFMT_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = D3DI_SPTFMT_B5G5R5A1;
            }
            else
            {
                *pFmt = D3DI_SPTFMT_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = D3DI_SPTFMT_B5G5R5;
            break;
        case 0xff0:
            *pFmt = D3DI_SPTFMT_B4G4R4;
            break;
        case 0xfff0:
            *pFmt = D3DI_SPTFMT_B4G4R4A4;
            break;
        case 0xff:
            *pFmt = D3DI_SPTFMT_L8;
            break;
        case 0xffff:
            *pFmt = D3DI_SPTFMT_L8A8;
            break;
        case 0xfc:
            *pFmt = D3DI_SPTFMT_B2G3R3;
            break;
        default:
            *pFmt = D3DI_SPTFMT_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidTextureSize
//
// checks for power of two texture size
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                 INT16 ivSize, INT16 ivShift)
{
    if (iuSize == 1)
    {
        if (ivSize == 1)
        {
            return TRUE;
        }
        else
        {
            return !(ivSize & (~(1 << ivShift)));
        }
    }
    else
    {
        if (ivSize == 1)
        {
            return !(iuSize & (~(1 << iuShift)));
        }
        else
        {
            return (!(iuSize & (~(1 << iuShift)))
                    && !(iuSize & (~(1 << iuShift))));
        }
    }
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}


//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_TEXTURE_FORMATS   22

int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType)
{
    int i = 0;

    if (RastType == SW_RAST_MMX && dwVersion < 3)
    {
        static DDSURFACEDESC mmx_ddsd[1];

        /* pal8 */
        mmx_ddsd[i].dwSize = sizeof(mmx_ddsd[0]);
        mmx_ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        mmx_ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        mmx_ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        mmx_ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
        mmx_ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

        i++;

        *lplpddsd = mmx_ddsd;

        return i;
    }

    static DDSURFACEDESC ddsd_RefNull_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RefNull_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RGBMMX_Dev3[NUM_SUPPORTED_TEXTURE_FORMATS];
    static DDSURFACEDESC ddsd_RGBMMX_Dev2[NUM_SUPPORTED_TEXTURE_FORMATS];
    DDSURFACEDESC *ddsd;

    if (RastType == SW_RAST_REFNULL)
    {
        if (dwVersion >= 3)
        {
            ddsd = ddsd_RefNull_Dev3;
        }
        else
        {
            ddsd = ddsd_RefNull_Dev2;
        }
    }
    else
    {
        if (dwVersion >= 3)
        {
            ddsd = ddsd_RGBMMX_Dev3;
        }
        else
        {
            ddsd = ddsd_RGBMMX_Dev2;
        }
    }

    /* 888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 8888 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;

    i++;

    /* 565 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xf800;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x07e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* 555 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
    ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

    i++;

    /* pal4 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;

    i++;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    if ((dwVersion >= 3) || (RastType == SW_RAST_REFNULL))
    {
        /* 1555 */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0x7c00;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x03e0;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x001f;

        i++;

        // A formats for PC98 consistency
        // 4444 ARGB (it is already supported by S3 Virge)
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
        ddsd[i].ddpfPixelFormat.dwRBitMask        = 0x0f00;
        ddsd[i].ddpfPixelFormat.dwGBitMask        = 0x00f0;
        ddsd[i].ddpfPixelFormat.dwBBitMask        = 0x000f;

        i++;
    }

    if ((dwVersion >= 2) && (RastType == SW_RAST_REFNULL))
    {
        // 332 8-bit RGB
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwRBitMask = 0xe0;
        ddsd[i].ddpfPixelFormat.dwGBitMask = 0x1c;
        ddsd[i].ddpfPixelFormat.dwBBitMask = 0x03;

        i++;
    }

    if (dwVersion >= 3)
    {
        /* 8 bit luminance-only */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        /* 16 bit alpha-luminance */
        ddsd[i].dwSize = sizeof(ddsd[0]);
        ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
        ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
        ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
        ddsd[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
        ddsd[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff00;
        ddsd[i].ddpfPixelFormat.dwLuminanceBitMask = 0xff;

        i++;

        if (RastType == SW_RAST_REFNULL)
        {
            // A couple of formats for PC98 consistency
            // UYVY
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('U', 'Y', 'V', 'Y');

            i++;

            // YVY2
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('Y', 'U', 'Y', '2');

            i++;

            // S3 compressed texture format 1
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '1');

            i++;

            // S3 compressed texture format 2
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '2');

            i++;

            // S3 compressed texture format 3
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '3');

            i++;

            // S3 compressed texture format 4
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '4');

            i++;

            // S3 compressed texture format 5
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_FOURCC;
            ddsd[i].ddpfPixelFormat.dwFourCC = MAKEFOURCC('D', 'X', 'T', '5');

            i++;

            // Add a few bump map formats
            // U8V8
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV;
            ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
            ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x00ff;
            ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0xff00;
            ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0x0;

            i++;

            // U5V5L6
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
                                              DDPF_BUMPLUMINANCE;
            ddsd[i].ddpfPixelFormat.dwBumpBitCount = 16;
            ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x001f;
            ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x03e0;
            ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xfc00;

            i++;

            // U8V8L8
            ddsd[i].dwSize = sizeof(ddsd[0]);
            ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
            ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
            ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
            ddsd[i].ddpfPixelFormat.dwFlags = DDPF_BUMPDUDV |
                                              DDPF_BUMPLUMINANCE;
            ddsd[i].ddpfPixelFormat.dwBumpBitCount = 24;
            ddsd[i].ddpfPixelFormat.dwBumpDuBitMask = 0x0000ff;
            ddsd[i].ddpfPixelFormat.dwBumpDvBitMask = 0x00ff00;
            ddsd[i].ddpfPixelFormat.dwBumpLuminanceBitMask = 0xff0000;

            i++;
        }
    }

    *lplpddsd = ddsd;

    return i;
}

//----------------------------------------------------------------------------
//
// ZBufferFormats
//
// Must return union of all the Z buffer formats supported by all rasterizers.
// CreateDevice will screen out device-specific ones (i.e. ones ramp doesnt handle) later.
// Called at device creation time and by DDHEL to validate software ZBuffer
// creation.
//
//----------------------------------------------------------------------------

#define NUM_SUPPORTED_ZBUFFER_FORMATS   4

int
ZBufferFormats(DDPIXELFORMAT** ppDDPF, BOOL bIsRefOrNull)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    memset(&DDPF[0],0,sizeof(DDPF));

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;

    /* 24 bit Z; 8 bit stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
    DDPF[i].dwZBufferBitDepth = 32;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
    DDPF[i].dwStencilBitDepth = 8;
    DDPF[i].dwZBitMask = 0xffffff00;
    DDPF[i].dwStencilBitMask = 0x000000ff;

    i++;

    if (bIsRefOrNull)
    {
        /* 15 bit Z; 1 bit stencil */
        DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
        DDPF[i].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
        DDPF[i].dwZBufferBitDepth = 16;   // ZBufferBitDepth represents the total bits.  Z Bits are ZBBitDepth-StencilBitDepth
        DDPF[i].dwStencilBitDepth = 1;
        DDPF[i].dwZBitMask = 0xfffe;
        DDPF[i].dwStencilBitMask = 0x0001;

        i++;

        /* 32bit Z; no stencil */
        DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
        DDPF[i].dwFlags = DDPF_ZBUFFER;
        DDPF[i].dwZBufferBitDepth = 32;
        DDPF[i].dwStencilBitDepth = 0;
        DDPF[i].dwZBitMask = 0xffffffff;
        DDPF[i].dwStencilBitMask = 0x00000000;

        i++;
    }

    *ppDDPF = DDPF;

    return i;
}

// this fn is exported externally to be called by the directdraw HEL
DWORD WINAPI Direct3DGetSWRastZPixFmts(DDPIXELFORMAT** ppDDPF)
{
    // try to get texture formats from external DLL ref device
    PFNGETREFZBUFFERFORMATS pfnGetRefZBufferFormats;
    if (NULL != (pfnGetRefZBufferFormats =
        (PFNGETREFZBUFFERFORMATS)LoadReferenceDeviceProc("GetRefZBufferFormats")))
    {
        D3D_INFO(0,"Direct3DGetSWRastZPixFmts: getting Z buffer formats from d3dref");
        return pfnGetRefZBufferFormats(IID_IDirect3DRefDevice, ppDDPF);
    }

    // always return all formats so DDraw creates
    // all surfaces which it should
    return (DWORD) ZBufferFormats(ppDDPF, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>
#include "d3dif.hpp"
#include "swprov.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\cspan\sources.inc ===
TARGETNAME = rcspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\catest.cpp\
        $O\cbeadtbl.cpp\
        ..\cbldfncs.cpp\
        ..\cbufread.cpp\
        ..\cbufwrt.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        ..\cspnpars.cpp\
        ..\cspnutil.cpp\
        $O\ctest.cpp\
        $O\ctx1addr.cpp\
        $O\ctx2addr.cpp\
        $O\ctxblend.cpp\
        ..\ctexfilt.cpp\
        $O\ctexread.cpp\
        $O\ctstfail.cpp

NTTARGETFILE0 = \
        $O\catest_mh.h\
        $O\ccrbd_mh.h\
        $O\ccrgn_mh.h\
        $O\ctest_mh.h\
        $O\ctx1a_mh.h\
        $O\ctx2a_mh.h\
        $O\ctxbd_mh.h\
        $O\ctxrd_mh.h\
        $O\ctstf_mh.h\
        $O\cbeadtbl.cpp\
        $O\cclrbld.cpp\
        $O\cclrgen.cpp\
        $O\cloop.cpp\
        $O\ctest.cpp\
        $O\ctx1addr.cpp\
        $O\ctx2addr.cpp\
        $O\ctxblend.cpp\
        $O\ctexread.cpp\
        $O\catest.cpp\
        $O\ctstfail.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\getcaps.h ===
//----------------------------------------------------------------------------
//
// getcaps.h
//
// Legacy caps as pulled from mustard\direct3d\d3d\ddraw\getcaps.c
//
// This file is included from swprov.cpp with BUILD_RAMP set and not set,
// to pick up exactly the caps reported by the software rasterizers in DX5.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#define	MAX_CLIPPING_PLANES	12

/* Space for vertices generated/copied while clipping one triangle */

#define MAX_CLIP_VERTICES	(( 2 * MAX_CLIPPING_PLANES ) + 3 )

#define MAX_VERTEX_COUNT 2048
#define BASE_VERTEX_COUNT (MAX_VERTEX_COUNT - MAX_CLIP_VERTICES)

#define transformCaps { sizeof(D3DTRANSFORMCAPS), D3DTRANSFORMCAPS_CLIP }

#ifdef BUILD_RAMP
#define THIS_MODEL D3DLIGHTINGMODEL_MONO
#define THIS_COLOR_MODEL D3DCOLOR_MONO
#else
#define THIS_MODEL D3DLIGHTINGMODEL_RGB
#define THIS_COLOR_MODEL D3DCOLOR_RGB
#endif

#define lightingCaps {							\
    	sizeof(D3DLIGHTINGCAPS),					\
	D3DLIGHTCAPS_POINT |						\
	    D3DLIGHTCAPS_SPOT |						\
	    D3DLIGHTCAPS_DIRECTIONAL |					\
	    D3DLIGHTCAPS_PARALLELPOINT,		 			\
	THIS_MODEL,			/* dwLightingModel */		\
	0,				/* dwNumLights (infinite) */	\
}

/*
 * Software Driver caps
 */
#ifdef BUILD_RAMP
#define TRISHADECAPS					\
    D3DPSHADECAPS_COLORFLATMONO			|	\
	D3DPSHADECAPS_COLORGOURAUDMONO		|	\
	D3DPSHADECAPS_SPECULARFLATMONO		|	\
	D3DPSHADECAPS_SPECULARGOURAUDMONO	|	\
	D3DPSHADECAPS_ALPHAFLATSTIPPLED		|	\
	D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED
#else
#define TRISHADECAPS					\
    D3DPSHADECAPS_COLORFLATRGB			|	\
	D3DPSHADECAPS_COLORGOURAUDRGB		|	\
	D3DPSHADECAPS_SPECULARFLATRGB		|	\
	D3DPSHADECAPS_SPECULARGOURAUDRGB	|	\
	D3DPSHADECAPS_ALPHAFLATSTIPPLED		|	\
	D3DPSHADECAPS_ALPHAGOURAUDSTIPPLED	|	\
	D3DPSHADECAPS_FOGFLAT			|	\
	D3DPSHADECAPS_FOGGOURAUD
#endif

#ifdef BUILD_RAMP
#define TRIFILTERCAPS					   \
    D3DPTFILTERCAPS_NEAREST          | \
    D3DPTFILTERCAPS_MIPNEAREST
#else
#define TRIFILTERCAPS					   \
    D3DPTFILTERCAPS_NEAREST			 |	\
    D3DPTFILTERCAPS_LINEAR           | \
    D3DPTFILTERCAPS_MIPNEAREST		 |	\
    D3DPTFILTERCAPS_MIPLINEAR        | \
    D3DPTFILTERCAPS_LINEARMIPNEAREST
#endif

#ifndef BUILD_RAMP
#define TRIRASTERCAPS					\
    D3DPRASTERCAPS_DITHER			|	\
    	D3DPRASTERCAPS_SUBPIXELX		|	\
	D3DPRASTERCAPS_FOGVERTEX		|	\
	D3DPRASTERCAPS_FOGTABLE		|	\
	D3DPRASTERCAPS_ZTEST
#else
#define TRIRASTERCAPS					\
    D3DPRASTERCAPS_DITHER			|	\
    	D3DPRASTERCAPS_SUBPIXELX		|	\
	D3DPRASTERCAPS_ZTEST
#endif

#define triCaps {					\
    sizeof(D3DPRIMCAPS),				\
    D3DPMISCCAPS_CULLCCW | D3DPMISCCAPS_CULLCW | D3DPMISCCAPS_CULLNONE,	/* miscCaps */		\
    TRIRASTERCAPS,		/* rasterCaps */	\
    D3DPCMPCAPS_NEVER | D3DPCMPCAPS_LESS | D3DPCMPCAPS_EQUAL | D3DPCMPCAPS_LESSEQUAL | D3DPCMPCAPS_GREATER | D3DPCMPCAPS_NOTEQUAL | D3DPCMPCAPS_GREATEREQUAL | D3DPCMPCAPS_ALWAYS,	/* zCmpCaps */		\
    0,				/* sourceBlendCaps */	\
    0,				/* destBlendCaps */	\
    0,				/* alphaBlendCaps */	\
    TRISHADECAPS,		/* shadeCaps */		\
    D3DPTEXTURECAPS_PERSPECTIVE |/* textureCaps */	\
	D3DPTEXTURECAPS_POW2 |				\
	D3DPTEXTURECAPS_TRANSPARENCY,			\
    TRIFILTERCAPS,		/* textureFilterCaps */ \
    D3DPTBLENDCAPS_COPY |	/* textureBlendCaps */	\
	D3DPTBLENDCAPS_MODULATE,			\
    D3DPTADDRESSCAPS_WRAP,	/* textureAddressCaps */\
    4,				/* stippleWidth */	\
    4				/* stippleHeight */	\
}							\

static D3DDEVICEDESC devDesc = {
    sizeof(D3DDEVICEDESC),	/* dwSize */
    D3DDD_COLORMODEL |		/* dwFlags */
	D3DDD_DEVCAPS |
	D3DDD_TRANSFORMCAPS |
	D3DDD_LIGHTINGCAPS |
	D3DDD_BCLIPPING |
	D3DDD_TRICAPS |
	D3DDD_DEVICERENDERBITDEPTH |
	D3DDD_DEVICEZBUFFERBITDEPTH |
	D3DDD_MAXBUFFERSIZE |
	D3DDD_MAXVERTEXCOUNT,
    THIS_COLOR_MODEL,		/* dcmColorModel */
    D3DDEVCAPS_FLOATTLVERTEX |
	D3DDEVCAPS_SORTINCREASINGZ |
	D3DDEVCAPS_SORTEXACT |
	D3DDEVCAPS_EXECUTESYSTEMMEMORY |
	D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY |
        D3DDEVCAPS_DRAWPRIMTLVERTEX,
    transformCaps,		/* transformCaps */
    TRUE,			/* bClipping */
    lightingCaps,		/* lightingCaps */
    triCaps,			/* lineCaps */
    triCaps,			/* triCaps */
    DDBD_8 | DDBD_16 | DDBD_24 | DDBD_32, /* dwDeviceRenderBitDepth */
    DDBD_16,			/* dwDeviceZBufferBitDepth */
    0,				/* dwMaxBufferSize */
    BASE_VERTEX_COUNT		/* dwMaxVertexCount */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rampif.cpp ===
//----------------------------------------------------------------------------
//
// rampif.cpp
//
// Implements RampService.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "rampif.h"
#include "rampmat.hpp"

//----------------------------------------------------------------------------
//
// RastRampService
//
// Called by d3dim to update RampRast about material cchanges and so on.
//
//----------------------------------------------------------------------------

HRESULT
RastRampService(ULONG_PTR dwCtx,
                RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2)
{
    D3DContext *pD3DCtx = (D3DContext *)dwCtx;

    switch (srvType)
    {
    case RAMP_SERVICE_CREATEMAT    :
        return pD3DCtx->RampCreateMaterial((D3DMATERIALHANDLE) arg1);
    case RAMP_SERVICE_DESTORYMAT   :
        return pD3DCtx->RampDestroyMaterial((D3DMATERIALHANDLE) arg1);
    case RAMP_SERVICE_SETMATDATA   :
        return pD3DCtx->RampMaterialChanged((D3DMATERIALHANDLE) arg1);
    case RAMP_SERVICE_SETLIGHTSTATE:
        return pD3DCtx->RampSetLightstate((UINT32)arg1, arg2);
    case RAMP_SERVICE_FIND_LIGHTINGRANGE:
        return pD3DCtx->RampFindLightingRange((RAMP_RANGE_INFO *)arg1);
    case RAMP_SERVICE_CLEAR:
        return pD3DCtx->RampClear();
    case RAMP_SERVICE_MATERIAL_TO_PIXEL:
        return pD3DCtx->RampMaterialToPixel((D3DMATERIALHANDLE) arg1, (DWORD*) arg2);
    case RAMP_SERVICE_SCENE_CAPTURE:
        return pD3DCtx->RampSceneCapture((DWORD)arg1, (LPDIRECT3DDEVICEI)arg2);
    case RAMP_SERVICE_PALETTE_CHANGED:
        return pD3DCtx->RampPaletteChanged((D3DTEXTUREHANDLE)arg1);
    case RAMP_SERVICE_CLEAR_TEX_RECT:
        return pD3DCtx->RampClearTexRect((D3DMATERIALHANDLE)arg1, (LPD3DRECT)arg2);
    default:
        D3D_ERR("(Rast) Invalid Service type passed to RastRampService");
        return DDERR_GENERIC;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastService
//
// Generic Rasterizer service call.
//
// Only use currently is to compute the RGB8 clear color, which requires
// accessing an internal ramp map.
//
//----------------------------------------------------------------------------

HRESULT
RastService(ULONG_PTR dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2)
{
    D3DContext *pD3DCtx = (D3DContext *)dwCtx;

    switch (srvType)
    {
    case RAST_SERVICE_RGB8COLORTOPIXEL    :
        return pD3DCtx->RGB8ColorToPixel((D3DCOLOR) arg1, (DWORD*)arg2);
    default:
        D3D_ERR("(Rast) Invalid Service type passed to RastService");
        return DDERR_GENERIC;
    }
}

inline HRESULT
D3DContext::RampCreateMaterial(D3DMATERIALHANDLE hMat)
{
    return RLDDIRampCreateMaterial(
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv,
                        hMat,
                        &(m_RastCtx));
}

inline HRESULT
D3DContext::RampDestroyMaterial(D3DMATERIALHANDLE hMat)
{
    return RLDDIRampDestroyMaterial(
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv,
                        hMat);
}

inline HRESULT
D3DContext::RampMaterialChanged(D3DMATERIALHANDLE hMat)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    if (pLtDriver)
    {
        // Update the material
        HRESULT hr = RLDDIRampMaterialChanged(pLtDriver, hMat);

        RampUpdateRangeInfo();

        return hr;
    }
    else
    {
        return DDERR_GENERIC;
    }
}

inline HRESULT
D3DContext::RampSetLightstate(UINT32 uState, LPVOID pVal)
{
    RLDDIRampLightingDriver *pRampdrv =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    // d3dim has alreay filtered out invlaid light states
    switch (uState)
    {
    case D3DLIGHTSTATE_MATERIAL:
        RampSetMaterial(*((LPD3DMATERIALHANDLE)pVal));
        break;
    case D3DLIGHTSTATE_AMBIENT:
        {
            D3DCOLOR Color = *((D3DCOLOR*)pVal);
            pRampdrv->driver.ambient = (FLOAT)(RGBA_GETRED(Color) * 0x4c + RGBA_GETGREEN(Color) * 0x96 +
                RGBA_GETBLUE(Color) * 0x1d) * (1.0F/(256.0F*255.0F));
        }
        break;
    case D3DLIGHTSTATE_FOGMODE:
        pRampdrv->driver.fog_mode = *((D3DFOGMODE*)pVal);
        break;
    case D3DLIGHTSTATE_FOGSTART:
        pRampdrv->driver.fog_start = *((FLOAT*)pVal);
        break;
    case D3DLIGHTSTATE_FOGEND:
        pRampdrv->driver.fog_end = *((FLOAT*)pVal);
        break;
    case D3DLIGHTSTATE_FOGDENSITY:
        pRampdrv->driver.fog_density = *((FLOAT*)pVal);
        break;
    case D3DLIGHTSTATE_COLORMODEL:
        pRampdrv->driver.color_model = *((D3DCOLORMODEL*)pVal);
        break;
    }
    return D3D_OK;
}

inline void
D3DContext::BeginSceneHook(void)
{
    RLDDIRampBeginSceneHook((RLDDIRampLightingDriver*)m_RastCtx.pRampDrv);
    RampUpdateRangeInfo();
}

inline void
D3DContext::EndSceneHook(void)
{
    RLDDIRampEndSceneHook((RLDDIRampLightingDriver*)m_RastCtx.pRampDrv);
}

inline HRESULT
D3DContext::RampMaterialToPixel(D3DMATERIALHANDLE hMat, DWORD* pPixel)
{
    *pPixel = RLDDIRampMaterialToPixel(
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv,
                        hMat);
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastClearRamp
//
// This is for RampRast only.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::RampClear(void)
{
    // We only need to call BeginSceneHook here
    BeginSceneHook();

    return D3D_OK;
}

inline void
D3DContext::RampUpdateRangeInfo(void)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;

    if (pLtDriver && pLtDriver->current_material)
    {
        // Update the ramp info. in RastCtx
        pLtDriver->current_material->FindLightingRange(
                             &(m_RastCtx.RampBase),
                             &(m_RastCtx.RampSize),
                             &(m_RastCtx.bRampSpecular),
                             (unsigned long**)&(m_RastCtx.pTexRampMap));

        // Make sure DD Palette is updated after it gets set by FindLightingRange
        RLDDIRampUpdateDDPalette(&m_RastCtx);
    }
}
inline void
D3DContext::RampSetMaterial(D3DMATERIALHANDLE hMat)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    RLDDIRampSetMaterial(pLtDriver, hMat);
    // Update the ramp info. in RastCtx
    RampUpdateRangeInfo();
}

inline HRESULT
D3DContext::RampFindLightingRange(RAMP_RANGE_INFO *pRampInfo)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;

    if (pLtDriver && pLtDriver->current_material)
    {
        RampUpdateRangeInfo();

        pRampInfo->base = m_RastCtx.RampBase;
        pRampInfo->size = m_RastCtx.RampSize;
        pRampInfo->specular = m_RastCtx.bRampSpecular;
        pRampInfo->pTexRampMap = m_RastCtx.pTexRampMap;

        return D3D_OK;
    }
    else
    {
        return DDERR_GENERIC;
    }
}

//-----------------------------------------------------------------------------
//
// RampSceneCapture
//
// Called on either begin or end scene to perform needed deferred operations on
// ramp materials and palettes.
//
//-----------------------------------------------------------------------------
inline HRESULT
D3DContext::RampSceneCapture(DWORD dwStart, LPDIRECT3DDEVICEI lpDevI)
{
    // always do begin, so that even materials used on internal begin/end's
    // (like textured fills) get properly aged so they don't go away.
    if (dwStart)
    {
        BeginSceneHook();
    }
    else
    {
        if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INTERNAL_BEGIN_END))
        {
            EndSceneHook();
        }
    }
    return DD_OK;
}

//---------------------------------------------------------------------
// Builds color index that moste closely matches the D3DCOLOR source color.
// For use in 8 bit RGB mode which requires a palette.
//
// Returns:
//      color index in range 0 to 0xff
//
//---------------------------------------------------------------------
inline HRESULT
D3DContext::RGB8ColorToPixel(D3DCOLOR Color, DWORD* pdwPalIdx)
{
    if ((m_RastCtx.pRampMap == NULL) || (pdwPalIdx == NULL))
    {
        return DDERR_GENERIC;
    }
    INT32 iMapIdx = MAKE_RGB8(RGBA_GETRED(Color), RGBA_GETGREEN(Color), RGBA_GETBLUE(Color));
    iMapIdx &= 0xff;    // RGB8 ramp map always first and only rampmap
    // 8 bit result
    *pdwPalIdx = m_RastCtx.pRampMap[iMapIdx] & 0xff;
    return DD_OK;
}

//---------------------------------------------------------------------
// Causes the texture handle passed to have its colors rebuild, based
// on the new palette.
//
// Returns:
//      color index in range 0 to 0xff
//
//---------------------------------------------------------------------
inline HRESULT
D3DContext::RampPaletteChanged(D3DTEXTUREHANDLE hTex)
{
    RLDDIRampLightingDriver *pLtDriver =
        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;

    return RLDDIRampPaletteChanged(pLtDriver, hTex);
}

//---------------------------------------------------------------------
// Handles legacy non-power of 2 texture fill for clear.
//
// Returns:
//      D3D_OK
//
//---------------------------------------------------------------------
inline HRESULT D3DContext::RampClearTexRect(D3DMATERIALHANDLE hMat, LPD3DRECT pRect)
{
    switch (m_RastCtx.iSurfaceBitCount)
    {
    case 8:
        Ramp_Mono_ScaleImage_8(&m_RastCtx, hMat, pRect);
        break;
    case 16:
        Ramp_Mono_ScaleImage_16(&m_RastCtx, hMat, pRect);
        break;
    case 24:
        Ramp_Mono_ScaleImage_24(&m_RastCtx, hMat, pRect);
        break;
    case 32:
        Ramp_Mono_ScaleImage_32(&m_RastCtx, hMat, pRect);
        break;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\d3dif.hpp ===
//----------------------------------------------------------------------------
//
// d3dif.hpp
//
// D3D front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DIF_HPP_
#define _D3DIF_HPP_

#include <setup.hpp>

// For Primitive function prototypes.
#include <pmfns_mh.h>

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32

// Flags for uflags of D3DContex
#define D3DCONTEXT_IN_BEGIN             0x0001
#define D3DCONTEXT_TEXTURE_LOCKED       0x0002

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// Note: This must be replicated in ddraw\ddd3dapi.h so DDHEL can pick them up
//       It only affect what legacy apps see when using GetCaps or EnumDevices,
//       internally ZBufferFormats() is checked when on ZBuffer creation.
//       Note stencil formats should have no representation in this flag word
//       becase legacy apps will be fooled into trying to create a Z-only surface
//       at the DDBD bitdepth and fail.   New apps should ignore dwDeviceZBufferBitDepth
//       and use EnumZBufferFormats

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

// Macros used to access DDRAW surface info.
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDS) \
    (!(((LPDDRAWI_DDRAWSURFACE_INT) (pDDS))->lpLcl->lpGbl->dwGlobalFlags & \
    DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDS) \
    (((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl->lpGbl->dwUsageCount > 0)

// Macro to retrieve SPANTEX pointer
#define HANDLE_TO_SPANTEX(hTex) \
    (*(PD3DI_SPANTEX *)ULongToPtr(hTex))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != D3D_OK)                                                           \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}

// Triangle/Line/Point function
typedef HRESULT (*PFN_TRIANGLE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1,
                                PUINT8 pV2,
                                WORD wFlags =
                                  D3DTRIFLAG_EDGEENABLE1 |
                                  D3DTRIFLAG_EDGEENABLE2 |
                                  D3DTRIFLAG_EDGEENABLE3 );
typedef HRESULT (*PFN_POINT)(LPVOID pCtx, PUINT8 pV0);
typedef HRESULT (*PFN_LINE)(LPVOID pCtx, PUINT8 pV0, PUINT8 pV1);
typedef void (*PFN_STORELASTPIXELSTATE)(LPVOID pCtx, BOOL bStore);
typedef HRESULT (*PFN_DP2SETRENDERSTATES)(LPVOID pCtx,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2TEXTURESTAGESTATE)(LPVOID pCtx,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);

typedef HRESULT (*PFN_DP2SETVIEWPORT)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2SETWRANGE)(LPVOID pCtx, LPD3DHAL_DP2COMMAND pCmd);

typedef struct _PRIMITIVE_FUNTIONS
{
    PFN_TRIANGLE pfnTri;
    PFN_POINT pfnPoint;
    PFN_LINE pfnLine;
    PFN_STORELASTPIXELSTATE pfnStoreLastPixelState;
    PFN_DP2SETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2TEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2SETVIEWPORT pfnDp2SetViewport;
    PFN_DP2SETWRANGE pfnDp2SetWRange;
}PRIMITIVE_FUNTIONS;

typedef enum _SW_RAST_TYPE
{
    SW_RAST_REFNULL = 1,
    SW_RAST_RGB = 2,
    SW_RAST_MMX = 3,
    SW_RAST_MMXASRGB = 4,
}SW_RAST_TYPE;

// Records the stride and the member offsets of the current FVF vertex type
// Used to pack a FVF vertex into one known by the rasterizer, such as
// RAST_GENERIC_VERTEX
typedef struct _FVFDATA
{
    // 0 means no according field
    INT16 offsetRHW;
    INT16 offsetDiff;
    INT16 offsetSpec;
    INT16 offsetTex0;
    INT16 offsetTex1;

    UINT16 stride;

    RAST_VERTEX_TYPE vtxType;

    DWORD preFVF;
    INT TexIdx[2];
    UINT cActTex;
}FVFDATA;

// Class used for the context returned to D3DIM.
class D3DContext
{
public:
    D3DI_RASTCTX m_RastCtx;

    // InBegin and TextureLockd flags
    // TextureLockd bit is set/cleared by texture Lock/Unlock functions.
    // It is used by texture Lock/Unlock and Begin functions.
    // InBegin bit is set by Begin and cleared by End
    unsigned short m_uFlags;

    // This is init'ed according to the fill mode.
    // It is init'ed after state change and before rendering
    PRIMITIVE_FUNTIONS m_fnPrims;

    // This is used to save the current ramp tex map in Begin and then used to
    // restore it in End. It's needed primarily because for ExecBuf apps the
    // the current mat may not be the one used for a primitive. For DrawPrim
    // apps, the prims are flushed whenever a material change occurs. As a
    // result this is not necessary but will not hurt anything. Also, if
    // everything works out fine, the Flush may be removed.
    PUINT32 pTexRampmapSave;

    // Used to store the old last pixel setting when drawing line strips.
    UINT uOldFlags;

    inline BOOL IsTextureOff(void);

    inline void UpdatePrimFunctionTbl(void);    // Init m_pfnTri
    inline BOOL IsAnyStatesChanged(void);
    inline BOOL IsStateChanged(UINT32 uState);
    inline void StateChanged(UINT32 uState);
    inline void SetAllStatesDirtyBits(void);
    inline void ClearAllStatesDirtyBits(void);
    inline void ClearStateDirtyBit(UINT32 uState);

    // FVF stuff
    FVFDATA m_fvfData;


#if DBG
    inline HRESULT ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType);
#endif

    PrimProcessor m_PrimProc;

    // Used by RenderState for override states.
    D3DFE_STATESET m_renderstate_override;

    UINT32 dwSize;

    D3DContext(void){};
    ~D3DContext(void){};

    HRESULT Initialize(LPDIRECTDRAWSURFACE pDDS,
        LPDIRECTDRAWSURFACE pDDSZ, DWORD BeadSet, DWORD devVer);
    HRESULT FillContext(LPDIRECTDRAWSURFACE pDDS, LPDIRECTDRAWSURFACE pDDSZ);
    HRESULT SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt);
    HRESULT TextureSetState(PD3DI_SPANTEX pSpanTex, DWORD dwState, DWORD dwValue);
    HRESULT ValidateTextureStageState(void);
    HRESULT UpdateActiveTexStageCount(void);

    inline PD3DI_RASTCTX GetRastCtx(void){return &m_RastCtx;};

    HRESULT Begin(void);
    inline HRESULT End(BOOL bNotFlush = TRUE);
    inline void BeginPrimSet(D3DPRIMITIVETYPE PrimType, RAST_VERTEX_TYPE VertType)
        {m_PrimProc.BeginPrimSet(PrimType, VertType);};
    inline void StoreLastPixelState(BOOL bStore);
    inline PRIMITIVE_FUNTIONS *GetFunsTbl(void){return &m_fnPrims;};

    void RastUnlockSpanTexture(void);
    HRESULT RastLockSpanTexture(void);
    void UpdateColorKeyAndPalette(void);
    void RemoveTexture(PD3DI_SPANTEX pSpanTex);
    HRESULT InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS);
    HRESULT SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex);

    HRESULT SetRenderState(UINT32 uState, UINT32 uStateVal);
    HRESULT UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges);
    HRESULT UpdateAllRenderStates(LPDWORD puStates);
    HRESULT Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf);
    void MapTextureStage0State( void );
    void MapTextureStage1State( void );
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

    inline HRESULT CheckDrawOnePrimitive(
        LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);
    inline HRESULT CheckDrawOneIndexedPrimitive(
        LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData);
    inline HRESULT DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
    inline HRESULT DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);

    // Check if a triangle is culled or not. It's only used for wireframe and
    // point mode. It's done in PrimProc.Tri for solid mode.
    inline BOOL NotCulled(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                                             LPD3DTLVERTEX pV2);

    // FVF stuff
    HRESULT FASTCALL CheckFVF(DWORD dwFVF);
    void FASTCALL PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx);
    inline UINT16 GetFvfStride(void){return m_fvfData.stride;};
    inline RAST_VERTEX_TYPE GetFvfVertexType(void){return m_fvfData.vtxType;};

    // Following functions are for RampRast
    // Create/Destroy a RampLightingDriver.
    inline HRESULT CreateRampLightingDriver(void);
    inline void DestroyRampLightingDriver(void);

    inline void InitRampFuncs(void){
    m_fnPrims.pfnTri = RAMP_TriSolid;
    m_fnPrims.pfnPoint = RAMP_Point;
    m_fnPrims.pfnLine = RAMP_Line;
    };
    inline HRESULT RampCreateMaterial(D3DMATERIALHANDLE hMat);
    inline HRESULT RampDestroyMaterial(D3DMATERIALHANDLE hMat);
    inline HRESULT RampSetLightstate(UINT32 uState, LPVOID pVal);
    inline HRESULT RampMaterialChanged(D3DMATERIALHANDLE hMat);
    inline void BeginSceneHook(void);
    inline void EndSceneHook(void);
    inline HRESULT RampSceneCapture(DWORD dwStart, LPDIRECT3DDEVICEI lpDevI);
    inline HRESULT RampFindLightingRange(RAMP_RANGE_INFO *pRampInfo);
    inline HRESULT RampClear(void);
    inline HRESULT RampMaterialToPixel(D3DMATERIALHANDLE hMat, DWORD* pPixel);
    inline void RampSetFogData(UINT32 uState, UINT32 uStateVal);
    inline void RampSetMaterial(D3DMATERIALHANDLE hMat);
    inline HRESULT RampCheckTexMap(LPD3DTLVERTEX pV);
    inline void RampInitTexMap(LPD3DTLVERTEX pV)
            {m_RastCtx.pTexRampMap = (PUINT32)ULongToPtr(pV->specular);};
    inline void RampUpdateRangeInfo(void);
    inline HRESULT RGB8ColorToPixel(D3DCOLOR Color, DWORD* pdwPalIdx);
    inline HRESULT RampPaletteChanged(D3DTEXTUREHANDLE hTex);
    inline HRESULT RampClearTexRect(D3DMATERIALHANDLE hMat, LPD3DRECT pRect);

};

inline void D3DContext::StoreLastPixelState(BOOL bStore)
{
    if (bStore)
    {
        uOldFlags = m_PrimProc.GetFlags();
        m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
    }
    else
    {
        m_PrimProc.SetFlags(uOldFlags & PPF_DRAW_LAST_LINE_PIXEL);
    }
}

inline BOOL D3DContext::NotCulled(LPD3DTLVERTEX pV0,
              LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2)
{
    if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE)
    {
        return TRUE;
    }

    FLOAT x1, y1, x2x1, x3x1, y2y1, y3y1, fDet;

    x1 = pV0->sx;
    y1 = pV0->sy;
    x2x1 = pV1->sx - x1;
    y2y1 = pV1->sy - y1;
    x3x1 = pV2->sx - x1;
    y3y1 = pV2->sy - y1;

    fDet = x2x1 * y3y1 - x3x1 * y2y1;

    if (0. == fDet)
    {
        return FALSE;
    }
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_CULLMODE] )
    {
    case D3DCULL_CW:
        if ( fDet > 0.f )
        {
            return FALSE;
        }
        break;
    case D3DCULL_CCW:
        if ( fDet < 0.f )
        {
            return FALSE;
        }
        break;
    }
    return TRUE;
}
// Update m_pfnPrims according to the current fill mode, device type
// and vertextype. It's called when fill mode or FVF type chang.
inline void D3DContext::UpdatePrimFunctionTbl(void)
{
    if (m_RastCtx.BeadSet == D3DIBS_RAMP)
    {
        switch (m_RastCtx.pdwRenderState[D3DRENDERSTATE_FILLMODE])
        {
        case D3DFILL_POINT:
            m_fnPrims.pfnTri = RAMP_TriPoint;
            break;
        case D3DFILL_WIREFRAME:
            m_fnPrims.pfnTri = RAMP_TriWireframe;
            break;
        case D3DFILL_SOLID:
        default:
            m_fnPrims.pfnTri = RAMP_TriSolid;
            break;
        }
    }
    else
    {
        if (m_fvfData.vtxType == RAST_GENVERTEX)
        {
            m_fnPrims.pfnPoint = RGB_PointPack;
            m_fnPrims.pfnLine = RGB_LinePack;
        }
        else
        {
            m_fnPrims.pfnPoint = RGB_PointNoPack;
            m_fnPrims.pfnLine = RGB_LineNoPack;
        }
        switch (m_RastCtx.pdwRenderState[D3DRENDERSTATE_FILLMODE])
        {
        case D3DFILL_POINT:
            if (m_fvfData.vtxType == RAST_GENVERTEX)
            {
                m_fnPrims.pfnTri = RGB_TriPackPoint;
            }
            else
            {
                m_fnPrims.pfnTri = RGB_TriNoPackPoint;
            }
            break;
        case D3DFILL_WIREFRAME:
            if (m_fvfData.vtxType == RAST_GENVERTEX)
            {
                m_fnPrims.pfnTri = RGB_TriPackWireframe;
            }
            else
            {
                m_fnPrims.pfnTri = RGB_TriNoPackWireframe;
            }
            break;
            break;
        case D3DFILL_SOLID:
        default:
            if (m_fvfData.vtxType == RAST_GENVERTEX)
            {
                m_fnPrims.pfnTri = RGB_TriPackSolid;
            }
            else
            {
                m_fnPrims.pfnTri = RGB_TriNoPackSolid;
            }
            break;
        }
    }
}

// The following inline functions are provided to manipulate StatesDirtyBits.
// StatesDirtyBits is used to store one dirty bit for each render state. It
// contains (D3DHAL_MAX_RSTATES_AND_STAGES>>3+1) bytes.
// For a particular state, say uState,
// it is represented by i'th bit of j'th byte, where i=(uState & 7) and
// j=uState>>3. So,
// StatesDirtyBits[uState>>3]&(1<<(uState&7)) gives the bit info. for uState
// StatesDirtyBits[uState>>3] |= (1<<(uState&7)) sets the bit to 1
// StatesDirtyBits[uState>>3] &= ~(1 <<(uState&7)) clears the bit to 0

// Check if any render states have changed. The info. is stored in the bit
// corresponding to D3DHAL_MAX_RSTATES_AND_STAGES.
inline BOOL D3DContext::IsAnyStatesChanged()
{
    return (m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] &
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7)));
}
// Check if uState has changed.
inline BOOL D3DContext::IsStateChanged(UINT32 uState)
{
    return (m_RastCtx.StatesDirtyBits[uState>>3] & (1<<(uState & 7)));
};

// uState has changed so set the according dirty bit and the AnyStates bit.
inline void D3DContext::StateChanged(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] |= (1<<(uState & 7));
    m_RastCtx.StatesDirtyBits[D3DHAL_MAX_RSTATES_AND_STAGES>>3] |=
        (1<<(D3DHAL_MAX_RSTATES_AND_STAGES & 7));
};

// Called after bead chooser to clear all the dirty bits.
inline void D3DContext::ClearAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 0, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Called at context creation time to set all the dirty bits.
inline void D3DContext::SetAllStatesDirtyBits(void)
{
    memset(m_RastCtx.StatesDirtyBits, 7, sizeof(UINT8) * RAST_DIRTYBITS_SIZE);
};

// Clear the dirty bit corresponding to uState.
inline void D3DContext::ClearStateDirtyBit(UINT32 uState)
{
    m_RastCtx.StatesDirtyBits[uState>>3] &= ~(1 << (uState & 7));
}
inline BOOL D3DContext::IsTextureOff(void)
{
    return
        (m_RastCtx.cActTex == 0 ||
        (m_RastCtx.cActTex == 1 && m_RastCtx.pTexture[0] == NULL) ||
        (m_RastCtx.cActTex == 2 &&
         (m_RastCtx.pTexture[0] == NULL ||
          m_RastCtx.pTexture[1] == NULL)));
}
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

// Lock surfaces before rendering
inline HRESULT LockSurface(LPDIRECTDRAWSURFACE pDDS, LPVOID *ppData)
{
    if (pDDS)
    {
        if (!VIDEO_MEMORY(pDDS))
        {
            if (SURFACE_LOCKED(pDDS))
            return DDERR_SURFACEBUSY;
            *ppData = (LPVOID)SURFACE_MEMORY(pDDS);
            return DD_OK;
        }
        else
        {
            HRESULT ddrval;
            do
            {
                LPDDRAWI_DDRAWSURFACE_INT lpInt;

                lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
                ddrval = DDInternalLock(lpInt->lpLcl, ppData);
            } while (ddrval == DDERR_WASSTILLDRAWING);
            return ddrval;
        }
    }
    return DD_OK;
}
// Unlock surfaces after rendering
inline void UnlockSurface(LPDIRECTDRAWSURFACE pDDS)
{
    if (pDDS && VIDEO_MEMORY(pDDS))
    {
        LPDDRAWI_DDRAWSURFACE_INT lpInt;

        lpInt = (LPDDRAWI_DDRAWSURFACE_INT) pDDS;
        DDInternalUnlock(lpInt->lpLcl);
    }
}
// After rendering cleanup: flush primitive processor, unlock textures
inline HRESULT
D3DContext::End(BOOL bNotFlush)
{
    if (m_uFlags & D3DCONTEXT_IN_BEGIN)
    {
        HRESULT hr = m_PrimProc.End();

        // Unlock texture if this is not called in the middle of drawPrims to
        // flush for possible state changes. In the 2nd case, let
        // SetRenderState to handle it.
        if (bNotFlush)
        {
            RastUnlockSpanTexture();
        }

        // Unlock surfaces
        UnlockSurface(m_RastCtx.pDDS);
        if (m_RastCtx.pDDSZ != NULL)
        {
            UnlockSurface(m_RastCtx.pDDSZ);
        }

        m_uFlags &= ~D3DCONTEXT_IN_BEGIN;
        if (m_RastCtx.pRampDrv)
        {
            m_RastCtx.pTexRampMap = pTexRampmapSave;
        }
        return (hr);
    }
    else
    {
        // In the case of DrawPrims being called just to set render states,
        // Begin is actually not called.
        return D3D_OK;
    }
}

inline HRESULT
D3DContext::RampCheckTexMap(LPD3DTLVERTEX pV)
{
    if (m_RastCtx.pTexRampMap != (PUINT32)ULongToPtr(pV->specular))
    {
        HRESULT hr;
        // Flush Prims
        HR_RET(End());
        HR_RET(Begin());
        m_RastCtx.pTexRampMap = (PUINT32)ULongToPtr(pV->specular);
    }
    return D3D_OK;
}

// Following primitive functions are shared by RGB/RAMP/REF rasterizers
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices);
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices);
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags);
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt);
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine);
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri);
HRESULT FASTCALL
DoDrawPrimitives2(LPVOID pCtx,
                  PRIMITIVE_FUNTIONS *pfnPrims,
                  UINT16 dwStride,
                  DWORD dwFvf,
                  PUINT8 pVtx,
                  LPD3DHAL_DP2COMMAND *ppCmd,
                  LPDWORD lpdwRStates,
                  BOOL bWireframe = FALSE
                  );


inline HRESULT
D3DContext::DrawOnePrimitive(PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOnePrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    PrimType,
                                    cVertices);

}

inline HRESULT
D3DContext::DrawOneIndexedPrimitive(PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    m_PrimProc.BeginPrimSet(PrimType, m_fvfData.vtxType);
    return DoDrawOneIndexedPrimitive((LPVOID)this,
                                    &m_fnPrims,
                                    m_fvfData.stride,
                                    (PUINT8)pVtx,
                                    puIndices,
                                    PrimType,
                                    cIndices);
}

// Macros to check if a pointer is valid
#if DBG
#define VALID_D3DCONTEX_PTR(pDCtx)  ((pDCtx)->dwSize == sizeof(D3DContext))
#define VALID_D3DI_RASTCTX_PTR(pRastCtx) \
            ((pRastCtx)->dwSize == sizeof(D3DI_RASTCTX))
#define VALID_D3DI_SPANTEX_PTR(pSpanTex) \
            ((pSpanTex)->dwSize == sizeof(D3DI_SPANTEX))
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex) \
            ((ppSpanTex) && VALID_D3DI_SPANTEX_PTR(*(ppSpanTex)))
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        D3D_INFO(1, "in %s, data pointer = NULL", (caller_name));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        D3D_INFO(1, "in %s, dwhContext = NULL", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
#define VALID_D3DCONTEX_PTR(pDCtx)              1
#define VALID_D3DI_RASTCTX_PTR(pRastCtx)        1
#define VALID_D3DI_SPANTEX_PTR(pSpanTex)        1
#define VALID_D3DI_SPANTEX_PTR_PTR(ppSpanTex)   1
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate D3DCxt. pDCtx should be declared before this macro
#define VALIDATE_D3DCONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pDCtx, D3DContext*); \
    if (!VALID_D3DCONTEX_PTR(pDCtx) ||  \
        !VALID_D3DI_RASTCTX_PTR((pDCtx)->GetRastCtx()))    \
    {   \
        D3D_INFO(1, "in %s, invalid dwhContext", (caller_name));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

// Validate ReferenceRasterizer. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefRast, ReferenceRasterizer*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT pDdPixFmt,
                  D3DI_SPANTEX_FORMAT *pFmt);

extern int
TextureFormats(LPDDSURFACEDESC* lplpddsd, DWORD dwVersion, SW_RAST_TYPE RastType);

extern int
RampTextureFormats(LPDDSURFACEDESC* lplpddsd);

extern int
ZBufferFormats(DDPIXELFORMAT** ppDDPF, BOOL bIsRefRast);

extern int
RampZBufferFormats(DDPIXELFORMAT** ppDDPF);

BOOL FASTCALL
ValidTextureSize(INT16 iuSize, INT16 iuShift,
                             INT16 ivSize, INT16 ivShift);
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet);

DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateCMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextCreateRamp(LPD3DHAL_CONTEXTCREATEDATA pCtxData);

DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData);

DWORD __stdcall
RastContextDestroyRamp(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData);

DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData);

DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData);

DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData);

DWORD __stdcall
RastTextureSwap(LPD3DHAL_TEXTURESWAPDATA pTexSwapData);

DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf);

DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData);

DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData);

DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData);

DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData);

DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData);

DWORD __stdcall
RastClearRamp(LPD3DHAL_CLEARDATA pClrData);

DWORD __stdcall
RastSceneCaptureRamp(LPD3DHAL_SCENECAPTUREDATA pSceneData);

DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD __stdcall
RastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);


//---------------------------------------------------------------------------
//
//  Interface for Reference Device External DLL
//

//  prototypes for functions exported by d3dref.dll
STDAPI GetRefHalProvider(REFCLSID riid, IHalProvider **ppHalProvider, HINSTANCE *phDll);
STDAPI GetRefZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF);
STDAPI GetRefTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion);

typedef HRESULT (STDAPICALLTYPE* PFNGETREFHALPROVIDER)(REFCLSID,IHalProvider**,HINSTANCE*);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFZBUFFERFORMATS)(REFCLSID, DDPIXELFORMAT**);
typedef HRESULT (STDAPICALLTYPE* PFNGETREFTEXTUREFORMATS)(REFCLSID, LPDDSURFACEDESC*, DWORD);

inline FARPROC LoadReferenceDeviceProc( char* szProc )
{
    HINSTANCE hRefDLL;
    if (NULL == (hRefDLL = LoadLibrary("d3dref.dll")) )
    {
        return NULL;
    }
    return GetProcAddress(hRefDLL, szProc);
}

//---------------------------------------------------------------------------
#endif // #ifndef _D3DIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// CheckFVF
//
// Check a FVF control word and then init m_fvfData accordingly
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
D3DContext::CheckFVF(DWORD dwFVF)
{
    // check if FVF controls have changed
    if ( (m_fvfData.preFVF == dwFVF) &&
         (m_fvfData.TexIdx[0] == (INT)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_TEXCOORDINDEX)]) &&
         (m_fvfData.TexIdx[1] == (INT)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_TEXCOORDINDEX)]) &&
         (m_fvfData.cActTex == m_RastCtx.cActTex) )
    {
        return D3D_OK;
    }
#if DBG
    // This is added here per Iouri's request. It will make it easier for him
    // to test his code for legacy drivers.
    if (dwFVF == 0)
    {
        dwFVF = D3DFVF_TLVERTEX;
    }
#endif

    memset(&m_fvfData, 0, sizeof(FVFDATA));
    m_fvfData.preFVF = dwFVF;
    m_fvfData.TexIdx[0] = m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_TEXCOORDINDEX)];
    m_fvfData.TexIdx[1] = m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_TEXCOORDINDEX)];
    m_fvfData.cActTex = m_RastCtx.cActTex;

#if DBG
    // We only support max 8 texture coords
    if (m_fvfData.TexIdx[0] > 7 || m_fvfData.TexIdx[1] > 7)
    {
        D3D_WARN(0, "(Rast) Texture coord index bigger than max supported.");
        return DDERR_INVALIDPARAMS;
    }
#endif

    // Update the copy of wrap states in RastCtx
    m_RastCtx.pdwWrap[0] = m_RastCtx.pdwRenderState[
                (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+m_fvfData.TexIdx[0])];
    m_RastCtx.pdwWrap[1] = m_RastCtx.pdwRenderState[
                (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+m_fvfData.TexIdx[1])];

    // do either true FVF parsing or legacy TLVERTEX handling
    if ( (m_RastCtx.BeadSet != D3DIBS_RAMP) &&
         ( (dwFVF != D3DFVF_TLVERTEX) ||
           (0 != m_fvfData.TexIdx[0]) ||
           (m_RastCtx.cActTex > 1) ) )
    {   // New (non TL)FVF vertex
        // XYZ
        if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
             D3DFVF_NORMAL)) ||
             ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
        {
            // can't set reserved bits, shouldn't have normals in
            // output to rasterizers, and must have coordinates
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            m_fvfData.offsetRHW = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            m_fvfData.offsetDiff = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            m_fvfData.offsetSpec = m_fvfData.stride;
            m_fvfData.stride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
#if DBG
        INT iTexIdx0 = m_fvfData.TexIdx[0], iTexIdx1 = m_fvfData.TexIdx[1];
        if (iTexCount > 0)
        {
            if ( iTexIdx0 >= iTexCount)
            {
                D3D_WARN(1, "(Rast)Texture coord index bigger than texture coord count.");
                iTexIdx0 = 0;
            }
            if ( iTexIdx1 >= iTexCount)
            {
                D3D_WARN(1, "(Rast)Texture coord index bigger than texture coord count.");
                iTexIdx1 = 0;
            }
            // set offset for Textures 0 and 1
            m_fvfData.offsetTex0 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*iTexIdx0);
            m_fvfData.offsetTex1 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*iTexIdx1);
            // update stride
            m_fvfData.stride += (INT16)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#else
        if (iTexCount > 0)
        {
            // set offset for Textures 0 and 1
            m_fvfData.offsetTex0 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[0]);
            m_fvfData.offsetTex1 = (INT16)(m_fvfData.stride +
                                    2*sizeof(D3DVALUE)*m_fvfData.TexIdx[1]);
            // update stride
            m_fvfData.stride += (INT16)(iTexCount * (sizeof(D3DVALUE) * 2));
        }
#endif

        m_fvfData.vtxType = RAST_GENVERTEX;
    }
    else
    {
        // (Legacy) TL vertex
        if (0 < m_fvfData.TexIdx[0])
        {
            D3D_ERR("(Rast) Texture coord index bigger than 0 for legacy TL vertex.");
            return DDERR_INVALIDPARAMS;
        }
        m_fvfData.stride = sizeof(D3DTLVERTEX);
        m_fvfData.vtxType = RAST_TLVERTEX;
    }

    UpdatePrimFunctionTbl();

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PackGenVertex
//
// Pack a FvFVertex into RAST_GENERIC_VERTEX. This is called for every non TL
// FVF vertex. It can be optimized for speed later.
//
//----------------------------------------------------------------------------
void FASTCALL
D3DContext::PackGenVertex(PUINT8 pFvfVtx, RAST_GENERIC_VERTEX *pGenVtx)
{
    pGenVtx->sx = *((D3DVALUE *)pFvfVtx);
    pGenVtx->sy = *((D3DVALUE *)pFvfVtx + 1);
    pGenVtx->sz = *((D3DVALUE *)pFvfVtx + 2);
    if (m_fvfData.offsetRHW)
    {
        pGenVtx->rhw = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetRHW));
    }
    else
    {
        pGenVtx->rhw = 1.0f;
    }
    if (m_fvfData.offsetDiff)
    {
        pGenVtx->color = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetDiff));
    }
    else
    {
        pGenVtx->color = __DEFAULT_DIFFUSE;
    }
    if (m_fvfData.offsetSpec)
    {
        pGenVtx->specular = *((D3DCOLOR *)(pFvfVtx + m_fvfData.offsetSpec));
    }
    else
    {
        pGenVtx->specular = __DEFAULT_SPECULAR;
    }
    if (m_fvfData.offsetTex0)
    {
        pGenVtx->tu = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex0));
        pGenVtx->tv = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex0) + 1);
    }
    else
    {
        pGenVtx->tu = 0.0f;
        pGenVtx->tv = 0.0f;
    }
    if (m_fvfData.offsetTex1)
    {
        pGenVtx->tu2 = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex1));
        pGenVtx->tv2 = *((D3DVALUE *)(pFvfVtx + m_fvfData.offsetTex1) + 1);
    }
    else
    {
        pGenVtx->tu2 = 0.0f;
        pGenVtx->tv2 = 0.0f;
    }
}

//----------------------------------------------------------------------------
//
// DoDrawOnePrimitive
//
// Draw one list of primitives. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOnePrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cVertices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch (PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            HR_RET(pfnPrims->pfnPoint(pCtx, pVtx));
            pVtx += FvfStride;
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = pVtx;

            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pVtx += FvfStride;
                pV1 = pVtx;
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }

            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride;
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = pVtx;
            pVtx += FvfStride;
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx;
            pVtx += FvfStride;
            pV2 = pVtx;
            pVtx += FvfStride;

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx;
            pVtx += FvfStride;
            // Preload initial pV0.
            pV1 = pVtx;
            pVtx += FvfStride;
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx;
                pVtx += FvfStride;
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneIndexedPrimitive
//
// Draw one list of indexed primitives. It's called by
// RastDrawOneIndexedPrimitive.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneIndexedPrimitive(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 LPWORD puIndices,
                 D3DPRIMITIVETYPE PrimType,
                 UINT cIndices)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    switch(PrimType)
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnPoint(pCtx, pV0));
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            pfnPrims->pfnStoreLastPixelState(pCtx, 1);
            // Initial pV1.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnLine(pCtx, pV0, pV1));
            }
            // Restore last-pixel setting.
            pfnPrims->pfnStoreLastPixelState(pCtx, 0);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = pVtx + FvfStride * (*puIndices);
                HR_RET(pfnPrims->pfnLine(pCtx, pV1, pV0));
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = pVtx + FvfStride * (*puIndices++);
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = pVtx + FvfStride * (*puIndices++);
            pV2 = pVtx + FvfStride * (*puIndices++);

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));

                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV2, pV1));
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = pVtx + FvfStride * (*puIndices++);
            // Preload initial pV0.
            pV1 = pVtx + FvfStride * (*puIndices++);
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = pVtx + FvfStride * (*puIndices++);
                HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2));
            }
        }
        break;

    default:
        D3D_ERR("(Rast) Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoDrawOneEdgeFlagTriangleFan(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 UINT16 FvfStride,
                 PUINT8 pVtx,
                 UINT cVertices,
                 UINT32 dwEdgeFlags)
{
    INT i;
    PUINT8 pV0, pV1, pV2;
    HRESULT hr;

    pV2 = pVtx;
    pVtx += FvfStride;
    pV0 = pVtx;
    pVtx += FvfStride;
    pV1 = pVtx;
    pVtx += FvfStride;
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
        return D3D_OK;
    }
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = pVtx;
        pVtx += FvfStride;
        if(dwEdgeFlags & dwMask)
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1));
        }
        else
        {
            HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, 0));
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = pVtx;
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    HR_RET(pfnPrims->pfnTri(pCtx, pV0, pV1, pV2, wFlags));

    return D3D_OK;
}

#if DBG
//----------------------------------------------------------------------------
//
// ValidatePrimType
//
// Check if the primitive type is supported. We could remove this function
// after we have implemented all primitive types and then depend on D3DIM
// to check if the primitive type is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::ValidatePrimType(D3DPRIMITIVETYPE PrimitiveType)
{
    switch(PrimitiveType)
    {
    case D3DPT_POINTLIST:
    case D3DPT_LINELIST:
    case D3DPT_LINESTRIP:
    case D3DPT_TRIANGLELIST:
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        break;
    default:
        D3D_ERR("(Rast) PrimitiveType not supported by the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif
//----------------------------------------------------------------------------
//
// CheckDrawOnePrimitive
//
// Check if the DRAWONEPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
#if DBG
    HRESULT hr;

    if (pOnePrimData == NULL ||
        pOnePrimData->dwhContext == 0 ||
        pOnePrimData->lpvVertices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOnePrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// CheckDrawOneIndexedPrimitive
//
// Check if the DRAWONEINDEXEDPRIMITIVEDATA is valid.
//
//----------------------------------------------------------------------------
inline HRESULT
D3DContext::CheckDrawOneIndexedPrimitive(
                         LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pOneIdxPrimData)
{
#if DBG
    HRESULT hr;

    if (pOneIdxPrimData == NULL ||
        pOneIdxPrimData->dwhContext == 0 ||
        pOneIdxPrimData->lpvVertices == NULL ||
        pOneIdxPrimData->lpwIndices == NULL)
    {
        D3D_ERR("(Rast) Invalid data passed to the new rasterizer.");
        return DDERR_INVALIDPARAMS;
    }

    HR_RET(ValidatePrimType(pOneIdxPrimData->PrimitiveType));
#endif
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastDrawOnePrimitive
//
// Draw one list of primitives. This is called by D3DIM for API DrawPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA pOnePrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOnePrimitive", pOnePrimData);

    if ((pOnePrimData->ddrval =
        pDCtx->CheckDrawOnePrimitive(pOnePrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOnePrimData->ddrval, pDCtx, (DWORD)pOnePrimData->dwFVFControl);

    pOnePrimData->ddrval = pDCtx->Begin();
    if (pOnePrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOnePrimData->ddrval =
        pDCtx->DrawOnePrimitive((PUINT8)pOnePrimData->lpvVertices,
                         pOnePrimData->PrimitiveType,
                         pOnePrimData->dwNumVertices);

    hr = pDCtx->End();
    if (pOnePrimData->ddrval == D3D_OK)
    {
        pOnePrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawOneIndexedPrimitive
//
// Draw one list of primitives. This is called by D3DIM for API
// DrawIndexedPrimitive.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
                            pOneIdxPrimData)
{
    HRESULT hr;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawOneIndexedPrimitive", pOneIdxPrimData);

    if ((pOneIdxPrimData->ddrval =
         pDCtx->CheckDrawOneIndexedPrimitive(pOneIdxPrimData)) != DD_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Check for FVF vertex, and init FVF related fileds if necessary
    // Assume the control word is passed in through dwFlags
    CHECK_FVF(pOneIdxPrimData->ddrval, pDCtx, (DWORD)pOneIdxPrimData->dwFVFControl);

    pOneIdxPrimData->ddrval = pDCtx->Begin();
    if (pOneIdxPrimData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pOneIdxPrimData->ddrval =
        pDCtx->DrawOneIndexedPrimitive((PUINT8)pOneIdxPrimData->lpvVertices,
                                pOneIdxPrimData->lpwIndices,
                                pOneIdxPrimData->PrimitiveType,
                                pOneIdxPrimData->dwNumIndices);

    hr = pDCtx->End();
    if (pOneIdxPrimData->ddrval == D3D_OK)
    {
        pOneIdxPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastDrawPrimitives
//
// This is called by D3DIM for a list of batched API DrawPrimitive calls.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA pDrawPrimData)
{
    PUINT8  pData = (PUINT8)pDrawPrimData->lpvData;
    LPD3DHAL_DRAWPRIMCOUNTS pDrawPrimitiveCounts;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastDrawPrimitives", pDrawPrimData);

    pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;

    // Check for FVF vertex when there are actually something to be drawn, and
    // init FVF related fileds if necessary Assume the control word is passed
    // in through dwReserved
    if (pDrawPrimitiveCounts->wNumVertices > 0)
    {
        CHECK_FVF(pDrawPrimData->ddrval, pDCtx, pDrawPrimData->dwFVFControl);
    }

    // Skip state check and texture lock if the first thing is state change
    if (pDrawPrimitiveCounts->wNumStateChanges == 0)
    {
        pDrawPrimData->ddrval =pDCtx->Begin();
        if (pDrawPrimData->ddrval != D3D_OK)
        {
            goto EH_Exit;
        }
    }

    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        pDrawPrimitiveCounts = (LPD3DHAL_DRAWPRIMCOUNTS)pData;
        pData += sizeof(D3DHAL_DRAWPRIMCOUNTS);

        //
        // Update render states
        //

        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // Flush the prim proc before any state changs
            pDrawPrimData->ddrval = pDCtx->End(FALSE);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                return DDHAL_DRIVER_HANDLED;
            }

            pDrawPrimData->ddrval =
                pDCtx->UpdateRenderStates((LPDWORD)pData,
                                   pDrawPrimitiveCounts->wNumStateChanges);
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }

            pData += pDrawPrimitiveCounts->wNumStateChanges *
                sizeof(DWORD) * 2;
        }

        // Check for exit
        if (pDrawPrimitiveCounts->wNumVertices == 0)
        {
            break;
        }

        // Align pointer to vertex data
        pData = (PUINT8)
            ((UINT_PTR)(pData + (DP_VTX_ALIGN - 1)) & ~(DP_VTX_ALIGN - 1));

        // Delayed change until we really need to render something
        if (pDrawPrimitiveCounts->wNumStateChanges > 0)
        {
            // We might have a new texture so lock.
            pDrawPrimData->ddrval = pDCtx->Begin();
            if (pDrawPrimData->ddrval != D3D_OK)
            {
                goto EH_Exit;
            }
        }

        //
        // Primitives
        //
        pDrawPrimData->ddrval =
            pDCtx->DrawOnePrimitive((PUINT8)pData,
                        (D3DPRIMITIVETYPE)pDrawPrimitiveCounts->wPrimitiveType,
                        pDrawPrimitiveCounts->wNumVertices);
        if (pDrawPrimData->ddrval != DD_OK)
        {
            goto EH_Exit;
        }

        pData += pDrawPrimitiveCounts->wNumVertices * pDCtx->GetFvfStride();
    }

 EH_Exit:
    HRESULT hr;

    hr = pDCtx->End();

    if (pDrawPrimData->ddrval == D3D_OK)
    {
        pDrawPrimData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\ramprov.cpp ===
//----------------------------------------------------------------------------
//
// ramprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

extern HRESULT
RastService(ULONG_PTR dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2);

extern HRESULT
RastRampService(ULONG_PTR dwCtx,
                RastRampServiceType srvType, ULONG_PTR arg1, LPVOID arg2);

extern D3DDEVICEDESC g_nullDevDesc;

#define BUILD_RAMP 1
#define devDesc rampDevDescDX5
#include "getcaps.h"

STDMETHODIMP
RampRastHalProvider::GetCaps(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;
    *pHelDesc = rampDevDescDX5;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RampRastHalProvider::GetInterface
//
// Returns driver interface data for opt rast.
//
//----------------------------------------------------------------------------

static D3DHAL_GLOBALDRIVERDATA SwDriverData =
{
    sizeof(D3DHAL_GLOBALDRIVERDATA),
    // The rest is filled in at runtime.
};

static D3DHAL_CALLBACKS RampRastCallbacks =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateRamp,
    RastContextDestroyRamp,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 RampRastCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
        D3DHAL2_CB32_DRAWONEPRIMITIVE |
        D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
        D3DHAL2_CB32_DRAWPRIMITIVES,
    RastSetRenderTarget,
    NULL,
    RastDrawOnePrimitive,
    RastDrawOneIndexedPrimitive,
    RastDrawPrimitives
};

static D3DHAL_CALLBACKS3 RampRastCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, // lpvReserved
    NULL, // ValidateTextureStageState
    RastDrawPrimitives2,  // DrawVB
};

//----------------------------------------------------------------------------
//
// TextureFormats
//
// Returns all the texture formats supported by our rasterizer.
// Right now, it's called at device creation time to fill the driver gloabl
// data.
//
//----------------------------------------------------------------------------

#define NUM_RAMP_SUPPORTED_TEXTURE_FORMATS   2

int
RampTextureFormats(LPDDSURFACEDESC* lplpddsd)
{
    static DDSURFACEDESC ddsd[NUM_RAMP_SUPPORTED_TEXTURE_FORMATS];

    int i = 0;

    /* pal8 */
    ddsd[i].dwSize = sizeof(ddsd[0]);
    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED8 | DDPF_RGB;
    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 8;

    i++;

    /* pal4 */
//  although ramp supports the pal4 (and 16 bit texture formats, for copy)
//  texture format, it must not be enumerated for backwards compatibility
//
//    ddsd[i].dwSize = sizeof(ddsd[0]);
//    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
//    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
//    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
//    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_PALETTEINDEXED4 | DDPF_RGB;
//    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 4;
//
//    i++;

    *lplpddsd = ddsd;

    return i;
}

// Note: because ramp ZBuffer Formats are different than the standard ones
// used by the other rasterizers, it is impossible for DDHEL to properly validate
// zbuffer creation for the case of ramp (because the ramp device may have not
// been created at zbuffer creation time), so Direct3DCreateDevice has a special check
// to invalidate the zformats (i.e. stencil) not accepted by ramp

#define NUM_SUPPORTED_ZBUFFER_FORMATS  1

int
RampZBufferFormats(DDPIXELFORMAT** ppDDPF)
{
    static DDPIXELFORMAT DDPF[NUM_SUPPORTED_ZBUFFER_FORMATS];

    int i = 0;

    /* 16 bit Z; no stencil */
    DDPF[i].dwSize = sizeof(DDPIXELFORMAT);
    DDPF[i].dwFlags = DDPF_ZBUFFER;
    DDPF[i].dwZBufferBitDepth = 16;
    DDPF[i].dwStencilBitDepth = 0;
    DDPF[i].dwZBitMask = 0xffff;
    DDPF[i].dwStencilBitMask = 0x0000;

    i++;
    *ppDDPF = DDPF;

    return i;
}

STDMETHODIMP
RampRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{

    memcpy(&SwDriverData.hwCaps, &rampDevDescDX5, sizeof(SwDriverData.hwCaps));
    SwDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    SwDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    SwDriverData.dwNumTextureFormats =
        RampTextureFormats(&SwDriverData.lpTextureFormats);
    pInterfaceData->pGlobalData = &SwDriverData;

    pInterfaceData->pExtCaps = NULL;

    pInterfaceData->pCallbacks = &RampRastCallbacks;
    pInterfaceData->pCallbacks2 = &RampRastCallbacks2;
    pInterfaceData->pCallbacks3 = &RampRastCallbacks3;
    pInterfaceData->pfnRampService = RastRampService;
    pInterfaceData->pfnRastService = RastService;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rastctx.cpp ===
//----------------------------------------------------------------------------
//
// rastctx.cpp
//
// Context functions + state functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop
#include "rampif.h"
#include "rampmat.hpp"

// Unlock previous texture if necessary. It's called before the texture handle
// is going to be changed.
#define CHECK_AND_UNLOCK_TEXTURE    \
{   \
    if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)   \
    {   \
        RastUnlockSpanTexture();    \
    }   \
}

inline void
D3DContext::RampSetFogData(UINT32 uState, UINT32 uStateVal)
{
    RLDDIRampLightingDriver *pRampdrv =
                        (RLDDIRampLightingDriver*)m_RastCtx.pRampDrv;
    if (pRampdrv != NULL)
    {
        switch(uState)
        {
        case D3DRENDERSTATE_FOGENABLE      :
            pRampdrv->fog_enable = uStateVal;
            break;
        case D3DRENDERSTATE_FOGCOLOR       :
            pRampdrv->fog_color = uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLEMODE   :
            pRampdrv->driver.fog_mode = (D3DFOGMODE)uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLESTART  :
            pRampdrv->driver.fog_start = (FLOAT)uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLEEND    :
            pRampdrv->driver.fog_end = (FLOAT)uStateVal;
            break;
        case D3DRENDERSTATE_FOGTABLEDENSITY:
            pRampdrv->driver.fog_density = (FLOAT)uStateVal;
            break;
        }
    }
}

//----------------------------------------------------------------------------
//
// FillContext
//
// Fill the context with the info. from the surfaces.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::FillContext(LPDIRECTDRAWSURFACE pDDS,
                               LPDIRECTDRAWSURFACE pDDSZ)
{
    HRESULT hr;

    LPDDRAWI_DDRAWSURFACE_LCL pLcl =
        ((LPDDRAWI_DDRAWSURFACE_INT)(pDDS))->lpLcl;
    m_RastCtx.iSurfaceStride = DDSurf_Pitch(pLcl);
    m_RastCtx.iSurfaceBitCount = DDSurf_BitDepth(pLcl);
    m_RastCtx.iSurfaceStep = m_RastCtx.iSurfaceBitCount/8;
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)),
        (D3DI_SPANTEX_FORMAT *)&(m_RastCtx.iSurfaceType)));
    m_RastCtx.Clip.left = m_RastCtx.Clip.top = 0;
    m_RastCtx.Clip.bottom = DDSurf_Height(pLcl);
    m_RastCtx.Clip.right = DDSurf_Width(pLcl);

    if (pDDSZ != NULL)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pDDSZ))->lpLcl;
        m_RastCtx.pZBits = (PUINT8)SURFACE_MEMORY(pDDSZ);
        m_RastCtx.iZStride = DDSurf_Pitch(pLcl);
        m_RastCtx.iZBitCount = DDSurf_BitDepth(pLcl);
        m_RastCtx.iZStep = m_RastCtx.iZBitCount/8;
    }
    else
    {
        m_RastCtx.pZBits = NULL;
        m_RastCtx.iZStride = 0;
        m_RastCtx.iZBitCount = 0;
        m_RastCtx.iZStep = 0;
    }

    m_RastCtx.pDDS = pDDS;
    m_RastCtx.pDDSZ = pDDSZ;

    m_RastCtx.dwSize = sizeof(D3DI_RASTCTX);

    // Make sure SpanInit is called at least once
    SetAllStatesDirtyBits();

    // Check for MsGolf AppHack
    if (pLcl->lpSurfMore->lpDD_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_FORCEMODULATED)
    {
        m_RastCtx.uFlags |= RASTCTXFLAGS_APPHACK_MSGOLF;
    }

    return D3D_OK;
}

HRESULT
D3DContext::Initialize(LPDIRECTDRAWSURFACE pDDS,
                       LPDIRECTDRAWSURFACE pDDSZ,
                       DWORD BeadSet,
                       DWORD devVer)
{
    HRESULT hr;

    // Initialize the primitive processor.
    HR_RET(m_PrimProc.Initialize());

    memset(&m_RastCtx, 0, sizeof(m_RastCtx));

    m_uFlags = 0;
    HR_RET(FillContext(pDDS, pDDSZ));

    m_PrimProc.SetCtx(&m_RastCtx);

    dwSize = sizeof(D3DContext);

    // Initialize bead table enum
    m_RastCtx.BeadSet = (D3DI_BEADSET)BeadSet;

    STATESET_INIT(m_renderstate_override);

    // Init FVF data as legacy TL vertex
    m_fvfData.preFVF = -1;
    CheckFVF(D3DFVF_TLVERTEX);

    m_RastCtx.uDevVer = devVer;

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    // Init prim function table. It will be updated for RAMP, or when FVF
    // control word changes or when fill mode changes.
    m_fnPrims.pfnTri = RGB_TriNoPackSolid;
    m_fnPrims.pfnPoint = RGB_PointNoPack;
    m_fnPrims.pfnLine = RGB_LineNoPack;
    // This one should be always the same.
    m_fnPrims.pfnStoreLastPixelState = RGBRAMP_StoreLastPixelState;
    m_fnPrims.pfnDp2SetRenderStates = RGBRAMP_Dp2SetRenderStates;
    m_fnPrims.pfnDp2TextureStageState = RGBRAMP_Dp2TextureStageState;
    m_fnPrims.pfnDp2SetViewport = RGBRAMP_Dp2SetViewport;
    m_fnPrims.pfnDp2SetWRange = RGBRAMP_Dp2SetWRange;

    // Enable MMX Fast Paths (Monolithics) if a registry key for it is not 0
    m_RastCtx.dwMMXFPDisableMask[0] = 0x0;       // enable MMX FP's by default
    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwDisableMask[MMX_FP_DISABLE_MASK_NUM] = {0x0};
        DWORD dwSize = 4;

        // only code up looking at one mask, for now
        DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMXFPDisableMask0", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD )
        {
           dwDisableMask[0] = dwValue;
        }
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "MMX Fast Path", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD)
        {
            if (dwValue == 0)
            {
                // Override MMXFPDisableMask0 and disable all MMX Fast Paths
                m_RastCtx.dwMMXFPDisableMask[0] = 0xffffffff;
            }
            else
            {
                // Take all MMX paths not disabled by MMXFPDisableMask0
                m_RastCtx.dwMMXFPDisableMask[0] = dwDisableMask[0];
            }
        }

        RegCloseKey( hKey );
    }

    return D3D_OK;
}

HRESULT
D3DContext::SetViewport(LPD3DHAL_DP2VIEWPORTINFO pVpt)
{
    m_RastCtx.Clip.left = pVpt->dwX;
    m_RastCtx.Clip.top = pVpt->dwY;
    m_RastCtx.Clip.bottom = pVpt->dwY + pVpt->dwHeight;
    m_RastCtx.Clip.right = pVpt->dwX + pVpt->dwWidth;
    return D3D_OK;
}

inline HRESULT
D3DContext::CreateRampLightingDriver(void)
{
    m_RastCtx.pRampDrv = RLDDIRampCreate(&m_RastCtx);

    if (m_RastCtx.pRampDrv == NULL)
    {
        return DDERR_OUTOFMEMORY;
    }
    else
    {
        return D3D_OK;
    }
}

inline void
D3DContext::DestroyRampLightingDriver(void)
{
    RLDDIRampDestroy((RLDDIRampLightingDriver*)m_RastCtx.pRampDrv);
    m_RastCtx.pRampDrv = NULL;
}

//----------------------------------------------------------------------------
//
// RastContextCreateC
//
// Calls RastContextCreate with the C bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateC(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_C);
}

//----------------------------------------------------------------------------
//
// RastContextCreateCMMX
//
// Calls RastContextCreate with the CMMX bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateCMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_CMMX);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMX
//
// Calls RastContextCreate with the MMX bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMX(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMX);
}

//----------------------------------------------------------------------------
//
// RastContextCreateMMXAsRGB
//
// Calls RastContextCreate with the MMX bead set, but remember that we
// came from RGB.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateMMXAsRGB(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    return RastContextCreate(pCtxData, (DWORD)D3DIBS_MMXASRGB);
}

//----------------------------------------------------------------------------
//
// RastContextCreateRamp
//
// Calls RastContextCreate with the ramp bead set.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreateRamp(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    HRESULT hr;

    hr = RastContextCreate(pCtxData, (DWORD)D3DIBS_RAMP);

    if (pCtxData->ddrval != D3D_OK)
    {
        return hr;
    }

    // Create a RampLightingDriver
    D3DContext *pDCtx = (D3DContext *)pCtxData->dwhContext;
    pCtxData->ddrval = pDCtx->CreateRampLightingDriver();

    // Init prim function table for RAMP
    pDCtx->InitRampFuncs();

    return hr;
}

//----------------------------------------------------------------------------
//
// RastContextCreate
//
// Creates a RASTCTX and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData, DWORD BeadSet)
{
    DDASSERT(pCtxData != NULL);

    D3DContext *pDCtx = new D3DContext;

    if (pDCtx == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pCtxData->ddrval =
        pDCtx->Initialize(pCtxData->lpDDS,
                          pCtxData->lpDDSZ,
                          BeadSet,
                          (DWORD)pCtxData->dwhContext);

    pCtxData->dwhContext = (ULONG_PTR)pDCtx;

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    if ((D3DI_SPTFMT_PALETTE8 == pCtx->iSurfaceType) &&
        (D3DIBS_RAMP != BeadSet))
    {
        // need a ramp lighting driver for 8 bit palettized RGB output
        pCtxData->ddrval = pDCtx->CreateRampLightingDriver();

        if (pCtxData->ddrval == D3D_OK)
        {
            // initialize the RGB8 palette
            RLDDIRampMakePaletteRGB8((RLDDIRampLightingDriver*)pCtx->pRampDrv);

            // Make sure DD Palette is updated after it gets set by FindLightingRange
            RLDDIRampUpdateDDPalette(pCtx);
        }
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastContextDestroy
//
// Destroy a rast context.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastContextDestroy", pCtxDestroyData);

    PD3DI_RASTCTX pCtx = pDCtx->GetRastCtx();
    if (pCtx->pRampDrv)
    {
        // destroy the ramp lighting driver, if one was created
        pDCtx->DestroyRampLightingDriver();
    }

    delete pDCtx;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// ValidateTextureStageState
//
// Utility function that returns an appropriate D3DERR_ if the current
// multi-texture setup can not be rendered, D3D_OK otherwise.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::ValidateTextureStageState(void)
{
#if DBG
    if ((m_RastCtx.pTexture[0] == m_RastCtx.pTexture[1]) &&
        (m_RastCtx.pTexture[0] != NULL) )
    {
        // except under very special circumstances, this will not work in RGB/MMX
        // since we keep a lot of stage state in the D3DI_SPANTEX structure
        D3D_ERR("(Rast) ValidateTextureStageState Warning, pTexture[0] == pTexture[1]");
    }
#endif
    for (INT i = 0; i < 2; i++)
    {
        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_COLOROP)])
        {
        default:
            return D3DERR_UNSUPPORTEDCOLOROPERATION;
        case D3DTOP_DISABLE:
            return D3D_OK;  // don't have to validate further if the stage is disabled
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
            break;
        }

        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_COLORARG1)] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TEXTURE):
            break;
        }

        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_COLORARG2)] &
                ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
        {
        default:
            return D3DERR_UNSUPPORTEDCOLORARG;
        case (D3DTA_TFACTOR):
        case (D3DTA_CURRENT):
        case (D3DTA_DIFFUSE):
            break;
        }

        switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_ALPHAOP)])
        {
        default:
            return D3DERR_UNSUPPORTEDALPHAOPERATION;
        case D3DTOP_DISABLE:
            break;
        case D3DTOP_SELECTARG1:
        case D3DTOP_SELECTARG2:
        case D3DTOP_MODULATE:
        case D3DTOP_MODULATE2X:
        case D3DTOP_MODULATE4X:
        case D3DTOP_ADD:
        case D3DTOP_ADDSIGNED:
        case D3DTOP_BLENDDIFFUSEALPHA:
        case D3DTOP_BLENDTEXTUREALPHA:
        case D3DTOP_BLENDFACTORALPHA:
        case D3DTOP_BLENDTEXTUREALPHAPM:
            // only validate alpha args if alpha op is not disable
            switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_ALPHAARG1)] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TEXTURE):
                break;
            }

            switch(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(i,D3DTSS_ALPHAARG2)] &
                    ~(D3DTA_ALPHAREPLICATE|D3DTA_COMPLEMENT))
            {
            default:
                return D3DERR_UNSUPPORTEDALPHAARG;
            case (D3DTA_TFACTOR):
            case (D3DTA_CURRENT):
            case (D3DTA_DIFFUSE):
                break;
            }
            break;
        }

    }
    // allow unused state to be zero'ed since this is so common
    if ( !((m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(2,D3DTSS_COLOROP)] == D3DTOP_DISABLE) ||
         (m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(2,D3DTSS_COLOROP)] == 0)) )
    {
        return D3DERR_TOOMANYOPERATIONS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastValidateTextureStageState
//
// Returns whether the current multitexture setup can be rendered and, if
// so, the number of passes required to render it.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;

    pData->ddrval = pDCtx->ValidateTextureStageState();

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastContextDestroyRamp
//
// Destroy a rast context.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastContextDestroyRamp(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastContextDestroy", pCtxDestroyData);

    pDCtx->DestroyRampLightingDriver();

    delete pDCtx;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastSetRenderTarget
//
// Update a rast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastSetRenderTarget", pTgtData);

    pTgtData->ddrval = pDCtx->FillContext(pTgtData->lpDDS, pTgtData->lpDDSZ);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// SetRenderState
//
// Check to see if a state change requires an update to the D3DCTX.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetRenderState(UINT32 uState, UINT32 uStateVal)
{
    // Assume d3dim has filtered out unchanged states
    StateChanged(uState);

    m_RastCtx.pdwRenderState[uState] = uStateVal;

    switch(uState)
    {
    case D3DRENDERSTATE_FOGENABLE      :
    case D3DRENDERSTATE_FOGCOLOR       :
    case D3DRENDERSTATE_FOGTABLEMODE   :
    case D3DRENDERSTATE_FOGTABLESTART  :
    case D3DRENDERSTATE_FOGTABLEEND    :
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        RampSetFogData(uState, uStateVal);
        break;
    case D3DRENDERSTATE_CULLMODE:
        // Set face culling sign from state.
        switch(uStateVal)
        {
        case D3DCULL_CCW:
            m_RastCtx.uCullFaceSign = 1;
            break;
        case D3DCULL_CW:
            m_RastCtx.uCullFaceSign = 0;
            break;
        case D3DCULL_NONE:
            m_RastCtx.uCullFaceSign = 2;
            break;
        }
        break;
    case D3DRENDERSTATE_ZENABLE:
        if ( (D3DZB_FALSE != uStateVal) && (NULL == m_RastCtx.pDDSZ) )
        {
            DPF(0, "(ERROR) (Rast) SetRenderState: Can't set D3DRENDERSTATE_ZENABLE to %d if there is no Z Buffer", uStateVal);
            m_RastCtx.pdwRenderState[uState] = D3DZB_FALSE;
        }
        break;
    case D3DRENDERSTATE_LASTPIXEL:
        // Set last-pixel flag from state.
        if (uStateVal)
        {
            m_PrimProc.SetFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        else
        {
            m_PrimProc.ClrFlags(PPF_DRAW_LAST_LINE_PIXEL);
        }
        break;


        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESS)] =
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)] =
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPMAPLODBIAS)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_BORDERCOLOR)] = uStateVal;
        MapTextureStage0State();
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        // assign to current texture
        MapTextureStage0State();
        break;

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy WRAPU/V to per-index controls
    case D3DRENDERSTATE_WRAPU:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_U : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_RastCtx.pdwRenderState[D3DRENDERSTATE_WRAP0] |= ((uStateVal) ? D3DWRAP_V : 0);
        StateChanged(D3DRENDERSTATE_WRAP0);
        break;

//
// NOTE - this compututation of cActTex does not account for blend-only stages
//
    case D3DRENDERSTATE_TEXTUREHANDLE:

        CHECK_AND_UNLOCK_TEXTURE;

        // map handle thru to stage 0
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_TEXTUREMAP)] = uStateVal;
        m_RastCtx.pTexture[1] = NULL;
        // set up for single stage
        if (uStateVal == 0)
        {
            m_RastCtx.pTexture[0] = NULL;
        }
        else
        {
            m_RastCtx.pTexture[0] = HANDLE_TO_SPANTEX(uStateVal);
        }
        // map stage 0 state to first texture
        MapTextureStage0State();
        UpdateActiveTexStageCount();
        break;

    case D3DHAL_TSS_TEXTUREMAP0:
        // Silently zero out legacy handle.  They didn't mean it.
        if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] != 0 &&
            uStateVal != 0)
        {
            m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

        CHECK_AND_UNLOCK_TEXTURE;

        if (uStateVal == 0)
        {
            if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] == 0)
            {
                m_RastCtx.pTexture[0] = NULL;
            }
            // don't set m_RastCtx.pTexture[1] = NULL (in case the handle is never
            // sent again).  cActTex will keep it from being used until pTexture[0] is
            // set to something
        }
        else
        {
#if DBG
            if (HANDLE_TO_SPANTEX(uStateVal) == m_RastCtx.pTexture[1])
            {
                D3D_ERR( "Stage1 and 2 have same texture handle." );
                return DDERR_INVALIDPARAMS;
            }
#endif
            m_RastCtx.pTexture[0] = HANDLE_TO_SPANTEX(uStateVal);
        }

        // map stage 0 state to first texture
        MapTextureStage0State();
        UpdateActiveTexStageCount();
        break;

    case D3DHAL_TSS_TEXTUREMAP1:
        // Silently zero out legacy handle.  They didn't mean it.
        if (m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] != 0 &&
            uStateVal != 0)
        {
            m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        }

        CHECK_AND_UNLOCK_TEXTURE;

        if (uStateVal == 0)
        {
            m_RastCtx.pTexture[1] = NULL;
        }
        else
        {
            // 2nd texture can only be enabled if there's an active
            // 1st texture, but computation of cActTex will prevent this
            // from happening
#if DBG
            if (HANDLE_TO_SPANTEX(uStateVal) == m_RastCtx.pTexture[0])
            {
                D3D_ERR( "Stage1 and 2 have same texture handle." );
                return DDERR_INVALIDPARAMS;
            }
#endif
            m_RastCtx.pTexture[1] = HANDLE_TO_SPANTEX(uStateVal);
        }

        // map stage 1 state to second texture
        MapTextureStage1State();
        UpdateActiveTexStageCount();
        break;


    // map single set ADDRESS to both U and V controls for stages 0 & 1
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESS):
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)] = uStateVal;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage0State();
        break;
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESS):
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSU)] = uStateVal;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSV)] = uStateVal;
        MapTextureStage1State();
        break;

    case D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MIPMAPLODBIAS):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MAXMIPLEVEL):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_BORDERCOLOR):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER):
        MapTextureStage0State();
        break;

    case D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSU):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSV):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MIPMAPLODBIAS):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MAXMIPLEVEL):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_BORDERCOLOR):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MAGFILTER):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MINFILTER):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_MIPFILTER):
        MapTextureStage1State();
        break;

    case D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1):
    case D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_COLOROP):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_COLORARG1):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_COLORARG2):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ALPHAOP):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ALPHAARG1):
    case D3DHAL_TSS_OFFSET(1,D3DTSS_ALPHAARG2):
        // anything that effects the validity of the texture blending
        // could change the number of active texture stages
        UpdateActiveTexStageCount();
        break;
    }

    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Steps through per-stage renderstate and computes
// a count of currently active texture stages.  For legacy texture, the count
// is at most one.
//
//-----------------------------------------------------------------------------
HRESULT D3DContext::UpdateActiveTexStageCount( void )
{
    HRESULT hr;
    UINT cNewActTex = 0;

    // conservative but correct
    if ((hr = ValidateTextureStageState()) == D3D_OK)
    {
        // always one active texture stage for legacy texture mode
        if ( NULL != m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
        {
            cNewActTex = 1;
        }
        else
        {
            // count number of contiguous-from-zero active texture blend stages
            for ( INT iStage=0; iStage<2; iStage++ )
            {
                // check for disabled stage (subsequent are thus inactive)
                // also conservatively checks for incorrectly enabled stage (might be legacy)
                if ( ( m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(iStage,D3DTSS_COLOROP)] == D3DTOP_DISABLE ) ||
                     ( m_RastCtx.pTexture[iStage] == NULL ) )
                {
                    break;
                }

                // stage is active
                cNewActTex ++;
            }
        }
    }
    if (m_RastCtx.cActTex != cNewActTex)
    {
        CHECK_AND_UNLOCK_TEXTURE;
        StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
        m_RastCtx.cActTex = cNewActTex;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// UpdateRenderStates
//
// Update a list of render states and notify components of state change.
//
//----------------------------------------------------------------------------
HRESULT D3DContext::
UpdateRenderStates(LPDWORD puStateChange, UINT cStateChanges)
{
    HRESULT hr;
    INT i;
    UINT32 State, StateVal;

    if (cStateChanges == 0)
    {
        return D3D_OK;
    }

    // Update the D3DCTX
    for (i = 0; i < (INT)cStateChanges; i++)
    {
        State = *puStateChange ++;
        StateVal = * puStateChange++;
        HR_RET(SetRenderState(State, StateVal));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// UpdateAllRenderStates
//
// Update all render states.
// It is still kept here because we probably need it in the case of fail-over.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::UpdateAllRenderStates(LPDWORD puStates)
{
    HRESULT hr, hrSet;
    INT i;

    DDASSERT(puStates != NULL);

    // Update D3DCTX.
    // Attempt to set as many states as possible, even if there are
    // errors on some.  This allows context initialization to work
    // even though some of the states fail due to dependencies on
    // other state, such as active texture handles.
    // SetRenderState failures are noted and returned eventually,
    // even if everything else succeeds.
    hrSet = D3D_OK;
    for (i = 0; i < D3DHAL_MAX_RSTATES_AND_STAGES; i++)
    {
        if ((hr = SetRenderState(i, puStates[i])) != D3D_OK)
        {
            hrSet = hr;
        }
    }

    return hrSet;
}

//----------------------------------------------------------------------------
//
// Dp2SetRenderStates
//
// Called by Drawprim2 to set render states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2SetRenderStates(LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Check for overrides
        if (IS_OVERRIDE(type)) {
            UINT32 override = GET_OVERRIDE(type);
            if (pRenderState->dwState)
            STATESET_SET(m_renderstate_override, override);
            else
            STATESET_CLEAR(m_renderstate_override, override);
            continue;
        }

        if (STATESET_ISSET(m_renderstate_override, type))
            continue;

        // Set the runtime copy (if necessary)
        if (NULL != lpdwRuntimeRStates)
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

            // Set the state
        HR_RET(SetRenderState(pRenderState->RenderState,
                            pRenderState->dwState));
    }

    hr = Begin();
    return hr;
}
//----------------------------------------------------------------------------
//
// Begin - Before rendering preparation
//
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Begin(void)
{
    HRESULT hr;

    DDASSERT((m_uFlags & D3DCONTEXT_IN_BEGIN) == 0);

    // ATTENTION call this less often?
    UpdateColorKeyAndPalette();

    // Check for state changes
    if (IsAnyStatesChanged())
    {
        // Check for fillmode change
        if (IsStateChanged(D3DRENDERSTATE_FILLMODE))
        {
            UpdatePrimFunctionTbl();
        }

        BOOL bMaxMipLevelsDirty = FALSE;
        for (INT j = 0; j < (INT)m_RastCtx.cActTex; j++)
        {
            PD3DI_SPANTEX pSpanTex = m_RastCtx.pTexture[j];
            if (pSpanTex)
            {
                bMaxMipLevelsDirty = bMaxMipLevelsDirty || (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY);
            }
        }

        if (IsStateChanged(D3DRENDERSTATE_TEXTUREHANDLE) ||
            IsStateChanged(D3DHAL_TSS_TEXTUREMAP0) ||
            IsStateChanged(D3DHAL_TSS_TEXTUREMAP1) ||
            bMaxMipLevelsDirty)
        {
            // Relock texture if texture handles have changed.
            // SetRenderState should have already unlocked the texture.
            if (m_uFlags & D3DCONTEXT_TEXTURE_LOCKED)
            {
                RastUnlockSpanTexture();
            }
            HR_RET(RastLockSpanTexture());
        }

        // Check for WRAP state change
        for (int iWrap=0; iWrap<8; iWrap++)
        {
            D3DRENDERSTATETYPE iWrapState = (D3DRENDERSTATETYPE)(D3DRENDERSTATE_WRAP0+iWrap);
            if (IsStateChanged(iWrapState))
            {
                int i;
                for (i=0; i < 2; i++)
                {
                    if (m_fvfData.TexIdx[i] == iWrap)
                    {
                        m_RastCtx.pdwWrap[i] = m_RastCtx.pdwRenderState[iWrapState];
                    }
                }
            }
        }

        // Notify primitive Processor of state change.
        m_PrimProc.StateChanged();

        // Clear state dirtybits
        ClearAllStatesDirtyBits();

        // Must call SpanInit AFTER texture is locked, since this
        // sets various flags and fields that are needed for bead choosing
        // Call SpanInit to setup the beads
        HR_RET(SpanInit(&m_RastCtx));
    }

    // If texture is not locked yet, lock it
    if (!(m_uFlags & D3DCONTEXT_TEXTURE_LOCKED))
    {
        HR_RET(RastLockSpanTexture());
    }

    // Lock rendering target.
    if ((hr=LockSurface(m_RastCtx.pDDS, (LPVOID *)&(m_RastCtx.pSurfaceBits))) != D3D_OK)
    {
        RastUnlockSpanTexture();
        return hr;
    }
    if (m_RastCtx.pDDSZ != NULL)
    {
        if ((hr=LockSurface(m_RastCtx.pDDSZ, (LPVOID *)&(m_RastCtx.pZBits))) != D3D_OK)
        {
            RastUnlockSpanTexture();
            UnlockSurface(m_RastCtx.pDDS);
            return hr;
        }
    }
    else
    {
        m_RastCtx.pZBits = NULL;
    }

    // Prepare the primitive processor
    m_PrimProc.Begin();
    m_uFlags |= D3DCONTEXT_IN_BEGIN;

    if (m_RastCtx.pRampDrv)
    {
        pTexRampmapSave = m_RastCtx.pTexRampMap;
    }

    return D3D_OK;

}


//-----------------------------------------------------------------------------
//
// MapTextureStage0/1State - Maps state0/stage1 texture state to spantex object
//
//-----------------------------------------------------------------------------
void
D3DContext::MapTextureStage0State( void )
{
    if (m_RastCtx.pTexture[0] == NULL) return;
    //
    // assign texture state from stage 0
    //
    m_RastCtx.pTexture[0]->TexAddrU = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSU)]);
    m_RastCtx.pTexture[0]->TexAddrV = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ADDRESSV)]);
    m_RastCtx.pTexture[0]->BorderColor = (D3DCOLOR)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_BORDERCOLOR)]);
    m_RastCtx.pTexture[0]->uMagFilter = (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER)]);
    m_RastCtx.pTexture[0]->uMinFilter = (D3DTEXTUREMINFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)]);
    m_RastCtx.pTexture[0]->uMipFilter = (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)]);
    m_RastCtx.pTexture[0]->cLOD =
        (D3DTFP_NONE == m_RastCtx.pTexture[0]->uMipFilter)
        ? 0 : m_RastCtx.pTexture[0]->cLODTex;
    {
        m_RastCtx.pTexture[0]->fLODBias = m_RastCtx.pfRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPMAPLODBIAS)];
    }
    if (m_RastCtx.pTexture[0]->iMaxMipLevel != (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAXMIPLEVEL)])
    {
        m_RastCtx.pTexture[0]->iMaxMipLevel = (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAXMIPLEVEL)];
        m_RastCtx.pTexture[0]->uFlags |= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
    }
}
void
D3DContext::MapTextureStage1State( void )
{
    if (m_RastCtx.pTexture[1] == NULL) return;
    //
    // assign texture state from stage 0
    //
    m_RastCtx.pTexture[1]->TexAddrU = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSU)]);
    m_RastCtx.pTexture[1]->TexAddrV = (D3DTEXTUREADDRESS)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_ADDRESSV)]);
    m_RastCtx.pTexture[1]->BorderColor = (D3DCOLOR)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_BORDERCOLOR)]);
    m_RastCtx.pTexture[1]->uMagFilter = (D3DTEXTUREMAGFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MAGFILTER)]);
    m_RastCtx.pTexture[1]->uMinFilter = (D3DTEXTUREMINFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MINFILTER)]);
    m_RastCtx.pTexture[1]->uMipFilter = (D3DTEXTUREMIPFILTER)(m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MIPFILTER)]);
    m_RastCtx.pTexture[1]->cLOD =
        (D3DTFP_NONE == m_RastCtx.pTexture[1]->uMipFilter)
        ? 0 : m_RastCtx.pTexture[1]->cLODTex;
    {
        m_RastCtx.pTexture[1]->fLODBias = m_RastCtx.pfRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MIPMAPLODBIAS)];
    }
    if (m_RastCtx.pTexture[1]->iMaxMipLevel != (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MAXMIPLEVEL)])
    {
        m_RastCtx.pTexture[1]->iMaxMipLevel = (INT32)m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_MAXMIPLEVEL)];
        m_RastCtx.pTexture[1]->uFlags |= D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter -
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureFilter( void )
{
    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER)] = D3DTFG_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MAGFILTER)] = D3DTFG_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_POINT;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_POINT;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_POINT;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_LINEAR;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_LINEAR;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MINFILTER)] = D3DTFN_LINEAR;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_MIPFILTER)] = D3DTFP_LINEAR;
        break;
    }
}

//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
D3DContext::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(1,D3DTSS_COLOROP)] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_RastCtx.pdwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_MODULATE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG1;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_MODULATE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_MODULATE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_BLENDTEXTUREALPHA;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP)]   = D3DTOP_ADD;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_COLORARG2)] = D3DTA_DIFFUSE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAOP)]   = D3DTOP_SELECTARG2;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG1)] = D3DTA_TEXTURE;
        m_RastCtx.pdwRenderState[D3DHAL_TSS_OFFSET(0,D3DTSS_ALPHAARG2)] = D3DTA_DIFFUSE;
        break;
    }

    // since we change [D3DHAL_TSS_OFFSET(0,D3DTSS_COLOROP), we can go from DISABLE to
    // something else, and we can need to update the TexStageCount
    UpdateActiveTexStageCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\sources.inc ===
TARGETNAME = rd3dif
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;..\..\rampmat;$(D3DROOT)\pipeln\inc;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        ..\d3dif.cpp\
        ..\swprov.cpp\
        ..\drawprim.cpp\
        $O\dprim2.cpp\
        ..\rendprim.cpp\
        ..\rastctx.cpp\
        ..\rasttex.cpp\
        ..\ramprov.cpp\
        ..\rampif.cpp\
        $O\pmfns.cpp\
        $O\nullif.cpp

NTTARGETFILE0 = \
        $O\pmfns_mh.h\
        $O\pmfns.cpp\
        $O\dprim2.cpp\
        $O\nullif.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\swprov.hpp ===
//----------------------------------------------------------------------------
//
// swprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SWPROV_HPP_
#define _SWPROV_HPP_

//----------------------------------------------------------------------------
//
// SwHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class SwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// RefRastHalProvider
//
// Specific provider for the reference rasterizer.
//
//----------------------------------------------------------------------------

class RefRastHalProvider : public SwHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Specific provider for the optimized software rasterizer.
//
//----------------------------------------------------------------------------

class OptRastHalProvider : public SwHalProvider
{
private:
    DWORD m_BeadSet;
public:
    OptRastHalProvider(THIS_
                       DWORD);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// RampRastHalProvider
//
// Specific provider for the ramp software rasterizer.
//
//----------------------------------------------------------------------------

class RampRastHalProvider : public SwHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider
//
// Specific provider for the null device.
//
//----------------------------------------------------------------------------

class NullDeviceHalProvider : public SwHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _SWPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rasttex.cpp ===
//----------------------------------------------------------------------------
//
// rasttex.cpp
//
// Texture functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// SetSizesSpanTexture
//
// Initialize pSpanTex data using current iMaxMipLevel info, Getting the
// surfaces from pSurf.  Assumes InitSpanTexture has been called first.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::SetSizesSpanTexture(PD3DI_SPANTEX pSpanTex)
{
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
    LPDIRECTDRAWSURFACE pDDS = pSpanTex->pSurf[iFirstSurf];
    INT i;

    // Init
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    pSpanTex->iSizeU = (INT16)DDSurf_Width(pLcl);
    pSpanTex->iSizeV = (INT16)DDSurf_Height(pLcl);
    pSpanTex->uMaskU = (INT16)(pSpanTex->iSizeU - 1);
    pSpanTex->uMaskV = (INT16)(pSpanTex->iSizeV - 1);
    pSpanTex->iShiftU = (INT16)IntLog2(pSpanTex->iSizeU);
    if (0 != DDSurf_BitDepth(pLcl))
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2((UINT32)(DDSurf_Pitch(pLcl) * 8)/DDSurf_BitDepth(pLcl));
    }
    else
    {
        pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl) * 8));
    }
    pSpanTex->iShiftV = (INT16)IntLog2(pSpanTex->iSizeV);
    pSpanTex->uMaskV = pSpanTex->uMaskV;

    // Check if the texture size is power of 2
    if (!ValidTextureSize(pSpanTex->iSizeU, pSpanTex->iShiftU,
                          pSpanTex->iSizeV, pSpanTex->iShiftV))
    {
        // this texture can only be used for a ramp fill
        pSpanTex->uFlags |= D3DI_SPANTEX_NON_POWER_OF_2;
        pSpanTex->cLODTex = 0;
    }

    // Check for mipmap if any.
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for ( i = iFirstSurf + 1; i <= pSpanTex->cLODTex; i++)
    {
        pDDS = pSpanTex->pSurf[i];
        // Check for invalid mipmap texture size
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;
        if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
            !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
        {
            return DDERR_INVALIDPARAMS;
        }
        if (0 != DDSurf_BitDepth(pLcl))
        {
            pSpanTex->iShiftPitch[i - iFirstSurf] =
                (INT16)IntLog2(((UINT32)DDSurf_Pitch(pLcl)*8)/DDSurf_BitDepth(pLcl));
        }
        else
        {
            pSpanTex->iShiftPitch[0] =
                (INT16)IntLog2(((UINT32)DDSurf_Width(pLcl)*8));
        }
        iPreSizeU = (INT16)DDSurf_Width(pLcl);
        iPreSizeV = (INT16)DDSurf_Height(pLcl);
    }
    pSpanTex->iMaxScaledLOD = ((pSpanTex->cLODTex + 1) << LOD_SHIFT) - 1;
    pSpanTex->uFlags &= ~D3DI_SPANTEX_MAXMIPLEVELS_DIRTY;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// InitSpanTexture
//
// Initializes the entire array of pSurf's (regardless of iMaxMipLevel) pointed
// to by the root surface of pDDS.  Sets all pSpanTex state that will not ever
// change in SetSizesSpanTexture.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::InitSpanTexture(PD3DI_SPANTEX pSpanTex, LPDIRECTDRAWSURFACE pDDS)
{
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    DDSCAPS ddscaps;
    static INT32 iGeneration = 0;

    // Init
    pSpanTex->iGeneration = iGeneration++;

    // Note that all pSpanTex elements are initialized to 0
    pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    // Set the transparent bit and the transparent color with pSurf[0]
    // initially
    if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
    {
        pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;
        pSpanTex->TransparentColor =
            pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
    }
    else
    {
        pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;
    }

    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &(pSpanTex->Format)));

    if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
        pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
    {
        if (pLcl->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
            }
            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
        }
        if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8)
        {
            pSpanTex->iPaletteSize = 256;
        }
        else
        {
            // PALETTE4
            pSpanTex->iPaletteSize = 16;
        }
    }
    pSpanTex->TexAddrU = D3DTADDRESS_WRAP;
    pSpanTex->TexAddrV = D3DTADDRESS_WRAP;
    pSpanTex->BorderColor = RGBA_MAKE(0xff, 0x00, 0xff, 0xff);

    // assign first pSurf here (mipmap chain gets assigned below)
    pSpanTex->pSurf[0] = pDDS;

    // Check for mipmap if any.
    LPDIRECTDRAWSURFACE pTmpS;
    // iPreSizeU and iPreSizeV store the size(u and v) of the previous level
    // mipmap. They are init'ed with the first texture size.
    INT16 iPreSizeU = pSpanTex->iSizeU, iPreSizeV = pSpanTex->iSizeV;
    for (;;)
    {
        memset(&ddscaps, 0, sizeof(DDSCAPS));
        ddscaps.dwCaps = DDSCAPS_TEXTURE;
        hr = pDDS->GetAttachedSurface(&ddscaps, &pTmpS);    //implicit AddRef
        if (hr == DDERR_NOTFOUND)
        {
            break;
        }
        else if (hr != D3D_OK)
        {
            return hr;
        }
        pDDS = pTmpS;

        pSpanTex->cLODTex ++;
        pSpanTex->pSurf[pSpanTex->cLODTex] = pTmpS;
    }

    pSpanTex->dwSize = sizeof(D3DI_SPANTEX);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RemoveTexture
//
// Check to see if the to-be-destroyed pSpanTex is currently used by the
// context. If yes, set the according entry to be NULL to disable texture.
//
//----------------------------------------------------------------------------
void D3DContext::RemoveTexture(PD3DI_SPANTEX pSpanTex)
{
    INT i;
    INT cActTex = (INT)m_RastCtx.cActTex;

    for (i = 0; i < cActTex; i++)
    {
        if (m_RastCtx.pTexture[i] == pSpanTex)
        {
            // NULL out the according texture and set dirty bits
            m_RastCtx.cActTex --;
            StateChanged(D3DRENDERSTATE_TEXTUREHANDLE);
            m_RastCtx.pTexture[i] = NULL;
            for (int j=pSpanTex->cLODTex;j>0;j--)   //release attached surfs
            {
                pSpanTex->pSurf[j]->Release();
            }
        }
    }
}
//----------------------------------------------------------------------------
//
// RastTextureCreate
//
// Creates a RAST texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureCreate", pTexData);

    // Create the span texture
    ppSpanTex = new PD3DI_SPANTEX;
    pSpanTex = new D3DI_SPANTEX;
    if (ppSpanTex == NULL || pSpanTex == NULL)
    {
        delete ppSpanTex;
        delete pSpanTex;
        D3D_ERR("(Rast) Out of memory in RastTextureCreate");
        pTexData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }
    memset(pSpanTex, 0, sizeof(D3DI_SPANTEX));

    // Point indirector to this texture initially.
    *ppSpanTex = pSpanTex;

    // Init the span texture
    if ((pTexData->ddrval = pDCtx->InitSpanTexture(pSpanTex, pTexData->lpDDS))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }
    if ((pTexData->ddrval = pDCtx->SetSizesSpanTexture(pSpanTex))
        != D3D_OK)
    {
        delete ppSpanTex;
        delete pSpanTex;
        return DDHAL_DRIVER_HANDLED;
    }

    // ppSpanTex is used as the texture handle returned to d3dim.
    pTexData->dwHandle = (UINT32)(ULONG_PTR)ppSpanTex;

    pTexData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureDestroy
//
// Destroy a RAST texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    PD3DI_SPANTEX *ppSpanTex;
    PD3DI_SPANTEX pSpanTex;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureDestroy", pTexDestroyData);
    if (!VALID_D3DI_SPANTEX_PTR_PTR(
        (PD3DI_SPANTEX*)ULongToPtr(pTexDestroyData->dwHandle)))
    {
        D3D_ERR("(Rast) in RastTextureDestroy, invalid texture handle");
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find the texture
    ppSpanTex = (PD3DI_SPANTEX *)ULongToPtr(pTexDestroyData->dwHandle);
    pSpanTex = *ppSpanTex;

    pDCtx->RemoveTexture(pSpanTex);

    // Delete it
    if (pSpanTex)
    {
        delete ppSpanTex;
        delete pSpanTex;
    }
    else
    {
        pTexDestroyData->ddrval = DDERR_INVALIDPARAMS;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureSwap
//
// Swaps over the ownership of two texture handles.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureSwap(LPD3DHAL_TEXTURESWAPDATA pTexSwapData)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureSwap", pTexSwapData);

    // Check out the span textures
    PD3DI_SPANTEX pSpanTex1, pSpanTex2;
    pSpanTex1 = HANDLE_TO_SPANTEX(pTexSwapData->dwHandle1);
    pSpanTex2 = HANDLE_TO_SPANTEX(pTexSwapData->dwHandle2);

    // Swap
    if (pSpanTex1 != NULL && pSpanTex2 != NULL)
    {
        HANDLE_TO_SPANTEX(pTexSwapData->dwHandle1) = pSpanTex2;
        HANDLE_TO_SPANTEX(pTexSwapData->dwHandle2) = pSpanTex1;
        pTexSwapData->ddrval = D3D_OK;
    }
    else
    {
        pTexSwapData->ddrval = DDERR_INVALIDPARAMS;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastTextureGetSurf", pTexGetSurf);

    // Check out the span texture
    PD3DI_SPANTEX pSpanTex;
    pSpanTex = HANDLE_TO_SPANTEX(pTexGetSurf->dwHandle);

    if (pSpanTex)
    {
        pTexGetSurf->lpDDS = (UINT_PTR)pSpanTex->pSurf[0];
        pTexGetSurf->ddrval = D3D_OK;
    }
    else
    {
        pTexGetSurf->ddrval = DDERR_INVALIDPARAMS;
    }
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastLockSpanTexture
//
// Lock current texture surface before the texture bits are accessed.
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::RastLockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;
    HRESULT hr;

    if (IsTextureOff())
    {
        return D3D_OK;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) == 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if (pSpanTex->uFlags & D3DI_SPANTEX_MAXMIPLEVELS_DIRTY)
        {
            hr = SetSizesSpanTexture(pSpanTex);
            if (hr != D3D_OK)
            {
                goto EH_Unlock;
            }
        }
        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);

        // Currently recursive locks are not allowed.
        DDASSERT((pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED) == 0);

        for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
        {
            hr = LockSurface(pSpanTex->pSurf[i],
                            (LPVOID*)&(pSpanTex->pBits[i-iFirstSurf]));
            if (hr != D3D_OK)
            {
                // Unlock any partial mipmap locks we've taken, as
                // RastUnlock can only handle entire textures being
                // locked or unlocked.
                while (--i >= 0)
                {
                    UnlockSurface(pSpanTex->pSurf[i]);
                }

                // Make sure that i is signed and that the above
                // loop exited properly.
                DDASSERT(i < 0);

                goto EH_Unlock;
            }
        }

        pSpanTex->uFlags |= D3DI_SPANTEX_SURFACES_LOCKED;
    }

    m_uFlags |= D3DCONTEXT_TEXTURE_LOCKED;

    return D3D_OK;

 EH_Unlock:
    if (j > 0)
    {
        // Unlock complete textures we've already locked.
        // RastUnlock will check the flags to figure
        // out which ones to unlock.
        RastUnlockSpanTexture();
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// RastUnlockTexture
//
// Unlock texture surface after the texture bits are accessed.
// The input is a D3DI_SPANTEX. NULL texture needs to be checked before this
// function gets called.
//
//----------------------------------------------------------------------------
void
D3DContext::RastUnlockSpanTexture(void)
{
    INT i, j;
    PD3DI_SPANTEX pSpanTex;;

    if (IsTextureOff())
    {
        return;
    }

    DDASSERT((m_uFlags & D3DCONTEXT_TEXTURE_LOCKED) != 0);

    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];

        INT iFirstSurf = min(pSpanTex->iMaxMipLevel, pSpanTex->cLODTex);
        // RastUnlock is used for cleanup in RastLock so it needs to
        // be able to handle partially locked mipmap chains.
        if (pSpanTex->uFlags & D3DI_SPANTEX_SURFACES_LOCKED)
        {
            for (i = iFirstSurf; i <= pSpanTex->cLODTex; i++)
            {
                UnlockSurface(pSpanTex->pSurf[i]);
            }

            pSpanTex->uFlags &= ~D3DI_SPANTEX_SURFACES_LOCKED;
        }
    }
    m_uFlags &= ~D3DCONTEXT_TEXTURE_LOCKED;
}

//----------------------------------------------------------------------------
//
// UpdateColorKeyAndPalette
//
// Updates the color key value and palette.
//
// Also, if the ColorKey enable for the texture has changed, set the texture handle
// dirty bit so the new mode is recognized in span init.
//
//----------------------------------------------------------------------------
void
D3DContext::UpdateColorKeyAndPalette(void)
{
    INT j;
    PD3DI_SPANTEX pSpanTex;

    // Set the transparent bit and the transparent color with pSurf[0]
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;
    for (j = 0;
        j < (INT)m_RastCtx.cActTex;
        j++)
    {
        pSpanTex = m_RastCtx.pTexture[j];
        if ((pSpanTex != NULL) && (pSpanTex->pSurf[0] != NULL))
        {
            pLcl = ((LPDDRAWI_DDRAWSURFACE_INT) pSpanTex->pSurf[0])->lpLcl;

            // Palette might be changed
            if (pSpanTex->Format == D3DI_SPTFMT_PALETTE8 ||
                    pSpanTex->Format == D3DI_SPTFMT_PALETTE4)
            {
                    if (pLcl->lpDDPalette)
                    {
                            LPDDRAWI_DDRAWPALETTE_GBL   pPal = pLcl->lpDDPalette->lpLcl->lpGbl;
                            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
                            {
                                    pSpanTex->uFlags |= D3DI_SPANTEX_ALPHAPALETTE;
                            }
                            pSpanTex->pPalette = (PUINT32)pPal->lpColorTable;
                    }
            }

            if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
            {
                // texture has a ColorKey value
                pSpanTex->TransparentColor =
                    pLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
                if (!(pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT))
                {
                    pSpanTex->uFlags |= D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(D3DHAL_TSS_OFFSET(j, D3DTSS_TEXTUREMAP));
                }
            }
            else
            {
                // texture does not have a ColorKey value
                if (pSpanTex->uFlags & D3DI_SPANTEX_HAS_TRANSPARENT)
                {
                    pSpanTex->uFlags &= ~D3DI_SPANTEX_HAS_TRANSPARENT;

                    // make sure this state change is recognized, and a new
                    // texture read function is used
                    StateChanged(D3DHAL_TSS_OFFSET(j, D3DTSS_TEXTUREMAP));
                }
            }
        }
    }
}

//----------------------------------------------------------------------------
//
// Dp2TextureStageState
//
// Called by Drawprim2 to set texture stage states..
//
//----------------------------------------------------------------------------
HRESULT
D3DContext::Dp2TextureStageState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwFvf)
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr;
    LPD3DHAL_DP2TEXTURESTAGESTATE pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);
    // Flush the prim proc before any state changs
    HR_RET(End(FALSE));

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        HR_RET(SetRenderState(D3DHAL_TSS_OFFSET((DWORD)pTexStageState->wStage,
                                              (DWORD)pTexStageState->TSState),
                            pTexStageState->dwValue));
    }

    HR_RET(CheckFVF(dwFvf));

    hr = Begin();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\rendprim.cpp ===
//----------------------------------------------------------------------------
//
// rendprim.cpp
//
// RastRenderState and RastRenderPrimitive.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#define DDS_LCL(x) ((LPDDRAWI_DDRAWSURFACE_INT)(x))->lpLcl

//----------------------------------------------------------------------------
//
// RendPoint
//
// Draw lists of points. Called by RastRenderPrimitive() for drawing points.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendPoints(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DPOINT pPt)
{
    INT i;
    LPD3DTLVERTEX pV;

    for (i = pIns->wCount; i > 0; i--)
    {
        INT iPts;
        for (iPts = pPt->wCount, pV = pVtx + pPt->wFirst;
             iPts > 0;
             iPts --, pV ++)
        {
            HRESULT hr;
            HR_RET(pfnPrims->pfnPoint(pCtx, (PUINT8)pV));
        }
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendLine
//
// Draw a list of lines. Called by RastRenderPrimitive() for drawing lines.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendLines(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DLINE pLine)
{
    INT i;
    LPD3DTLVERTEX pV0, pV1;

    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pLine->v1;
        pV1 = pVtx + pLine->v2;
        pLine = (LPD3DLINE)((PINT8)pLine + pIns->bSize);
        HR_RET(pfnPrims->pfnLine(pCtx, (PUINT8)pV0, (PUINT8)pV1));
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RendTriangle
//
// Draw a list of triangles. Called by RastRenderPrimitive() for drawing
// triangles.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
DoRendTriangles(LPVOID pCtx,
                 PRIMITIVE_FUNTIONS *pfnPrims,
                 LPD3DINSTRUCTION pIns,
                 LPD3DTLVERTEX pVtx,
                 LPD3DTRIANGLE pTri)
{
    LPD3DTLVERTEX pV0, pV1, pV2;
    INT i;
    for (i = pIns->wCount; i > 0; i --)
    {
        HRESULT hr;
        pV0 = pVtx + pTri->v1;
        pV1 = pVtx + pTri->v2;
        pV2 = pVtx + pTri->v3;
        HR_RET(pfnPrims->pfnTri(pCtx, (PUINT8)pV0, (PUINT8)pV1, 
                                (PUINT8)pV2, pTri->wFlags));
        pTri = (LPD3DTRIANGLE)((PINT8)pTri + pIns->bSize);
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for drawing primitives.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA pRenderData)
{
    LPD3DINSTRUCTION pIns;
    LPD3DTLVERTEX pVtx;
    PUINT8 pData, pPrim;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderPrimitive", pRenderData);

    if (pDCtx->GetRastCtx()->pdwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        pRenderData->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        pRenderData->ddrval = D3D_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // Find out necessary data
    pData = (PUINT8)(DDS_LCL(pRenderData->lpExeBuf)->lpGbl->fpVidMem);
    pIns = &pRenderData->diInstruction;
    pPrim = pData + pRenderData->dwOffset;
    pVtx = (LPD3DTLVERTEX)
                ((PUINT8)DDS_LCL(pRenderData->lpTLBuf)->lpGbl->fpVidMem
                + pRenderData->dwTLOffset);

    pRenderData->ddrval = pDCtx->Begin();
    if (pRenderData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    // Render
    switch (pIns->bOpcode) {
    case D3DOP_POINT:
        pDCtx->BeginPrimSet(D3DPT_POINTLIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendPoints((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DPOINT)pPrim);
        break;
    case D3DOP_LINE:
        pDCtx->BeginPrimSet(D3DPT_LINELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendLines((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DLINE)pPrim);
        break;
    case D3DOP_TRIANGLE:
        pDCtx->BeginPrimSet(D3DPT_TRIANGLELIST, RAST_TLVERTEX);
        pRenderData->ddrval = DoRendTriangles((LPVOID)pDCtx, pDCtx->GetFunsTbl(),
                                        pIns, pVtx, (LPD3DTRIANGLE)pPrim);
        break;
    default:
        D3D_ERR("(Rast) Wrong Opcode passed to the new rasterizer.");
        pRenderData->ddrval =  DDERR_INVALIDPARAMS;
        break;
    }

    HRESULT hr;

    hr = pDCtx->End();
    if (pRenderData->ddrval == D3D_OK)
    {
        pRenderData->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RastRenderPrimitive
//
// Called by Execute() for setting render states.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RastRenderState(LPD3DHAL_RENDERSTATEDATA pStateData)
{
    PUINT8 pData;
    LPD3DSTATE pState;
    INT i;
    D3DContext *pDCtx;

    VALIDATE_D3DCONTEXT("RastRenderState", pStateData);

    // Updates D3DCTX
    pData = (PUINT8) (((LPDDRAWI_DDRAWSURFACE_INT)
        (pStateData->lpExeBuf))->lpLcl->lpGbl->fpVidMem);
    for (i = 0, pState = (LPD3DSTATE) (pData + pStateData->dwOffset);
         i < (INT)pStateData->dwCount;
         i ++, pState ++)
    {
        UINT32 type = (UINT32) pState->drstRenderStateType;

        // Check for overrides
    if (IS_OVERRIDE(type)) {
        UINT32 override = GET_OVERRIDE(type);
        if (pState->dwArg[0])
        STATESET_SET(pDCtx->m_renderstate_override, override);
        else
        STATESET_CLEAR(pDCtx->m_renderstate_override, override);
        continue;
    }

    if (STATESET_ISSET(pDCtx->m_renderstate_override, type))
        continue;

        // Set the state
        pStateData->ddrval = pDCtx->SetRenderState(type, pState->dwArg[0]);
        if (pStateData->ddrval != D3D_OK)
        {
            return DDHAL_DRIVER_HANDLED;
        }
    }

    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3dif\swprov.cpp ===
//----------------------------------------------------------------------------
//
// swprov.cpp
//
// Implements software rasterizer HAL provider.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

extern HRESULT
RastService(ULONG_PTR dwCtx,
                RastServiceType srvType, DWORD arg1, LPVOID arg2);

#define nullPrimCaps \
{                                                                             \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0                \
}

#define nullTransCaps \
{                                                                             \
    sizeof(D3DTRANSFORMCAPS), 0                                               \
}

#define nullLightCaps \
{                                                                             \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0                                          \
}

D3DDEVICEDESC g_nullDevDesc =
{
    sizeof(D3DDEVICEDESC),      /* dwSize */
    0,                          /* dwFlags */
    0,                          /* dcmColorModel */
    0,                          /* dwDevCaps */
    nullTransCaps,              /* transformCaps */
    FALSE,
    nullLightCaps,              /* lightingCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwMaxBufferSize */
    0,                          /* dwMaxVertexCount */
    0, 0,
    0, 0,
    0, 0,
    0, 0
};

/**********************************************************
 *
 * Legacy caps, as pulled from mustard\direct3d\d3d\ddraw\getcaps.c
 *
 **********************************************************/

#undef BUILD_RAMP
#define devDesc rgbDevDescDX5
#include "getcaps.h"
#undef devDesc

/**********************************************************
 *
 * End legacy caps
 *
 **********************************************************/

static D3DDEVICEDESC rgbDevDesc = {0};
static D3DHAL_D3DEXTENDEDCAPS OptSwExtCaps;

static void
FillOutDeviceCaps( void )
{
    //
    //  set device description
    //
    rgbDevDesc.dwSize = sizeof(rgbDevDesc);

    rgbDevDesc.dwFlags =
        D3DDD_COLORMODEL            |
        D3DDD_DEVCAPS               |
        D3DDD_TRANSFORMCAPS         |
        D3DDD_LIGHTINGCAPS          |
        D3DDD_BCLIPPING             |
        D3DDD_LINECAPS              |
        D3DDD_TRICAPS               |
        D3DDD_DEVICERENDERBITDEPTH  |
        D3DDD_DEVICEZBUFFERBITDEPTH |
        D3DDD_MAXBUFFERSIZE         |
        D3DDD_MAXVERTEXCOUNT        ;
    rgbDevDesc.dcmColorModel = D3DCOLOR_RGB;
    rgbDevDesc.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     ;

    rgbDevDesc.dtcTransformCaps.dwSize = sizeof(D3DTRANSFORMCAPS);
    rgbDevDesc.dtcTransformCaps.dwCaps = D3DTRANSFORMCAPS_CLIP;
    rgbDevDesc.bClipping = TRUE;
    rgbDevDesc.dlcLightingCaps.dwSize = sizeof(D3DLIGHTINGCAPS);
    rgbDevDesc.dlcLightingCaps.dwCaps =
        D3DLIGHTCAPS_POINT         |
        D3DLIGHTCAPS_SPOT          |
        D3DLIGHTCAPS_DIRECTIONAL   |
        D3DLIGHTCAPS_PARALLELPOINT ;
    rgbDevDesc.dlcLightingCaps.dwLightingModel = D3DLIGHTINGMODEL_RGB;
    rgbDevDesc.dlcLightingCaps.dwNumLights = 0;

    rgbDevDesc.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    rgbDevDesc.dpcTriCaps.dwMiscCaps =
        D3DPMISCCAPS_CULLNONE |
        D3DPMISCCAPS_CULLCW   |
        D3DPMISCCAPS_CULLCCW  ;
    rgbDevDesc.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
        D3DPRASTERCAPS_ROP2                     |
        D3DPRASTERCAPS_XOR                      |
    //    D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
    //    D3DPRASTERCAPS_STIPPLE                  |
    //    D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
    //    D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
    //    D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
    //    D3DPRASTERCAPS_ZBIAS                    |
    //    D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE;
    //    D3DPRASTERCAPS_ANISOTROPY               ;
        rgbDevDesc.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    rgbDevDesc.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    rgbDevDesc.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    rgbDevDesc.dpcTriCaps.dwAlphaCmpCaps =
    rgbDevDesc.dpcTriCaps.dwZCmpCaps;
    rgbDevDesc.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    rgbDevDesc.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE  |
        D3DPTEXTURECAPS_POW2         |
        D3DPTEXTURECAPS_ALPHA        |
        D3DPTEXTURECAPS_TRANSPARENCY |
        D3DPTEXTURECAPS_ALPHAPALETTE |
        D3DPTEXTURECAPS_BORDER       |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             ;
    rgbDevDesc.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       ;
    rgbDevDesc.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    rgbDevDesc.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    rgbDevDesc.dpcTriCaps.dwStippleWidth = 4;
    rgbDevDesc.dpcTriCaps.dwStippleHeight = 4;

    //  line caps - copy tricaps and modify
    memcpy( &rgbDevDesc.dpcLineCaps, &rgbDevDesc.dpcTriCaps, sizeof(D3DPRIMCAPS) );

    rgbDevDesc.dwDeviceRenderBitDepth = DDBD_8 | DDBD_16 | DDBD_24 | DDBD_32;
    rgbDevDesc.dwDeviceZBufferBitDepth = D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS;
    rgbDevDesc.dwMaxBufferSize = 0;
    rgbDevDesc.dwMaxVertexCount = BASE_VERTEX_COUNT;

    // DX5 stuff (should be in sync with the extended caps reported below)
    rgbDevDesc.dwMinTextureWidth = 1;
    rgbDevDesc.dwMaxTextureWidth = 1024;
    rgbDevDesc.dwMinTextureHeight = 1;
    rgbDevDesc.dwMaxTextureHeight = 1024;
    rgbDevDesc.dwMinStippleWidth = 0;   //  stipple unsupported
    rgbDevDesc.dwMaxStippleWidth = 0;
    rgbDevDesc.dwMinStippleHeight = 0;
    rgbDevDesc.dwMaxStippleHeight = 0;


    //
    //  set extended caps
    //
    OptSwExtCaps.dwSize = sizeof(OptSwExtCaps);

    OptSwExtCaps.dwMinTextureWidth = 1;
    OptSwExtCaps.dwMaxTextureWidth = 1024;
    OptSwExtCaps.dwMinTextureHeight = 1;
    OptSwExtCaps.dwMaxTextureHeight = 1024;
    OptSwExtCaps.dwMinStippleWidth = 0;   //  stipple unsupported
    OptSwExtCaps.dwMaxStippleWidth = 0;
    OptSwExtCaps.dwMinStippleHeight = 0;
    OptSwExtCaps.dwMaxStippleHeight = 0;

    OptSwExtCaps.dwMaxTextureRepeat = 256;
    OptSwExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    OptSwExtCaps.dwMaxAnisotropy = 1;
    OptSwExtCaps.dvGuardBandLeft  = -32768.f;
    OptSwExtCaps.dvGuardBandTop   = -32768.f;
    OptSwExtCaps.dvGuardBandRight  = 32767.f;
    OptSwExtCaps.dvGuardBandBottom = 32767.f;
    OptSwExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    OptSwExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    OptSwExtCaps.dwFVFCaps = 2;
    OptSwExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
//        D3DTEXOPCAPS_ADDSIGNED2X               |
//        D3DTEXOPCAPS_SUBTRACT                  |
//        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       ;
//        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
//        D3DTEXOPCAPS_PREMODULATE               |
//        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
//        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
//        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
//        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
    OptSwExtCaps.wMaxTextureBlendStages = 2;
    OptSwExtCaps.wMaxSimultaneousTextures = 2;
}
//----------------------------------------------------------------------------
//
// SwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP SwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) SwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// SwHalProvider::GetCaps
//
// Returns software rasterizer caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
OptRastHalProvider::GetCaps(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC pHwDesc,
                       LPD3DDEVICEDESC pHelDesc,
                       DWORD dwVersion)
{
    *pHwDesc = g_nullDevDesc;

    if (rgbDevDesc.dwSize == 0)
    {
        FillOutDeviceCaps();
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);  // add extended caps to rgbDevDesc
    }
    if (dwVersion >= 3)
        *pHelDesc = rgbDevDesc;
    else
    {
        D3D_WARN(1, "(Rast) GetCaps: returning legacy caps for RGB rasterizer");
        *pHelDesc = rgbDevDescDX5;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider::GetInterface
//
// Returns driver interface data for opt rast.
//
//----------------------------------------------------------------------------

static D3DHAL_GLOBALDRIVERDATA SwDriverData =
{
    sizeof(D3DHAL_GLOBALDRIVERDATA),
    // The rest is filled in at runtime.
};

static D3DHAL_CALLBACKS OptRastCallbacksCMMX =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateCMMX,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksC =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateC,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMX =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMX,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS OptRastCallbacksMMXAsRGB =
{
    sizeof(D3DHAL_CALLBACKS),
    RastContextCreateMMXAsRGB,
    RastContextDestroy,
    NULL,
    NULL,
    NULL,
    NULL,
    RastRenderState,
    RastRenderPrimitive,
    NULL,
    RastTextureCreate,
    RastTextureDestroy,
    RastTextureSwap,
    RastTextureGetSurf,
    // All others NULL.
};

static D3DHAL_CALLBACKS2 OptRastCallbacks2 =
{
    sizeof(D3DHAL_CALLBACKS2),
    D3DHAL2_CB32_SETRENDERTARGET |
        D3DHAL2_CB32_DRAWONEPRIMITIVE |
        D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE |
        D3DHAL2_CB32_DRAWPRIMITIVES,
    RastSetRenderTarget,
    NULL,
    RastDrawOnePrimitive,
    RastDrawOneIndexedPrimitive,
    RastDrawPrimitives
};

static D3DHAL_CALLBACKS3 OptRastCallbacks3 =
{
    sizeof(D3DHAL_CALLBACKS3),
    D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
        D3DHAL3_CB32_DRAWPRIMITIVES2,
    NULL, // Clear2
    NULL, //lpvReserved
    RastValidateTextureStageState,
    RastDrawPrimitives2,
};

STDMETHODIMP
OptRastHalProvider::GetInterface(THIS_
                                 LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                                 LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                                 DWORD dwVersion)
{
    if (rgbDevDesc.dwSize == 0)
    {
        FillOutDeviceCaps();
        D3DDeviceDescConvert(&rgbDevDesc,NULL,&OptSwExtCaps);  // add extended caps to rgbDevDesc
    }

    memcpy(&SwDriverData.hwCaps, &rgbDevDesc, sizeof(SwDriverData.hwCaps));
    SW_RAST_TYPE RastType;
    switch(m_BeadSet)
    {
    default:
    case D3DIBS_C:
        RastType = SW_RAST_RGB;
        break;
    case D3DIBS_MMX:
        RastType = SW_RAST_MMX;
        break;
    case D3DIBS_MMXASRGB:
        RastType = SW_RAST_MMXASRGB;
        break;
    }
    // Vertex counts are left zero.
    SwDriverData.dwNumTextureFormats =
        TextureFormats(&SwDriverData.lpTextureFormats, dwVersion, RastType);
    SwDriverData.dwNumVertices = BASE_VERTEX_COUNT;
    SwDriverData.dwNumClipVertices = MAX_CLIP_VERTICES;
    pInterfaceData->pGlobalData = &SwDriverData;

    pInterfaceData->pExtCaps = &OptSwExtCaps;

    switch(m_BeadSet)
    {
    case D3DIBS_CMMX:       pInterfaceData->pCallbacks = &OptRastCallbacksCMMX;     break;
    case D3DIBS_MMX:        pInterfaceData->pCallbacks = &OptRastCallbacksMMX;      break;
    case D3DIBS_MMXASRGB:   pInterfaceData->pCallbacks = &OptRastCallbacksMMXAsRGB; break;
    case D3DIBS_C:          pInterfaceData->pCallbacks = &OptRastCallbacksC;        break;
    }
    pInterfaceData->pCallbacks2 = &OptRastCallbacks2;
    pInterfaceData->pCallbacks3 = &OptRastCallbacks3;

    pInterfaceData->pfnRampService = NULL;
    pInterfaceData->pfnRastService = RastService;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// OptRastHalProvider
//
// Constructor for OptRastHalProvider to allow a bit of private state to be
// kept to indicate which optimized rasterizer is to be used.
//
//----------------------------------------------------------------------------
OptRastHalProvider::OptRastHalProvider(THIS_
                       DWORD BeadSet)
{
    m_BeadSet = BeadSet;
}

//----------------------------------------------------------------------------
//
// GetSwProvider
//
// Returns the appropriate software HAL provider based on the given GUID.
//
//----------------------------------------------------------------------------

static OptRastHalProvider g_OptRastHalProviderC(D3DIBS_C);
static OptRastHalProvider g_OptRastHalProviderMMX(D3DIBS_MMX);
static OptRastHalProvider g_OptRastHalProviderCMMX(D3DIBS_CMMX);
static OptRastHalProvider g_OptRastHalProviderMMXAsRGB(D3DIBS_MMXASRGB);
static RampRastHalProvider g_RampRastHalProvider;
static NullDeviceHalProvider g_NullDeviceHalProvider;

STDAPI GetSwHalProvider(REFIID riid, IHalProvider **ppHalProvider,
                        HINSTANCE *phDll)
{
    *phDll = NULL;
    if (IsEqualIID(riid, IID_IDirect3DRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderC;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
    }
    else if (IsEqualIID(riid, IID_IDirect3DNewRGBDevice))
    {
        *ppHalProvider = &g_OptRastHalProviderCMMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        *ppHalProvider = &g_RampRastHalProvider;
    }
    else if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
             IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFHALPROVIDER pfnGetRefHalProvider;
        if (NULL == (pfnGetRefHalProvider =
            (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
        {
            *ppHalProvider = NULL;
            return E_NOINTERFACE;
        }
        D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
        pfnGetRefHalProvider(riid, ppHalProvider, phDll);
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    // As a debugging aid, allow the particular rasterizer to be forced
    // via a registry setting.  This lets a developer run an app on any
    // rasterizer regardless of what it asks for.

    // Don't remap ramp.
    if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        return S_OK;
    }

    LONG iRet;
    HKEY hKey;

    iRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
    if (iRet == ERROR_SUCCESS)
    {
        DWORD dwData, dwType;
        DWORD dwDataSize;

        dwDataSize = sizeof(dwData);
        iRet = RegQueryValueEx(hKey, "ForceRgbRasterizer", NULL,
                               &dwType, (BYTE *)&dwData, &dwDataSize);
        if (iRet == ERROR_SUCCESS &&
            dwType == REG_DWORD &&
            dwDataSize == sizeof(dwData))
        {
            switch(dwData)
            {
            case 1:
                *ppHalProvider = &g_OptRastHalProviderC;
                break;
            case 2:
                *ppHalProvider = &g_OptRastHalProviderCMMX;
                break;
            case 3:
                *ppHalProvider = &g_OptRastHalProviderMMX;
                break;
            case 4:
                {
                    // try to get provider from external DLL ref device
                    PFNGETREFHALPROVIDER pfnGetRefHalProvider;
                    if (NULL == (pfnGetRefHalProvider =
                                 (PFNGETREFHALPROVIDER)LoadReferenceDeviceProc("GetRefHalProvider")))
                    {
                        *ppHalProvider = NULL;
                        return E_NOINTERFACE;
                    }
                    D3D_INFO(0,"GetSwHalProvider: getting provider from d3dref");
                    pfnGetRefHalProvider(riid, ppHalProvider, phDll);
                    break;
                }
            case 5:
                *ppHalProvider = &g_NullDeviceHalProvider;
                break;
            case 6:
                *ppHalProvider = &g_OptRastHalProviderMMXAsRGB;
                break;
            case 0:
                // no override for 0
                break;
            default:
                D3D_ERR("(Rast) Unknown ForceRgbRasterizer setting - no force");
                break;
            }

            D3D_INFO(1, "(Rast) ForceRgbRasterizer to %d", dwData);
        }

        RegCloseKey(hKey);
    }

    return S_OK;
}

STDAPI GetSwTextureFormats(REFCLSID riid, LPDDSURFACEDESC* lplpddsd, DWORD dwD3DDeviceVersion) {

    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) 
    {
        D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: HAL GUID is not valid arg");
        *lplpddsd=NULL;
        return 0;
    }

    if(IsEqualIID(riid, IID_IDirect3DRefDevice) ||
       IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get provider from external DLL ref device
        PFNGETREFTEXTUREFORMATS pfnGetRefTextureFormats;
        if (NULL == (pfnGetRefTextureFormats =
                     (PFNGETREFTEXTUREFORMATS)LoadReferenceDeviceProc("GetRefTextureFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWTextureFormats Internal Error: d3dref.dll not found");
            *lplpddsd=NULL;
            return 0;
        }
        D3D_INFO(0,"GetSWTextureFormats: getting provider from d3dref");
        return pfnGetRefTextureFormats(riid, lplpddsd, dwD3DDeviceVersion);
    }

    if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        return RampTextureFormats(lplpddsd);
    }

    // else using RGB or internal ref device
    SW_RAST_TYPE RastType = SW_RAST_RGB;
    if (IsEqualIID(riid, IID_IDirect3DMMXDevice))
    {
        RastType = SW_RAST_MMX;
    }
    else if (IsEqualIID(riid, IID_IDirect3DMMXAsRGBDevice))
    {
        RastType = SW_RAST_MMXASRGB;
    }
    return TextureFormats(lplpddsd,dwD3DDeviceVersion, RastType);
}

STDAPI GetSwZBufferFormats(REFCLSID riid, DDPIXELFORMAT **ppDDPF)
{
    // assumes it can't get an invalid RIID.
    if(IsEqualIID(riid, IID_IDirect3DHALDevice)) 
    {
        D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: HAL GUID is not valid arg");
        *ppDDPF=NULL;
        return 0;
    }

    if (IsEqualIID(riid, IID_IDirect3DRefDevice) ||
        IsEqualIID(riid, IID_IDirect3DNullDevice))
    {
        // try to get Z buffer formats from external DLL ref device
        PFNGETREFZBUFFERFORMATS pfnGetRefZBufferFormats;
        if (NULL == (pfnGetRefZBufferFormats =
            (PFNGETREFZBUFFERFORMATS)LoadReferenceDeviceProc("GetRefZBufferFormats")))
        {
            D3D_WARN(2,"(Rast) GetSWZBufferFormats Internal Error: d3dref.dll not found");
            *ppDDPF=NULL;
            return 0;
        }
        return pfnGetRefZBufferFormats(riid, ppDDPF);
    }

    if (IsEqualIID(riid, IID_IDirect3DRampDevice))
    {
        return RampZBufferFormats(ppDDPF);
    }

    return ZBufferFormats(ppDDPF, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3drast\d3drast.cpp ===
#define INITGUID
#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>

//
//  dummy file to get build.exe to do something
//
//  also used to get guid's into d3drast.dll
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\d3drast\sources.inc ===
MAJORCOMP=d3drast
MINORCOMP=d3drast
TARGETNAME=d3drast
TARGETPATH=$(BASEDIR)\public\sdk\lib
TARGETTYPE=DYNLINK
DLLDEF=..\$(TARGETNAME).def
COFFBASE = usermode
SUBSYSTEM_VERSION=4.00

!IFDEF NTBBT
X3DLIB=x3dbbt.lib
!ELSE
X3DLIB=x3d.lib
!ENDIF

SYNCHRONIZE_DRAIN = 1

TARGETLIBS = \
        $(BASEDIR)\public\sdk\lib\*\user32.lib\
        $(BASEDIR)\public\sdk\lib\*\advapi32.lib\
        $(BASEDIR)\public\sdk\lib\*\uuid.lib

!if !("$(ALPHA)" == "1")
TARGETLIBS=$(TARGETLIBS) \
           $(D3DROOT)\lib\$(PLAT_DIR)\*\$(X3DLIB)
!endif

LINKLIBS = \
        $(D3DROOT)\d3dutil\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dutil.lib \
        $(D3DROOT)\pipeln\$(PLAT_DIR)\$(_OBJ_DIR)\*\pipeln.lib \
        $(D3DROOT)\d3dim\$(PLAT_DIR)\$(_OBJ_DIR)\*\d3dim.lib \
        $(D3DROOT)\rast\mmxemul\$(PLAT_DIR)\$(_OBJ_DIR)\*\mmxemul.lib \
        $(D3DROOT)\rast\refrast\$(PLAT_DIR)\$(_OBJ_DIR)\*\refrast.lib \
        $(D3DROOT)\rast\cspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rcspan.lib \
        $(D3DROOT)\rast\mmxspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmmxspan.lib \
        $(D3DROOT)\rast\rampspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrmpspan.lib \
        $(D3DROOT)\rast\rampmat\$(PLAT_DIR)\$(_OBJ_DIR)\*\rrampmat.lib \
        $(D3DROOT)\rast\mlspan\$(PLAT_DIR)\$(_OBJ_DIR)\*\rmlspan.lib \
        $(D3DROOT)\rast\spaninit\$(PLAT_DIR)\$(_OBJ_DIR)\*\rspanini.lib \
        $(D3DROOT)\rast\setup\$(PLAT_DIR)\$(_OBJ_DIR)\*\rsetup.lib \
        $(D3DROOT)\rast\d3dif\$(PLAT_DIR)\$(_OBJ_DIR)\*\rd3dif.lib

DLLENTRY = _DllMainCRTStartup

INCLUDES = ..\..\inc;$(D3DROOT)\pipeln\inc;$(INCLUDES)

SOURCES = \
        ..\d3drast.cpp \
        ..\d3drast.rc

BINPLACE_PLACEFILE = ..\d3drast.dir
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\dxshad.h ===
/*--

$Revision: 1 $

Copyright (c) 1995, Microsoft Corporation

--*/
#ifndef _DXSHAD_H_
#define _DXSHAD_H_

//////////////////////////////////////////////////////////////////////////
//
//  Needed extensions to D3D to support hardware, per pixel style shadows
//
//////////////////////////////////////////////////////////////////////////

typedef struct _D3DSHADOWDATA {
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    LPDIRECTDRAWSURFACE lpDDSZBuffer;      /* Shadow z-buffer surface */
    D3DMATRIX*          lpD3DMatrixEye;    /* Eye space transform matrix */
    D3DMATRIX*          lpD3DMatrixLight;  /* Light space transform matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasMax;        /* Maximum z bias */
    D3DVALUE            dvUJitter;         /* Shadow sample jitter in u */
    D3DVALUE            dvVJitter;         /* Shadow sample jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
} D3DSHADOWDATA, *LPD3DSHADOWDATA;

// D3DSHADOWDATA dwFlags
#define D3DSZBUF_ZBIAS      1
#define D3DSZBUF_UVJITTER   2
#define D3DSZBUF_TRIANGLEFILTER   4         /* for experimental purposes */

// This structure is how shadow information is communicated
// to the HAL
typedef struct _D3DI_SHADOWDATA{
    DWORD               dwSize;            /* Size of structure */
    DWORD               dwFlags;           /* Flags */
    DDSURFACEDESC       ddsdShadZ;         /* Shadow z-buffer surface */
    DWORD               dwShadZMaskU;      /* ~(ddsdShadZ.dwWidth-1) */
    DWORD               dwShadZMaskV;      /* ~(ddsdShadZ.dwHeight-1) */
    D3DMATRIX           MatrixShad;        /* Embedded Concatenated screen to light space matrix */
    D3DVALUE            dvAttenuation;     /* Attenuation of light in shadow */
    D3DVALUE            dvZBiasMin;        /* Minimum z bias */
    D3DVALUE            dvZBiasRange;      /* Maximum z bias - Minimum z bias */
    D3DVALUE            dvUJitter;         /* 4.4 integer jitter in u */
    D3DVALUE            dvVJitter;         /* 4.4 integer jitter in v */
    DWORD               dwFilterSize;      /* Size of shadow filter */
    DWORD               dwFilterArea;      /* dwFilterSize*dwFilterSize */
} D3DI_SHADOWDATA, *LPD3DI_SHADOWDATA;

// Additional D3DI_SHADOWDATA dwFlags
#define D3DSHAD_ENABLE  0x80000000          // set to enable shadowing

typedef enum _D3DSHADOWFILTERSIZE {
    D3DSHADOWFILTERSIZE_1x1 = 1,
    D3DSHADOWFILTERSIZE_2x2,
    D3DSHADOWFILTERSIZE_3x3,
    D3DSHADOWFILTERSIZE_4x4,
    D3DSHADOWFILTERSIZE_5x5,
    D3DSHADOWFILTERSIZE_6x6,
    D3DSHADOWFILTERSIZE_7x7,
    D3DSHADOWFILTERSIZE_8x8,
} D3DSHADOWFILTERSIZE;

#endif  // _DXSHAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\lists.h ===
/* Copyright (c) 1997-1998  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);

    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);

        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);

        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);

        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);

        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);

        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);

        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);

        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);

        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);

        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);

        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\mlspan.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Monolithic Rasterizer Functions - Public Header File
//
///////////////////////////////////////////////////////////////////////////////


#ifndef _MONOSPAN_H
#define _MONOSPAN_H

#include "span.h"

DllExport HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\rast.h ===
//----------------------------------------------------------------------------
//
// rast.h
//
// Umbrella header file for the rasterizers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAST_H_
#define _RAST_H_

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

#include <d3ditype.h>
#include <d3dutil.h>
#include <span.h>

#endif // #ifndef _RAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\mmxemul.h ===
//-----------------------------------------------------------------------------
//
// This file contains headers for routines that emulate MMX instructions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// union for playing with 16 bit multiplies
typedef union tagVAL32 {
    INT32 i;
    struct {
        INT16 l;
        INT16 h;
    } i16;
} VAL32;

UINT16 MMX_addsw(INT16 x, INT16 y);
INT16  MMX_addusw(UINT16 x, UINT16 y);
UINT16 MMX_cmpeqw(INT16 x, INT16 y);
UINT16 MMX_cmpgtw(INT16 x, INT16 y);
INT16  MMX_mulhw(INT16 x, INT16 y);
INT16  MMX_mullw(INT16 x, INT16 y);
INT16  MMX_subsw(INT16 x, INT16 y);
UINT16 MMX_subusw(UINT16 x, UINT16 y);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\mlrfns.h ===
#ifndef _CMLRFNS_H_
#define _CMLRFNS_H_

#ifdef __cplusplus
  extern "C" {
#endif

HRESULT MMXMLRast_1(PD3DI_RASTCTX);
HRESULT MMXMLRast_2(PD3DI_RASTCTX);
HRESULT MMXMLRast_3(PD3DI_RASTCTX);
HRESULT MMXMLRast_4(PD3DI_RASTCTX);
HRESULT MMXMLRast_5(PD3DI_RASTCTX);
HRESULT MMXMLRast_6(PD3DI_RASTCTX);
HRESULT MMXMLRast_7(PD3DI_RASTCTX);
HRESULT MMXMLRast_8(PD3DI_RASTCTX);
HRESULT MMXMLRast_9(PD3DI_RASTCTX);
HRESULT MMXMLRast_10(PD3DI_RASTCTX);
HRESULT MMXMLRast_11(PD3DI_RASTCTX);
HRESULT MMXMLRast_12(PD3DI_RASTCTX);
HRESULT MMXMLRast_13(PD3DI_RASTCTX);
HRESULT MMXMLRast_14(PD3DI_RASTCTX);
HRESULT MMXMLRast_15(PD3DI_RASTCTX);
HRESULT MMXMLRast_16(PD3DI_RASTCTX);
HRESULT MMXMLRast_17(PD3DI_RASTCTX);
HRESULT MMXMLRast_18(PD3DI_RASTCTX);
HRESULT MMXMLRast_19(PD3DI_RASTCTX);
HRESULT MMXMLRast_20(PD3DI_RASTCTX);
HRESULT MMXMLRast_21(PD3DI_RASTCTX);
HRESULT MMXMLRast_22(PD3DI_RASTCTX);
HRESULT MMXMLRast_23(PD3DI_RASTCTX);
HRESULT MMXMLRast_24(PD3DI_RASTCTX);
HRESULT MMXMLRast_25(PD3DI_RASTCTX);
HRESULT MMXMLRast_26(PD3DI_RASTCTX);
HRESULT MMXMLRast_27(PD3DI_RASTCTX);
HRESULT MMXMLRast_28(PD3DI_RASTCTX);

#ifdef __cplusplus
}
#endif


HRESULT CMLRast_1(PD3DI_RASTCTX);
HRESULT CMLRast_2(PD3DI_RASTCTX);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\nothing.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// Does nothing and is only used as a test to see if bead selector can get here.
//
//-----------------------------------------------------------------------------
HRESULT Monolithic_RenderSpansTestSelector(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            //pCtx->pfnBegin(pCtx, pP, pS);
            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
typedef struct tagATTRSET
{
    union
    {
        struct
        {
            PUINT8 pSurface, pZ;
        };
        struct
        {
            INT32 ipSurface, ipZ;
        };
    };

    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };

    union
    {
        struct
        {
            FLOAT fUoW1, fVoW1;
        };
        struct
        {
            INT32 iUoW1, iVoW1;
        };
    };

    union
    {
        struct
        {
            FLOAT fUoW2, fVoW2;
        };
        struct
        {
            INT32 iUoW2, iVoW2;
        };
    };

    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
        struct
        {
            FLOAT fDIdx, fDIdxA;
        };
        struct
        {
            INT32 iDIdx, iDIdxA;
        };
        struct
        {
            UINT32 uDIdx, uDIdxA;
        };
    };

    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS;
        };
        struct
        {
            INT32 iBS, iGS, iRS;
        };
        struct
        {
            UINT32 uBS, uGS, uRS;
        };
    };
    union
    {
        FLOAT fFog;
        INT32 iFog;
        UINT32 uFog;
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef struct tagSETUPCTX *PSETUPCTX;

typedef void (FASTCALL *PFN_ADDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, PSETUPCTX pStpCtx);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta,
     PSETUPCTX pStpCtx, int iScale);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     PSETUPCTX pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[];

// Triangle trapezoid walkers.
typedef HRESULT (FASTCALL *PFN_WALKTRAPSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     PSETUPCTX pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[];
extern PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs, PSETUPCTX pStpCtx);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

typedef void (FASTCALL *PFN_SETUPTRIATTR)
    (PSETUPCTX pStpCtx, LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
     LPD3DTLVERTEX pV2);

//
// Setup flags.
//

// Per primitive set.
#define PRIMSF_DIFF_USED                0x00000001
#define PRIMSF_SPEC_USED                0x00000002
#define PRIMSF_TEX1_USED                0x00000004
#define PRIMSF_TEX2_USED                0x00000008
#define PRIMSF_DIDX_USED                0x00000010
#define PRIMSF_LOCAL_FOG_USED           0x00000020
#define PRIMSF_GLOBAL_FOG_USED          0x00000040
#define PRIMSF_Z_USED                   0x00000080
#define PRIMSF_LOD_USED                 0x00000100
#define PRIMSF_PERSP_USED               0x00000200
#define PRIMSF_FLAT_SHADED              0x00000400

#define PRIMSF_COLORS_USED              (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED)
#define PRIMSF_TEX_USED                 (PRIMSF_TEX1_USED | PRIMSF_TEX2_USED)
#define PRIMSF_ALL_USED \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_PERSP_USED | \
     PRIMSF_DIDX_USED)

#define PRIMSF_SLOW_USED \
    (PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_LOCAL_FOG_USED | PRIMSF_GLOBAL_FOG_USED | PRIMSF_TEX2_USED)

#define PRIMSF_ALL \
    (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED | \
     PRIMSF_TEX2_USED | PRIMSF_DIDX_USED  | PRIMSF_LOCAL_FOG_USED |\
     PRIMSF_GLOBAL_FOG_USED | PRIMSF_Z_USED | PRIMSF_LOD_USED | \
     PRIMSF_PERSP_USED | PRIMSF_FLAT_SHADED)

// Per primitive.
#define PRIMF_FIXED_OVERFLOW            0x00001000
#define PRIMF_TRIVIAL_ACCEPT_Y          0x00002000
#define PRIMF_TRIVIAL_ACCEPT_X          0x00004000

#define PRIMF_ALL \
    (PRIMF_TRIVIAL_ACCEPT_Y | PRIMF_TRIVIAL_ACCEPT_X | PRIMF_FIXED_OVERFLOW)

// No point flags right now.
#define PTF_ALL 0

// Per line.
#define LNF_X_MAJOR                     0x00008000

#define LNF_ALL \
    (LNF_X_MAJOR)

// Per triangle.
#define TRIF_X_DEC                      0x00008000
#define TRIF_RASTPRIM_OVERFLOW          0x00010000

#define TRIF_ALL \
    (TRIF_X_DEC | TRIF_RASTPRIM_OVERFLOW)

// PWL support flags.
#define PWL_NEXT_LOD                    0x00000001

#ifdef PWL_FOG
#define PWL_NEXT_FOG                    0x00000002
// Suppress computation of next fog for lines.
// No equivalent flag for LOD since lines don't support LOD.
#define PWL_NO_NEXT_FOG                 0x00000004
#endif

// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current PrimProcessor for span allocator calls.
    PVOID PrimProcessor;

    // Current primitive.
    PD3DI_RASTPRIM pPrim;

    // Per-primitive flags.
    UINT uFlags;

    // Flat shading vertex pointer.
    LPD3DTLVERTEX pFlatVtx;

    // Maximum span length allowed.
    INT cMaxSpan;

    //
    // Piecewise-linear support for LOD and global fog.
    //
    UINT uPwlFlags;

    // LOD.
    FLOAT fNextW;
    FLOAT fNextOoW;
    FLOAT fNextUoW1, fNextVoW1;
    INT iNextLOD;

    // Local fog X delta.  Fog deltas are always sent through RASTSPAN
    // instead of RASTPRIM to make the local and global cases the same.
    // For the local fog case where the delta doesn't change convert
    // it once and keep it here.
    INT iDLocalFogDX;
#ifdef PWL_FOG
    // Global fog.
    FLOAT fNextZ;
    UINT uNextFog;
#endif

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKTRAPSPANS pfnWalkTrapSpans;

    // Triangle attribute setup beads.
    PFN_SETUPTRIATTR pfnTriSetupFirstAttr;
    PFN_SETUPTRIATTR pfnTriSetupZEnd;
    PFN_SETUPTRIATTR pfnTriSetupTex1End;
    PFN_SETUPTRIATTR pfnTriSetupTex2End;
    PFN_SETUPTRIATTR pfnTriSetupDiffEnd;
    PFN_SETUPTRIATTR pfnTriSetupSpecEnd;
    PFN_SETUPTRIATTR pfnTriSetupFogEnd;

    // Current X and Y values.
    INT iX, iY;

    union
    {
        // Edge fraction and delta for lines.
        struct
        {
            INT iLineFrac, iDLineFrac;
        };

        // Edge X walkers for triangles.
        struct
        {
            INTCARRYVAL X20, X10, X21;
        };
    };

    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;

    // Long edge attribute values.
    ATTRSET Attr;

    union
    {
        // Attribute major axis deltas for lines.
        ATTRSET DAttrDMajor;

        // Attribute X deltas for triangles.
        ATTRSET DAttrDX;
    };

    // Attribute Y deltas.
    ATTRSET DAttrDY;

    // Span-to-span deltas when attribute edge carries a pixel.
    INT iDXCY, iDYCY;
    ATTRSET DAttrCY;

    // Span-to-span deltas when attribute edge doesn't carry a pixel.
    INT iDXNC, iDYNC;
    ATTRSET DAttrNC;

    union
    {
        // One over length for lines.
        FLOAT fOoLen;

        // One over determinant for triangles.
        FLOAT fOoDet;
    };

    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;

    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;

    // Subpixel correction amounts.
    union
    {
        // Lines.
        FLOAT fDMajor;

        // Triangles.
        struct
        {
            FLOAT fDX, fDY;
        };
    };

    // Pixel length of line.
    INT cLinePix;
} SETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\cmlrast.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains C span loops.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

HRESULT
CMLRast_1(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    *(PUINT16)pS->pSurface =
                        ((pCtx->SI.uBR >>  1) & 0x7c00) |
                        ((pCtx->SI.uBG >>  6) & 0x03e0) |
                        ((pCtx->SI.uBB >> 11) & 0x001f) |
                        0x8000;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}

HRESULT
CMLRast_2(
    PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            UINT16 uPix = pS->uPix;
            INT iSurfaceStep;
            INT iZStep;

            if (pP->uFlags & D3DI_RASTPRIM_X_DEC) {
                iZStep = -pCtx->iZStep;
                iSurfaceStep = -pCtx->iSurfaceStep;
                pCtx->SI.iXStep = -1;   // for dithering
            } else {
                iZStep = pCtx->iZStep;
                iSurfaceStep = pCtx->iSurfaceStep;
                pCtx->SI.iXStep = 1;
            }

            while (1) {
                UINT16 uZ = (UINT16)(pS->uZ>>15);
                UINT16 uZB = *((UINT16*)pS->pZ);
                pS->uZ += pP->iDZDX;
                if ((pCtx->iZXorMask)^(uZ > uZB)) {
                    *((UINT16*)pS->pZ) = uZ;
                    pCtx->SI.uBB = pS->uB;
                    pCtx->SI.uBG = pS->uG;
                    pCtx->SI.uBR = pS->uR;
                    pCtx->SI.uBA = pS->uA;
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    pCtx->SI.uBB = (UINT16)min((UINT32)pCtx->SI.uBB + (UINT32)pS->uBS, 0xffff);
                    pCtx->SI.uBG = (UINT16)min((UINT32)pCtx->SI.uBG + (UINT32)pS->uGS, 0xffff);
                    pCtx->SI.uBR = (UINT16)min((UINT32)pCtx->SI.uBR + (UINT32)pS->uRS, 0xffff);
                    pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                    pS->uRS += pP->iDRSDX;
                    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                                             pCtx->SI.uBB>>8, 0xff);
                    PUINT32 pSurface = (PUINT32)pS->pSurface;
                    *pSurface = uARGB;
                } else {
                    pS->uB += pP->iDBDX; pS->uG += pP->iDGDX;
                    pS->uR += pP->iDRDX; pS->uA += pP->iDADX;
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
                        pS->uBS += pP->iDBSDX; pS->uGS += pP->iDGSDX;
                        pS->uRS += pP->iDRSDX;
                    }
                    if (pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE]) {
                        pS->uFog += (INT16)pS->iDFog;
                        pCtx->SI.uFogB += pCtx->SI.iFogBDX;
                        pCtx->SI.uFogG += pCtx->SI.iFogGDX;
                        pCtx->SI.uFogR += pCtx->SI.iFogRDX;
                    }
                }
                if (--uPix <= 0)
                    break;
                pS->pZ += iZStep;
                pS->pSurface += iSurfaceStep;
#ifdef DBG
                // handy for debug to see where we are
                pS->uX += (INT16)pCtx->SI.iXStep;
#endif
            }

            pS++;
        }

        pP = pP->pNext;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
#include "mlspan.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\inc\setup.hpp ===
//----------------------------------------------------------------------------
//
// setup.hpp
//
// Setup declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SETUP_HPP_
#define _SETUP_HPP_

#pragma warning(disable:4786)

#include "stp_base.h"

// PrimProcessor flags.
#define PPF_IN_BEGIN                    0x00000001
#define PPF_STATE_CHANGED               0x00000002
#define PPF_NORMALIZE_RHW               0x00000004
#define PPF_DRAW_LAST_LINE_PIXEL        0x00000008

// Bounds for normalized RHWs.  These are not quite the ideal bounds to
// avoid over- and underflow after normalization when at least one RHW is
// guaranteed to be at the bounds.  There is no reason it
// has to be normalized to [0,1] anway, other than to try and spread
// the values across the desired range.
#define NORMALIZED_RHW_MIN g_fZero
#define NORMALIZED_RHW_MAX g_fp95

//----------------------------------------------------------------------------
//
// PrimProcessor
//
// Accepts primitives to be rasterized.  Primitive and span descriptions
// are put into a buffer for later processing by the span-level code.
//
//----------------------------------------------------------------------------

class DllExport PrimProcessor
{
public:
    PrimProcessor(void);
    HRESULT Initialize(void);
    ~PrimProcessor(void);

    inline UINT GetFlags(void);
    inline void SetFlags(UINT uFlags);
    inline void ClrFlags(UINT uFlags);

    inline void StateChanged();

    void SetCtx(PD3DI_RASTCTX pCtx);

    void BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                      RAST_VERTEX_TYPE VertType);

    HRESULT Point(LPD3DTLVERTEX pV0,
                  LPD3DTLVERTEX pFlatVtx);
    HRESULT Line(LPD3DTLVERTEX pV0,
                 LPD3DTLVERTEX pV1,
                 LPD3DTLVERTEX pFlatVtx);
    HRESULT Tri(LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1,
                LPD3DTLVERTEX pV2);

    void Begin(void);
    HRESULT End(void);

    HRESULT AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan);
    void FreeSpans(UINT cSpans);

private:
    // Original FP control word.
    UINT16 m_uFpCtrl;

    // Buffer space and current pointer.
    PUINT8 m_pBuffer;
    PUINT8 m_pBufferStart;
    PUINT8 m_pBufferEnd;
    PUINT8 m_pCur;

    // Flags.
    UINT m_uPpFlags;

    //
    // Intermediate results shared between methods.
    //

    SETUPCTX m_StpCtx;

    // Previous primitive, for primitive chaining.
    PD3DI_RASTPRIM m_pOldPrim;

    // Attribute function table index.
    INT m_iAttrFnIdx;

    // Old primitive and vertex types.
    D3DPRIMITIVETYPE m_PrimType;
    RAST_VERTEX_TYPE m_VertType;

    //
    // Triangle values.
    //

    // Y values and trapezoid heights.
    INT m_iY1, m_iY2;
    UINT m_uHeight10, m_uHeight21, m_uHeight20;

    // Triangle X extent.
    INT m_iXWidth;

    // Original RHW saved during RHW normalization.
    D3DVALUE m_dvV0RHW;
    D3DVALUE m_dvV1RHW;
    D3DVALUE m_dvV2RHW;

    //
    // Point methods.
    //
    void NormalizePointRHW(LPD3DTLVERTEX pV0);
    void FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan);

    //
    // Line methods.
    //
    void NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);
    BOOL PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                           BOOL bSlopeIsOne, BOOL bSlopeIsPosOne);
    BOOL LineSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1);

    //
    // Triangle methods.
    //
    void NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                         LPD3DTLVERTEX pV2);
    BOOL TriSetup(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1, LPD3DTLVERTEX pV2);
    inline void SetTriFunctions(void);

    //
    // Buffer management methods.
    //
    inline void ResetBuffer(void);
    HRESULT Flush(void);
    HRESULT FlushPartial(void);
    HRESULT AppendPrim(void);

#if DBG
    //
    // Debug methods.  Only callable within DBG builds.
    //
    inline HRESULT ValidateVertex(LPD3DTLVERTEX pV);
#endif
};

//----------------------------------------------------------------------------
//
// PrimProcessor::GetFlags
//
// Returns the current PrimProcessor flags.
//
//----------------------------------------------------------------------------

inline UINT
PrimProcessor::GetFlags(void)
{
    return m_uPpFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetFlags
//
// Sets the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetFlags(UINT uFlags)
{
    m_uPpFlags |= uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ClrFlags
//
// Clears the given flags.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ClrFlags(UINT uFlags)
{
    m_uPpFlags &= ~uFlags;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::StateChanged
//
// Notifies the PrimProcessor that state has changed.
// Could be done through SetFlags but this hides the actual implementation.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::StateChanged(void)
{
    m_uPpFlags |= PPF_STATE_CHANGED;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ComputeIntCarry
//
// Takes an FP coordinate value and span delta and computes integer form
// for int/carry arithmetic.
//
// NOTE: Assumes iV already computed.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

// Prototype is:
// inline void
// PrimProcessor::ComputeIntCarry(FLOAT fV, FLOAT fDVDS, PINTCARRYVAL pICY)
//
// Fraction is biased by one to handle exactly-integer coordinate
// values properly.

#define ComputeIntCarry(fV, fDVDS, pICY)                                      \
    ((pICY)->iFrac = (SCALED_FRACTION((fV) - FLOORF(fV)) - 1) & 0x7fffffff,   \
     (pICY)->iNC = FTOI(fDVDS),                                               \
     (pICY)->iDFrac = SCALED_FRACTION((fDVDS) - (pICY)->iNC),                 \
     (pICY)->iCY = FLOAT_LTZ(fDVDS) ? (pICY)->iNC - 1 : (pICY)->iNC + 1)

//----------------------------------------------------------------------------
//
// PrimProcessor::GetPrim
//
// Moves prim pointer to the next position in the buffer, flushing
// to make space if necessary.  Checks to see if there's space for
// at least one span also since it doesn't make much sense to not
// flush if there's exactly enough space for just the prim structure.
//
// Does not update m_pCur until CommitPrim.  m_pCur == pPrim
// indicates pPrim is not fully valid.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define GET_PRIM()                                                            \
{                                                                             \
    if (m_pCur + (sizeof(D3DI_RASTPRIM) + sizeof(D3DI_RASTSPAN)) >            \
        m_pBufferEnd)                                                         \
    {                                                                         \
        HRESULT hr;                                                           \
                                                                              \
        RSHRRET(Flush());                                                     \
    }                                                                         \
                                                                              \
    m_StpCtx.pPrim = (PD3DI_RASTPRIM)m_pCur;                                  \
}

//----------------------------------------------------------------------------
//
// PrimProcessor::CommitPrim
//
// Commits the current primitive space so that spans may be added.
// The primitive data can be partly or fulled cleared as part of
// the commit.
//
// Written as a macro because the compiler doesn't inline it even when
// declared as an inline method.
//
//----------------------------------------------------------------------------

#define COMMIT_PRIM(bClearAll)                                                \
{                                                                             \
    m_pCur = (PUINT8)(m_StpCtx.pPrim + 1);                                    \
                                                                              \
    if (m_pOldPrim != NULL)                                                   \
    {                                                                         \
        m_pOldPrim->pNext = m_StpCtx.pPrim;                                   \
    }                                                                         \
    m_pOldPrim = m_StpCtx.pPrim;                                              \
                                                                              \
    if (bClearAll)                                                            \
    {                                                                         \
        memset(m_StpCtx.pPrim, 0, sizeof(*m_StpCtx.pPrim));                   \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        m_StpCtx.pPrim->uSpans = 0;                                           \
        m_StpCtx.pPrim->pNext = NULL;                                         \
    }                                                                         \
}

#define ALLOC_SPANS(pStpCtx, pcSpans, ppSpan) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->AllocSpans(pcSpans, ppSpan)
#define FREE_SPANS(pStpCtx, cSpans) \
    ((PrimProcessor *)pStpCtx->PrimProcessor)->FreeSpans(cSpans)

// Compute texture difference times 1/W.
#define PERSP_TEXTURE_DELTA(fTb, fRb, fTa, fTRa, iWrap)                       \
    ((TextureDiff((fTb), (fTa), (iWrap)) + (fTa)) * (fRb) - (fTRa))

// Extract components from a packed color.
#define SPLIT_COLOR(uPacked, uB, uG, uR, uA)                                  \
    ((uB) = (UINT)RGBA_GETBLUE(uPacked),                                      \
     (uG) = (UINT)RGBA_GETGREEN(uPacked),                                     \
     (uR) = (UINT)RGBA_GETRED(uPacked),                                       \
     (uA) = (UINT)RGBA_GETALPHA(uPacked))

// Compute FP deltas from the difference of the given packed color
// and the given components.
#define COLOR_DELTA(uPacked, uB, uG, uR, uA, fDB, fDG, fDR, fDA)              \
    ((fDB) = (FLOAT)((INT)((UINT)RGBA_GETBLUE(uPacked)-(uB)) << COLOR_SHIFT), \
     (fDG) = (FLOAT)((INT)((UINT)RGBA_GETGREEN(uPacked)-(uG)) << COLOR_SHIFT),\
     (fDR) = (FLOAT)((INT)((UINT)RGBA_GETRED(uPacked)-(uR)) << COLOR_SHIFT),  \
     (fDA) = (FLOAT)((INT)((UINT)RGBA_GETALPHA(uPacked)-(uA)) << COLOR_SHIFT))

// Extract components from a packed index color.
// Applies a .5F offset to the color index to effect rounding
// when the color index is truncated.
#define SPLIT_IDX_COLOR(uPacked, iIdx, iA)                                    \
    ((iIdx) = (INT32)CI_MASKALPHA(uPacked) + (1<<(INDEX_COLOR_VERTEX_SHIFT-1)),                                   \
     (iA) = (INT32)CI_GETALPHA(uPacked))

#define IDX_COLOR_DELTA(uPacked, iIdx, iA, fDIdx, fDA)                        \
    ((fDIdx) = (FLOAT)((((INT32)CI_MASKALPHA(uPacked) +                       \
                    (1<<(INDEX_COLOR_VERTEX_SHIFT-1))) - (iIdx)) <<           \
                       INDEX_COLOR_FIXED_SHIFT),                              \
     (fDA) = (FLOAT)(((INT32)CI_GETALPHA(uPacked) - (iA)) <<                  \
                     INDEX_COLOR_SHIFT))

#endif // #ifndef _SETUP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mlspan\sources.inc ===
TARGETNAME = rmlspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\cmlrast.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxemul\sources.inc ===
TARGETNAME = mmxemul
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\mmxemul.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR MMX_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR MMX_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR MMX_BufRead_Palette8(PUINT8 pBits);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxemul\mmxemul.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains routines that emulate MMX instructions in ordinary C
// for algorithm development.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "d3dtypesp.h"
#include "d3ditype.h"
#include "mmxemul.h"

UINT16 MMX_addsw(INT16 x, INT16 y)
{
    INT32 z = x + y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

INT16  MMX_addusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x + (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}

UINT16 MMX_cmpeqw(INT16 x, INT16 y)
{
    if (x == y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

UINT16 MMX_cmpgtw(INT16 x, INT16 y)
{
    if (x > y) {
        return 0xffff;
    } else {
        return 0x0;
    }
}

// Emulate 16 bit MMX style multiplies
// Note that MULHW only works with signed operands, but MULLW works for
// signed and unsigned operands.
INT16 MMX_mulhw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = (INT16)(z>>16);
    return r;
}

INT16 MMX_mullw(INT16 x, INT16 y)
{
    INT32 z = x*y;
    INT16 r = z & 0xffff;
    return r;
}

INT16 MMX_subsw(INT16 x, INT16 y)
{
    INT32 z = x - y;
    if (z > 0x7fff)
        z = 0x7fff;
    if (z < -32768)
        z = -32768;
    return (INT16)z;
}

UINT16 MMX_subusw(UINT16 x, UINT16 y)
{
    INT32 z = (INT32)x - (INT32)y;
    if (z > 0xffff)
        z = 0xffff;
    if (z < 0)
        z = 0;
    return (UINT16)z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bldfuncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void MMX_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void MMX_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\loop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

void MMX_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\i386src.inc ===
i386_SOURCES = \
        $O\atest.asm\
        $O\bldfuncs.asm\
        $O\bufread.asm\
        $O\bufwrite.asm\
        $O\colorbld.asm\
        $O\colorgen.asm\
        $O\spanpars.asm\
        ..\spanutil.cpp\
        $O\test.asm\
        $O\tex1addr.asm\
        $O\tex2addr.asm\
        $O\texblend.asm\
        $O\texread.asm\
        $O\tstfail.asm\
        $O\ml1.asm\
        $O\ml2.asm\
        $O\ml3.asm\
        $O\ml4.asm\
        $O\ml5.asm\
        $O\ml6.asm\
        $O\ml7.asm\
        $O\ml8.asm\
        $O\ml9.asm\
        $O\ml10.asm\
        $O\ml11.asm\
        $O\ml12.asm\
        $O\ml13.asm\
        $O\ml14.asm\
        $O\ml15.asm\
        $O\ml16.asm\
        $O\ml17.asm\
        $O\ml18.asm\
        $O\ml19.asm\
        $O\ml20.asm\
        $O\ml21.asm\
        $O\ml22.asm\
        $O\ml23.asm\
        $O\ml24.asm\
        $O\ml25.asm\
        $O\ml26.asm\
        $O\ml27.asm\
        $O\ml28.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\tex1a_mh.h\
        $O\tex2a_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\tstf_mh.h\
        $O\atest_mh.h\
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bufwrite.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#ifdef __cplusplus
  extern "C" {
#endif

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void MMX_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void MMX_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);

#ifdef __cplusplus
  }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\iammx.inc ===
;/*
;*    INTEL CORPORATION PROPRIETARY INFORMATION 
;*
;*    This software is supplied under the terms of a license
;*    agreement or nondisclosure agreement with Intel Corporation 
;*    and may not be copied or disclosed except in accordance with 
;*    the terms of that agreement.
;*    Copyright (c) 1991,1992,1993  Intel Corporation. 
;*
;*/
;NOTE:NOTE:NOTE:
; IF YOU MODIFY ANY OF THE OPCODES HERE, MAKE SURE TO REFLECT THAT
; IN THE ValidMmxOpcode[] array in mm.c. 
;
;Please use MMWORD and not DWORD (QWORD does not work) for 64 bit data 
; in MMX instructions. After getting a real assembler you will just have to
; add the line " MMWORD	TEXTEQU	<QWORD>" to your code.
MMWORD	TEXTEQU	<DWORD>
opc_Rdpmc     = 033H
opc_Emms      = 077H
opc_Movd_ld   = 06EH
opc_Movd_st   = 07EH
opc_Movq_ld   = 06FH
opc_Movq_st   = 07FH
opc_Packssdw  = 06BH
opc_Packsswb  = 063H
opc_Packuswb  = 067H
opc_Paddb     = 0FCH
opc_Paddd     = 0FEH
opc_Paddsb    = 0ECH
opc_Paddsw    = 0EDH
opc_Paddusb   = 0DCH
opc_Paddusw   = 0DDH
opc_Paddw     = 0FDH
opc_Pand      = 0DBH
opc_Pandn     = 0DFH
opc_Pcmpeqb   = 074H
opc_Pcmpeqd   = 076H
opc_Pcmpeqw   = 075H
opc_Pcmpgtb   = 064H
opc_Pcmpgtd   = 066H
opc_Pcmpgtw   = 065H
opc_Pmaddwd   = 0F5H
opc_Pmulhw    = 0E5H
opc_Pmullw    = 0D5H
opc_Por       = 0EBH
opc_PSHimd    = 072H
opc_PSHimq    = 073H
opc_PSHimw    = 071H
opc_Pslld     = 0F2H
opc_Psllq     = 0F3H
opc_Psllw     = 0F1H
opc_Psrad     = 0E2H
opc_Psraw     = 0E1H
opc_Psrld     = 0D2H
opc_Psrlq     = 0D3H
opc_Psrlw     = 0D1H
opc_Psubb     = 0F8H
opc_Psubd     = 0FAH
opc_Psubsb    = 0E8H
opc_Psubsw    = 0E9H
opc_Psubusb   = 0D8H
opc_Psubusw   = 0D9H
opc_Psubw     = 0F9H
opc_Punpcklbw = 060H
opc_Punpckldq = 062H
opc_Punpcklwd = 061H
opc_Punpckhbw = 068H
opc_Punpckhdq = 06AH
opc_Punpckhwd = 069H
opc_Pxor      = 0EFH

.486P

; ALIAS R# to MM# registers

DefineMMxRegs Macro
IFDEF APP_16BIT
	MM0	TEXTEQU	<AX>
	MM1	TEXTEQU	<CX>
	MM2	TEXTEQU	<DX>
	MM3	TEXTEQU	<BX>
	MM4	TEXTEQU	<SP>
	MM5	TEXTEQU	<BP>
	MM6	TEXTEQU	<SI>
	MM7	TEXTEQU	<DI>

	mm0	TEXTEQU	<AX>
	mm1	TEXTEQU	<CX>
	mm2	TEXTEQU	<DX>
	mm3	TEXTEQU	<BX>
	mm4	TEXTEQU	<SP>
	mm5	TEXTEQU	<BP>
	mm6	TEXTEQU	<SI>
	mm7	TEXTEQU	<DI>

	Mm0	TEXTEQU	<AX>
	Mm1	TEXTEQU	<CX>
	Mm2	TEXTEQU	<DX>
	Mm3	TEXTEQU	<BX>
	Mm4	TEXTEQU	<SP>
	Mm5	TEXTEQU	<BP>
	Mm6	TEXTEQU	<SI>
	Mm7	TEXTEQU	<DI>

	mM0	TEXTEQU	<AX>
	mM1	TEXTEQU	<CX>
	mM2	TEXTEQU	<DX>
	mM3	TEXTEQU	<BX>
	mM4	TEXTEQU	<SP>
	mM5	TEXTEQU	<BP>
	mM6	TEXTEQU	<SI>
	mM7	TEXTEQU	<DI>

ELSE
	MM0	TEXTEQU	<EAX>
	MM1	TEXTEQU	<ECX>
	MM2	TEXTEQU	<EDX>
	MM3	TEXTEQU	<EBX>
	MM4	TEXTEQU	<ESP>
	MM5	TEXTEQU	<EBP>
	MM6	TEXTEQU	<ESI>
	MM7	TEXTEQU	<EDI>

	mm0	TEXTEQU	<EAX>
	mm1	TEXTEQU	<ECX>
	mm2	TEXTEQU	<EDX>
	mm3	TEXTEQU	<EBX>
	mm4	TEXTEQU	<ESP>
	mm5	TEXTEQU	<EBP>
	mm6	TEXTEQU	<ESI>
	mm7	TEXTEQU	<EDI>

	Mm0	TEXTEQU	<EAX>
	Mm1	TEXTEQU	<ECX>
	Mm2	TEXTEQU	<EDX>
	Mm3	TEXTEQU	<EBX>
	Mm4	TEXTEQU	<ESP>
	Mm5	TEXTEQU	<EBP>
	Mm6	TEXTEQU	<ESI>
	Mm7	TEXTEQU	<EDI>

	mM0	TEXTEQU	<EAX>
	mM1	TEXTEQU	<ECX>
	mM2	TEXTEQU	<EDX>
	mM3	TEXTEQU	<EBX>
	mM4	TEXTEQU	<ESP>
	mM5	TEXTEQU	<EBP>
	mM6	TEXTEQU	<ESI>
	mM7	TEXTEQU	<EDI>
ENDIF
EndM

; ALIAS R# to MM# registers
DefineMMxNUM Macro
	MM0	TEXTEQU	<0>
	MM1	TEXTEQU	<0>
	MM2	TEXTEQU	<0>
	MM3	TEXTEQU	<0>
	MM4	TEXTEQU	<0>
	MM5	TEXTEQU	<0>
	MM6	TEXTEQU	<0>
	MM7	TEXTEQU	<0>

	mm0	TEXTEQU	<0>
	mm1	TEXTEQU	<0>
	mm2	TEXTEQU	<0>
	mm3	TEXTEQU	<0>
	mm4	TEXTEQU	<0>
	mm5	TEXTEQU	<0>
	mm6	TEXTEQU	<0>
	mm7	TEXTEQU	<0>

	Mm0	TEXTEQU	<0>
	Mm1	TEXTEQU	<0>
	Mm2	TEXTEQU	<0>
	Mm3	TEXTEQU	<0>
	Mm4	TEXTEQU	<0>
	Mm5	TEXTEQU	<0>
	Mm6	TEXTEQU	<0>
	Mm7	TEXTEQU	<0>

	mM0	TEXTEQU	<0>
	mM1	TEXTEQU	<0>
	mM2	TEXTEQU	<0>
	mM3	TEXTEQU	<0>
	mM4	TEXTEQU	<0>
	mM5	TEXTEQU	<0>
	mM6	TEXTEQU	<0>
	mM7	TEXTEQU	<0>
EndM



UnDefineMMxRegs Macro
	MM0	TEXTEQU	<MM0>
	MM1	TEXTEQU	<MM1>
	MM2	TEXTEQU	<MM2>
	MM3	TEXTEQU	<MM3>
	MM4	TEXTEQU	<MM4>
	MM5	TEXTEQU	<MM5>
	MM6	TEXTEQU	<MM6>
	MM7	TEXTEQU	<MM7>

	mm0	TEXTEQU	<mm0>
	mm1	TEXTEQU	<mm1>
	mm2	TEXTEQU	<mm2>
	mm3	TEXTEQU	<mm3>
	mm4	TEXTEQU	<mm4>
	mm5	TEXTEQU	<mm5>
	mm6	TEXTEQU	<mm6>
	mm7	TEXTEQU	<mm7>

	Mm0	TEXTEQU	<Mm0>
	Mm1	TEXTEQU	<Mm1>
	Mm2	TEXTEQU	<Mm2>
	Mm3	TEXTEQU	<Mm3>
	Mm4	TEXTEQU	<Mm4>
	Mm5	TEXTEQU	<Mm5>
	Mm6	TEXTEQU	<Mm6>
	Mm7	TEXTEQU	<Mm7>

	mM0	TEXTEQU	<mM0>
	mM1	TEXTEQU	<mM1>
	mM2	TEXTEQU	<mM2>
	mM3	TEXTEQU	<mM3>
	mM4	TEXTEQU	<mM4>
	mM5	TEXTEQU	<mM5>
	mM6	TEXTEQU	<mM6>
	mM7	TEXTEQU	<mM7>
EndM


rdpmc     macro
	db	0fh, opc_Rdpmc
endm

emms     macro
	db	0fh, opc_Emms
endm



movd   macro   dst:req, src:req
        local   x, y

		DefineMMxNUM

IF (OPATTR(dst)) AND 00010000y ; register
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
		UnDefineMMxRegs
ELSE
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st 
        org     y
ENDIF
		UnDefineMMxRegs
ENDIF
        endm

movdt    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movd_ld 
        org     y
		UnDefineMMxRegs
        endm

movdf   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movd_st
        org     y
		UnDefineMMxRegs
        endm

movq   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(dst)) AND 00010000y ; register
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Movq_ld 
        org     y
ELSE
x:
        cmpxchg   dst, src
y:
        org     x+1
        byte    opc_Movq_st 
        org     y
ENDIF
		UnDefineMMxRegs
        endm


packssdw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packssdw
        org     y
		UnDefineMMxRegs
        endm

packsswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packsswb
        org     y
		UnDefineMMxRegs
        endm

packuswb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Packuswb
        org     y
		UnDefineMMxRegs
        endm

paddd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddd   
        org     y
		UnDefineMMxRegs
        endm

paddsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsb  
        org     y
		UnDefineMMxRegs
        endm

paddsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddsw  
        org     y
		UnDefineMMxRegs
        endm

paddusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusb 
        org     y
		UnDefineMMxRegs
        endm

paddusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddusw 
        org     y
		UnDefineMMxRegs
        endm

paddb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddb   
        org     y
		UnDefineMMxRegs
        endm

paddw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Paddw   
        org     y
		UnDefineMMxRegs
        endm

pand    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pand    
        org     y
		UnDefineMMxRegs
        endm

pandn    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pandn   
        org     y
		UnDefineMMxRegs
        endm

pcmpeqb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqb 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqd 
        org     y
		UnDefineMMxRegs
        endm

pcmpeqw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpeqw 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtb 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtd 
        org     y
		UnDefineMMxRegs
        endm

pcmpgtw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pcmpgtw 
        org     y
		UnDefineMMxRegs
        endm

pmaddwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmaddwd 
        org     y
		UnDefineMMxRegs
        endm

pmulhw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmulhw  
        org     y
		UnDefineMMxRegs
        endm

pmullw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pmullw  
        org     y
		UnDefineMMxRegs
        endm

por    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Por     
        org     y
		UnDefineMMxRegs
        endm


pslld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pslld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psllw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrad    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrad   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psraw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        bt   dst, src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psraw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrld    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimd  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrld   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psrlq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psllq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        btr   dst, src
y:
        org     x+1
        byte    opc_PSHimq  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psllq   
        org     y
ENDIF
		UnDefineMMxRegs
        endm



psrlw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
IF (OPATTR(src)) AND 00000100y ; constant
x:
        cmpxchg dst,MM2
	byte	src
y:
        org     x+1
        byte    opc_PSHimw  
        org     y
ELSE
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psrlw   
        org     y
ENDIF
		UnDefineMMxRegs
        endm

psubsb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsb  
        org     y
		UnDefineMMxRegs
        endm

psubsw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubsw  
        org     y
		UnDefineMMxRegs
        endm

psubusb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusb 
        org     y
		UnDefineMMxRegs
        endm

psubusw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubusw 
        org     y
		UnDefineMMxRegs
        endm

psubb    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubb   
        org     y
		UnDefineMMxRegs
        endm

psubw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubw   
        org     y
		UnDefineMMxRegs
        endm

punpcklbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklbw
        org     y
		UnDefineMMxRegs
        endm

punpckhdq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhdq
        org     y
		UnDefineMMxRegs
        endm

punpcklwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpcklwd
        org     y
		UnDefineMMxRegs
        endm

punpckhbw    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhbw
        org     y
		UnDefineMMxRegs
        endm

punpckldq    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckldq
        org     y
		UnDefineMMxRegs
        endm

punpckhwd    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Punpckhwd
        org     y
		UnDefineMMxRegs
        endm

pxor    macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Pxor    
        org     y
		UnDefineMMxRegs
        endm

psubd   macro   dst:req, src:req
        local   x, y
		DefineMMxRegs
x:
        cmpxchg   src, dst
y:
        org     x+1
        byte    opc_Psubd   
        org     y
		UnDefineMMxRegs
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\nommxsrc.inc ===
NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\clrbd_mh.h\
        $O\clrgn_mh.h\
        $O\test_mh.h\
        $O\tex1a_mh.h\
        $O\tex2a_mh.h\
        $O\texbd_mh.h\
        $O\texrd_mh.h\
        $O\atest_mh.h\
        $O\tstf_mh.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\makefile.inc ===
$(GENTGT)\clrbd_mh.h: ..\clrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\clrgn_mh.h: ..\clrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\test_mh.h: ..\test_mh.mh $(RAST_STD_M4)

$(GENTGT)\tex1a_mh.h: ..\tex1a_mh.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\tex2a_mh.h: ..\tex2a_mh.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texbd_mh.h: ..\texbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\texrd_mh.h: ..\texrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstf_mh.h: ..\tstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\atest_mh.h: ..\atest_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h

$(GENTGT)\beadtbl.cpp: ..\beadtbl.mcp $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\atest.asm: ..\atest.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bldfuncs.asm: ..\bldfuncs.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufread.asm: ..\bufread.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\bufwrite.asm: ..\bufwrite.mas ..\bufwrite.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorbld.asm: ..\colorbld.mas ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\colorgen.asm: ..\colorgen.mas ..\colorgen.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\test.asm: ..\test.mas ..\test.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\tex1addr.asm: ..\tex1addr.mas ..\cvars.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\tex2addr.asm: ..\tex2addr.mas ..\cvars.mh ..\texaddra.mh $(RAST_STD_M4)

$(GENTGT)\texblend.asm: ..\texblend.mas ..\texblend.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\texread.asm: ..\texread.mas ..\texread.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\tstfail.asm: ..\tstfail.mas ..\tstfail.mh ..\cvars.mh $(RAST_STD_M4)

$(GENTGT)\spanpars.asm: ..\spanpars.mas ..\cvars.mh $(RAST_STD_M4)

$(GENGT)\ml1.asm: ..\ml1.mas $(RAST_STD_M4)
$(GENGT)\ml2.asm: ..\ml2.mas $(RAST_STD_M4)
$(GENGT)\ml3.asm: ..\ml3.mas $(RAST_STD_M4)
$(GENGT)\ml4.asm: ..\ml4.mas $(RAST_STD_M4)
$(GENGT)\ml5.asm: ..\ml5.mas $(RAST_STD_M4)
$(GENGT)\ml6.asm: ..\ml6.mas $(RAST_STD_M4)
$(GENGT)\ml7.asm: ..\ml7.mas $(RAST_STD_M4)
$(GENGT)\ml8.asm: ..\ml8.mas $(RAST_STD_M4)
$(GENGT)\ml9.asm: ..\ml9.mas $(RAST_STD_M4)
$(GENGT)\ml10.asm: ..\ml10.mas $(RAST_STD_M4)
$(GENGT)\ml11.asm: ..\ml11.mas $(RAST_STD_M4)
$(GENGT)\ml12.asm: ..\ml12.mas $(RAST_STD_M4)
$(GENGT)\ml13.asm: ..\ml13.mas $(RAST_STD_M4)
$(GENGT)\ml14.asm: ..\ml14.mas $(RAST_STD_M4)
$(GENGT)\ml15.asm: ..\ml15.mas $(RAST_STD_M4)
$(GENGT)\ml16.asm: ..\ml16.mas $(RAST_STD_M4)
$(GENGT)\ml17.asm: ..\ml17.mas $(RAST_STD_M4)
$(GENGT)\ml18.asm: ..\ml18.mas $(RAST_STD_M4)
$(GENGT)\ml19.asm: ..\ml19.mas $(RAST_STD_M4)
$(GENGT)\ml20.asm: ..\ml20.mas $(RAST_STD_M4)
$(GENGT)\ml21.asm: ..\ml21.mas $(RAST_STD_M4)
$(GENGT)\ml22.asm: ..\ml22.mas $(RAST_STD_M4)
$(GENGT)\ml23.asm: ..\ml23.mas $(RAST_STD_M4)
$(GENGT)\ml24.asm: ..\ml24.mas $(RAST_STD_M4)
$(GENGT)\ml25.asm: ..\ml25.mas $(RAST_STD_M4)
$(GENGT)\ml26.asm: ..\ml26.mas $(RAST_STD_M4)
$(GENGT)\ml27.asm: ..\ml27.mas $(RAST_STD_M4)
$(GENGT)\ml28.asm: ..\ml28.mas $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\spanpars.h ===
//----------------------------------------------------------------------------
//
// spanpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

#ifdef __cplusplus
  extern "C" {
#endif


HRESULT MMX_RenderSpansAny(PD3DI_RASTCTX pCtx);

#ifdef __cplusplus
  }
#endif


#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>
#define BUILD_DDDDK
#include <d3dp.h>
#include <d3dhal.h>

#include <dpf.h>

#include <math.h>

#include "rast.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\sources.inc ===
TARGETNAME = rmmxspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

SOURCES = \
        $O\beadtbl.cpp

NTTARGETFILE0 = \
        $O\beadtbl.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\spanutil.cpp ===
//----------------------------------------------------------------------------
//
// spanutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\spanutil.h ===
//----------------------------------------------------------------------------
//
// spanutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\makefile.inc ===
$(GENTGT)\rampmat.cpp: ..\rampmat.mcp $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\colall.h ===
//----------------------------------------------------------------------------
//
// colall.h
//
// Structures and prototypes for color allocation code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPCOLALL_H_
#define _RAMPCOLALL_H_

struct _RLDDIColorAllocator;
typedef struct _RLDDIColorAllocator RLDDIColorAllocator;

typedef unsigned long (*RLDDIColorAllocatorAllocateColor)(void*,
                                int red,
                                int green,
                                int blue);

typedef void (*RLDDIColorAllocatorFreeColor)(void*,
                           unsigned long pixel);

struct _RLDDIColorAllocator {
    void* priv;         /* implementation dependant */
    RLDDIColorAllocatorAllocateColor    allocate_color;
    RLDDIColorAllocatorFreeColor    free_color;
};

#endif // _RAMPCOLALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\mmxspan\stp_base.h ===
//----------------------------------------------------------------------------
//
// stp_base.h
//
// Basic types shared between C++ and assembly.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _STP_BASE_H_
#define _STP_BASE_H_

// Generic set of attribute values.  Used for holding current values
// and deltas.
// ATTENTION - It may be better to use RASTSPAN.  RASTSPAN has some extra
// space that'd go unused but then it'd be possible to memcpy ATTRSETs
// to RASTSPANs during fixed-point edge walking.
typedef struct tagATTRSET
{
    union
    {
        FLOAT fZ;
        INT32 iZ;
        UINT32 uZ;
    };
    union
    {
        FLOAT fOoW;
        INT32 iOoW;
    };
    union
    {
        struct
        {
            FLOAT fUoW1, fVoW1;
        };
        struct
        {
            INT32 iUoW1, iVoW1;
        };
    };
    union
    {
        struct
        {
            FLOAT fB, fG, fR, fA;
        };
        struct
        {
            INT32 iB, iG, iR, iA;
        };
        struct
        {
            UINT32 uB, uG, uR, uA;
        };
    };
    union
    {
        struct
        {
            FLOAT fBS, fGS, fRS, fFog;
        };
        struct
        {
            INT32 iBS, iGS, iRS, iFog;
        };
        struct
        {
            UINT32 uBS, uGS, uRS, uFog;
        };
        struct
        {
            FLOAT fUoW2, fVoW2;
        };
        struct
        {
            INT32 iUoW2, iVoW2;
        };
    };
    union
    {
        struct
        {  
            PUINT8 pSurface, pZ;
        };
        struct
        {  
            INT32 ipSurface, ipZ;
        };
    };
} ATTRSET, *PATTRSET;

// Parameters for doing int/carry arithmetic on a value.
typedef struct tagINTCARRYVAL
{
    INT iV;
    INT iFrac;
    INT iDFrac;
    INT iCY, iNC;
} INTCARRYVAL, *PINTCARRYVAL;

// Attribute handlers.
typedef void (FASTCALL *PFN_ADDATTRS)(PATTRSET pAttrs, PATTRSET pDelta);
typedef void (FASTCALL *PFN_ADDSCALEDATTRS)
    (PATTRSET pAttrs, PATTRSET pDelta, int iScale, FLOAT fNextOoW);
typedef void (FASTCALL *PFN_FILLSPANATTRS)
    (PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
     struct tagSETUPCTX *pStpCtx, INT cPix);

extern PFN_ADDATTRS g_pfnAddFloatAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[];
#ifdef STEP_FIXED
extern PFN_ADDATTRS g_pfnAddFixedAttrsTable[];
extern PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[];
#endif
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[];
extern PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsPwlTable[];

// Edge walkers.
typedef HRESULT (FASTCALL *PFN_WALKSPANS)
    (UINT uSpans, PINTCARRYVAL pXOther,
     struct tagSETUPCTX *pStpCtx, BOOL bAdvanceLast);

extern PFN_WALKSPANS g_pfnWalkFloatSpansClipTable[];
extern PFN_WALKSPANS g_pfnWalkFloatSpansNoClipTable[];
#ifdef STEP_FIXED
extern PFN_WALKSPANS g_pfnWalkFixedSpansNoClipTable[];
#endif

// Float-to-fixed attribute converters.
typedef void (FASTCALL *PFN_FLOATATTRSTOFIXED)
    (PATTRSET pfAttrs, PATTRSET piAttrs);

#ifdef STEP_FIXED
extern PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[];
#endif

// Setup flags.
#define TRIP_DIFF_USED                  0x00000001
#define TRIP_SPEC_USED                  0x00000002
#define TRIP_TEX1_USED                  0x00000004
#define TRIP_TEX2_USED                  0x00000008
#define TRIP_Z_USED                     0x00000010
#define TRIP_LOD_USED                   0x00000020
#define TRIP_FOG_USED                   0x00000040
#define TRIP_TRIVIAL_ACCEPT_Y           0x00000080
#define TRIP_TRIVIAL_ACCEPT_X           0x00000100
#define TRIP_X_DEC                      0x00000200
#define TRIP_RASTPRIM_OVERFLOW          0x00000400
#define TRIP_FIXED_OVERFLOW             0x00000800
#define TRIP_IN_BEGIN                   0x00001000

#define TRIP_COLORS_USED                (TRIP_DIFF_USED | TRIP_SPEC_USED)
#define TRIP_TEX_USED                   (TRIP_TEX1_USED | TRIP_TEX2_USED)

// These flags are set and reset per-triangle, while the other flags are
// set per triangle set.
#define TRIP_PER_TRIANGLE_FLAGS \
    (TRIP_TRIVIAL_ACCEPT_Y | TRIP_TRIVIAL_ACCEPT_X | TRIP_X_DEC | \
     TRIP_RASTPRIM_OVERFLOW | TRIP_FIXED_OVERFLOW)
#define TRIP_PER_TRIANGLE_SET_FLAGS \
    (TRIP_DIFF_USED | TRIP_SPEC_USED | TRIP_TEX1_USED | TRIP_TEX2_USED | \
     TRIP_Z_USED | TRIP_LOD_USED | TRIP_FOG_USED)
    
// Setup information shared between C++ and assembly.
typedef struct tagSETUPCTX
{
    // Overall rasterization context.
    PD3DI_RASTCTX pCtx;

    // Current TriProcessor for span allocator calls.
    PVOID TriProcessor;
    
    // Current primitive.
    PD3DI_RASTPRIM pPrim;
    
    // Per-triangle flags.
    UINT uFlags;

    // Maximum span length allowed.
    INT cMaxSpan;
    
    // Piecewise-linear support for LOD.
    BOOL bNextValid;
    FLOAT fNextW;
    FLOAT fNextOoW;
    INT iNextLOD;

    // Attribute handling functions.
    PFN_ADDATTRS pfnAddAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrs;
    PFN_ADDSCALEDATTRS pfnAddScaledAttrsPwl;
    PFN_FILLSPANATTRS pfnFillSpanAttrs;

    // Edge walking function.
    PFN_WALKSPANS pfnWalkSpans;
    
    // Current Y value.
    INT iY;
    
    // Edge X walkers.
    INTCARRYVAL X20, X10, X21;
    
    // Floating-point versions of X20 NC and CY values for setup.
    FLOAT fX20NC, fX20CY;
    
    // Long edge attribute values.
    ATTRSET Attr;
    
    // Attribute X deltas.
    ATTRSET DAttrDX;
    
    // Attribute Y deltas.
    ATTRSET DAttrDY;
    
    // Attribute span-to-span deltas when X carries a pixel.
    ATTRSET DAttrCY;

    // Attribute span-to-span deltas when X doesn't carry a pixel.
    ATTRSET DAttrNC;

    // One over determinant.
    FLOAT fOoDet;
    
    // Edge deltas.
    FLOAT fDX10, fDY10;
    FLOAT fDX20, fDY20;
    
    // Normalized edge deltas.
    FLOAT fNX10, fNY10;
    FLOAT fNX20, fNY20;
    
    // Subpixel correction amounts.
    FLOAT fDX, fDY;
} SETUPCTX, *PSETUPCTX;

#endif // #ifndef _STP_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\indcmap.cpp ===
//----------------------------------------------------------------------------
//
// indcmap.cpp
//
// Implements indirect colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

typedef struct _RLDDIIndirectPrivate
{
    RLDDIColorAllocator*    alloc;
    size_t          size;
    unsigned long*      map;
} RLDDIIndirectPrivate;

static void Destroy(RLDDIColormap* cmap);
static void SetColor(RLDDIColormap* cmap,
                     int index, int red, int green, int blue);

RLDDIColormap* RLDDICreateIndirectColormap(RLDDIColorAllocator* alloc,
                                           size_t size)
{
    RLDDIColormap* cmap;
    RLDDIIndirectPrivate* priv;
    size_t i;

    if (D3DMalloc((void**) &cmap, sizeof(RLDDIColormap)))
        return NULL;

    if (D3DMalloc((void**) &priv, sizeof(RLDDIIndirectPrivate)))
    {
        D3DFree(cmap);
        return NULL;
    }

    cmap->size = size;
    cmap->destroy = Destroy;
    cmap->set_color = SetColor;
    cmap->priv = priv;
    priv->alloc = alloc;
    priv->size = size;
    if (D3DMalloc((void**) &priv->map, size * sizeof(unsigned long)))
    {
        D3DFree(priv);
        D3DFree(cmap);
        return NULL;
    }

    for (i = 0; i < size; i++)
        priv->map[i] = alloc->allocate_color(alloc->priv, 0, 0, 0);

    return cmap;
}

unsigned long* RLDDIIndirectColormapGetMap(RLDDIColormap* cmap)
{
    RLDDIIndirectPrivate* priv;

    if (cmap == NULL)
        return NULL;
    priv = (RLDDIIndirectPrivate*) cmap->priv;
    if ( priv == NULL)
        return NULL;
    else
        return priv->map;
}

static void Destroy(RLDDIColormap* cmap)
{
    if (cmap && cmap->priv && ((RLDDIIndirectPrivate*)cmap->priv)->alloc)
    {
        RLDDIIndirectPrivate* priv = (RLDDIIndirectPrivate*) cmap->priv;
        RLDDIColorAllocator* alloc = priv->alloc;
        size_t i;

        for (i = 0; i < priv->size; i++)
            alloc->free_color(alloc->priv, priv->map[i]);
        D3DFree(priv->map);
        D3DFree(priv);
        D3DFree(cmap);
    }
}

static void SetColor(RLDDIColormap* cmap,
                     int index, int red, int green, int blue)
{
    red   = min(max(red,   0x0), 0xff);
    green = min(max(green, 0x0), 0xff);
    blue  = min(max(blue,  0x0), 0xff);
    if (cmap && cmap->priv && ((RLDDIIndirectPrivate*)cmap->priv)->alloc)
    {
        RLDDIIndirectPrivate* priv = (RLDDIIndirectPrivate*) cmap->priv;
        RLDDIColorAllocator* alloc = priv->alloc;

        if (index >= 0 && ((size_t)index) < priv->size)
        {
            alloc->free_color(alloc->priv, priv->map[index]);
            priv->map[index] = alloc->allocate_color(alloc->priv, red, green, blue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\cmap.h ===
//----------------------------------------------------------------------------
//
// cmap.h
//
// Declares RLDDIColormap structures and procedures.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPCMAP_H_
#define _RAMPCMAP_H_

struct _RLDDIColormap;
typedef struct _RLDDIColormap RLDDIColormap;

typedef void (*RLDDIColormapDestroy)(RLDDIColormap*);
typedef void (*RLDDIColormapSetColor)(RLDDIColormap*,
                    int index,
                    int red, int green, int blue);

struct _RLDDIColormap {
    int size;           /* maximum color index */
    void* priv;         /* implementation dependant */
    RLDDIColormapDestroy    destroy;
    RLDDIColormapSetColor   set_color;
};

void RLDDIDestroyColormap(RLDDIColormap* cmap);

#endif // _RAMPCMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\indcmap.h ===
//----------------------------------------------------------------------------
//
// indcmap.h
//
// Structures and prototypes for indirect colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _INDCMAP_H_
#define _INDCMAP_H_

RLDDIColormap* RLDDICreateIndirectColormap(RLDDIColorAllocator* alloc,
                         size_t size);
unsigned long* RLDDIIndirectColormapGetMap(RLDDIColormap* cmap);

#endif // _INDCMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\palette.cpp ===
//----------------------------------------------------------------------------
//
// palette.cpp
//
// Implements ramp palette code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// RLDDIRampUpdateDDPalette
//
// Called before the destination DirectDraw surface is displayed, to set its palette.
//
//-----------------------------------------------------------------------------
long RLDDIRampUpdateDDPalette(PD3DI_RASTCTX pCtx)
{
    RLDDIRampLightingDriver* driver = (RLDDIRampLightingDriver*)pCtx->pRampDrv;

    if (driver->paletteChanged) {
        HRESULT ddrval;
        LPDIRECTDRAWPALETTE lpDDPal;
        ddrval = pCtx->pDDS->GetPalette(&lpDDPal);

        driver->paletteChanged = FALSE;
        if (lpDDPal) {
            PALETTEENTRY ddppe[256];
            DWORD i;

            ddrval = lpDDPal->GetEntries(0, 0, 256, ddppe);
            if (ddrval != DD_OK) {
                DPF_ERR("Failed to get palette entries from DirectDraw.");
                return ddrval;
            }

            // Update only those entries marked as free.
            for (i=0; i<256; i++) {
                if (!(ddppe[i].peFlags & (D3DPAL_READONLY | D3DPAL_RESERVED))) {
                                        ddppe[i] = driver->ddpalette[i];
                }
            }

            // Reset palette
            ddrval = lpDDPal->SetEntries(0, 0, 256, ddppe);
            if (ddrval != DD_OK)
                return ddrval;
        }
    }
    return DD_OK;
}

//
// Set color in preparation to set the real palette
//
static void SetColor(void* arg, int index, int red, int green, int blue)
{
    PD3DI_RASTCTX pCtx = (PD3DI_RASTCTX)arg;

    RLDDIRampLightingDriver* driver = (RLDDIRampLightingDriver*)pCtx->pRampDrv;

    driver->ddpalette[index].peRed = (BYTE)red;
    driver->ddpalette[index].peGreen = (BYTE)green;
    driver->ddpalette[index].peBlue = (BYTE)blue;
    //driver->ddpalette[index].peFlags = PC_RESERVED;
    driver->paletteChanged = TRUE;
}

RLDDIPalette* RLDDICreatePalette(PD3DI_RASTCTX pCtx, size_t size)
{
    RLDDIPalette* pal;
    int i;

    if (D3DMalloc((void**) &pal, sizeof(RLDDIPalette)))
        return NULL;

    if (D3DMalloc((void**) &pal->entries,
                  size * sizeof(RLDDIPaletteEntry)))
    {
        D3DFree(pal);
        return NULL;
    }

    pal->size = size;
    pal->priv = pCtx;
    pal->set_color = SetColor;
    pal->allocate_color = NULL;
    pal->free_color = NULL;

    LIST_INITIALIZE(&pal->free);
    LIST_INITIALIZE(&pal->unused);
    for (i = 0; i < HASH_SIZE; i++)
        LIST_INITIALIZE(&pal->hash[i]);

    for (i = size - 1; i >= 0; i--)
    {
        pal->entries[i].state = PALETTE_UNUSED;
        pal->entries[i].usage = 1;
        LIST_INSERT_ROOT(&pal->unused, &pal->entries[i], list);
    }

    pal->alloc.priv = pal;
    pal->alloc.allocate_color =
    (RLDDIColorAllocatorAllocateColor) RLDDIPaletteAllocateColor;
    pal->alloc.free_color =
    (RLDDIColorAllocatorFreeColor) RLDDIPaletteFreeColor;

    return pal;
}

void RLDDIPaletteSetColor(RLDDIPalette* pal,
                          int index, int red, int green, int blue)
{
    RLDDIPaletteEntry* entry;
    unsigned int hash = RGB_HASH(red, green, blue) % HASH_SIZE;

    entry = INDEX_TO_ENTRY(pal, index);

    /*
     * Snip out from its list (free, unused or some hash list).
     */
    LIST_DELETE(entry, list);
    entry->red = (BYTE)red;
    entry->green = (BYTE)green;
    entry->blue = (BYTE)blue;
    entry->state = PALETTE_USED;
    entry->usage = 1;
    LIST_INSERT_ROOT(&pal->hash[hash], entry, list);

    if (pal->set_color)
    {
        /*
         * Call lower level to set the color (hardware colormap or Windows
         * palette or whatever).
         */
        pal->set_color(pal->priv, index, red, green, blue);
    }
}

#define COLOR_MASK 0xF8

int RLDDIPaletteAllocateColor(RLDDIPalette* pal,
                              int red, int green, int blue)
{
    RLDDIPaletteEntry* entry;
    unsigned int hash = RGB_HASH(red, green, blue) % HASH_SIZE;
    RLDDIPaletteEntry* best = NULL;
    size_t i;
    int closeness;

    for (entry = LIST_FIRST(&pal->hash[hash]); entry;
        entry = LIST_NEXT(entry,list))
    {
        if ((entry->red & COLOR_MASK) == (red & COLOR_MASK)
            && (entry->green & COLOR_MASK) == (green & COLOR_MASK)
            && (entry->blue & COLOR_MASK) == (blue & COLOR_MASK)
            && entry->state != PALETTE_UNUSED)
        {
            entry->usage++;
            return ENTRY_TO_INDEX(pal, entry);
        }
    }

    /*
     * Are there any free palette entries?
     */
    if (pal->allocate_color)
    {
        int index;
        index = pal->allocate_color(pal->priv, red, green, blue);
        if (index >= 0)
        {
            RLDDIPaletteSetColor(pal, index, red, green, blue);
            return index;
        }
    }
    else if (LIST_FIRST(&pal->free))
    {
        entry = LIST_FIRST(&pal->free);
        RLDDIPaletteSetColor(pal, ENTRY_TO_INDEX(pal, entry),
                             red, green, blue);
        return ENTRY_TO_INDEX(pal, entry);
    }

    /*
     * No more colors available, return the closest.
     */
    closeness = INT_MAX;
    for (i = 0, entry = pal->entries; i < pal->size; i++, entry++)
    {
        int t;
        if (entry->state != PALETTE_USED) continue;
#if 1
        {
            int t1,t2,t3;
            t1 = red - entry->red;
            t2 = green - entry->green;
            t3 = blue - entry->blue;
            t = (t1*t1 + t2*t2 + t3*t3);
        }
#else
        t = (abs(red - entry->red)
             + abs(green - entry->green)
             + abs(blue - entry->blue));
#endif
        if (t < closeness)
        {
            closeness = t;
            best = entry;
        }
    }
    best->usage++;
    /* *error = closeness; */
    return ENTRY_TO_INDEX(pal, best);
}

void RLDDIPaletteFreeColor(RLDDIPalette* pal, int index)
{
    RLDDIPaletteEntry* entry;

    entry = INDEX_TO_ENTRY(pal, index);
    entry->usage--;
    if (entry->usage > 0) return;

    /*
     * Remove from whichever list it is on (pal->unused or pal->hash[])
     * and add to the free list.
     */
    LIST_DELETE(entry, list);

    if (pal->free_color)
    {
        pal->free_color(pal->priv, index);
        entry->state = PALETTE_UNUSED;
        LIST_INSERT_ROOT(&pal->unused, entry, list);
    }
    else
    {
        entry->state = PALETTE_FREE;
        LIST_INSERT_ROOT(&pal->free, entry, list);
    }
}

void RLDDIDestroyPalette(RLDDIPalette* pal)
{
    RLDDIPaletteEntry* entry;
    size_t i;

    for (i = 0, entry = pal->entries; i < pal->size; i++, entry++)
    {
        if (entry->state != PALETTE_USED) continue;
        RLDDIPaletteFreeColor(pal, i);
    }
    D3DFree(pal->entries);
    D3DFree(pal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\palette.h ===
//----------------------------------------------------------------------------
//
// palette.h
//
// Structures and prototypes ramp palette code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPPALETTE_H_
#define _RAMPPALETTE_H_

#include "colall.h"

typedef void (*RLDDIPaletteSetColorMethod)(void*, int index,
                        int red, int green, int blue);
typedef int (*RLDDIPaletteAllocateColorMethod)(void*,
                        int red, int green, int blue);
typedef void (*RLDDIPaletteFreeColorMethod)(void*, int index);

typedef struct _RLDDIPaletteEntry RLDDIPaletteEntry;

typedef enum _PaletteState
{
    PALETTE_FREE,                   /* not used, allocatable */
    PALETTE_UNUSED,                 /* not used, not allocatable */
    PALETTE_USED                    /* used, allocatable */
} PaletteState;

struct _RLDDIPaletteEntry {
    LIST_MEMBER(_RLDDIPaletteEntry) list;
    int usage;                              /* how many users (0 => free) */
    unsigned char red, green, blue, pad1;   /* intensity values */
    PaletteState state;
};

#define HASH_SIZE 257
#define RGB_HASH(red, green, blue)      (((red) << 8) ^ ((green) << 4) ^ (blue))
#define ENTRY_TO_INDEX(pal, entry)      ((int)((entry) - (pal)->entries))
#define INDEX_TO_ENTRY(pal, index)      (&(pal)->entries[index])

typedef struct _RLDDIPalette {
    RLDDIPaletteEntry*  entries;        /* palette entries */
    size_t              size;           /* number of entries in palette */
    LIST_ROOT(name3, _RLDDIPaletteEntry) free; /* free list */
    LIST_ROOT(name4, _RLDDIPaletteEntry) unused; /* colors not to use */
    LIST_ROOT(name5, _RLDDIPaletteEntry) hash[HASH_SIZE];

    void*                       priv;
    RLDDIPaletteAllocateColorMethod allocate_color;
    RLDDIPaletteFreeColorMethod free_color;
    RLDDIPaletteSetColorMethod set_color;

    /*
     * A color allocator for use with RLDDIColormap.
     */
    RLDDIColorAllocator        alloc;
} RLDDIPalette;

RLDDIPalette* RLDDICreatePalette(PD3DI_RASTCTX pCtx, size_t size);
void RLDDIPaletteSetColor(RLDDIPalette* pal,
               int index, int red, int green, int blue);
int RLDDIPaletteAllocateColor(RLDDIPalette* pal,
                   int red, int green, int blue);
void RLDDIPaletteFreeColor(RLDDIPalette* pal, int index);
void RLDDIDestroyPalette(RLDDIPalette* pal);

#endif // _RAMPPALETTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmap.h ===
//----------------------------------------------------------------------------
//
// rampmap.h
//
// Declares structures and procedures for RLDDIRampmap.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPMAP_H_
#define _RAMPMAP_H_

#include "cmap.h"

struct _RLDDIRampmap;
typedef struct _RLDDIRampmap RLDDIRampmap;

typedef struct _RLDDIRamp {
    CIRCLE_QUEUE_MEMBER(_RLDDIRamp) queue;

    int         base, size;
    int         free;
} RLDDIRamp;

struct _RLDDIRampmap {
    RLDDIColormap*  cmap;

    CIRCLE_QUEUE_ROOT(RLDDIRampQueue, _RLDDIRamp) free, allocated;
};

RLDDIRampmap* RLDDICreateRampmap(RLDDIColormap* cmap);
void RLDDIDestroyRampmap(RLDDIRampmap* rmap);
RLDDIRamp* RLDDIRampmapAllocate(RLDDIRampmap* rmap, int size);
void RLDDIRampmapFree(RLDDIRampmap* rmap, RLDDIRamp* ramp);

#endif // _RAMPMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>

#include "lists.h"

#include "cmap.h"
#include "colall.h"
#include "rgbmap.h"
#include "rampmap.h"
#include "palette.h"
#include "rampmat.hpp"
#include "indcmap.h"
#include "rampmisc.h"
#include "rampif.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampif.h ===
//----------------------------------------------------------------------------
//
// rampif.h
//
// Declares external interface for ramp material handling.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPIF_H_
#define _RAMPIF_H_

struct RLDDIRampLightingDriver;

RLDDIRampLightingDriver* RLDDIRampCreate(PD3DI_RASTCTX pCtx);
void RLDDIRampDestroy(RLDDIRampLightingDriver* drv);
void RLDDIRampBeginSceneHook(RLDDIRampLightingDriver* driver);
void RLDDIRampEndSceneHook(RLDDIRampLightingDriver* driver);
long RLDDIRampMaterialChanged(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
long RLDDIRampSetMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
long RLDDIRampCreateMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat, PD3DI_RASTCTX pCtx);
long RLDDIRampDestroyMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
unsigned long RLDDIRampMaterialToPixel(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
long RLDDIRampUpdateDDPalette(PD3DI_RASTCTX pCtx);
long RLDDIRampMakePaletteRGB8(RLDDIRampLightingDriver* driver);
long RLDDIRampPaletteChanged(RLDDIRampLightingDriver* driver, D3DTEXTUREHANDLE hTex);
void Ramp_Mono_ScaleImage_8(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);
void Ramp_Mono_ScaleImage_16(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);
void Ramp_Mono_ScaleImage_24(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);
void Ramp_Mono_ScaleImage_32(PD3DI_RASTCTX pCtx, D3DMATERIALHANDLE hMat, LPD3DRECT pRect);


#endif // _RAMPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmap.cpp ===
//----------------------------------------------------------------------------
//
// rampmap.cpp
//
// Implements required RLDDI stuff for rampmaps.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

static RLDDIRamp* NewRamp(int base, int size);

RLDDIRampmap* RLDDICreateRampmap(RLDDIColormap* cmap)
{
    RLDDIRampmap* rampmap;
    RLDDIRamp* ramp;

    if (D3DMalloc((void**) &rampmap, sizeof(RLDDIRampmap)))
        return NULL;

    CIRCLE_QUEUE_INITIALIZE(&rampmap->free,RLDDIRamp);
    CIRCLE_QUEUE_INITIALIZE(&rampmap->allocated,RLDDIRamp);

    rampmap->cmap = cmap;
    ramp = NewRamp(0, cmap->size);
    if (ramp == NULL)
    {
        D3DFree(rampmap);
        return NULL;
    }
    CIRCLE_QUEUE_INSERT_ROOT(&rampmap->free, RLDDIRamp, ramp, queue);

    return rampmap;
}

void RLDDIDestroyRampmap(RLDDIRampmap* rampmap)
{
    RLDDIRamp* ramp;
    RLDDIRamp* ramp_next;

    if (!rampmap)
        return ;

    for (ramp = CIRCLE_QUEUE_FIRST(&rampmap->allocated); ramp;
        ramp = ramp_next)
    {
        ramp_next = CIRCLE_QUEUE_NEXT(&rampmap->allocated,ramp,queue);
        D3DFree(ramp);
    }
    for (ramp = CIRCLE_QUEUE_FIRST(&rampmap->free); ramp;
        ramp = ramp_next)
    {
        ramp_next = CIRCLE_QUEUE_NEXT(&rampmap->free,ramp,queue);
        D3DFree(ramp);
    }
    D3DFree(rampmap);
}

RLDDIRamp* RLDDIRampmapAllocate(RLDDIRampmap* rampmap, int size)
{
    RLDDIRamp* ramp;
    RLDDIRamp* newramp;
    RLDDIRamp* ramp_next;

    if (!rampmap)
        return NULL;

    ramp = CIRCLE_QUEUE_FIRST(&rampmap->free);
    if (!ramp) return NULL;

    /*
     * cycle thru free rampmaps
     */
    for (; ramp && ramp->size < size; ramp = ramp_next)
    {
        ramp_next = CIRCLE_QUEUE_NEXT(&rampmap->free,ramp,queue);
    }
    /*
     * if we can't find a large enough ramp give up,
     * should try coalescing but it is non functional
     */
    if (!ramp || size > ramp->size)
        return NULL;

    /*
     * Remove the ramp from the freelist and add it to the allocated list.
     */
    CIRCLE_QUEUE_DELETE(&rampmap->free, ramp, queue);
    CIRCLE_QUEUE_INSERT_ROOT(&rampmap->allocated, RLDDIRamp, ramp, queue);
    ramp->free = FALSE;

    /*
     * If the size is right, return it.
     */
    if (size == ramp->size)
        return ramp;

    /*
     * Otherwise create a new ramp from the unneeded tail of this one and
     * throw it back into the freelist.
     */
    newramp = NewRamp(ramp->base + size, ramp->size - size);
    ramp->size = size;
    RLDDIRampmapFree(rampmap, newramp);

    return ramp;
}

void RLDDIRampmapFree(RLDDIRampmap* rampmap, RLDDIRamp* ramp)
{
    RLDDIRamp* free;

    if (!rampmap || !ramp)
        return ;

    DDASSERT(!ramp->free);
    ramp->free = TRUE;
    if (CIRCLE_QUEUE_NEXT(&rampmap->free,ramp,queue))
    {
        CIRCLE_QUEUE_DELETE(&rampmap->allocated, ramp, queue);
    }
    for (free = CIRCLE_QUEUE_FIRST(&rampmap->free); free;
        free = CIRCLE_QUEUE_NEXT(&rampmap->free,free,queue))
    {
        if (free->size > ramp->size)
        {
            /*
             * Add this ramp before the current one.
             */
            CIRCLE_QUEUE_INSERT_PREVIOUS(&rampmap->free, free, ramp, queue);
            return;
        }
    }
    /*
     * Must be the smallest so far, so add it to the end.
     */
    CIRCLE_QUEUE_INSERT_END(&rampmap->free, RLDDIRamp, ramp, queue);
}

static RLDDIRamp* NewRamp(int base, int size)
{
    RLDDIRamp* ramp;

    if (D3DMalloc((void**) &ramp, sizeof(RLDDIRamp)))
        return NULL;

    CIRCLE_QUEUE_INITIALIZE_MEMBER(ramp,queue);
    ramp->base = base;
    ramp->size = size;
    ramp->free = FALSE;
    return ramp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmisc.h ===
//----------------------------------------------------------------------------
//
// rampmisc.h
//
// Miscellaneous stuff needed to compile imported ramp code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPMISC_H_
#define _RAMPMISC_H_

#define VALPTOD(f,prec) ((double) (f))

#define NORMAL_PREC     16
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)

// Macro to retrieve SPANTEX pointer
#define HANDLE_TO_SPANTEX(hTex) \
    (*(PD3DI_SPANTEX *)ULongToPtr(hTex))

#endif // _RAMPMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rgbmap.h ===
//----------------------------------------------------------------------------
//
// rgbmap.h
//
// Structures and prototypes for rgb colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RGBMAP_H_
#define _RGBMAP_H_

#include "colall.h"

typedef struct _RLDDIRGBMap {
    unsigned long   red_mask;
    unsigned long   green_mask;
    unsigned long   blue_mask;

    int         red_shift;
    int         green_shift;
    int         blue_shift;

    /*
     * A color allocator for use with RLDDIColormap.
     */
    RLDDIColorAllocator alloc;
} RLDDIRGBMap;

RLDDIRGBMap* RLDDICreateRGBMap(unsigned long red_mask,
                   unsigned long green_mask,
                   unsigned long blue_mask);
void RLDDIDestroyRGBMap(RLDDIRGBMap* rgbmap);

#endif // _RGBMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rampmat.hpp ===
//----------------------------------------------------------------------------
//
// rampmat.hpp
//
// Declares classes for ramp material handling.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPMAT_HPP_
#define _RAMPMAT_HPP_

/* -*- c++ -*- */

#include "rampmap.h"
#include "palette.h"
#include "rgbmap.h"

struct ExtMaterial;
struct IntMaterial;
struct RampMaterial;
struct RLDDIRampLightingDriver;

struct AgeList {
    CIRCLE_QUEUE_MEMBER(AgeList) list;
    LIST_ROOT(alh,IntMaterial) agelist;
};

class RampCommon {
public:

    void* operator new(size_t size)
    {
    void* p;
        if (D3DMalloc(&p, size))
        return NULL;
    return p;
    }

    void operator delete(void *p)
    {
        D3DFree(p);
    }
};

/*
 * An ExtMaterial is the underlying driver object for an LPDIRECT3DMATERIAL.
 * When used, it creates IntMaterials which are distinguished by different
 * ambient light, fog, D3DMATERIAL value etc.
 *
 * The ExtMaterials are kept on a list in the driver and if not explicitly
 * freed, they are cleaned up when the driver is destroyed.
 *
 * The IntMaterials can outlive the ExtMaterial in the case that the
 * ExtMaterial is destroyed right after use.  We add these orphans to a list
 * which is emptied at Clear time since after Clear, no pixels are visible
 * which were rendered with the IntMaterial and it can be freed.
 */
struct ExtMaterial : public RampCommon {
    friend struct IntMaterial;
private:
    /*
     * Driver object which owns us.
     */
    RLDDIRampLightingDriver*    driver;

    /*
     * Current API level material definition.
     */
    D3DMATERIAL         mat;

    /*
     * List of internal materials derived from us.
     */
    LIST_ROOT(eml,IntMaterial)  intlist;

    /*
     * Generation count.  The generation is incremented each time
     * the material is changed.  This allows us to generate a new internal
     * material as needed.
     */
    int             generation;

    /*
     * This tracks the generation of any texture used by the material.  The
     * texture generation is bumped if its palette is changed or it is
     * loaded from another texture.
     */
    int             texture_generation;

    /*
     * This tracks the underlying texture object represented by the texture
     * handle (if any).  If texture handles are swapped, we need to know
     * so that we can make a new internal material for the new texture.
     */
    PD3DI_SPANTEX       texture;

    /*
     * Increment the generation either because the material was set or
     * because a texture changed.
     */
    void            Age();

public:
    /*
     * Chain for list of external materials created by this driver.
     */
    LIST_MEMBER(ExtMaterial)    list;

public:
    /*
     * Constructor/Destructor.
     */
    ExtMaterial(RLDDIRampLightingDriver* driver, D3DMATERIALHANDLE hMat);
    ~ExtMaterial();

    /*
     * Change the API level material.
     */
    void SetMaterial(D3DMATERIAL* mat);

    /*
     * Accessor to the current API level material.
     */
    D3DMATERIAL* GetMaterial() {
    return &mat;
    }

    /*
     * Find an internal material which corresponds to the current driver
     * object state.
     */
    IntMaterial* FindIntMaterial();

    /*
     * Find what range of values lighting should take.  The base is the
     * pixel value (in fixed point) of the dark end of the material.  The
     * shift value is user to convert a 0.16 fixed point shade into the
     * range needed for the material. e.g.
     *
     *      pixel = base + (VALTOFX8(shade) << shift);
     *
     */
    HRESULT FindLightingRange(unsigned long* base,
                  unsigned long* size,
                  BOOL* specular,
                  unsigned long** texture_colors);
};

/*
 * The IntMaterial is derived from an ExtMaterial taking into account the
 * driver state when the ExtMaterial was used.  Normally IntMaterials are
 * on a list in their owning ExtMaterial.  If the external material is
 * destroyed, any active internal materials which it owned are
 * transferred to an orphans list in the driver.  This is cleared out
 * next time Clear is called.
 *
 * The internal material has a list of underlying RampMaterials.  For
 * a non-textured material, there is exactly one and for a textured
 * material, there is one per color in the texture's palette.  The
 * ramp materials track color sharing between internal materials and
 * handle the details of allocating color resources.
 *
 * Internal materials are also chained onto one of a number of lists
 * based on their age.  The age of a material is the number of frames
 * since it was last used to render something.  When a material is
 * aged, it is rejuvenated by moving it to the age=0 list.  Each
 * frame, the lists are rotated by one notch and materials on the
 * oldest list are reclaimed.
 *
 * A material is either active or inactive.  Active materials have
 * color resources and are either on the age=0 list (active this
 * frame) or the age=1 list (active last frame).  When an inactive
 * material is used, it allocates color resources by attempting to
 * activate the underlying ramp materials.
 *
 * At the end of the frame, on Update, any active materials on the
 * age=1 list must be materials which were active last frame but were
 * not used this frame.  We remove their color resources by
 * deactivating the underlying ramp materials.
 */
struct IntMaterial : public RampCommon {
private:
    /*
     * Driver object which owns us.
     */
    RLDDIRampLightingDriver*    driver;

    /*
     * External material which created us.
     */
    ExtMaterial*        extmat;

public:
    /*
     * Too annoying to have these private.
     */

    /*
     * Chain of internal materials created by our external material owner
     * which owns us.  The chain is also used to place the material on the
     * driver's orphans list if appropriate.
     */
    LIST_MEMBER(IntMaterial)    list;

    /*
     * Current ageing list which we are on.
     */
    AgeList*            age;
    LIST_MEMBER(IntMaterial)    agelist;
private:

    /*
     * D3DMATERIAL which the external material had when it created us.
     */
    D3DMATERIAL         mat;

    /*
     * TRUE if we are active.  We are active if we currently have color
     * allocation resources assigned to us.
     */
    int             active;

    /*
     * Base values of our color allocation resources.  Contents are valid
     * only when active.
     */
    unsigned long*      colors;

    /*
     * Features which distinguish us from other internal materials owned by
     * our external material.
     */
    float                  ambient;        // ambient shade
    unsigned long       viewport_id;    // viewport which owns it
    int             fog_enable; // material incorporates fog
    unsigned long       fog_color;  // the fogging color
    int             generation;

    /*
     * RampMaterials used by this internal material.
     */
    int             ramp_count;
    RampMaterial**      ramps;

public:

    /*
     * Constructor/Destructor.
     */
    IntMaterial(ExtMaterial* extmat);
    ~IntMaterial();

    /*
     * Returns TRUE if we match the current settings of our external material
     * and driver state.
     */
    int Valid();

    /*
     * See ExtMaterial
     */
    HRESULT FindLightingRange(unsigned long* base,
                  unsigned long* size,
                  BOOL* specular,
                  unsigned long** texture_colors);

    /*
     * Activate the material and allocate color resources for it.
     */
    HRESULT Activate();

    /*
     * Deactivate the material, freeing color resources.  Always works.
     */
    void Deactivate();

    /*
     * Returns TRUE if the material is currently active.
     */
    int IsActive() {
    return active;
    }

    /*
     * Add the material to the driver's orphaned material list.  Called when
     * the external material is destroyed.
     */
    void Orphan();
};

/*
 * RampMaterials are used by internal materials to represent ranges of
 * colors.  They perform low level color allocation by allocating
 * color ranges (RLDDIRamps) from a rampmap.
 *
 * A textured internal material can use many ramp materials.
 * Several internal materials can use the same ramp material if the
 * colors match.  This can happen easily if many textures use the same
 * palette.  The ramp material maintains a usage of how many internal
 * materials are using it and is freed when the last one stops.
 *
 * Ramp materials, like internal materials are either active or
 * inactive.  Active materials have color resources and inactive
 * materials do not.  A ramp material is made active when any of its
 * internal material users are active and inactive when none of then
 * are active.  To track this a count of how many active users is
 * maintained.
 *
 * When a material is made active, it attempts to allocate a color
 * range to use.  If that is successful, it sets the colors in the
 * range to an appropriate ramp of colors.  If is no more space in the
 * colormap for a new range, it finds the closes active ramp material
 * and shares its ramp.
 *
 * To track active materials and sharing materials, the driver has a
 * list of active materials and each material has a list of sharers.
 * The sharers list is only valid for materials which are both active
 * and which own their ramp.
 */
struct RampMaterial : public RampCommon {
private:
    /*
     * Driver object which owns us.
     */
    RLDDIRampLightingDriver* driver;

    /*
     * List of materials which have the same hash value.
     */
    LIST_MEMBER(RampMaterial) hash;

    /*
     * Materials sharing this ramp.  Only valid for active materials
     * with owner == TRUE.
     */
    LIST_ROOT(name6,RampMaterial) sharers;

    /*
     * If the material is active, then it is on the drivers rmactive list
     * if it owns the ramp, otherwise it is on the sharers list of the
     * material which does own the ramp.  Only valid for active materials.
     */
    LIST_MEMBER(RampMaterial) list;

    /*
     * If were sharing a ramp and inherit it from the owner, we need to
     * defer setting the colors until the next frame to avoid possible
     * palette flashing.  The driver has a list of materials for which
     * color setting is deferred, chainged through here.
     *
     * We make sure that deferredlist.le_next is NULL unless we are
     * actually on the deferred list so that we can avoid list problems
     * if we are destroyed or passed on to another inheritor before the
     * list is processed.
     */
    LIST_MEMBER(RampMaterial) deferredlist;

    /*
     * A count of the number of internal materials which use us.
     */
    int         usage;

    /*
     * A count of active internal materials which use us.
     */
    int         active;

    /*
     * If we are active (active > 0), this is the underlying color
     * range for the material.
     */
    RLDDIRamp*          ramp;

    /*
     * TRUE if we created or inherited the ramp.  FALSE if I am merely
     * sharing some other material.
     */
    int                 owner;

    /*
     * Distinguishing features.
     */
    float          ambient;        /* ambient shade */
    D3DMATERIAL         mat;            /* material we represent */
    int         fog_enable; /* material incorporates fog */
    unsigned long   fog_color;  /* the fogging color */

private:

    /*
     * Constructor/Destructor.
     * These are private.  Callers should use Find/Release.
     */
    RampMaterial(RLDDIRampLightingDriver* driver,
                 D3DMATERIAL* mat, float ambient);
    ~RampMaterial();

public:
    /*
     * Find a material which matches the api material and driver state.
     * If no such material exists, make one.
     */
    static RampMaterial* Find(RLDDIRampLightingDriver* driver,
                  D3DMATERIAL* mat);

private:
    /*
     * Next functions are implementation detail of Find.
     */

    /*
     * Compare two api materials to see if they are identical.
     */
    static int MaterialSame(D3DMATERIAL* mat1, D3DMATERIAL* mat2);

    /*
     * Return a measure of how close two rgb colors are in rgb space.
     */
    static int RGBDist(D3DCOLORVALUE* rgb1, D3DCOLORVALUE* rgb2);

    /*
     * Return a measure of how close two api materials are.
     */
    static int CompareMaterials(D3DMATERIAL* mat1, D3DMATERIAL* mat2);

public:
    /*
     * Called by a user when it is no longer needed.
     */
    void Release();

    /*
     * Called by a user when the material is about to be used.
     */
    HRESULT Activate();

    /*
     * Called by a user when the material has not been used this frame.
     */
    void Deactivate();

    /*
     * Return the base color of an active material.
     */
    unsigned long Base();

private:
    /*
     * Implementation details of Activate and Deactivate.
     */

    /*
     * Allocate a ramp of colors for us to use.
     * May only be called for an inactive material.
     */
    HRESULT AllocateColors();

    /*
     * Free our color allocation.  May only be called for an active material.
     */
    void FreeColors();

    /*
     * Set the color values of our color allocation.
     */
private:
    void SetColorsStd();
    void SetColorsFog();
public:
    void SetColors();
};

///*
// * Workspace used when evaluating complex lighting models.
// */
//struct Workspace {
//    float  diffuse;
//    float  specular;
//};
//
//struct SpecularTable {
//    LIST_MEMBER(SpecularTable) list;
//    float          power;          /* shininess power */
//    float          table[260];     /* space for overflows */
//};
//
//#define WORKSPACE_SIZE  1024

#define HASH_SIZE       257
/*
 * If the app is rendering at 30fps, this means that a material can survive
 * for about 5 seconds.  This seems like enough to cope with stuff moving
 * out of shot and back in again soon after.
 */
#define AGE_MAX         (30*5)      /* age at which unused materials die */

typedef struct _RLDDISoftLightingDriver {
    D3DMATERIAL     material;
    float          ambient;
    D3DFOGMODE      fog_mode;
    float          fog_start;
    float          fog_end;
    float          fog_density;
    D3DMATERIALHANDLE   hMat;
    D3DCOLORMODEL   color_model;
    DWORD           ambient_save;
} RLDDISoftLightingDriver;

struct RLDDIRampLightingDriver {
    RLDDISoftLightingDriver         driver; /* common fields */

    /*
     * Colormap
     */
    RLDDIPalette*   palette;
    RLDDIRGBMap*    rgbmap;
    unsigned long*  pixelmap; /* map color indices to pixels */
    PALETTEENTRY    ddpalette[256];
    int         paletteChanged;

    RLDDIRampmap*       rampmap;
    unsigned long   viewport_id;    /* current viewport */
    int         fog_enable;
    unsigned long   fog_color;

    /*
     * External materials created by this driver.
     */
    LIST_ROOT(deml,ExtMaterial) materials;

    /*
     * Active internal materials orphaned by their owning external material.
     */
    LIST_ROOT(diml,IntMaterial) orphans;

    AgeList     agelists[AGE_MAX];
    CIRCLE_QUEUE_ROOT(aqh,AgeList) agequeue;    /* age sorted queue of lists */
    AgeList*        active;     /* current active list */

    /*
     * This is set to TRUE after Clear has advanced the ages one notch and
     * cleared on update.  It is used to stop multiple calls to Clear from
     * confusing the aging system
     */
    int         already_aged;

    LIST_ROOT(name7,RampMaterial) rmactive; /* materials with ramps */
    LIST_ROOT(name8,RampMaterial) rmdeferred;
    LIST_ROOT(name9,RampMaterial) hash[HASH_SIZE]; /* materials hash table */

    /*
     * Current material.
     */
    ExtMaterial*    current_material;
};

typedef struct _RLDDILookupMaterialData {
    D3DMATERIALHANDLE   hMat;            /* material to look up */
    unsigned long       base;           /* base pixel value */
    unsigned long       size;           /* size of index range */
    unsigned long       texture_index;  /* texture table for textures */
} RLDDILookupMaterialData;


#endif // _RAMPMAT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\sources.inc ===
TARGETNAME = rrampmat
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(D3DROOT)\pipeln\inc;$(INCLUDES)

SOURCES = \
        ..\indcmap.cpp\
        ..\rampmap.cpp\
        $O\rampmat.cpp\
        ..\palette.cpp\
        ..\rgbmap.cpp

NTTARGETFILE0 = \
        $O\rampmat.cpp


PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampmat\rgbmap.cpp ===
//----------------------------------------------------------------------------
//
// rgbmap.cpp
//
// Implements rgb colormap code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

static int CalculateShift(unsigned long mask);
static unsigned long AllocateColor(void* arg, int red, int green, int blue);
static void FreeColor(void* arg, unsigned long pixel);

RLDDIRGBMap* RLDDICreateRGBMap(unsigned long red_mask,
                               unsigned long green_mask,
                               unsigned long blue_mask)
{
    RLDDIRGBMap* rgbmap;

    if (D3DMalloc((void**) &rgbmap, sizeof(RLDDIRGBMap)))
        return NULL;

    rgbmap->red_mask = red_mask;
    rgbmap->green_mask = green_mask;
    rgbmap->blue_mask = blue_mask;

    rgbmap->red_shift = CalculateShift(rgbmap->red_mask);
    rgbmap->green_shift = CalculateShift(rgbmap->green_mask);
    rgbmap->blue_shift = CalculateShift(rgbmap->blue_mask);

    rgbmap->alloc.priv = rgbmap;
    rgbmap->alloc.allocate_color = AllocateColor;
    rgbmap->alloc.free_color = FreeColor;

    return rgbmap;
}

// ATTENTION this function should perhaps be packaged up and put in d3dutil
static int RLDDILog2[] = {
    0,  0,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,
    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,
    8,
};

static int CalculateShift(unsigned long mask)
{
    int shift, width;

    shift = 0;
    while ((mask & 1) == 0)
    {
        shift++;
        mask >>= 1;
    }
    width = RLDDILog2[mask + 1];
    return shift - (8 - width);
}

/*
 * We can't just use left shift since some CPUs don't treat left shift by
 * a negative as right shift (and why should they after all).
 */
#define SHIFT(t, v, s)                                \
do {                                          \
    if (s < 0)                                    \
    t = v >> -s;                                  \
    else                                      \
    t = v << s;                               \
} while (0)

static unsigned long AllocateColor(void* arg, int red, int green, int blue)
{
    RLDDIRGBMap* rgbmap = (RLDDIRGBMap*) arg;
    unsigned long pixel;
    unsigned long t;
    SHIFT(t, red, rgbmap->red_shift);
    pixel = t & rgbmap->red_mask;
    SHIFT(t, green, rgbmap->green_shift);
    pixel |= t & rgbmap->green_mask;
    SHIFT(t, blue, rgbmap->blue_shift);
    pixel |= t & rgbmap->blue_mask;
    return pixel;
}

static void FreeColor(void* arg, unsigned long pixel)
{
}

void RLDDIDestroyRGBMap(RLDDIRGBMap* rgbmap)
{
    D3DFree(rgbmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\d3drlddi.h ===
/*
 * $Id: d3drlddi.h,v 1.8 1995/11/21 14:42:53 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef _D3DRLDDI_H_
#define _D3DRLDDI_H_

#include "d3di.h"

#if defined(__cplusplus)
extern "C"
{
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef D3DRECT RLDDIRectangle;
typedef D3DTLVERTEX RLDDIVertex;
typedef D3DTRANSFORMDATA RLDDITransformData;

#define RLDDI_TRIANGLE_ENABLE_EDGE01 D3DTRIANGLE_ENABLE_EDGE01
#define RLDDI_TRIANGLE_ENABLE_EDGE12 D3DTRIANGLE_ENABLE_EDGE12
#define RLDDI_TRIANGLE_ENABLE_EDGE20 D3DTRIANGLE_ENABLE_EDGE20

#if defined(__cplusplus)
};
#endif

#endif /* _D3DRLDDI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dmath.h ===
#ifndef __RLDMATH__
#define __RLDMATH__

extern RLDDIValue RLDDIhdivtab[];

#define HDIVIDE(a, b)	RLDDIFMul24((a), RLDDIhdivtab[b])

#ifdef USE_FLOAT
#define TWOPOW32 ((double)(65536.0 * 65536.0))

#define TWOPOW(N) (((N) < 32) ? ((double)(1UL << (N))) : \
		                ((double)(1UL << (N - 32)) * TWOPOW32))

extern double RLDDIConvertIEEE[];
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dlist.h ===
/*
 * $Id: dlist.h,v 1.13 1995/07/31 16:01:40 dfr Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __DLIST_H__
#define __DLIST_H__




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\equates.asm ===
; $Id: equates.asm,v 1.5 1995/04/04 14:57:34 servan Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;

ifdef STACK_CALL 
else
SUFFIX = 1
endif

ifdef MICROSOFT_NT
SUFFIX = 1
endif

	ifdef	SUFFIX


	else

_RLDDIhdivtab		equ RLDDIhdivtab
_RLDDIhdiv2tab		equ RLDDIhdiv2tab

 	endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dmath.c ===
/* $Id: dmath.c,v 1.2 1995/09/25 11:39:43 james Exp $ */

#include <math.h>
#include <limits.h>
#include "driver.h"
#include "dmath.h"

//#ifdef USE_FLOAT
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW27  134217728
#define FLOAT_TWOPOW27  ((float)(CONST_TWOPOW27))

float RLDDIFloatConstInv64K = (float)1.0 / (float)65536.0;
float RLDDIFloatConstInv256 = (float)1.0 / (float)256.0;
float RLDDIFloatConst64K = (float)65536.0;
float RLDDIFloatConst2p24 = (float)65536.0 * (float)256.0;
float RLDDIFloatConst2p36 = (float)16.0 * (float)65536.0 * (float)65536.0;
float RLDDIFloatConst5 = (float)5.0;
float RLDDIFloatConst16 = (float)16.0;
float RLDDIFloatConst1 = (float)1.0;
float RLDDIFloatConstHalf = (float)0.5;
float RLDDIFloatConstAffineThreshold = (float)2.0 * (float)64.0;
float g_fOne = (float)1.0;
float g_fOoTwoPow20 =           (float)(1.0 / (double)CONST_TWOPOW20);
float g_fTwoPow27 =             FLOAT_TWOPOW27;
//#endif

double RLDDIConvertIEEE[33] =
{
  TWOPOW32 + TWOPOW(52),
  TWOPOW32 + TWOPOW(51),
  TWOPOW32 + TWOPOW(50),
  TWOPOW32 + TWOPOW(49),
  TWOPOW32 + TWOPOW(48),
  TWOPOW32 + TWOPOW(47),
  TWOPOW32 + TWOPOW(46),
  TWOPOW32 + TWOPOW(45),
  TWOPOW32 + TWOPOW(44),
  TWOPOW32 + TWOPOW(43),
  TWOPOW32 + TWOPOW(42),
  TWOPOW32 + TWOPOW(41),
  TWOPOW32 + TWOPOW(40),
  TWOPOW32 + TWOPOW(39),
  TWOPOW32 + TWOPOW(38),
  TWOPOW32 + TWOPOW(37),
  TWOPOW32 + TWOPOW(36),
  TWOPOW32 + TWOPOW(35),
  TWOPOW32 + TWOPOW(34),
  TWOPOW32 + TWOPOW(33),
  TWOPOW32 + TWOPOW(31),
  TWOPOW(31) + TWOPOW(30),
  TWOPOW(30) + TWOPOW(29),
  TWOPOW(29) + TWOPOW(28),
  TWOPOW(28) + TWOPOW(27),
  TWOPOW(27) + TWOPOW(26),
  TWOPOW(26) + TWOPOW(25),
  TWOPOW(25) + TWOPOW(24),
  TWOPOW(24) + TWOPOW(23),
  TWOPOW(23) + TWOPOW(22),
  TWOPOW(22) + TWOPOW(21),
  TWOPOW(21) + TWOPOW(20),
  TWOPOW(20) + TWOPOW(19)
};

RLDDIValue RLDDIhdivtab[] = {
#include "hdivtab.i"
};

#ifdef CHIMERA
unsigned short RLDDI_reciprocals[] = {
#include "recips.i"
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\driver.h ===
/* $Id: driver.h,v 1.71 1995/12/04 11:31:51 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __DRIVER_H__
#define __DRIVER_H__

#define USE_FLOAT

#ifdef WIN32
//#define WIN32_LEAN_AND_MEAN
#endif
#include <stddef.h>
#include <wtypes.h>

typedef struct _RLDDIDriver RLDDIDriver;
typedef struct _RLDDIDriverStack RLDDIDriverStack;

#ifdef USE_FLOAT
#include "fltval.h"
#else
#include "fixval.h"
#endif
#include "osdep.h"

#ifdef D3D
typedef enum _RLRenderQuality {
    RLRenderWireframe,      /* display just the edges */
    RLRenderUnlitFlat,      /* flat shaded without lighting */
    RLRenderFlat,       /* flat shaded */
    RLRenderGouraud,        /* gouraud shaded */
    RLRenderPhong       /* phong shaded */
} RLRenderQuality;

typedef enum _RLColorModel {
    RLColorRamp, RLColorRGB
} RLColorModel;

typedef enum _RLLightType {
    RLLightAmbient,
    RLLightPoint,
    RLLightSpot,
    RLLightDirectional,
    RLLightParallelPoint
} RLLightType;

#if 0
/*
 * Error codes
 */
typedef enum _RLError {
    RLNoError = 0,      /* no error */
    RLBadObject,        /* object expected in argument */
    RLBadType,          /* bad argument type passed */
    RLBadAlloc,         /* out of memory */
    RLFaceUsed,         /* face already used in a mesh */
    RLNotFound,         /* object not found in specified place */
    RLNotDoneYet,       /* unimplemented */
    RLFileNotFound,     /* file cannot be opened */
    RLBadFile,          /* data file is corrupt */
    RLBadDevice,        /* device is not compatible with renderer */
    RLBadValue,         /* bad argument value */
    RLBadMajorVersion,      /* bad dll major version */
    RLBadMinorVersion,      /* bad dll minor version */
    RLMaxError
} RLErrorXXX;
#endif

#else
#include "rl.h"
#endif D3D

/*
 * Normal precision used to store numbers.
 */
#define NORMAL_PREC     16
#define DTOVAL(d)       DTOVALP(d,NORMAL_PREC)
#define VALTOD(f)       VALPTOD(f,NORMAL_PREC)
#define ITOVAL(i)       ITOVALP(i,NORMAL_PREC)
#define VALTOI(f)       VALPTOI(f,NORMAL_PREC)
#define VALROUND(f)     VALPROUND(f,NORMAL_PREC)
#define VALTOFX(f)      VALTOFXP(f,NORMAL_PREC)
#define FXTOVAL(f)      FXPTOVAL(f,NORMAL_PREC)
#define ITOFX(i)        ITOFXP(i,NORMAL_PREC)
#define FXTOI(f)        FXPTOI(f,NORMAL_PREC)
#define FXROUND(f)      FXPROUND(f,NORMAL_PREC)
#define FXFLOOR(f)      FXPTOI(f,NORMAL_PREC)
#define FXCEIL(f)       FXPCEIL(f,NORMAL_PREC)
#define VALTOFX24(f)    VALTOFXP(f,24)
#define FX24TOVAL(f)    FXPTOVAL(f,24)
#define VALTOFX20(f)    VALTOFXP(f,20)
#define FX20TOVAL(f)    FXPTOVAL(f,20)
#define VALTOFX12(f)    VALTOFXP(f,12)
#define FX12TOVAL(f)    FXPTOVAL(f,12)
#define VALTOFX8(f)     VALTOFXP(f,8)
#define FX8TOVAL(f)     FXPTOVAL(f,8)

/*
 * A handy macro.
 */
#define RLDDIAbs(N) (((N) < 0) ? -(N) : (N))

#if defined(__DOS__) || defined(__WINDOWS_386__)
#define RLFAR far
#else
#define RLFAR
#endif

#ifndef UNUSED
#if defined(__WATCOMC__)
#define UNUSED(v)       (v)
#else
#define UNUSED(v)
#endif
#endif

typedef enum _RLDDIServiceType {
    /*
     * Notify a module after it has been pushed into a stack.
     *
     * The module may also register fast service functions;
     * to register a fast service, set the appropriate table entry.
     * Note: the module must either register *no* services (old style),
     * or *all* the services it supports (including RLDDIPush)
     */
    /* HRESULT */ RLDDIPush,                    /* 0, RLDDIServiceProc[] */

    /*
     * Get a set of functions to create transform, render and lighting
     * drivers compatible with the given windowing system driver and color
     * model.
     */
    /* HRESULT */ RLDDIGetCreateDriverFunctions,/* RLColorModel, &result */

    /*
     * Notify a module before it is popped from a stack.
     */
    /* HRESULT */ RLDDIPop,                     /* NULL, NULL */

    /*
     * Set various rendering parameters.
     */
    /* HRESULT */ RLDDISetRenderParams,         /* 0, RLDDIRenderParams* */

    /*
     * Set the current viewport.
     */
    /* HRESULT */ RLDDISetViewport,             /* id, D3DVIEWPORT2* */

    /*
     * Deal with matrices
     */
    /* HRESULT */ RLDDICreateMatrix,        /* 0, LPD3DMATRIXHANDLE */
    /* HRESULT */ RLDDISetMatrix,       /* D3DMATRIXHANDLE, LPD3DMATRIX */
    /* HRESULT */ RLDDIGetMatrix,       /* D3DMATRIXHANDLE, LPD3DMATRIX */
    /* HRESULT */ RLDDIDeleteMatrix,        /* D3DMATRIXHANDLE, NULL */
    /*
     * Set one of the transformation matrices
     */
    /* HRESULT */ RLDDISetMatrixView,                   /* type, D3DMATRIXHANDLE */
    /* HRESULT */ RLDDISetMatrixProj,                   /* type, D3DMATRIXHANDLE */
    /* HRESULT */ RLDDISetMatrixWorld,                  /* type, D3DMATRIXHANDLE */
#if 0
    /* HRESULT */ RLDDISetMatrixTrans,                  /* type, D3DMATRIXHANDLE */
#endif

    /* HRESULT */ RLDDIMultiplyMatrices,                /* count, RLDDIMatrix** */

    /*
     * Transform some vertices.
     */
    /* ClipFlags */ RLDDITransform,                     /* count, RLDDITransformData* */
    /* ClipFlags */ RLDDITransformClipped,              /* count, RLDDITransformData* */
    /* ClipFlags */ RLDDITransformUnclipped,            /* count, RLDDITransformData* */

    /*
     * Set the current lighting configuration.  All normals are given
     * in the current model coordinate system.
     */
    /* HRESULT */ RLDDISetLight,               /* which_light, D3DI_LIGHTDATA* */

    /*
     * Set the current fog configuration.
     */
    /* HRESULT */ RLDDISetFogMode,          /* 0, D3DFOGMODE* */
    /* HRESULT */ RLDDISetFogStart,         /* 0, RLDDIValue* */
    /* HRESULT */ RLDDISetFogEnd,           /* 0, RLDDIValue* */
    /* HRESULT */ RLDDISetFogDensity,           /* 0, RLDDIValue* */

    /* HRESULT */ RLDDISetFogEnable,            /* 0, D3DFOGMODE* */
    /* HRESULT */ RLDDISetFogColor,         /* 0, D3DFOGMODE* */

    /*
     * Calculate pixel values for some primitives with lighting.
     */
    /* HRESULT */ RLDDIApplyMaterialsLit,       /* count, D3DLIGHTDATA* */

    /*
     * Calculate pixel values for some primitives without lighting.
     */
    /* HRESULT */ RLDDIApplyMaterialsUnlit,     /* count, D3DLIGHTDATA* */

    /*
     * Calculate vertex values for some primitives without lighting.
     */
    /* HRESULT */ RLDDIApplyMaterialShade,     /* count, D3DLIGHTDATA* */

    /*
     * Called to update dynamic color allocation state for materials
     * which are still being used but not lit.  Returns TRUE if the
     * results of the previous lighting calls can be reused or FALSE
     * if the object should be relit anyway due to color entries being
     * reclaimed.
     */
    /* Boolean */ RLDDIUpdateMaterial,

    /*
     * Clear a drivers pick records
     */
    /* HRESULT */ RLDDIClearPickRecords,                /* 0, NULL */

    /* HRESULT */ RLDDIGetPickRecords,                  /* 0, NULL */
    /*
     * pick a display list.
     */
    /* HRESULT */ RLDDIPickExecuteBuffer,               /* stak top, RLDDIPickData* */

    /*
     * Execute a display list.
     */
    /* HRESULT */ RLDDIExecuteUnclipped,                /* stak top, RLDDIExecuteData* */
    /* HRESULT */ RLDDIExecuteClipped,                  /* stak top, RLDDIExecuteData* */

    /*
     * Get the current pixmaps used for drawing (used by software
     * renderers to interface with low level drivers).
     */
    /* HRESULT */ RLDDIGetColorPixmap,                  /* NULL, &pixmap */
    /* HRESULT */ RLDDIGetDepthPixmap,                  /* NULL, &pixmap */

    /*
     * Release the current pixmaps used for drawing (used by software
     * renderers to interface with low level drivers).
     */
    /* HRESULT */ RLDDIReleaseColorPixmap,              /* NULL NULL */
    /* HRESULT */ RLDDIReleaseDepthPixmap,              /* NULL NULL */

    /*
     * Find a color allocator to use for mapping rgb values to pixels.
     */
    /* HRESULT */ RLDDIFindColorAllocator,              /* NULL, &alloc */

    /*
     * Find a rampmap to use for color allocation in color index
     * drivers.  This does not need to be supported if color index
     * rendering is not used.
     */
    /* HRESULT */ RLDDIFindRampmap,                     /* NULL, &rampmap */

    /*
     * Release a rampmap (from RLDDIFindRampmap), freeing all
     * resources.
     */
    /* HRESULT */ RLDDIReleaseRampmap,                  /* NULL, rampmap */

    /*
     * Get the color index -> pixel value mapping (if any).
     */
    /* HRESULT */ RLDDIGetColorMapping,                 /* NULL, &unsigned_long_ptr */

    /*
     * Convert a texture handle into a pointer (private to ramp driver)
     */
    /* HRESULT */ RLDDILookupTexture,               /* NULL, handle */

    /*
     * Update the screen with a region which has changed.  May involve
     * copying into the window, swapping double buffers, etc.
     */
    /* HRESULT */ RLDDIUpdate,                          /* count, D3DRECTANGLE* */

    /*
     * Lock against vsync, if necessary, for a given driver.
     */
    /* HRESULT */ RLDDISync,

    /*
     * Clear the viewport.
     */
    /* HRESULT */ RLDDIClear,                           /*  */

    /*
     * Clear the zbuffer.
     */
    /* HRESULT */ RLDDIClearZ,                          /*  */

    /*
     * Clear the both the z and viewport.
     */
    /* HRESULT */ RLDDIClearBoth,                       /*  */

    /*
     * Get the dimensions of the device.
     */
    /* HRESULT */ RLDDIGetDriverParams,                 /* 0, RLDDIDriverParams* */

    /*
     * Set a material to be used to clear the viewport in RLDDIClear.
     */
    /* HRESULT */ RLDDISetBackgroundMaterial,           /* 0, D3DMATERIALHANDLE */

    /*
     * Set an image to be used to clear the viewport depth planes
     * in RLDDIClear.
     */
    /* HRESULT */ RLDDISetBackgroundDepth,              /* 0, RLImage* */

    /*
     * Ask the driver whether it can support the given RLImage as a
     * texture map.  If the image can be supported directly, the
     * driver should return RLNoError.  If another image format is
     * preferred, the driver should modify the pointer to point to an
     * RLImage structure of the required format and return RLNoError.  Note
     * that this need not be a complete image.  The buffer1 and
     * palette fields are ignored.
     *
     * If the driver does not support texture mapping at all, then it
     * should return RLBadDevice.
     *
     * If arg1 is not null, the driver will point at an array of DDSURFACEDESC
     * structures and return the size of the array.
     */
    /* HRESULT  | int */ RLDDIQueryTextureFormat,               /* LPDDSURFACEDESC*, RLImage** */

    /* HRESULT */ RLDDIActivatePalette,                 /* WM_ACTIVATE */

    /*
     * Set the current material for the lighting module.
     */
    /* HRESULT */ RLDDISetMaterial,                 /* 0, D3DMATERIALHANDLE */

    /*
     * Set the color of the ambient light. The format is:
     *     (white << 24) | (red << 16) | (green << 8) | blue
     * where white is the equivalent white shade for monochrome lighting.
     */
    /* HRESULT */ RLDDISetAmbientLight,                 /* color, NULL */

    /*
     * Create a texture from the given image.  The image must be in a format
     * approved by RLDDIQueryTextureFormat.  The texture may use the memory
     * of the image for the pixel values or it may copy the image.  Returns
     * a handle for the texture.
     */
    /* HRESULT */ RLDDICreateTexture,             /* LPDIRECTDRAWSURFACE, &D3DTEXTUREHANDLE */

    /*
     * Destroy a texture previously created using RLDDICreateTexture.
     */
    /* HRESULT */ RLDDIDestroyTexture,                  /* D3DTEXTUREHANDLE, 0 */

    /*
     * Load a texture previously created using RLDDICreateTexture.
     * arg1 - src, arg2 = dst
     */
    /* HRESULT */ RLDDILoadTexture,                 /* D3DTEXTUREHANDLE, D3DTEXTUREHANDLE*/

    /*
     * Lock a texture previously created using RLDDICreateTexture.
     */
    /* HRESULT */ RLDDILockTexture,                 /* D3DTEXTUREHANDLE, 0 */

    /*
     * Unlock a texture previously created using RLDDICreateTexture.
     */
    /* HRESULT */ RLDDIUnlockTexture,                   /* D3DTEXTUREHANDLE, 0 */

    /*
     * Swap two textures.
     */
    /* HRESULT */ RLDDISwapTextureHandles,              /* D3DTEXTUREHANDLE, D3DTEXTUREHANDLE */

    /*
     * Update any private copies of the pixels in a texture when it has been
     * changed by the application.  The flags argument is a bitfield:
     *
     *          flags & 1               the image pixels have changed
     *          flags & 2               the image palette has changed
     */
    /* HRESULT */ RLDDIUpdateTexture,                   /* flags, handle */

    /*
     *
     */
    /* HRESULT */ RLDDISetTextureOpacity,       /* 0, RLDDISetTextureOpacityParams */

    /*
     * Used in ramp color module for interfacing between renderer and
     * lighting.
     */
    /* HRESULT */ RLDDILookupMaterial,

    /*
     * Create a material
     */
    /* HRESULT */ RLDDICreateMaterial,  /* D3DMATERIALHANDLE*, D3DMATERIAL* */

    /*
     * Destroy a material
     */
    /* HRESULT */ RLDDIDestroyMaterial, /* D3DMATERIALHANDLE, NULL */

    /*
     * Used by renderer to map material handles to materials.
     */
    /* HRESULT */ RLDDIFindMaterial,    /* D3DMATERIALHANDLE, LPD3DMATERIAL* */

    /*
     * Used by Direct3D to inform the driver that a material has changed.
     */
    /* HRESULT */ RLDDIMaterialChanged, /* D3DMATERIALHANDLE, LPD3DMATERIAL */

    /*
     * Used by Direct3D to reserve a material
     */
    /* HRESULT */ RLDDIMaterialReserve, /* D3DMATERIALHANDLE, NULL */

    /*
     * Used by Direct3D to unreserve a material
     */
    /* HRESULT */ RLDDIMaterialUnreserve,/* D3DMATERIALHANDLE, NULL */

    /*
     * Used with frame materials to override the settings of a
     * display list.
     */
    /* HRESULT */ RLDDISetOverrideFillParams,           /* 0, &override_params */

    /*
     * Used with frame materials to override the settings of a
     * display list.
     */
    /* HRESULT */ RLDDISetOverrideMaterial,     /* 0, override_material */

    /*
     * Create an Execute Buffer
     */
    /* HRESULT */ RLDDIAllocateBuffer,          /* LPD3DI_BUFFERHANDLE, LPD3DEXECUTEBUFFERDESC */

    /*
     * Destroy an Execute Buffer
     */
    /* HRESULT */ RLDDIDeallocateBuffer,        /* D3DI_BUFFERHANDLE, (LPVOID)0 */

    /*
     * Lock an Execute Buffer
     */
    /* HRESULT */ RLDDILockBuffer,          /* D3DI_BUFFERHANDLE, (LPVOID)0 */

    /*
     * Unlock an Execute Buffer
     */
    /* HRESULT */ RLDDIUnlockBuffer,            /* D3DI_BUFFERHANDLE, (LPVOID)0 */

    /*
     * Set all 256 palette entries in an 8 bit device.
     */
    /* HRESULT */ RLDDISetPalette,          /* 0, RLPalettEntry* */

    /*
     * Get all 256 palette entries of an 8 bit device.
     */
    /* HRESULT */ RLDDIGetPalette,          /* 0, RLPaletteEntry* */

    /*
     * Generic platform specific driver extension type thing.
     */
    /* HRESULT */ RLDDIDriverExtension,         /* code, (void *) */

#ifdef __psx__
    /*
     * Set various PSX specific flags, to increase speed
     */
    /* HRESULT */ RLDDIPSXSetUpdateFlags,

    /*
     * allow people to reserve space in VRAM for their own use
     */
    /* HRESULT */ RLDDIPSXReserveTextureSpace,
    /* HRESULT */ RLDDIPSXReserveCLUTSpace,

    /*
     * so that people can access ordering table info
     */

    /* HRESULT */ RLDDIPSXQuery,
#endif

    /*
     * Inform of beginning/end of a scene.
     */
    /* HRESULT */ RLDDISceneCapture,            /* BOOL, NULL */

    /*
     * Get an item of state from a particular module.
     */
    /* HRESULT */ RLDDIGetState,            /* long, LPD3DSTATE */

    /*
     * Get stats from a driver
     */
    /* HRESULT */ RLDDIGetStats,            /* 0, LPD3DSTATS */

    /*
     * Not a service call
     */
    RLDDIServiceCount /* assumes none of the other enums are given initializers */

} RLDDIServiceType;


#ifdef D3D
typedef enum _RLPaletteFlags {
    RLPaletteFree,      /* renderer may use this entry freely */
    RLPaletteReadOnly,      /* fixed but may be used by renderer */
    RLPaletteReserved       /* may not be used by renderer */
} RLPaletteFlags;


typedef struct _RLPaletteEntry {
    unsigned char red;      /* 0 .. 255 */
    unsigned char green;    /* 0 .. 255 */
    unsigned char blue;     /* 0 .. 255 */
    unsigned char flags;    /* one of RLPaletteFlags */
} RLPaletteEntry;

typedef struct _RLImage {
    int width, height;      /* width and height in pixels */
    int aspectx, aspecty;   /* aspect ratio for non-square pixels */
    int depth;          /* bits per pixel */
    int rgb;            /* if false, pixels are indices into a
                   palette otherwise, pixels encode
                   RGB values. */
    int bytes_per_line;     /* number of bytes of memory for a
                   scanline. This must be a multiple
                   of 4. */
    void* buffer1;      /* memory to render into (first buffer). */
    void* buffer2;      /* second rendering buffer for double
                   buffering, set to NULL for single
                   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;
                /* if rgb is true, these are masks for
                   the red, green and blue parts of a
                   pixel.  Otherwise, these are masks
                   for the significant bits of the
                   red, green and blue elements in the
                   palette.  For instance, most SVGA
                   displays use 64 intensities of red,
                   green and blue, so the masks should
                   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    RLPaletteEntry* palette;    /* description of the palette (only if
                   rgb is false).  Must be (1<<depth)
                   elements. */
} RLImage;




#endif /* D3D */


#ifdef WIN32
#define RLDDIAPI  __stdcall
#else
#define RLDDIAPI
#endif

typedef void (*RLDDIDestroyProc)(RLDDIDriver* driver);
typedef long (*RLDDIServiceProc)(RLDDIDriver* driver,
                 RLDDIServiceType type,
                 long arg1,
                 void* arg2);

typedef HRESULT (RLDDIAPI *RLDDIMallocFn)(void**, size_t);
typedef HRESULT (RLDDIAPI *RLDDIReallocFn)(void**, size_t);
typedef void (RLDDIAPI *RLDDIFreeFn)(void*);
typedef HRESULT (*RLDDIRaiseFn)(HRESULT);

#ifndef DLL_IMPORTS_GEN
__declspec( dllexport ) extern RLDDIRaiseFn RLDDIRaise;
__declspec( dllexport ) extern RLDDIMallocFn    RLDDIMalloc;
__declspec( dllexport ) extern RLDDIReallocFn   RLDDIRealloc;
__declspec( dllexport ) extern RLDDIFreeFn  RLDDIFree;
#else
__declspec( dllimport ) RLDDIRaiseFn    RLDDIRaise;
__declspec( dllimport ) RLDDIMallocFn   RLDDIMalloc;
__declspec( dllimport ) RLDDIReallocFn  RLDDIRealloc;
__declspec( dllimport ) RLDDIFreeFn RLDDIFree;
#endif

#include "d3di.h"
#include "dditypes.h"

typedef struct _RLDDIGlobalDriverData {
    /*
     * Pointers to driver modules
     */
    RLDDIDriver     *transform;
    RLDDIDriver     *lighting;
    RLDDIDriver     *raster;
} RLDDIGlobalDriverData;

struct _RLDDIDriver {
    RLDDIDriver*        prev;
    RLDDIDriver*        next;
    RLDDIDriverStack*   top;            /* top of the driver stack */

    int                 width, height;  /* dimensions */

    RLDDIDestroyProc    destroy;        /* clean up */
    RLDDIServiceProc    service;        /* do something */

    RLDDIGlobalDriverData* data;    /* pointer to global data */
    /* Driver private data may follow */
};

struct _RLDDIDriverStack {
    RLDDIDriver *top;
    struct {
    RLDDIServiceProc call;
    RLDDIDriver *driver;
    } fastService[RLDDIServiceCount];
    int polygons_drawn;
    RLDDIGlobalDriverData data;
};

#include "d3drlddi.h"
#include "dlist.h"

#define RLDDIService(stackp, type, arg1, arg2) \
    (*((stackp)->fastService[type].call)) \
    ((stackp)->fastService[type].driver, (type), (arg1), (arg2))

/* old macro
    (*((stackp)->top->service))((stackp)->top, (type), (arg1), (arg2))
*/

#ifdef DLL_IMPORTS_GEN
__declspec( dllimport ) int RLDDILog2[];
#else
extern int RLDDILog2[];
#endif

#ifdef _DLL
void RLDDIInit2(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
#endif
void RLDDIInit(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
void RLDDIPushDriver(RLDDIDriverStack* stack, RLDDIDriver* driver);
void RLDDIPopDriver(RLDDIDriverStack* stack);

HRESULT RLDDICreatePixmap(RLDDIPixmap** result,
              int width, int height, int depth);
HRESULT RLDDICreatePixmapFrom(RLDDIPixmap** result,
                  int width, int height, int depth,
                  void RLFAR* data, int bytes_per_line);
HRESULT RLDDICreatePixmapFromSurface(RLDDIPixmap** result,
                     LPDIRECTDRAWSURFACE lpDDS);
void RLDDIDestroyPixmap(RLDDIPixmap* pm);
void RLDDIPixmapFill(RLDDIPixmap* pm, unsigned long value,
             int x1, int y1, int x2, int y2);
void RLDDIPixmapCopy(RLDDIPixmap* dstpm, RLDDIPixmap* srcpm,
             int x1, int y1, int x2, int y2,
             int dstx, int dsty);
void RLDDIPixmapScale(RLDDIPixmap* dstpm, LPDDSURFACEDESC srcim,
              RLDDIValue scalex, RLDDIValue scaley,
              int x1, int y1, int x2, int y2,
              int dstx, int dsty);
HRESULT RLDDIPixmapLock(RLDDIPixmap* pm);
void RLDDIPixmapUnlock(RLDDIPixmap* pm);
void RLDDIPixmapUpdatePalette(RLDDIPixmap* pm);

RLDDIDriver*    RLDDICreateTransformDriver(int width, int height);
RLDDIDriver*    RLDDICreateRampLightingDriver(int width, int height);
RLDDIDriver*    RLDDICreateRampDriver(int width, int height);
RLDDIDriver*    RLDDICreateRGBLightingDriver(int width, int height);
RLDDIDriver*    RLDDICreateRGBDriver(int width, int height);

extern HRESULT WINAPI DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern HRESULT WINAPI DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

/*
 * RLDDIDriverExtension codes
 */
#define RLDDIDDrawGetObjects    0x1234
#define RLDDIDDrawWinMove   0x1235

/*
 * Six standard clipping planes plus six user defined clipping planes.
 * See rl\d3d\d3d\d3dtypes.h.
 */

#define MAX_CLIPPING_PLANES 12

/* Space for vertices generated/copied while clipping one triangle */

#define MAX_CLIP_VERTICES   (( 2 * MAX_CLIPPING_PLANES ) + 3 )

/* 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles */

#define MAX_CLIP_TRIANGLES  ( MAX_CLIP_VERTICES - 2 )

#endif /* driver.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\dditypes.h ===
/*
 * $Id: dditypes.h,v 1.28 1995/11/21 14:46:07 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __DDITYPES_H__
#define __DDITYPES_H__

#include "d3di.h"

#ifdef __psx__
typedef struct _RLDDIPSXUpdateFlags {;
    int 		update_color;
    int 		update_texture;
} RLDDIPSXUpdateFlags;
#endif


typedef struct _RLDDIDriverParams {
    int			width, height;	/* dimensions */
    int			depth;		/* pixel depth */
    unsigned long	red_mask;
    unsigned long	green_mask;
    unsigned long	blue_mask;
    int			aspectx, aspecty; /* aspect ratios */

    unsigned long	caps;		/* miscellaneous capabilities */
} RLDDIDriverParams;

typedef enum _RLDDIRenderParamType {
    RLDDIRenderParamDither,		/* enable dithering */
    RLDDIRenderParamGamma,		/* change gamma correction */
    RLDDIRenderParamPerspective		/* enable perspective correction */
} RLDDIRenderParamType;

#if 0
typedef struct _RLDDIRenderParams {
    int			dither;		/* TRUE to enable dithering */
    RLDDIValue		gamma;		/* gamma correction value */
    int			perspective;	/* TRUE for perspective correction */
} RLDDIRenderParams;
#endif

typedef struct _RLDDIMatrix {
    RLDDIValue		_11, _12, _13, _14;
    RLDDIValue		_21, _22, _23, _24;
    RLDDIValue		_31, _32, _33, _34;
    RLDDIValue		_41, _42, _43, _44;
} RLDDIMatrix;

typedef struct _RLDDIVector {
    RLDDIValue		x, y, z;
} RLDDIVector;

#if 0
/*
 * Format of CI colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |         color index          |   fraction    |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define CI_GET_ALPHA(ci)	((ci) >> 24)
#define CI_GET_INDEX(ci)	(((ci) >> 8) & 0xffff)
#define CI_GET_FRACTION(ci)	((ci) & 0xff)
#define CI_ROUND_INDEX(ci)	CI_GET_INDEX((ci) + 0x80)
#define CI_MASK_ALPHA(ci)	((ci) & 0xffffff)
#define CI_MAKE(a, i, f)	(((a) << 24) | ((i) << 8) | (f))

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGBA_GET_ALPHA(ci)	((ci) >> 24)
#define RGBA_GET_RED(ci)	(((ci) >> 16) & 0xff)
#define RGBA_GET_GREEN(ci)	(((ci) >> 8) & 0xff)
#define RGBA_GET_BLUE(ci)	((ci) & 0xff)
#define RGBA_SET_ALPHA(rgba, x)	(((x) << 24) | ((rgba) & 0x00ffffff))
#define RGBA_SET_RED(rgba, x)	(((x) << 16) | ((rgba) & 0xff00ffff))
#define RGBA_SET_GREEN(rgba, x)	(((x) << 8) | ((rgba) & 0xffff00ff))
#define RGBA_SET_BLUE(rgba, x)	(((x) << 0) | ((rgba) & 0xffffff00))
#define RGBA_MAKE(r, g, b, a)	(((a) << 24) | ((r) << 16) | ((g) << 8) | (b))

/*
 * Format of RGB colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    ignored    |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */
#define RGB_GET_RED(ci)		(((ci) >> 16) & 0xff)
#define RGB_GET_GREEN(ci)	(((ci) >> 8) & 0xff)
#define RGB_GET_BLUE(ci)	((ci) & 0xff)
#define RGB_SET_RED(rgb, x)	(((x) << 16) | ((rgb) & 0xff00ffff))
#define RGB_SET_GREEN(rgb, x)	(((x) << 8) | ((rgb) & 0xffff00ff))
#define RGB_SET_BLUE(rgb, x)	(((x) << 0) | ((rgb) & 0xffffff00))
#define RGB_MAKE(r, g, b)	(((r) << 16) | ((g) << 8) | (b))
#define RGBA_TO_RGB(rgba)	((rgba) & 0xffffff)
#define RGB_TO_RGBA(rgb)	((rgb) | 0xff000000)

#endif

/* XXX move into D3D */
typedef struct _RLDDIFogData {
    int			fog_enable;
    int			fog_mode;	/* make a  D3Dfog mode */
    unsigned long	fog_color;
    RLDDIValue		fog_start;
    RLDDIValue		fog_end;
    RLDDIValue		fog_density;
} RLDDIFogData;

typedef struct _RLDDIPixmap {
    int			width;		/* width in pixels */
    int			height;		/* height in pixels */
    int			depth;		/* bits per pixel */
    int			bytes_per_line;	/* bytes per scanline */
    short		free_pixels;	/* TRUE if we allocated pixels */
    short		vidmem;		/* surface is in vidmem */
    LPPALETTEENTRY	palette;	/* if !NULL, associated palette */
    int			palette_size;	/* number of valid palette entries */
    unsigned long	red_mask;	/* if palette==NULL, rgba masks */
    unsigned long	green_mask;
    unsigned long	blue_mask;
    unsigned long	alpha_mask;
    void RLFAR*		pixels;		/* the scanlines */
    LPDIRECTDRAWSURFACE	lpDDS;		/* underlying surface if relavent */
} RLDDIPixmap;

#define PIXMAP_LINE(pm, y)	(void RLFAR*)((char RLFAR*) (pm)->pixels \
					      + y * (pm)->bytes_per_line)

#define PIXMAP_POS(pm, x, y)	(void RLFAR*)((char RLFAR*)		\
					      PIXMAP_LINE(pm, y)	\
					      + (x) * (pm)->depth / 8)

typedef struct _RLDDISetTextureOpacityParams {
    D3DTEXTUREHANDLE	texture; 	/* texture to change */
    int			has_transparent; /* texture has a transparent color */
    unsigned long	transparent;	/* transparent color */
    RLImage*		opacity;	/* opacity map */
} RLDDISetTextureOpacityParams;

typedef RLDDIDriver* (*RLDDICreateDriverFunction)(int width, int height);
typedef struct _RLDDICreateDriverFunctions {
    RLDDICreateDriverFunction	transform;
    RLDDICreateDriverFunction	render;
    RLDDICreateDriverFunction	light;
} RLDDICreateDriverFunctions;

#endif /* dditypes.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\d3di.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3di.h
 *  Content:	Direct3D internal include file
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: d3di.h,v 1.26 1995/12/04 11:29:44 sjl Exp $
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05/11/95   stevela	Initial rev with this header.
 *   11/11/95	stevela	Light code changed.
 *   21/11/95   colinmc Made Direct3D aggregatable
 *                      (so it can be QI'd off DirectDraw).
 *   23/11/95   colinmc Made Direct3D textures and devices aggregatable
 *                      (QI'd off DirectDrawSurfaces).
 *   07/12/95	stevela Merged in Colin's changes.
 *   10/12/95	stevela	Removed AGGREGATE_D3D.
 *			Removed Validate macros from here. Now in d3dpr.h
 *   02/03/96   colinmc Minor build fix
 *   17/04/96	stevela Use ddraw.h externally and ddrawp.h internally
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DI_H
#define _D3DI_H

//@@BEGIN_MSINTERNAL
#include "ddrawp.h"
#if 0
//@@END_MSINTERNAL
#include "ddraw.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
#include "d3dp.h"

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#include "ddrawi.h"

#include "rlreg.h"
#include "lists.h"
#include "object.h"


/*
	INDEX_BATCH_SCALE is the constant which is used by DrawIndexedPrim
	to deterimine if the number of primitives being drawn is small 
	relative to the number of vertices being passed.  If it is then
	the prims are dereferenced in batches and sent to DrawPrim.
*/
#define INDEX_BATCH_SCALE	2

/*
typedef D3DCOLORMODEL D3DCOLORMODEL;

#define D3DCOLOR_RAMP D3DCOLOR_RAMP
#define D3DCOLOR_RGB D3DCOLOR_RGB
#define D3D_COLORMODEL D3D_COLORMODEL
*/
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

typedef DWORD D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;		/* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;		/* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;

/*
 * Internal version of lightdata and constants for flags
 */

#define D3DLIGHTI_ATT0_IS_NONZERO	(0x00010000)	
#define D3DLIGHTI_ATT1_IS_NONZERO	(0x00020000)
#define D3DLIGHTI_ATT2_IS_NONZERO	(0x00040000)
#define D3DLIGHTI_LINEAR_FALLOFF	(0x00080000)
#define D3DLIGHTI_UNIT_SCALE		(0x00100000)
#define D3DLIGHTI_LIGHT_AT_EYE		(0x00200000)

typedef struct _D3DI_LIGHT {
    D3DLIGHTTYPE	type;
	DWORD			version;	/* matches number on D3DLIGHT struct */
    BOOL			valid;
    D3DVALUE		red, green, blue, shade;
    D3DVECTOR		position;
    D3DVECTOR		model_position;
    D3DVECTOR		direction;
    D3DVECTOR		model_direction;
    D3DVECTOR		halfway;
	D3DVECTOR		model_eye;		/* direction from eye in model space */
	D3DVECTOR		model_scale;	/* model scale for proper range computations */
    D3DVALUE		range;
    D3DVALUE		range_squared;
    D3DVALUE		falloff;
    D3DVALUE		attenuation0;
    D3DVALUE		attenuation1;
    D3DVALUE		attenuation2;
    D3DVALUE		cos_theta_by_2;
    D3DVALUE		cos_phi_by_2;
	DWORD			flags;
} D3DI_LIGHT, *LPD3DI_LIGHT;

// @@BEGIN_MSINTERNAL
#if !defined(BUILD_RLAPI) && !defined(BUILD_DDDDK)
#ifndef BUILD_HEL
#ifdef BUILD_D3D_LAYER
#include "driver.h"
#endif

typedef struct IUnknownVtbl D3DUNKNOWNCALLBACKS, *LPD3DUNKNOWNCALLBACKS;
typedef struct ID3DObjectVtbl D3DOBJECTVTBL, *LPD3DOBJECTVTBL;
typedef struct IDirect3DVtbl DIRECT3DCALLBACKS, *LPDIRECT3DCALLBACKS;
typedef struct IDirect3D2Vtbl DIRECT3D2CALLBACKS, *LPDIRECT3D2CALLBACKS;
typedef struct IDirect3DDeviceVtbl DIRECT3DDEVICECALLBACKS, *LPDIRECT3DDEVICECALLBACKS;
typedef struct IDirect3DDevice2Vtbl DIRECT3DDEVICE2CALLBACKS, *LPDIRECT3DDEVICE2CALLBACKS;
typedef struct IDirect3DExecuteBufferVtbl DIRECT3DEXECUTEBUFFERCALLBACKS, *LPDIRECT3DEXECUTEBUFFERCALLBACKS;
typedef struct IDirect3DLightVtbl DIRECT3DLIGHTCALLBACKS, *LPDIRECT3DLIGHTCALLBACKS;
typedef struct IDirect3DMaterialVtbl DIRECT3DMATERIALCALLBACKS, *LPDIRECT3DMATERIALCALLBACKS;
typedef struct IDirect3DMaterial2Vtbl DIRECT3DMATERIAL2CALLBACKS, *LPDIRECT3DMATERIAL2CALLBACKS;
typedef struct IDirect3DTextureVtbl DIRECT3DTEXTURECALLBACKS, *LPDIRECT3DTEXTURECALLBACKS;
typedef struct IDirect3DTexture2Vtbl DIRECT3DTEXTURE2CALLBACKS, *LPDIRECT3DTEXTURE2CALLBACKS;
typedef struct IDirect3DViewport2Vtbl DIRECT3DVIEWPORT2CALLBACKS, *LPDIRECT3DVIEWPORT2CALLBACKS;

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DIRECT3DI *LPDIRECT3DI;
typedef struct _DIRECT3DDEVICEI *LPDIRECT3DDEVICEI;
typedef struct _DIRECT3DEXECUTEBUFFERI *LPDIRECT3DEXECUTEBUFFERI;
typedef struct _DIRECT3DLIGHTI *LPDIRECT3DLIGHTI;
typedef struct _DIRECT3DMATERIALI *LPDIRECT3DMATERIALI;
typedef struct _DIRECT3DTEXTUREI *LPDIRECT3DTEXTUREI;
typedef struct _DIRECT3DVIEWPORTI *LPDIRECT3DVIEWPORTI;

/*
 * If we have an aggregate Direct3D we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. None of this would be necessary
 * in C++
 */
typedef struct _DIRECT3DUNKNOWNI
{
    LPD3DUNKNOWNCALLBACKS       lpVtbl;
    LPDIRECT3DI                lpObj;
} DIRECT3DUNKNOWNI;
typedef struct _DIRECT3DUNKNOWNI *LPDIRECT3DUNKNOWNI;

typedef struct _DIRECT3DOLDI
{
	LPDIRECT3DCALLBACKS lpVtbl;
	LPDIRECT3DI lpObj;
} DIRECT3DOLDI;
typedef struct _DIRECT3DOLDI *LPDIRECT3DOLDI;

/*
 * Internal version of Direct3D object; it has data after the vtable
 */
typedef struct _DIRECT3DI
{
    /*** Object Interface ***/
    LPDIRECT3D2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count object */

    /*** Object Relations ***/
    /* Devices */
    int				numDevs;/* Number of devices */
    LIST_ROOT(_devices, _DIRECT3DDEVICEI) devices;
    					/* Associated IDirect3DDevices */

    /* Viewports */
    int				numViewports; /* Number of viewports */
    LIST_ROOT(_viewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Created IDirect3DViewports */
					
    /* Lights */
    int				numLights; /* Number of lights */
    LIST_ROOT(_lights, _DIRECT3DLIGHTI) lights;
    					/* Created IDirect3DLights */

    /* Materials */
    int				numMaterials; /* Number of materials */
    LIST_ROOT(_materials, _DIRECT3DMATERIALI) materials;
    					/* Created IDirect3DMaterials */

    /*** Object Data ***/
    unsigned long		v_next;	/* id of next viewport to be created */
    RLDDIRegistry*		lpReg;	/* Registry */

    /*
     * DirectDraw Interface
     */
    LPDDRAWI_DIRECTDRAW_INT	lpDDInt;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DUNKNOWNI            lpThisIUnknown;   /* Our IUnknown interface */
	DIRECT3DOLDI				lpThisIDirect3D;   /* Our IDirect3D interface */

    DWORD                       dwVersion;      /* 1 for legacy D3D, 2 for D3D2 */
} DIRECT3DI;

/*
 * If we have an aggreate Direct3DDevice we need a structure to
 * represent an interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DDEVICEUNKNOWNI
{
    LPDIRECT3DDEVICE2CALLBACKS   lpVtbl;
    LPDIRECT3DDEVICEI           lpObj;
} DIRECT3DDEVICEUNKNOWNI;
typedef struct _DIRECT3DDEVICEUNKNOWNI *LPDIRECT3DDEVICEUNKNOWNI;

typedef struct _DIRECT3DDEVICEOLDI
{
    LPDIRECT3DDEVICECALLBACKS   lpVtbl;
    LPDIRECT3DDEVICEI           lpObj;
} DIRECT3DDEVICEOLDI;
typedef struct _DIRECT3DDEVICEOLDI *LPDIRECT3DDEVICEOLDI;

/*
 * Internal version of Direct3DDevice object; it has data after the vtable
 */

#include "d3dhal.h"

typedef RLDDIDriver*  (*RLDDIDDrawCreateDriverFn)(
					LPDDRAWI_DIRECTDRAW_INT lpDDInt,
					LPDIRECTDRAWSURFACE lpDDS,
					LPDIRECTDRAWSURFACE lpZ,
					LPDIRECTDRAWPALETTE lpPal,
					LPDIRECT3DDEVICEI);

typedef HRESULT (*RLDDIGetCapsFn)(LPD3DDEVICEDESC*, LPD3DDEVICEDESC*);
typedef void (*RLDDIInitFn)(RLDDIMallocFn, RLDDIReallocFn, RLDDIFreeFn, RLDDIRaiseFn, RLDDIValue**, int, int);
typedef void (*RLDDIPushDriverFn)(RLDDIDriverStack*, RLDDIDriver*);
typedef void (*RLDDIPopDriverFn)(RLDDIDriverStack*);

struct _RLDDIGenRasDriver;
typedef struct _RLDDIGenRasDriver* LPRLDDIGENRASDRIVER;
struct _RLDDIDDrawDriver;
typedef struct _RLDDIDDrawDriver* LPRLDDIDDRAWDRIVER;

struct _RLDDITransformDriver;
typedef struct _RLDDITransformDriver* LPRLDDITRANSFORMDRIVER;

typedef HRESULT (*PFNLOCKTEXTURE)(LPRLDDIGENRASDRIVER driver);
typedef void (*PFNUNLOCKTEXTURE)(LPRLDDIGENRASDRIVER driver);
typedef int (*PFNSETFILLPARAMS)(LPRLDDIGENRASDRIVER driver, D3DSTATE* in_params,
			  int count);
typedef HRESULT (*PFNREALLOCALIGNED)(void** p_inout, size_t size);
typedef HRESULT (*PFNMALLOCALIGNED)(void** p_inout, size_t size);
typedef HRESULT (*PFNFREEALIGNED)(void* p_inout);
typedef HRESULT (*PFNDRVSETRENDERTARGET)(LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE, 
										 LPDIRECTDRAWPALETTE, LPDIRECT3DDEVICEI);
typedef HRESULT (*PFNDOFLUSHBEGINEND)(LPDIRECT3DDEVICE2, DWORD);
typedef	HRESULT (*PFNDRAWPRIMITIVES)(LPDIRECT3DDEVICEI, LPD3DTLVERTEX, LPVOID, LPD3DINSTRUCTION, DWORD);


typedef struct _D3DI_TEXTUREBLOCK
{
    LIST_MEMBER(_D3DI_TEXTUREBLOCK)	list;
    					/* Next block in IDirect3DTexture */
    LIST_MEMBER(_D3DI_TEXTUREBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DTEXTUREI			lpD3DTextureI;
    D3DTEXTUREHANDLE			hTex;
    					/* texture handle */
} D3DI_TEXTUREBLOCK;
typedef struct _D3DI_TEXTUREBLOCK *LPD3DI_TEXTUREBLOCK;

typedef struct _D3DI_MATERIALBLOCK
{
    LIST_MEMBER(_D3DI_MATERIALBLOCK)	list;
    					/* Next block in IDirect3DMaterial */
    LIST_MEMBER(_D3DI_MATERIALBLOCK)	devList;
    					/* Next block in IDirect3DDevice */
    LPDIRECT3DDEVICEI			lpD3DDeviceI;
    LPDIRECT3DMATERIALI			lpD3DMaterialI;
    D3DMATERIALHANDLE			hMat;
    					/* material handle */
} D3DI_MATERIALBLOCK;
typedef struct _D3DI_MATERIALBLOCK *LPD3DI_MATERIALBLOCK;

#define D3D_RSTATEBUF_SIZE 128
#define D3D_MAX_RSTATES 96 /* Last render state ID + 1 */
#define D3D_MAX_MMX_VERTICES 1024

extern DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
extern DWORD dwHWBufferSize, dwHWMaxTris;
extern DWORD dwHWFewVertices;

typedef struct _D3DHAL_DRAWPRIMCOUNTS *LPD3DHAL_DRAWPRIMCOUNTS;

// Legacy HAL batching is done with these structs.
typedef struct _D3DI_HWCOUNTS {
    WORD wNumStateChanges;      // Number of state changes batched
    WORD wNumVertices;          // Number of vertices in tri list
    WORD wNumTriangles;         // Number of triangles in tri list
} D3DI_HWCOUNTS, *LPD3DI_HWCOUNTS;

typedef struct _DIRECT3DDEVICEI
{
    /*** Object Interface ***/
    LPDIRECT3DDEVICE2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* parent */
    LIST_MEMBER(_DIRECT3DDEVICEI)list;	/* Next device IDirect3D */

    /* Textures */
    LIST_ROOT(_textures, _D3DI_TEXTUREBLOCK) texBlocks;
    					/* Ref to created IDirect3DTextures */

    /* Execute buffers */
    LIST_ROOT(_buffers, _DIRECT3DEXECUTEBUFFERI) buffers;
    					/* Created IDirect3DExecuteBuffers */

    /* Viewports */
    int				numViewports;
    CIRCLE_QUEUE_ROOT(_dviewports, _DIRECT3DVIEWPORTI) viewports;
    					/* Associated IDirect3DViewports */
    LPDIRECT3DVIEWPORT2 lpCurrentViewport;

    /* Materials */
    LIST_ROOT(_dmmaterials, _D3DI_MATERIALBLOCK) matBlocks;
    					/* Ref to associated IDirect3DMaterials */

    /*** Object Data ***/
    /* Private interfaces */
    LPD3DOBJECTVTBL		lpClassVtbl; /* Private Vtbl */
    LPD3DOBJECTVTBL		lpObjVtbl; /* Private Vtbl */

    LPD3DHAL_CALLBACKS		lpD3DHALCallbacks; /* HW specific */
    LPD3DHAL_GLOBALDRIVERDATA	lpD3DHALGlobalDriverData; /* HW specific */

    /* Viewports */
    unsigned long		v_id;	/* ID of last viewport rendered */

    /* Lights */
    int				numLights;
    					/* This indicates the maximum number
					   of lights that have been set in
					   the device. */

    /* Device characteristics */
    int				age;
    int				width;
    int				height;
    int				depth;
    unsigned long		red_mask, green_mask, blue_mask;

    int				dither;
    int				ramp_size; /* SW specific */
    D3DCOLORMODEL		color_model;
    int				wireframe_options;
    D3DTEXTUREFILTER		texture_quality;
    D3DVALUE			gamma;
    unsigned char		gamma_table[256];
    int				aspectx, aspecty;
    D3DVALUE			perspective_tolerance;

    /* Library information */
#ifdef WIN32
    HINSTANCE		hDrvDll;
    char		dllname[MAXPATH];
    char		base[256];
#endif
#ifdef SHLIB
    void*		so;
#endif

    /* Are we in a scene? */
    BOOL		bInScene;

    /* Our Device type */
    GUID		guid;

    /* GetCaps function from the library */
    RLDDIGetCapsFn	GetCapsFn;

    /* Functions required to build driver */
    RLDDIInitFn		RLDDIInit;
    RLDDIPushDriverFn	RLDDIPushDriver;
    RLDDIPopDriverFn	RLDDIPopDriver;
    RLDDIDDrawCreateDriverFn	RLDDIDDrawCreateDriver;

    /* Device description */
    D3DDEVICEDESC	d3dHWDevDesc;
    D3DDEVICEDESC	d3dHELDevDesc;

    /* Driver stack */
    RLDDIDriverStack*	stack;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DDEVICEUNKNOWNI      lpThisIUnknown;   /* Our IUnknown interface */
    DIRECT3DDEVICEOLDI			lpThisID3DDev;   /* Our IDirect3DDevice interface */

    LPD3DHAL_CALLBACKS2         lpD3DHALCallbacks2; /* HW specific */

	/*
	 * Renderstate cache for DrawPrimitive
	 */
	WORD wRStateBufLevel;
        D3DSTATE renStateBuf[D3D_RSTATEBUF_SIZE];

	/* Pointers to drivers used by DrawPrimitive */
	LPRLDDIGENRASDRIVER rasDriver; /* SW specific */
	LPRLDDITRANSFORMDRIVER xfmDriver; /* Assumed to be NULL for HW */
	LPRLDDIDDRAWDRIVER drawDriver; /* Assumed to be NULL for HW */

	/*
	 * Pointers to functions used by DrawPrim&Begin/End
	 */

	PFNLOCKTEXTURE pfnLockTexture; /* SW specific */
	PFNUNLOCKTEXTURE pfnUnlockTexture; /* SW specific */
	PFNSETFILLPARAMS pfnSetFillParams; /* SW specific */
	PFNREALLOCALIGNED pfnReallocAligned; /* SW specific */
	PFNDRVSETRENDERTARGET pfnDrvSetRenderTarget; /* SW specific */
	HRESULT (*pfnFlushStates)(struct _DIRECT3DDEVICEI*);
    PFNDOFLUSHBEGINEND pfnDoFlushBeginEnd;
	PFNDRAWPRIMITIVES pfnDrawPrimitives;

    /* Are we between Begin/End? */
    BOOL				bInBegin;
    D3DVERTEXTYPE		vtVertexType;
    D3DPRIMITIVETYPE	ptPrimitiveType;
	CRITICAL_SECTION	BeginEndCSect;

	// max number of vertices
    #define BEGIN_DATA_BLOCK_SIZE   256

    LPVOID	lpvVertexBatch;
	WORD	*lpIndexBatch;

    // lpvVertexData is non-NULL if we are InBegin and indexed.
    LPVOID	lpvVertexData;
    DWORD	dwNumVertices;
	DWORD	dwMaxVertexCount;	// current number of vertices there is space for
    WORD	*lpVertexIndices;
    DWORD	dwNumIndices;
	DWORD	dwMaxIndexCount;	// current number of indices there is space for

    DWORD	dwFlags;
    WORD	wFlushed;

    /*
     * DrawPrimitives batching
     */


        // Buffer to put DrawPrimitives stuff into
        // Used for both legacy and DrawPrimitive HALs
	 WORD *lpwDPBuffer; 
	 WORD *lpwDPBufferAlloced;

    /* Legacy HALs */
        // pointer to current prim counts struct
        LPD3DHAL_DRAWPRIMCOUNTS lpDPPrimCounts;

        // Buffer of counts structures that keep track of the
        // number of render states and vertices buffered
        LPD3DI_HWCOUNTS lpHWCounts;

        // Buffer of triangle structures.
        LPD3DTRIANGLE lpHWTris;

        // Buffer of interleaved render states and primitives.
        LPD3DTLVERTEX lpHWVertices;

        // Byte offset into lpHWVertices. This gets incremented
        // by 8 when a render state is batched and by 32*dwNumVertices
        // when a primitive is batched.
        DWORD dwHWOffset;

        // Max value of dwHWOffset. Used to decide whether to flush.
        DWORD dwHWMaxOffset;

        // Index into lpHWTris.
        DWORD dwHWTriIndex;

        // Number of counts structures used so far. This actually
        // gives the number of primitives batched and the index of
        // the counts structure to batch render states into.
        DWORD dwHWNumCounts;

    /* DrawPrimitive-aware HALs */

        // Byte offset into buffer (we are currently
        // using the device's wTriIndex)
        DWORD dwDPOffset;

        // Maximum offset. If dwDPOffset exceeds this, it is
        // time to flush.
        DWORD dwDPMaxOffset;

	WORD *wTriIndex;

	// buffers for TL and H vertices
	LPD3DTLVERTEX	lpTLVbuf;
	LPD3DHVERTEX	lpHVbuf;
	DWORD			dwVbufSize;

    LPD3DHAL_D3DEXTENDEDCAPS lpD3DExtendedCaps;  /* HW specific */

} DIRECT3DDEVICEI;

/*
 * Internal version of Direct3DExecuteBuffer object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DEXECUTEBUFFERI
{
    /*** Object Interface ***/
    LPDIRECT3DEXECUTEBUFFERCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Parent */
    LIST_MEMBER(_DIRECT3DEXECUTEBUFFERI)list;
    					/* Next buffer in IDirect3D */

    /*** Object Data ***/
    DWORD			pid;	/* Process locking execute buffer */
    D3DEXECUTEBUFFERDESC	debDesc;
    					/* Description of the buffer */
    D3DEXECUTEDATA		exData;	/* Execute Data */
    BOOL			locked;	/* Is the buffer locked */

    D3DI_BUFFERHANDLE		hBuf;
    					/* Execute buffer handle */
} DIRECT3DEXECUTEBUFFERI;

/*
 * Internal version of Direct3DLight object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DLIGHTI
{
    /*** Object Interface ***/
    LPDIRECT3DLIGHTCALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* Parent */
    LIST_MEMBER(_DIRECT3DLIGHTI)list;
    					/* Next light in IDirect3D */

    LPDIRECT3DVIEWPORTI		lpD3DViewportI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(_DIRECT3DLIGHTI)light_list;
    					/* Next light in IDirect3DViewport */

    /*** Object Data ***/
    D3DLIGHT2			dlLight;/* Data describing light */
    D3DI_LIGHT			diLightData;
    					/* Internal representation of light */
} DIRECT3DLIGHTI;

typedef struct _DIRECT3DMATERIALOLDI
{
	LPDIRECT3DMATERIALCALLBACKS lpVtbl;
	LPDIRECT3DMATERIALI lpObj;
} DIRECT3DMATERIALOLDI, *LPDIRECT3DMATERIALOLDI;

/*
 * Internal version of Direct3DMaterial object;
 * it has data after the vtable
 */
typedef struct _DIRECT3DMATERIALI
{
    /*** Object Interface ***/
    LPDIRECT3DMATERIAL2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations ***/
    LPDIRECT3DI                lpDirect3DI; /* Parent */
	DIRECT3DMATERIALOLDI lpThisID3DMat; /* Our IDirect3DMaterial interface */
    LIST_MEMBER(_DIRECT3DMATERIALI)list;
    					/* Next MATERIAL in IDirect3D */

    LIST_ROOT(_mblocks, _D3DI_MATERIALBLOCK)blocks;
    					/* devices we're associated with */

    /*** Object Data ***/
    D3DMATERIAL			dmMaterial; /* Data describing material */
    BOOL			bRes;	/* Is this material reserved in the driver */
} DIRECT3DMATERIALI;

/*
 * If we have an aggreate Direct3DTexture we need a structure
 * to represent an unknown interface distinct from the underlying
 * object. This is that structure. 
 */
typedef struct _DIRECT3DTEXTUREUNKNOWNI
{
    LPDIRECT3DTEXTURECALLBACKS  lpVtbl;
    LPDIRECT3DTEXTUREI          lpObj;
} DIRECT3DTEXTUREUNKNOWNI;
typedef struct _DIRECT3DTEXTUREUNKNOWNI *LPDIRECT3DTEXTUREUNKNOWNI;

typedef struct _DIRECT3DTEXTUREOLDI
{
	LPDIRECT3DTEXTURECALLBACKS lpVtbl;
	LPDIRECT3DTEXTUREI lpObj;
} DIRECT3DTEXTUREOLDI, *LPDIRECT3DTEXTUREOLDI;

/*
 * Internal version of Direct3DTexture object; it has data after the vtable
 */
typedef struct _DIRECT3DTEXTUREI
{
    /*** Object Interface ***/
    LPDIRECT3DTEXTURE2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */


    /*** Object Relations ***/
    LIST_ROOT(_blocks, _D3DI_TEXTUREBLOCK) blocks;
    					/* Devices we're associated with */

    /*** Object Data ***/
    LPDIRECTDRAWSURFACE		lpDDS;

    /*
     * The special IUnknown interface for the aggregate that does
     * not punt to the parent object.
     */
    LPUNKNOWN                   lpOwningIUnknown; /* The owning IUnknown    */
    DIRECT3DTEXTUREUNKNOWNI     lpThisIUnknown;   /* Our IUnknown interface */
    DIRECT3DTEXTUREOLDI     lpThisID3DTex;   /* Our IDirect3DTexture interface */
    BOOL			bIsPalettized;

} DIRECT3DTEXTUREI;

/*
 * Internal version of Direct3DViewport object; it has data after the vtable
 */
typedef struct _DIRECT3DVIEWPORTI
{
    /*** Object Interface ***/
    LPDIRECT3DVIEWPORT2CALLBACKS	lpVtbl;	/* Pointer to callbacks */
    int				refCnt;	/* Reference count */

    /*** Object Relations */
    LPDIRECT3DI                 lpDirect3DI; /* Parent */
    LIST_MEMBER(_DIRECT3DVIEWPORTI)list;
    					/* Next viewport in IDirect3D */

    LPDIRECT3DDEVICEI		lpD3DDeviceI; /* Guardian */
    CIRCLE_QUEUE_MEMBER(_DIRECT3DVIEWPORTI)vw_list;
    					/* Next viewport in IDirect3DDevice */
					
    /* Lights */
    int				numLights;
    CIRCLE_QUEUE_ROOT(_dlights, _DIRECT3DLIGHTI) lights;
    					/* Associated IDirect3DLights */

    /*** Object Data ***/
    unsigned long		v_id;	/* Id for this viewport */
    D3DVIEWPORT2			v_data;
    BOOL                v_data_is_set;

    BOOL			have_background;
    D3DMATERIALHANDLE		background;
    					/* Background material */
    BOOL			have_depth;
    LPDIRECTDRAWSURFACE		depth;	/* Background depth */
    
    BOOL			bLightsChanged;
    					/* Have the lights changed since they
					   were last collected? */
    DWORD			clrCount; /* Number of rects allocated */
    LPD3DRECT			clrRects; /* Rects used for clearing */
} DIRECT3DVIEWPORTI;

/*
 * Picking stuff.
 */
typedef struct _D3DI_PICKDATA {
    D3DI_EXECUTEDATA*	exe;
    D3DPICKRECORD*	records;
    int			pick_count;
    D3DRECT		pick;
} D3DI_PICKDATA, *LPD3DI_PICKDATA;

/*
 * Direct3D memory allocation
 */

/*
 * Register a set of functions to be used in place of malloc, realloc
 * and free for memory allocation.  The functions D3DMalloc, D3DRealloc
 * and D3DFree will use these functions.  The default is to use the
 * ANSI C library routines malloc, realloc and free.
 */
typedef LPVOID (*D3DMALLOCFUNCTION)(size_t);
typedef LPVOID (*D3DREALLOCFUNCTION)(LPVOID, size_t);
typedef VOID (*D3DFREEFUNCTION)(LPVOID);

/*
 * Allocate size bytes of memory and return a pointer to it in *p_return.
 * Returns D3DERR_BADALLOC with *p_return unchanged if the allocation fails.
 */
HRESULT D3DAPI 		D3DMalloc(LPVOID* p_return, size_t size);

/*
 * Change the size of an allocated block of memory.  A pointer to the
 * block is passed in in *p_inout.  If *p_inout is NULL then a new
 * block is allocated.  If the reallocation is successful, *p_inout is
 * changed to point to the new block.  If the allocation fails,
 * *p_inout is unchanged and D3DERR_BADALLOC is returned.
 */
HRESULT D3DAPI 		D3DRealloc(LPVOID* p_inout, size_t size);

/*
 * Free a block of memory previously allocated with D3DMalloc or
 * D3DRealloc.
 */
VOID D3DAPI		D3DFree(LPVOID p);

/*
 * Used for raising errors from the driver.
 */
HRESULT D3DAPI D3DRaise(HRESULT);

/*
 * Convert RLDDI error codes to D3D error codes
 */
#define RLDDITOD3DERR(_errcode) (RLDDIToD3DErrors[_errcode])
extern HRESULT RLDDIToD3DErrors[];

/*
 * maths
 */
#if 1 /* defined(STACK_CALL) && defined(__WATCOMC__) */
D3DVALUE D3DIPow(D3DVALUE, D3DVALUE);
#else
#define D3DIPow(v,p)	DTOVAL(pow(VALTOD(v), VALTOD(p)))
#endif

/*
 * Light utils
 */
void D3DI_DeviceMarkLightEnd(LPDIRECT3DDEVICEI, int);
void D3DI_UpdateLightInternal(LPDIRECT3DLIGHTI);
void D3DI_VectorNormalise12(LPD3DVECTOR v);
D3DTEXTUREHANDLE D3DI_FindTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI);
void D3DI_SetTextureHandle(LPDIRECT3DTEXTUREI, LPDIRECT3DDEVICEI, D3DTEXTUREHANDLE);
void D3DI_RemoveTextureBlock(LPD3DI_TEXTUREBLOCK);
void D3DI_RemoveMaterialBlock(LPD3DI_MATERIALBLOCK);

extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS);

#ifdef BUILD_D3D_LAYER
extern RLDDIValue* RLDDIFInvSqrtTable;
#endif

#ifdef __cplusplus
};
#endif

#endif /* BUILD_HEL */
#endif /* !BUILD_RLAPI */
// @@END_MSINTERNAL

#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\i386src.inc ===
i386_SOURCES = \
$O\zramp8f.asm $O\zramp8ft.asm $O\zramp8g.asm $O\zramp8gt.asm $O\zramp8gtg.asm \
$O\zramp8ftg.asm $O\zrmfp8.asm $O\zrmfpg8.asm $O\zrmgp8.asm $O\zrmgpg8.asm \
$O\gramp8f.asm $O\gramp8ft.asm $O\gramp8g.asm $O\gramp8gt.asm $O\gramp8gtg.asm \
$O\gramp8ftg.asm $O\grmfp8.asm $O\grmfpg8.asm $O\grmgp8.asm $O\grmgpg8.asm \
$O\zramp16f.asm $O\zramp16ft.asm $O\zramp16g.asm $O\zramp16gt.asm $O\zramp16gtg.asm \
$O\zramp16ftg.asm $O\zrmfp16.asm $O\zrmfpg16.asm $O\zrmgp16.asm $O\zrmgpg16.asm \
$O\gramp16f.asm $O\gramp16ft.asm $O\gramp16g.asm $O\gramp16gt.asm $O\gramp16gtg.asm \
$O\gramp16ftg.asm $O\grmfp16.asm $O\grmfpg16.asm $O\grmgp16.asm $O\grmgpg16.asm

NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

        ifdef INTEL
func    macro   name
        public  name
name:
        endm
        else
func    macro   name
        public  _&name
name:                   ;lay down both labels so I have one I know will
_&name:                 ;always be available for asm to call.
        endm
        endif

push_all        macro
        irp     z,<edi,esi,edx,ecx,ebx,eax>
        push    z
        endm
        endm

pop_all         macro
        irp     z,<eax,ebx,ecx,edx,esi,edi>
        pop     z
        endm
        endm

push_m  macro   list
        irp     z,<list>
        push    z
        endm
        endm

pop_m   macro   list
        irp     z,<list>
        pop     z
        endm
        endm

byte_eax        equ     al
byte_ebx        equ     bl
byte_ecx        equ     cl
byte_edx        equ     dl

word_eax        equ     ax
word_ebx        equ     bx
word_ecx        equ     cx
word_edx        equ     dx
word_edi        equ     di
word_esi        equ     si
word_ebp        equ     bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8    macro   divisor
        local   divide, nodivide
        cdq
        xor     edx, eax
        sar     edx, 017H
        cmp     divisor, edx
        jg      divide
        sar     eax, 1fH
        xor     eax, 7fffffffH
        jmp     nodivide
divide:
        mov     edx, eax
        sar     edx, 018h
        shl     eax, 008h
        idiv    divisor
nodivide:
        endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16   macro   divisor
        local   divide, nodivide
        cdq
        xor     edx, eax
        sar     edx, 0fH
        cmp     divisor, edx
        jg      divide
        sar     eax, 1fH
        xor     eax, 7fffffffH
        jmp     nodivide
divide:
        mov     edx, eax
        sar     edx, 010h
        shl     eax, 010h
        idiv    divisor
nodivide:
        endm

ES_PREFIX       macro
    ifndef      NT
        db      26h
    endif
        endm

beginargs macro
        align   4
stack   =       4       ;return address
vars    =       0       ;no vars yet
args    =       0       ;no args yet
        endm

endargs macro
        sub     esp, vars
        endm

savereg macro   arg
        push    arg
stack   =       stack + 4
        endm

saveregs macro  arglist
        irp     z,<arglist>
        savereg z
        endm
        endm

defvar  macro   name
name    =       vars
vars    =       vars + 4
stack   =       stack + 4
        endm

defvars macro   arglist
        irp     z,<arglist>
        defvar  z
        endm
        endm

defarg  macro   name
name    =       stack + args
args    =       args + 4
        endm

defargs macro   arglist
        irp     z,<arglist>
        defarg  z
        endm
        endm

regarg  macro   name
        ifdef   STACK_CALL
        defarg  name
        else
        defvar  name
        endif
        endm

regargs macro   arglist
        irp     z,<arglist>
        regarg  z
        endm
        endm

return  macro
        ifdef   STACK_CALL
        ret
        else
        ret     args
        endif
        endm

    ifdef       BCC             ;{

beginproc macro prefix,GF,Te,Tr,name    ;{
        align   4
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the beginproc macro"
        endif
        if DEPTH eq 0
prefix&name     equ     _&prefix&GF&Tr&Te&name
        else
          if DEPTH eq 8
prefix&name     equ     _&prefix&8&GF&Tr&Te&name
          else
prefix&name     equ     _&prefix&16&GF&Tr&Te&name
          endif
        endif
        public  prefix&name
prefix&name proc
        endm                    ;}

    else                        ;} ifndef BCC {

beginproc macro prefix,GF,Z,Te,Tr,name  ;{
        align   4
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the beginproc macro"
        endif
        ifdef   STACK_CALL      ;{
        if DEPTH eq 0
prefix&name     equ     prefix&GF&Z&Tr&Te&name
        else
            if DEPTH eq 8
prefix&name     equ     prefix&8_&GF&Z&Tr&Te&name
            else
prefix&name     equ     prefix&16_&GF&Z&Tr&Te&name
            endif
        endif
        else                    ;} else {
        if DEPTH eq 0
prefix&name     equ     prefix&GF&Tr&Te&name&_
        else
            if DEPTH eq 8
prefix&name     equ     prefix&8&GF&Tr&Te&name&_
            else
prefix&name     equ     prefix&16&GF&Tr&Te&name&_
            endif
        endif
        endif                   ;}
        public  prefix&name
prefix&name proc
        endm                    ;}
    endif               ;}

    ifdef       BCC     ;{
endproc macro prefix,name       ;{
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the endproc macro"
        endif
        if      DEPTH eq 8
_&prefix&name endp
        else
_&prefix&name endp
        endif
        endm                    ;}

    else                ;} ifndef BCC {

endproc macro prefix,GF,Z,Te,Tr,name    ;{
        ifndef  DEPTH
        display "DEPTH must be defined for modules using the endproc macro"
        endif
        ifdef   STACK_CALL
            if  DEPTH eq 0
prefix&GF&Tr&Te&name endp
            else
            if  DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
            else
prefix&16_&GF&Z&Tr&Te&name endp
            endif
            endif
        else
            if  DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
            else
            if  DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
            else
prefix&16&GF&Tr&Te&name&_ endp
            endif
            endif
        endif
        endm                    ;}

    endif               ;}

; ************************************************************************
itoval  macro   reg
        shl     reg,10h
        endm

FDUP    macro
        fld     st(0)
        endm

FDROP   macro
        fstp    st(0)
        endm

FRECIPROCAL     macro
        fld1
        fdivrp  st(1),st
        endm

FCOMXX macro   v
      fcom    v
      fnstsw  ax
      sahf
      endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\osdep.h ===
/*
 * $Id: osdep.h,v 1.6 1995/07/21 12:46:14 dfr Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */


/* Check that the programmer gives at least one useable definition */
#define NO_MACHINE


#ifdef WIN32

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
/*
#define RLINLINE   __inline
*/
#define RLINLINE  
#undef NO_MACHINE
#define DEFAULT_GAMMA   DTOVAL(1.4)

#endif /* WIN32 */

#ifdef __psx__

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
#define RLINLINE   
#define FIXED_POINT_API
#undef NO_MACHINE

#endif /* PSX */


#if defined(DOS) || defined(__WINDOWS_386__)

#define MAXPATH    256
#define PATHSEP    ';'
#define FILESEP    '\\'
#define RLINLINE   
#define DEFAULT_GAMMA   DTOVAL(1.4)
#undef NO_MACHINE

#endif /* DOS */


#ifdef MAC

#define MAXPATH 1024
#define FILESEP ':'
#define PATHSEP '\0'
#define BIG_ENDIAN
#define DONT_UNROLL
#undef NO_MACHINE
#define RLINLINE inline

#endif /* MAC */

#ifdef POWERMAC

#define MAXPATH 1024
#define FILESEP ':'
#define PATHSEP '\0'
#define BIG_ENDIAN
#define DONT_UNROLL
#undef NO_MACHINE
#define RLINLINE inline

#endif /* POWERMAC */


#ifdef __FreeBSD__

#define MAXPATH    1024
#define PATHSEP    ':'
#define FILESEP    '/'
#define RLINLINE   
#define DEFAULT_GAMMA   DTOVAL(1.4)
#undef NO_MACHINE

#endif /* __FreeBSD__ */


#if defined(sun) || defined(sgi)

#define MAXPATH    1024
#define PATHSEP    ':'
#define FILESEP    '/'
#define RLINLINE   
#define DEFAULT_GAMMA   DTOVAL(2.2)
#define BIG_ENDIAN
#undef NO_MACHINE

#endif /* sun */


#ifdef NO_MACHINE
#error There appears to be no machine defined...
#endif

#ifdef FIXED_POINT_API

#ifdef USE_FLOAT
#define APITOVAL(x)     FXTOVAL(x)
#define VALTOAPI(x)     VALTOFX(x)
#else
#define APITOVAL(x)     (x)
#define VALTOAPI(x)     (x)
#endif

#else

#ifdef USE_FLOAT
#define APITOVAL(x)     (x)
#define VALTOAPI(x)     (x)
#else
#define APITOVAL(x)     DTOVAL(x)
#define VALTOAPI(x)     VALTOD(x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>

#include "lists.h"
#include "rampold.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\makefile.inc ===
$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h

##############################################################################
# 8
##############################################################################

$(GENTGT)\zramp8f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zramp8ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

##########

$(GENTGT)\gramp8f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\gramp8ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmfp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmfpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmgp8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmgpg8.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=8 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@


##############################################################################
# 16
##############################################################################

$(GENTGT)\zramp16f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zramp16ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmfpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\zrmgpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=1 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

##########

$(GENTGT)\gramp16f.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16ft.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16g.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=0 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16gt.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16gtg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\gramp16ftg.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=1 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmfp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmfpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=0 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@

$(GENTGT)\grmgp16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=0 ..\rmfillf5.mas > $@

$(GENTGT)\grmgpg16.asm: ..\rmfillf5.mas $(RAST_STD_M4)
    m4 -I..;$(RASTROOT)\inc -Dd_z=0 -Dd_depth=16 -Dd_gouraud=1 -Dd_tex=2 -Dd_trans=1 ..\rmfillf5.mas > $@


##############################################################################
# apparently never compiled or tested 24 or 32 bit versions of fast fill
# routines under DX5, don't do it now!
##############################################################################
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\fltval.h ===
/*
 * $Id: fltval.h,v 1.7 1995/12/01 18:07:12 dave Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef __RLFLOAT__
#define __RLFLOAT__

/*
 * Floating point versions of fixed point math.
 */
typedef float RLDDIValue;
typedef int RLDDIFixed;

#define VAL_MAX		((RLDDIValue) 1e30)
#define VAL_MIN		((RLDDIValue) (-1e30))

/*
 * Convert a value to fixed point at given precision.
 */
#define VALTOFXP(d,prec) ((RLDDIFixed)SAFE_FLOAT_TO_INT((d) * (double)(1 << (prec))))
extern double RLDDIConvertIEEE[];
// The macro form can cause problems when used multiple times in
// a function invocation due to its use of a global
// Fortunately, inline functions work in our compiler
__inline RLDDIFixed QVALTOFXP(double d, int prec)
{
    double tmp = d+RLDDIConvertIEEE[prec];
    return *(RLDDIFixed *)&tmp;
}

/*
 * Convert from fixed point to value.
 */
#define FXPTOVAL(f,prec) ((RLDDIValue)(((double)(f)) / (double)(1 << (prec))))

/*
 * Convert from integer to fixed point.
 */
#define ITOFXP(i,prec)	((i) << (prec))

/*
 * Convert from fixed point to integer, truncating.
 */
#define FXPTOI(f,prec)	((int)((f) >> (prec)))

/*
 * Convert from fixed point to integer, rounding.
 */
#define FXPROUND(f,prec) ((int)(((f) + (1 << ((prec) - 1))) >> (prec)))

/*
 * Convert from fixed point to nearest integer greater or equal to f.
 */
#define FXPCEIL(f,prec) ((int)(((f) + (1 << (prec)) - 1) >> (prec)))

/*
 * Convert a double to fixed point at given precision.
 */
#define DTOVALP(d,prec)	((RLDDIValue) (d))

/*
 * Convert from fixed point to double.
 */
#define VALPTOD(f,prec)	((double) (f))

/*
 * Convert from integer to fixed point.
 */
#define ITOVALP(i,prec)	((RLDDIValue)(i))

/*
 * Convert from fixed point to integer, truncating.
 */
#define VALPTOI(f,prec)	((int)(f))

/*
 * Convert from fixed point to integer, rounding.
 */
#define VALPROUND(f,prec) ((int)((f) + 0.5))

/*
 * Convert between fixed point precisions.
 */
#define VALPTOVALP(f,from,to) (f)

/*
 * Increase the precision of a value.
 */
#define INCPREC(f,amount)	(f)

/*
 * Decrease the precision of a value.
 */
#define DECPREC(f,amount)	(f)

#define RLDDIFMul8(a, b)		((a) * (b))

#define RLDDIFMul12(a, b)		((a) * (b))

#define RLDDIFMul16(a, b)		((a) * (b))

#define RLDDIFMul24(a, b)		((a) * (b))

#define RLDDIFInvert12(a)		(1.0f / (a))

#define RLDDIFInvert16(a)		(1.0f / (a))

#define RLDDIFInvert24(a)		(1.0f / (a))

#define RLDDIFMulDiv(a, b, c)	((a) * (b) / (c))

#define RLDDIFDiv24(a, b)		((a) / (b))

#define RLDDIFDiv16(a, b)		((a) / (b))

#define RLDDIFDiv12(a, b)		((a) / (b))

#define RLDDIFDiv8(a, b)		((a) / (b))

/*
 * RLDDIFDiv8, checking for overflow.
 */
#define RLDDICheckDiv8(a, b)      ((a) / (b))

/*
 * RLDDIFDiv16, checking for overflow.
 */
#define RLDDICheckDiv16(a, b)	((a) / (b))

#define RLDDIGetZStep(zl, zr, zm, h3, h1) \
	(((zr - zm) * h3 - (zl - zm) * h1) / denom)

#if defined(i386)
#include <limits.h>
#define SAFE_FLOAT_TO_INT(f)	((f) > LONG_MAX				      \
				 ? LONG_MAX				      \
				 : (f) < LONG_MIN			      \
				 ? LONG_MIN				      \
				 : (RLDDIFixed)(f))
#else
#define SAFE_FLOAT_TO_INT(f)	((RLDDIFixed)(f))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\offsets.asm ===
include offs_acp.inc

RLDDIRampDriver_map     equ     RCTX_pRampMap
RLDDIGenRasDriver_fill_params   equ     RCTX_pFillParams
RLDDIGenRasDriver_pm    equ     RCTX_pSurfaceBits
RLDDIGenRasDriver_zb    equ     RCTX_pZBits
RLDDIGenRasDriver_texture       equ     RCTX_pTexture
RLDDIGenRasFillParams_wrap_u    equ     FPMS_dwWrapU
RLDDIGenRasFillParams_wrap_v    equ     FPMS_dwWrapV
RLDDIGenRasFillParams_culling_ccw       equ     FPMS_dwCullCCW
RLDDIGenRasFillParams_culling_cw        equ     FPMS_dwCullCW

RLDDITexture_transparent      equ     STEX_TransparentColor
RLDDITexture_u_shift    equ     STEX_iShiftU
RLDDITexture_v_shift    equ     STEX_iShiftV
D3DINSTRUCTION_wCount   equ     02h
D3DINSTRUCTION_bSize    equ     01h
D3DTLVERTEX_sx  equ     00h
D3DTLVERTEX_sy  equ     04h
D3DTLVERTEX_sz  equ     08h
D3DTLVERTEX_rhw       equ     0ch
D3DTLVERTEX_color       equ     010h
D3DTLVERTEX_specular    equ     014h
D3DTLVERTEX_tu  equ     018h
D3DTLVERTEX_tv  equ     01ch
D3DTRIANGLE_v1  equ     00h
D3DTRIANGLE_v2  equ     02h
D3DTRIANGLE_v3  equ     04h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\rampold.h ===
//----------------------------------------------------------------------------
//
// rampold.h
//
// Structures which define the interface to the old ramp routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RAMPOLD_H_
#define _RAMPOLD_H_


#define ROB_DEPTH_NUM 2
#define ROB_RENDER_Z_NUM 2
#define ROB_RENDER_GOURAUD_NUM 2
#define ROB_RENDER_TEXTURE_NUM 3
#define ROB_RENDER_TRANS_NUM 2

typedef struct tagRAMPOLDBEADS
{
    PFNRAMPOLD pfnRampOld[ROB_DEPTH_NUM][ROB_RENDER_Z_NUM][ROB_RENDER_GOURAUD_NUM][ROB_RENDER_TEXTURE_NUM][ROB_RENDER_TRANS_NUM];
} RAMPOLDBEADS, *PRAMPOLDBEADS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\rampold.cpp ===
//----------------------------------------------------------------------------
//
// rampold.cpp
//
// Entry points for DX3/DX5 ramp assembly routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

#ifdef __cplusplus
  extern "C" {
#endif

void __cdecl RLDDIR8_FTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR8_GTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR8_FZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_FZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR8_GZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR8_GZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_FTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_GTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_FZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_FZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_GZTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZGTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);
void __cdecl RLDDIR16_GZGPTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

void __cdecl RLDDIR16_GZTTriangle(PD3DI_RASTCTX drv, D3DINSTRUCTION* ins, D3DTLVERTEX* lpTLVert, D3DTRIANGLE* tri);

#ifdef __cplusplus
  }
#endif

//----------------------------------------------------------------------------
//
// RampOldTri
//
// Entry point for DX3/DX5 ramp assembly routines.
//
//----------------------------------------------------------------------------

HRESULT RampOldTri(PD3DI_RASTCTX pCtx,
                   LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;

    hr = D3D_OK;

    D3DINSTRUCTION ins;
    ins.bOpcode = D3DOP_TRIANGLE;
    ins.bSize = sizeof(D3DTRIANGLE);
    ins.wCount = 1;

    D3DTRIANGLE tri;
    tri.v1 = 0;
    tri.v2 = 1;
    tri.v3 = 2;

    D3DTLVERTEX TLVert[3];
    TLVert[0] = *pV0;
    TLVert[1] = *pV1;
    TLVert[2] = *pV2;

    // Lego Island fix
    // 0x3f7ffe00 == 1 - 2/0xffff or 2 Z units from the maximum Z.  Integer math is faster
    // and doesn't cause FP lib linker issues with the assembly.
    INT32* pZ;
    pZ = (INT32*)&TLVert[0].sz;
    *pZ = (*pZ > 0x3f7ffe00) ? (0x3f7ffe00) : (*pZ);
    pZ = (INT32*)&TLVert[1].sz;
    *pZ = (*pZ > 0x3f7ffe00) ? (0x3f7ffe00) : (*pZ);
    pZ = (INT32*)&TLVert[2].sz;
    *pZ = (*pZ > 0x3f7ffe00) ? (0x3f7ffe00) : (*pZ);

    pCtx->pFillParams = &pCtx->FillParams;
    pCtx->pFillParams->dwWrapU = pCtx->pdwWrap[0] & D3DWRAP_U;
    pCtx->pFillParams->dwWrapV = pCtx->pdwWrap[0] & D3DWRAP_V;
    pCtx->pFillParams->dwCullCCW = (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW);
    pCtx->pFillParams->dwCullCW =  (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CW);

    pCtx->pfnRampOld(pCtx, &ins, TLVert, &tri);

    return hr;
}

// resurrect this if DX5 ramp assembly must be called with a triangle list for performance
// reasons.
#if 0
HRESULT RampOldTriList(PD3DI_RASTCTX pCtx, DWORD dwStride, D3DTLVERTEX* pVtx, WORD cPrims, D3DTRIANGLE* pTri)
{
    HRESULT hr;

    hr = D3D_OK;

    D3DINSTRUCTION ins;
    ins.bOpcode = D3DOP_TRIANGLE;
    ins.bSize = sizeof(D3DTRIANGLE);
    ins.wCount = cPrims;

    DDASSERT(dwStride == sizeof(D3DTLVERTEX));

    pCtx->pFillParams = &pCtx->FillParams;
    pCtx->pFillParams->dwWrapU = pCtx->pdwWrap[0] & D3DWRAP_U;
    pCtx->pFillParams->dwWrapV = pCtx->pdwWrap[0] & D3DWRAP_V;
    pCtx->pFillParams->dwCullCCW = (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW);
    pCtx->pFillParams->dwCullCW =  (pCtx->pdwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CW);

    pCtx->pfnRampOld(pCtx, &ins, pVtx, pTri);

    return hr;
}
#endif // RampOldTriList

//
//  [ROB_DEPTH_NUM]
//  [ROB_RENDER_Z_NUM]
//  [ROB_RENDER_GOURAUD_NUM]
//  [ROB_RENDER_TEXTURE_NUM][ROB_RENDER_TRANS_NUM]
RAMPOLDBEADS g_RampOld_BeadTbl =
{
    RLDDIR8_FTriangle, NULL,    RLDDIR8_FTTriangle, RLDDIR8_FGTTriangle,    RLDDIR8_FPTriangle, RLDDIR8_FGPTriangle,
    RLDDIR8_GTriangle, NULL,    RLDDIR8_GTTriangle, RLDDIR8_GGTTriangle,    RLDDIR8_GPTriangle, RLDDIR8_GGPTriangle,

    RLDDIR8_FZTriangle, NULL,   RLDDIR8_FZTTriangle, RLDDIR8_FZGTTriangle,  RLDDIR8_FZPTriangle, RLDDIR8_FZGPTriangle,
    RLDDIR8_GZTriangle, NULL,   RLDDIR8_GZTTriangle, RLDDIR8_GZGTTriangle,  RLDDIR8_GZPTriangle, RLDDIR8_GZGPTriangle,

    RLDDIR16_FTriangle, NULL,   RLDDIR16_FTTriangle, RLDDIR16_FGTTriangle,  RLDDIR16_FPTriangle, RLDDIR16_FGPTriangle,
    RLDDIR16_GTriangle, NULL,   RLDDIR16_GTTriangle, RLDDIR16_GGTTriangle,  RLDDIR16_GPTriangle, RLDDIR16_GGPTriangle,

    RLDDIR16_FZTriangle, NULL,  RLDDIR16_FZTTriangle, RLDDIR16_FZGTTriangle,RLDDIR16_FZPTriangle, RLDDIR16_FZGPTriangle,
    RLDDIR16_GZTriangle, NULL,  RLDDIR16_GZTTriangle, RLDDIR16_GZGTTriangle,RLDDIR16_GZPTriangle, RLDDIR16_GZGPTriangle,

};

#else // _X86_

HRESULT RampOldTri(PD3DI_RASTCTX pCtx,
                   LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    return D3D_OK;
}

// since all ramp beads are NULL, will never call RampOldTri
RAMPOLDBEADS g_RampOld_BeadTbl = { NULL };


#endif // _X86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\sources.inc ===
TARGETNAME=d3dramp
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\$(TARGETNAME).def

INCLUDES = ..;$(INCLUDES);$(O)

SOURCES = \
        ..\dmath.c \
        ..\rampold.cpp \
        ..\d3dramp.rc

NTTARGETFILE0 = \
        $(O)\offs_acp.$(ASM_INCLUDE_SUFFIX)


PRECOMPILED_INCLUDE = ..\pch.cpp

BINPLACE_PLACEFILE = ..\rampold.dir
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampold\rlreg.h ===
/*
 * $Id: rlreg.h,v 1.1 1995/10/10 11:18:16 sjl Exp $
 *
 * Copyright (c) RenderMorphics Ltd. 1993, 1994
 * Version 2.0
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * RenderMorphics Ltd.
 *
 */

#ifndef _RLREG_H_
#define _RLREG_H_

#include <objbase.h>

#define RESPATH    "Software\\Microsoft\\Direct3D\\Drivers"
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

typedef struct _RLDDIRegDriver {
    char name[256];
    char base[256];
    char description[512];
    GUID guid;
} RLDDIRegDriver;

typedef struct _RLDDIRegistry {
    char defaultDriver[256];
    int numDrivers;
    int onlySoftwareDrivers;
    RLDDIRegDriver* drivers;
} RLDDIRegistry;

extern HRESULT RLDDIBuildRegistry(RLDDIRegistry** lplpReg, BOOL bEnumMMXDevice);
extern HRESULT RLDDIGetDriverName(REFIID lpGuid, char** lpBase, BOOL bEnumMMXDevice); /* get name from registry */

#endif _RLREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\makefile.inc ===
$(GENTGT)\rbeadtbl.cpp: ..\rbeadtbl.mcp $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)

$(GENTGT)\rloop.cpp: ..\rloop.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\ramppix.mh ..\rtexread.mh $(RAST_STD_M4)

$(GENTGT)\rrampgen.cpp: ..\rrampgen.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\ramppix.mh $(RAST_STD_M4)

$(GENTGT)\rrampcpy.cpp: ..\rrampcpy.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\ramppix.mh $(RAST_STD_M4)

$(GENTGT)\rtexread.cpp: ..\rtexread.mcp $(RASTROOT)\inc\rampbead.mh ..\rtexaddr.mh ..\rtexread.mh $(RAST_STD_M4)

$(GENTGT)\rloop_mh.h: ..\rloop_mh.mh $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)

$(GENTGT)\rtrd_mh.h: ..\rtrd_mh.mh $(RASTROOT)\inc\rampbead.mh ..\rtexread.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h

$(GENTGT)\raloop.asm: ..\raloop.mas $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\rmono.h ===
//----------------------------------------------------------------------------
//
// rmono.h
//
// Declarations of all monolithic ramp routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RMONO_H_
#define _RMONO_H_

void Ramp_Mono_Modulate(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                        PD3DI_RASTSPAN pS);
void Ramp_Mono_Copy_8(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                    PD3DI_RASTSPAN pS);
void Ramp_Mono_Copy_16(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP,
                    PD3DI_RASTSPAN pS);

#endif // #ifndef _RMONO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <limits.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3di.hpp>
#include <haldrv.hpp>

#include <dpf.h>

#include <rast.h>
#include "rspnutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\i386src.inc ===
i386_SOURCES = $O\raloop.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES)\
    $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\rspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "rloop_mh.h"

// #define SPAN_HISTOGRAM

#ifdef SPAN_HISTOGRAM
UINT32 uSpanHist[16];
#endif

//-----------------------------------------------------------------------------
//
// RenderSpans_Any
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT Ramp_RenderSpans_Any(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    if (pCtx->pTexture[0])
    {
        pCtx->pTexture[0]->pRampmap = pCtx->pTexRampMap;
    }
    
    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
#ifdef SPAN_HISTOGRAM
            INT iBucket;

            for (iBucket = 0;
                 iBucket < sizeof(uSpanHist)/sizeof(uSpanHist[0]);
                 iBucket++)
            {
                if (pS->uPix <= (1 << iBucket))
                {
                    uSpanHist[iBucket]++;
                    break;
                }
            }
#endif
            
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\rspnutil.h ===
//----------------------------------------------------------------------------
//
// rspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

extern UINT16 g_uRampDitherTable[16];

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}

#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\rampspan\sources.inc ===
TARGETNAME = rrmpspan
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

#386_OPTIMIZATION = /Oxt /G5

SOURCES = \
        $O\rbeadtbl.cpp\
        $O\rloop.cpp\
        $O\rrampcpy.cpp\
        $O\rrampgen.cpp\
        ..\rspnpars.cpp\
        $O\rtexread.cpp

NTTARGETFILE0 = \
        $O\rbeadtbl.cpp\
        $O\rloop.cpp\
        $O\rloop_mh.h\
        $O\rrampcpy.cpp\
        $O\rrampgen.cpp\
        $O\rtexread.cpp\
        $O\rtrd_mh.h

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\cppsrc.inc ===
O_FILES = $O\attrscpp.cpp $O\tstpcpp.cpp
$(TARGET_DIRECTORY)_SOURCES = $(O_FILES) ..\walkcpp.cpp
NTTARGETFILE0 = $(NTTARGETFILE0) $(O_FILES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\line.cpp ===
//----------------------------------------------------------------------------
//
// line.cpp
//
// Line processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.
//
//----------------------------------------------------------------------------

static inline BOOL LinePatternStateMachine(WORD wRepeatFactor, WORD wLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    if (wRepeatFactor == 0)
    {
        return TRUE;
    }
    WORD wBit = (wLinePattern >> wPatterni) & 1;
    if (++wRepeati >= wRepeatFactor)
    {
        wRepeati = 0;
        wPatterni = (wPatterni+1) & 0xf;
    }
    return (BOOL)wBit;
}

#define CLAMP_COLOR(fVal, uVal) \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \
    else                        \
    {                           \
        if (uVal > 0xffff)      \
        {                       \
            uVal = 0xffff;      \
        }                       \
    }                           \

#define CLAMP_Z(fVal, uVal)     \
    if (FLOAT_LTZ(fVal))        \
    {                           \
        uVal = 0;               \
    }                           \

//----------------------------------------------------------------------------
//
// ClampPixel
//
// Clamp color, specular and z(if any) of a pixel. Right now, it's done for 
// first and last pixel of a line only.
//
//----------------------------------------------------------------------------
inline void
ClampPixel(PATTRSET pAttrs, PD3DI_RASTSPAN pSpan)
{
    CLAMP_COLOR(pAttrs->fB, pSpan->uB);
    CLAMP_COLOR(pAttrs->fG, pSpan->uG);
    CLAMP_COLOR(pAttrs->fR, pSpan->uR);
    CLAMP_COLOR(pAttrs->fA, pSpan->uA);
    CLAMP_COLOR(pAttrs->fBS, pSpan->uBS);
    CLAMP_COLOR(pAttrs->fGS, pSpan->uGS);
    CLAMP_COLOR(pAttrs->fRS, pSpan->uRS);
    CLAMP_Z(pAttrs->fZ, pSpan->uZ);
}

//----------------------------------------------------------------------------
//
// WalkLinePattern
//
// Walks a line and generates the pixels touched according to the pattern.
// If wRepeatFactor >= 1, we are patterning, otherwise, we are not
//
//----------------------------------------------------------------------------

HRESULT
WalkLinePattern(PSETUPCTX pStpCtx, WORD wRepeatFactor, WORD wLinePattern)
{
    HRESULT hr;
    UINT uSpansAvail;
    PD3DI_RASTSPAN pSpan;
    WORD wRepeati = 0;
    WORD wPatterni = 0;
    BOOL bFirst = TRUE;

    RSASSERT(pStpCtx->cLinePix > 0);

    hr = D3D_OK;
    uSpansAvail = 0;

    RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);
#ifdef PWL_FOG
    pStpCtx->uPwlFlags = PWL_NO_NEXT_FOG;
#endif

    for (;;)
    {
        if (pStpCtx->iX >= pStpCtx->pCtx->Clip.left &&
            pStpCtx->iX < pStpCtx->pCtx->Clip.right &&
            pStpCtx->iY >= pStpCtx->pCtx->Clip.top &&
            pStpCtx->iY < pStpCtx->pCtx->Clip.bottom)
        {
            if (LinePatternStateMachine(wRepeatFactor, wLinePattern, wRepeati, wPatterni))
            {
                if (uSpansAvail == 0)
                {
                    uSpansAvail = pStpCtx->cLinePix;
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                pSpan->uPix = 1;
                pSpan->uX = (UINT16)pStpCtx->iX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
                // Clamp first/last pixel
                if (bFirst || pStpCtx->cLinePix == 1)
                {
                    bFirst = FALSE;
                    ClampPixel(&pStpCtx->Attr, pSpan);
                }
            }
        }

        if (--pStpCtx->cLinePix == 0)
        {
            break;
        }

#ifdef VERBOSE_LINES
        RSDPF(("  %4d,%4d: %10d %11d => ",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac, pStpCtx->iLineFrac + pStpCtx->iDLineFrac));
#endif

        pStpCtx->iLineFrac += pStpCtx->iDLineFrac;
        if (pStpCtx->iLineFrac < 0)
        {
            pStpCtx->iLineFrac &= 0x7fffffff;

            pStpCtx->iX += pStpCtx->iDXCY;
            pStpCtx->iY += pStpCtx->iDYCY;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrCY.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrCY.ipZ;
        }
        else
        {
            pStpCtx->iX += pStpCtx->iDXNC;
            pStpCtx->iY += pStpCtx->iDYNC;

            pStpCtx->DAttrDMajor.ipSurface = pStpCtx->DAttrNC.ipSurface;
            pStpCtx->DAttrDMajor.ipZ = pStpCtx->DAttrNC.ipZ;
        }

#ifdef VERBOSE_LINES
        RSDPFM((DBG_MASK_FORCE | DBG_MASK_NO_PREFIX, "%4d,%4d: %10d\n",
               pStpCtx->iX, pStpCtx->iY,
               pStpCtx->iLineFrac));
#endif

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDMajor, pStpCtx);
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Line
//
// Provides a line for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Line(LPD3DTLVERTEX pV0,
                    LPD3DTLVERTEX pV1,
                    LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-line flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | LNF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_LINES, "Line\n"));
    RSDPFM((RSM_LINES, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_LINES, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    if (LineSetup(pV0, pV1))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // Line walking only generates single-pixel spans so
        // the prim deltas are unused.  Therefore, line spans
        // are simply added to whatever primitive happens to
        // be sitting in the buffer.

        hr = AppendPrim();
        if (hr != D3D_OK)
        {
            return hr;
        }

        union
        {
            D3DLINEPATTERN LPat;
            DWORD dwLPat;
        } LinePat;
        LinePat.dwLPat = m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LINEPATTERN];
        hr = WalkLinePattern(&m_StpCtx, LinePat.LPat.wRepeatFactor, LinePat.LPat.wLinePattern);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\i386src.inc ===
i386_SOURCES = $O\attrsx86.asm $O\tstpx86.asm $O\walkx86.asm
NTTARGETFILE0 = $(NTTARGETFILE0) $(i386_SOURCES) \
        $O\offs_acp.$(ASM_INCLUDE_SUFFIX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\makefile.inc ===
$(GENTGT)\attrs_mh.h: ..\attrs_mh.mh $(RAST_STD_M4)

$(GENTGT)\tstp_mh.h: ..\tstp_mh.mh $(RAST_STD_M4)

$(GENTGT)\walk_mh.h: ..\walk_mh.mh $(RAST_STD_M4)

$(GENTGT)\offs_acp.$(ASM_INCLUDE_SUFFIX): ..\offs_acp.acp \
        ..\..\..\inc\span.h ..\..\inc\stp_base.h

$(GENTGT)\attrsx86.asm: ..\attrsx86.mas ..\attrsx86.mh $(RAST_STD_M4)

$(GENTGT)\attrscpp.cpp: ..\attrscpp.mcp $(RAST_STD_M4)

$(GENTGT)\tstpx86.asm: ..\tstpx86.mas $(RAST_STD_M4)

$(GENTGT)\tstpcpp.cpp: ..\tstpcpp.mcp $(RAST_STD_M4)

$(GENTGT)\walkx86.asm: ..\walkx86.mas ..\attrsx86.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <ddrawp.h>

#include <d3dp.h>
#include <d3dhal.h>

#include <rast.h>
#include "setup.hpp"
#include "attrs_mh.h"
#include "tstp_mh.h"
#include "walk_mh.h"
#include "rsdbg.hpp"

#include <dpf.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\attrs.cpp ===
//----------------------------------------------------------------------------
//
// attrs.cpp
//
// Cross-platform attribute handling functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// AddFloatAttrs_Any
//
// Adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
//
//----------------------------------------------------------------------------

void FASTCALL
AddFloatAttrs_Any(PATTRSET pAttr, PATTRSET pDelta, PSETUPCTX pStpCtx)
{
    pAttr->pSurface += pDelta->ipSurface;
    pAttr->pZ += pDelta->ipZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pAttr->fZ += pDelta->fZ;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        pAttr->fOoW += pDelta->fOoW;

        pAttr->fUoW1 += pDelta->fUoW1;
        pAttr->fVoW1 += pDelta->fVoW1;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        pAttr->fUoW2 += pDelta->fUoW2;
        pAttr->fVoW2 += pDelta->fVoW2;
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB;
        pAttr->fG += pDelta->fG;
        pAttr->fR += pDelta->fR;
        pAttr->fA += pDelta->fA;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx;
        pAttr->fDIdxA += pDelta->fDIdxA;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS;
        pAttr->fGS += pDelta->fGS;
        pAttr->fRS += pDelta->fRS;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog;
    }
}

//----------------------------------------------------------------------------
//
// AddScaledFloatAttrs_Any_Either
//
// Scales and adds a set of attribute deltas to an ATTRSET.
// Handles any set of attributes via USED flags.
// Uses PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
AddScaledFloatAttrs_Any_Either(PATTRSET pAttr, PATTRSET pDelta,
                               PSETUPCTX pStpCtx, INT iScale)
{
    FLOAT fScale = (FLOAT)iScale;

    pAttr->pSurface += pDelta->ipSurface * iScale;
    pAttr->pZ += pDelta->ipZ * iScale;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
#ifdef PWL_FOG
        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pAttr->fZ = pStpCtx->fNextZ;
        }
        else
#endif
        {
            pAttr->fZ += pDelta->fZ * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            pAttr->fOoW = pStpCtx->fNextOoW;
            pAttr->fUoW1 = pStpCtx->fNextUoW1;
            pAttr->fVoW1 = pStpCtx->fNextVoW1;
        }
        else
        {
            pAttr->fOoW += pDelta->fOoW * fScale;
            pAttr->fUoW1 += pDelta->fUoW1 * fScale;
            pAttr->fVoW1 += pDelta->fVoW1 * fScale;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        pAttr->fUoW2 += pDelta->fUoW2 * fScale;
        pAttr->fVoW2 += pDelta->fVoW2 * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pAttr->fB += pDelta->fB * fScale;
        pAttr->fG += pDelta->fG * fScale;
        pAttr->fR += pDelta->fR * fScale;
        pAttr->fA += pDelta->fA * fScale;
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pAttr->fDIdx += pDelta->fDIdx * fScale;
        pAttr->fDIdxA += pDelta->fDIdxA * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pAttr->fBS += pDelta->fBS * fScale;
        pAttr->fGS += pDelta->fGS * fScale;
        pAttr->fRS += pDelta->fRS * fScale;
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pAttr->fFog += pDelta->fFog * fScale;
    }
}

//----------------------------------------------------------------------------
//
// FillSpanFloatAttrs_Any_Either
//
// Fills in a span structure with the given attributes.
// Handles any set of attributes via USED flags.
// Uses and updates PWL support.
//
//----------------------------------------------------------------------------

void FASTCALL
FillSpanFloatAttrs_Any_Either(PATTRSET pAttr, PD3DI_RASTSPAN pSpan,
                              PSETUPCTX pStpCtx, INT cPix)
{
    FLOAT fPix = (FLOAT)cPix;
    pSpan->pSurface = pAttr->pSurface;
    pSpan->pZ = pAttr->pZ;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        pSpan->uZ = FTOI(pAttr->fZ);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;

        if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
        {
            fW = pStpCtx->fNextW;
        }
        else if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pAttr->fOoW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = OOW_SCALE / pAttr->fOoW;
            }
        }
        else
        {
            fW = g_fOne;
        }

        pSpan->iW = FTOI(fW * W_SCALE);

        if (pStpCtx->uFlags & PRIMSF_LOD_USED)
        {
            // Mipmapping is enabled so compute texture LOD.
            // The span code can do linear LOD interpolation
            // so that we can do piecewise-linear approximations
            // instead of true per-pixel LOD.  In order to make this
            // work we need to compute the next LOD and a delta
            // value.  All of these values can be reused if this
            // loop goes around so keep them available for the next
            // iteration and set a flag to indicate that they've
            // been computed.

            if (pStpCtx->uPwlFlags & PWL_NEXT_LOD)
            {
                pSpan->iLOD = (INT16)pStpCtx->iNextLOD;
            }
            else
            {
                pSpan->iLOD =
                    (INT16)ComputeLOD(pStpCtx->pCtx,
                               (pAttr->fUoW1 * OO_TEX_SCALE) * fW,
                               (pAttr->fVoW1 * OO_TEX_SCALE) * fW,
                               fW,
                               (pStpCtx->DAttrDX.fUoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fVoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                               (pStpCtx->DAttrDY.fUoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fVoW1 * OO_TEX_SCALE),
                               (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            }

            if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
            {
                pStpCtx->fNextOoW = pAttr->fOoW + pStpCtx->DAttrDX.fOoW * fPix;

                if (FLOAT_EQZ(pStpCtx->fNextOoW))
                {
                    fW = g_fZero;
                }
                else
                {
                    fW = OOW_SCALE / pStpCtx->fNextOoW;
                }
            }
            else
            {
                pStpCtx->fNextOoW = OOW_SCALE;
                fW = g_fOne;
            }

            pStpCtx->fNextW = fW;
            pStpCtx->fNextUoW1 = pAttr->fUoW1 + pStpCtx->DAttrDX.fUoW1 * fPix;
            pStpCtx->fNextVoW1 = pAttr->fVoW1 + pStpCtx->DAttrDX.fVoW1 * fPix;
            pStpCtx->iNextLOD =
                ComputeLOD(pStpCtx->pCtx,
                           (pStpCtx->fNextUoW1 * OO_TEX_SCALE) * fW,
                           (pStpCtx->fNextVoW1 * OO_TEX_SCALE) * fW,
                           fW,
                           (pStpCtx->DAttrDX.fUoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fVoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDX.fOoW * OO_OOW_SCALE),
                           (pStpCtx->DAttrDY.fUoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fVoW1 * OO_TEX_SCALE),
                           (pStpCtx->DAttrDY.fOoW * OO_OOW_SCALE));
            pStpCtx->uPwlFlags |= PWL_NEXT_LOD;

            pSpan->iDLOD = (INT16)
                FTOI((FLOAT)(pStpCtx->iNextLOD - pSpan->iLOD) / fPix);
        }
        else
        {
            pSpan->iLOD = 0;
            pSpan->iDLOD = 0;
        }

        pSpan->iOoW = FTOI(pAttr->fOoW);

        pSpan->iUoW1 = FTOI(pAttr->fUoW1);
        pSpan->iVoW1 = FTOI(pAttr->fVoW1);
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        pSpan->iUoW2 = FTOI(pAttr->fUoW2);
        pSpan->iVoW2 = FTOI(pAttr->fVoW2);
    }

    if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (INT16)FTOI(pAttr->fB);
        pSpan->uG = (INT16)FTOI(pAttr->fG);
        pSpan->uR = (INT16)FTOI(pAttr->fR);
        pSpan->uA = (INT16)FTOI(pAttr->fA);
    }
    else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = FTOI(pAttr->fDIdx);
        pSpan->iIdxA = FTOI(pAttr->fDIdxA);
    }

    if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (INT16)FTOI(pAttr->fBS);
        pSpan->uGS = (INT16)FTOI(pAttr->fGS);
        pSpan->uRS = (INT16)FTOI(pAttr->fRS);
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        pSpan->uFog = (INT16)FTOI(pAttr->fFog);
        pSpan->iDFog = (INT16)(pStpCtx->iDLocalFogDX);
    }
#ifdef PWL_FOG
    else if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
    {
        FLOAT fOoZScale;

        // The span code doesn't have direct global fog support.
        // It's faked by setup doing PWL approximations here
        // similarly to how LOD is handled.

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fOoZScale = OO_Z16_SCALE;
        }
        else
        {
            fOoZScale = OO_Z32_SCALE;
        }

        if (pStpCtx->uPwlFlags & PWL_NEXT_FOG)
        {
            pSpan->uFog = pStpCtx->uNextFog;
        }
        else
        {
            pSpan->uFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                          pAttr->fZ * fOoZScale);
        }

        if ((pStpCtx->uPwlFlags & PWL_NO_NEXT_FOG) == 0)
        {
            pStpCtx->fNextZ = pAttr->fZ + pStpCtx->DAttrDX.fZ * fPix;
            pStpCtx->uNextFog = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                                pStpCtx->fNextZ * fOoZScale);
            pStpCtx->uPwlFlags |= PWL_NEXT_FOG;

            pSpan->iDFog =
                FTOI((FLOAT)((INT)pStpCtx->uNextFog -
                             (INT)pSpan->uFog) / fPix);
        }
        else
        {
            pSpan->iDFog = 0;
        }
    }
#endif
}

//
// Tables of attribute handlers.
// Indexing is with the low four PRIMSF_*_USED bits.
//

// Attribute adders.
PFN_ADDATTRS g_pfnAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFloatAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFloatAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFloatAttrs_Z_Diff_Tex1,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFloatAttrs_Z_Diff_Spec_Tex1,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFloatAttrs_Z_Tex1_Tex2,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_ADDATTRS g_pfnAddFixedAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -2 -1 -S -D */
    AddFixedAttrs_Z_Diff,                               /* 1: -2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 2: -2 -1 +S -D */
    AddFixedAttrs_Z_Diff_Spec,                          /* 3: -2 -1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 4: -2 +1 -S -D */
    AddFixedAttrs_Z_Diff_Tex1,                          /* 5: -2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 6: -2 +1 +S -D */
    AddFixedAttrs_Z_Diff_Spec_Tex1,                     /* 7: -2 +1 +S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 8: +2 -1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* 9: +2 -1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* A: +2 -1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* B: +2 -1 +S +D */
    AddFixedAttrs_Z_Tex1_Tex2,                          /* C: +2 +1 -S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* D: +2 +1 -S +D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* E: +2 +1 +S -D */
    (PFN_ADDATTRS)DebugBreakFn,                         /* F: +2 +1 +S +D */
};
#endif

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -2 -1 -S -D */
    AddScaledFloatAttrs_Z_Diff,                         /* 1: -2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 2: -2 -1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec,                    /* 3: -2 -1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 4: -2 +1 -S -D */
    AddScaledFloatAttrs_Z_Diff_Tex1,                    /* 5: -2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 6: -2 +1 +S -D */
    AddScaledFloatAttrs_Z_Diff_Spec_Tex1,               /* 7: -2 +1 +S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 8: +2 -1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 9: +2 -1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* A: +2 -1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* B: +2 -1 +S +D */
    AddScaledFloatAttrs_Z_Tex1_Tex2,                    /* C: +2 +1 -S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* D: +2 +1 -S +D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* E: +2 +1 +S -D */
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* F: +2 +1 +S +D */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFloatAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFloatAttrs_Z_Diff_Tex1,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFloatAttrs_Z_Diff_Spec_Tex1,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFloatAttrs_Z_Tex1_Tex2,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_FILLSPANATTRS g_pfnFillSpanFixedAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    FillSpanFixedAttrs_Z_Diff,                          /* 1: -2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec,                     /* 3: -2 -1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    FillSpanFixedAttrs_Z_Diff_Tex1,                     /* 5: -2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    FillSpanFixedAttrs_Z_Diff_Spec_Tex1,                /* 7: -2 +1 +S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    FillSpanFixedAttrs_Z_Tex1_Tex2,                     /* C: +2 +1 -S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Float-to-fixed attribute converters.
#ifdef STEP_FIXED
PFN_FLOATATTRSTOFIXED g_pfnFloatAttrsToFixedTable[] =
{
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 0: -2 -1 -S -D */
    FloatAttrsToFixed_Z_Diff,                           /* 1: -2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 2: -2 -1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec,                      /* 3: -2 -1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 4: -2 +1 -S -D */
    FloatAttrsToFixed_Z_Diff_Tex1,                      /* 5: -2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 6: -2 +1 +S -D */
    FloatAttrsToFixed_Z_Diff_Spec_Tex1,                 /* 7: -2 +1 +S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 8: +2 -1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* 9: +2 -1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* A: +2 -1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* B: +2 -1 +S +D */
    FloatAttrsToFixed_Z_Tex1_Tex2,                      /* C: +2 +1 -S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* D: +2 +1 -S +D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* E: +2 +1 +S -D */
    (PFN_FLOATATTRSTOFIXED)DebugBreakFn,                /* F: +2 +1 +S +D */
};
#endif

//
// Tables of ramp mode attribute handlers.
// Indexing is with PRIMSF_TEX1_USED and PRIMSF_DIDX_USED.
//

// Attribute adders.
PFN_ADDATTRS g_pfnRampAddFloatAttrsTable[] =
{
    (PFN_ADDATTRS)DebugBreakFn,                         /* 0: -I -1 */
    AddFloatAttrs_Z_Tex1,                               /* 1: -I +1 */
    AddFloatAttrs_Z_DIdx,                               /* 2: +I -1 */
    AddFloatAttrs_Z_DIdx_Tex1,                          /* 3: +I +1 */
};

// Scaled attribute adders without PWL support.
PFN_ADDSCALEDATTRS g_pfnRampAddScaledFloatAttrsTable[] =
{
    (PFN_ADDSCALEDATTRS)DebugBreakFn,                   /* 0: -I -1 */
    AddScaledFloatAttrs_Z_Tex1,                         /* 1: -I +1 */
    AddScaledFloatAttrs_Z_DIdx,                         /* 2: +I -1 */
    AddScaledFloatAttrs_Z_DIdx_Tex1,                    /* 3: +I +1 */
};

// RASTSPAN filling functions.
PFN_FILLSPANATTRS g_pfnRampFillSpanFloatAttrsTable[] =
{
    (PFN_FILLSPANATTRS)DebugBreakFn,                    /* 0: -I -1 */
    FillSpanFloatAttrs_Z_Tex1,                          /* 1: -I +1 */
    FillSpanFloatAttrs_Z_DIdx,                          /* 2: +I -1 */
    FillSpanFloatAttrs_Z_DIdx_Tex1,                     /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\lstp.cpp ===
//----------------------------------------------------------------------------
//
// lstp.cpp
//
// Line setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// LineSetup_Start
//
// Starts setup of line attributes.
//
//----------------------------------------------------------------------------

void FASTCALL
LineSetup_Start(PSETUPCTX pStpCtx,
                LPD3DTLVERTEX pV0,
                LPD3DTLVERTEX pV1)
{
    FLOAT fZ0;

    if (pStpCtx->uFlags & PRIMSF_Z_USED)
    {
        FLOAT fZScale;

        if (pStpCtx->pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        pStpCtx->DAttrDMajor.fZ =
            (pV1->dvSZ - pV0->dvSZ) * fZScale * pStpCtx->fOoLen;

        // fZ0 may be used later so set if from the vertex Z.
        fZ0 = pV0->dvSZ;
        pStpCtx->Attr.fZ = fZ0 * fZScale +
            pStpCtx->DAttrDMajor.fZ * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fUoW1, fVoW1;

        // Mipmapping doesn't have any meaning.
        RSASSERT((pStpCtx->uFlags & PRIMSF_LOD_USED) == 0);

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            pStpCtx->DAttrDMajor.fOoW =
                (pV1->dvRHW - pV0->dvRHW) * OOW_SCALE * pStpCtx->fOoLen;
            pStpCtx->Attr.fOoW = pV0->dvRHW * OOW_SCALE +
                pStpCtx->DAttrDMajor.fOoW * pStpCtx->fDMajor;

            fUoW1 = pV0->dvTU * pV0->dvRHW;
            fVoW1 = pV0->dvTV * pV0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW1 =
                PERSP_TEXTURE_DELTA(pV1->dvTU, pV1->dvRHW, pV0->dvTU, fUoW1,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW1 =
                PERSP_TEXTURE_DELTA(pV1->dvTV, pV1->dvRHW, pV0->dvTV, fVoW1,
                                    pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            pStpCtx->DAttrDMajor.fOoW = g_fZero;
            pStpCtx->Attr.fOoW = OOW_SCALE;

            fUoW1 = pV0->dvTU;
            fVoW1 = pV0->dvTV;

            pStpCtx->DAttrDMajor.fUoW1 =
                TextureDiff(pV1->dvTU, fUoW1,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW1 =
                TextureDiff(pV1->dvTV, fVoW1,
                            pStpCtx->pCtx->pdwWrap[0] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW1 = TEX_SCALE * fUoW1 +
            pStpCtx->DAttrDMajor.fUoW1 * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW1 = TEX_SCALE * fVoW1 +
            pStpCtx->DAttrDMajor.fVoW1 * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_TEX2_USED)
    {
        PRAST_GENERIC_VERTEX pVM0 = (PRAST_GENERIC_VERTEX)pV0;
        PRAST_GENERIC_VERTEX pVM1 = (PRAST_GENERIC_VERTEX)pV1;
        FLOAT fUoW2, fVoW2;

        if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
        {
            fUoW2 = pVM0->dvTU2 * pVM0->dvRHW;
            fVoW2 = pVM0->dvTV2 * pVM0->dvRHW;

            pStpCtx->DAttrDMajor.fUoW2 =
                PERSP_TEXTURE_DELTA(pVM1->dvTU2, pVM1->dvRHW,
                                    pVM0->dvTU2, fUoW2,
                                    pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_U) *
                                    TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW2 =
                PERSP_TEXTURE_DELTA(pVM1->dvTV2, pVM1->dvRHW,
                                    pVM0->dvTV2, fVoW2,
                                    pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_V) *
                                    TEX_SCALE * pStpCtx->fOoLen;
        }
        else
        {
            fUoW2 = pVM0->dvTU2;
            fVoW2 = pVM0->dvTV2;

            pStpCtx->DAttrDMajor.fUoW2 =
                TextureDiff(pVM1->dvTU2, fUoW2,
                            pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_U) *
                            TEX_SCALE * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fVoW2 =
                TextureDiff(pVM1->dvTV2, fVoW2,
                            pStpCtx->pCtx->pdwWrap[1] & D3DWRAP_V) *
                            TEX_SCALE * pStpCtx->fOoLen;
        }

        pStpCtx->Attr.fUoW2 = fUoW2 +
            pStpCtx->DAttrDMajor.fUoW2 * pStpCtx->fDMajor;
        pStpCtx->Attr.fVoW2 = fVoW2 +
            pStpCtx->DAttrDMajor.fVoW2 * pStpCtx->fDMajor;
    }

    if (pStpCtx->uFlags & PRIMSF_FLAT_SHADED)
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcColor, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fB = g_fZero;
            pStpCtx->DAttrDMajor.fG = g_fZero;
            pStpCtx->DAttrDMajor.fR = g_fZero;
            pStpCtx->DAttrDMajor.fA = g_fZero;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT);
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT);
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            pStpCtx->DAttrDMajor.fDIdx = g_fZero;
            pStpCtx->DAttrDMajor.fDIdxA = g_fZero;

            pStpCtx->Attr.fDIdx =
                (FLOAT)(CI_MASKALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_FIXED_SHIFT);
            pStpCtx->Attr.fDIdxA =
                (FLOAT)(CI_GETALPHA(pStpCtx->pFlatVtx->dcColor) <<
                        INDEX_COLOR_SHIFT);
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;

            SPLIT_COLOR(pStpCtx->pFlatVtx->dcSpecular, uB, uG, uR, uA);

            pStpCtx->DAttrDMajor.fBS = g_fZero;
            pStpCtx->DAttrDMajor.fGS = g_fZero;
            pStpCtx->DAttrDMajor.fRS = g_fZero;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT);
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT);
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT);
        }
    }
    else
    {
        if (pStpCtx->uFlags & PRIMSF_DIFF_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcColor, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcColor, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fB = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fG = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fR = fDR * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fB = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fB * pStpCtx->fDMajor;
            pStpCtx->Attr.fG = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fG * pStpCtx->fDMajor;
            pStpCtx->Attr.fR = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fR * pStpCtx->fDMajor;
            pStpCtx->Attr.fA = (FLOAT)(uA << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fA * pStpCtx->fDMajor;
        }
        else if (pStpCtx->uFlags & PRIMSF_DIDX_USED)
        {
            INT32 iIdx, iA;
            FLOAT fDIdx, fDA;

            SPLIT_IDX_COLOR(pV0->dcColor, iIdx, iA);
            IDX_COLOR_DELTA(pV1->dcColor, iIdx, iA, fDIdx, fDA);

            pStpCtx->DAttrDMajor.fDIdx = fDIdx * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fDIdxA = fDA * pStpCtx->fOoLen;

            pStpCtx->Attr.fDIdx = (FLOAT)(iIdx << INDEX_COLOR_FIXED_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdx * pStpCtx->fDMajor;
            pStpCtx->Attr.fDIdxA = (FLOAT)(iA << INDEX_COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fDIdxA * pStpCtx->fDMajor;
        }

        if (pStpCtx->uFlags & PRIMSF_SPEC_USED)
        {
            UINT uB, uG, uR, uA;
            FLOAT fDB, fDG, fDR, fDA;

            SPLIT_COLOR(pV0->dcSpecular, uB, uG, uR, uA);
            COLOR_DELTA(pV1->dcSpecular, uB, uG, uR, uA, fDB, fDG, fDR, fDA);

            pStpCtx->DAttrDMajor.fBS = fDB * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fGS = fDG * pStpCtx->fOoLen;
            pStpCtx->DAttrDMajor.fRS = fDR * pStpCtx->fOoLen;

            pStpCtx->Attr.fBS = (FLOAT)(uB << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fBS * pStpCtx->fDMajor;
            pStpCtx->Attr.fGS = (FLOAT)(uG << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fGS * pStpCtx->fDMajor;
            pStpCtx->Attr.fRS = (FLOAT)(uR << COLOR_SHIFT) +
                pStpCtx->DAttrDMajor.fRS * pStpCtx->fDMajor;
        }
    }

    if (pStpCtx->uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        UINT uFog0, uFog1;

#ifndef PWL_FOG
        // Check for global-into-local fog.  If global fog is on,
        // compute the local fog values from table fog rather than
        // from the vertex.
        if (pStpCtx->uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure Z information is valid.
            RSASSERT(pStpCtx->uFlags & PRIMSF_Z_USED);

            uFog0 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState, fZ0);
            uFog1 = ComputeTableFog(pStpCtx->pCtx->pdwRenderState,
                                    pV1->dvSZ);
        }
        else
#endif
        {
            uFog0 = (UINT)RGBA_GETALPHA(pV0->dcSpecular) << FOG_SHIFT;
            uFog1 = (UINT)RGBA_GETALPHA(pV1->dcSpecular) << FOG_SHIFT;
        }

        pStpCtx->DAttrDMajor.fFog =
            (FLOAT)((INT)uFog1 - (INT)uFog0) * pStpCtx->fOoLen;
        pStpCtx->Attr.fFog = (FLOAT)uFog0 +
            pStpCtx->DAttrDMajor.fFog * pStpCtx->fDMajor;
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE2(fV0, fV1) \
    ((ASUINT32(fV0) | ASUINT32(fV1)) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeLineRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeLineRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || FLOAT_LTZ(pV1->dvRHW))
    {
        RSDPF(("Line RHW out of range %f,%f\n",
               pV0->dvRHW, pV1->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        fMax = pV1->dvRHW;
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
}

//-----------------------------------------------------------------------------
//
// PrimProcessor::PointDiamondCheck
//
// Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is
// pixel-relative test - this corresponds to an upper-left test for
// a vertex-relative position.
//
//-----------------------------------------------------------------------------

BOOL
PrimProcessor::PointDiamondCheck(INT32 iXFrac, INT32 iYFrac,
                                 BOOL bSlopeIsOne, BOOL bSlopeIsPosOne)
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf )
    {
        return TRUE;
    }

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
    {
        return TRUE;
    }

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
    {
        return TRUE;
    }

    // return true if slope is one, vertex is on edge,
    // and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::LineSetup
//
// Does attribute setup computations.
//
//----------------------------------------------------------------------------

// Line computations are done in n.4 fixed-point to reduce vertex jitter,
// move more computation to integer and to more easily match the GDI
// line computations.
#define LINE_FIX 4
#define LINE_SNAP FLOAT_TWOPOW4
#define OO_LINE_SNAP (1.0f / FLOAT_TWOPOW4)
#define LINE_FIX_HALF (1 << (LINE_FIX - 1))
#define LINE_FIX_NEAR_HALF (LINE_FIX_HALF - 1)

BOOL
PrimProcessor::LineSetup(LPD3DTLVERTEX pV0,
                         LPD3DTLVERTEX pV1)
{
    // compute fixed point vertex values, with cheap
    // rounding for better accuracy
    INT32 iX0 = FTOI(pV0->dvSX * LINE_SNAP + .5F);
    INT32 iX1 = FTOI(pV1->dvSX * LINE_SNAP + .5F);
    INT32 iY0 = FTOI(pV0->dvSY * LINE_SNAP + .5F);
    INT32 iY1 = FTOI(pV1->dvSY * LINE_SNAP + .5F);

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = iX1 - iX0;
    INT32 iYSize = iY1 - iY0;

    // ignore zero length lines
    if ( iXSize == 0 && iYSize == 0 )
    {
        return FALSE;
    }

    INT32 iAbsXSize;
    INT32 iAbsYSize;

    if ( iXSize < 0 )
    {
        m_StpCtx.iDXCY = -1;
        iAbsXSize = -iXSize;
    }
    else
    {
        m_StpCtx.iDXCY = 1;
        iAbsXSize = iXSize;
    }

    if ( iYSize < 0 )
    {
        m_StpCtx.iDYCY = -1;
        iAbsYSize = -iYSize;
    }
    else
    {
        m_StpCtx.iDYCY = 1;
        iAbsYSize = iYSize;
    }

    BOOL bSlopeIsOne = iAbsXSize == iAbsYSize;
    BOOL bSlopeIsPosOne =
        bSlopeIsOne && ((iXSize ^ iYSize) & 0x80000000) == 0;

    // compute closest pixel for vertices
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for
    // exception (slope == +1) case else use nearest ceiling
    //
    INT32 iXAdjust;
    if (bSlopeIsPosOne)
    {
        iXAdjust = LINE_FIX_HALF;
    }
    else
    {
        iXAdjust = LINE_FIX_NEAR_HALF;
    }
    INT32 iPixX0 = ( iX0 + iXAdjust ) >> LINE_FIX;
    INT32 iPixX1 = ( iX1 + iXAdjust ) >> LINE_FIX;
    INT32 iPixY0 = ( iY0 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;
    INT32 iPixY1 = ( iY1 + LINE_FIX_NEAR_HALF ) >> LINE_FIX;

    // determine major axis and compute step values

    // sign of extent from V0 to V1 in major direction
    BOOL bLineMajorNeg;

    INT32 iLineMajor0;
    INT32 iLineMajor1;
    INT32 iLinePix0;
    INT32 iLinePix1;
    INT32 iLinePixStep;

    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( iAbsXSize >= iAbsYSize )
    {
        // here for X major
        m_StpCtx.uFlags |= LNF_X_MAJOR;
        iLineMajor0 = iX0;
        iLineMajor1 = iX1;
        iLinePix0 = iPixX0;
        iLinePix1 = iPixX1;
        iLinePixStep = m_StpCtx.iDXCY;
        bLineMajorNeg = iXSize & 0x80000000;
        m_StpCtx.iDXNC = m_StpCtx.iDXCY;
        m_StpCtx.iDYNC = 0;
    }
    else
    {
        // here for Y major
        iLineMajor0 = iY0;
        iLineMajor1 = iY1;
        iLinePix0 = iPixY0;
        iLinePix1 = iPixY1;
        iLinePixStep = m_StpCtx.iDYCY;
        bLineMajorNeg = iYSize & 0x80000000;
        m_StpCtx.iDXNC = 0;
        m_StpCtx.iDYNC = m_StpCtx.iDYCY;
    }

    // The multiplies here could be traded for sign tests but there'd
    // be four cases.  On a PII the multiplies will be faster than
    // the branches.
    m_StpCtx.DAttrCY.ipSurface =
        m_StpCtx.iDYCY * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXCY * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipSurface =
        m_StpCtx.iDYNC * m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.iDXNC * m_StpCtx.pCtx->iSurfaceStep;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        m_StpCtx.DAttrCY.ipZ =
            m_StpCtx.iDYCY * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXCY * m_StpCtx.pCtx->iZStep;
        m_StpCtx.DAttrNC.ipZ =
            m_StpCtx.iDYNC * m_StpCtx.pCtx->iZStride +
            m_StpCtx.iDXNC * m_StpCtx.pCtx->iZStep;
    }

    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( iX0 - (iPixX0 << LINE_FIX),
                                           iY0 - (iPixY0 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( iX1 - (iPixX1 << LINE_FIX),
                                           iY1 - (iPixY1 << LINE_FIX),
                                           bSlopeIsOne, bSlopeIsPosOne );

#define LINEDIR_CMP( _A, _B ) \
    ( bLineMajorNeg ? ( (_A) > (_B) ) : ( (_A) < (_B) ) )

    // do first pixel handling - not in or behind diamond
    if ( !( bV0InDiamond ||
            LINEDIR_CMP( iLineMajor0, iLinePix0 << LINE_FIX ) ) )
    {
        iLinePix0 += iLinePixStep;
    }

    // do last-pixel handling - don't pull in extent if past diamond
    // (in which case the pixel is always filled) or if in diamond
    // and rendering last pixel
    if ( !( ( !bV1InDiamond &&
              LINEDIR_CMP( iLinePix1 << LINE_FIX, iLineMajor1 ) ||
            ( bV1InDiamond &&
              m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_LASTPIXEL] ) ) ) )
    {
        iLinePix1 -= iLinePixStep;
    }

    // compute extent along major axis
    m_StpCtx.cLinePix =
        bLineMajorNeg ? iLinePix0 - iLinePix1 + 1 : iLinePix1 - iLinePix0 + 1;

    // return if no major extent
    if ( m_StpCtx.cLinePix <= 0 )
    {
        return FALSE;
    }

    FLOAT fSlope;
    FLOAT fMinor0;

    // compute final axis-specific line values
    if ( iAbsXSize >= iAbsYSize )
    {
        m_StpCtx.iX = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iX0 - (m_StpCtx.iX << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX0 - iX1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iX << LINE_FIX) - iX0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iX1 - iX0);
        }

        fSlope = m_StpCtx.fOoLen * (iY1 - iY0) * OO_LINE_SNAP;

        fMinor0 = (iY0 + LINE_FIX_NEAR_HALF) * OO_LINE_SNAP +
            m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iY = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iY);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }
    else
    {
        m_StpCtx.iY = iLinePix0;

        if (bLineMajorNeg)
        {
            m_StpCtx.fDMajor =
                (iY0 - (m_StpCtx.iY << LINE_FIX)) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY0 - iY1);
        }
        else
        {
            m_StpCtx.fDMajor =
                ((m_StpCtx.iY << LINE_FIX) - iY0) * OO_LINE_SNAP;
            m_StpCtx.fOoLen = LINE_SNAP / (FLOAT)(iY1 - iY0);
        }

        fSlope = m_StpCtx.fOoLen * (iX1 - iX0) * OO_LINE_SNAP;

        fMinor0 = (iX0 + iXAdjust) * OO_LINE_SNAP + m_StpCtx.fDMajor * fSlope;
        m_StpCtx.iX = IFLOORF(fMinor0);
        m_StpCtx.iLineFrac = SCALED_FRACTION(fMinor0 - m_StpCtx.iX);
        m_StpCtx.iDLineFrac = SCALED_FRACTION(fSlope);
    }

#ifdef LINE_CORRECTION_BIAS
    // A fudge factor of one-half is thrown into the correction
    // to avoid undershoot due to negative corrections.
    // This shifts all the attributes along the line,
    // introducing error, but it's better than clamping
    // them.  This is not done to the coordinates to avoid
    // perturbing them.
    m_StpCtx.fDMajor += g_fHalf;
#else
    // The correction factor is clamped to positive numbers to
    // avoid undershooting with attribute values.  This won't
    // cause overshooting issues because it moves attributes by
    // at most one-half.
    if (FLOAT_LTZ(m_StpCtx.fDMajor))
    {
        m_StpCtx.fDMajor = 0;
    }
#endif

    RSDPFM((RSM_LINES, "Line %.2f,%.2f - %.2f,%.2f\n",
            pV0->dvSX, pV0->dvSY, pV1->dvSX, pV1->dvSY));
    RSDPFM((RSM_LINES, "  %c major, %d,%d, %d pix\n",
            (m_StpCtx.uFlags & LNF_X_MAJOR) ? 'X' : 'Y',
            m_StpCtx.iX, m_StpCtx.iY, m_StpCtx.cLinePix));
    RSDPFM((RSM_LINES, "  slope %f, dmajor %f, minor0 %f\n",
            fSlope, m_StpCtx.fDMajor, fMinor0));
    RSDPFM((RSM_LINES, "  frac %d, dfrac %d\n",
            m_StpCtx.iLineFrac, m_StpCtx.iDLineFrac));

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE2(pV0->dvRHW, pV1->dvRHW))
    {
        NormalizeLineRHW(pV0, pV1);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    LineSetup_Start(&m_StpCtx, pV0, pV1);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\buffer.cpp ===
//----------------------------------------------------------------------------
//
// buffer.cpp
//
// PrimProcessor buffering methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Define to use new/delete instead of VirtualAlloc/VirtualFree.
#if 0
#define USE_CPP_HEAP
#endif

// Define to show FP exceptions.
#if 0
#define UNMASK_EXCEPTIONS
#endif

//----------------------------------------------------------------------------
//
// PrimProcessor::PrimProcessor
//
// Initializes a triangle processor to an invalid state.
//
//----------------------------------------------------------------------------

PrimProcessor::PrimProcessor(void)
{
    // Zero everything to NULL initial pointers and eliminate FP garbage.
    memset(this, 0, sizeof(PrimProcessor));

    m_StpCtx.PrimProcessor = (PVOID)this;

    // Initialize to values that will force a validation.
    // ATTENTION - Default to normalizing RHW.  This is a performance hit
    // and should be removed if possible.
    m_uPpFlags = PPF_STATE_CHANGED | PPF_NORMALIZE_RHW;
    m_PrimType = D3DPT_FORCE_DWORD;
    m_VertType = RAST_FORCE_DWORD;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Initialize
//
// Initializes the triangle processor to an active state.
//
//----------------------------------------------------------------------------

#define CACHE_LINE 32
#define BUFFER_SIZE 4096
// Uncomment to force a flush every span for debug purposes
//#define BUFFER_SIZE ((8 * sizeof(D3DI_RASTSPAN)) + sizeof(D3DI_RASTPRIM))

HRESULT
PrimProcessor::Initialize(void)
{
    HRESULT hr;

    // Assert that both RASTPRIM and RASTSPAN are multiples of the cache
    // line size so that everything in the buffer stays cache aligned.
    RSASSERT((sizeof(D3DI_RASTPRIM) & (CACHE_LINE - 1)) == 0 &&
             (sizeof(D3DI_RASTSPAN) & (CACHE_LINE - 1)) == 0);

#ifdef USE_CPP_HEAP
    m_pBuffer = new UINT8[BUFFER_SIZE];
#else
    // Get a page-aligned buffer.
    m_pBuffer = (PUINT8)
        VirtualAlloc(NULL, BUFFER_SIZE,
                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
#endif
    if (m_pBuffer == NULL)
    {
        return RSHRCHK(E_OUTOFMEMORY);
    }

    m_pBufferEnd = m_pBuffer+BUFFER_SIZE;

#ifdef USE_CPP_HEAP
    // Compute cache-line aligned start in the buffer.  Formulated
    // somewhat oddly to avoid casting a complete pointer to a DWORD and
    // back.
    m_pBufferStart = m_pBuffer +
        ((CACHE_LINE - ((UINT)m_pBuffer & (CACHE_LINE - 1))) &
         (CACHE_LINE - 1));
#else
    // Page aligned memory should be cache aligned.
    RSASSERT(((UINT_PTR)m_pBuffer & (CACHE_LINE - 1)) == 0);
    m_pBufferStart = m_pBuffer;
#endif

    m_pCur = m_pBufferStart;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::~PrimProcessor
//
//----------------------------------------------------------------------------

PrimProcessor::~PrimProcessor(void)
{
#ifdef USE_CPP_HEAP
    delete m_pBuffer;
#else
    if (m_pBuffer != NULL)
    {
        VirtualFree(m_pBuffer, 0, MEM_RELEASE);
    }
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::ResetBuffer
//
// Initialize buffer pointers to an empty state.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::ResetBuffer(void)
{
    m_pCur = m_pBufferStart;
    m_StpCtx.pPrim = NULL;
    m_pOldPrim = NULL;
}

//----------------------------------------------------------------------------
//
// DumpPrims
//
// Debugging function to dump primitives sent to the span renderer.
//
//----------------------------------------------------------------------------

#if DBG
void
DumpPrims(PSETUPCTX pStpCtx)
{
    PD3DI_RASTPRIM pPrim;
    UINT uOldFlags;

    uOldFlags = RSGETFLAGS(DBG_OUTPUT_FLAGS);
    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags | DBG_OUTPUT_ALL_MATCH);

    for (pPrim = pStpCtx->pCtx->pPrim; pPrim != NULL; pPrim = pPrim->pNext)
    {
        RSDPFM((RSM_BUFPRIM, "Prim at %p, %d spans at %p\n",
                pPrim, pPrim->uSpans, pPrim+1));
        RSDPFM((RSM_BUFPRIM | RSM_OOW, "  DOoWDX %X (%f)\n",
                pPrim->iDOoWDX, (FLOAT)pPrim->iDOoWDX / OOW_SCALE));

        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & RSM_BUFSPAN) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            PD3DI_RASTSPAN pSpan;
            UINT16 i;

            pSpan = (PD3DI_RASTSPAN)(pPrim+1);
            for (i = 0; i < pPrim->uSpans; i++)
            {
                RSDPFM((RSM_BUFSPAN,
                        "  Span at (%d,%d), pix %c%d, S %p Z %p\n",
                        pSpan->uX, pSpan->uY,
                        (pPrim->uFlags & D3DI_RASTPRIM_X_DEC) ? '-' : '+',
                        pSpan->uPix, pSpan->pSurface, pSpan->pZ));

                if (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                                  RSU_CHECK_SPAN_EDGES))
                {
                    PUINT16 pPix;

                    pPix = (PUINT16)pSpan->pSurface;
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                    {
                        if (*pPix != 0)
                        {
                            RSDPF(("  Overwrite at %p: %X\n", pPix, *pPix));
                        }
                    }
                    if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                    {
                        *pPix = 0xffff;
                    }

                    if (pSpan->uPix > 1)
                    {
                        if (pPrim->uFlags & D3DI_RASTPRIM_X_DEC)
                        {
                            pPix = (PUINT16)pSpan->pSurface -
                                (pSpan->uPix - 1);
                        }
                        else
                        {
                            pPix = (PUINT16)pSpan->pSurface +
                                (pSpan->uPix - 1);
                        }

                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_CHECK_SPAN_EDGES)
                        {
                            if (*pPix != 0)
                            {
                                RSDPF(("  Overwrite at %p: %X\n",
                                       pPix, *pPix));
                            }
                        }
                        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_MARK_SPAN_EDGES)
                        {
                            *pPix = 0xffff;
                        }
                    }
                }

                FLOAT fZScale;
                if (pStpCtx->pCtx->iZBitCount == 16)
                {
                    fZScale = Z16_SCALE;
                }
                else
                {
                    fZScale = Z32_SCALE;
                }
                RSDPFM((RSM_BUFSPAN | RSM_Z,
                        "    Z %X (%f)\n",
                        pSpan->uZ, (FLOAT)pSpan->uZ / fZScale));

                RSDPFM((RSM_BUFSPAN | RSM_DIFF,
                        "    D %X,%X,%X,%X (%f,%f,%f,%f)\n",
                        pSpan->uB, pSpan->uG, pSpan->uR, pSpan->uA,
                        (FLOAT)pSpan->uB / COLOR_SCALE,
                        (FLOAT)pSpan->uG / COLOR_SCALE,
                        (FLOAT)pSpan->uR / COLOR_SCALE,
                        (FLOAT)pSpan->uA / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_SPEC,
                        "    S %X,%X,%X (%f,%f,%f)\n",
                        pSpan->uBS, pSpan->uGS, pSpan->uRS,
                        (FLOAT)pSpan->uBS / COLOR_SCALE,
                        (FLOAT)pSpan->uGS / COLOR_SCALE,
                        (FLOAT)pSpan->uRS / COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_DIDX,
                        "    I %X,%X (%f,%f)\n",
                        pSpan->iIdx, pSpan->iIdxA,
                        (FLOAT)pSpan->iIdx / INDEX_COLOR_SCALE,
                        (FLOAT)pSpan->iIdxA / INDEX_COLOR_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_OOW,
                        "    OoW %X (%f), W %X (%f)\n",
                        pSpan->iOoW, (FLOAT)pSpan->iOoW / OOW_SCALE,
                        pSpan->iW, (FLOAT)pSpan->iW / W_SCALE));

                RSDPFM((RSM_BUFSPAN | RSM_LOD,
                        "    LOD %X (%f), DLOD %X (%f)\n",
                        pSpan->iLOD, (FLOAT)pSpan->iLOD / LOD_SCALE,
                        pSpan->iDLOD, (FLOAT)pSpan->iDLOD / LOD_SCALE));

                if (pStpCtx->uFlags & PRIMSF_PERSP_USED)
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    PTex1 %X,%X (%f,%f) (%f,%f)\n",
                            pSpan->iUoW1, pSpan->iVoW1,
                            (FLOAT)pSpan->iUoW1 / TEX_SCALE,
                            (FLOAT)pSpan->iVoW1 / TEX_SCALE,
                            ((FLOAT)pSpan->iUoW1 * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW),
                            ((FLOAT)pSpan->iVoW1 * OOW_SCALE) /
                            (TEX_SCALE * (FLOAT)pSpan->iOoW)));
                }
                else
                {
                    RSDPFM((RSM_BUFSPAN | RSM_TEX1,
                            "    ATex1 %X,%X (%f,%f)\n",
                            pSpan->iUoW1, pSpan->iVoW1,
                            (FLOAT)pSpan->iUoW1 / TEX_SCALE,
                            (FLOAT)pSpan->iVoW1 / TEX_SCALE));
                }

                RSDPFM((RSM_BUFSPAN | RSM_FOG,
                        "    Fog %X (%f), DFog %X (%f)\n",
                        pSpan->uFog, (FLOAT)pSpan->uFog / FOG_SCALE,
                        pSpan->iDFog, (FLOAT)pSpan->iDFog / FOG_SCALE));

                pSpan++;
            }
        }
    }

    RSSETFLAGS(DBG_OUTPUT_FLAGS, uOldFlags);
}
#endif // DBG

//----------------------------------------------------------------------------
//
// PrimProcessor::Flush
//
// Flushes any remaining data from the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Flush(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        // Process data.
        m_StpCtx.pCtx->pPrim = (PD3DI_RASTPRIM)m_pBufferStart;
        m_StpCtx.pCtx->pNext = NULL;

#if DBG
        if ((RSGETFLAGS(DBG_OUTPUT_MASK) & (RSM_BUFPRIM | RSM_BUFSPAN)) ||
            (RSGETFLAGS(DBG_USER_FLAGS) & (RSU_MARK_SPAN_EDGES |
                                           RSU_CHECK_SPAN_EDGES)))
        {
            DumpPrims(&m_StpCtx);
        }

        if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_NO_RENDER_SPANS) == 0)
        {
            if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_BREAK_ON_RENDER_SPANS)
            {
                DebugBreak();
            }

            RSHRCHK(m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx));
        }
        else
        {
            hr = D3D_OK;
        }
#else
        hr = m_StpCtx.pCtx->pfnRenderSpans(m_StpCtx.pCtx);
#endif

        ResetBuffer();
    }
    else
    {
        hr = D3D_OK;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FlushPartial
//
// Flushes the buffer in the middle of a primitive.  Preserves last
// partial primitive and replaces it in the buffer after the flush.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::FlushPartial(void)
{
    D3DI_RASTPRIM SavedPrim;
    HRESULT hr;

    RSDPFM((RSM_BUFFER, "FlushPartial, saving prim at %p, Y %d\n",
            m_StpCtx.pPrim, m_StpCtx.iY));

    // Not enough space.  Flush current buffer.  We need to
    // save the current prim and put it back in the buffer after the
    // flush since it's being extended.
    SavedPrim = *m_StpCtx.pPrim;

    RSHRRET(Flush());

    GET_PRIM();

    *m_StpCtx.pPrim = SavedPrim;
    COMMIT_PRIM(FALSE);

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AppendPrim
//
// Ensures that some primitive is active in the buffer for spans to
// be added to.  If no valid primitive is available to append to,
// a zeroed primitive is committed into the buffer.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::AppendPrim(void)
{
    // If there's no primitive or the current primitive has not
    // been committed, commit a clean primitive into the buffer.
    if (m_StpCtx.pPrim == NULL ||
        (PUINT8)m_StpCtx.pPrim == m_pCur)
    {
        GET_PRIM();
        COMMIT_PRIM(TRUE);
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Begin
//
// Resets the buffer to an empty state in preparation for incoming
// triangles.
//
//----------------------------------------------------------------------------

void
PrimProcessor::Begin(void)
{
    UINT16 uFpCtrl;
    FPU_GET_MODE(uFpCtrl);
    m_uFpCtrl = uFpCtrl;
    uFpCtrl =
        FPU_MODE_CHOP_ROUND(
                FPU_MODE_LOW_PRECISION(
                        FPU_MODE_MASK_EXCEPTIONS(m_uFpCtrl)));
#if defined(_X86_) && defined(UNMASK_EXCEPTIONS)
    // Unmask some exceptions so that we can eliminate them.
    // This requires a safe set to clear any exceptions that
    // are currently asserted.
    //
    // Exceptions left masked:
    //   Precision, denormal.
    // Exceptions unmasked:
    //   Underflow, overflow, divzero, invalid op.
    uFpCtrl &= ~0x1d;
    FPU_SAFE_SET_MODE(uFpCtrl);
#else
    FPU_SET_MODE(uFpCtrl);
#endif

    m_uPpFlags |= PPF_IN_BEGIN;
    ResetBuffer();
}

//----------------------------------------------------------------------------
//
// PrimProcessor::End
//
// Flushes if necessary and cleans up.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::End(void)
{
    HRESULT hr;

    if (m_pCur - m_pBufferStart > sizeof(D3DI_RASTPRIM))
    {
        RSHRCHK(Flush());
    }
    else
    {
        hr = D3D_OK;
    }

    UINT16 uFpCtrl = m_uFpCtrl;
    FPU_SAFE_SET_MODE(uFpCtrl);

    m_uPpFlags &= ~PPF_IN_BEGIN;

    return hr;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::SetCtx
//
// Sets the rasterization context to operate in.
//
//----------------------------------------------------------------------------

void
PrimProcessor::SetCtx(PD3DI_RASTCTX pCtx)
{
    // This function can't be called inside a Begin/End pair.  This
    // is enforced so that we don't have to worry about the span
    // rendering function changing in the middle of a batch.
    RSASSERT((m_uPpFlags & PPF_IN_BEGIN) == 0);

    m_StpCtx.pCtx = pCtx;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::AllocSpans
//
// Checks to see if there's room in the buffer for the requested number
// of spans.  If so the buffer pointer is updated and a pointer is returned.
// If the requested number is not available but some reasonable number is,
// return that many.  Otherwise the buffer is flushed and the process starts
// over.  The "reasonable" number must therefore be no more than what
// can fit in the buffer at once.
//
//----------------------------------------------------------------------------

// Space for enough spans to avoid a flush.
#define AVOID_FLUSH_SPACE (8 * sizeof(D3DI_RASTSPAN))

HRESULT
PrimProcessor::AllocSpans(PUINT pcSpans, PD3DI_RASTSPAN *ppSpan)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    UINT uSpanSize;

    RSASSERT(AVOID_FLUSH_SPACE <= (BUFFER_SIZE - sizeof(D3DI_RASTPRIM)));
    // The multiplies and divides here will be really bad unless
    // RASTPRIM is a nice power-of-two in size.
    RSASSERT((sizeof(D3DI_RASTSPAN) & (sizeof(D3DI_RASTSPAN) - 1)) == 0);

    uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);

    for (;;)
    {
        // First check for space for all requested spans.
        if (m_pCur + uSpanSize > m_pBufferEnd)
        {
            // Not enough space for everything, so see if we have
            // enough space to avoid a flush.
            if (m_pCur + AVOID_FLUSH_SPACE > m_pBufferEnd)
            {
                // Not enough space, so flush.
                RSHRCHK(FlushPartial());
                if (hr != D3D_OK)
                {
                    *pcSpans = 0;
                    return hr;
                }

                // Loop around.  Flush is guaranteed to at least produce
                // AVOID_FLUSH_SPACE so the loop will always exit.
            }
            else
            {
                // Not enough space for everything but enough space
                // to return some.  Set new span count.
                *pcSpans = (UINT)((m_pBufferEnd - m_pCur) / sizeof(D3DI_RASTSPAN));
                uSpanSize = *pcSpans * sizeof(D3DI_RASTSPAN);
                break;
            }
        }
        else
        {
            break;
        }
    }

    pSpan = (PD3DI_RASTSPAN)m_pCur;
    m_pCur += uSpanSize;
    *ppSpan = pSpan;

    RSDPFM((RSM_BUFFER, "Alloc %d spans at %p, cur %p\n",
            *pcSpans, pSpan, m_pCur));

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// PrimProcessor::FreeSpans and FreeSpans
//
// Returns space given out by AllocSpans.
//
//----------------------------------------------------------------------------

void
PrimProcessor::FreeSpans(UINT cSpans)
{
    m_pCur -= cSpans * sizeof(D3DI_RASTSPAN);

    RSDPFM((RSM_BUFFER, "Free  %d spans at %p, cur %p\n", cSpans,
            m_pCur + cSpans * sizeof(D3DI_RASTSPAN), m_pCur));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\point.cpp ===
//----------------------------------------------------------------------------
//
// point.cpp
//
// Point processing.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

void
PrimProcessor::FillPointSpan(LPD3DTLVERTEX pV0, PD3DI_RASTSPAN pSpan)
{
    FLOAT fZ;
    FLOAT fZScale;

    pSpan->uPix = 1;
    pSpan->uX = (UINT16)m_StpCtx.iX;
    pSpan->uY = (UINT16)m_StpCtx.iY;

    pSpan->pSurface = m_StpCtx.pCtx->pSurfaceBits +
        m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
        m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;

    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        pSpan->pZ = m_StpCtx.pCtx->pZBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iZStride;

        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            fZScale = Z16_SCALE;
        }
        else
        {
            fZScale = Z32_SCALE;
        }

        // fZ may be used later so set if from the vertex Z.
        fZ = pV0->dvSZ;
        pSpan->uZ = FTOI(fZ * fZScale);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX_USED)
    {
        FLOAT fW;
        FLOAT fUoW, fVoW;

        // Mipmapping doesn't have any meaning.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_LOD_USED) == 0);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            if (FLOAT_EQZ(pV0->dvRHW))
            {
                fW = g_fZero;
            }
            else
            {
                fW = g_fOne / pV0->dvRHW;
            }

            pSpan->iW = FTOI(fW * W_SCALE);

            fUoW = pV0->dvTU * pV0->dvRHW;
            fVoW = pV0->dvTV * pV0->dvRHW;

            pSpan->iOoW = FTOI(pV0->dvRHW * OOW_SCALE);
        }
        else
        {
            fUoW = pV0->dvTU;
            fVoW = pV0->dvTV;
        }

        pSpan->iLOD = 0;
        pSpan->iDLOD = 0;

        pSpan->iUoW1 = FTOI(fUoW * TEX_SCALE);
        pSpan->iVoW1 = FTOI(fVoW * TEX_SCALE);
    }

    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            pSpan->iUoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTU2 *
                     pV0->dvRHW * TEX_SCALE);
            pSpan->iVoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTV2 *
                     pV0->dvRHW * TEX_SCALE);
        }
        else
        {
            pSpan->iUoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTU2 * TEX_SCALE);
            pSpan->iVoW2 =
                FTOI(((PRAST_GENERIC_VERTEX)pV0)->dvTV2 * TEX_SCALE);
        }
    }

    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        pSpan->uB = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uG = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uR = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
        pSpan->uA = (UINT)RGBA_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            COLOR_SHIFT;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        pSpan->iIdx = (INT32)CI_MASKALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_FIXED_SHIFT;
        pSpan->iIdxA = (INT32)CI_GETALPHA(m_StpCtx.pFlatVtx->dcColor) <<
            INDEX_COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        pSpan->uBS = (UINT)RGBA_GETBLUE(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uGS = (UINT)RGBA_GETGREEN(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
        pSpan->uRS = (UINT)RGBA_GETRED(m_StpCtx.pFlatVtx->dcSpecular) <<
            COLOR_SHIFT;
    }

    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_GLOBAL_FOG_USED)
        {
            // Make sure that fZ has been set.
            RSASSERT(m_StpCtx.uFlags & PRIMSF_Z_USED);

            pSpan->uFog = (UINT16)ComputeTableFog(m_StpCtx.pCtx->pdwRenderState, fZ);
        }
        else
        {
            pSpan->uFog = (INT16)
                FTOI((FLOAT)RGBA_GETALPHA(pV0->dcSpecular) *
                     FOG_255_SCALE);
        }
    }
}

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
#define NEEDS_NORMALIZE1(fV0) \
    (ASUINT32(fV0) > INT32_FLOAT_ONE)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizePointRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function clamps
// the RHW to the proper range.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizePointRHW(LPD3DTLVERTEX pV0)
{
    // Save original value.
    m_dvV0RHW = pV0->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW))
    {
        RSDPF(("Point RHW out of range %f,%f",
               pV0->dvRHW));
    }
#endif

    if (pV0->dvRHW < NORMALIZED_RHW_MIN)
    {
        pV0->dvRHW = NORMALIZED_RHW_MIN;
    }
    else if (pV0->dvRHW > NORMALIZED_RHW_MAX)
    {
        pV0->dvRHW = NORMALIZED_RHW_MAX;
    }
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Point
//
// Provides a point for processing.
//
//----------------------------------------------------------------------------

HRESULT
PrimProcessor::Point(LPD3DTLVERTEX pV0,
                     LPD3DTLVERTEX pFlatVtx)
{
    HRESULT hr;

    hr = D3D_OK;

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        return hr;
    }
#endif

    // Clear per-point flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | PTF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X",
            m_uPpFlags, m_StpCtx.uFlags));

    // Round coordinates to integer.
    m_StpCtx.iX = IFLOORF(pV0->dvSX + g_fHalf);
    m_StpCtx.iY = IFLOORF(pV0->dvSY + g_fHalf);

    RSDPFM((RSM_POINTS, "Point\n"));
    RSDPFM((RSM_POINTS, "    V0 (%f,%f,%f) (%d,%d)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ,
            m_StpCtx.iX, m_StpCtx.iY));

    // Clip test.
    if (m_StpCtx.iX < m_StpCtx.pCtx->Clip.left ||
        m_StpCtx.iX >= m_StpCtx.pCtx->Clip.right ||
        m_StpCtx.iY < m_StpCtx.pCtx->Clip.top ||
        m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom)
    {
        return D3D_OK;
    }

    //
    // Fill out a one-pixel span for the point.
    // Since the prim deltas are irrelevant for the span,
    // the span is appended to whatever primitive happens
    // to be available in the buffer.
    //

    PD3DI_RASTSPAN pSpan;
    UINT cSpans = 1;

    hr = AppendPrim();
    if (hr != D3D_OK)
    {
        return hr;
    }

    hr = AllocSpans(&cSpans, &pSpan);
    if (hr != D3D_OK)
    {
        return hr;
    }

    m_StpCtx.pPrim->uSpans++;

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE1(pV0->dvRHW))
    {
        NormalizePointRHW(pV0);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    // Remember flat color controlling vertex for setup.
    m_StpCtx.pFlatVtx = pFlatVtx;

    FillPointSpan(pV0, pSpan);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
    }

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\tstp.cpp ===
//----------------------------------------------------------------------------
//
// setup.cpp
//
// PrimProcessor setup methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// MINMAX3
//
// Computes the min and max of three integer values.
//
//----------------------------------------------------------------------------

#define MINMAX3(iV0, iV1, iV2, iMin, iMax)                                    \
    if ((iV0) <= (iV1))                                                       \
    {                                                                         \
        if ((iV1) <= (iV2))                                                   \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else if ((iV0) <= (iV2))                                              \
        {                                                                     \
            (iMin) = (iV0);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMin) = (iV2);                                                   \
            (iMax) = (iV1);                                                   \
        }                                                                     \
    }                                                                         \
    else if ((iV1) <= (iV2))                                                  \
    {                                                                         \
        (iMin) = (iV1);                                                       \
        if ((iV0) <= (iV2))                                                   \
        {                                                                     \
            (iMax) = (iV2);                                                   \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            (iMax) = (iV0);                                                   \
        }                                                                     \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        (iMin) = (iV2);                                                       \
        (iMax) = (iV0);                                                       \
    }

// Determine whether any of the given values are less than zero or greater
// than one.  Negative zero counts as less than zero so this check will
// produce some false positives but that's OK.
//
// ATTENTION Just wipe this out for now.  Need a test for W too close to
// zero to avoid numerical problems.
//#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
//    ((ASUINT32(fV0) | ASUINT32(fV1) | ASUINT32(fV2)) > INT32_FLOAT_ONE)

#define NEEDS_NORMALIZE3(fV0, fV1, fV2) \
    (1)

//----------------------------------------------------------------------------
//
// PrimProcessor::NormalizeTriRHW
//
// D3DTLVERTEX.dvRHW can be anything, but our internal structures only
// allow for it being in the range [0, 1].  This function ensures that
// the RHWs are in the proper range by finding the largest one and
// scaling all of them down by it.
//
//----------------------------------------------------------------------------

void
PrimProcessor::NormalizeTriRHW(LPD3DTLVERTEX pV0, LPD3DTLVERTEX pV1,
                               LPD3DTLVERTEX pV2)
{
    // Save original values.
    m_dvV0RHW = pV0->dvRHW;
    m_dvV1RHW = pV1->dvRHW;
    m_dvV2RHW = pV2->dvRHW;

    // Produce a warning when a value is out of the desired range.
#if DBG
    if (FLOAT_LTZ(pV0->dvRHW) || 
        FLOAT_LTZ(pV1->dvRHW) || 
        FLOAT_LTZ(pV2->dvRHW))
    {
        RSDPF(("Triangle RHW out of range %f,%f,%f\n",
               pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    }
#endif

    // Find bounds and compute scale.
    FLOAT fMax;

    if (pV0->dvRHW < pV1->dvRHW)
    {
        if (pV1->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV1->dvRHW;
        }
        else
        {
            fMax = pV1->dvRHW;
        }
    }
    else if (pV1->dvRHW < pV2->dvRHW)
    {
        if (pV0->dvRHW < pV2->dvRHW)
        {
            fMax = pV2->dvRHW;
        }
        else
        {
            fMax = pV0->dvRHW;
        }
    }
    else
    {
        fMax = pV0->dvRHW;
    }

    FLOAT fRHWScale;

    fRHWScale = NORMALIZED_RHW_MAX / fMax;

    // Scale all values by scaling factor.
    pV0->dvRHW = pV0->dvRHW * fRHWScale;
    pV1->dvRHW = pV1->dvRHW * fRHWScale;
    pV2->dvRHW = pV2->dvRHW * fRHWScale;

#ifdef DBG_RHW_NORM
    RSDPF(("%f,%f,%f - %f,%f,%f\n",
           m_dvV0RHW, m_dvV1RHW, m_dvV2RHW,
           pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
#endif
}

//----------------------------------------------------------------------------
//
// PrimProcessor::TriSetup
//
// Takes three vertices and does triangle setup, filling in both a
// primitive structure for the triangle and a span structure for the first
// span.  All internal intermediates and DY values are computed.
//
// Uses the current D3DI_RASTPRIM and D3DI_RASTSPAN so these pointers must
// be valid before calling this routine.
//
// Returns whether the triangle was kept or not.  Culled triangles return
// FALSE.
//
//----------------------------------------------------------------------------

BOOL
PrimProcessor::TriSetup(LPD3DTLVERTEX pV0,
                        LPD3DTLVERTEX pV1,
                        LPD3DTLVERTEX pV2)
{
    // Preserve original first vertex for flat shading reference.
    m_StpCtx.pFlatVtx = pV0;

    //
    // Sort vertices in Y.
    // This can cause ordering changes from the original vertex set
    // so track reversals.
    //
    // Determinant computation and culling could be done before this.
    // Doing so causes headaches with computing deltas up front, though,
    // because the edges may change during sorting.
    //

    LPD3DTLVERTEX pVTmp;
    UINT uReversed;

    uReversed = 0;
    if (pV0->dvSY <= pV1->dvSY)
    {
        if (pV1->dvSY <= pV2->dvSY)
        {
            // Sorted.
        }
        else if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 0 2 1.
            pVTmp = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 2 0 1.
            pVTmp = pV0;
            pV0 = pV2;
            pV2 = pV1;
            pV1 = pVTmp;
        }
    }
    else if (pV1->dvSY < pV2->dvSY)
    {
        if (pV0->dvSY <= pV2->dvSY)
        {
            // Sorted order is 1 0 2.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pVTmp;
            uReversed = 1;
        }
        else
        {
            // Sorted order is 1 2 0.
            pVTmp = pV0;
            pV0 = pV1;
            pV1 = pV2;
            pV2 = pVTmp;
        }
    }
    else
    {
        // Sorted order is 2 1 0.
        pVTmp = pV0;
        pV0 = pV2;
        pV2 = pVTmp;
        uReversed = 1;
    }

    FLOAT fX0 = pV0->dvSX;
    FLOAT fX1 = pV1->dvSX;
    FLOAT fX2 = pV2->dvSX;
    FLOAT fY0 = pV0->dvSY;
    FLOAT fY1 = pV1->dvSY;
    FLOAT fY2 = pV2->dvSY;

    //
    // Compute x,y deltas.
    //
    m_StpCtx.fDX10 = fX1 - fX0;
    m_StpCtx.fDX20 = fX2 - fX0;
    m_StpCtx.fDY10 = fY1 - fY0;
    m_StpCtx.fDY20 = fY2 - fY0;

    //
    // Compute determinant and do culling.
    //
    FLOAT fDet;

    fDet = m_StpCtx.fDX20 * m_StpCtx.fDY10 - m_StpCtx.fDX10 * m_StpCtx.fDY20;
    if (FLOAT_EQZ(fDet))
    {
        // No area, so bail out
        return FALSE;
    }

    // Get sign of determinant.
    UINT uDetCcw = FLOAT_GTZ(fDet) ? 1 : 0;

    // If culling is off the cull sign to check against is set to a
    // value that can't be matched so this single check is sufficient
    // for all three culling cases.
    //
    // Fold in sign reversal here rather than in uDetCcw because
    // we need the true sign later to determine whether the long edge is
    // to the left or the right.
    if ((uDetCcw ^ uReversed) == m_StpCtx.pCtx->uCullFaceSign)
    {
        return FALSE;
    }

    // Snap bounding vertex Y's to pixel centers and check for trivial reject.

    m_StpCtx.iY = ICEILF(fY0);
    m_iY2 = ICEILF(fY2);

    if (m_StpCtx.iY >= m_StpCtx.pCtx->Clip.bottom ||
        m_iY2 <= m_StpCtx.pCtx->Clip.top)
    {
        return FALSE;
    }

    INT iX0 = ICEILF(fX0);
    INT iX1 = ICEILF(fX1);
    INT iX2 = ICEILF(fX2);

    // Start 2 - 0 edge DXDY divide so that it's overlapped with the
    // integer processing done during X clip checking.  The assumption
    // is that it's nearly zero cost when overlapped so it's worth
    // it to start it even when the clip check rejects the triangle.
    FLOAT fDX20, fDY20, fDXDY20;

    // Need to use stack variables so the assembly can understand the
    // address.
    fDX20 = m_StpCtx.fDX20;
    fDY20 = m_StpCtx.fDY20;
    FLD_BEGIN_DIVIDE(fDX20, fDY20, fDXDY20);

    // Computing the X triangle bounds involves quite a few operations,
    // but it allows for both trivial rejection and trivial acceptance.
    // Given that guard band clipping can lead to a lot of trivial rejections
    // and that there will usually be a lot of trivial acceptance cases,
    // the work is worth it.

    INT iMinX, iMaxX;
    BOOL bXAccept;

    MINMAX3(iX0, iX1, iX2, iMinX, iMaxX);

    m_iXWidth = iMaxX - iMinX;

    // Use X bounds for trivial reject and accept.
    if (iMinX >= m_StpCtx.pCtx->Clip.right ||
        iMaxX <= m_StpCtx.pCtx->Clip.left ||
        m_iXWidth <= 0)
    {
        bXAccept = FALSE;
    }
    else
    {
        if (iMinX >= m_StpCtx.pCtx->Clip.left &&
            iMaxX <= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.uFlags |= PRIMF_TRIVIAL_ACCEPT_X;
        }
        else
        {
            RSDPFM((RSM_XCLIP, "XClip bounds %5d - %5d, %5d\n",
                    iMinX, iMaxX, m_iXWidth));
        }

        bXAccept = TRUE;
    }

    // Complete divide.
    FSTP_END_DIVIDE(fDXDY20);

    if (!bXAccept)
    {
        return FALSE;
    }

    // Clamp triangle Y's to clip rect.

    m_iY1 = ICEILF(fY1);

    if (m_StpCtx.iY < m_StpCtx.pCtx->Clip.top)
    {
        RSDPFM((RSM_YCLIP, "YClip iY %d to %d\n",
                m_StpCtx.iY, m_StpCtx.pCtx->Clip.top));

        m_StpCtx.iY = m_StpCtx.pCtx->Clip.top;

        if (m_iY1 < m_StpCtx.pCtx->Clip.top)
        {
            RSDPFM((RSM_YCLIP, "YClip iY1 %d to %d\n",
                    m_iY1, m_StpCtx.pCtx->Clip.top));

            m_iY1 = m_StpCtx.pCtx->Clip.top;
        }
    }

    if (m_iY1 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY1 %d, iY2 %d to %d\n",
                m_iY1, m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY1 = m_StpCtx.pCtx->Clip.bottom;
        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }
    else if (m_iY2 > m_StpCtx.pCtx->Clip.bottom)
    {
        RSDPFM((RSM_YCLIP, "YClip iY2 %d to %d\n",
                m_iY2, m_StpCtx.pCtx->Clip.bottom));

        m_iY2 = m_StpCtx.pCtx->Clip.bottom;
    }

    // Compute Y subpixel correction.  This will include any Y
    // offset due to clamping.
    m_StpCtx.fDY = m_StpCtx.iY - fY0;

    // Compute trapzeoid heights.  These will be restricted to
    // lie in the clip rect.

    RSASSERT(m_iY1 >= m_StpCtx.iY && m_iY2 >= m_iY1);

    m_uHeight10 = m_iY1 - m_StpCtx.iY;
    m_uHeight21 = m_iY2 - m_iY1;

    m_uHeight20 = m_uHeight10 + m_uHeight21;
    if (m_uHeight20 == 0)
    {
        // Triangle doesn't cover any pixels.
        return FALSE;
    }

    RSDPFM((RSM_TRIS, "Tstp (%.4f,%.4f) (%.4f,%.4f) (%.4f,%.4f)\n",
            fX0, fY0, fX1, fY1, fX2, fY2));
    RSDPFM((RSM_TRIS, "    (%.4f,%.4f : %.4f,%.4f) %d:%d det %.4f\n",
            m_StpCtx.fDX10, m_StpCtx.fDY10,
            m_StpCtx.fDX20, m_StpCtx.fDY20,
            m_uHeight10, m_uHeight21, fDet));
    RSDPFM((RSM_Z, "    Z (%f) (%f) (%f)\n",
        pV0->dvSZ, pV1->dvSZ, pV2->dvSZ));
    RSDPFM((RSM_DIFF, "    diff (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_DIDX, "    didx (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcColor, pV1->dcColor, pV2->dcColor));
    RSDPFM((RSM_SPEC, "    spec (0x%08X) (0x%08X) (0x%08X)\n",
            pV0->dcSpecular & 0xffffff, pV1->dcSpecular & 0xffffff,
            pV2->dcSpecular & 0xffffff));
    RSDPFM((RSM_OOW, "    OoW (%f) (%f) (%f)\n",
            pV0->dvRHW, pV1->dvRHW, pV2->dvRHW));
    RSDPFM((RSM_TEX1, "    Tex1 (%f,%f) (%f,%f) (%f,%f)\n",
            pV0->dvTU, pV0->dvTV, pV1->dvTU, pV1->dvTV,
            pV2->dvTU, pV2->dvTV));
    RSDPFM((RSM_FOG, "    Fog (0x%02X) (0x%02X) (0x%02X)\n",
            RGBA_GETALPHA(pV0->dcSpecular),
            RGBA_GETALPHA(pV1->dcSpecular),
            RGBA_GETALPHA(pV2->dcSpecular)));

    // Compute dx/dy for edges and initial X's.

    m_StpCtx.fDX = m_StpCtx.fDY * fDXDY20;
    FLOAT fX20 = fX0 + m_StpCtx.fDX;

    ComputeIntCarry(fX20, fDXDY20, &m_StpCtx.X20);
    m_StpCtx.fX20NC = (FLOAT)m_StpCtx.X20.iNC;
    m_StpCtx.fX20CY = (FLOAT)m_StpCtx.X20.iCY;

    RSDPFM((RSM_TRIS, "    edge20  %f dxdy %f\n", fX20, fDXDY20));
    RSDPFM((RSM_TRIS, "            (?.%d d %d nc %d cy %d)\n",
            m_StpCtx.X20.iFrac,
            m_StpCtx.X20.iDFrac, m_StpCtx.X20.iNC, m_StpCtx.X20.iCY));

    if (m_uHeight10 > 0)
    {
        FLOAT fDXDY10;
        FLOAT fX10;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_EQZ(m_StpCtx.fDX10))
        {
            fDXDY10 = g_fZero;
            fX10 = fX0;
        }
        else
#endif
        {
            fDXDY10 = m_StpCtx.fDX10 / m_StpCtx.fDY10;
            fX10 = fX0 + m_StpCtx.fDY * fDXDY10;
        }

        m_StpCtx.X10.iV = ICEILF(fX10);
        ComputeIntCarry(fX10, fDXDY10, &m_StpCtx.X10);

        RSDPFM((RSM_TRIS, "    edge10  %f dxdy %f\n", fX10, fDXDY10));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X10.iV, m_StpCtx.X10.iFrac,
                m_StpCtx.X10.iDFrac, m_StpCtx.X10.iNC, m_StpCtx.X10.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X10, 0, sizeof(m_StpCtx.X10));
    }
#endif

    if (m_uHeight21 > 0)
    {
        FLOAT fDXDY21;
        FLOAT fX21;

#ifdef CHECK_VERTICAL
        // This case probably doesn't occur enough to justify the code.
        if (FLOAT_COMPARE(fX1, ==, fX2))
        {
            fDXDY21 = g_fZero;
            fX21 = fX1;
        }
        else
#endif
        {
            fDXDY21 = (fX2 - fX1) / (fY2 - fY1);
            fX21 = fX1 + (m_iY1 - fY1) * fDXDY21;
        }

        m_StpCtx.X21.iV = ICEILF(fX21);
        ComputeIntCarry(fX21, fDXDY21, &m_StpCtx.X21);

        RSDPFM((RSM_TRIS, "    edge21  %f dxdy %f\n", fX21, fDXDY21));
        RSDPFM((RSM_TRIS, "            (%d.%d d %d nc %d cy %d)\n",
                m_StpCtx.X21.iV, m_StpCtx.X21.iFrac,
                m_StpCtx.X21.iDFrac, m_StpCtx.X21.iNC, m_StpCtx.X21.iCY));
    }
#if DBG
    else
    {
        // Make it easier to detect when an invalid edge is used.
        memset(&m_StpCtx.X21, 0, sizeof(m_StpCtx.X21));
    }
#endif

    // The edge walker always walks the long edge so it may either
    // be a left or a right edge.  Determine what side the long edge
    // is and perform appropriate snapping and subpixel adjustment
    // computations.
    //
    // The clip-clamped initial X pixel position is also computed and
    // any necessary offset added into the subpixel correction delta.

    if (uDetCcw)
    {
        // Long edge (0-2) is to the right.

        m_StpCtx.uFlags |= TRIF_X_DEC;
        m_StpCtx.pPrim->uFlags = D3DI_RASTPRIM_X_DEC;

        m_StpCtx.X20.iV = ICEILF(fX20) - 1;

        // Other edges are left edges.  Bias them back by one
        // so that the span width computation can do R - L
        // rather than R - L + 1.
        m_StpCtx.X10.iV--;
        m_StpCtx.X21.iV--;

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV >= m_StpCtx.pCtx->Clip.right)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.right - 1;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }
    else
    {
        // Long edge (0-2) is to the left.

        m_StpCtx.pPrim->uFlags = 0;

        m_StpCtx.X20.iV = ICEILF(fX20);

        // Other edges are right edges.  The ICEILF snapping done
        // already leaves them off by one so that R - L works.

        // Clamp the initial X position.
        if (m_StpCtx.X20.iV < m_StpCtx.pCtx->Clip.left)
        {
            m_StpCtx.iX = m_StpCtx.pCtx->Clip.left;
        }
        else
        {
            m_StpCtx.iX = m_StpCtx.X20.iV;
        }
    }

    // Update X subpixel correction.  This delta includes any
    // offseting due to clamping of the initial pixel position.
    m_StpCtx.fDX += m_StpCtx.iX - fX20;

    RSDPFM((RSM_TRIS, "    subp    %f,%f\n", m_StpCtx.fDX, m_StpCtx.fDY));

    // Compute span-to-span steps for buffer pointers.
    m_StpCtx.DAttrNC.ipSurface = m_StpCtx.pCtx->iSurfaceStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iSurfaceStep;
    m_StpCtx.DAttrNC.ipZ = m_StpCtx.pCtx->iZStride +
        m_StpCtx.X20.iNC * m_StpCtx.pCtx->iZStep;

    // Start one over determinant divide.  Done after the multiplies
    // since integer multiplies require some of the FP unit.

    FLOAT fOoDet;

    FLD_BEGIN_DIVIDE(g_fOne, fDet, fOoDet);

    if (m_StpCtx.X20.iCY > m_StpCtx.X20.iNC)
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface +
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ + m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrCY.ipSurface = m_StpCtx.DAttrNC.ipSurface -
            m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrCY.ipZ = m_StpCtx.DAttrNC.ipZ - m_StpCtx.pCtx->iZStep;
    }

    //
    // Compute attribute functions.
    //

    // Set pure X/Y step deltas for surface and Z so that DX, DY, CY and NC all
    // have complete information and can be used interchangeably.
    if (m_StpCtx.uFlags & TRIF_X_DEC)
    {
        m_StpCtx.DAttrDX.ipSurface = -m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = -m_StpCtx.pCtx->iZStep;
    }
    else
    {
        m_StpCtx.DAttrDX.ipSurface = m_StpCtx.pCtx->iSurfaceStep;
        m_StpCtx.DAttrDX.ipZ = m_StpCtx.pCtx->iZStep;
    }
    m_StpCtx.DAttrDY.ipSurface = m_StpCtx.pCtx->iSurfaceStride;
    m_StpCtx.DAttrDY.ipZ = m_StpCtx.pCtx->iZStride;

    // Finish overlapped divide.
    FSTP_END_DIVIDE(fOoDet);

    m_StpCtx.fOoDet = fOoDet;

    // The PrimProcessor is created zeroed out so the initial
    // state is FP clean.  Later uses may put FP values in slots but
    // they should still be valid, so the optional computations here
    // should never result in FP garbage.  It should therefore be
    // OK to use any mixture of attribute handlers since there should
    // never be any case where FP garbage will creep in.

    BOOL bNorm;

    // USED checks cannot be combined since TEX_USED is a multibit check.
    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        (m_StpCtx.uFlags & PRIMSF_PERSP_USED) &&
        (m_uPpFlags & PPF_NORMALIZE_RHW) &&
        NEEDS_NORMALIZE3(pV0->dvRHW, pV1->dvRHW, pV2->dvRHW))
    {
        NormalizeTriRHW(pV0, pV1, pV2);
        bNorm = TRUE;
    }
    else
    {
        bNorm = FALSE;
    }

    TriSetup_Start(&m_StpCtx, pV0, pV1, pV2);

    if (bNorm)
    {
        pV0->dvRHW = m_dvV0RHW;
        pV1->dvRHW = m_dvV1RHW;
        pV2->dvRHW = m_dvV2RHW;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\rsdbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSetupOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(RSM, TRIS),
    DBG_DECLARE_MODFLAG(RSM, LINES),
    DBG_DECLARE_MODFLAG(RSM, POINTS),
    DBG_DECLARE_MODFLAG(RSM, Z),
    DBG_DECLARE_MODFLAG(RSM, DIFF),
    DBG_DECLARE_MODFLAG(RSM, SPEC),
    DBG_DECLARE_MODFLAG(RSM, OOW),
    DBG_DECLARE_MODFLAG(RSM, LOD),
    DBG_DECLARE_MODFLAG(RSM, TEX1),
    DBG_DECLARE_MODFLAG(RSM, TEX2),
    DBG_DECLARE_MODFLAG(RSM, XCLIP),
    DBG_DECLARE_MODFLAG(RSM, YCLIP),
    DBG_DECLARE_MODFLAG(RSM, BUFFER),
    DBG_DECLARE_MODFLAG(RSM, BUFPRIM),
    DBG_DECLARE_MODFLAG(RSM, BUFSPAN),
    DBG_DECLARE_MODFLAG(RSM, FLAGS),
    DBG_DECLARE_MODFLAG(RSM, WALK),
    DBG_DECLARE_MODFLAG(RSM, DIDX),
    0, NULL,
};
static DebugModuleFlags g_RastSetupUserFlags[] =
{
    DBG_DECLARE_MODFLAG(RSU, BREAK_ON_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, MARK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, CHECK_SPAN_EDGES),
    DBG_DECLARE_MODFLAG(RSU, NO_RENDER_SPANS),
    DBG_DECLARE_MODFLAG(RSU, FORCE_GENERAL_WALK),
    DBG_DECLARE_MODFLAG(RSU, FORCE_PIXEL_SPANS),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSetup, RS,
                 g_RastSetupOutputFlags, 0,
                 g_RastSetupUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\walk.cpp ===
//----------------------------------------------------------------------------
//
// walk.cpp
//
// TriProcessor edge walking methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_Clip
//
// Walks the given number of spans, using edge 0 - 2 as the attribute
// edge and the given X and DXDY for the other edge.
// Spans are clipped in X against the current clip rect.
//
// The spans can be split into subspans if required.  cPixSplit indicates
// the maximum length span that should be recorded.  Any longer spans will
// be cut into multiple span segments.
//
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_Clip(UINT uSpans, PINTCARRYVAL pXOther,
                             PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    INT cTotalPix;
    INT cPix;
    INT uX, uXO;
    BOOL b20Valid;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;
    uSpansAvail = 0;
    
    for (;;)
    {
        //
        // Clip span and compute length.  No attributes need to be
        // updated here because attributes have already been moved
        // inside the clip boundary.
        //

        uX = pStpCtx->X20.iV;
        uXO = pXOther->iV;
        b20Valid = TRUE;

        RSDPFM((RSM_WALK, "Full span at Y %d, %d - %d\n",
                pStpCtx->iY, uX,
                (pStpCtx->uFlags & TRIF_X_DEC) ? uXO + 1 : uXO - 1));
        
        if (pStpCtx->uFlags & TRIF_X_DEC)
        {
            if (uX >= pStpCtx->pCtx->Clip.right)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.right - 1;
            }
            else if (uX < pStpCtx->pCtx->Clip.left &&
                     pStpCtx->X20.iCY <= 0)
            {
                // Right edge has crossed the left clip boundary
                // travelling left so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }


            // -1 because this edge is displaced by one.
            if (uXO < pStpCtx->pCtx->Clip.left - 1)
            {
                uXO = pStpCtx->pCtx->Clip.left - 1;
            }

            cTotalPix = uX - uXO;
        }
        else
        {
            if (uX < pStpCtx->pCtx->Clip.left)
            {
                b20Valid = FALSE;
                uX = pStpCtx->pCtx->Clip.left;
            }
            else if (uX >= pStpCtx->pCtx->Clip.right &&
                     pStpCtx->X20.iCY >= 0)
            {
                // Left edge has crossed the right clip boundary
                // travelling right so the remainder of the triangle
                // will not be visible.
                goto EH_Exit;
            }

            if (uXO > pStpCtx->pCtx->Clip.right)
            {
                uXO = pStpCtx->pCtx->Clip.right;
            }

            cTotalPix = uXO - uX;
        }

        if (cTotalPix > 0)
        {
            ATTRSET Attr;
            PATTRSET pAttr;

            // Start without PWL support since the first iteration doesn't
            // have precomputed values.
            pStpCtx->uPwlFlags = 0;
            
            pAttr = &pStpCtx->Attr;
        
            for (;;)
            {
                if (uSpansAvail == 0)
                {
                    // We don't really have a good number to request
                    // since uSpans could result in any number of span
                    // fragments after dicing.  Using uSpans is OK
                    // as long as uSpans is relatively large, but if
                    // uSpans gets small and there's a lot of dicing then
                    // it would result in excessive AllocSpans calls.
                    // Try to avoid this problem by lower-bounding the
                    // request.  Any excess spans will be given back
                    // at the end.
                    uSpansAvail = min(8, uSpans);
                    hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                    if (hr != D3D_OK)
                    {
                        // uSpansAvail is set to zero on failure.
                        goto EH_Exit;
                    }
                }
                else
                {
                    pSpan++;
                }
                uSpansAvail--;
                pStpCtx->pPrim->uSpans++;

                // Split up remaining pixels if necessary.
                cPix = min(cTotalPix, pStpCtx->cMaxSpan);

                pSpan->uPix = (UINT16)cPix;
                pSpan->uX = (UINT16)uX;
                pSpan->uY = (UINT16)pStpCtx->iY;

                RSDPFM((RSM_WALK, "  Seg at Y %d, X %d, %c%d pix (%d, %d)\n",
                        pStpCtx->iY, uX,
                        (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                        cPix, cTotalPix, pStpCtx->cMaxSpan));

                pStpCtx->pfnFillSpanAttrs(pAttr, pSpan, pStpCtx, cPix);

                cTotalPix -= cPix;
                if (cTotalPix <= 0)
                {
                    break;
                }

                // There are still pixels left in the span so the loop's
                // going to go around again.  Update all the attribute
                // values by cPix dX steps.
                //
                // We don't want to update the real edge attributes so we
                // need to work with a copy.  We do this lazily to
                // avoid the data movement for the normal case where
                // the span isn't split.
                if (pAttr == &pStpCtx->Attr)
                {
                    Attr = pStpCtx->Attr;
                    pAttr = &Attr;
                }

                if (pStpCtx->uFlags & TRIF_X_DEC)
                {
                    uX -= cPix;
                }
                else
                {
                    uX += cPix;
                }
                pStpCtx->pfnAddScaledAttrs(pAttr, &pStpCtx->DAttrDX,
                                           pStpCtx, cPix);
            }
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        // See if the edge has crossed a clip boundary.
        cPix = 0;
        if (b20Valid)
        {
            // Always take a normal step.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

            // See if the edge crossed out of the clip rect and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV >= pStpCtx->pCtx->Clip.right)
                {
                    cPix = pStpCtx->X20.iV - (pStpCtx->pCtx->Clip.right - 1);
                }
            }
            else
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->pCtx->Clip.left - pStpCtx->X20.iV;
                }
            }
        }
        else
        {
            // Always step in Y.
            pStpCtx->pfnAddAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDY, pStpCtx);

            // See if the edge crossed into validity and if so,
            // how far.
            if (pStpCtx->uFlags & TRIF_X_DEC)
            {
                if (pStpCtx->X20.iV < pStpCtx->pCtx->Clip.right - 1)
                {
                    cPix = (pStpCtx->pCtx->Clip.right - 1) - pStpCtx->X20.iV;
                }
            }
            else
            {
                if (pStpCtx->X20.iV > pStpCtx->pCtx->Clip.left)
                {
                    cPix = pStpCtx->X20.iV - pStpCtx->pCtx->Clip.left;
                }
            }
        }

        if (cPix > 0)
        {
            // The edge made a validity transition.  Either the
            // attributes are sitting back at the edge of validity and
            // need to move forward or they've left the clip rect and
            // need to move back.  Either way, cPix has the
            // number of pixels to move in X.
            
            // No precomputed values.
            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnAddScaledAttrs(&pStpCtx->Attr, &pStpCtx->DAttrDX,
                                       pStpCtx, cPix);
        }

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
// WalkTrapEitherSpans_Any_NoClip
//
// WalkTrapSpans specialized for the trivial-accept clipping case.
// Span dicing is also unsupported.
// Calls attribute handler functions so all attributes are supported.
// Attributes are never touched directly so both fixed and float are supported.
//
//----------------------------------------------------------------------------

HRESULT FASTCALL
WalkTrapEitherSpans_Any_NoClip(UINT uSpans, PINTCARRYVAL pXOther,
                               PSETUPCTX pStpCtx, BOOL bAdvanceLast)
{
    PD3DI_RASTSPAN pSpan;
    HRESULT hr;
    PINTCARRYVAL pXLeft, pXRight;
    UINT uSpansAvail;

    RSASSERT(uSpans > 0);
    
    hr = D3D_OK;

    if (pStpCtx->uFlags & TRIF_X_DEC)
    {
        pXLeft = pXOther;
        pXRight = &pStpCtx->X20;
    }
    else
    {
        pXLeft = &pStpCtx->X20;
        pXRight = pXOther;
    }

    uSpansAvail = 0;

    for (;;)
    {
        if (pXRight->iV > pXLeft->iV)
        {
            if (uSpansAvail == 0)
            {
                uSpansAvail = uSpans;
                hr = ALLOC_SPANS(pStpCtx, &uSpansAvail, &pSpan);
                if (hr != D3D_OK)
                {
                    // uSpansAvail is set to zero on failure.
                    goto EH_Exit;
                }
            }
            else
            {
                pSpan++;
            }
            uSpansAvail--;
            pStpCtx->pPrim->uSpans++;

            pSpan->uPix = (UINT16)(pXRight->iV - pXLeft->iV);
            pSpan->uX = (UINT16)pStpCtx->X20.iV;
            pSpan->uY = (UINT16)pStpCtx->iY;

            RSDPFM((RSM_WALK, "Span at Y %d, X %d, %c%d pix\n",
                    pStpCtx->iY, pSpan->uX,
                    (pStpCtx->uFlags & TRIF_X_DEC) ? '-' : '+',
                    pSpan->uPix));

            pStpCtx->uPwlFlags = 0;
            pStpCtx->pfnFillSpanAttrs(&pStpCtx->Attr, pSpan, pStpCtx, 1);
        }

        uSpans--;

        // If this is truly the last span of the triangle then we can stop,
        // but if it's just the last span of the top trapezoid then we
        // still need to advance the attributes on the long edge so
        // they're correct for the next trapzoid's first span.
        if (!bAdvanceLast && uSpans == 0)
        {
            break;
        }

        //
        // Advance long edge and all attributes.
        //

        pStpCtx->iY++;
        
        PATTRSET pDelta;

        pStpCtx->X20.iFrac += pStpCtx->X20.iDFrac;
        if (pStpCtx->X20.iFrac < 0)
        {
            // Carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iCY;
            pStpCtx->X20.iFrac &= 0x7fffffff;
            pDelta = &pStpCtx->DAttrCY;
        }
        else
        {
            // No-carry step.

            pStpCtx->X20.iV += pStpCtx->X20.iNC;
            pDelta = &pStpCtx->DAttrNC;
        }

        pStpCtx->pfnAddAttrs(&pStpCtx->Attr, pDelta, pStpCtx);

        // Long edge updating is done so we can always stop here if we're out
        // of spans.
        if (uSpans == 0)
        {
            break;
        }

        // Advance other edge.
        pXOther->iFrac += pXOther->iDFrac;
        if (pXOther->iFrac < 0)
        {
            // Carry step.
            pXOther->iV += pXOther->iCY;
            pXOther->iFrac &= 0x7fffffff;
        }
        else
        {
            // No-carry step.
            pXOther->iV += pXOther->iNC;
        }
    }

 EH_Exit:
    if (uSpansAvail > 0)
    {
        FREE_SPANS(pStpCtx, uSpansAvail);
    }
    
    return hr;
}

//
// Tables of edge walkers.
// Indexing is with the low four TRISF_*_USED bits.
//

#if !defined(_X86_) || defined(X86_CPP_WALKTRAPSPANS)
#define WalkTrapFloatSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Diff_Spec_Tex1_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex1_Tex2_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_DIdx_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFloatSpans_Z_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Diff_Spec_Tex1_NoClip \
    WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex1_Tex2_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_DIdx_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#define WalkTrapFixedSpans_Z_Tex1_NoClip WalkTrapEitherSpans_Any_NoClip
#endif

// Trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFloatSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFloatSpans_Z_Diff_Tex1_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFloatSpans_Z_Diff_Spec_Tex1_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFloatSpans_Z_Tex1_Tex2_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#ifdef STEP_FIXED
PFN_WALKTRAPSPANS g_pfnWalkTrapFixedSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -2 -1 -S -D */
    WalkTrapFixedSpans_Z_Diff_NoClip,                   /* 1: -2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 2: -2 -1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_NoClip,              /* 3: -2 -1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 4: -2 +1 -S -D */
    WalkTrapFixedSpans_Z_Diff_Tex1_NoClip,              /* 5: -2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 6: -2 +1 +S -D */
    WalkTrapFixedSpans_Z_Diff_Spec_Tex1_NoClip,         /* 7: -2 +1 +S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 8: +2 -1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 9: +2 -1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* A: +2 -1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* B: +2 -1 +S +D */
    WalkTrapFixedSpans_Z_Tex1_Tex2_NoClip,              /* C: +2 +1 -S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* D: +2 +1 -S +D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* E: +2 +1 +S -D */
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* F: +2 +1 +S +D */
};
#endif

// Ramp mode trivial accept walkers.
PFN_WALKTRAPSPANS g_pfnRampWalkTrapFloatSpansNoClipTable[] =
{
    (PFN_WALKTRAPSPANS)DebugBreakFn,                    /* 0: -I -1 */
    WalkTrapFloatSpans_Z_Tex1_NoClip,                   /* 1: -I +1 */
    WalkTrapFloatSpans_Z_DIdx_NoClip,                   /* 2: +I -1 */
    WalkTrapFloatSpans_Z_DIdx_Tex1_NoClip,              /* 3: +I +1 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\sources.inc ===
TARGETNAME = rsetup
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY)

#C_DEFINES = $(C_DEFINES) -DSTEP_FIXED

SOURCES = \
        ..\attrs.cpp\
        ..\buffer.cpp\
        ..\line.cpp\
        ..\lstp.cpp\
        ..\point.cpp\
        ..\primproc.cpp\
        ..\rsdbg.cpp\
        ..\tri.cpp\
        ..\tstp.cpp\
        ..\walk.cpp

NTTARGETFILE0 = $(NTTARGETFILE0) \
        $O\attrs_mh.h\
        $O\tstp_mh.h\
        $O\walk_mh.h

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\rsdbg.hpp ===
//----------------------------------------------------------------------------
//
// rsdbg.hpp
//
// Setup debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _RSDBG_HPP_
#define _RSDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(RS);

#define RSDPF(Args)             DBG_DECLARE_DPF(RS, Args)
#define RSDPFM(Args)            DBG_DECLARE_DPFM(RS, Args)
#define RSASSERT(Exp)           DBG_DECLARE_ASSERT(RS, Exp)
#define RSASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(RS, Exp, Args)
#define RSVERIFY(Exp)           DBG_DECLARE_VERIFY(RS, Exp)
#define RSVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(RS, Exp, Args)
#define RSPROMPT(Args)          DBG_DECLARE_PROMPT(RS, Args)
#define RSGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(RS, Idx)
#define RSSETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(RS, Idx, Value)
#define RSHRCHK(Exp)            DBG_DECLARE_HRCHK(RS, Exp)
#define RSHRGO(Exp, Label)      DBG_DECLARE_HRGO(RS, Exp, Label)
#define RSHRERR(Exp)            DBG_DECLARE_HRERR(RS, Exp)
#define RSHRRET(Exp)            DBG_DECLARE_HRRET(RS, Exp)

#define RSM_TRIS                0x00000001
#define RSM_LINES               0x00000002
#define RSM_POINTS              0x00000004
#define RSM_Z                   0x00000008
#define RSM_DIFF                0x00000010
#define RSM_SPEC                0x00000020
#define RSM_OOW                 0x00000040
#define RSM_LOD                 0x00000080
#define RSM_TEX1                0x00000100
#define RSM_TEX2                0x00000200
#define RSM_FOG                 0x00000400
#define RSM_XCLIP               0x00000800
#define RSM_YCLIP               0x00001000
#define RSM_BUFFER              0x00002000
#define RSM_BUFPRIM             0x00004000
#define RSM_BUFSPAN             0x00008000
#define RSM_FLAGS               0x00010000
#define RSM_WALK                0x00020000
#define RSM_DIDX                0x00040000

#define RSU_BREAK_ON_RENDER_SPANS       0x00000001
#define RSU_MARK_SPAN_EDGES             0x00000002
#define RSU_CHECK_SPAN_EDGES            0x00000004
#define RSU_NO_RENDER_SPANS             0x00000008
#define RSU_FORCE_GENERAL_WALK          0x00000010
#define RSU_FORCE_PIXEL_SPANS           0x00000020
#define RSU_FLUSH_AFTER_PRIM            0x00000040

#endif // #ifndef _RSDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\primproc.cpp ===
//----------------------------------------------------------------------------
//
// primproc.cpp
//
// Miscellaneous PrimProcessor methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

//----------------------------------------------------------------------------
//
// PrimProcessor::BeginPrimSet
//
// Marks the start of a set of primitives that have the same vertex type.
// Computes attributes used from the current state and the vertex type.
//
//----------------------------------------------------------------------------

void
PrimProcessor::BeginPrimSet(D3DPRIMITIVETYPE PrimType,
                            RAST_VERTEX_TYPE VertType)
{
    // If state hasn't changed and the primitive and vertex types match the
    // ones we're already set up for there's no work to do.
    if ((m_uPpFlags & PPF_STATE_CHANGED) == 0 &&
        VertType == m_VertType &&
        PrimType == m_PrimType)
    {
        return;
    }

    m_StpCtx.uFlags &= ~PRIMSF_ALL;

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_STENCILENABLE])
    {
        m_StpCtx.uFlags |= PRIMSF_Z_USED;
    }

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Index is unused during copy mode texturing.
        if (m_StpCtx.pCtx->pdwRenderState
            [D3DRENDERSTATE_TEXTUREMAPBLEND] != D3DTBLEND_COPY ||
            m_StpCtx.pCtx->cActTex == 0)
        {
            m_StpCtx.uFlags |= PRIMSF_DIDX_USED;
        }
    }
    else
    {
        // ATTENTION - Don't set these for copy mode texture?  Is
        // copy mode texture meaningful in RGB?
        m_StpCtx.uFlags |= PRIMSF_DIFF_USED;
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SPECULARENABLE])
        {
            m_StpCtx.uFlags |= PRIMSF_SPEC_USED;
        }
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_SHADEMODE] ==
        D3DSHADE_FLAT)
    {
        m_StpCtx.uFlags |= PRIMSF_FLAT_SHADED;
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        m_StpCtx.uFlags |= PRIMSF_TEX1_USED;
        DDASSERT((m_StpCtx.pCtx->pTexture[0]->uFlags & D3DI_SPANTEX_NON_POWER_OF_2) == 0);

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            m_StpCtx.uFlags |= PRIMSF_TEX2_USED;
            DDASSERT((m_StpCtx.pCtx->pTexture[1]->uFlags & D3DI_SPANTEX_NON_POWER_OF_2) == 0);
        }
    }

    if ((m_StpCtx.uFlags & PRIMSF_TEX_USED) &&
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
    {
        m_StpCtx.uFlags |= PRIMSF_PERSP_USED;
    }

    // Currently only tex1 can be mipmapped.
    if (((m_StpCtx.uFlags & PRIMSF_TEX1_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[0]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[0]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[0]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[0]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    // select between min and mag filters for TEX2
    if (((m_StpCtx.uFlags & PRIMSF_TEX2_USED) &&
        (PrimType == D3DPT_TRIANGLELIST ||
         PrimType == D3DPT_TRIANGLESTRIP ||
         PrimType == D3DPT_TRIANGLEFAN) &&
        (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FILLMODE]
         == D3DFILL_SOLID)) &&

        (((m_StpCtx.pCtx->pTexture[1]->cLOD >= 1) &&
        (m_StpCtx.pCtx->pTexture[1]->uMipFilter != D3DTFP_NONE)) ||
        // need LOD if we need to dynamically switch between different min
        // and mag filters
        (m_StpCtx.pCtx->pTexture[1]->uMinFilter !=
         m_StpCtx.pCtx->pTexture[1]->uMagFilter)))
    {
        m_StpCtx.uFlags |= PRIMSF_LOD_USED;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGENABLE])
    {
        // Note, if PWL_FOG is ever brought back to life, enabling
        // PRIMSF_GLOBAL_FOG_USED with no Z buffer will not trivially work
        // if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            switch (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
            {
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                m_StpCtx.uFlags |= PRIMSF_GLOBAL_FOG_USED;
#ifndef PWL_FOG
                // The span routines don't support table fog directly.
                // Instead table fog is computed per vertex and used to
                // set up local fog.
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
#endif
                break;
            default:
                m_StpCtx.uFlags |= PRIMSF_LOCAL_FOG_USED;
                break;
            }
        }
    }

    PFN_ADDATTRS *ppfnAddAttrsTable;
    PFN_ADDSCALEDATTRS *ppfnAddScaledAttrsTable;
    PFN_FILLSPANATTRS *ppfnFillSpanAttrsTable;

    if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
    {
        // Ramp does not support multitexture.
        RSASSERT((m_StpCtx.uFlags & PRIMSF_TEX2_USED) == 0);

        RSASSERT((PRIMSF_TEX1_USED | PRIMSF_DIDX_USED) == 0x14);

        // Derive a function table index from bits 2 and 4 of usage
        // information.
        // An alternative method would be to use bits 0-4 and have the
        // ramp information in the top 16 entries, but splitting the
        // ramp and RGB tables is cleaner and decouples the table sizes.
        // Decoupling is useful since the ramp possibilities are much
        // more limited so its table can be smaller.

        m_iAttrFnIdx =
            ((m_StpCtx.uFlags & PRIMSF_TEX1_USED) >> 2) |
            ((m_StpCtx.uFlags & PRIMSF_DIDX_USED) >> 3);

        ppfnAddAttrsTable = g_pfnRampAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnRampAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnRampFillSpanFloatAttrsTable;
    }
    else
    {
        RSASSERT((PRIMSF_DIFF_USED | PRIMSF_SPEC_USED | PRIMSF_TEX1_USED |
                  PRIMSF_TEX2_USED) == 0xf);

        // Derive a function table index from the lower four bits of
        // usage information.  The lower bits are deliberately chosen
        // to represent the more performance-sensitive cases while
        // the upper bits generally represent cases handled by generic
        // code.
        //
        // Even restricted to only four bits the index contains unimportant
        // and unreachable cases, such as specular without diffuse or
        // tex2 without tex1.  Tables indexed must account for this.

        m_iAttrFnIdx = m_StpCtx.uFlags & (PRIMSF_DIFF_USED | PRIMSF_SPEC_USED |
                                          PRIMSF_TEX1_USED | PRIMSF_TEX2_USED);

        ppfnAddAttrsTable = g_pfnAddFloatAttrsTable;
        ppfnAddScaledAttrsTable = g_pfnAddScaledFloatAttrsTable;
        ppfnFillSpanAttrsTable = g_pfnFillSpanFloatAttrsTable;
    }

    //
    // These functions only depend on the index and so can be set here.
    // Other functions depend on per-triangle information and are set
    // later.
    //

    if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
    {
        // If any slow attrs are on or Z is off use the general functions.
        m_StpCtx.pfnAddScaledAttrs = AddScaledFloatAttrs_Any_Either;
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
        m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
#endif
    }
    else
    {
        m_StpCtx.pfnAddScaledAttrs =
            ppfnAddScaledAttrsTable[m_iAttrFnIdx];
#ifndef STEP_FIXED
        m_StpCtx.pfnAddAttrs = ppfnAddAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs = ppfnFillSpanAttrsTable[m_iAttrFnIdx];
#endif
    }

    // Attribute beads can be set here.
    PFN_SETUPTRIATTR *ppfnSlot;

    ppfnSlot = &m_StpCtx.pfnTriSetupFirstAttr;
    if (m_StpCtx.uFlags & PRIMSF_Z_USED)
    {
        if (m_StpCtx.pCtx->iZBitCount == 16)
        {
            *ppfnSlot = TriSetup_Z16;
        }
        else
        {
            *ppfnSlot = TriSetup_Z32;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupZEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX1_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex1;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex1;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTex1End;
    }
    if (m_StpCtx.uFlags & PRIMSF_TEX2_USED)
    {
        // Code assumes that tex1 is enabled if tex2 is enabled.
        RSASSERT(m_StpCtx.uFlags & PRIMSF_TEX1_USED);

        if (m_StpCtx.uFlags & PRIMSF_PERSP_USED)
        {
            *ppfnSlot = TriSetup_Persp_Tex2;
        }
        else
        {
            *ppfnSlot = TriSetup_Affine_Tex2;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupTex2End;
    }
    if (m_StpCtx.uFlags & PRIMSF_DIFF_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DiffFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Diff;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    else if (m_StpCtx.uFlags & PRIMSF_DIDX_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_DIdxFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_DIdx;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupDiffEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_SPEC_USED)
    {
        if (m_StpCtx.uFlags & PRIMSF_FLAT_SHADED)
        {
            *ppfnSlot = TriSetup_SpecFlat;
        }
        else
        {
            *ppfnSlot = TriSetup_Spec;
        }
        ppfnSlot = &m_StpCtx.pfnTriSetupSpecEnd;
    }
    if (m_StpCtx.uFlags & PRIMSF_LOCAL_FOG_USED)
    {
        *ppfnSlot = TriSetup_Fog;
        ppfnSlot = &m_StpCtx.pfnTriSetupFogEnd;
    }
    *ppfnSlot = TriSetup_End;

    // Remember the primitive and vertex type and clear the state change bit.
    m_PrimType = PrimType;
    m_VertType = VertType;
    m_uPpFlags &= ~PPF_STATE_CHANGED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\tri.cpp ===
//----------------------------------------------------------------------------
//
// tri.cpp
//
// PrimProcessor top-level triangle methods.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

DBG_DECLARE_FILE();

// Disallow fixed-point edge walkers to be chosen or not.
#if 0
#define DISALLOW_FIXED
#endif

// Maximum length of a PWL span.  Short to make piecewise-linear
// approximation more accurate.
#define MAX_PWL_SPAN_LEN        16
// Maximum normal span length.
#define MAX_SPAN_LEN            256

//----------------------------------------------------------------------------
//
// PrimProcessor::SetTriFunctions
//
// Set up function pointers for triangle processing.
//
//----------------------------------------------------------------------------

inline void
PrimProcessor::SetTriFunctions(void)
{
#if DBG
    if ((RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_PIXEL_SPANS) == 0)
#else
    if ((m_StpCtx.uFlags & TRIF_RASTPRIM_OVERFLOW) == 0)
#endif
    {
        // Valid deltas.  If mipmapping or global fog is on then
        // only allow short subspans so that they can be done
        // reasonably accurately via piecewise linear interpolation.
#ifdef PWL_FOG
        if (m_StpCtx.uFlags & (PRIMSF_LOD_USED | PRIMSF_GLOBAL_FOG_USED))
#else
        if (m_StpCtx.uFlags & PRIMSF_LOD_USED)
#endif
        {
            m_StpCtx.cMaxSpan = MAX_PWL_SPAN_LEN;
        }
        else
        {
            // No mipmapping so we can handle much larger spans.
            // Color values only have 8 bits of fraction so
            // we still need to worry about error accumulation.
            // Cut long spans to cap accumulated error.
            m_StpCtx.cMaxSpan = MAX_SPAN_LEN;
        }
    }
    else
    {
        // Invalid deltas.  There's no way to communicate deltas to
        // the span routines so chop spans into pixels.
        // This case can only occur with very narrow triangles so
        // this isn't as expensive as it might seem at first.
        m_StpCtx.cMaxSpan = 1;
    }

    BOOL bFixed = FALSE;

#ifdef STEP_FIXED
    // No ramp support.
    RSASSERT(m_StpCtx.pCtx->BeadSet != D3DIBS_RAMP);
#endif

    if ((m_StpCtx.uFlags & PRIMF_TRIVIAL_ACCEPT_X) &&
#if DBG
        (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FORCE_GENERAL_WALK) == 0 &&
#endif
        m_iXWidth <= m_StpCtx.cMaxSpan)
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general
            // function.
            m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_NoClip;
        }
#if defined(STEP_FIXED) && !defined(DISALLOW_FIXED)
        // Attribute conversion can be a dominant cost for
        // triangles with very few spans, so avoid using fixed point
        // edge walking for them.
        else if ((m_StpCtx.uFlags & PRIMF_FIXED_OVERFLOW) == 0 &&
                 m_uHeight20 > 3)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFixedSpansNoClipTable[m_iAttrFnIdx];
            bFixed = TRUE;
        }
#endif
        else if (m_StpCtx.pCtx->BeadSet == D3DIBS_RAMP)
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnRampWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
        else
        {
            m_StpCtx.pfnWalkTrapSpans =
                g_pfnWalkTrapFloatSpansNoClipTable[m_iAttrFnIdx];
        }
    }
    else
    {
        // No special cases, just a general function.
        m_StpCtx.pfnWalkTrapSpans = WalkTrapEitherSpans_Any_Clip;
    }

#ifdef STEP_FIXED
    if (bFixed)
    {
        RSASSERT((m_StpCtx.uFlags & PRIMSF_SLOW_USED) == PRIMSF_Z_USED);

        m_StpCtx.pfnAddAttrs = g_pfnAddFixedAttrsTable[m_iAttrFnIdx];
        m_StpCtx.pfnFillSpanAttrs =
            g_pfnFillSpanFixedAttrsTable[m_iAttrFnIdx];

        PFN_FLOATATTRSTOFIXED pfnFloatAttrsToFixed;

        pfnFloatAttrsToFixed = g_pfnFloatAttrsToFixedTable[m_iAttrFnIdx];
        pfnFloatAttrsToFixed(&m_StpCtx.Attr, &m_StpCtx.Attr);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrNC, &m_StpCtx.DAttrNC);
        pfnFloatAttrsToFixed(&m_StpCtx.DAttrCY, &m_StpCtx.DAttrCY);
    }
    else
    {
        if ((m_StpCtx.uFlags & PRIMSF_SLOW_USED) != PRIMSF_Z_USED)
        {
            // If any slow attrs are on or Z is off use the general functions.
            m_StpCtx.pfnAddAttrs = AddFloatAttrs_Any;
            m_StpCtx.pfnFillSpanAttrs = FillSpanFloatAttrs_Any_Either;
        }
        else
        {
            m_StpCtx.pfnAddAttrs = g_pfnAddFloatAttrsTable[m_iAttrFnIdx];
            m_StpCtx.pfnFillSpanAttrs =
                g_pfnFillSpanFloatAttrsTable[m_iAttrFnIdx];
        }
    }

    // Scaled attr functions already set since they only depend on
    // m_iAttrFnIdx.
#else // STEP_FIXED
    // All attr functions already set since they only depend on
    // m_iAttrFnIdx.
#endif // STEP_FIXED
}

//----------------------------------------------------------------------------
//
// PrimProcessor::Tri
//
// Calls triangle setup.  If a triangle is produced by setup
// this routine walks edges, generating spans into the buffer.
//
//----------------------------------------------------------------------------
HRESULT
PrimProcessor::Tri(LPD3DTLVERTEX pV0,
                   LPD3DTLVERTEX pV1,
                   LPD3DTLVERTEX pV2)
{
    HRESULT hr;


    hr = D3D_OK;

    if (m_StpCtx.pCtx->pfnRampOld)
    {
        m_StpCtx.pCtx->pfnRampOldTri(m_StpCtx.pCtx, pV0, pV1, pV2);

        return hr;
    }

#if DBG
    hr = ValidateVertex(pV0);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V0\n"));
        return hr;
    }
    hr = ValidateVertex(pV1);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V1\n"));
        return hr;
    }
    hr = ValidateVertex(pV2);
    if (hr != D3D_OK)
    {
        RSDPF(("PrimProcessor::Tri, Invalid V2\n"));
        return hr;
    }
#endif

    // Clear per-triangle flags.
    m_StpCtx.uFlags &= ~(PRIMF_ALL | TRIF_ALL);

    RSDPFM((RSM_FLAGS, "m_uPpFlags: 0x%08X, m_StpCtx.uFlags: 0x%08X\n",
            m_uPpFlags, m_StpCtx.uFlags));

    RSDPFM((RSM_TRIS, "Tri\n"));
    RSDPFM((RSM_TRIS, "  V0 (%f,%f,%f)\n",
            pV0->dvSX, pV0->dvSY, pV0->dvSZ));
    RSDPFM((RSM_TRIS, "  V1 (%f,%f,%f)\n",
            pV1->dvSX, pV1->dvSY, pV1->dvSZ));
    RSDPFM((RSM_TRIS, "  V2 (%f,%f,%f)\n",
            pV2->dvSX, pV2->dvSY, pV2->dvSZ));

    GET_PRIM();

    // Set up the triangle and see if anything was produced.
    // Triangles may not be produced due to:
    //   Face culling.
    //   Trivial rejection against the clip rect.
    //   Zero pixel coverage.
    if (TriSetup(pV0, pV1, pV2))
    {
        // Compute initial buffer pointers for the scanline.
        m_StpCtx.Attr.pSurface = m_StpCtx.pCtx->pSurfaceBits +
            m_StpCtx.iX * m_StpCtx.pCtx->iSurfaceStep +
            m_StpCtx.iY * m_StpCtx.pCtx->iSurfaceStride;
        if (m_StpCtx.uFlags & PRIMSF_Z_USED)
        {
            m_StpCtx.Attr.pZ = m_StpCtx.pCtx->pZBits +
                m_StpCtx.iX * m_StpCtx.pCtx->iZStep +
                m_StpCtx.iY * m_StpCtx.pCtx->iZStride;
        }

        // uSpans and pNext have already been initialized.

        SetTriFunctions();
        COMMIT_PRIM(FALSE);

        if (m_uHeight10 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight10, &m_StpCtx.X10,
                                           &m_StpCtx, m_uHeight21 > 0);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

        if (m_uHeight21 > 0)
        {
            hr = m_StpCtx.pfnWalkTrapSpans(m_uHeight21, &m_StpCtx.X21,
                                           &m_StpCtx, FALSE);
            if (hr != D3D_OK)
            {
                return hr;
            }
        }

#if DBG
        if (RSGETFLAGS(DBG_USER_FLAGS) & RSU_FLUSH_AFTER_PRIM)
        {
            Flush();
        }
#endif
    }

    return hr;
}

#if DBG
//----------------------------------------------------------------------------
//
// PrimProcessor::ValidateVertex
//
// Checks the ranges of verifiable contents of vertex, to avoid setting up
// garbage.
//
//----------------------------------------------------------------------------
inline HRESULT PrimProcessor::ValidateVertex(LPD3DTLVERTEX pV)
{
    // from the OptSwExtCaps.dvGuardBand caps.
    if ((pV->sx < -32768.f) || (pV->sx > 32767.f) ||
        (pV->sy < -32768.f) || (pV->sy > 32767.f))
    {
        RSDPF(("ValidateVertex: x,y out of guardband range (%f,%f)\n",pV->sx,pV->sy));
        return DDERR_INVALIDPARAMS;
    }

    if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZENABLE] ||
        m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_ZWRITEENABLE])
    {

        // Allow a little slack for those generating triangles exactly on the
        // depth limit.  Needed for Quake.
        if ((pV->sz < -0.00015f) || (pV->sz > 1.00015f))
        {
            RSDPF(("ValidateVertex: z out of range (%f)\n",pV->sz));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (m_StpCtx.pCtx->cActTex > 0)
    {
        if (m_StpCtx.pCtx->pdwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE])
        {
            if (pV->rhw <= 0 )
            {
                RSDPF(("ValidateVertex: rhw out of range (%f)\n",pV->rhw));
                return DDERR_INVALIDPARAMS;
            }
        }

        // from OptSwExtCaps.dwMaxTextureRepeat cap.
        if ((pV->tu > 256.0F) || (pV->tu < -256.0F) ||
            (pV->tv > 256.0F) || (pV->tv < -256.0F))
        {
            RSDPF(("ValidateVertex: tu,tv out of range (%f,%f)\n",pV->tu,pV->tv));
            return DDERR_INVALIDPARAMS;
        }

        if (m_StpCtx.pCtx->cActTex > 1)
        {
            PRAST_GENERIC_VERTEX pGV = (PRAST_GENERIC_VERTEX)pV;
            if ((pGV->tu2 > 256.0F) || (pGV->tu2 < -256.0F) ||
                (pGV->tv2 > 256.0F) || (pGV->tv2 < -256.0F))
            {
                RSDPF(("ValidateVertex: tu2,tv2 out of range (%f,%f)\n",pGV->tu2,pGV->tv2));
                return DDERR_INVALIDPARAMS;
            }
        }
    }

    return D3D_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\sources.inc ===
TARGETNAME = rspanini
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;..\..\refrast;$(INCLUDES);$(_OBJ_DIR)\$(TARGET_DIRECTORY);..\..\rampold

SOURCES = \
        $O\beadstr.cpp\
        $O\spaninit.cpp\
        ..\spindbg.cpp\
        ..\rastcoll.cpp

NTTARGETFILE0 = \
        $O\bdstr_mh.h\
        $O\beadstr.cpp\
        $O\spaninit.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\setup\walkcpp.cpp ===
//----------------------------------------------------------------------------
//
// walkcpp.cpp
//
// C++ trapezoid edge walking functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

// Currently empty.
//
// Could use m4 to generate specialized versions of everything,
// but the only overhead is two function calls per span.  I don't
// think it's important enough to justify the extra code.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\rastcoll.h ===
// RastColl.h - declaration of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCOLL_H_
#define _RASTCOLL_H_

typedef struct _RASTFNREC {
    DWORD           rgdwRastCap[RASTCAPRECORD_SIZE];
    PFNRENDERSPANS  pfnRastFunc;
    int             iIndex;             // index for disable mask
    char            pszRastDesc[128];   // brief human description of monolith
} RASTFNREC;

class CRastCollection {

private:

    RASTFNREC* RastFnLookup(CRastCapRecord*,RASTFNREC*,int);

public:

    RASTFNREC*  Search(PD3DI_RASTCTX,CRastCapRecord*);

};

#endif  // _RASTCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\makefile.inc ===
$(GENTGT)\bdstr_mh.h: ..\bdstr_mh.mh $(RAST_STD_M4)

$(GENTGT)\beadstr.cpp: ..\beadstr.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RAST_STD_M4)

$(GENTGT)\spaninit.cpp: ..\spaninit.mcp ..\bdstr_mh.mh $(RASTROOT)\inc\bead.mh $(RASTROOT)\inc\rampbead.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\spindbg.cpp ===
//----------------------------------------------------------------------------
//
// rsdbg.cpp
//
// Setup debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

static DebugModuleFlags g_RastSpanInitOutputFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIM, INVALID),
    DBG_DECLARE_MODFLAG(SPIM, REPORT),
    0, NULL,
};
static DebugModuleFlags g_RastSpanInitUserFlags[] =
{
    DBG_DECLARE_MODFLAG(SPIU, BREAK_ON_SPANINIT),
    0, NULL,
};
DBG_DECLARE_ONCE(RastSpanInit, SPI,
                 g_RastSpanInitOutputFlags, 0,
                 g_RastSpanInitUserFlags, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include <ddrawpr.h> // This must be included before windows.h to prevent name collisions
#include <windows.h>
#include <ddrawp.h>
#include <ddrawi.h>

#include <d3dp.h>
#include <d3dhal.h>

#include "rast.h"
#include "spindbg.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\bc9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\bcnt\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\win9x\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\daytona\makefile.inc ===
!include ..\..\rastrule.mk
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dcom.h ===
/*
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//  History:    02-7-94   terryru           Created.
//
//----------------------------------------------------------------------------
*/
/*
 * Taken from objbase.h
 */
#ifndef _D3DCOM_H
#define _D3DCOM_H

#include "subwtype.h"

#ifndef WIN32
#define __export
#define __stdcall
#endif /* WIN32 */

typedef void    IUnknown;
#ifndef WINAPI
#define WINAPI
#endif
#define FAR
#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | \
            ((unsigned long)(fac)<<16) | \
             ((unsigned long)(code))))

/* Component Object Model defines, and macros */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef WIN32

/* Win32 doesn't support __export */

#define STDMETHODCALLTYPE       __stdcall
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

/* The 'V' versions allow Variable Argument lists. */

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
/*#define interface               struct FAR */
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface



#else

#define interface               struct


#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)




#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif

#endif /* _D3DCOM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\rastcap.h ===
// rastcap.h - declaration of the CRastCapRecord class
//
// Copyright Microsoft Corporation, 1997.
//

#ifndef _RASTCAP_H_
#define _RASTCAP_H_

// the current size of the rasterizer capability bit vector, in DWORDs.
#define RASTCAPRECORD_SIZE  3

// sets bits in the rasterizer capability bit vector
#define SET_VAL(pos, len, val)  ((m_rgdwData[(pos) / 32]) |= \
                                 (((val) & ~(0xFFFFFFFF << (len))) << \
                                  ((pos) % 32)))

// the positions and lengths of fields in the rasterizer capability bit vector
// note: make sure fields do not straddle DWORD boundaries!  SET_VAL cannot
//       currently handle that
#define ZFUNC_POS               0
#define ZFUNC_LEN               8
#define ZFORMAT_POS             8
#define ZFORMAT_LEN             4
#define ZTEST_POS               12
#define ZTEST_LEN               1
#define ZWRITE_POS              13
#define ZWRITE_LEN              1

#define SHADEMODE_POS           16
#define SHADEMODE_LEN           4
#define SPECULAR_POS            20
#define SPECULAR_LEN            1
#define VERTEXFOG_POS           21
#define VERTEXFOG_LEN           1
#define MONO_POS                22
#define MONO_LEN                1

#define TEXTUREFORMAT_POS       32
#define TEXTUREFORMAT_LEN       8
#define TEXTURE_POS             40
#define TEXTURE_LEN             4
#define TEXTUREBLEND_POS        44
#define TEXTUREBLEND_LEN        4
#define TEXTUREFILTER_POS       48
#define TEXTUREFILTER_LEN       4
#define TEXTUREPERSP_POS        52
#define TEXTUREPERSP_LEN        1
#define TEXTUERBORDER_POS       53
#define TEXTUREBORDER_LEN       1
#define TEXTUREADDR_POS         54
#define TEXTUREADDR_LEN         1
#define TEXTUREMIP_POS          55
#define TEXTUREMIP_LEN          1
#define TEXTURELOD_POS          56
#define TEXTURELOD_LEN          1
#define TEXTURECOLORKEY_POS     57
#define TEXTURECOLORKEY_LEN     1
#define TEXTUREALPHAOVERRIDE_POS 58
#define TEXTUREALPHAOVERRIDE_LEN 1

#define TARGETPIXELFORMAT_POS   64
#define TARGETPIXELFORMAT_LEN   8
#define SRCBLEND_POS            72
#define SRCBLEND_LEN            4
#define DESTBLEND_POS           76
#define DESTBLEND_LEN           4
#define STIPPLE_POS             80
#define STIPPLE_LEN             1
#define DITHER_POS              81
#define DITHER_LEN              1
#define ROP_POS                 82
#define ROP_LEN                 1
#define BLEND_POS               83
#define BLEND_LEN               1
#define ALPHATEST_POS           84
#define ALPHATEST_LEN           1
#define ALPHABLEND_POS          85
#define ALPHABLEND_LEN          1
#define STENCIL_POS             86
#define STENCIL_LEN             1

class CRastCapRecord {

    friend class CRastCollection;

private:

    DWORD   m_rgdwData[RASTCAPRECORD_SIZE];

public:

    CRastCapRecord(void)
    {
        memset(m_rgdwData,0,RASTCAPRECORD_SIZE * sizeof(DWORD));
        return;
    }

    void Set_ZTest(int iZTest)
    {
        SET_VAL(ZTEST_POS,ZTEST_LEN,iZTest);
        return;
    }

    void Set_ZFormat(int iZFormat)
    {
        SET_VAL(ZFORMAT_POS,ZFORMAT_LEN,iZFormat);
        return;
    }

    void Set_ZWrite(int iZWrite)
    {
        SET_VAL(ZWRITE_POS,ZWRITE_LEN,iZWrite);
        return;
    }

    void Set_ZFunc(int iZFunc)
    {
        SET_VAL(ZFUNC_POS,ZFUNC_LEN,iZFunc);
        return;
    }

    void Set_Stipple(int iStipple)
    {
        SET_VAL(STIPPLE_POS,STIPPLE_LEN,iStipple);
        return;
    }

    void Set_AlphaTest(int iAlphaTest)
    {
        SET_VAL(ALPHATEST_POS,ALPHATEST_LEN,iAlphaTest);
        return;
    }

    void Set_ShadeMode(int iShadeMode)
    {
        SET_VAL(SHADEMODE_POS,SHADEMODE_LEN,iShadeMode);
        return;
    }

    void Set_Specular(int iSpecular)
    {
        SET_VAL(SPECULAR_POS,SPECULAR_LEN,iSpecular);
        return;
    }

    void Set_VertexFog(int iVertexFog)
    {
        SET_VAL(VERTEXFOG_POS,VERTEXFOG_LEN,iVertexFog);
        return;
    }

    void Set_Texture(int iTexture)
    {
        SET_VAL(TEXTURE_POS,TEXTURE_LEN,iTexture);
        return;
    }

    void Set_TexturePersp(int iTexturePersp)
    {
        SET_VAL(TEXTUREPERSP_POS,TEXTUREPERSP_LEN,iTexturePersp);
        return;
    }

    void Set_TextureBlend(int iTextureBlend)
    {
        SET_VAL(TEXTUREBLEND_POS,TEXTUREBLEND_LEN,iTextureBlend);
        return;
    }

    // for now, just capture texture state for the first texture
    // and assume monolithics are single textured.
    void Set_TextureBorder(int i, int iTextureBorder)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUERBORDER_POS,TEXTUREBORDER_LEN,iTextureBorder);
        }
        return;
    }

    void Set_TextureAddr(int i, int iTextureAddr)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREADDR_POS,TEXTUREADDR_LEN,iTextureAddr);
        }
        return;
    }

    void Set_TextureFilter(int i, int iTextureFilter)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFILTER_POS,TEXTUREFILTER_LEN,iTextureFilter);
        }
        return;
    }

    void Set_TextureMip(int i, int iTextureMip)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREMIP_POS,TEXTUREMIP_LEN,iTextureMip);
        }
        return;
    }

    void Set_TextureLOD(int i, int iTextureLOD)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURELOD_POS,TEXTURELOD_LEN,iTextureLOD);
        }
        return;
    }

    void Set_TextureFormat(int i, int iTextureFormat)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREFORMAT_POS,TEXTUREFORMAT_LEN,iTextureFormat);
        }
        return;
    }

    void Set_TextureColorKey(int i, int iTextureColorKey)
    {
        if (i == 0)
        {
            SET_VAL(TEXTURECOLORKEY_POS,TEXTURECOLORKEY_LEN,iTextureColorKey);
        }
        return;
    }

    void Set_TextureAlphaOverride(int i, int iTextureAlphaOverride)
    {
        if (i == 0)
        {
            SET_VAL(TEXTUREALPHAOVERRIDE_POS,TEXTUREALPHAOVERRIDE_LEN,iTextureAlphaOverride);
        }
        return;
    }

    void Set_Mono(int iMono)
    {
        SET_VAL(MONO_POS,MONO_LEN,iMono);
        return;
    }

    void Set_AlphaBlend(int iAlphaBlend)
    {
        SET_VAL(ALPHABLEND_POS,ALPHABLEND_LEN,iAlphaBlend);
        return;
    }

    void Set_Blend(int iBlend)
    {
        SET_VAL(BLEND_POS,BLEND_LEN,iBlend);
        return;
    }

    void Set_ROP(int iROP)
    {
        SET_VAL(ROP_POS,ROP_LEN,iROP);
        return;
    }

    void Set_SrcBlend(int iSrcBlend)
    {
        SET_VAL(SRCBLEND_POS,SRCBLEND_LEN,iSrcBlend);
        return;
    }

    void Set_DestBlend(int iDestBlend)
    {
        SET_VAL(DESTBLEND_POS,DESTBLEND_LEN,iDestBlend);
        return;
    }

    void Set_TargetPixelFormat(int iTargetPixelFormat)
    {
        SET_VAL(TARGETPIXELFORMAT_POS,TARGETPIXELFORMAT_LEN,iTargetPixelFormat);
        return;
    }

    void Set_Dither(int iDither)
    {
        SET_VAL(DITHER_POS,DITHER_LEN,iDither);
        return;
    }

    void Set_Stencil(int iStencil)
    {
        SET_VAL(STENCIL_POS,STENCIL_LEN,iStencil);
        return;
    }

#if DBG
    DWORD GetCapDWord(int iNum)
    {
        return m_rgdwData[iNum];
    }
#endif
};

#endif  // _RASTCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\rastcoll.cpp ===
// rastcoll.cpp - implementation of the CRastCollection class
//
// Copyright Microsoft Corporation, 1997.
//

#include "pch.cpp"
#pragma hdrstop

#include "RastCap.h"
#include "rastcoll.h"
#include "mlrfns.h"

// MMX monolithic rasterizers are for X86 only
#ifdef _X86_
// table containing rasterzer capability bit vectors and
// pointers to functions implementing MMX monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//

static RASTFNREC s_RastListMMX[] = {
    {{ 0x00000000, 0x00000000, 0x00000100 }, MMXMLRast_22, 21, "MMX ml22" },
    {{ 0x00000000, 0x00000000, 0x00000102 }, MMXMLRast_8,   7, "MMX ml8 " },
    {{ 0x00000000, 0x00001100, 0x00000100 }, MMXMLRast_23, 22, "MMX ml23" },
    {{ 0x00000000, 0x00001102, 0x00000102 }, MMXMLRast_9,   8, "MMX ml9 " },
    {{ 0x00000000, 0x00003100, 0x00000100 }, MMXMLRast_26, 25, "MMX ml26" },
    {{ 0x00000000, 0x00003102, 0x00000102 }, MMXMLRast_12, 11, "MMX ml12" },
    {{ 0x00000000, 0x00101200, 0x00000100 }, MMXMLRast_24, 23, "MMX ml24" },
    {{ 0x00000000, 0x00101202, 0x00000102 }, MMXMLRast_10,  9, "MMX ml10" },
    {{ 0x00000000, 0x00103200, 0x00000100 }, MMXMLRast_27, 26, "MMX ml27" },
    {{ 0x00000000, 0x00103202, 0x00000102 }, MMXMLRast_13, 12, "MMX ml13" },
    {{ 0x00000000, 0x00111200, 0x00000100 }, MMXMLRast_25, 24, "MMX ml25" },
    {{ 0x00000000, 0x00111202, 0x00000102 }, MMXMLRast_11, 10, "MMX ml11" },
    {{ 0x00000000, 0x00113200, 0x00000100 }, MMXMLRast_28, 27, "MMX ml28" },
    {{ 0x00000000, 0x00113202, 0x00000102 }, MMXMLRast_14, 13, "MMX ml14" },
    {{ 0x00003003, 0x00000000, 0x00000100 }, MMXMLRast_15, 14, "MMX ml15" },
    {{ 0x00003003, 0x00000000, 0x00000102 }, MMXMLRast_1,   0, "MMX ml1 " },
    {{ 0x00003003, 0x00001100, 0x00000100 }, MMXMLRast_16, 15, "MMX ml16" },
    {{ 0x00003003, 0x00001102, 0x00000102 }, MMXMLRast_2,   1, "MMX ml2 " },
    {{ 0x00003003, 0x00003100, 0x00000100 }, MMXMLRast_19, 18, "MMX ml19" },
    {{ 0x00003003, 0x00003102, 0x00000102 }, MMXMLRast_5,   4, "MMX ml5 " },
    {{ 0x00003003, 0x00101200, 0x00000100 }, MMXMLRast_17, 16, "MMX ml17" },
    {{ 0x00003003, 0x00101202, 0x00000102 }, MMXMLRast_3,   2, "MMX ml3 " },
    {{ 0x00003003, 0x00103200, 0x00000100 }, MMXMLRast_20, 19, "MMX ml20" },
    {{ 0x00003003, 0x00103202, 0x00000102 }, MMXMLRast_6,   5, "MMX ml6 " },
    {{ 0x00003003, 0x00111200, 0x00000100 }, MMXMLRast_18, 17, "MMX ml18" },
    {{ 0x00003003, 0x00111202, 0x00000102 }, MMXMLRast_4,   3, "MMX ml4 " },
    {{ 0x00003003, 0x00113200, 0x00000100 }, MMXMLRast_21, 20, "MMX ml21" },
    {{ 0x00003003, 0x00113202, 0x00000102 }, MMXMLRast_7,   6, "MMX ml7 " },


};
#endif // _X86_

// table containing rasterizer capability bit vectors and
// pointers to functions implementing monolithic
// rasterizers with those capabilities.
//
// note that table is sorted numerically by
// capability bit vector, this is essential for the
// search through the table.
//
static RASTFNREC s_RastListNormal[] = {
    // Don't select these until we are sure they work
//    {{ 0x00113003, 0x00000000, 0x00000100 }, CMLRast_1, 0, "CML 1" },
//    {{ 0x00113003, 0x00000000, 0x00000103 }, CMLRast_2, 1, "CML 2" }
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_1, 0, "CML 1" },
    {{ 0xffffffff, 0xffffffff, 0xffffffff }, CMLRast_2, 1, "CML 2" }
};


int RastCapCompare(DWORD* pdwCap1, DWORD* pdwCap2)
{
    for (int i = 0; i < RASTCAPRECORD_SIZE; i++) {
        if (pdwCap1[i] < pdwCap2[i]) {
            return -1;
        } else if (pdwCap1[i] > pdwCap2[i]) {
            return 1;
        }
    }

    return 0;
}


RASTFNREC*
CRastCollection::RastFnLookup(
    CRastCapRecord* pRastCapRec,
    RASTFNREC* pRastFnTbl,
    int iSize)
{
    int iLow = 0,
        iHigh = iSize - 1,
    iMid;
    RASTFNREC* pfnRastFnRec = NULL;

    // all MMX monolithics can handle either shade mode
    pRastCapRec->m_rgdwData[SHADEMODE_POS/32] &= ~(((1<<SHADEMODE_LEN)-1)<<SHADEMODE_POS);

    do
    {
        iMid = (iLow + iHigh) / 2;
        switch (RastCapCompare(pRastCapRec->
                m_rgdwData,pRastFnTbl[iMid].rgdwRastCap))
        {
        case -1 :
            iHigh = iMid - 1;
            break;
        case 0 :
            // found match
            pfnRastFnRec = &pRastFnTbl[iMid];
            iLow = iHigh + 1;       // exits while loop
            break;
        case 1 :
            iLow = iMid + 1;
            break;
        }
    } while (iLow <= iHigh);

    return pfnRastFnRec;
}


RASTFNREC*
CRastCollection::Search(PD3DI_RASTCTX pCtx,
    CRastCapRecord* pRastCapRec)
{
    RASTFNREC* pfnRastFnRec = NULL;

#ifdef _X86_
    // if we're on an MMX machine, is there an MMX rasterizer to use?
    if ((pCtx->BeadSet == D3DIBS_MMX)||(pCtx->BeadSet == D3DIBS_MMXASRGB)) {
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListMMX,
                             sizeof(s_RastListMMX) /
                             sizeof(s_RastListMMX[0]));
        if (pfnRastFnRec)
        {
            // only code up looking at one mask, for now
            DDASSERT(MMX_FP_DISABLE_MASK_NUM == 1);
            int iIndex = pfnRastFnRec->iIndex;
            DDASSERT((iIndex < 32) && (iIndex >= 0));
            if ((pCtx->dwMMXFPDisableMask[0]>>iIndex) & 1)
            {
                // oops, don't choose this one, it is on the disable list
                pfnRastFnRec = NULL;
            }
        }
    } else {
#endif //_X86_
        // no MMX or on ALPHA, so look in the normal list
        pfnRastFnRec = RastFnLookup(pRastCapRec,s_RastListNormal,
                                 sizeof(s_RastListNormal) /
                                 sizeof(s_RastListNormal[0]));
#ifdef _X86_
    }
#endif //_X86_

    return pfnRastFnRec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx6\rast\spaninit\spindbg.hpp ===
//----------------------------------------------------------------------------
//
// spindbg.hpp
//
// Span Init debug definitions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPINDBG_HPP_
#define _SPINDBG_HPP_

#include <cppdbg.hpp>

DBG_DECLARE_HEADER(SPI);

#define SPIDPF(Args)             DBG_DECLARE_DPF(SPI, Args)
#define SPIDPFM(Args)            DBG_DECLARE_DPFM(SPI, Args)
#define SPIASSERT(Exp)           DBG_DECLARE_ASSERT(SPI, Exp)
#define SPIASSERTMSG(Exp, Args)  DBG_DECLARE_ASSERTMSG(SPI, Exp, Args)
#define SPIVERIFY(Exp)           DBG_DECLARE_VERIFY(SPI, Exp)
#define SPIVERIFYMSG(Exp)        DBG_DECLARE_VERIFYMSG(SPI, Exp, Args)
#define SPIPROMPT(Args)          DBG_DECLARE_PROMPT(SPI, Args)
#define SPIGETFLAGS(Idx)         DBG_DECLARE_GETFLAGS(SPI, Idx)
#define SPISETFLAGS(Idx, Value)  DBG_DECLARE_SETFLAGS(SPI, Idx, Value)
#define SPIHRCHK(Exp)            DBG_DECLARE_HRCHK(SPI, Exp)
#define SPIHRGO(Exp, Label)      DBG_DECLARE_HRGO(SPI, Exp, Label)
#define SPIHRERR(Exp)            DBG_DECLARE_HRERR(SPI, Exp)
#define SPIHRRET(Exp)            DBG_DECLARE_HRRET(SPI, Exp)

#define SPIM_INVALID             0x00000001
#define SPIM_REPORT              0x00000002

#define SPIU_BREAK_ON_SPANINIT   0x00000001

#endif // #ifndef _SPINDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3ddev.cpp
 *  Content:    Direct3D device implementation
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: device.c,v 1.26 1995/12/04 11:29:47 sjl Exp $
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
/*
 * Create an api for the Direct3DDevice object
 */
extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
}
#include "commdrv.hpp"
#include "drawprim.hpp"

//#ifdef DEBUG_PIPELINE
#include "testprov.h"
//#endif //DEBUG_PIPELINE
#ifdef PROFILE4
#include <icecap.h>
#endif
#ifdef PROFILE
#include <icapexp.h>
#endif

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice"

// DX3, DX5, DX6, DX7, TL
#define MAX_DRIVERMODELS_SUPPORTED 5
#define D3DDRVMODEL_DX3  0x00000001
#define D3DDRVMODEL_DX5  0x00000002
#define D3DDRVMODEL_DX6  0x00000003
#define D3DDRVMODEL_DX7  0x00000004
#define D3DDRVMODEL_TL   0x00000005

extern BOOL isMMXprocessor(void);
extern BOOL IsValidD3DDeviceGuid(REFCLSID riid);
extern void setIdentity(D3DMATRIXI * m);
extern DWORD dwCPUFeatures;
#ifdef _X86_
extern HRESULT D3DAPI katmai_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern HRESULT D3DAPI wlmt_FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs);
extern LPD3DFE_CONTEXTCREATE px3DContextCreate;
#endif


BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS halTable)
{
    if(halTable==NULL) {
        D3D_WARN(0, "HAL callbacks is NULL. HAL will not be enumerated.");
        return FALSE;
    }

    if (halTable->dwSize != D3DHAL_SIZE_V1) {
        D3D_WARN(0, "HAL callbacks invalid - size = %d, wanted %d. HAL will not be enumerated.",
            halTable->dwSize, D3DHAL_SIZE_V1);
        return FALSE;
    }
    if (halTable->dwReserved  ||
        halTable->dwReserved0 ||
        halTable->dwReserved1 ||
        halTable->dwReserved2 ||
        halTable->dwReserved3 ||
        halTable->dwReserved4 ||
        halTable->dwReserved5 ||
        halTable->dwReserved6 ||
        halTable->dwReserved7 ||
        halTable->dwReserved8 ||
        halTable->dwReserved9 ||
        halTable->lpReserved10 ||
        halTable->lpReserved11 ||
        halTable->lpReserved12 ||
        halTable->lpReserved13 ||
        halTable->lpReserved14 ||
        halTable->lpReserved15 ||
        halTable->lpReserved16 ||
        halTable->lpReserved17 ||
        halTable->lpReserved18 ||
        halTable->lpReserved19 ||
        halTable->lpReserved20 ||
        halTable->lpReserved21) {
        D3D_WARN(0, "HAL callbacks invalid - has non-zero reserved fields, HAL will not be enumerated.");
        return FALSE;
    }

    return TRUE;
}

// This is a list of all rstates that UpdateInternalState does some
// work other than updating this->rstates[] array. This is used to
// do a quick bitwise check to see if this rstate is trivial or not.

const D3DRENDERSTATETYPE rsList[] = {
    D3DRENDERSTATE_FOGENABLE,
    D3DRENDERSTATE_SPECULARENABLE,
    D3DRENDERSTATE_RANGEFOGENABLE,
    D3DRENDERSTATE_FOGDENSITY,
    D3DRENDERSTATE_FOGSTART,
    D3DRENDERSTATE_FOGEND,
    D3DRENDERSTATE_WRAP0,
    D3DRENDERSTATE_WRAP1,
    D3DRENDERSTATE_WRAP2,
    D3DRENDERSTATE_WRAP3,
    D3DRENDERSTATE_WRAP4,
    D3DRENDERSTATE_WRAP5,
    D3DRENDERSTATE_WRAP6,
    D3DRENDERSTATE_WRAP7,
    D3DRENDERSTATE_CLIPPING,
    D3DRENDERSTATE_LIGHTING,
    D3DRENDERSTATE_EXTENTS,
    D3DRENDERSTATE_AMBIENT,
    D3DRENDERSTATE_FOGVERTEXMODE,
    D3DRENDERSTATE_COLORVERTEX,
    D3DRENDERSTATE_LOCALVIEWER,
    D3DRENDERSTATE_NORMALIZENORMALS,
    D3DRENDERSTATE_COLORKEYBLENDENABLE,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
    D3DRENDERSTATE_VERTEXBLEND,
    D3DRENDERSTATE_CLIPPLANEENABLE,
    D3DRENDERSTATE_SHADEMODE,

    // Retired renderstates to be filtered with DPF error and INVALID return
    // NOTE: everything listed here is also assumed to appear in rsListRetired
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
};

// list of retired renderstates - need to make sure these are
// filtered and never get from app directly to driver
const D3DRENDERSTATETYPE rsListRetired[] = {
    D3DRENDERSTATE_TEXTUREHANDLE,
    D3DRENDERSTATE_TEXTUREADDRESS,
    D3DRENDERSTATE_WRAPU,
    D3DRENDERSTATE_WRAPV,
    D3DRENDERSTATE_MONOENABLE,
    D3DRENDERSTATE_ROP2,
    D3DRENDERSTATE_PLANEMASK,
    D3DRENDERSTATE_TEXTUREMAG,
    D3DRENDERSTATE_TEXTUREMIN,
    D3DRENDERSTATE_TEXTUREMAPBLEND,
    D3DRENDERSTATE_SUBPIXEL,
    D3DRENDERSTATE_SUBPIXELX,
    D3DRENDERSTATE_STIPPLEENABLE,
    D3DRENDERSTATE_BORDERCOLOR,
    D3DRENDERSTATE_TEXTUREADDRESSU,
    D3DRENDERSTATE_TEXTUREADDRESSV,
    D3DRENDERSTATE_MIPMAPLODBIAS,
    D3DRENDERSTATE_ANISOTROPY,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT,
    D3DRENDERSTATE_STIPPLEPATTERN00,
    D3DRENDERSTATE_STIPPLEPATTERN01,
    D3DRENDERSTATE_STIPPLEPATTERN02,
    D3DRENDERSTATE_STIPPLEPATTERN03,
    D3DRENDERSTATE_STIPPLEPATTERN04,
    D3DRENDERSTATE_STIPPLEPATTERN05,
    D3DRENDERSTATE_STIPPLEPATTERN06,
    D3DRENDERSTATE_STIPPLEPATTERN07,
    D3DRENDERSTATE_STIPPLEPATTERN08,
    D3DRENDERSTATE_STIPPLEPATTERN09,
    D3DRENDERSTATE_STIPPLEPATTERN10,
    D3DRENDERSTATE_STIPPLEPATTERN11,
    D3DRENDERSTATE_STIPPLEPATTERN12,
    D3DRENDERSTATE_STIPPLEPATTERN13,
    D3DRENDERSTATE_STIPPLEPATTERN14,
    D3DRENDERSTATE_STIPPLEPATTERN15,
    D3DRENDERSTATE_STIPPLEPATTERN16,
    D3DRENDERSTATE_STIPPLEPATTERN17,
    D3DRENDERSTATE_STIPPLEPATTERN18,
    D3DRENDERSTATE_STIPPLEPATTERN19,
    D3DRENDERSTATE_STIPPLEPATTERN20,
    D3DRENDERSTATE_STIPPLEPATTERN21,
    D3DRENDERSTATE_STIPPLEPATTERN22,
    D3DRENDERSTATE_STIPPLEPATTERN23,
    D3DRENDERSTATE_STIPPLEPATTERN24,
    D3DRENDERSTATE_STIPPLEPATTERN25,
    D3DRENDERSTATE_STIPPLEPATTERN26,
    D3DRENDERSTATE_STIPPLEPATTERN27,
    D3DRENDERSTATE_STIPPLEPATTERN28,
    D3DRENDERSTATE_STIPPLEPATTERN29,
    D3DRENDERSTATE_STIPPLEPATTERN30,
    D3DRENDERSTATE_STIPPLEPATTERN31,
};
//---------------------------------------------------------------------
DIRECT3DDEVICEI::DIRECT3DDEVICEI()
{
    m_rsMax  = D3DRENDERSTATE_CLIPPING;
    m_tssMax = D3DTSS_TEXTURETRANSFORMFLAGS;
}
//---------------------------------------------------------------------
HRESULT DIRECT3DDEVICEI::stateInitialize(BOOL bZEnable)
{
    D3DLINEPATTERN defLPat;
    HRESULT ret;
    float tmpval;
    DWORD i;

    // Initialize the bit array indicating the rstates needing non-trivial
    // work.
    for (i=0; i < sizeof(rsList) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVec[rsList[i] >> D3D_RSVEC_SHIFT] |= 1 << (rsList[i] & D3D_RSVEC_MASK);
    // Initialize the bit array indicating the retired rstates
    for (i=0; i < sizeof(rsListRetired) / sizeof(D3DRENDERSTATETYPE); ++i)
        rsVecRetired[rsListRetired[i] >> D3D_RSVEC_SHIFT] |= 1 << (rsListRetired[i] & D3D_RSVEC_MASK);
    // Obviate SetRenderState filtering 'redundant' render state settings
    // since this is the init step.
    memset( this->rstates, 0xff, sizeof(DWORD)*D3D_MAXRENDERSTATES);
    this->rstates[D3DRENDERSTATE_PLANEMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILMASK] = 0;
    this->rstates[D3DRENDERSTATE_STENCILWRITEMASK] = 0;
    this->rstates[D3DRENDERSTATE_TEXTUREFACTOR] = 0;

    SetRenderStateInternal( D3DRENDERSTATE_TEXTUREPERSPECTIVE, TRUE);
    SetRenderStateInternal( D3DRENDERSTATE_SPECULARENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ZENABLE, bZEnable);
    SetRenderStateInternal( D3DRENDERSTATE_FILLMODE, D3DFILL_SOLID);
    SetRenderStateInternal( D3DRENDERSTATE_SHADEMODE, D3DSHADE_GOURAUD);

    defLPat.wRepeatFactor = 0;
    defLPat.wLinePattern = 0;

    SetRenderStateInternal( D3DRENDERSTATE_LINEPATTERN, *((LPDWORD)&defLPat)); /* 10 */
    /*
      ((LPD3DSTATE)lpPointer)->drstRenderStateType =
      (D3DRENDERSTATETYPE)D3DRENDERSTATE_LINEPATTERN;
      memcpy(&(((LPD3DSTATE)lpPointer)->dwArg[0]), &defLPat, sizeof(DWORD));
      lpPointer = (void *)(((LPD3DSTATE)lpPointer) + 1);*/

    SetRenderStateInternal( D3DRENDERSTATE_ZWRITEENABLE, TRUE);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHATESTENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_LASTPIXEL, TRUE);
    SetRenderStateInternal( D3DRENDERSTATE_SRCBLEND, D3DBLEND_ONE);
    SetRenderStateInternal( D3DRENDERSTATE_DESTBLEND, D3DBLEND_ZERO);
    SetRenderStateInternal( D3DRENDERSTATE_CULLMODE, D3DCULL_CCW); /* 21 */
    SetRenderStateInternal( D3DRENDERSTATE_ZFUNC, D3DCMP_LESSEQUAL);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHAREF, 0);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHAFUNC, D3DCMP_ALWAYS);
    SetRenderStateInternal( D3DRENDERSTATE_DITHERENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_FOGENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ZVISIBLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_STIPPLEDALPHA, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_FOGCOLOR, 0);
    SetRenderStateInternal( D3DRENDERSTATE_FOGTABLEMODE, D3DFOG_NONE);
    tmpval = 0.0f;
    SetRenderStateInternal( D3DRENDERSTATE_FOGSTART, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal( D3DRENDERSTATE_FOGEND, *((DWORD *)&tmpval));
    tmpval = 1.0f;
    SetRenderStateInternal( D3DRENDERSTATE_FOGDENSITY, *((DWORD *)&tmpval));
    SetRenderStateInternal( D3DRENDERSTATE_COLORKEYENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ALPHABLENDENABLE, FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_ZBIAS, 0);
    SetRenderStateInternal( D3DRENDERSTATE_RANGEFOGENABLE, FALSE);

    if (deviceType < D3DDEVTYPE_DX7HAL)
    {
        // send retired renderstate init's to pre-DX7 HALs only
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_MONOENABLE, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ROP2, R2_COPYPEN);
        SetRenderStateInternal( D3DRENDERSTATE_PLANEMASK, (DWORD)~0);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPU, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_WRAPV, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_ANTIALIAS, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXEL, FALSE); /* 30 */
        SetRenderStateInternal( D3DRENDERSTATE_SUBPIXELX, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_EDGEANTIALIAS, FALSE);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN00, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN01, 0); /* 40 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN02, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN03, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN04, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN05, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN06, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN07, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN08, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN09, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN10, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN11, 0); /* 50 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN12, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN13, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN14, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN15, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN16, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN17, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN18, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN19, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN20, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN21, 0); /* 60 */
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN22, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN23, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN24, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN25, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN26, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN27, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN28, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN29, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN30, 0);
        SetRenderStateInternal( D3DRENDERSTATE_STIPPLEPATTERN31, 0); /* 70 */
    }

    // init stencil states to something reasonable
    // stencil enable is OFF by default since stenciling rasterizers will be
    // faster with it disabled, even if stencil states are benign
    SetRenderStateInternal( D3DRENDERSTATE_STENCILENABLE,   FALSE);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILFAIL,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILZFAIL,    D3DSTENCILOP_KEEP);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILPASS,     D3DSTENCILOP_KEEP);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILFUNC,     D3DCMP_ALWAYS);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILREF,      0);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILMASK,     0xFFFFFFFF);
    SetRenderStateInternal( D3DRENDERSTATE_STENCILWRITEMASK,0xFFFFFFFF);

    // don't forget about texturefactor (like we did in DX6.0...)
    SetRenderStateInternal( D3DRENDERSTATE_TEXTUREFACTOR,   0xFFFFFFFF);

    for (i = 0; i < 8; i++)
    {
        SetRenderStateInternal( (D3DRENDERSTATETYPE)
                        (D3DRENDERSTATE_WRAPBIAS + i), FALSE );
    }
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        lpD3DMappedTexI[i] = NULL;
        lpD3DMappedBlock[i] = NULL;
    }
    m_dwStageDirty = 0;

    // Obviate SetTextureStageState/Settexture filtering 'redundant' render state
    // settings since this is the init step.
    memset( this->tsstates, 0xff, sizeof(DWORD)*D3DHAL_TSS_MAXSTAGES*D3DHAL_TSS_STATESPERSTAGE );
    for (i = 0; i < D3DHAL_TSS_MAXSTAGES; i++)
    {
        SetTexture(i, NULL);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_MODULATE);
        else
            SetTextureStageState(i, D3DTSS_COLOROP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_COLORARG2, D3DTA_CURRENT);
        if(i == 0)
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
        else
            SetTextureStageState(i, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        SetTextureStageState(i, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        SetTextureStageState(i, D3DTSS_ALPHAARG2, D3DTA_CURRENT);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT00, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT01, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT10, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVMAT11, 0);
        SetTextureStageState(i, D3DTSS_TEXCOORDINDEX, 0);
        SetTextureStageState(i, D3DTSS_ADDRESS, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
        SetTextureStageState(i, D3DTSS_BORDERCOLOR, 0x00000000);
        SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTFG_POINT);
        SetTextureStageState(i, D3DTSS_MINFILTER, D3DTFN_POINT);
        SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTFP_NONE);
        SetTextureStageState(i, D3DTSS_MIPMAPLODBIAS, 0);
        SetTextureStageState(i, D3DTSS_MAXMIPLEVEL, 0);
        SetTextureStageState(i, D3DTSS_MAXANISOTROPY, 1);
        SetTextureStageState(i, D3DTSS_BUMPENVLSCALE, 0);
        SetTextureStageState(i, D3DTSS_BUMPENVLOFFSET, 0);
        SetTextureStageState(i, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
    }

#ifdef WIN95
    // Force a mapping if old HAL
    if(deviceType < D3DDEVTYPE_DP2HAL)
    {
        SetRenderStateInternal( D3DRENDERSTATE_TEXTUREHANDLE, (DWORD)NULL);
        static_cast<CDirect3DDeviceIHW*>(this)->MapTSSToRS();
    }
#endif

    SetRenderStateInternal(D3DRENDERSTATE_AMBIENT, 0);
    SetRenderStateInternal(D3DRENDERSTATE_COLORVERTEX, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_FOGVERTEXMODE, D3DFOG_NONE);
    SetRenderStateInternal(D3DRENDERSTATE_CLIPPING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_LIGHTING, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_EXTENTS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_NORMALIZENORMALS, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_LOCALVIEWER, TRUE);
    SetRenderStateInternal(D3DRENDERSTATE_COLORKEYBLENDENABLE, FALSE);
    SetRenderStateInternal(D3DRENDERSTATE_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_AMBIENTMATERIALSOURCE,  D3DMCS_MATERIAL);
    SetRenderStateInternal(D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,  D3DMCS_COLOR1);
    SetRenderStateInternal(D3DRENDERSTATE_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
    SetRenderStateInternal(D3DRENDERSTATE_VERTEXBLEND, D3DVBLEND_DISABLE);
    SetRenderStateInternal(D3DRENDERSTATE_CLIPPLANEENABLE, 0);

    // If we have created any textures prior to creating this device, then
    // let the driver know their priorities.
    if(DDCAPS2_CANMANAGETEXTURE & ((LPDDRAWI_DIRECTDRAW_INT)lpDirect3DI->lpDD)->lpLcl->lpGbl->ddCaps.dwCaps2)
    {
        LPDIRECT3DTEXTUREI lpTexI = LIST_FIRST(&lpDirect3DI->textures);
        while(lpTexI)
        {
            // If the texture is managed (by the driver)
            if(DDSCAPS2_TEXTUREMANAGE & ((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2)
            {
                ret = lpTexI->SetPriority(lpTexI->m_dwPriority);
                if(ret != D3D_OK)
                {
                    D3D_ERR("SetPriority failed in device initialize.");
                    return ret;
                }
                ret = lpTexI->SetLOD(lpTexI->m_dwLOD);
                if(ret != D3D_OK)
                {
                    D3D_ERR("SetLOD failed in device initialize.");
                    return ret;
                }
            }
            lpTexI = LIST_NEXT(lpTexI, m_List);
        }
    }

    return(D3D_OK);
}

DWORD BitDepthToDDBD(int bpp)
{
    switch(bpp)
    {
    case 1:
        return DDBD_1;
    case 2:
        return DDBD_2;
    case 4:
        return DDBD_4;
    case 8:
        return DDBD_8;
    case 16:
        return DDBD_16;
    case 24:
        return DDBD_24;
    case 32:
        return DDBD_32;
    default:
        D3D_ERR("Invalid bit depth");
        return 0;
    }
}

HRESULT DIRECT3DDEVICEI::checkDeviceSurface(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZbuffer, LPGUID pGuid)
{
    D3DDEVICEDESC7 Desc;
    DDPIXELFORMAT surfPF;
    DDSCAPS surfCaps;
    HRESULT ret;
    DWORD bpp;

    /* Get caps bits - check whether device and surface are:
       - video/system memory and depth compatible */

    if (FAILED(ret = lpDDS->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get render-target surface caps");
        return(ret);
    }

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpDDS->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get render-target surface pixel format");
        return(ret);
    }

    if (IS_HW_DEVICE(this)) {
        /* I'm taking this as evidence that its running on hardware - therefore
           the surface should be in video memory */
        D3D_INFO(3, "Hardware device being used");

        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Render-target surface not in video memory for hw device");
            return(D3DERR_SURFACENOTINVIDMEM);
        }
    }

    /* A surface can only have one bit depth - whereas a device can support
       multiple bit depths */
    if (surfPF.dwFlags & DDPF_RGB) {
        D3D_INFO(3, "Render-target surface is RGB");

        bpp = BitDepthToDDBD(surfPF.dwRGBBitCount);
        if (!bpp) {
            D3D_ERR("Bogus render-target surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
       }

       if((surfPF.dwRGBBitCount<16) && (IsEqualIID(*pGuid, IID_IDirect3DRefDevice) || IsEqualIID(*pGuid, IID_IDirect3DNullDevice))) {
           // this is actually subsumed by the following test, but whatever
            D3D_ERR("Reference rasterizer and null device dont support render targets with bitdepth < 16");
            return(DDERR_INVALIDPIXELFORMAT);
       }

        if (!(bpp & this->d3dDevDesc.dwDeviceRenderBitDepth)) {
            D3D_ERR("Render-target surface bitdepth is not supported by this device");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    if(lpZbuffer==NULL)
      return D3D_OK;

    memset(&surfPF, 0, sizeof(DDPIXELFORMAT));
    surfPF.dwSize = sizeof(DDPIXELFORMAT);

    if (FAILED(ret = lpZbuffer->GetPixelFormat(&surfPF))) {
        D3D_ERR("Failed to get zbuffer pixel format");
        return(ret);
    }

    if (FAILED(ret = lpZbuffer->GetCaps(&surfCaps))) {
        D3D_ERR("Failed to get Zbuffer caps");
        return(ret);
    }

    if (IS_HW_DEVICE(this)) {
        if (!(surfCaps.dwCaps & DDSCAPS_VIDEOMEMORY)) {
            D3D_ERR("Zbuffer not in video memory for hw device");
            return(D3DERR_ZBUFF_NEEDS_VIDEOMEMORY);
        }
        D3D_INFO(3, "Hw device, zbuffer in video memory");
    } else {
        if (!(surfCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)) {
            D3D_ERR("Zbuffer not in system memory for HEL device");
            return(D3DERR_ZBUFF_NEEDS_SYSTEMMEMORY);
        }
        D3D_INFO(3, "Hel device, zbuffer in system memory");

         // have to hack in a check to make sure ramp isn't used with stencil zbuffer
         // cant do this validation until device creation time (instead of at zbuffer creation in
         // ddhel.c) because rgb vs. ramp isn't known until now
         if(IsEqualIID(*pGuid, IID_IDirect3DRampDevice)) {
            if(surfPF.dwFlags & DDPF_STENCILBUFFER) {
                D3D_ERR("Z-Buffer with stencil is invalid with RAMP software rasterizer");
                return DDERR_INVALIDPARAMS;
            }
         }
    }

    if (surfPF.dwFlags & DDPF_ZBUFFER) {
        bpp = BitDepthToDDBD(surfPF.dwZBufferBitDepth);
        if (!bpp) {
            D3D_ERR("Bogus Zbuffer surface pixel depth");
            return(DDERR_INVALIDPIXELFORMAT);
        }
    }

    return(D3D_OK);
}


/*
 * Initialisation - class part and device part
 */

/*
 * Generic class part initialisation
 */
HRESULT InitDeviceI(LPDIRECT3DDEVICEI lpDevI, LPDIRECT3DI lpD3DI)
{
    LPDDRAWI_DIRECTDRAW_GBL lpDDI;
    HRESULT error;
    D3DDEVICEDESC7 dummyDesc;

    lpDDI = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl;

    //
    // Retrieve HAL information from provider.
    //

    if (IS_HW_DEVICE(lpDevI))
        error = lpDevI->pHalProv->GetCaps(lpDDI,
                                      &lpDevI->d3dDevDesc,
                                      &dummyDesc,
                                      4);
    else
        error = lpDevI->pHalProv->GetCaps(lpDDI,
                                      &dummyDesc,
                                      &lpDevI->d3dDevDesc,
                                      4);
    if (error != S_OK)
    {
        return (error);
    }
    // Insert the GUID
    memcpy(&lpDevI->d3dDevDesc.deviceGUID, &lpDevI->guid, sizeof(GUID));

    if( lpDevI->d3dDevDesc.wMaxVertexBlendMatrices == 1 )
        lpDevI->d3dDevDesc.wMaxVertexBlendMatrices = 0;

    //
    // Fix up the caps for non-T&L devices
    // That use out front-end
    //
    if( IsEqualIID(lpDevI->guid, IID_IDirect3DHALDevice) ||
        IsEqualIID(lpDevI->guid, IID_IDirect3DRGBDevice) )
    {
        lpDevI->d3dDevDesc.dwMaxActiveLights = 0xffffffff;
        lpDevI->d3dDevDesc.wMaxVertexBlendMatrices = 4;
        lpDevI->d3dDevDesc.wMaxUserClipPlanes = __MAXUSERCLIPPLANES;
        lpDevI->d3dDevDesc.dwVertexProcessingCaps = D3DVTXPCAPS_ALL;
    }


    D3DHALPROVIDER_INTERFACEDATA HalProviderIData;
    memset(&HalProviderIData,0,sizeof(HalProviderIData));
    HalProviderIData.dwSize = sizeof(HalProviderIData);
    if ((error = lpDevI->pHalProv->GetInterface(lpDDI,
                                                &HalProviderIData,
                                                4)) != S_OK)
    {
        return error;
    }
    //  interface data for <=DX5 HAL
    lpDevI->lpD3DHALGlobalDriverData = HalProviderIData.pGlobalData;
    lpDevI->lpD3DExtendedCaps        = HalProviderIData.pExtCaps;
    lpDevI->lpD3DHALCallbacks        = HalProviderIData.pCallbacks;
    lpDevI->lpD3DHALCallbacks2       = HalProviderIData.pCallbacks2;
    //  interface data for DX6 HAL
    lpDevI->lpD3DHALCallbacks3       = HalProviderIData.pCallbacks3;

    lpDevI->pfnRastService = HalProviderIData.pfnRastService;
    lpDevI->dwHintFlags = 0;

    // This is available in all DX7+ drivers and is used by GetInfo API
    // call.
    lpDevI->pfnGetDriverState = HalProviderIData.pfnGetDriverState;

    // Zero out 8 bpp render target caps for real hardware.
    if (IS_HW_DEVICE(lpDevI))
    {
        lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth &=
            (~DDBD_8);
    }

    if (!D3DI_isHALValid(lpDevI->lpD3DHALCallbacks))
    {
        return D3DERR_INITFAILED;
    }

    if (lpDevI->lpD3DExtendedCaps && lpDevI->lpD3DExtendedCaps->dwFVFCaps)
    {
        lpDevI->dwMaxTextureIndices =
            lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_TEXCOORDCOUNTMASK;
        lpDevI->dwMaxTextureBlendStages =
            lpDevI->lpD3DExtendedCaps->wMaxTextureBlendStages;
        lpDevI->dwDeviceFlags |= D3DDEV_FVF;
        if (lpDevI->lpD3DExtendedCaps->dwFVFCaps & D3DFVFCAPS_DONOTSTRIPELEMENTS)
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;

        DWORD value;
        if ((
#ifdef WIN95
            lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP ||
            lpDevI->dwDebugFlags & D3DDEBUG_DISABLEDP2 ||
#endif // WIN95
            (GetD3DRegValue(REG_DWORD, "DisableFVF", &value, 4) &&
            value != 0)) &&
            FVF_DRIVERSUPPORTED(lpDevI))
        {
            lpDevI->dwMaxTextureIndices = 1;
            lpDevI->dwDeviceFlags &= ~D3DDEV_FVF;
            lpDevI->dwDebugFlags |= D3DDEBUG_DISABLEFVF;
        }
        if ((GetD3DRegValue(REG_DWORD, "DisableStripFVF", &value, 4) &&
            value != 0))
        {
            lpDevI->dwDeviceFlags |= D3DDEV_DONOTSTRIPELEMENTS;
        }
    }
    else
    {
        lpDevI->dwMaxTextureIndices = 1;
        lpDevI->dwMaxTextureBlendStages = 1;
    }

    lpDevI->transform.dwMaxUserClipPlanes =
        lpDevI->d3dDevDesc.wMaxUserClipPlanes;

    lpDevI->dwFEFlags |= D3DFE_FRONTEND_DIRTY;

#if DBG
    lpDevI->dwCaller=0;
    memset(lpDevI->dwPrimitiveType,0,sizeof(lpDevI->dwPrimitiveType));
    memset(lpDevI->dwVertexType1,0,sizeof(lpDevI->dwVertexType1));
    memset(lpDevI->dwVertexType2,0,sizeof(lpDevI->dwVertexType2));
#endif
    return D3D_OK;
}

HRESULT D3DMallocBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET *lplpBucket)
{
    if (lpD3DI->lpFreeList == NULL ){
      if (lpD3DI->lpFreeList == NULL )
      {
        LPD3DBUCKET   lpBufferList;
        LPVOID  lpBuffer;
        int i;
        *lplpBucket=NULL;
        if (D3DMalloc(&lpBuffer, D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET)) != D3D_OK)
            return  DDERR_OUTOFMEMORY;
        D3D_INFO(9, "D3DMallocBucket %d Bytes allocated for %d free Buckets",
            D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET),D3DBUCKETBUFFERSIZE-1);
        lpBufferList=(LPD3DBUCKET)lpBuffer;
        for (i=0;i<D3DBUCKETBUFFERSIZE-2;i++)
            lpBufferList[i].next=&lpBufferList[i+1];
        lpBufferList[D3DBUCKETBUFFERSIZE-2].next=NULL;
        lpD3DI->lpFreeList=(LPD3DBUCKET)lpBuffer; //new free list
        lpBufferList[D3DBUCKETBUFFERSIZE-1].next=lpD3DI->lpBufferList;//add to lpBufferList
        lpBufferList[D3DBUCKETBUFFERSIZE-1].lpBuffer=lpBuffer;
        lpD3DI->lpBufferList=&lpBufferList[D3DBUCKETBUFFERSIZE-1];
      }
    }
    *lplpBucket=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpD3DI->lpFreeList->next;
    return  D3D_OK;
}

void    D3DFreeBucket(LPDIRECT3DI lpD3DI, LPD3DBUCKET lpBucket)
{
    lpBucket->next=lpD3DI->lpFreeList;
    lpD3DI->lpFreeList=lpBucket;
}

void DIRECT3DDEVICEI::CleanupTextures()
{
    /*
     * free up all textures created by this object - this also frees up Textures
     * We need to do this backwards because we cannot have a texture bound to
     * stage i + 1 when there is a texture bound to stage i.
     */
    for (int i = D3DHAL_TSS_MAXSTAGES - 1; i >= 0; --i)
    {
        if (lpD3DMappedTexI[i])
        {
            lpD3DMappedTexI[i]->Release();
            lpD3DMappedTexI[i] = NULL;
            lpD3DMappedBlock[i] = NULL;
        }
    }
    // The following code can result in D3DHAL_TextureDestroy() being called.
    // This BATCHES NEW INSTRUCTIONS in the instruction stream. So we must
    // make sure that at this point, the device is still able to accept
    // instructions.
    while (LIST_FIRST(&this->texBlocks)) {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->texBlocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }
    FlushStates();
}

/*
 * Generic device part destroy
 */
DIRECT3DDEVICEI::~DIRECT3DDEVICEI()
{
    LPDIRECTDRAWSURFACE lpDDS=NULL, lpDDSZ=NULL;
    LPDIRECTDRAWSURFACE7 lpDDS_DDS7=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;

    /* Clear flags that could prohibit cleanup */
    this->dwHintFlags &=  ~(D3DDEVBOOL_HINTFLAGS_INSCENE);

    // Hold pointers into ddraw object for release after driver is destroyed
    lpDDSZ = this->lpDDSZBuffer;
    lpDDPal = this->lpDDPalTarget;
    lpDDS_DDS7 = this->lpDDSTarget_DDS7;

    // this indicates that the device need no longer be flushed when Locking, Blting
    // or GetDC'ing from the previous rendertarget
    if (this->lpDDSTarget)
        ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;
    // this indicates that the device need no longer be flushed when Locking, Blting
    // or GetDC'ing from the previous zbuffer
    if (this->lpDDSZBuffer)
        ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSZBuffer)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;

    if (pGeometryFuncs != &GeometryFuncsGuaranteed)
        delete pGeometryFuncs;

    D3DFE_Destroy(this);

    if (this->lpDirect3DI)
        UnhookFromD3D();

    if (this->lpwDPBufferAlloced)
        D3DFree(this->lpwDPBufferAlloced);

    if (this->pHalProv != NULL)
    {
        this->pHalProv->Release();
    }
    if (this->hDllProv != NULL)
    {
        FreeLibrary(this->hDllProv);
    }

    // Free the rstates that was allocated
    if(!(IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this)))
    {
        delete rstates;
    }

    if (m_pStateSets)
        delete m_pStateSets;

    if (lpDDS)
        lpDDS->Release();
    if (lpDDSZ)
        lpDDSZ->Release();
    if (lpDDPal)
        lpDDPal->Release();
    if (lpDDS_DDS7)
        lpDDS_DDS7->Release();
    D3DFree(clrRects);
}

HRESULT DIRECT3DDEVICEI::HookToD3D(LPDIRECT3DI lpD3DI)
{

    LIST_INSERT_ROOT(&lpD3DI->devices, this, list);
    this->lpDirect3DI = lpD3DI;
    this->lpDirect3DI->AddRef(); // Since we hold a pointer to Direct3D
    lpD3DI->numDevs++;

    return (D3D_OK);
}

HRESULT DIRECT3DDEVICEI::UnhookFromD3D()
{
    LIST_DELETE(this, list);
    this->lpDirect3DI->numDevs--;
    this->lpDirect3DI->Release(); // Release our AddRef
    this->lpDirect3DI = NULL;

    return (D3D_OK);
}

/*
 * Create a device.
 *
 * NOTE: Radical modifications to support the aggregatable device
 * interface (so devices can be queried off DirectDraw surfaces):
 *
 * 1) This call is no longer a member of the Direct3D device interface.
 *    It is now an API function exported from the Direct3D DLL. Its
 *    a hidden API function - only DirectDraw will ever invoke it.
 *
 * 2) This call is, in effect, the class factory for Direct3DDevice
 *    objects. This function will be invoked to create the aggregated
 *    device object hanging off the DirectDraw surface.
 *
 * NOTE: So the Direct3DDevice knows which DirectDraw surface is
 * its rendering target this function is passed an interface pointer
 * for that DirectDraw surface. I suspect this blows a nice big
 * hole in the COM model as the DirectDraw surface is also the
 * owning interface of the device and I don't think aggregated
 * objects should know about thier owning interfaces. However, to
 * make this thing work this is what we have to do.
 *
 * EXTRA BIG NOTE: Because of the above don't take a reference to
 * the DirectDraw surface passed in. If you do you will get a circular
 * reference and the bloody thing will never die. When aggregated
 * the device interface's lifetime is entirely defined by the
 * lifetime of its owning interface (the DirectDraw surface) so the
 * DirectDraw surface can never go away before the texture.
 *
 * EXTRA EXTRA BIG NOTE: No device description is passed in any more.
 * The only things that can get passed in are things that DirectDraw
 * knows about (which does not include stuff like dither and color
 * model). Therefore, any input parameters must come in via a
 * different IID for the device. The data returned by the device
 * description must now be retrieved by another call.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreateDevice"

HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                    LPUNKNOWN           lpDirect3D,
                                    LPDIRECTDRAWSURFACE lpDDSTarget,
                                    LPUNKNOWN*          lplpD3DDevice,
                                    IUnknown*           pUnkOuter)
{
    LPDIRECT3DI           lpD3DI;
    LPDIRECT3DDEVICEI     pd3ddev;
    D3DCOLORMODEL         cm = D3DCOLOR_MONO;
    HRESULT               ret = D3D_OK;
    HKEY                  hKey = (HKEY) NULL;
    bool                  bDisableST = false;
    WORD                  wDriverStyle = MAX_DRIVERMODELS_SUPPORTED;
#if _D3D_FORCEDOUBLE
    bool    bForceDouble = true;
#endif  //_D3D_FORCEDOUBLE
    /* No need to validate params as they are passed to us by DirectDraw */

    /* CreateDevice member of IDirect3D2 will cause this function to be called
     * from within Direct3D. The parameters from the application level must be
     * validated. Need a way to validate the surface pointer from outside DDraw.
     */

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if( ! VALID_PTR_PTR( lplpD3DDevice) )
    {
        D3D_ERR( "Invalid ptr to device pointer in Direct3DCreateDevice" );
        return DDERR_INVALIDPARAMS;
    }

    if(!IsValidD3DDeviceGuid(riid))
    {
        D3D_ERR( "Unrecognized Device GUID!");
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3DDevice = NULL;

    // Might be safer to use dynamic_cast<> if RTTI is enabled
    lpD3DI = reinterpret_cast<CDirect3DUnk*>(lpDirect3D)->pD3DI;

    if (IsEqualIID(riid, IID_IDirect3DMMXDevice) && !isMMXprocessor()) {
      D3D_ERR("Can't create MMX Device on non-MMX machine");
      return DDERR_INVALIDPARAMS;
    }

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DriverStyle", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            // Win64 compiler will scream here!!
            wDriverStyle = (WORD)dwValue;
            if (wDriverStyle > MAX_DRIVERMODELS_SUPPORTED)
                wDriverStyle = MAX_DRIVERMODELS_SUPPORTED;
        }
        D3D_INFO(2,"DriverStyle: %d",wDriverStyle);

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DisableST", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            bDisableST = true;
        }
#if _D3D_FORCEDOUBLE
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "ForceDouble", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
             dwType == REG_DWORD &&
             dwValue == 0)
        {
            bForceDouble = false;
        }
        D3D_INFO(2,"ForceDouble: %d",bForceDouble);
#endif  //_D3D_FORCEDOUBLE
        RegCloseKey( hKey );
    }

    // Now create the appropriate device based on the wDriverStyle settings

    //---------------------------------------------------------------------
    // HKEY_LOCAL_MACHINE\Software\Microsoft\Direct3D\DriverStyle
    // In DX7 this registry key replaces the host of keys we had before like
    // DisableDP, DisableDP2 etc. This stuff is for testing purpose only.
    // It is more like a hint, in that, if the requested driver type is
    // available, it is used otherwise the latest available driver is used
    // The following is the meanings for this dword:
    //
    // Value:                    Driver-type:
    //       0x0                           Latest available
    //       0x1                           DeviceHW  (DX3)
    //       0x2                           DeviceDP  (DX5)
    //       0x3                           DeviceDP2 (DX6)
    //       0x4                           DeviceDX7 (DX7)
    //       0x5                           DeviceTL  (DX7+T&L)
    //
    // The following are the various cases we need to consider:
    // 1) NT Hardware: 3 and above are considered legal
    // 2) W9x Hardware: All of the above are legal
    // 3) Reference: 2 and above
    // 4) Software:  3 till 4 (no TL)
    //---------------------------------------------------------------------

    if (IsEqualIID(riid, IID_IDirect3DTnLHalDevice))
    {
        // For T&L hal guid, we ignore the wDriverStyle hint
        // set in the registry
        if (DDGBL(lpD3DI)->lpD3DGlobalDriverData &&
            (DDGBL(lpD3DI)->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
             D3DDEVCAPS_HWTRANSFORMANDLIGHT))
        {
            wDriverStyle = D3DDRVMODEL_TL;
        }
        else // fail device creation
        {
            wDriverStyle = 0;
        }
        D3D_INFO(1,"TnLHalDevice Driver Style %x",wDriverStyle);
    }
    else if (IsEqualIID(riid, IID_IDirect3DHALDevice))
    {
        WORD wDriverCaps = 0;
        WORD wLatestDDI=0;
        //
        // 1) Determine what styles of DDIs the driver is capable of
        //

        // DX7 ?
        if (DDGBL(lpD3DI)->lpDDCBtmp &&
            DDGBL(lpD3DI)->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX7);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX7;
        }

        // DX6 ?
        if (DDGBL(lpD3DI)->lpD3DHALCallbacks3 &&
            DDGBL(lpD3DI)->lpD3DHALCallbacks3->DrawPrimitives2)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX6);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX6;
        }

#ifdef WIN95
        // DX5 ?
        if (DDGBL(lpD3DI)->lpD3DHALCallbacks2 &&
            DDGBL(lpD3DI)->lpD3DHALCallbacks2->DrawOnePrimitive)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX5);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX5;
        }

        // DX3 ?
        if (DDGBL(lpD3DI)->lpD3DHALCallbacks &&
            DDGBL(lpD3DI)->lpD3DHALCallbacks->RenderPrimitive)
        {
            wDriverCaps |= (1 << D3DDRVMODEL_DX3);
            if (wLatestDDI==0)
                wLatestDDI = D3DDRVMODEL_DX3;
        }
#endif //WIN95

        //
        // 2) Verify if the requested driver is supported
        //
        if (wDriverCaps == 0)
        {
            wDriverStyle = 0;   // nothing supported so fail
        }
        else if (!(wDriverCaps & (1 << wDriverStyle)))
        {
            // use the latest available if not specified or
            // incorrectly specified or specified but not available
            wDriverStyle = wLatestDDI;
        }
        D3D_INFO(1,"HalDevice Driver Style %x",wDriverStyle);
    }
    // Reference Device
    else if (IsEqualIID(riid, IID_IDirect3DRefDevice))
    {
        // By default choose TL device for RefRast in DX7
        if (wDriverStyle < D3DDRVMODEL_DX5 || wDriverStyle > D3DDRVMODEL_TL)
        {
            // Refrast is capable of DX7+T&L
            wDriverStyle = D3DDRVMODEL_TL;
        }
    }
    // Software Rasterizers
    else
    {
        // Ignore driver style for everything except the reference rasterizer
        wDriverStyle = D3DDRVMODEL_DX6;
    }

    // Note: If wDriverStyle == 0x0 here, driver creation will fail
    // Something must have been chosen by now
    switch (wDriverStyle)
    {
#ifdef WIN95
    case D3DDRVMODEL_DX3:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIHW());
        break;
    case D3DDRVMODEL_DX5:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP());
        break;
#endif //WIN95
    case D3DDRVMODEL_DX6:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceIDP2());
        break;
    case D3DDRVMODEL_DX7:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDevice7());
        break;
    case D3DDRVMODEL_TL:
        pd3ddev = static_cast<LPDIRECT3DDEVICEI>(new CDirect3DDeviceTL());
        break;
    default:
        D3D_ERR("Runtime doesnt support requested/installed driver");
        // Change this return value ?
        return (DDERR_OUTOFMEMORY);
    }

    if (!pd3ddev) {
        D3D_ERR("Failed to allocate space for D3DDevice. Quitting.");
        return (DDERR_OUTOFMEMORY);
    }

    // If we have lost managed textures, we need to cleanup
    // since CheckSurfaces() would fail which would cause
    // FlushStates() to fail, which would result in the
    // current batch being abandoned (along with any device initialization)
    if(lpD3DI->lpTextureManager->CheckIfLost())
    {
        D3D_INFO(2, "Found lost managed textures. Evicting...");
        lpD3DI->lpTextureManager->EvictTextures();
    }

    ret = pd3ddev->Init(riid, lpD3DI, lpDDSTarget, pUnkOuter, lplpD3DDevice);
    if (ret!=D3D_OK)
    {
        delete pd3ddev;
        D3D_ERR("Failed to intilialize D3DDevice");
        return ret;
    }
    if (bDisableST)
        pd3ddev->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

#ifdef _X86_
    if (!(((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_FPUPRESERVE) &&
        IS_DP2HAL_DEVICE(pd3ddev))
    {
        pd3ddev->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_FPUSETUP;
        WORD wSave, wTemp;
        __asm {
            fstcw wSave
            mov ax, wSave
            and ax, not 300h    ;; single mode
            or  ax, 3fh         ;; disable all exceptions
            and ax, not 0C00h   ;; round to nearest mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#if _D3D_FORCEDOUBLE
    if (bForceDouble && (pd3ddev->deviceType <= D3DDEVTYPE_DPHAL))
    {
        pd3ddev->dwDebugFlags |= D3DDEBUG_FORCEDOUBLE;
    }
    else
    {
        pd3ddev->dwDebugFlags &= ~D3DDEBUG_FORCEDOUBLE;
    }
#endif  //_D3D_FORCEDOUBLE
#endif

    return (ret);
}

HRESULT DIRECT3DDEVICEI::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                              IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    DDSCAPS               ddscaps;
    DDSURFACEDESC     ddsd;
    HRESULT       ret, ddrval;
    LPDIRECTDRAWSURFACE lpDDSZ=NULL;
    LPDIRECTDRAWPALETTE lpDDPal=NULL;
    LPGUID              pGuid;
    DDSCAPS surfCaps;

    m_qwBatch = 1;
    this->dwVIDIn = 0;
    this->refCnt = 1;

    pD3DMappedTexI = (LPVOID*)(this->lpD3DMappedTexI);

    /* Single threaded or Multi threaded app ? */
    if (((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->dwLocalFlags & DDRAWILCL_MULTITHREADED)
        this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_MULTITHREADED;

    /*
     * Initialise textures
     */
    LIST_INITIALIZE(&this->texBlocks);

    this->dwVertexBase = 0;
    pGeometryFuncs = &GeometryFuncsGuaranteed;

    /*-----------------------------------------------------------------------------------------
     * Up till now we have done the easy part of the initialization. This is the stuff that
     * cannot fail. It initializes the object so that the destructor can be safely called if
     * any of the further initialization does not succeed.
     *---------------------------------------------------------------------------------------*/

    /*
     * Ensure the riid is one we understand.
     *
     * Query the registry.
     */
    pGuid = (GUID *)&riid;

#if DBG
    if (IsEqualIID(*pGuid, IID_IDirect3DTnLHalDevice))
    {
        D3D_INFO(0, "======================= TL-Hal device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice))
    {
        D3D_INFO(0, "======================= RGB device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DHALDevice))
    {
        D3D_INFO(0, "======================= HAL device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DRefDevice))
    {
        D3D_INFO(0, "======================= Reference Rasterizer device selected");
    }
    if (IsEqualIID(*pGuid, IID_IDirect3DNullDevice))
    {
        D3D_INFO(0, "======================= Null device selected");
    }
#endif

    // set up flag to use MMX when requested RGB
    BOOL bUseMMXAsRGBDevice = FALSE;
    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) && isMMXprocessor())
    {
        bUseMMXAsRGBDevice = TRUE;
        // read reg key to override use of MMX for RGB
        HKEY    hKey = (HKEY) NULL;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH, &hKey) )
        {
            DWORD dwType;
            DWORD dwValue;
            DWORD dwSize = 4;

            if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "UseMMXForRGB", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) &&
                 dwType == REG_DWORD &&
                 dwValue == 0)
            {
                bUseMMXAsRGBDevice = FALSE;
            }
            RegCloseKey( hKey );
        }
        if (bUseMMXAsRGBDevice)
        {
            D3D_INFO(0, "  using MMX in RGB device");
        }
    }


    if (IsEqualIID(*pGuid, IID_IDirect3DRGBDevice) &&
        isMMXprocessor())
    {
        // Check for whether this app is one of the Intel ones
        // that want the MMX rasterizer
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl;

        // 0x4 corresponds to the "Intel app that wants MMX"
        // flag defined in ddrawpr.h
        if ( lpDDLcl->dwAppHackFlags & 0x4 )
        {
            pGuid = (GUID *)&IID_IDirect3DMMXDevice;
        }
    }

    /*
     * Check if the 3D cap is set on the surface.
     */
    memset(&ddsd, 0, sizeof ddsd);
    ddsd.dwSize = sizeof ddsd;
    ddrval = lpDDS->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        D3D_ERR("Failed to get surface description of device's surface.");
        return (ddrval);
    }

    if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE)) {
        D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
        D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
        D3D_ERR("**** when creating the surface.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.ddsCaps.dwCaps & DDSCAPS_ZBUFFER) {
        D3D_ERR("**** DDSCAPS_ZBUFFER is set on this surface.");
        D3D_ERR("**** Rendering into Z buffer surfaces is not");
        D3D_ERR("**** currently supported by Direct3D.");
        return (DDERR_INVALIDCAPS);
    }

    if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
    {
        D3D_ERR("**** Surface too large - must be <= 2048 in width & height.");
        return (DDERR_INVALIDOBJECT);
    }

    /* Check for palette... */
    ret = lpDDS->GetPalette(&lpDDPal);
    if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
    {
        /*
         * NOTE: Again, not an error (yet) if there is no palette attached.
         * But if there is palette and we can't get at it for some reason
         * - fail.
         */
        D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
        return (DDERR_INVALIDPARAMS);
    }

    /*
     * We're going to check now whether we should have got a palette.
     */
    if (ret == DDERR_NOPALETTEATTACHED) {
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16) {
            D3D_ERR("No palette supplied for palettized surface - can't create device");
            return (DDERR_NOPALETTEATTACHED);
        }
    }

    this->lpDDPalTarget = lpDDPal;

    // Check for ZBuffer

    memset(&surfCaps, 0, sizeof(DDSCAPS));
    surfCaps.dwCaps = DDSCAPS_ZBUFFER;

    if (FAILED(ret = lpDDS->GetAttachedSurface(&surfCaps, &lpDDSZ))) {
        if (ret != DDERR_NOTFOUND) {
           D3D_ERR("Failed GetAttachedSurface for ZBuffer");
           goto handle_err;
        }
        D3D_INFO(2, "No zbuffer is attached to rendertarget surface (which is OK)");
    }

    this->lpDDSZBuffer = lpDDSZ;

    this->guid = *pGuid;

    // Try to get a HAL provider for this driver (may need to use MMX guid if
    // using MMX for RGB requested device)
    ret = GetSwHalProvider(
        bUseMMXAsRGBDevice ? IID_IDirect3DMMXAsRGBDevice : riid,
        &this->pHalProv, &this->hDllProv);

    if (ret == S_OK)
    {
        // Got a software provider.
    }
    else if (ret == E_NOINTERFACE &&
             ((ret = GetHwHalProvider(riid, &this->pHalProv,
                                     &this->hDllProv,
                                     ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl)) == S_OK))
    {
        // Got a hardware provider.
    }
    else
    {
        if( IsEqualIID(riid, IID_IDirect3DHALDevice) ||
            IsEqualIID(riid, IID_IDirect3DTnLHalDevice)) {
            D3D_ERR("Requested HAL Device non-existent or invalid");
        } else {
            D3D_ERR("Unable to get D3D Device provider for requested GUID");
        }
        goto handle_err;
    }

    {
        // Initialize test HAL provider to drop HAL calls (sort of a Null device)
        //
        DWORD value = 0;
        if (GetD3DRegValue(REG_DWORD, "DisableRendering", &value, sizeof(DWORD)) &&
            value != 0)
        {
            ret = GetTestHalProvider(
                    riid, ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl,
                    &this->pHalProv, this->pHalProv, 0);
            if (ret != D3D_OK)
            {
                D3D_ERR("Unable to set up 'DisableRendering' mode");
                goto handle_err;
            }
        }
    }

    // Initialise general DEVICEI information.
    if ((ret = InitDeviceI(this, lpD3DI)) != D3D_OK)
    {
        D3D_ERR("Failed to initialise device");
        goto handle_err;
    }

    // Check the surface and device to see if they're compatible
    if (FAILED(ret = checkDeviceSurface(lpDDS,lpDDSZ,pGuid))) {
        D3D_ERR("Device and surface aren't compatible");
        goto handle_err;
    }

    // Create front-end support structures.
    // ATTENTION - We probably want to avoid doing this if the driver
    // does its own front end.  Software fallbacks complicate the issue,
    // though.
    ret = D3DFE_Create(this, lpD3DI->lpDD, lpD3DI->lpDD7, lpDDS, lpDDSZ, lpDDPal);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to create front-end data-structures.");
        goto handle_err;
    }

    // Figure out place for rstates
    if (IS_HW_DEVICE(this) && IS_DP2HAL_DEVICE(this))
    {
        // In case of HW DP2 HAL we reuse the kernel allocated
        // memory for RStates since we need the driver to update
        // it
        rstates = (LPDWORD)lpwDPBuffer;
    }
    else
    {
        // In all other cases we simply allocate memory for rstates
        rstates = new DWORD[D3D_MAXRENDERSTATES];
    }
    D3DFE_PROCESSVERTICES::lpdwRStates = this->rstates;

    // Check if we have a processor specific implementation available
    //  only use if DisablePSGP is not in registry or set to zero
    DWORD value;
    if (!GetD3DRegValue(REG_DWORD, "DisablePSGP", &value, sizeof(DWORD)))
    {
        value = 0;
    }
#ifdef _X86_
    if (value != 1)
    {
        if ( dwCPUFeatures & D3DCPU_X3D && value != 2)
           pfnFEContextCreate = px3DContextCreate;
        else if ( dwCPUFeatures & D3DCPU_WLMT )
           pfnFEContextCreate = wlmt_FEContextCreate;
        else if ( dwCPUFeatures & D3DCPU_SSE )
           pfnFEContextCreate = katmai_FEContextCreate;

        if (pfnFEContextCreate)
        {
            D3D_INFO(0, "PSGP enabled for device");
            // Ask the PV implementation to create a device specific "context"
            LPD3DFE_PVFUNCS pOptGeoFuncs = pGeometryFuncs;
            ret = pfnFEContextCreate(dwDeviceFlags, &pOptGeoFuncs);
            if ((ret == D3D_OK) && pOptGeoFuncs)
            {
                D3D_INFO(2, "using PSGP");
                pGeometryFuncs = pOptGeoFuncs;
            }
        }
    }
#endif // _X86_

    /*
     * put this device in the list of those owned by the Direct3D object
     */
    ret = HookToD3D(lpD3DI);
    if (ret != D3D_OK)
    {
        D3D_ERR("Failed to associate device with Direct3D");
        goto handle_err;
    }
    {
        if (HVbuf.Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DFE_CLIPCODE)) != DD_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (HVBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBuf.Grow
                (this, MAX_CLIP_VERTICES*__MAX_VERTEX_SIZE);
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBuf)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }
        ret = this->ClipperState.clipBufPrim.Grow
                (this, MAX_CLIP_TRIANGLES*sizeof(D3DTRIANGLE));
        if (ret != D3D_OK)
        {
            D3D_ERR( "Out of memory in DeviceCreate (ClipBufPrim)" );
            ret = DDERR_OUTOFMEMORY;
            goto handle_err;
        }

    }

    // this indicates that the device should always be flushed when Locking, Blting
    // or GetDC'ing a rendertarget
    ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;
    // this indicates that the device should always be flushed when Locking, Blting
    // or GetDC'ing a zbuffer
    if (lpDDSZ)
    {
        ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZ)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;
    }

    /* Set the initial render state of the device */
    if (FAILED(ret = stateInitialize(lpDDSZ!=NULL)))
    {
        D3D_ERR("Failed to set initial state for device");
        goto handle_err;
    }

    // Setup the viewport
    m_Viewport.dwX = 0;
    m_Viewport.dwY = 0;
    m_Viewport.dwWidth  = ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wWidth;
    m_Viewport.dwHeight = ((LPDDRAWI_DDRAWSURFACE_INT) lpDDS)->lpLcl->lpGbl->wHeight;
    m_Viewport.dvMinZ = (D3DVALUE)0;
    m_Viewport.dvMaxZ = (D3DVALUE)1;
    if (FAILED(this->SetViewport(&m_Viewport)))
        goto handle_err;

    // Setup lights
    m_dwNumLights = 8;
    m_pLights = new DIRECT3DLIGHTI[8];
    LIST_INITIALIZE(&m_ActiveLights);

    // Setup material
    memset(&this->lighting.material, 0, sizeof(this->lighting.material));

    // Setup set states
    m_pStateSets = new CStateSets;
    if (m_pStateSets == NULL)
        return DDERR_OUTOFMEMORY;
    m_pStateSets->Init(this->dwFEFlags);

#ifdef PROFILE4
    m_dwProfStart = m_dwProfStop = 0;
    GetD3DRegValue(REG_DWORD, "ProfileStartFrame", &m_dwProfStart, 4);
    GetD3DRegValue(REG_DWORD, "ProfileStopFrame", &m_dwProfStop, 4);
#endif
#ifdef PROFILE
    m_dwProfStart = m_dwProfStop = 0;
    GetD3DRegValue(REG_DWORD, "ProfileStartFrame", &m_dwProfStart, 4);
    GetD3DRegValue(REG_DWORD, "ProfileStopFrame", &m_dwProfStop, 4);
#endif

#ifdef VTABLE_HACK
    // Copy with vtable
    lpVtbl = *((LPVOID**)this);
    memcpy(newVtbl, lpVtbl, sizeof(PVOID)*D3D_NUM_VIRTUAL_FUNCTIONS);
    // Point to the new one
    *((LPVOID*)this) = (LPVOID)newVtbl;

    // Set vtable hack for PreLoad() if single threaded and not software
    if (!IS_MT_DEVICE(this) && (this->dwFEFlags & D3DFE_REALHAL))
    {
        VtblPreLoadFast();
    }
#endif // VTABLE_HACK

    /*
     * NOTE: We don't return the actual device interface. We
     * return the device's special IUnknown interface which
     * will be used in a QueryInterface to get the actual
     * Direct3D device interface.
     */
    *lplpD3DDevice = static_cast<LPUNKNOWN>(this);
    return (D3D_OK);

handle_err:
    // might be able to simplify if this fn and not D3DFE_Create sets this->lpDDSZBuffer/this->lpDDPalette
    if(lpDDSZ!=NULL) {
       lpDDSZ->Release();    // release the reference GetAttachedSurface created
       this->lpDDSZBuffer=NULL;  // make sure the device destructor doesn't try to re-release this
                                 // I'd let device destructor handle this, but errors can occur before D3DFE_Create is called
    }

    if(lpDDPal!=NULL) {
      lpDDPal->Release();      // release the reference GetPalette created
      this->lpDDPalTarget=NULL;  // make sure the device destructor doesn't try to re-release this
    }

    D3D_ERR("Device creation failed!!");
    return(ret);
}

HRESULT D3DAPI DIRECT3DDEVICEI::GetCaps(LPD3DDEVICEDESC7 lpD3DDevDesc)
{
    HRESULT ret;

    ret = D3D_OK;

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_D3DDEVICEDESC7_PTR(lpD3DDevDesc))
    {
        D3D_ERR( "Invalid D3DDEVICEDESC7 pointer" );
        return DDERR_INVALIDPARAMS;
    }
    memcpy(lpD3DDevDesc, &this->d3dDevDesc, sizeof( D3DDEVICEDESC7 ));
    return (ret);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EnumTextureFormats"

HRESULT D3DAPI DIRECT3DDEVICEI::EnumTextureFormats(
    LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
    LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDSURFACEDESC lpDescs, lpRetDescs;
    DWORD num_descs;
    DWORD i;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        ret = D3D_OK;

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALIDEX_CODE_PTR(lpEnumCallback))
        {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl;
        BOOL bFourCCAppHack =
            (lpDDLcl->dwAppHackFlags & DDRAW_APPCOMPAT_TEXENUMDX7FOURCC)?1:0;
        D3D_INFO(3, "APPCOMPAT_TEXENUMDX7FOURCC: %d",bFourCCAppHack);

        num_descs = this->lpD3DHALGlobalDriverData->dwNumTextureFormats;
        lpDescs = this->lpD3DHALGlobalDriverData->lpTextureFormats;
        if (!num_descs)
        {
            D3D_ERR("no texture formats supported");
            return (D3DERR_TEXTURE_NO_SUPPORT);
        }

        if (D3DMalloc((void**)&lpRetDescs, sizeof(DDSURFACEDESC) * num_descs) != D3D_OK)
        {
            D3D_ERR("failed to alloc space for return descriptions");
            return (DDERR_OUTOFMEMORY);
        }
        memcpy(lpRetDescs, lpDescs, sizeof(DDSURFACEDESC) * num_descs);

        userRet = D3DENUMRET_OK;
        for (i = 0; i < num_descs && userRet == D3DENUMRET_OK; i++) {

            // Filter out any DX8 formats
            if (lpRetDescs[i].ddpfPixelFormat.dwFlags & DDPF_D3DFORMAT)
            {
                continue;
            }

            // Filter out non-DXTn FourCCs if apphack set
            if ( bFourCCAppHack && (lpRetDescs[i].ddpfPixelFormat.dwFlags == DDPF_FOURCC) )
            {
                if ( (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '1')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '2')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '3')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '4')) &&
                     (lpRetDescs[i].ddpfPixelFormat.dwFourCC != MAKEFOURCC('D', 'X', 'T', '5')) )
                {
                    D3D_INFO(3, "EnumTextureFormats: filtering non-DXT FourCC format <%08x>",
                        lpRetDescs[i].ddpfPixelFormat.dwFourCC);
                    continue;
                }
            }

            userRet = (*lpEnumCallback)(&(lpRetDescs[i].ddpfPixelFormat), lpContext);
        }

        D3DFree(lpRetDescs);

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::ResetStats"
void DIRECT3DDEVICEI::ResetTexStats()
{
    this->lpDirect3DI->ResetTexStats();
    memset(&m_texstats, 0, sizeof(D3DDEVINFO_TEXTURING));
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::BeginScene"

HRESULT D3DAPI DIRECT3DDEVICEI::BeginScene()
{
#ifdef PROFILE4
    static DWORD dwFrameCount = 0;
#endif
#ifdef PROFILE
    static DWORD dwFrameCount = 0;
#endif
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
        {
            D3D_ERR("BeginScene, already in scene.");
            return (D3DERR_SCENE_IN_SCENE);
        }

        // Check if we lost surfaces or rtarget / zbuffer was locked
        HRESULT servRet = this->CheckSurfaces();
        if (servRet != D3D_OK)
        {
            // If we lost surfaces
            if (servRet == DDERR_SURFACELOST)
            {
                // Even if the app restores the rendertargets and z buffer, it
                // doesn't know anything about vidmem execute buffers or
                // managed texture surfaces in vidmem. So, we need to do
                // this on our own. We first check if it is safe to restore
                // surfaces. If not, we fail in the usual way. Else, we
                // do the restore. Note that we will fail *only* if the
                // app calls BeginScene at the wrong time.
                servRet = this->lpDirect3DI->lpDD7->TestCooperativeLevel();
                if (servRet == DD_OK)
                {
                    // Everything must be evicted otherwise Restore might not work
                    // as there might be new surface allocated, in fact, we should
                    // post a flag in Device so that Texture manage stop calling
                    // CreateSurface() if this flag is indicating TestCooperativeLevel()
                    // failed, however, even we added those, the EvictTextures below
                    // is still needed but not this critical--kanqiu
                    this->lpDirect3DI->lpTextureManager->EvictTextures();
                    if(IS_DP2HAL_DEVICE(this))
                    {
                        // We just bother restoring our internal vertex and command buffers
                        // It is upto the app to restore all surfaces that IT allocated.
                        // (managed textures are taken care of by the preceding evict)
                        CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2*>(this);
                        servRet = dp2dev->TLVbuf_GetDDS()->Restore();
                        if (servRet != DD_OK)
                            return D3DERR_SCENE_BEGIN_FAILED;
                        servRet = dp2dev->lpDDSCB1->Restore();
                        if (servRet != DD_OK)
                            return D3DERR_SCENE_BEGIN_FAILED;
                        // If TLVbuf was really lost
                        if (dp2dev->TLVbuf_GetVBI()->position.lpvData == 0)
                        {
                            DPF(10, "Need to reallocate TLVbuf");
                            // Reallocate TLVbuf of the orig size in the same memory location as before
                            dp2dev->TLVbuf_base = 0;
                            DWORD origSize = dp2dev->TLVbuf_size;
                            dp2dev->TLVbuf_size = 0;
                            if (dp2dev->TLVbuf_Grow(origSize, (this->dwDeviceFlags & D3DDEV_TLVBUFWRITEONLY) != 0) != DD_OK)
                            {
                                D3D_ERR( "Out of memory in BeginScene (TLVbuf)" );
                                return DDERR_OUTOFMEMORY;
                            }
                        }
                        // Release current VB since it could be app created and app might want
                        // to get rid of it due to the mode change.
                        if (dp2dev->lpDP2CurrBatchVBI)
                        {
                            dp2dev->lpDP2CurrBatchVBI->lpDevIBatched = NULL;
                            dp2dev->lpDP2CurrBatchVBI->Release();
                        }
                        dp2dev->lpDP2CurrBatchVBI = dp2dev->TLVbuf_GetVBI();
                        dp2dev->lpDP2CurrBatchVBI->AddRef();
                        dp2dev->dp2data.lpDDVertex = DDSLCL(dp2dev->TLVbuf_GetDDS());
                        dp2dev->dp2data.dwVertexLength = 0;
#ifdef VTABLE_HACK
                        dp2dev->VtblDrawPrimitiveDefault();
                        dp2dev->VtblDrawPrimitiveVBDefault();
                        dp2dev->VtblDrawIndexedPrimitiveDefault();
                        dp2dev->VtblDrawIndexedPrimitiveVBDefault();
#endif
                    }
                    servRet = this->CheckSurfaces();
                    if(servRet != D3D_OK)
                        return servRet;
                    this->dwFEFlags &= ~D3DFE_LOSTSURFACES;
                }
                else
                    return DDERR_SURFACELOST;
            }
            else
            {
                // Render target and / or the z buffer was locked
                return servRet;
            }
        }
        else
        {
            // We need to check if TLVbuf was lost. The app could have restored
            // all surfaces and thus we might not know by check TCL. However the
            // BreakLock function would have been called on the VB and the position.lpvData
            // would be set to NULL. We check this to detect that the TLVbuf was lost.
            if (IS_DP2HAL_DEVICE(this))
            {
                CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2*>(this);
                // If the lock was broken
                if (dp2dev->TLVbuf_GetVBI()->position.lpvData == 0)
                {
                    DPF(10, "Broken lock on TLVbuf. Need to reallocate");
                    // Reallocate TLVbuf of the orig size in the same memory location as before
                    dp2dev->TLVbuf_base = 0;
                    DWORD origSize = dp2dev->TLVbuf_size;
                    dp2dev->TLVbuf_size = 0;
                    if (dp2dev->TLVbuf_Grow(origSize, (this->dwDeviceFlags & D3DDEV_TLVBUFWRITEONLY) != 0) != DD_OK)
                    {
                        D3D_ERR( "Out of memory in BeginScene (TLVbuf)" );
                        return DDERR_OUTOFMEMORY;
                    }
                }
            }
        }
        if (IS_DX7HAL_DEVICE(this))
        {
            if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            {
                D3D_ERR("Cannot be recording state macros when calling BeginScene");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, TRUE);
        }
        else
            servRet = D3DHAL_SceneCapture(this, TRUE);

        if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
        {
            D3D_ERR("Could not BeginScene.");
            return D3DERR_SCENE_BEGIN_FAILED;
        }

#ifdef PROFILE4
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 7.0: Started Profiling...\n");
            StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
            OutputDebugString("Direct3D IM 7.0: Stopped Profiling.\n");
        }
#endif
#ifdef PROFILE
        if (++dwFrameCount == m_dwProfStart)
        {
            OutputDebugString("Direct3D IM 7.0: Started Profiling...\n");
            StartCAP();
        }
        else if (dwFrameCount == m_dwProfStop)
        {
            StopCAP();
            OutputDebugString("Direct3D IM 7.0: Stopped Profiling.\n");
        }
#endif

        // So that currently bound textures get scene stamped
        m_dwStageDirty = (1ul << this->dwMaxTextureBlendStages) - 1ul;
        this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;

#if COLLECTSTATS
        this->lpDirect3DI->lpTextureManager->ResetStatCounters();
        this->ResetTexStats();
#endif

        this->dwHintFlags |= D3DDEVBOOL_HINTFLAGS_INSCENE;
        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DisplayStats"

void DIRECT3DDEVICEI::DisplayStats()
{
    HDC hDC;
    if(SUCCEEDED(this->lpDDSTarget_DDS7->GetDC(&hDC)))
    {
        HFONT hOldFont = (HFONT)SelectObject(hDC, this->lpDirect3DI->m_hFont);
        SetTextColor(hDC, RGB(255,255,0));
        SetBkMode(hDC, TRANSPARENT);
        D3DDEVINFO_TEXTUREMANAGER stats;
        GetInfo(D3DDEVINFOID_TEXTUREMANAGER, &stats, sizeof(D3DDEVINFO_TEXTUREMANAGER));
        char str[256];
        int x = STATS_FONT_SIZE, y = STATS_FONT_SIZE, len;
        len = sprintf(str, "Texture Cache Management Statistics");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "-----------------------------------");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Thrashing     : %s", stats.bThrashing ? "Yes" : "No");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Downloaded    : %d bytes", stats.dwApproxBytesDownloaded);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Evicts        : %d", stats.dwNumEvicts);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Creates       : %d", stats.dwNumVidCreates);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Textures used : %d", stats.dwNumTexturesUsed);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Hit rate      : %d%%", stats.dwNumTexturesUsed != 0 ? ((stats.dwNumUsedTexInVid * 100) / stats.dwNumTexturesUsed) : 0);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Working set   : %d (%d bytes)", stats.dwWorkingSet, stats.dwWorkingSetBytes);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Total managed : %d (%d bytes)", stats.dwTotalManaged, stats.dwTotalBytes);
        TextOut( hDC, x, y, str, len );
        D3DDEVINFO_TEXTURING texstats;
        GetInfo(D3DDEVINFOID_TEXTURING, &texstats, sizeof(D3DDEVINFO_TEXTURING));
        y += STATS_FONT_SIZE * 2;
        len = sprintf(str, "Texturing Statistics");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "--------------------");
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Loads         : %d (%d bytes)", texstats.dwNumLoads, texstats.dwApproxBytesLoaded);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "PreLoads      : %d", texstats.dwNumPreLoads);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "SetTextures   : %d", texstats.dwNumSet);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Creates       : %d", texstats.dwNumCreates);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Destroys      : %d", texstats.dwNumDestroys);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "SetPriorities : %d", texstats.dwNumSetPriorities);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "SetLODs       : %d", texstats.dwNumSetLODs);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "Locks         : %d", texstats.dwNumLocks);
        TextOut( hDC, x, y, str, len );
        y += STATS_FONT_SIZE;
        len = sprintf(str, "GetDCs        : %d", texstats.dwNumGetDCs);
        TextOut( hDC, x, y, str, len );
        SelectObject(hDC, hOldFont);
        this->lpDDSTarget_DDS7->ReleaseDC(hDC);
    }
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::EndScene"

HRESULT D3DAPI DIRECT3DDEVICEI::EndScene()
{
    HRESULT servRet;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!(this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)) {
            D3D_ERR("EndScene, not in scene.");
            return (D3DERR_SCENE_NOT_IN_SCENE);
        }

        this->dwHintFlags &= ~D3DDEVBOOL_HINTFLAGS_INSCENE;
        if (IS_DX7HAL_DEVICE(this))
        {
            if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            {
                D3D_ERR("Cannot be recording state macros when calling EndScene");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_SCENECAPTURE, FALSE);
            if (servRet != D3D_OK)
            {
                D3D_ERR("Could not send EndScene to Driver!");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = FlushStates();    //time to flush DrawPrimitives
        }
        else
        {
            servRet = FlushStates();    //time to flush DrawPrimitives
            if (servRet != D3D_OK)
            {
                D3D_ERR("Could not Flush commands in EndScene!");
                return (D3DERR_SCENE_END_FAILED);
            }
            servRet = D3DHAL_SceneCapture(this, FALSE);
        }
        if (servRet != D3D_OK && servRet != DDERR_NOTFOUND)
        {
            DPF(0, "(ERROR) Direct3DDevice::EndScene: Could not EndScene. Returning %08lx", servRet);
            return (D3DERR_SCENE_END_FAILED);
        }

        // Did we lose any surfaces during this scene ?
        if (this->dwFEFlags & D3DFE_LOSTSURFACES)
        {
            D3D_INFO(3, "reporting DDERR_SURFACELOST in EndScene");
            this->dwFEFlags &= ~D3DFE_LOSTSURFACES;
            return DDERR_SURFACELOST;
        }

        // Update the scene count in texman
        lpDirect3DI->lpTextureManager->SceneStamp();

        // Clear num TLVbuf changes per frame
        if (IS_DP2HAL_DEVICE(this))
        {
            CDirect3DDeviceIDP2* dev = static_cast<CDirect3DDeviceIDP2*>(this);
            dev->dwTLVbufChanges = 0;
        }

#if COLLECTSTATS
        // Display stats if they have been enabled via regkey
        if(this->lpDirect3DI->m_hFont != 0)
        {
            DisplayStats();
        }
#endif

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

void
D3DDeviceDescConvert(LPD3DDEVICEDESC7 lpOut,
                     LPD3DDEVICEDESC_V1 lpV1,
                     LPD3DHAL_D3DEXTENDEDCAPS lpExt)
{
    if( lpV1 )
    {
        lpOut->dwDevCaps = lpV1->dwDevCaps;
        lpOut->dpcLineCaps = lpV1->dpcLineCaps;
        lpOut->dpcTriCaps = lpV1->dpcTriCaps;
        lpOut->dwDeviceRenderBitDepth = lpV1->dwDeviceRenderBitDepth;
        lpOut->dwDeviceZBufferBitDepth = lpV1->dwDeviceZBufferBitDepth;
    }

    if (lpExt)
    {
        // DX5
        lpOut->dwMinTextureWidth = lpExt->dwMinTextureWidth;
        lpOut->dwMaxTextureWidth = lpExt->dwMaxTextureWidth;
        lpOut->dwMinTextureHeight = lpExt->dwMinTextureHeight;
        lpOut->dwMaxTextureHeight = lpExt->dwMaxTextureHeight;

        // DX6
        lpOut->dwMaxTextureRepeat = lpExt->dwMaxTextureRepeat;
        lpOut->dwMaxTextureAspectRatio = lpExt->dwMaxTextureAspectRatio;
        lpOut->dwMaxAnisotropy = lpExt->dwMaxAnisotropy;
        lpOut->dvGuardBandLeft = lpExt->dvGuardBandLeft;
        lpOut->dvGuardBandTop = lpExt->dvGuardBandTop;
        lpOut->dvGuardBandRight = lpExt->dvGuardBandRight;
        lpOut->dvGuardBandBottom = lpExt->dvGuardBandBottom;
        lpOut->dvExtentsAdjust = lpExt->dvExtentsAdjust;
        lpOut->dwStencilCaps = lpExt->dwStencilCaps;
        lpOut->dwFVFCaps = lpExt->dwFVFCaps;
        lpOut->dwTextureOpCaps = lpExt->dwTextureOpCaps;
        lpOut->wMaxTextureBlendStages = lpExt->wMaxTextureBlendStages;
        lpOut->wMaxSimultaneousTextures = lpExt->wMaxSimultaneousTextures;

        // DX7
        lpOut->dwMaxActiveLights = lpExt->dwMaxActiveLights;
        lpOut->dvMaxVertexW = lpExt->dvMaxVertexW;
        lpOut->wMaxUserClipPlanes = lpExt->wMaxUserClipPlanes;
        lpOut->wMaxVertexBlendMatrices = lpExt->wMaxVertexBlendMatrices;
        lpOut->dwVertexProcessingCaps = lpExt->dwVertexProcessingCaps;
        lpOut->dwReserved1 = lpExt->dwReserved1;
        lpOut->dwReserved2 = lpExt->dwReserved2;
        lpOut->dwReserved3 = lpExt->dwReserved3;
        lpOut->dwReserved4 = lpExt->dwReserved4;
    }
}

//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CheckSurfaces"

HRESULT DIRECT3DDEVICEI::CheckSurfaces()
{
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetDirect3D"

HRESULT D3DAPI DIRECT3DDEVICEI::GetDirect3D(LPDIRECT3D7 *lplpD3D)
{

    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_OUTPTR(lplpD3D))
    {
        D3D_ERR( "Invalid Direct3D pointer pointer" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpD3D = (LPDIRECT3D7) this->lpDirect3DI;
    (*lplpD3D)->AddRef();

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::HookTexture"

LPD3DI_TEXTUREBLOCK DIRECT3DDEVICEI::HookTexture(LPDIRECT3DTEXTUREI lpD3DText)
{
    LPD3DI_TEXTUREBLOCK nBlock;

    if (D3DMalloc((void**)&nBlock, sizeof(D3DI_TEXTUREBLOCK)) != D3D_OK)
    {
        D3D_ERR("failed to allocate space for texture block");
        return NULL;
    }
    nBlock->lpDevI = this;
    nBlock->lpD3DTextureI = lpD3DText;
    nBlock->hTex = 0;              // initialized to be zero

    LIST_INSERT_ROOT(&lpD3DText->blocks, nBlock, list);
    LIST_INSERT_ROOT(&texBlocks, nBlock, devList);

    return nBlock;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::D3DI_FindTextureBlock"

LPD3DI_TEXTUREBLOCK DIRECT3DDEVICEI::D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI lpTex)
{
    LPD3DI_TEXTUREBLOCK tBlock;

    tBlock = LIST_FIRST(&lpTex->blocks);
    while (tBlock) {
        //  return match for Texture(2) only (not Texture3)
        if (tBlock->lpDevI == this) {
            return tBlock;
        }
        tBlock = LIST_NEXT(tBlock,list);
    }
    return NULL;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetTextureDDIHandle"

HRESULT DIRECT3DDEVICEI::GetTextureDDIHandle(LPDIRECT3DTEXTUREI lpTexI,
                                             LPD3DI_TEXTUREBLOCK* lplpBlock)
{
    HRESULT ret;
    LPD3DI_TEXTUREBLOCK lpBlock=*lplpBlock; //in case has the pointer

    DDASSERT(lpTexI);
    /*
     * Find out if we've used this device before.
     */
    if (!lpBlock)
    {
        lpBlock = D3DI_FindTextureBlock(lpTexI);
        if (!lpBlock)
        {
            /*
             * Put this device in the list of those owned by the
             * Direct3DDevice object
             */
            lpBlock=HookTexture(lpTexI);
            if (!lpBlock)
            {
                D3D_ERR("failed to associate texture with device");
                return DDERR_OUTOFMEMORY;
            }
        }
        *lplpBlock = lpBlock;
    }
    if (!lpBlock->hTex)
    {
        if (lpTexI->D3DManaged())
        {
            if(!lpTexI->InVidmem()) // This check covers the case when hTex is zero,
                                    // but there ALREADY IS a vidmem copy don't
                                    // create another one. This case arises when
                                    // InvalidateHandles() is called by SetRenderTarget.
            {
                ret = lpDirect3DI->lpTextureManager->allocNode(lpTexI, this);
                if (D3D_OK != ret)
                {
                    D3D_ERR("Failed to create video memory surface");
                    return ret;
                }
            }
            lpDirect3DI->lpTextureManager->TimeStamp(lpTexI);
        }
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));
        if (D3D_OK != (ret=D3DHAL_TextureCreate(this, &lpBlock->hTex, (LPDIRECTDRAWSURFACE)&(lpTexI->DDS1Tex))))
            return ret;
    }
    else
    {
        if(lpTexI->D3DManaged())
            lpDirect3DI->lpTextureManager->TimeStamp(lpTexI);
    }

    DDASSERT(lpBlock->hTex);
    return D3D_OK;
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "BytesDownloaded"

DWORD BytesDownloaded(LPDDRAWI_DDRAWSURFACE_LCL lpLcl, LPRECT lpRect)
{
    DWORD bytes;
    if( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
        (lpLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) )
    {
        switch (lpLcl->lpGbl->ddpfSurface.dwFourCC)
        {
        case FOURCC_DXT1:
        case FOURCC_DXT2:
        case FOURCC_DXT3:
        case FOURCC_DXT4:
        case FOURCC_DXT5:
            if(lpRect == NULL)
            {
                bytes = lpLcl->lpGbl->dwLinearSize;
            }
            else
            {
                bytes = (DWORD)(lpLcl->lpGbl->dwLinearSize * (double((lpRect->right - lpRect->left) * (lpRect->bottom - lpRect->top)) /
                                                              double(lpLcl->lpGbl->wWidth * lpLcl->lpGbl->wHeight)));
            }
            return lpLcl->lpSurfMore->dwMipMapCount == 0 ? bytes : (DWORD)(bytes * ((1. - pow(.25, lpLcl->lpSurfMore->dwMipMapCount)) / .75));
        }
    }
    if(lpRect == NULL)
    {
        bytes = lpLcl->lpGbl->lPitch * lpLcl->lpGbl->wHeight;
    }
    else
    {
        bytes = (DWORD)(lpLcl->lpGbl->lPitch * lpLcl->lpGbl->wHeight *
                            (double((lpRect->right - lpRect->left) * (lpRect->bottom - lpRect->top)) /
                             double(lpLcl->lpGbl->wWidth * lpLcl->lpGbl->wHeight)));
    }
    return lpLcl->lpSurfMore->dwMipMapCount == 0 ? bytes : (DWORD)(bytes * ((1. - pow(.25, lpLcl->lpSurfMore->dwMipMapCount)) / .75));
}
#endif

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::PreLoad"

HRESULT D3DAPI DIRECT3DDEVICEI::PreLoad(LPDIRECTDRAWSURFACE7 lpSrc)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if(!(this->dwFEFlags & D3DFE_REALHAL))
    {
        D3D_WARN(2, "PreLoad called on a software device");
        return D3D_OK;
    }

    return PreLoadFast(lpSrc);
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::PreLoadFast"

HRESULT D3DAPI DIRECT3DDEVICEI::PreLoadFast(LPDIRECTDRAWSURFACE7 lpSrc)
{
#if DBG
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
        return DDERR_INVALIDOBJECT;
    }

    if (!VALID_DDSURF_PTR(lpSrc))
    {
        D3D_ERR( "Invalid DIRECTDRAWSURFACE7 source pointer" );
        return DDERR_INVALIDOBJECT;
    }

    if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl))
    {
        D3D_ERR( "Cannot PreLoad a mipmap sublevel or a cubemap subface" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    LPDIRECT3DTEXTUREI this_src = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl->lpSurfMore->lpTex);
#if DBG
    if (this_src == NULL)
    {
        D3D_ERR( "Not a texture" );
        return DDERR_INVALIDPARAMS;
    }
#endif
#if COLLECTSTATS
    this->IncNumPreLoads();
#endif
    try
    {
        HRESULT ddrval = D3D_OK;
        if (!this_src->D3DManaged())
        {
#if DBG
            // Make sure that texture is driver managed
            if(!(DDSCAPS2_TEXTUREMANAGE & ((LPDDRAWI_DDRAWSURFACE_INT)(this_src->lpDDS))->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2))
            {
                D3D_ERR( "Cannot PreLoad unmanaged textures" );
                return DDERR_INVALIDPARAMS;
            }
#endif
            if(this->lpDirect3DI->numDevs > 1)
            {
                D3D_WARN(2, "Multiple devices used. Calling Flush");
                ddrval = this->lpDirect3DI->FlushDevicesExcept(this); // to avoid sync problems
                if(ddrval != D3D_OK)
                {
                    D3D_ERR("Error flushing devices");
                    return ddrval;
                }
            }
            POINT p = {0, 0};
            RECTL r = {0, 0, 0, 0};
            DDASSERT(IS_DX7HAL_DEVICE(this));
            ddrval = static_cast<CDirect3DDevice7*>(this)->TexBltI(NULL, ((LPDDRAWI_DDRAWSURFACE_INT)(this_src->lpDDS))->lpLcl, &p, &r, 0);
            if(ddrval != D3D_OK)
            {
                DPF_ERR("Error inserting TexBlt instruction in batch");
                return ddrval;
            }
            if(this->lpDirect3DI->numDevs > 1)
            {
                ddrval = FlushStates(); // to avoid sync problems
                if(ddrval != D3D_OK)
                {
                    D3D_ERR("Error flushing device");
                    return ddrval;
                }
            }
            else
            {
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(this_src->lpDDS))->lpLcl);
            }
        }
        else if (this_src->InVidmem())
        {
            if (this_src->bDirty)
            {
                // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
                // that this is a sysmem -> vidmem transfer.
                ddrval = CopySurface(this_src->lpDDS,NULL,this_src->lpDDSSys,NULL,0xFFFFFFFF);
                if (DD_OK == ddrval)
                {
                    this_src->bDirty=FALSE;
                    D3D_INFO(4,"Load: Dirty texture updated");
                }
            }
#if COLLECTSTATS
            this->lpDirect3DI->lpTextureManager->IncNumTexturesSet();
            this->lpDirect3DI->lpTextureManager->IncNumSetTexInVid();
#endif
        }
        else
        {
            if(IS_DX7HAL_DEVICE(this))
            {
                D3DTEXTUREHANDLE hTex;
                ddrval = static_cast<CDirect3DDevice7*>(this)->GetTextureDDIHandle(this_src, &hTex);
            }
            else
            {
                LPD3DI_TEXTUREBLOCK lpBlock = NULL;
                ddrval = GetTextureDDIHandle(this_src, &lpBlock);
            }
#if COLLECTSTATS
            this->lpDirect3DI->lpTextureManager->IncNumTexturesSet();
#endif
        }
        return ddrval;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::Load"

HRESULT D3DAPI DIRECT3DDEVICEI::Load(LPDIRECTDRAWSURFACE7 lpDest, LPPOINT lpDestPoint,
                                     LPDIRECTDRAWSURFACE7 lpSrc, LPRECT lpSrcRect, DWORD dwFlags)
{
    LPDIRECT3DTEXTUREI  this_src, this_dst;
    HRESULT     ddrval = D3D_OK;
    LPDIRECTDRAWSURFACE7 lpDDSSrc, lpDDSDst;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock (can't take MT since code accesses DDraw surf global)
                                                        // Release in the destructor
#if DBG
        // validate args
        if(lpDestPoint != NULL && lpSrcRect == NULL)
        {
            D3D_ERR( "Cannot have NULL src rect and non-NULL dest" );
            return DDERR_INVALIDPARAMS;
        }
        if(lpDestPoint != NULL)
        {
            if(!VALID_GDIPOINT_PTR(lpDestPoint))
            {
                D3D_ERR( "Invalid POINT pointer" );
                return DDERR_INVALIDOBJECT;
            }
        }
        if(lpSrcRect != NULL)
        {
            if(!VALID_GDIRECT_PTR(lpSrcRect))
            {
                D3D_ERR( "Invalid RECT pointer" );
                return DDERR_INVALIDOBJECT;
            }
        }
        if(dwFlags & (~DDSCAPS2_CUBEMAP_ALLFACES))
        {
            D3D_ERR( "Invalid flags" );
            return DDERR_INVALIDPARAMS;
        }

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_DDSURF_PTR(lpDest))
        {
            D3D_ERR( "Invalid DIRECTDRAWSURFACE7 dest pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpDest)->lpLcl))
        {
            D3D_ERR( "Cannot Load to a mipmap sublevel or a cubemap subface" );
            return DDERR_INVALIDPARAMS;
        }
#endif
        this_dst = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpDest)->lpLcl->lpSurfMore->lpTex);
#if DBG
        if(this_dst == NULL)
        {
            D3D_ERR( "Destination surface not a texture" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_DDSURF_PTR(lpSrc))
        {
            D3D_ERR( "Invalid DIRECTDRAWSURFACE7 source pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl))
        {
            D3D_ERR( "Cannot Load from a mipmap sublevel or a cubemap subface" );
            return DDERR_INVALIDPARAMS;
        }
#endif
        this_src = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpSrc)->lpLcl->lpSurfMore->lpTex);
#if DBG
        if(this_src == NULL)
        {
            D3D_ERR( "Source surface not a texture" );
            return DDERR_INVALIDPARAMS;
        }
#endif
#if COLLECTSTATS
        this->IncNumLoads();
#endif

        if(this_src->D3DManaged())
            lpDDSSrc = this_src->lpDDSSys;
        else
            lpDDSSrc = this_src->lpDDS;

        RECT destRect, *lpDestRect;
        if(lpDestPoint)
        {
            if(IsRectEmpty(lpSrcRect))
            {
                D3D_ERR( "Source rectangle is empty" );
                return DDERR_INVALIDPARAMS;
            }
            WORD &width  = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wWidth;
            WORD &height = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wHeight;
            if(lpSrcRect->left < 0 ||
                lpSrcRect->left >= width ||
                lpSrcRect->top < 0 ||
                lpSrcRect->top >= height ||
                lpSrcRect->right <= 0 ||
                lpSrcRect->right > width ||
                lpSrcRect->bottom <= 0 ||
                lpSrcRect->bottom > height)
            {
                D3D_ERR( "Rectangle outside source texture" );
                return DDERR_INVALIDPARAMS;
            }
            destRect.left   = lpDestPoint->x;
            destRect.top    = lpDestPoint->y;
            destRect.right  = lpDestPoint->x + (lpSrcRect->right - lpSrcRect->left);
            destRect.bottom = lpDestPoint->y + (lpSrcRect->bottom - lpSrcRect->top);
            lpDestRect = &destRect;
            if(lpDestRect->left < 0 ||
                lpDestRect->left >= width ||
                lpDestRect->top < 0 ||
                lpDestRect->top >= height ||
                lpDestRect->right <= 0 ||
                lpDestRect->right > width ||
                lpDestRect->bottom <= 0 ||
                lpDestRect->bottom > height)
            {
                D3D_ERR( "Rectangle outside destination texture" );
                return DDERR_INVALIDPARAMS;
            }
        }
        else
        {
            if(lpSrcRect)
            {
                if(IsRectEmpty(lpSrcRect))
                {
                    D3D_ERR( "Source rectangle is empty" );
                    return DDERR_INVALIDPARAMS;
                }
                WORD &width  = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wWidth;
                WORD &height = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl->lpGbl->wHeight;
                if(lpSrcRect->left < 0 ||
                    lpSrcRect->left >= width ||
                    lpSrcRect->top < 0 ||
                    lpSrcRect->top >= height ||
                    lpSrcRect->right <= 0 ||
                    lpSrcRect->right > width ||
                    lpSrcRect->bottom <= 0 ||
                    lpSrcRect->bottom > height)
                {
                    D3D_ERR( "Source rectangle outside texture" );
                    return DDERR_INVALIDPARAMS;
                }
                destRect = *lpSrcRect;
                lpDestRect = &destRect;
            }
            else
            {
                lpDestRect = NULL;
            }
        }
        if(this_dst->D3DManaged())
            lpDDSDst = this_dst->lpDDSSys;
        else
            lpDDSDst = this_dst->lpDDS;
        ddrval = CopySurface(lpDDSDst, lpDestRect, lpDDSSrc, lpSrcRect, dwFlags);
        return ddrval;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CanDoTexBlt"

bool DIRECT3DDEVICEI::CanDoTexBlt(LPDDRAWI_DDRAWSURFACE_LCL lpDDSSrcSubFace_lcl,
                                  LPDDRAWI_DDRAWSURFACE_LCL lpDDSDstSubFace_lcl)
{
    return false;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CopySurface"

HRESULT DIRECT3DDEVICEI::CopySurface(LPDIRECTDRAWSURFACE7 lpDDSDst,
                                     LPRECT lpDestRect,
                                     LPDIRECTDRAWSURFACE7 lpDDSSrc,
                                     LPRECT lpSrcRect,
                                     DWORD dwFlags)
{

    DDRAWI_DDRAWSURFACE_INT DDSSrcSubFace, DDSDstSubFace;
    DDSSrcSubFace.lpVtbl = DDSDstSubFace.lpVtbl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpVtbl;
    DDSDstSubFace.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSDst)->lpLcl;
    DDSSrcSubFace.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSSrc)->lpLcl;
    LPDIRECTDRAWSURFACE7 lpDDSSrcSubFace = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSSrcSubFace);
    LPDIRECTDRAWSURFACE7 lpDDSDstSubFace = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSDstSubFace);
    CCubemapIter cmsrc(DDSSrcSubFace.lpLcl), cmdst(DDSDstSubFace.lpLcl);
    while(true)
    {
        DDSSrcSubFace.lpLcl = cmsrc();
        DDSDstSubFace.lpLcl = cmdst();
        DWORD face = DDSSrcSubFace.lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
        if(face != (DDSDstSubFace.lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES))
        {
            D3D_ERR("Destination texture has different cubemap faces than source");
            return DDERR_INVALIDPARAMS;
        }
        if(face == 0 || (DDSSrcSubFace.lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & dwFlags))
        {
            HRESULT ddrval = D3D_OK;
            DWORD psize = 0;
            if (DDSDstSubFace.lpLcl->lpDDPalette)
            {
                if(DDSSrcSubFace.lpLcl->lpDDPalette)
                {
                    const DWORD paltype = DDPF_PALETTEINDEXED8 | DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED2 | DDPF_PALETTEINDEXED1;
                    if((PixelFormat(DDSDstSubFace.lpLcl).dwFlags & paltype) != (PixelFormat(DDSSrcSubFace.lpLcl).dwFlags & paltype))
                    {
                        D3D_ERR("Src texture is has a different type of palette than dest");
                        return DDERR_INVALIDPARAMS;
                    }
                    switch(PixelFormat(DDSDstSubFace.lpLcl).dwFlags & paltype)
                    {
                    case DDPF_PALETTEINDEXED1:
                        psize = 2;
                        break;
                    case DDPF_PALETTEINDEXED2:
                        psize = 4;
                        break;
                    case DDPF_PALETTEINDEXED4:
                        psize = 16;
                        break;
                    case DDPF_PALETTEINDEXED8:
                        psize = 256;
                        break;
                    default:
                        D3D_ERR("Paletted texture format not supported");
                        return E_NOTIMPL;
                    }
                    ddrval = (reinterpret_cast<LPDIRECTDRAWPALETTE>(DDSDstSubFace.lpLcl->lpDDPalette))->SetEntries(0, 0, psize, DDSSrcSubFace.lpLcl->lpDDPalette->lpLcl->lpGbl->lpColorTable);
                    if (ddrval != DD_OK)
                    {
                        D3D_ERR("Failed to set palette entries in dest texture");
                        return ddrval;
                    }
                }
                else
                {
                    D3D_WARN(2, "Destination texture has palette, but source has none");
                }
            }

            /* Copy color keys */
            if(DDSSrcSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_DESTBLT, &DDSSrcSubFace.lpLcl->ddckCKDestBlt);
            else if(DDSDstSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYDESTBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_DESTBLT, NULL);
            if(DDSSrcSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_SRCBLT, &DDSSrcSubFace.lpLcl->ddckCKSrcBlt);
            else if(DDSDstSubFace.lpLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
                lpDDSDstSubFace->SetColorKey(DDCKEY_SRCBLT, NULL);

            DDRAWI_DDRAWSURFACE_INT DDSSrcSubMip, DDSDstSubMip;
            DDSSrcSubMip.lpVtbl = DDSDstSubMip.lpVtbl = DDSSrcSubFace.lpVtbl;
            DDSDstSubMip.lpLcl = DDSDstSubFace.lpLcl;
            DDSSrcSubMip.lpLcl = DDSSrcSubFace.lpLcl;
            LPDIRECTDRAWSURFACE7 lpDDSSrcSubMip = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSSrcSubMip);
            LPDIRECTDRAWSURFACE7 lpDDSDstSubMip = reinterpret_cast<LPDIRECTDRAWSURFACE7>(&DDSDstSubMip);
            RECT SrcRct, DstRct, *lpSrcRct, *lpDstRct;
            if(lpSrcRect)
            {
                SrcRct = *lpSrcRect;
                lpSrcRct = &SrcRct;
            }
            else
                lpSrcRct = NULL;
            if(lpDestRect)
            {
                DstRct = *lpDestRect;
                lpDstRct = &DstRct;
            }
            else
                lpDstRct = NULL;
            CMipmapIter mmsrc(DDSSrcSubMip.lpLcl), mmdst(DDSDstSubMip.lpLcl);
            unsigned srcmipoff = 0;
            while(mmsrc()->lpGbl->wHeight != mmdst()->lpGbl->wHeight || mmsrc()->lpGbl->wWidth != mmdst()->lpGbl->wWidth)
            {

//
//  _COMPUTE_NEXT_LOD_RECT - Computes rectangle (in place) for next smaller LOD in mip
//  chain.  Top & left are divided by two, which effectively rounds down (via truncation).
//  Bottom & right are incremented prior to truncated-division, which will round up.
//  Result is guaranteed to be at least 1x1 in size.
//
#define _COMPUTE_NEXT_LOD_RECT( m_pRct )                                                \
{                                                                                       \
    (m_pRct)->left >>= 1;                                                               \
    (m_pRct)->top  >>= 1;                                                               \
    DWORD right  = ((m_pRct)->right +1) >> 1;                                           \
    DWORD bottom = ((m_pRct)->bottom+1) >> 1;                                           \
    (m_pRct)->right  = ((right  - (m_pRct)->left) < 1) ? ((m_pRct)->left+1) : (right);  \
    (m_pRct)->bottom = ((bottom - (m_pRct)->top ) < 1) ? ((m_pRct)->top +1) : (bottom); \
}

                if(lpSrcRct)
                {
                    _COMPUTE_NEXT_LOD_RECT(lpSrcRct)
                }
                if(lpDstRct)
                {
                    _COMPUTE_NEXT_LOD_RECT(lpDstRct)
                }
                ++srcmipoff;
                ++mmsrc;
                if(mmsrc == 0)
                {
                    D3D_ERR("Size mismatch between source and destination textures");
                    return DDERR_INVALIDPARAMS;
                }
            }
            DWORD dstmipcnt = DDSDstSubMip.lpLcl->lpSurfMore->dwMipMapCount == 0 ? 1 : DDSDstSubMip.lpLcl->lpSurfMore->dwMipMapCount;
            DWORD srcmipcnt = DDSSrcSubMip.lpLcl->lpSurfMore->dwMipMapCount == 0 ? 1 : DDSSrcSubMip.lpLcl->lpSurfMore->dwMipMapCount;
            if(dstmipcnt != (srcmipcnt - srcmipoff))
            {
                if(dstmipcnt > (srcmipcnt - srcmipoff))
                {
                    D3D_ERR("Destination texture has more mipmap levels than source");
                    return DDERR_INVALIDPARAMS;
                }
                else
                    D3D_INFO(3, "Destination texture has fewer mipmap levels than source");
            }

#if COLLECTSTATS
            if(dwFlags == 0xFFFFFFFF) // texman CopySurface
                this->lpDirect3DI->lpTextureManager->IncBytesDownloaded(DDSDstSubMip.lpLcl, lpDstRct);
            else
                this->IncBytesDownloaded(DDSDstSubMip.lpLcl, lpDstRct);
#endif

            if(this->lpDirect3DI->numDevs == 1 && CanDoTexBlt(DDSSrcSubFace.lpLcl, DDSDstSubFace.lpLcl))
            {
                bool doblt = true;
                LPREGIONLIST lpRegionList = DDSSrcSubFace.lpLcl->lpSurfMore->lpRegionList;
                if(dwFlags == 0xFFFFFFFF) // 0xFFFFFFFF indicates that we
                                          // are loading from sysmem to vidmem
                                          // and the regionlist should be used
                {
                    if(lpRegionList->rdh.nCount == 0)
                    {
                        doblt = false;
                    }
                    else
                    {
                        if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            if(DDSSrcSubFace.lpLcl->lpGbl->dwUsageCount > 0
                                || DDSDstSubFace.lpLcl->lpGbl->dwUsageCount > 0)
                            {
                                D3D_ERR("Surfaces locked");
                                return DDERR_SURFACEBUSY;
                            }
                            for(unsigned i = 0; i < lpRegionList->rdh.nCount; ++i)
                            {
                                POINT p;
                                p.x = lpRegionList->rect[i].left;
                                p.y = lpRegionList->rect[i].top;
                                ddrval = static_cast<CDirect3DDevice7*>(this)->TexBltI(DDSDstSubFace.lpLcl,
                                                                                       DDSSrcSubFace.lpLcl,
                                                                                       &p, &lpRegionList->rect[i], 0);
                                if(ddrval != D3D_OK)
                                {
                                    DPF_ERR("Error inserting TexBlt instruction in batch");
                                    return ddrval;
                                }
                            }
                            BatchTexture(DDSDstSubFace.lpLcl);
                            BatchTexture(DDSSrcSubFace.lpLcl);
                            doblt = false;
                        }
                        lpRegionList->rdh.nCount = 0;
                        lpRegionList->rdh.nRgnSize = 0;
                        lpRegionList->rdh.rcBound.left = LONG_MAX;
                        lpRegionList->rdh.rcBound.right = 0;
                        lpRegionList->rdh.rcBound.top = LONG_MAX;
                        lpRegionList->rdh.rcBound.bottom = 0;
                    }
                }
                if(doblt)
                {
                    if(DDSSrcSubFace.lpLcl->lpGbl->dwUsageCount > 0
                        || DDSDstSubFace.lpLcl->lpGbl->dwUsageCount > 0)
                    {
                        D3D_ERR("Surfaces locked");
                        return DDERR_SURFACEBUSY;
                    }
                    POINT p;
                    if(lpDstRct)
                    {
                        p.x = lpDstRct->left;
                        p.y = lpDstRct->top;
                    }
                    else
                    {
                        p.x = 0;
                        p.y = 0;
                    }
                    RECTL r;
                    if(lpSrcRct)
                    {
                        r = *((LPRECTL)lpSrcRct);
                    }
                    else
                    {
                        r.bottom = DDSSrcSubFace.lpLcl->lpGbl->wHeight;
                        r.left = 0;
                        r.right = DDSSrcSubFace.lpLcl->lpGbl->wWidth;
                        r.top = 0;
                    }
                    ddrval = static_cast<CDirect3DDevice7*>(this)->TexBltI(DDSDstSubFace.lpLcl,
                                                                           DDSSrcSubFace.lpLcl,
                                                                           &p, &r, 0);
                    if(ddrval != D3D_OK)
                    {
                        DPF_ERR("Error inserting TexBlt instruction in batch");
                        return ddrval;
                    }
                    BatchTexture(DDSDstSubFace.lpLcl);
                    BatchTexture(DDSSrcSubFace.lpLcl);
                    if(IsD3DManaged(DDSDstSubFace.lpLcl))
                    {
                        MarkDirty(DDSDstSubFace.lpLcl);
                        LPREGIONLIST lpRegionList = DDSDstSubFace.lpLcl->lpSurfMore->lpRegionList;
                        if(lpDstRct)
                        {
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                lpRegionList->rect[(lpRegionList->rdh.nCount)++] = *((LPRECTL)lpDstRct);
                                lpRegionList->rdh.nRgnSize += sizeof(RECT);
                                if(lpDstRct->left < lpRegionList->rdh.rcBound.left)
                                    lpRegionList->rdh.rcBound.left = lpDstRct->left;
                                if(lpDstRct->right > lpRegionList->rdh.rcBound.right)
                                    lpRegionList->rdh.rcBound.right = lpDstRct->right;
                                if(lpDstRct->top < lpRegionList->rdh.rcBound.top)
                                    lpRegionList->rdh.rcBound.top = lpDstRct->top;
                                if(lpDstRct->bottom > lpRegionList->rdh.rcBound.bottom)
                                    lpRegionList->rdh.rcBound.bottom = lpDstRct->bottom;
                            }
                        }
                        else
                        {
                            /* Mark everything dirty */
                            lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                        }
                    }
                }
            }
            else
            {
                do
                {
                    DDSSrcSubMip.lpLcl = mmsrc();
                    DDSDstSubMip.lpLcl = mmdst();
                    bool doblt = true;
                    LPREGIONLIST lpRegionList = DDSSrcSubMip.lpLcl->lpSurfMore->lpRegionList;
                    if(dwFlags == 0xFFFFFFFF) // 0xFFFFFFFF indicates that we
                                              // are loading from sysmem to vidmem
                                              // and the regionlist should be used.
                    {
                        if(lpRegionList->rdh.nCount == 0)
                        {
                            doblt = false;
                        }
                        else if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            if(lpClipper->SetClipList((LPRGNDATA)lpRegionList, 0) != DD_OK)
                            {
                                D3D_ERR("Failed to set clip list");
                            }
                            if(lpDDSDstSubMip->SetClipper(lpClipper) != DD_OK)
                            {
                                D3D_ERR("Failed to detach the clipper");
                            }
                        }
                    }
                    if(doblt)
                    {
                        ddrval = lpDDSDstSubMip->Blt(lpDstRct, lpDDSSrcSubMip, lpSrcRct, DDBLT_WAIT, NULL);
                    }
                    if(dwFlags == 0xFFFFFFFF)
                    {
                        if(lpRegionList->rdh.nCount)
                        {
                            if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                            {
                                if(lpDDSDstSubMip->SetClipper(NULL) != DD_OK)
                                {
                                    D3D_ERR("Failed to detach the clipper");
                                }
                            }
                            lpRegionList->rdh.nCount = 0;
                            lpRegionList->rdh.nRgnSize = 0;
                            lpRegionList->rdh.rcBound.left = LONG_MAX;
                            lpRegionList->rdh.rcBound.right = 0;
                            lpRegionList->rdh.rcBound.top = LONG_MAX;
                            lpRegionList->rdh.rcBound.bottom = 0;
                        }
                    }

                    if (ddrval == E_NOTIMPL && (psize == 16 || psize == 4 || psize == 2))
                    {
                        DDSURFACEDESC2 ddsd_s, ddsd_d;
                        LPBYTE psrc, pdst;
                        DWORD i;
                        DWORD dwBytesPerLine;

                        memset(&ddsd_s, 0, sizeof ddsd_s);
                        memset(&ddsd_d, 0, sizeof ddsd_d);
                        ddsd_s.dwSize = ddsd_d.dwSize = sizeof(ddsd_s);

                        // ATTENTION: implement subrect locks and copy correctly.

                        if ((ddrval = lpDDSSrcSubMip->Lock(NULL, &ddsd_s, DDLOCK_WAIT, NULL)) != DD_OK)
                        {
                            if((ddrval == DDERR_SURFACELOST) && (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
                            {
                                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                                ddrval = DD_OK;
                            }
                            else
                            {
                                D3D_ERR("Failed to lock src texture");
                            }
                            return ddrval;
                        }
                        if ((ddrval = lpDDSDstSubMip->Lock(NULL, &ddsd_d, DDLOCK_WAIT, NULL)) != DD_OK)
                        {
                            lpDDSSrcSubMip->Unlock(NULL);
                            if((ddrval == DDERR_SURFACELOST) && (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
                            {
                                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                                ddrval = DD_OK;
                            }
                            else
                            {
                                D3D_ERR("Failed to lock dst texture");
                            }
                            return ddrval;
                        }

                        switch (psize)
                        {
                        case 16: dwBytesPerLine = (ddsd_s.dwWidth + 1) / 2; break;
                        case 4: dwBytesPerLine = (ddsd_s.dwWidth + 3) / 4; break;
                        case 2: dwBytesPerLine = (ddsd_s.dwWidth + 7) / 8; break;
                        }

                        psrc = (LPBYTE)ddsd_s.lpSurface;
                        pdst = (LPBYTE)ddsd_d.lpSurface;
                        for (i = 0; i < ddsd_s.dwHeight; i++) {
                            memcpy( pdst, psrc, dwBytesPerLine );
                            psrc += ddsd_s.lPitch;
                            pdst += ddsd_d.lPitch;
                        }

                        lpDDSSrcSubMip->Unlock(NULL);
                        lpDDSDstSubMip->Unlock(NULL);
                    }
                    else if (ddrval != DD_OK)
                    {
                        if((ddrval == DDERR_SURFACELOST) && (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
                        {
                            this->dwFEFlags |= D3DFE_LOSTSURFACES;
                            ddrval = DD_OK;
                        }
                        else
                        {
                            D3D_ERR("Blt failure");
                        }
                        return ddrval;
                    }

                    if(lpSrcRct)
                    {
                        _COMPUTE_NEXT_LOD_RECT(lpSrcRct)
                    }
                    if(lpDstRct)
                    {
                        _COMPUTE_NEXT_LOD_RECT(lpDstRct)
                    }

                    ++mmsrc;
                    ++mmdst;
                }
                while(mmsrc != 0 && mmdst != 0);
            }
        }
        ++cmsrc;
        if(cmsrc == 0)
        {
            break; // out of outer loop
        }
        ++cmdst;
        if(cmdst == 0)
        {
            D3D_ERR("Destination texture has different cubemap faces than source");
            return DDERR_INVALIDPARAMS;
        }
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::VerifyTextureCaps"
HRESULT DIRECT3DDEVICEI::VerifyTextureCaps(LPDIRECT3DTEXTUREI lpTexI)
{
    DWORD texcap;
    WORD width, height;
    LPDDRAWI_DDRAWSURFACE_INT lpDDS;
    if(lpTexI->D3DManaged())
        lpDDS = (LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDSSys);
    else
        lpDDS = (LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS);
    /*
     * Are we palettized?
     */
    LPDDPIXELFORMAT pPF = &PixelFormat(lpDDS->lpLcl);
    if ( (pPF->dwFlags & DDPF_PALETTEINDEXED1) ||
         (pPF->dwFlags & DDPF_PALETTEINDEXED2) ||
         (pPF->dwFlags & DDPF_PALETTEINDEXED4) ||
         (pPF->dwFlags & DDPF_PALETTEINDEXED8) )
    {
        if(lpDDS->lpLcl->lpDDPalette == NULL)
        {
            D3D_ERR("No palette attached to a palettized texture");
            return DDERR_NOPALETTEATTACHED;
        }
    }
    /* first verify the dimensions */
    texcap = this->d3dDevDesc.dpcTriCaps.dwTextureCaps;
    width = lpDDS->lpLcl->lpGbl->wWidth;
    height = lpDDS->lpLcl->lpGbl->wHeight;
    if (texcap & D3DPTEXTURECAPS_POW2)
    {
        if (width & (width - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture width not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture width not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
        if (height & (height - 1)) // Clear the right most set bit
        {
            if (texcap & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
            {
                D3D_INFO( 3, "Texture height not a power of two");
                D3D_INFO( 3, "  with D3DPTEXTURECAPS_NONPOW2CONDITIONAL");
            }
            else
            {
                D3D_ERR("Texture height not a power of two");
                return D3DERR_TEXTURE_BADSIZE;
            }
        }
    }
    if (texcap & D3DPTEXTURECAPS_SQUAREONLY)
    {
        if (width != height)
        {
            D3D_ERR("Texture not square");
            return D3DERR_TEXTURE_BADSIZE;
        }
    }
    return  D3D_OK;
}

#if COLLECTSTATS
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTexStats"
void DIRECT3DDEVICEI::GetTexStats(LPD3DDEVINFO_TEXTURING pStats)
{
    lpDirect3DI->GetTexStats(&m_texstats);
    *pStats = m_texstats;
}
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetInfoInternal"
BOOL DIRECT3DDEVICEI::GetInfoInternal(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize)
{
    switch(dwDevInfoID)
    {
#if COLLECTSTATS
    case D3DDEVINFOID_D3DTEXTUREMANAGER:
        if(dwSize < sizeof(D3DDEVINFO_TEXTUREMANAGER))
        {
            D3D_ERR( "Invalid size" );
            throw DDERR_INVALIDPARAMS;
        }
        lpDirect3DI->lpTextureManager->GetStats((LPD3DDEVINFO_TEXTUREMANAGER)pDevInfoStruct);
        break;
    case D3DDEVINFOID_TEXTURING:
        if(dwSize < sizeof(D3DDEVINFO_TEXTURING))
        {
            D3D_ERR( "Invalid size" );
            throw DDERR_INVALIDPARAMS;
        }
        this->GetTexStats((LPD3DDEVINFO_TEXTURING)pDevInfoStruct);
        break;
#else
    case D3DDEVINFOID_D3DTEXTUREMANAGER:
    case D3DDEVINFOID_TEXTURING:
        D3D_WARN( 0, "Stats not collected in this build" );
        memset(pDevInfoStruct, 0, dwSize);
        throw S_FALSE;
#endif
    default:
        return FALSE;
    }
    return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetInfo"

HRESULT D3DAPI DIRECT3DDEVICEI::GetInfo(DWORD dwDevInfoID, LPVOID pDevInfoStruct, DWORD dwSize)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid DIRECT3DDEVICE7 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (dwSize == 0 || !VALID_D3DDEVINFOSTRUCT_PTR(pDevInfoStruct, dwSize))
    {
        D3D_ERR( "Invalid structure pointer or size" );
        return DDERR_INVALIDOBJECT;
    }
    memset(pDevInfoStruct, 0, dwSize);
#if DBG
    if (this->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE)
    {
        D3D_WARN( 2, "GetInfo called within a scene" );
    }
#endif
    try
    {
        switch(dwDevInfoID)
        {
#if COLLECTSTATS
        case D3DDEVINFOID_TEXTUREMANAGER:
            lpDirect3DI->lpTextureManager->GetStats((LPD3DDEVINFO_TEXTUREMANAGER)pDevInfoStruct);
            return D3D_OK;
#else
        case D3DDEVINFOID_TEXTUREMANAGER:
            D3D_WARN( 0, "Stats not collected in this build" );
            return S_FALSE;
#endif
        default:
            if(GetInfoInternal(dwDevInfoID, pDevInfoStruct, dwSize))
                return D3D_OK;
        }
        D3D_WARN( 1, "Device information query unsupported" );        
        return E_FAIL;
    }
    catch(HRESULT hr)
    {
        memset(pDevInfoStruct, 0, dwSize);
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dpr.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dpr.h
 *  Content:    Direct3D private include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   23/11/95   colinmc Made various Direct3D interfaces queryable off
 *                      DirectDraw.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef _D3DPR_H_
#define _D3DPR_H_
#include "d3di.hpp"
#include "texman.hpp"
#include "dpf.h"

/*
 * Texture Manipulation Utils
 */
extern void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK);
extern "C" void WINAPI D3DTextureUpdate(IUnknown FAR * pD3DIUnknown);

extern DWORD BitDepthToDDBD(int bpp);
extern BOOL D3DI_isHALValid(LPD3DHAL_CALLBACKS pCallbacks);
extern void FreeDeviceI(LPDIRECT3DDEVICEI pDevI);

#define D3DBUCKETBUFFERSIZE 32  //make buffer byte size 2*D3DBUCKETBUFFERSIZE*4
extern HRESULT D3DMallocBucket(LPDIRECT3DI, LPD3DBUCKET *);
extern void D3DFreeBucket(LPDIRECT3DI, LPD3DBUCKET);
extern LPD3DI_TEXTUREBLOCK D3DI_FindTextureBlock(LPDIRECT3DTEXTUREI,LPDIRECT3DDEVICEI);

inline bool MatchDDPIXELFORMAT( DDPIXELFORMAT* pddpfA, DDPIXELFORMAT* pddpfB )
{
    return ( pddpfA->dwFlags == pddpfB->dwFlags ) &&
           ( pddpfA->dwRGBBitCount == pddpfB->dwRGBBitCount ) &&
           ( pddpfA->dwRBitMask == pddpfB->dwRBitMask ) &&
           ( pddpfA->dwGBitMask == pddpfB->dwGBitMask ) &&
           ( pddpfA->dwBBitMask == pddpfB->dwBBitMask ) &&
           ( pddpfA->dwRGBAlphaBitMask == pddpfB->dwRGBAlphaBitMask ) &&
           ( pddpfA->dwFourCC == pddpfB->dwFourCC );
}

inline DDPIXELFORMAT& PixelFormat(LPDDRAWI_DDRAWSURFACE_LCL lpLcl)
{
    return (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? lpLcl->lpGbl->ddpfSurface : lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay;
}

#if _D3D_FORCEDOUBLE
class CD3DForceFPUDouble
{
private:
    WORD    wFPUCW;
    WORD    wSaved;
public:
    __inline
    CD3DForceFPUDouble(CDirect3DDeviceIHW * lpDevI)
    {
        wSaved=FALSE;
        if (lpDevI->dwDebugFlags & D3DDEBUG_FORCEDOUBLE)
        {
            WORD    wTemp;
            __asm   fstcw   wTemp
            if (!(wTemp & 0x0200))
            {
                wSaved=TRUE;
                wFPUCW=wTemp;
                wTemp=wFPUCW | 0x0200;  //Enforce Double Precision bit
                __asm   fldcw  wTemp
            }
        }
    }
    __inline
    ~CD3DForceFPUDouble()
    {
        if (wSaved)
        {
            WORD    wTemp = wFPUCW;
            __asm   fldcw  wTemp
        }
    }
};
#endif  //_D3D_FORCEDOUBLE

/*
 * Critical section code.
 * Coarse locking.  All actions require this section.
 * Defined in d3dcreat.c
 */
/*
 * On WINNT critical sections can't be used because synchronization must
 * occur cross process.   DDraw and D3D must share this synchronization so
 * DDraw exports private functions for synchronization that NT D3D must use.
 */
#ifdef WIN95
extern LPCRITICAL_SECTION       lpD3DCSect;
#endif

extern "C" {
#define this _this
#include "ddrawpr.h"
#undef this
};
#if DBG
    extern int iD3DCSCnt;
    #define INCD3DCSCNT() iD3DCSCnt++;
    #define INITD3DCSCNT() iD3DCSCnt = 0;
    #define DECD3DCSCNT() iD3DCSCnt--;
#else
    #define INCD3DCSCNT()
    #define INITD3DCSCNT()
    #define DECD3DCSCNT()
#endif

#ifdef WIN95
#define ENTER_D3D() \
    EnterCriticalSection( lpD3DCSect ); \
    INCD3DCSCNT(); \

#define LEAVE_D3D() \
    DECD3DCSCNT() \
    LeaveCriticalSection( lpD3DCSect );
#else
#define ENTER_D3D() \
        AcquireDDThreadLock(); \
        INCD3DCSCNT(); \

#define LEAVE_D3D() \
        DECD3DCSCNT() \
        ReleaseDDThreadLock();
#endif

// This class is designed to simplify ENTER_D3D() LEAVE_D3D() logic
// If object of this class is instantiated, then internal lock will be taken.
// As soon as object is destroyed lock will be released
//
class CLockD3D
{
public:
    CLockD3D(char *moduleName, char *fileName)
    {
        ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
        D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
    }
    ~CLockD3D()
    {
        LEAVE_D3D();
        D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
    }
};

class CLockD3DST
{
private:
    bool bEnter;
public:
    CLockD3DST(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if (! IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DST()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

class CLockD3DMT
{
private:
    bool bEnter;
public:
    CLockD3DMT(LPDIRECT3DDEVICEI lpDevI, char *moduleName, char *fileName)
    {
        if ( IS_MT_DEVICE(lpDevI) )
        {
            ENTER_D3D();
#if DBG // Required to eliminate use of moduleName and fileName in retail builds
            D3D_INFO( 6, "*** LOCK_D3D: CNT = %ld %s %s", iD3DCSCnt, moduleName, fileName );
#endif
            bEnter = true;
        }
        else
            bEnter = false;
    }
    ~CLockD3DMT()
    {
        if (bEnter)
        {
            LEAVE_D3D();
            D3D_INFO( 6, "*** UNLOCK_D3D: CNT = %ld", iD3DCSCnt);
        }
    }
};

#define ENTER_CBCSECT(device) EnterCriticalSection(&(device)->CommandBufferCSect)
#define LEAVE_CBCSECT(device) LeaveCriticalSection(&(device)->CommandBufferCSect)

// Macro used to access DDRAW GBL from a given LPDIRECT3DI
#define DDGBL(lpD3DI) ((LPDDRAWI_DIRECTDRAW_INT)lpD3DI->lpDD)->lpLcl->lpGbl
// Macro used to access DDRAW SURF LCL from a given surface
#define DDSLCL(lpDDS) (((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl)
// Macro used to access DDRAW SURF GBL from a given surface
#define DDSGBL(lpDDS) (((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpGbl)
/*
 * Macros for validating parameters.
 * Only implement those not available in ddrawpr.h.
 */

#define VALID_OUTPTR(x) ((x) && VALID_PTR_PTR(x))

// FAST_CHECKING macro is defined in ddrawpr.h
// so in make sure that ddrawpr.h is always included
// before this header.

#ifndef FAST_CHECKING

#define VALID_DIRECT3D_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DI )))
#define VALID_DIRECT3DTEXTUREM_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTUREM )))
#define VALID_DIRECT3DTEXTURED3DM_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DTEXTURED3DM )))
#define VALID_DIRECT3DDEVICE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DIRECT3DDEVICEI )))
#define VALID_DDSURF_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( DDRAWI_DDRAWSURFACE_INT )))
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( CDirect3DVertexBuffer )))

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DVERTEXBUFFERDESC ) ) && \
    (ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC )) )
#define VALID_D3DDEVICEDESC7_PTR( ptr ) \
    (! IsBadWritePtr(ptr, sizeof( D3DDEVICEDESC7 )) )
#define VALID_D3DRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DRECT ) ))
#define VALID_GDIRECT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( RECT ) ))
#define VALID_GDIPOINT_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( POINT ) ))
#define VALID_D3DVIEWPORT_PTR( ptr ) (!IsBadWritePtr(ptr, sizeof(D3DVIEWPORT7)))
#define VALID_D3DMATRIX_PTR( ptr ) (!IsBadWritePtr(ptr, sizeof(D3DMATRIX)))
#define VALID_D3DLIGHT_PTR( ptr ) (!IsBadWritePtr(ptr, sizeof(D3DLIGHT7)))
#define VALID_D3DMATERIAL_PTR( ptr ) (!IsBadWritePtr( ptr, sizeof(D3DMATERIAL7)))
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DTEXTUREHANDLE ) ) )
#define VALID_D3DLIGHTDATA_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DLIGHTDATA ) ) && \
    (ptr->dwSize == sizeof( D3DLIGHTDATA )) )
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) \
    (!IsBadWritePtr( ptr, sizeof( D3DFINDDEVICESEARCH ) ) && \
    (ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ) ) )
#define VALID_D3DFINDDEVICERESULT7_PTR( ptr ) \
        ( (! IsBadWritePtr( ptr, 4)) &&                  \
          (ptr->dwSize == sizeof(D3DFINDDEVICERESULT7)) && \
          (! IsBadWritePtr( ptr, ptr->dwSize) ) )
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) \
    (!IsBadWritePtr( ptr, size ) )

// Note: these macros are replacements for the VALID_DIRECTDRAWSURFACE_PTR ddraw macros
// because those macros need access to the ddCallbacks ddraw globals.
// At some point these could be replaced with a ddraw exported fn that actually
// verifies the callback table type

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))
#define VALID_D3D_DIRECTDRAWSURFACE7_PTR(ptr) (!IsBadWritePtr(ptr, sizeof(DDRAWI_DDRAWSURFACE_INT)))

#else /* !FAST_CHECKING */

#define VALID_DIRECT3D_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTUREM_PTR( ptr ) (ptr)
#define VALID_DIRECT3DTEXTURED3DM_PTR( ptr ) (ptr)
#define VALID_DIRECT3DDEVICE_PTR( ptr ) (ptr)
#define VALID_DDSURF_PTR( ptr ) (ptr)
#define VALID_DIRECT3DVERTEXBUFFER_PTR( ptr ) (ptr)

#define VALID_D3DVERTEXBUFFERDESC_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DVERTEXBUFFERDESC ))
#define VALID_D3DDEVICEDESC7_PTR( ptr ) (ptr)
#define VALID_D3DVIEWPORT_PTR( ptr ) (ptr)
#define VALID_D3DRECT_PTR( ptr ) (ptr)
#define VALID_GDIRECT_PTR( ptr ) (ptr)
#define VALID_GDIPOINT_PTR( ptr ) (ptr)
#define VALID_D3DMATRIX_PTR( ptr ) (ptr)
#define VALID_D3DLIGHT_PTR( ptr ) (ptr)
#define VALID_D3DMATERIAL_PTR( ptr ) (ptr)
#define VALID_D3DTEXTUREHANDLE_PTR( ptr ) (ptr)
#define VALID_D3DLIGHTDATA_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DLIGHTDATA ))
#define VALID_D3DFINDDEVICESEARCH_PTR( ptr ) ((ptr) && ptr->dwSize == sizeof( D3DFINDDEVICESEARCH ))
#define VALID_D3DFINDDEVICERESULT7_PTR( ptr ) \
        ((ptr) && (ptr->dwSize == sizeof( D3DFINDDEVICERESULT7 )) )

#define VALID_D3D_DIRECTDRAWSURFACE_PTR(ptr) (ptr)    // see comment above
#define VALID_D3D_DIRECTDRAWSURFACE7_PTR(ptr) (ptr)
#define VALID_D3DDEVINFOSTRUCT_PTR( ptr, size ) (ptr)

#endif /* !FAST_CHECKING */


#endif /* _D3DPR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dtex.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    texture.c
*  Content: Direct3DTexture interface
*@@BEGIN_MSINTERNAL
*
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95   stevela  Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D
*   17/04/96   colinmc Bug 12185: Debug output too aggresive
*   30/04/96   stevela Bug 18898: Wrong error returned on invalid GetHandle
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
* Create an api for the Direct3DTexture object
*/

#undef  DPF_MODNAME
#define DPF_MODNAME "Direct3DTexture"

void D3DI_RemoveTextureHandle(LPD3DI_TEXTUREBLOCK lpBlock)
{
    /*  check if this block refers to a Texture/Texture2 - this
     *   needs to handle both texture types for device cleanup
     */
    if (lpBlock->hTex)
    {
        D3DHAL_TextureDestroy(lpBlock);
    }
}

DIRECT3DTEXTUREI::DIRECT3DTEXTUREI()
{
    m_dwHeapIndex = 0;
    m_bInUse = FALSE;
    m_dwPriority = 0;
    m_dwLOD = 0;
    bDirty = FALSE;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::Initialize"

HRESULT DIRECT3DTEXTUREI::Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS)
{
    LIST_INITIALIZE(&blocks);
    this->DDS1Tex.lpVtbl = ((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->pddSurfaceCallbacks;
    this->DDS1Tex.lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;
    this->DDS1Tex.lpLink = NULL;
    this->DDS1Tex.dwIntRefCnt = 1;
    this->lpDDS        = pDDS;
    this->lpDDSSys     = NULL;
    this->m_hTex       = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
    this->lpDirect3DI  = lpDirect3DI;
    this->lpDirect3DI->AddRef(); // Since we hold a pointer to D3DI
    // Hook texture into the list
    LIST_INSERT_ROOT(&this->lpDirect3DI->textures, this, m_List);
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::Destroy"

void DIRECT3DTEXTUREI::Destroy()
{
    // lpDDS or lpDDSSys need to remain alive during the while loop
    while (LIST_FIRST(&this->blocks)) 
    {
        LPD3DI_TEXTUREBLOCK tBlock = LIST_FIRST(&this->blocks);
        D3DI_RemoveTextureHandle(tBlock);
        // Remove from device
        LIST_DELETE(tBlock, devList);
        // Remove from texture
        LIST_DELETE(tBlock, list);
        D3DFree(tBlock);
    }
    LIST_DELETE(this, m_List); // Remove ourself from the texture chain
    lpDirect3DI->Release(); // Remove the Addref from Create
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::Initialize"

HRESULT DIRECT3DTEXTURED3DM::Initialize(LPDIRECT3DI lpDirect3DI, LPDIRECTDRAWSURFACE7 pDDS)
{
    HRESULT ddrval = DIRECT3DTEXTUREI::Initialize(lpDirect3DI, pDDS);
    if(ddrval != D3D_OK)
        return ddrval;
    memset(&this->ddsd, 0, sizeof(DDSURFACEDESC2));
    this->ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddrval = pDDS->GetSurfaceDesc(&this->ddsd);
    if(ddrval != DD_OK)
    {
        D3D_ERR("Failed to get surface descriptor for texture");
        return ddrval;
    }
    this->ddsd.dwFlags &= ~DDSD_PITCH;    // DDRAW always give that, but we don't want
    if(this->ddsd.ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        this->ddsd.ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
        this->ddsd.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
    }
    else
    {
        this->ddsd.ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
        this->ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
    }
    this->ddsd.ddsCaps.dwCaps2 &= ~(DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE);
    this->ddsd.ddsCaps.dwCaps2 |= DDSCAPS2_DONOTCREATED3DTEXOBJECT;
    
    if(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData)
    {
        if(!(((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_SEPARATETEXTUREMEMORIES) ||
            !(this->ddsd.dwFlags & DDSD_TEXTURESTAGE) ||
            (((LPDDRAWI_DIRECTDRAW_INT)(lpDirect3DI->lpDD7))->lpLcl->lpGbl->lpD3DExtendedCaps->wMaxSimultaneousTextures < 2))
            this->ddsd.dwTextureStage = 0;
    }
    else
    {
        this->ddsd.dwTextureStage = 0;
    }
    this->lpDDSSys = pDDS;
    this->lpDDS = NULL;
    this->m_hTex = 0;
    this->m_dwBytes = 0;
    this->m_dwVidBytes = 0;
    // Next, we need to loop thru and set pointers to the dirty
    // bit in the DDraw surfaces
    for(CCubemapIter cmit(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSSys)->lpLcl); cmit != 0; ++cmit)
    {
        // Set the faces bit so that when the cubemap is eventually created in vidmem, it will get all faces
        this->ddsd.ddsCaps.dwCaps2 |= (cmit()->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES);
        for(CMipmapIter mmit(cmit()); mmit != 0; ++mmit)
        {
            mmit()->lpSurfMore->lpbDirty = &(this->bDirty);
            if(this->ddsd.dwFlags & DDSD_LINEARSIZE)
                m_dwBytes += mmit()->lpGbl->dwLinearSize;
            else
                m_dwBytes += mmit()->lpGbl->lPitch * mmit()->lpGbl->wHeight;
        }
    }
#if COLLECTSTATS
    this->lpDirect3DI->lpTextureManager->IncTotSz(m_dwBytes);
#endif
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::Destroy"

void DIRECT3DTEXTURED3DM::Destroy()
{
    DIRECT3DTEXTUREI::Destroy();
    if(InVidmem())
    {
        this->lpDirect3DI->lpTextureManager->RemoveFromHeap(this);
        this->lpDirect3DI->lpTextureManager->remove(this);
    }
#if COLLECTSTATS
    this->lpDirect3DI->lpTextureManager->DecTotSz(m_dwBytes);
#endif
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::SetPriority"

HRESULT DIRECT3DTEXTUREI::SetPriority(DWORD dwPriority)
{
    D3D_ERR( "SetPriority called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::GetPriority"

HRESULT DIRECT3DTEXTUREI::GetPriority(LPDWORD lpdwPriority)
{
    D3D_ERR( "GetPriority called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::SetLOD"

HRESULT DIRECT3DTEXTUREI::SetLOD(DWORD dwLOD)
{
    D3D_ERR( "SetLOD called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREI::GetLOD"

HRESULT DIRECT3DTEXTUREI::GetLOD(LPDWORD lpdwLOD)
{
    D3D_ERR( "GetLOD called on unmanaged texture." );
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::SetPriority"

HRESULT DIRECT3DTEXTUREM::SetPriority(DWORD dwPriority)
{
    try
    {
        m_dwPriority = dwPriority;
        // Look for a hardware device
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->lpDirect3DI->devices);
        if(lpDevI == NULL)
        {
            D3D_WARN(0, "SetPriority called before D3D device was created.");
        }
        while (lpDevI)
        {
            if (lpDevI->dwFEFlags & D3DFE_REALHAL)
            {
                if(this->lpDirect3DI->numDevs > 1)
                {
                    D3D_WARN(2, "Multiple devices used. Calling Flush");
                    HRESULT hr = this->lpDirect3DI->FlushDevicesExcept(lpDevI);  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing devices in SetPriority");
                        return hr;
                    }
                }
                DDASSERT(IS_DX7HAL_DEVICE(lpDevI));
                HRESULT hr = static_cast<CDirect3DDevice7*>(lpDevI)->SetPriorityI(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl, m_dwPriority);
                if(hr != D3D_OK)
                {
                    DPF_ERR("Error inserting SetPriority instruction in batch");
                    return hr;
                }
                if(this->lpDirect3DI->numDevs > 1)
                {
                    hr = lpDevI->FlushStates();  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing device in SetPriority");
                    }
                }
                else
                {
                    // This will ensure that the SetPriority gets to the driver before
                    // Blting or Locking the (texture) surface. Not sure that this is
                    // necessary.
                    lpDevI->BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl);
                }
                return hr;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::GetPriority"

HRESULT DIRECT3DTEXTUREM::GetPriority(LPDWORD lpdwPriority)
{
    *lpdwPriority = m_dwPriority;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::SetPriority"

HRESULT DIRECT3DTEXTURED3DM::SetPriority(DWORD dwPriority)
{
    m_dwPriority = dwPriority;
    lpDirect3DI->lpTextureManager->UpdatePriority(this);
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::GetLOD"

HRESULT DIRECT3DTEXTUREM::GetLOD(LPDWORD lpdwLOD)
{
    *lpdwLOD = m_dwLOD;
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTUREM::SetLOD"

HRESULT DIRECT3DTEXTUREM::SetLOD(DWORD dwLOD)
{
    try
    {
        if(dwLOD >= ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl->lpSurfMore->dwMipMapCount)
        {
            D3D_ERR( "Texture has insufficient mipmap levels for this LOD" );
            return DDERR_INVALIDPARAMS;
        }
        m_dwLOD = dwLOD;
        // Look for a hardware device
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->lpDirect3DI->devices);
        if(lpDevI == NULL)
        {
            D3D_WARN(0, "SetLOD called before D3D device was created.");
        }
        while (lpDevI)
        {
            if (lpDevI->dwFEFlags & D3DFE_REALHAL)
            {
                if(this->lpDirect3DI->numDevs > 1)
                {
                    D3D_WARN(2, "Multiple devices used. Calling Flush");
                    HRESULT hr = this->lpDirect3DI->FlushDevicesExcept(lpDevI);  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing devices in SetLOD");
                        return hr;
                    }
                }
                DDASSERT(IS_DX7HAL_DEVICE(lpDevI));
                HRESULT hr = static_cast<CDirect3DDevice7*>(lpDevI)->SetTexLODI(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl, m_dwLOD);
                if(hr != D3D_OK)
                {
                    DPF_ERR("Error inserting SetTexLODI instruction in batch");
                    return hr;
                }
                if(this->lpDirect3DI->numDevs > 1)
                {
                    hr = lpDevI->FlushStates();  // to avoid sync problems
                    if(hr != D3D_OK)
                    {
                        DPF_ERR("Error flushing device in SetLODI");
                    }
                }
                else
                {
                    // This will ensure that the SetTexLODI gets to the driver before
                    // Blting or Locking the (texture) surface. Not sure that this is
                    // necessary.
                    lpDevI->BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDS))->lpLcl);
                }
                return hr;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::SetLOD"

HRESULT DIRECT3DTEXTURED3DM::SetLOD(DWORD dwLOD)
{
    if(dwLOD >= ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpSurfMore->dwMipMapCount)
    {
        D3D_ERR( "Texture has insufficient mipmap levels for this LOD" );
        return DDERR_INVALIDPARAMS;
    }
    if(m_dwLOD != dwLOD)
    {
        m_dwLOD = dwLOD;
        this->ddsd.dwWidth = ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpGbl->wWidth >> m_dwLOD;
        if(this->ddsd.dwWidth == 0)
            this->ddsd.dwWidth = 1;
        this->ddsd.dwHeight = ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpGbl->wHeight >> m_dwLOD;
        if(this->ddsd.dwHeight == 0)
            this->ddsd.dwHeight = 1;
        this->ddsd.dwMipMapCount = ((LPDDRAWI_DDRAWSURFACE_INT)(this->lpDDSSys))->lpLcl->lpSurfMore->dwMipMapCount - m_dwLOD;
        if(InVidmem())
        {
            this->lpDirect3DI->lpTextureManager->RemoveFromHeap(this);
            this->lpDirect3DI->lpTextureManager->remove(this);
        }
        D3DTextureUpdate(static_cast<LPUNKNOWN>(&(this->lpDirect3DI->mD3DUnk)));
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DTEXTURED3DM::MarkDirtyPointers"

void DIRECT3DTEXTURED3DM::MarkDirtyPointers()
{
    // We need to loop thru and set pointers to the dirty
    // bit in the DDraw surfaces. The dirty bit will be
    // used to properly update vidmem copies after they
    // have been lost and restored.
    CCubemapIter cmsysmem(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSSys)->lpLcl);
    CCubemapIter cmvidmem(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDS)->lpLcl);
    m_dwVidBytes = 0;
    do
    {
        CMipmapIter mmsysmem(cmsysmem()), mmvidmem(cmvidmem());
        do
        {
            mmvidmem()->lpSurfMore->lpbDirty = &(this->bDirty);
            mmvidmem()->lpSurfMore->lpRegionList = mmsysmem()->lpSurfMore->lpRegionList;
            // Mark everything dirty since we are going to copy into this surface
            // from sysmem
            mmvidmem()->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
            if(this->ddsd.dwFlags & DDSD_LINEARSIZE)
                m_dwVidBytes += mmvidmem()->lpGbl->dwLinearSize;
            else
                m_dwVidBytes += mmvidmem()->lpGbl->lPitch * mmvidmem()->lpGbl->wHeight;
            ++mmvidmem;
            ++mmsysmem;
        }
        while(mmsysmem != 0 && mmvidmem != 0);
        ++cmvidmem;
        ++cmsysmem;
    }
    while(cmsysmem != 0);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateTexture"

extern "C" HRESULT WINAPI CreateTexture(LPDIRECTDRAWSURFACE7 pDDS)
{
    LPDIRECT3DTEXTUREI pTex;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pDDS)->lpLcl;

    // Should this texture be managed by D3D?
    if(((DDSCAPS2_TEXTUREMANAGE & pLcl->lpSurfMore->ddsCapsEx.dwCaps2) && !(DDCAPS2_CANMANAGETEXTURE & pLcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2))
        || (DDSCAPS2_D3DTEXTUREMANAGE & pLcl->lpSurfMore->ddsCapsEx.dwCaps2))
    {
        pTex =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTURED3DM);
    }
    // Should this texture be managed by the driver?
    else if((DDSCAPS2_TEXTUREMANAGE & pLcl->lpSurfMore->ddsCapsEx.dwCaps2) && (DDCAPS2_CANMANAGETEXTURE & pLcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2))
    {
        pTex =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTUREM);
    }
    // This texture is unmanaged
    else
    {
        pTex =  static_cast<LPDIRECT3DTEXTUREI>(new DIRECT3DTEXTUREI);
    }

    if (!pTex) 
    {
        D3D_ERR("failed to allocate space for texture object");
        return (DDERR_OUTOFMEMORY);
    }

    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pLcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    HRESULT ddrval = pTex->Initialize(lpD3D, pDDS);
    if(ddrval != D3D_OK)
    {
        D3D_ERR("Failed to initialize texture.");
        delete pTex;
        return ddrval;
    }

    pLcl->lpSurfMore->lpTex = reinterpret_cast<LPVOID>(pTex);

#if COLLECTSTATS
    pTex->lpDirect3DI->IncNumTexCreates();
#endif

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DestroyTexture"

extern "C" void WINAPI DestroyTexture(LPVOID pTex)
{    
    D3D_INFO(3, "Destroying D3D texture");    
    LPDIRECT3DTEXTUREI lpTexI = reinterpret_cast<LPDIRECT3DTEXTUREI>(pTex);
#if COLLECTSTATS
    lpTexI->lpDirect3DI->IncNumTexDestroys();
#endif
    lpTexI->Destroy();
    delete lpTexI; 
} 

#undef DPF_MODNAME
#define DPF_MODNAME "SetPriority"

extern "C" HRESULT WINAPI SetPriority(LPVOID lpTexI, DWORD dwPriority)
{
#if COLLECTSTATS
    reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->lpDirect3DI->IncNumSetPris();
#endif
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->SetPriority(dwPriority);
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetPriority"

extern "C" HRESULT WINAPI GetPriority(LPVOID lpTexI, LPDWORD lpdwPriority)
{
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->GetPriority(lpdwPriority);
}

#undef DPF_MODNAME
#define DPF_MODNAME "SetLOD"

extern "C" HRESULT WINAPI SetLOD(LPVOID lpTexI, DWORD dwLOD)
{
#if COLLECTSTATS
    reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->lpDirect3DI->IncNumSetLODs();
#endif
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->SetLOD(dwLOD);
}

#undef DPF_MODNAME
#define DPF_MODNAME "GetLOD"

extern "C" HRESULT WINAPI GetLOD(LPVOID lpTexI, LPDWORD lpdwLOD)
{
    return reinterpret_cast<LPDIRECT3DTEXTUREI>(lpTexI)->GetLOD(lpdwLOD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dmem.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dmem.c
 *  Content:    Direct3D mem allocation
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10/12/95   stevela Initial rev with this header.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

static D3DMALLOCFUNCTION malloc_function = (D3DMALLOCFUNCTION) MemAlloc;
static D3DREALLOCFUNCTION realloc_function = (D3DREALLOCFUNCTION) MemReAlloc;
static D3DFREEFUNCTION free_function = MemFree;

#undef DPF_MODNAME
#define DPF_MODNAME "D3DMalloc"

HRESULT D3DAPI D3DMalloc(LPVOID* p_return, size_t size)
{
    void* p;

    if (!VALID_OUTPTR(p_return)) {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) {
        p = malloc_function(size);
        if (p == NULL)
            return (DDERR_OUTOFMEMORY);
    } else {
        p = NULL;
    }
    *p_return = p;

    return (D3D_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DRealloc"

HRESULT D3DAPI D3DRealloc(LPVOID* p_inout, size_t size)
{
    void* p = *p_inout;
    HRESULT err = D3D_OK;

    if (!VALID_OUTPTR(p_inout)) {
        D3D_ERR("Bad pointer given");
        return DDERR_OUTOFMEMORY;
    }
    if (size > 0) {
        if (p) {
            p = realloc_function(p, size);
            if (p == NULL)
                return (DDERR_OUTOFMEMORY);
        } else
            return D3DMalloc(p_inout, size);
    } else if (size == 0) {
        D3DFree(p);
        p = NULL;
    } else
        return (DDERR_INVALIDPARAMS);
    *p_inout = p;
    return (err);
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DFree"

VOID D3DAPI D3DFree(LPVOID p)
{
    if (p == NULL) return;

    if (!VALID_DWORD_PTR(p)) {
        D3D_ERR("invalid pointer");
        return;
    }
    if (p) {
        free_function(p);
    }
}

#define CACHE_LINE 32
HRESULT MallocAligned(void** p_return, size_t size)
{
    char* p;
    size_t offset;
    HRESULT error;

    if (!p_return)
        return DDERR_INVALIDPARAMS;

    if (size > 0) {
        if ((error = D3DMalloc((void**) &p, size + CACHE_LINE)) != DD_OK)
        {
            *p_return = NULL;
            return error;
        }
        offset = (size_t)(CACHE_LINE - ((ULONG_PTR)p & (CACHE_LINE - 1)));
        p += offset;
        ((size_t*)p)[-1] = offset;
    } else
        p = NULL;
    *p_return = p;
    return DD_OK;
}

void FreeAligned(void* p)
{
    if (p) {
        size_t offset = ((size_t*)p)[-1];
        p = (void*) ((unsigned char*)p - offset);
        D3DFree(p);
    }
}

HRESULT ReallocAligned(void** p_inout, size_t size)
{
    char* p = (char*)*p_inout;
    HRESULT error;

    if (!p_inout)
        return DDERR_INVALIDPARAMS;

    if (size > 0) {
        if (p) {
            size_t old_offset = ((size_t*)p)[-1];
            size_t new_offset;

            p -= old_offset;
            if ((error = D3DRealloc((void**) &p, size + CACHE_LINE)) != DD_OK)
                return error;

            new_offset = (size_t)(CACHE_LINE - ((ULONG_PTR)p & (CACHE_LINE - 1)));
            if (old_offset != new_offset)
                memmove(p + new_offset, p + old_offset, size);
            p += new_offset;
            ((size_t*)p)[-1] = new_offset;
        } else
            return MallocAligned(p_inout, size);
    } else if (size == 0) {
        FreeAligned(p);
        p = NULL;
    } else
        return DDERR_INVALIDPARAMS;
    *p_inout = p;
    return DD_OK;
}

//----------------------------------------------------------------------------
// Growing aligned buffer implementation.
//
HRESULT CAlignedBuffer32::Grow(DWORD growSize)
{
    if (allocatedBuf)
        D3DFree(allocatedBuf);
    size = growSize;
    if (D3DMalloc(&allocatedBuf, size + 31) != DD_OK)
    {
        allocatedBuf = 0;
        alignedBuf = 0;
        size = 0;
        return DDERR_OUTOFMEMORY;
    }
    alignedBuf = (LPVOID)(((ULONG_PTR)allocatedBuf + 31 ) & ~31);
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CBufferDDS::Grow"
//----------------------------------------------------------------------
// Growing buffer using DDS implementation.
//
HRESULT CBufferDDS::Grow(LPDIRECT3DDEVICEI lpDevI, DWORD growSize)
{
    DWORD dwRefCnt = 1;
    if (growSize <= size)
        return D3D_OK;
    if (allocatedBuf)
    {
        // Save reference count before deleting
        dwRefCnt = allocatedBuf->AddRef() - 1;
        // Release till gone!
        while (allocatedBuf->Release());
        allocatedBuf = NULL;
    }
    size = growSize;
    DDSURFACEDESC2 ddsd;
    memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
    ddsd.dwWidth = size + 31;
    ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER | DDSCAPS_SYSTEMMEMORY;
    LPDIRECTDRAWSURFACE7 lpDDS7;
    HRESULT ret = lpDevI->lpDirect3DI->lpDD7->CreateSurface(&ddsd, &lpDDS7, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Failed to allocate Vertex Buffer");
        size = 0;
        return ret;
    }
    ret = lpDDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&allocatedBuf);
    if (ret != DD_OK)
    {
        D3D_ERR("failed to QI for DDS1");
        lpDDS7->Release();
        size = 0;
        return ret;
    }
    ret = lpDDS7->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
    if (ret != DD_OK)
    {
        D3D_ERR("Could not lock system memory Vertex Buffer.");
        lpDDS7->Release();
        allocatedBuf->Release();
        allocatedBuf = NULL;
        size = 0;
        return ret;
    }
    lpDDS7->Release();
    alignedBuf = ddsd.lpSurface;
    // Restore reference count
    while (--dwRefCnt)
        allocatedBuf->AddRef();
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3diunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    d3diunk.c
*  Content: Direct3D IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   27/08/96   stevela Ifdefed out the Close of gHEvent.  We're using
*                      DirectDraw's critical section.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * If we are built with aggregation enabled then we actually need two
 * different Direct3D QueryInterface, AddRef and Releases. One which
 * does the right thing on the Direct3D object and one which simply
 * punts to the owning interface.
 */

/*
 * CDirect3DUnk::QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::QueryInterface"

HRESULT D3DAPI CDirect3DUnk::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    if( !VALID_OUTPTR( ppvObj ) )
    {
        D3D_ERR( "Invalid obj ptr" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    D3D_INFO(3, "Direct3D IUnknown QueryInterface");
    
    if(IsEqualIID(riid, IID_IUnknown))
    {
        /*
         * Asking for IUnknown and we are IUnknown so just bump the
         * reference count and return this interface.
         * NOTE: Must AddRef through the interface being returned.
         */
        pD3DI->AddRef();
        // explicit ::CDirect3D disambiguation required since there are multiple IUnknown DIRECT3DI inherits from
        *ppvObj = static_cast<LPVOID>(static_cast<LPUNKNOWN>(static_cast<DIRECT3DI*>(pD3DI)));
    }
    else if (IsEqualIID(riid, IID_IDirect3D7))
    {
        pD3DI->AddRef();
        // No disambiguation required. Only one IDirect3D3 base for DIRECT3DI
        *ppvObj = static_cast<LPVOID>(static_cast<LPDIRECT3D7>(pD3DI));
    }
    else
    {
        /*
         * Don't understand this interface. Fail.
         * NOTE: Used to return DDERR_GENERIC. Now return
         * E_NOINTERFACE.
         */
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* CDirect3DUnk::QueryInterface */

/*
 * CDirect3DUnk::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::AddRef"

ULONG D3DAPI CDirect3DUnk::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    refCnt++;
    D3D_INFO(3, "Direct3D IUnknown AddRef: Reference count = %d", refCnt);
    return (refCnt);
    
} /* CDirect3DUnk::AddRef */

/*
 * CDirect3DUnk::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DUnk::Release"

ULONG D3DAPI CDirect3DUnk::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    refCnt--;
    D3D_INFO(3, "Direct3D IUnknown Release: Reference count = %d", refCnt);
    
    if( refCnt == 0 )
    {
        delete pD3DI; // Delete Parent object
        return 0;
    }
    return refCnt;
    
} /* D3DIUnknown_Release */

DIRECT3DI::~DIRECT3DI()
{
    D3D_INFO(3, "Release Direct3D Object");

#if COLLECTSTATS
    if(m_hFont)
    {
        DeleteObject(m_hFont);
    }
#endif

    delete lpTextureManager;
    /*
     * free up all allocated Buckets
     */
#if DBG
    /* this->lpFreeList must have all the buckets that are allocated */
    if (this->lpFreeList || this->lpBufferList)
    {
        int i,j;
        LPD3DBUCKET   temp;
        for (i=0,temp=this->lpFreeList;temp;i++) temp=temp->next;
        for (j=0,temp=this->lpBufferList;temp;j++) temp=temp->next;
        D3D_INFO(4,"D3D Release: recovered %d buckets in lpFreeList in %d buffers",i,j);
        DDASSERT(j*(D3DBUCKETBUFFERSIZE-1)==i);
    }
#endif  //DBG
    while (this->lpBufferList)
    {
        LPD3DBUCKET   temp=this->lpBufferList;
        this->lpBufferList=temp->next;
        D3DFree(temp->lpBuffer);
        D3D_INFO(4,"D3D Release:lpBufferList %d bytes freed",D3DBUCKETBUFFERSIZE*sizeof(D3DBUCKET));
    }
    this->lpFreeList=NULL;
}
    
/*
  * DIRECT3DI::QueryInterface
  */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::QueryInterface"
  
HRESULT D3DAPI DIRECT3DI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT ret;
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 

    if( !VALID_OUTPTR( ppvObj ) )
    {
        D3D_ERR( "Invalid obj ptr" );
        return DDERR_INVALIDPARAMS;
    }
    
    *ppvObj = NULL;

    ret = this->lpOwningIUnknown->QueryInterface(riid, ppvObj);
    return ret;
}

/*
 * DIRECT3DI::AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::AddRef"

ULONG D3DAPI DIRECT3DI::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor

    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->AddRef();
}

/*
 * DIRECT3DI::Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DI::Release"

ULONG D3DAPI DIRECT3DI::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    /*
     * Punt to the owning interface.
     */
    return  this->lpOwningIUnknown->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\d3dcreat.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D HAL include file
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   09/11/95   stevela Initial rev with this header.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *                      Validate args.
 *   17/04/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   29/04/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *   27/08/96   stevela Ifdefed out definition of ghEvent as we're using
 *                      DirectDraw's critical section.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Create an api for the Direct3D object
 */

// Remove DDraw's type unsafe definition and replace with our C++ friendly def
#ifdef VALIDEX_CODE_PTR
#undef VALIDEX_CODE_PTR
#endif
#define VALIDEX_CODE_PTR( ptr ) \
(!IsBadCodePtr( (FARPROC) ptr ) )

LPCRITICAL_SECTION      lpD3DCSect;

#if DBG
    int     iD3DCSCnt;
#endif

#if COLLECTSTATS
void DIRECT3DI::ResetTexStats()
{
    ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexLocks = ((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->dwNumTexGetDCs = 0;
    m_setpris = m_setLODs = m_texCreates = m_texDestroys = 0;
}

void DIRECT3DI::GetTexStats(LPD3DDEVINFO_TEXTURING pStats)
{
    pStats->dwNumSetPriorities = GetNumSetPris();
    pStats->dwNumSetLODs = GetNumSetLODs();
    pStats->dwNumCreates = GetNumTexCreates();
    pStats->dwNumDestroys = GetNumTexDestroys();
    pStats->dwNumLocks = GetNumTexLocks();
    pStats->dwNumGetDCs = GetNumTexGetDCs();
}
#endif

//---------------------------------------------------------------------
// for use by fns that take a GUID param before device is created
BOOL IsValidD3DDeviceGuid(REFCLSID riid) {

    if (IsBadReadPtr(&riid, sizeof(CLSID))) {
        return FALSE;
    }
    if( IsEqualIID(riid, IID_IDirect3DRampDevice) ||
        IsEqualIID(riid, IID_IDirect3DRGBDevice)  ||
        IsEqualIID(riid, IID_IDirect3DMMXDevice)  ||
        IsEqualIID(riid, IID_IDirect3DHALDevice)  ||
        IsEqualIID(riid, IID_IDirect3DRefDevice)  ||
        IsEqualIID(riid, IID_IDirect3DNullDevice) ||
        IsEqualIID(riid, IID_IDirect3DTnLHalDevice)) {
       return TRUE;
    } else {
        return FALSE;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DCreate"

DIRECT3DI::DIRECT3DI()
{
    lpDD           = NULL;
    lpDD7          = NULL;
    numDevs        = 0;
    mD3DUnk.pD3DI  = this;
    mD3DUnk.refCnt = 1;

    LIST_INITIALIZE(&devices);
    LIST_INITIALIZE(&textures);

    lpFreeList       = NULL;    /* nothing is allocated initially */
    lpBufferList     = NULL;
    lpTextureManager = NULL;

#ifdef __DISABLE_VIDMEM_VBS__
    bDisableVidMemVBs = FALSE;
#endif
}

HRESULT DIRECT3DI::Initialize(IUnknown* pUnkOuter, LPDDRAWI_DIRECTDRAW_INT pDDrawInt)
{
    // HACK.  D3D needs a DD1 DDRAWI interface because it uses CreateSurface1 internally
    // for exebufs, among other things.  Because pDDrawInt could be any DDRAWI type,
    // we need to QI to find a DD1 interface.  But the D3DI object cannot keep a reference
    // to its parent DD object because it is aggegrated with the DD obj, so that would constitute
    // a circular reference that would prevent deletion. So we QI for DD1 interface, copy it into D3DI
    // and release it, then point lpDD at the copy. (disgusting)

    // another HACK alert: dont know which DDRAWI type pDDrawInt is, but a cast to LPDIRECTDRAW should
    // work because QI is in the same place in all the DDRAWI vtables and is the same fn for all
    HRESULT ret;
    ret = ((LPDIRECTDRAW)pDDrawInt)->QueryInterface(IID_IDirectDraw, (LPVOID*)&lpDD);
    if(FAILED(ret))
    {
        D3D_ERR( "QueryInterface for IDDraw failed" );
        return ret;
    }
    memcpy(&DDInt_DD1,lpDD,sizeof(DDInt_DD1));
    lpDD->Release();
    lpDD=(LPDIRECTDRAW)&DDInt_DD1;

    // We know that the pointer that is handed in is a DD7 interface, hence just typecast and assign
    lpDD7 = reinterpret_cast<LPDIRECTDRAW7>(pDDrawInt);

    lpTextureManager = new TextureCacheManager(this);
    if(lpTextureManager == 0)
    {
        D3D_ERR("Out of memory allocating texture manager");
        return E_OUTOFMEMORY;
    }
    ret = lpTextureManager->Initialize();
    if(ret != D3D_OK)
    {
        D3D_ERR("Failed to initialize texture manager");
        return ret;
    }

#if COLLECTSTATS
    DWORD value = 0;
    GetD3DRegValue(REG_DWORD, "DisplayStats", &value, sizeof(DWORD));
    if(value != 0)
    {
        LOGFONT font;
        strcpy(font.lfFaceName, STATS_FONT_FACE);
        font.lfCharSet        = DEFAULT_CHARSET;
        font.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
        font.lfEscapement     = 0;
        font.lfHeight         = STATS_FONT_SIZE;
        font.lfItalic         = FALSE;
        font.lfOrientation    = 0;
        font.lfOutPrecision   = OUT_DEFAULT_PRECIS;
        font.lfPitchAndFamily = DEFAULT_PITCH;
        font.lfQuality        = DEFAULT_QUALITY;
        font.lfStrikeOut      = FALSE;
        font.lfUnderline      = FALSE;
        font.lfWeight         = FW_DONTCARE;
        font.lfWidth          = 0;
        m_hFont = CreateFontIndirect(&font);
    }
    else
    {
        m_hFont = 0;
    }
#endif

#ifdef __DISABLE_VIDMEM_VBS__
    {
        bDisableVidMemVBs = FALSE;
        DWORD value = 0;
        GetD3DRegValue(REG_DWORD, "DisableVidMemVBs", &value, sizeof(DWORD));
        if(value != 0)
        {
            // Disable VidMemVBs 
            bDisableVidMemVBs = TRUE;
        }

        // We also disable vidmem VBs unless the driver explicitly asks us to turn them on...
        if (((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->lpGbl->lpD3DGlobalDriverData)
        {
            if (0 == (((LPDDRAWI_DIRECTDRAW_INT)lpDD7)->lpLcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_HWVERTEXBUFFER) )
            {
                bDisableVidMemVBs = TRUE;
            }
        }
    }
#endif //__DISABLE_VIDMEM_VBS__

    /*
     * Are we really being aggregated?
     */
    if (pUnkOuter != NULL)
    {
        /*
         * Yup - we are being aggregated. Store the supplied
         * IUnknown so we can punt to that.
         * NOTE: We explicitly DO NOT AddRef here.
         */
        this->lpOwningIUnknown = pUnkOuter;
        /*
         * Store away the interface pointer
         */
    }
    else
    {
        /*
         * Nope - but we pretend we are anyway by storing our
         * own IUnknown as the parent IUnknown. This makes the
         * code much neater.
         */
        this->lpOwningIUnknown = static_cast<LPUNKNOWN>(&this->mD3DUnk);
    }
    return D3D_OK;
}


extern "C" HRESULT WINAPI Direct3DCreate(LPCRITICAL_SECTION lpDDCSect,
                                         LPUNKNOWN*         lplpDirect3D,
                                         IUnknown*          pUnkOuter)
{
    LPDIRECT3DI pd3d;

    try
    {
        DPFINIT();

        /*
         * No need to validate params as DirectDraw is giving them to us.
         */

        /*
         * Is another thread coming in and is this the first time?
         */

        /*
         * We can let every invocation of this function assign
         * the critical section as we know its always going to
         * be the same value (for a D3D session).
         */
        lpD3DCSect = lpDDCSect;
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                        // Release in the destructor

        *lplpDirect3D = NULL;

        // We do not support non aggregated Direct3D object yet
        if (!pUnkOuter)
            return DDERR_INVALIDPARAMS;

        if (!(pd3d = static_cast<LPDIRECT3DI>(new DIRECT3DI)))
        {
            D3D_ERR("Out of memory allocating DIRECT3DI");
            return E_OUTOFMEMORY;
        }

        HRESULT hr = pd3d->Initialize(pUnkOuter, (LPDDRAWI_DIRECTDRAW_INT)pUnkOuter);
        if(hr != D3D_OK)
        {
            D3D_ERR("Failed to initialize Direct3D.");
            delete pd3d;
            return hr;
        }

        /*
         * NOTE: The special IUnknown is returned and not the actual
         * Direct3D interface so you can't use this to drive Direct3D.
         * You must query off this interface for the Direct3D interface.
         */
        *lplpDirect3D = static_cast<LPUNKNOWN>(&(pd3d->mD3DUnk));

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::EnumDevices"

extern BOOL isMMXprocessor(void);

typedef struct _D3DI_DeviceType {
    CONST GUID *pGuid;
    char name[256];
    char description[512];
} D3DI_DeviceType;

// Static definitions for various enumerable devices
static D3DI_DeviceType RGBDevice =
{
    &IID_IDirect3DRGBDevice, "RGB Emulation",
    "Microsoft Direct3D RGB Software Emulation"
};
static D3DI_DeviceType HALDevice =
{
    &IID_IDirect3DHALDevice, "Direct3D HAL",
    "Microsoft Direct3D Hardware acceleration through Direct3D HAL"
};
static D3DI_DeviceType RefDevice =
{
    &IID_IDirect3DRefDevice, "Reference Rasterizer",
    "Microsoft Reference Rasterizer"
};
static D3DI_DeviceType NullDevice =
{
    &IID_IDirect3DNullDevice, "Null device",
    "Microsoft Null Device"
};
static D3DI_DeviceType TnLHALDevice =
{
    &IID_IDirect3DTnLHalDevice, "Direct3D T&L HAL",
    "Microsoft Direct3D Hardware Transform and Lighting acceleration capable device"
};

static D3DI_DeviceType *AllDevices[] =
{
    &RGBDevice, &HALDevice, &RefDevice, &NullDevice,
    &TnLHALDevice, NULL
};

HRESULT
DIRECT3DI::EnumDevices(LPD3DENUMDEVICESCALLBACK7 lpEnumCallback,
                       LPVOID lpContext, DWORD dwSize, DWORD dwVer)
{
    HRESULT err, userRet;
    HKEY hKey;
    LONG result;
    int i;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                        // Release in the destructor

        if (!VALIDEX_CODE_PTR((FARPROC)lpEnumCallback))
        {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        BOOL bSoftwareOnly = FALSE;
        BOOL bEnumReference = FALSE;
        BOOL bEnumNullDevice = FALSE;
        BOOL bEnumSeparateMMX = FALSE;

        result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RESPATH, 0, KEY_READ, &hKey);
        if (result == ERROR_SUCCESS)
        {
            DWORD dwData, dwType;
            DWORD dwDataSize;

            // Enumerate software rasterizers only ?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "SoftwareOnly", NULL,
                                     &dwType, (BYTE *) &dwData, &dwDataSize);
            if ( result == ERROR_SUCCESS && dwType == REG_DWORD )
            {
                bSoftwareOnly = ( dwData != 0 );
            }

            // Enumerate Reference Rasterizer ?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "EnumReference", NULL,
                                     &dwType, (BYTE *)&dwData, &dwDataSize);
            if (result == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                dwDataSize == sizeof(dwData))
            {
                bEnumReference = (BOOL)dwData;
            }

            // Enumerate Null Device ?
            dwDataSize = sizeof(dwData);
            result = RegQueryValueEx(hKey, "EnumNullDevice", NULL,
                                     &dwType, (BYTE *)&dwData, &dwDataSize);
            if (result == ERROR_SUCCESS &&
                dwType == REG_DWORD &&
                dwDataSize == sizeof(dwData))
            {
                bEnumNullDevice = (BOOL)dwData;
            }


            RegCloseKey( hKey );
        }

        D3DI_DeviceType **lpDevices = AllDevices;

        userRet = D3DENUMRET_OK;
        for (i = 0; lpDevices[i] && userRet == D3DENUMRET_OK; i++)
        {
            LPSTR drvName = lpDevices[i]->name;
            LPSTR drvDesc = lpDevices[i]->description;
            REFCLSID riid = *lpDevices[i]->pGuid;
            D3DDEVICEDESC7 HWDesc;
            D3DDEVICEDESC7 HELDesc;
            LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;
            IHalProvider *pHalProv;
            HINSTANCE hDll;

            if ( !bEnumReference &&
                 IsEqualIID(riid, IID_IDirect3DRefDevice))
            {
                // Not enumerating the reference.
                continue;
            }

            if (!bEnumNullDevice &&
                IsEqualIID(riid, IID_IDirect3DNullDevice))
            {
                // Not enumerating the Null device.
                continue;
            }

            // By COM definition, our owning IUnknown is a pointer to the
            // DirectDraw object that was used to create us.
            // Check this for the existence of a Direct3D HAL.
            lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;


            if (IsEqualIID(riid, IID_IDirect3DTnLHalDevice) && (lpDDGbl->lpD3DGlobalDriverData))
            {
                if (!(lpDDGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
                  D3DDEVCAPS_HWTRANSFORMANDLIGHT))
            {
                // Not enumerating the T&L device if the hardware doesnt support
                // T&L
                continue;
                }
            }

            // See if this is a software driver.
            err = GetSwHalProvider(riid, &pHalProv, &hDll);
            if (err == S_OK)
            {
                // Successfully got a software driver.
            }
            else if (err == E_NOINTERFACE &&
                     ! bSoftwareOnly &&
                     GetHwHalProvider(riid, &pHalProv, &hDll, lpDDGbl) == S_OK)
            {
                // Successfully got a hardware driver.
            }
            else
            {
                // Unrecognized driver.
                continue;
            }

            err = pHalProv->GetCaps(lpDDGbl, &HWDesc, &HELDesc, dwVer);

            pHalProv->Release();
            if (hDll != NULL)
            {
                FreeLibrary(hDll);
            }

            if (err != S_OK)
            {
                continue;
            }

            if( HWDesc.wMaxVertexBlendMatrices == 1 )
                HWDesc.wMaxVertexBlendMatrices = 0;
    
            if( HELDesc.wMaxVertexBlendMatrices == 1 )
                HELDesc.wMaxVertexBlendMatrices = 0;
    
            // If Hal device is being enumerated, strip out the
            // HWTRANSFORM... flag
            if (IsEqualIID(riid, IID_IDirect3DHALDevice))
            {
                HWDesc.dwMaxActiveLights = 0xffffffff;
                HWDesc.wMaxVertexBlendMatrices = 4;
                HWDesc.wMaxUserClipPlanes = __MAXUSERCLIPPLANES;
                HWDesc.dwVertexProcessingCaps = D3DVTXPCAPS_ALL;
                HWDesc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT);
            }

            if (IsEqualIID(riid, IID_IDirect3DRGBDevice))
            {
                HELDesc.dwMaxActiveLights = 0xffffffff;
                HELDesc.wMaxVertexBlendMatrices = 4;
                HELDesc.wMaxUserClipPlanes = __MAXUSERCLIPPLANES;
                HELDesc.dwVertexProcessingCaps = D3DVTXPCAPS_ALL;
            }

            if (IsEqualIID(riid, IID_IDirect3DHALDevice) || IsEqualIID(riid, IID_IDirect3DTnLHalDevice))
            {
                memcpy(&HWDesc.deviceGUID, lpDevices[i]->pGuid, sizeof(GUID));
                userRet = (*lpEnumCallback)(drvDesc, drvName,
                                        &HWDesc, lpContext);
            }
            else
            {
                memcpy(&HELDesc.deviceGUID, lpDevices[i]->pGuid, sizeof(GUID));
                userRet = (*lpEnumCallback)(drvDesc, drvName,
                                        &HELDesc, lpContext);
            }
        }

        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

HRESULT D3DAPI DIRECT3DI::EnumDevices(LPD3DENUMDEVICESCALLBACK7 lpEnumCallback,
                                      LPVOID lpContext)
{
    return EnumDevices(lpEnumCallback, lpContext, D3DDEVICEDESC7SIZE, 4);
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DI::EnumZBufferFormats"

HRESULT D3DAPI DIRECT3DI::EnumZBufferFormats(REFCLSID riid,
                                             LPD3DENUMPIXELFORMATSCALLBACK lpEnumCallback,
                                             LPVOID lpContext)
{
    HRESULT ret, userRet;
    LPDDPIXELFORMAT lpTmpPixFmts;
    DWORD i,cPixFmts;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.

        ret = D3D_OK;

        if (!VALID_DIRECT3D_PTR(this))
        {
            D3D_ERR( "Invalid Direct3D3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALIDEX_CODE_PTR(lpEnumCallback))
        {
            D3D_ERR( "Invalid callback pointer" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsValidD3DDeviceGuid(riid))
        {
            D3D_ERR( "Invalid D3D Device GUID" );
            return DDERR_INVALIDPARAMS;
        }

        if( IsEqualIID(riid, IID_IDirect3DHALDevice) || 
            IsEqualIID(riid, IID_IDirect3DTnLHalDevice) ) 
        {
            LPDDRAWI_DIRECTDRAW_GBL pDdGbl=((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl;
            LPD3DHAL_GLOBALDRIVERDATA lpD3DHALGlobalDriverData=pDdGbl->lpD3DGlobalDriverData;
            DWORD dwHW_ZBitDepthFlags;
            if (NULL == lpD3DHALGlobalDriverData)
            {
                D3D_ERR("No HAL Support ZBufferBitDepths!");
                return (DDERR_NOZBUFFERHW);
            }
            cPixFmts=pDdGbl->dwNumZPixelFormats;
            if (cPixFmts==0) {
                // driver is pre-dx6, so it doesn't support stencil buffer pix fmts or this callback.
                // we can fake support using DD_BD bits in dwZBufferBitDepth in D3DDEVICEDESC
                D3D_WARN(6,"EnumZBufferFormats not supported directly by driver, faking it using dwDeviceZBufferBitDepth DD_BD bits");

                dwHW_ZBitDepthFlags=lpD3DHALGlobalDriverData->hwCaps.dwDeviceZBufferBitDepth;

                if(!(dwHW_ZBitDepthFlags & (DDBD_8|DDBD_16|DDBD_24|DDBD_32))) {
                        D3D_ERR("No Supported ZBufferBitDepths!");
                        return (DDERR_NOZBUFFERHW);
                }

                // malloc space for 4 DDPIXELFORMATs, since that the most there could be (DDBD_8,16,24,32)
                if (D3DMalloc((void**)&lpTmpPixFmts, 4*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                        D3D_ERR("failed to alloc space for return descriptions");
                        return (DDERR_OUTOFMEMORY);
                }

                DWORD zdepthflags[4]= {DDBD_8,DDBD_16,DDBD_24,DDBD_32};
                DWORD zbitdepths[4]= {8,16,24,32};
                DWORD zbitmasks[4]= {0xff,0xffff,0xffffff,0xffffffff};

                memset(lpTmpPixFmts,0,sizeof(4*sizeof(DDPIXELFORMAT)));

                // create some DDPIXELFORMATs the app can look at
                for(i=0;i<4;i++) {
                    if(dwHW_ZBitDepthFlags & zdepthflags[i]) {
                        lpTmpPixFmts[cPixFmts].dwSize=sizeof(DDPIXELFORMAT);
                        lpTmpPixFmts[cPixFmts].dwFlags=DDPF_ZBUFFER;
                        lpTmpPixFmts[cPixFmts].dwZBufferBitDepth=zbitdepths[i];
                        lpTmpPixFmts[cPixFmts].dwZBitMask= zbitmasks[i];
                        cPixFmts++;
                    }
                }
            } else {
                // only show the app a temp copy of DDraw's real records

                if (D3DMalloc((void**)&lpTmpPixFmts, cPixFmts*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                    D3D_ERR("Out of memory allocating space for return descriptions");
                    return (DDERR_OUTOFMEMORY);
                }
                memcpy(lpTmpPixFmts, pDdGbl->lpZPixelFormats, cPixFmts*sizeof(DDPIXELFORMAT));
            }
        } else {
            // Handle SW rasterizers
            DDPIXELFORMAT  *pDDPF;

            // malloc space for 10 DDPIXELFORMAT's, which is currently more than enough for the SW rasterizers
            if (D3DMalloc((void**)&lpTmpPixFmts, 10*sizeof(DDPIXELFORMAT)) != D3D_OK) {
                    D3D_ERR("Out of memory allocating space for return descriptions");
                    return (DDERR_OUTOFMEMORY);
            }

            cPixFmts=GetSwZBufferFormats(riid,&pDDPF);
            memcpy(lpTmpPixFmts, pDDPF, cPixFmts*sizeof(DDPIXELFORMAT));
        }

        userRet = D3DENUMRET_OK;
        for (i = 0; (i < cPixFmts) && (userRet == D3DENUMRET_OK); i++) {
            userRet = (*lpEnumCallback)(&lpTmpPixFmts[i], lpContext);
        }

        D3DFree(lpTmpPixFmts);

        return (D3D_OK);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::EvictManagedTextures"
HRESULT D3DAPI
DIRECT3DI::EvictManagedTextures()
{
    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
        if (!VALID_DIRECT3D_PTR(this))
        {
            D3D_ERR( "Invalid Direct3D3 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
        while (lpDevI)
        {
            if (lpDevI->dwFEFlags & D3DFE_REALHAL)
            {
                if (DDCAPS2_CANMANAGETEXTURE &
                    ((LPDDRAWI_DIRECTDRAW_INT)this->lpDD)->lpLcl->lpGbl->ddCaps.dwCaps2)
                {
                    lpDevI->SetRenderStateI((D3DRENDERSTATETYPE)D3DRENDERSTATE_EVICTMANAGEDTEXTURES,1);
                    lpDevI->FlushStates();
                }
                lpTextureManager->EvictTextures();
                break;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return  D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3D::FlushDevicesExcept"

HRESULT DIRECT3DI::FlushDevicesExcept(LPDIRECT3DDEVICEI pDev)
{
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&this->devices);
    while (lpDevI)
    {
        if(lpDevI != pDev)
        {
            HRESULT hr = lpDevI->FlushStates();
            if(hr != D3D_OK)
            {
                DPF_ERR("Error flushing device in FlushDevicesExcept");
                return hr;
            }
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FlushD3DDevices"

extern "C" HRESULT WINAPI FlushD3DDevices(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    try
    {
        ULONGLONG qwBatch = (surf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) 
                                && (surf_lcl->lpAttachListFrom != NULL) ?
                                    surf_lcl->lpAttachListFrom->lpAttached->lpSurfMore->qwBatch.QuadPart : 
                                    surf_lcl->lpSurfMore->qwBatch.QuadPart;
        LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(surf_lcl->lpSurfMore->lpDD_lcl->pD3DIUnknown)->pD3DI;
        DDASSERT(lpD3D);
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
        while (lpDevI)
        {
            if(lpDevI->m_qwBatch <= qwBatch)
            {
                HRESULT hr = lpDevI->FlushStates();
                if(hr != D3D_OK)
                {
                    DPF_ERR("Error flushing device in FlushD3DDevices");
                    return hr;
                }
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
        return DD_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

extern "C" void WINAPI PaletteUpdateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwStartIndex,
    DWORD dwNumberOfIndices,
    LPPALETTEENTRY pFirstIndex)
{
    try
    {
        LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
        DDASSERT(lpD3D);
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
        while (lpDevI)
        {
            D3D_INFO(4,"PaletteUpdateNotify lpDevI(%x) %08lx %08lx %08lx %08lx",
                lpDevI,dwPaletteHandle,dwStartIndex,dwNumberOfIndices,*(DWORD*)&pFirstIndex[10]);
            if (IS_DX7HAL_DEVICE(lpDevI) &&
                (lpDevI->dwFEFlags & D3DFE_REALHAL)
               )
            {
                if(lpD3D->numDevs > 1)
                    lpD3D->FlushDevicesExcept(lpDevI);
                static_cast<CDirect3DDevice7*>(lpDevI)->UpdatePalette(dwPaletteHandle,dwStartIndex,dwNumberOfIndices,pFirstIndex);
                if(lpD3D->numDevs > 1)
                    lpDevI->FlushStates();
                break;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
    }
    catch (HRESULT ret)
    {
        D3D_ERR("PaletteUpdateNotify: FlushStates failed");
    }
}

extern "C" void WINAPI PaletteAssociateNotify(
    LPVOID pD3DIUnknown,
    DWORD dwPaletteHandle,
    DWORD dwPaletteFlags,
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl )
{
    try
    {
        LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
        DDASSERT(lpD3D);
        LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
        while (lpDevI)
        {
            D3D_INFO(4,"PaletteAssociateNotify lpDevI(%x) %08lx %08lx",
                lpDevI,dwPaletteHandle,surf_lcl->lpSurfMore->dwSurfaceHandle);
            if (IS_DX7HAL_DEVICE(lpDevI) &&
                (lpDevI->dwFEFlags & D3DFE_REALHAL)
               )
            {
                if(lpD3D->numDevs > 1)
                    lpD3D->FlushDevicesExcept(lpDevI);
                static_cast<CDirect3DDevice7*>(lpDevI)->SetPalette(dwPaletteHandle,dwPaletteFlags,surf_lcl->lpSurfMore->dwSurfaceHandle);
                lpDevI->BatchTexture(surf_lcl);
                if(lpD3D->numDevs > 1)
                    lpDevI->FlushStates();
                break;
            }
            lpDevI = LIST_NEXT(lpDevI,list);
        }
    }
    catch (HRESULT ret)
    {
        D3D_ERR("PaletteAssociateNotify: FlushStates failed");
    }
}

extern "C" void WINAPI SurfaceFlipNotify(LPVOID pD3DIUnknown)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    D3D_INFO(4,"SurfaceFlipNotify");
    while (lpDevI)
    {
        if (IS_DX7HAL_DEVICE(lpDevI))
        {
            try
            {
                CDirect3DDevice7* lpDevI7 = static_cast<CDirect3DDevice7*>(lpDevI);
#ifndef WIN95
                if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface)
                {
                    lpDevI7->SetRenderTargetINoFlush(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                    lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->hDDSurface;
                }
#else
                if(lpDevI->hSurfaceTarget != ((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle)
                {
                    lpDevI7->SetRenderTargetINoFlush(lpDevI->lpDDSTarget,lpDevI->lpDDSZBuffer);
                    lpDevI->hSurfaceTarget=((LPDDRAWI_DDRAWSURFACE_INT)lpDevI->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;
                }
#endif
            }
            catch (HRESULT ret)
            {
                D3D_ERR("SetRenderTarget Failed on SurfaceFlipNotify!");
            }
        }
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DTextureUpdate"

extern "C" void WINAPI D3DTextureUpdate(IUnknown FAR * pD3DIUnknown)
{
    LPDIRECT3DI lpD3D = static_cast<CDirect3DUnk*>(pD3DIUnknown)->pD3DI;
    DDASSERT(lpD3D);
    LPDIRECT3DDEVICEI lpDevI = LIST_FIRST(&lpD3D->devices);
    while (lpDevI)
    {
        lpDevI->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;
        lpDevI = LIST_NEXT(lpDevI,list);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "D3DTextureUpdate"

extern "C" void WINAPI D3DBreakVBLock(LPVOID lpVB)
{
    DDASSERT(lpVB);
    CDirect3DVertexBuffer* lpVBI = static_cast<CDirect3DVertexBuffer*>(lpVB);
    lpVBI->BreakLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\devstate.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       devstate.c
 *  Content:    device state management
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "drawprim.hpp"
#include "pvvid.h"
#include "d3dfei.h"

extern HRESULT checkDeviceSurface(LPDIRECT3DDEVICEI lpD3DDev,
                                  LPDIRECTDRAWSURFACE lpDDS);
extern HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields);
//---------------------------------------------------------------------
inline void UpdateFogFactor(LPDIRECT3DDEVICEI lpDevI)
{
    if (lpDevI->lighting.fog_end == lpDevI->lighting.fog_start)
        lpDevI->lighting.fog_factor = D3DVAL(0.0);
    else
        lpDevI->lighting.fog_factor = D3DVAL(255) /
                                     (lpDevI->lighting.fog_end - lpDevI->lighting.fog_start);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderState(D3DRENDERSTATETYPE dwState, DWORD value)
{
#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    // Takes D3D lock (MT only).
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

    try
    {
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            if(this->CheckForRetiredRenderState(dwState))
            {
                m_pStateSets->InsertRenderState(dwState, value, CanHandleRenderState(dwState));
            }
            else
            {
                D3D_ERR("invalid renderstate %d", dwState);
                return DDERR_INVALIDPARAMS;
            }
        }
        else
            this->SetRenderStateFast(dwState, value);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetRenderStateFast"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderStateFast(D3DRENDERSTATETYPE dwState, DWORD value)
{
#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0 )
    {
        D3D_ERR( "Invalid render state type" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    if (!(rsVec[dwState >> D3D_RSVEC_SHIFT] & (1ul << (dwState & D3D_RSVEC_MASK))))
    { // Fast path. We do not need any processing done in UpdateInternalState other than updating rstates array
        if (this->rstates[dwState] == value)
        {
            D3D_WARN(4,"Ignoring redundant SetRenderState");
            return D3D_OK;
        }
        this->rstates[dwState] = value;
        // Output state to the device driver
        return SetRenderStateI(dwState, value);
    }
    else
    {
        try
        {
            // Wrap modes could be re-programmed. We need to restore them before
            // filtering redundant values
            if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
            if (this->rstates[dwState] == value)
            {
                D3D_WARN(4,"Ignoring redundant SetRenderState");
                return D3D_OK;
            }
            this->UpdateInternalState(dwState, value);
            if (CanHandleRenderState(dwState))
            {
                if(CheckForRetiredRenderState(dwState))
                    return SetRenderStateI(dwState, value);
                D3D_ERR("invalid renderstate %d", dwState);
                return DDERR_INVALIDPARAMS;
            }
        }
        catch(HRESULT ret)
        {
            return ret;
        }
    }
    return D3D_OK;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetRenderStateInternal"

HRESULT
DIRECT3DDEVICEI::SetRenderStateInternal(D3DRENDERSTATETYPE dwState, DWORD dwValue)
{
    if (this->rstates[dwState] == dwValue)
    {
        D3D_WARN(4,"Ignoring redundant SetRenderState");
        return D3D_OK;
    }
    try
    {
        this->UpdateInternalState(dwState, dwValue);
        if (CanHandleRenderState(dwState))
            return SetRenderStateI(dwState, dwValue);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetRenderState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderState(D3DRENDERSTATETYPE dwState, LPDWORD lpdwValue)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).

#if DBG
    if (dwState >= D3D_MAXRENDERSTATES || dwState == 0)
    {
        D3D_ERR( "Invalid render state value" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(lpdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }

    if(!CheckForRetiredRenderState(dwState))
    {
        D3D_ERR("invalid renderstate %d", dwState);
        return DDERR_INVALIDPARAMS;
    }

    // WRAP render states could be re-mapped so we have to return the original
    // value
    if (dwState >= D3DRENDERSTATE_WRAP0 && dwState <= D3DRENDERSTATE_WRAP7)
    {
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            DWORD dwTexCoordIndex = dwState - D3DRENDERSTATE_WRAP0;
            for (DWORD i=0; i < this->dwNumTextureStages; i++)
            {
                LPD3DFE_TEXTURESTAGE pStage = &this->textureStage[i];
                if (pStage->dwInpCoordIndex == dwTexCoordIndex)
                {
                    if (pStage->dwInpCoordIndex != pStage->dwOutCoordIndex)
                    {
                        *lpdwValue = pStage->dwOrgWrapMode;
                        return D3D_OK;
                    }
                }
            }
        }
    }
    *lpdwValue = this->rstates[dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 *lplpTex)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(lplpTex, sizeof(LPVOID)))
    {
        D3D_ERR( "Invalid pointer to LPDIRECTDRAWSURFACE7" );
        return DDERR_INVALIDPARAMS;
    }

    if (this->lpD3DMappedTexI[dwStage])
    {
        if(this->lpD3DMappedTexI[dwStage]->D3DManaged())
            *lplpTex = this->lpD3DMappedTexI[dwStage]->lpDDSSys;
        else
            *lplpTex = this->lpD3DMappedTexI[dwStage]->lpDDS;
        (*lplpTex)->AddRef();
    }
    else
    {
        *lplpTex = NULL;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::VerifyTexture"
HRESULT DIRECT3DDEVICEI::VerifyTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex)
{
    if (dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }

    if (lpTex)
    {
        if (!VALID_DDSURF_PTR(lpTex))
        {
            D3D_ERR( "Invalid surface pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if((((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) &&
            !(this->dwFEFlags & D3DFE_REALHAL))
        {
            D3D_ERR( "Managed textures cannot be used with a software device" );
            return DDERR_INVALIDPARAMS;
        }

        if(!IsToplevel(((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl))
        {
            D3D_ERR( "Cannot set a mipmap sublevel or a cubemap subface" );
            return DDERR_INVALIDPARAMS;
        }

        LPDIRECT3DTEXTUREI lpTexI = reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl->lpSurfMore->lpTex);
        if(lpTexI == NULL)
        {
            D3D_ERR( "Surface must have DDSCAPS_TEXTURE set to use in SetTexture" );
            return DDERR_INVALIDPARAMS;
        }

        if (!lpTexI->D3DManaged())
        {
            if((((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                (!(lpD3DHALGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURESYSTEMMEMORY)))
            {
                D3D_ERR( "Device cannot render using texture surface from system memory" );
                return DDERR_INVALIDPARAMS;
            }
        }

        CLockD3DST lockObject(this, DPF_MODNAME, REMIND("")); // we access DDraw gbl in VerifyTextureCaps
        return VerifyTextureCaps(lpTexI);
    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTexture"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTexture(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
        HRESULT ret = VerifyTexture(dwStage, lpTex);
        if(ret != D3D_OK)
            return ret;
#endif

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTexture(dwStage, lpTex);
            return D3D_OK;
        }

        return SetTextureInternal(dwStage, lpTex);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::SetTextureInternal"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTextureInternal(DWORD dwStage, LPDIRECTDRAWSURFACE7 lpTex)
{

#if DBG
    HRESULT ret = VerifyTexture(dwStage, lpTex);
    if(ret != D3D_OK)
        return ret;
#endif

#if COLLECTSTATS
    this->IncNumTexturesSet();
#endif

    LPDIRECT3DTEXTUREI lpTexI = lpTex ? reinterpret_cast<LPDIRECT3DTEXTUREI>(((LPDDRAWI_DDRAWSURFACE_INT)lpTex)->lpLcl->lpSurfMore->lpTex) : NULL;

    if (lpD3DMappedTexI[dwStage] == lpTexI)
    {
        return  D3D_OK;
    }

    if (lpD3DMappedTexI[dwStage])
    {
        lpD3DMappedTexI[dwStage]->Release();
    }

    lpD3DMappedTexI[dwStage] = lpTexI;

    if (lpTexI)
    {
        lpTexI->AddRef();
#if COLLECTSTATS
        if(lpTexI->D3DManaged())
        {
            this->lpDirect3DI->lpTextureManager->IncNumTexturesSet();
            if(lpTexI->InVidmem())
                this->lpDirect3DI->lpTextureManager->IncNumSetTexInVid();
        }
#endif
    }

    m_dwStageDirty |= (1 << dwStage);

    // Need to call UpdateTextures()
    this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTextureStageState"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      DWORD dwValue)
{
#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG
    try
    {
        // Holds D3D lock until exit.
        CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));

        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            m_pStateSets->InsertTextureStageState(dwStage, dwState, dwValue);
            return D3D_OK;
        }
        return this->SetTextureStageStateFast(dwStage, dwState, dwValue);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTextureStageStateFast"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTextureStageStateFast(DWORD dwStage,
                                          D3DTEXTURESTAGESTATETYPE dwState,
                                          DWORD dwValue)
{
#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif //DBG

    // Fast path. We do not need any processing done in UpdateInternalTSS other than updating tsstates array
    if (NeedInternalTSSUpdate(dwState))
    {
        // Texture stages could be re-programmed. We need to restore them before
        // filtering  redundant values
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            RestoreTextureStages(this);
            ForceFVFRecompute();
        }
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        if(this->UpdateInternalTextureStageState(dwStage, dwState, dwValue))
            return D3D_OK;
    }
    else
    {
        if (this->tsstates[dwStage][dwState] == dwValue)
        {
            D3D_WARN(4,"Ignoring redundant SetTextureStageState");
            return D3D_OK;
        }
        tsstates[dwStage][dwState] = dwValue;
    }

    if (dwStage >= this->dwMaxTextureBlendStages)
        return D3D_OK;

    return SetTSSI(dwStage, dwState, dwValue);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetTextureStageState"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTextureStageState(DWORD dwStage,
                                      D3DTEXTURESTAGESTATETYPE dwState,
                                      LPDWORD pdwValue)
{
    // Takes D3D lock (MT only).
    // Lock released in the destructor.
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

#if DBG
    if (dwStage >= D3DHAL_TSS_MAXSTAGES ||
        dwState == 0 || dwState >= D3DTSS_MAX)
    {
        D3D_ERR( "Invalid texture stage or state index" );
        return DDERR_INVALIDPARAMS;
    }
#endif  //DBG

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(pdwValue, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }

    // If texture indices were re-mapped we have to find and return the original value
    if (dwState == D3DTSS_TEXCOORDINDEX &&  this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
        ForceFVFRecompute();
    }
    // Don't bother to check for DX6 support, just return the
    // cached value.
    *pdwValue = tsstates[dwStage][dwState];
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D::CreateDevice"

extern HRESULT WINAPI Direct3DCreateDevice(REFCLSID            riid,
                                           LPUNKNOWN           lpDirect3D,
                                           LPDIRECTDRAWSURFACE lpDDSTarget,
                                           LPUNKNOWN*          lplpD3DDevice,
                                           IUnknown*           pUnkOuter);

HRESULT D3DAPI DIRECT3DI::CreateDevice(REFCLSID devType,
                                       LPDIRECTDRAWSURFACE7 lpDDS7,
                                       LPDIRECT3DDEVICE7 *lplpDirect3DDevice)
{
    HRESULT ret;
    LPUNKNOWN lpUnkDevice;
    LPDIRECTDRAWSURFACE lpDDS;

    try
    {
        CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                        // Release in the destructor

        if (!VALID_DIRECT3D_PTR(this)) {
            D3D_ERR( "Invalid Direct3D pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_OUTPTR(lplpDirect3DDevice))
        {
            D3D_ERR( "Invalid pointer to Device object pointer" );
            return DDERR_INVALIDPARAMS;
        }
        if (!VALID_D3D_DIRECTDRAWSURFACE7_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS7)))
        {
            D3D_ERR( "Invalid DirectDrawSurface7 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        *lplpDirect3DDevice = NULL;

        // QI lpDDS7 for lpDDS interface
        ret = lpDDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);
        if (FAILED(ret))
            return ret;

        lpDDS->Release();

        ret = Direct3DCreateDevice(devType, &this->mD3DUnk, lpDDS, (LPUNKNOWN *) &lpUnkDevice, NULL);

        if(FAILED(ret) || (lpUnkDevice==NULL))
          return ret;

        // QI device1 for a device7 interface
        ret = lpUnkDevice->QueryInterface(IID_IDirect3DDevice7, (LPVOID*)lplpDirect3DDevice);

        lpUnkDevice->Release();  // release unneeded interface

        return ret;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//----------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTransformI"

void DIRECT3DDEVICEI::SetTransformI(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
    switch (state)
    {
    case D3DTRANSFORMSTATE_WORLD      :
        *(D3DMATRIX*)&this->transform.world[0] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_WORLD1     :
        *(D3DMATRIX*)&this->transform.world[1] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX1_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_WORLD2     :
        *(D3DMATRIX*)&this->transform.world[2] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX2_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_WORLD3     :
        *(D3DMATRIX*)&this->transform.world[3] = *lpMat;
        this->dwFEFlags |= D3DFE_WORLDMATRIX3_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_VIEW       :
        *(D3DMATRIX*)&this->transform.view = *lpMat;
        this->dwFEFlags |= D3DFE_VIEWMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DTRANSFORMSTATE_PROJECTION :
        *(D3DMATRIX*)&this->transform.proj = *lpMat;
        this->dwFEFlags |= D3DFE_PROJMATRIX_DIRTY | D3DFE_FRONTEND_DIRTY;
        if (!(this->dwFEFlags & D3DFE_EXECUTESTATEMODE))
        {
            this->UpdateDrvWInfo();
        }
        break;
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        {
            this->dwDeviceFlags |= D3DDEV_TEXTRANSFORMDIRTY;
            DWORD dwIndex = state - D3DTRANSFORMSTATE_TEXTURE0;
            *(D3DMATRIX*)&this->mTexture[dwIndex] = *lpMat;
            break;
        }
    }
}
//----------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetTransform(D3DTRANSFORMSTATETYPE state, LPD3DMATRIX lpMat)
{
#if DBG
    if (!VALID_PTR(lpMat, sizeof(D3DMATRIX)))
    {
        D3D_ERR( "Invalid matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
    switch (state)
    {
    case D3DTRANSFORMSTATE_WORLD:
    case D3DTRANSFORMSTATE_WORLD1:
    case D3DTRANSFORMSTATE_WORLD2:
    case D3DTRANSFORMSTATE_WORLD3:
    case D3DTRANSFORMSTATE_VIEW :
    case D3DTRANSFORMSTATE_PROJECTION :
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        break;
    default :
        D3D_ERR( "Invalid state value passed to SetTransform" );
        return DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertTransform(state, lpMat);
        else
            this->SetTransformI(state, lpMat);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetTransform"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
    HRESULT ret = D3D_OK;
#if DBG
    if (!lpMat) {
        D3D_ERR( "NULL matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    switch (dtsTransformState) {
    case D3DTRANSFORMSTATE_WORLD :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[0]._11;
        break;
    case D3DTRANSFORMSTATE_WORLD1 :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[1]._11;
        break;
    case D3DTRANSFORMSTATE_WORLD2 :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[2]._11;
        break;
    case D3DTRANSFORMSTATE_WORLD3 :
        *lpMat = *(LPD3DMATRIX)&this->transform.world[3]._11;
        break;
    case D3DTRANSFORMSTATE_VIEW :
        *lpMat = *(LPD3DMATRIX)&this->transform.view._11;
        break;
    case D3DTRANSFORMSTATE_PROJECTION :
        *lpMat = *(LPD3DMATRIX)&this->transform.proj._11;
        break;
    case D3DTRANSFORMSTATE_TEXTURE0:
    case D3DTRANSFORMSTATE_TEXTURE1:
    case D3DTRANSFORMSTATE_TEXTURE2:
    case D3DTRANSFORMSTATE_TEXTURE3:
    case D3DTRANSFORMSTATE_TEXTURE4:
    case D3DTRANSFORMSTATE_TEXTURE5:
    case D3DTRANSFORMSTATE_TEXTURE6:
    case D3DTRANSFORMSTATE_TEXTURE7:
        *lpMat = *(LPD3DMATRIX)&this->mTexture[dtsTransformState-D3DTRANSFORMSTATE_TEXTURE0]._11;
        break;
    default :
        D3D_ERR( "Invalid state value passed to GetTransform" );
        ret = DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        break;
    }

    return ret;
}       // end of D3DDev2_GetTransform()

void InvalidateHandles(LPDIRECT3DDEVICEI lpDevI)
{
    /* free up all textures created by this object */
    LPD3DI_TEXTUREBLOCK tBlock=LIST_FIRST(&lpDevI->texBlocks);
    while (tBlock)
    {
        D3DI_RemoveTextureHandle(tBlock);
        tBlock=LIST_NEXT(tBlock,devList);
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::UpdateDriverStates"

HRESULT
DIRECT3DDEVICEI::UpdateDriverStates()
{
    // note we can't do a loop from 1 to D3DHAL_MAX_RSTATES(256) as some of rstates are not
    // valid states, passin them down to drivers(like voodoo2 DX6 driver) will crash.
    for (DWORD i = D3DRENDERSTATE_ANTIALIAS ; i < D3DRENDERSTATE_WRAPBIAS+8; ++i)
    {
        HRESULT ret = this->SetRenderStateI((D3DRENDERSTATETYPE)i, this->rstates[i]);
        if (ret != D3D_OK)
            return ret;
    }
    return D3D_OK;
}

void DIRECT3DDEVICEI::SetRenderTargetI(LPDIRECTDRAWSURFACE lpDDS, LPDIRECTDRAWSURFACE lpZ)
{
    HRESULT ret;

    // Flush before switching RenderTarget..
    ret = FlushStates();
    if (ret != D3D_OK)
    {
        D3D_ERR("Error trying to FlushStates in SetRenderTarget");
        throw ret;
    }

    if (this->lpD3DHALCallbacks2->SetRenderTarget)
    {
        D3DHAL_SETRENDERTARGETDATA rtData;

        rtData.dwhContext = this->dwhContext;
#ifndef WIN95
        if (dwFEFlags & D3DFE_REALHAL)
        {
            if (lpDDS)
                rtData.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl;
            else
                rtData.lpDDSLcl = NULL;

            if (lpZ)
                rtData.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpZ)->lpLcl;
            else
                rtData.lpDDSZLcl = NULL;

        }
        else
#endif //WIN95
        {
            rtData.lpDDS = lpDDS;
            rtData.lpDDSZ = lpZ;
        }

        rtData.ddrval = 0;
        CALL_HAL2ONLY(ret, this, SetRenderTarget, &rtData);
        if ((ret != DDHAL_DRIVER_HANDLED) || (rtData.ddrval != DD_OK))
        {
            D3D_ERR( "Driver call failed in SetRenderTarget" );
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = rtData.ddrval;
            throw ret;
        }
    }
    else
    {
        D3DHAL_CONTEXTCREATEDATA cdata;
        D3DHAL_CONTEXTDESTROYDATA ddata;

        /* Destroy old context */
        memset(&ddata, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        ddata.dwhContext = this->dwhContext;

        CALL_HALONLY(ret, this, ContextDestroy, &ddata);
        if (ret != DDHAL_DRIVER_HANDLED || ddata.ddrval != DD_OK)
        {
            DPF(0, "(ERROR) ContextDestroy. Failed. dwhContext = %d", ddata.dwhContext);
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            ret = ddata.ddrval;
            throw ret;
        }

        /* Create new context */
        memset(&cdata, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));

        cdata.lpDDGbl = this->lpDDGbl;
        cdata.lpDDS = lpDDS;
        cdata.lpDDSZ = lpZ;

        // Hack Alert!! dwhContext is used to inform the driver which version
        // of the D3D interface is calling it.
        cdata.dwhContext = 3;
        cdata.dwPID  = GetCurrentProcessId();
        // Hack Alert!! ddrval is used to inform the driver which driver type
        // the runtime thinks it is (DriverStyle registry setting)
        cdata.ddrval = this->deviceType;

        CALL_HALONLY(ret, this, ContextCreate, &cdata);
        if (ret != DDHAL_DRIVER_HANDLED || cdata.ddrval != DD_OK)
        {
            D3D_ERR("HAL call to ContextCreate failed in SetRenderTarget");
            // Need sensible return value in this case,
            // currently we return whatever the driver stuck in here.
            throw cdata.ddrval;
        }
        this->dwhContext = (DWORD)cdata.dwhContext;
        D3D_INFO(9, "in halCreateContext. Succeeded. dwhContext = %d", cdata.dwhContext);

        ret = this->UpdateDriverStates();
        if (ret != D3D_OK)
            throw ret;
    }
    InvalidateHandles(this);
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetRenderTarget(LPDIRECTDRAWSURFACE7 lpDDS7, DWORD dwFlags)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    LPDIRECTDRAWSURFACE lpZ=NULL,lpDDS=NULL;
    LPDIRECTDRAWSURFACE7 lpZ_DDS7=NULL;
    LPDIRECTDRAWPALETTE lpPal=NULL;
    try
    {
        DDSCAPS2 ddscaps;
        memset(&ddscaps, 0, sizeof(ddscaps));
        DDSURFACEDESC2 ddsd;
        HRESULT     ret, ddrval;
        DWORD i, j;


        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice7 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        if (!VALID_D3D_DIRECTDRAWSURFACE7_PTR(((LPDDRAWI_DDRAWSURFACE_INT)lpDDS7)))
        {
            D3D_ERR( "Invalid DirectDrawSurface7 pointer" );
            return DDERR_INVALIDOBJECT;
        }

        /*
         * Check if the 3D cap is set on the surface.
         */
        memset(&ddsd, 0, sizeof ddsd);
        ddsd.dwSize = sizeof ddsd;
        ddrval = lpDDS7->GetSurfaceDesc(&ddsd);
        if (ddrval != DD_OK)
        {
            D3D_ERR("Failed to get surface description of device's surface.");
            return (ddrval);
        }

        if (!(ddsd.ddsCaps.dwCaps & DDSCAPS_3DDEVICE))
        {
            D3D_ERR("**** The DDSCAPS_3DDEVICE is not set on this surface.");
            D3D_ERR("**** You need to add DDSCAPS_3DDEVICE to ddsCaps.dwCaps");
            D3D_ERR("**** when creating the surface.");
            return (DDERR_INVALIDCAPS);
        }
        if (!(this->lpD3DHALGlobalDriverData->hwCaps.dwDeviceRenderBitDepth & BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount))) {
            D3D_ERR("Rendering surface's RGB bit count not supported by hardware device");
            return (DDERR_INVALIDCAPS);
        }
        if (ddsd.dwWidth > 2048 || ddsd.dwHeight > 2048)
        {
            D3D_ERR("Surface dimension > 2048");
            return DDERR_INVALIDPARAMS;
        }

        /* The z-buffer... */
        ddscaps.dwCaps = DDSCAPS_ZBUFFER;
        ret = lpDDS7->GetAttachedSurface(&ddscaps, &lpZ_DDS7);
        if ((ret != DD_OK) && (ret != DDERR_NOTFOUND))
        {
            /*
             * NOTE: Not an error if the z-buffer is not found. We will let the
             * dirver handle that (it might fail or create its own z-buffer).
             */
            D3D_ERR("Supplied DirectDraw Z-Buffer is invalid - can't set render target");
            throw DDERR_INVALIDPARAMS;
        }
        if (lpZ_DDS7)
            lpZ_DDS7->Release(); // We do not need to addref this one;

        // QI lpDDS7 for lpDDS interface, which will be used internally by D3D
        ret = lpDDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpDDS);

        if(FAILED(ret))
          throw ret;

        /* The palette... */
        ret = lpDDS->GetPalette(&lpPal);
        if ((ret != DD_OK) && (ret != DDERR_NOPALETTEATTACHED))
        {
            /*
             * NOTE: Again, not an error (yet) if there is no palette attached.
             * But if there is palette and we can't get at it for some reason
             * - fail.
             */
            D3D_ERR("Supplied DirectDraw Palette is invalid - can't create device");
            throw DDERR_INVALIDPARAMS;
        }

        /*
         * We're going to check now whether we should have got a palette.
         */
        if (ret == DDERR_NOPALETTEATTACHED)
        {
            if (ddsd.ddpfPixelFormat.dwRGBBitCount < 16)
            {
                D3D_ERR("No palette supplied for palettized surface");
                throw DDERR_NOPALETTEATTACHED;
            }
        }

        /* Verify Z buffer */

        if (lpZ_DDS7!=NULL)
        {
            memset(&ddsd, 0, sizeof(ddsd));
            ddsd.dwSize = sizeof(ddsd);
            if ((ret=lpZ_DDS7->GetSurfaceDesc(&ddsd)) != DD_OK)
            {
                D3D_ERR("Failed to getsurfacedesc on Z");
                throw ret;
            }

            // QI lpDDS7 for lpDDS interface, which will be used internally by D3D
            ret = lpZ_DDS7->QueryInterface(IID_IDirectDrawSurface, (LPVOID*)&lpZ);

            if(FAILED(ret))
              throw ret;
        }

        SetRenderTargetI(lpDDS, lpZ);
        // this indicates that the device need no longer be flushed when Locking, Blting
        // or GetDC'ing from the previous rendertarget
        if (this->lpDDSTarget)
            ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;
        // this indicates that the device need no longer be flushed when Locking, Blting
        // or GetDC'ing from the previous zbuffer
        if (this->lpDDSZBuffer)
            ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSZBuffer)->lpLcl->lpSurfMore->qwBatch.QuadPart = 0;

        // this indicates that the device should always be flushed when Locking, Blting
        // or GetDC'ing a rendertarget
        ((LPDDRAWI_DDRAWSURFACE_INT)lpDDS7)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;
        // this indicates that the device should always be flushed when Locking, Blting
        // or GetDC'ing a zbuffer
        if(lpZ_DDS7)
            ((LPDDRAWI_DDRAWSURFACE_INT)lpZ_DDS7)->lpLcl->lpSurfMore->qwBatch.QuadPart = _UI64_MAX;

        // release old device DDS/DDS7 interfaces and replace with the new ones,
        // which are mostly already AddRef'd (except for lpDDS7)

        /// DDSZBuffer ///
        if(this->lpDDSZBuffer)
          this->lpDDSZBuffer->Release();

        // lpZ AddRef'd by QI
        this->lpDDSZBuffer = lpZ;

        /// DDSZBuffer DDS7 ///
        this->lpDDSZBuffer_DDS7=lpZ_DDS7; // This needs no AddRef or Release

        ///  DDSTarget  ///
        this->lpDDSTarget = lpDDS;
#ifndef WIN95
        hSurfaceTarget = (unsigned long)((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->hDDSurface;
#else
        hSurfaceTarget = (unsigned long)((LPDDRAWI_DDRAWSURFACE_INT)lpDDS)->lpLcl->lpSurfMore->dwSurfaceHandle;
#endif
        // lpDDS AddRef'd by QI so release it
        this->lpDDSTarget->Release();

        ///  DDSTarget DDS7  ///
        this->lpDDSTarget_DDS7->Release();
        lpDDS7->AddRef();  // ensure lpDDS7 (which was an argument) doesnt disappear

        this->lpDDSTarget_DDS7=lpDDS7;

        if (this->lpDDPalTarget)
          this->lpDDPalTarget->Release();

        // already AddRef'd by GetPalette()
        this->lpDDPalTarget = lpPal;

        ret=CalcDDSurfInfo(this,TRUE);  // this call will never fail due to external error
        DDASSERT(ret==D3D_OK);

        return ret;
    }
    catch (HRESULT ret)
    {
        if(lpPal)
          lpPal->Release();
        if(lpZ)
          lpZ->Release();
        if(lpZ_DDS7)
          lpZ_DDS7->Release();
        if(lpDDS)
          lpDDS->Release();

        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetRenderTarget"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetRenderTarget(LPDIRECTDRAWSURFACE7* lplpDDS)
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock.
                                                    // Release in the destructor
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if ( !VALID_OUTPTR( lplpDDS ) )
    {
        D3D_ERR( "Invalid ptr to DDS ptr" );
        return DDERR_INVALIDPARAMS;
    }

    *lplpDDS = this->lpDDSTarget_DDS7;

    this->lpDDSTarget_DDS7->AddRef();
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetClipStatus"

#define D3DSTATUS_VALID 0x80000000L /* Reserved Status flag to indicate SetClipStatus is called */

HRESULT D3DAPI DIRECT3DDEVICEI::SetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
    {
        D3D_ERR( "Invalid status pointer" );
        return DDERR_INVALIDPARAMS;
    }

#endif
    // D3DCLIPSTATUS_EXTENTS3 not supported in Device7
    if (status->dwFlags & D3DCLIPSTATUS_EXTENTS3)
    {
        D3D_ERR( "D3DCLIPSTATUS_EXTENTS3 not supported for Device7" );
        return DDERR_INVALIDPARAMS;
    }
    if (status->dwFlags & D3DCLIPSTATUS_STATUS)
        this->iClipStatus = status->dwStatus;

    if (status->dwFlags & (D3DCLIPSTATUS_EXTENTS2 | D3DCLIPSTATUS_EXTENTS3))
    {
        this->rExtents.x1 = status->minx;
        this->rExtents.y1 = status->miny;
        this->rExtents.x2 = status->maxx;
        this->rExtents.y2 = status->maxy;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::GetClipStatus"

HRESULT D3DAPI DIRECT3DDEVICEI::GetClipStatus(LPD3DCLIPSTATUS status)
{
    CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
                                                    // Release in the destructor
#if DBG
    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (! VALID_PTR(status, sizeof(D3DCLIPSTATUS)) )
    {
        D3D_ERR( "Invalid status pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    status->dwStatus = iClipStatus;
    status->dwFlags = D3DCLIPSTATUS_EXTENTS2;
    status->minx = this->rExtents.x1;
    status->miny = this->rExtents.y1;
    status->maxx = this->rExtents.x2;
    status->maxy = this->rExtents.y2;
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::UpdateTextures"

HRESULT DIRECT3DDEVICEI::UpdateTextures()
{
    HRESULT result = D3D_OK;
    DWORD dwSavedFlags = this->dwFlags;
    this->dwFlags |= D3DPV_WITHINPRIMITIVE;
    for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        D3DTEXTUREHANDLE dwDDIHandle;
        LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
        if(lpTexI)
        {
            if (lpTexI->bDirty)
            {
                if (lpTexI->InVidmem())
                {
                    CLockD3DST lockObject(this, DPF_MODNAME, REMIND("")); // we access DDraw gbl in CopySurface
                    // 0xFFFFFFFF is equivalent to ALL_FACES, but in addition indicates to CopySurface
                    // that this is a sysmem -> vidmem transfer.
                    result = CopySurface(lpTexI->lpDDS,NULL,lpTexI->lpDDSSys,NULL,0xFFFFFFFF);
                    if (DD_OK != result)
                    {
                        D3D_ERR("Error copying surface while updating textures");
                        goto l_exit;
                    }
                    else
                    {
                        lpTexI->bDirty=FALSE;
                        D3D_INFO(4,"UpdateTextures: Dirty texture updated");
                    }
                }
            }
            LPD3DI_TEXTUREBLOCK lpBlock;
            if (m_dwStageDirty & (1 << dwStage))
            {
                lpBlock = NULL; // indicates to GetTextureDDIHandle to find the block for this (tex,dev)
            }
            else
            {
                lpBlock = this->lpD3DMappedBlock[dwStage]; // use the cached block
                DDASSERT(lpBlock);
                if (lpBlock->hTex) // have we created a handle for this (tex,dev)?
                {
                    continue;   //nothing need to be done further
                }
            }

            result = GetTextureDDIHandle(lpTexI, &lpBlock);
            if (result != D3D_OK)
            {
                D3D_ERR("Failed to get texture handle");
                goto l_exit;
            }
            else
            {
                dwDDIHandle = lpBlock->hTex;
                this->lpD3DMappedBlock[dwStage] = lpBlock;
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)lpTexI->lpDDS)->lpLcl);
                m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
            }
        }
        else if (m_dwStageDirty & (1 << dwStage))
        {
            this->lpD3DMappedBlock[dwStage]=NULL; //a SetTexture(Stage,NULL) issued
            dwDDIHandle = 0;    //tell driver to disable this texture
            m_dwStageDirty &= ~(1 << dwStage); // reset stage dirty
        }
        else
        {
            continue;   //both zero, no action needed
        }
#ifdef WIN95
        if (IS_DP2HAL_DEVICE(this))
        {
#endif
            CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(this);
            result = dp2dev->SetTSSI(dwStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, dwDDIHandle);
            if(result != D3D_OK)
            {
                D3D_ERR("Failed to batch set texture instruction");
                goto l_exit;
            }
            // Update runtime copy of state.
            dp2dev->tsstates[dwStage][D3DTSS_TEXTUREMAP] = dwDDIHandle;
#ifdef WIN95
        }
        else
        {
            if(this->dwFEFlags & D3DFE_DISABLE_TEXTURES)
                break;
            CDirect3DDeviceIHW *dev = static_cast<CDirect3DDeviceIHW *>(this);
            result = dev->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, dwDDIHandle);
            if(result != D3D_OK)
            {
                D3D_ERR("Failed to batch setrenderstate instruction");
                goto l_exit;
            }
            // Update runtime copy of state.
            dev->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = dwDDIHandle;
        }
#endif
    }
l_exit:
    this->dwFlags = dwSavedFlags;
    return result;
}

//---------------------------------------------------------------------
// This function is called from HALEXE.CPP, from device::SetRenderState and
// from device::SetTexture.
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::UpdateInternalState"

void DIRECT3DDEVICEI::UpdateInternalState(D3DRENDERSTATETYPE type, DWORD value)
{
    switch (type)
    {
    case D3DRENDERSTATE_LIGHTING:
        if (value)
            this->dwDeviceFlags |= D3DDEV_LIGHTING;
        else
            this->dwDeviceFlags &= ~D3DDEV_LIGHTING;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_FOGENABLE:
        rstates[type] = value;      // set rstates BEFORE calling SetFogFlags
        SetFogFlags();
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        if (value)
            this->dwDeviceFlags |= D3DDEV_SPECULARENABLE;
        else
            this->dwDeviceFlags &= ~D3DDEV_SPECULARENABLE;
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            const D3DVALUE SCALE = 1.0f/255.0f;
            this->lighting.ambientSceneScaled.r = D3DVAL(RGBA_GETRED(value));
            this->lighting.ambientSceneScaled.g = D3DVAL(RGBA_GETGREEN(value));
            this->lighting.ambientSceneScaled.b = D3DVAL(RGBA_GETBLUE(value));
            this->lighting.ambientScene.r = this->lighting.ambientSceneScaled.r * SCALE;
            this->lighting.ambientScene.g = this->lighting.ambientSceneScaled.g * SCALE;
            this->lighting.ambientScene.b = this->lighting.ambientSceneScaled.b * SCALE;
            this->lighting.ambient_save  = value;
            this->dwFEFlags |= D3DFE_MATERIAL_DIRTY | D3DFE_FRONTEND_DIRTY;
            break;
        }
    case D3DRENDERSTATE_RANGEFOGENABLE:
        if (value)
            this->dwDeviceFlags |= D3DDEV_RANGEBASEDFOG;
        else
            this->dwDeviceFlags &= ~D3DDEV_RANGEBASEDFOG;
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        this->lighting.fog_mode = (D3DFOGMODE)value;
        SetFogFlags();
        break;
    case D3DRENDERSTATE_COLORVERTEX:
        if (value)
            this->dwDeviceFlags |= D3DDEV_COLORVERTEX;
        else
            this->dwDeviceFlags &= ~D3DDEV_COLORVERTEX;
        // Just to make it not take the FE fast path and call DoUpdateState()
        // This is necessary since we update lighting.alpha and
        // lighting.alphaSpecular in DoUpdateState.
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_CLIPPING:
        if (!value)
        {
            this->dwDeviceFlags |= D3DDEV_DONOTCLIP;
            // Clear clip union and intersection flags
            this->dwClipIntersection = 0;
            this->dwClipUnion = 0;
        }
        else
            this->dwDeviceFlags &= ~D3DDEV_DONOTCLIP;
        // This does not really require a "FVF" recompute,
        // but is a convenient way of switching back from
        // the fast path for DrawPrimitiveTL.
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_EXTENTS:
        if (!value)
            this->dwDeviceFlags |= D3DDEV_DONOTUPDATEEXTENTS;
        else
            this->dwDeviceFlags &= ~D3DDEV_DONOTUPDATEEXTENTS;
        // This does not really require a "FVF" recompute,
        // but is a convenient way of switching back from
        // the fast path for DrawPrimitiveTL.
        ForceFVFRecompute();
        break;
    case D3DRENDERSTATE_FOGDENSITY:
        this->lighting.fog_density = *(D3DVALUE*)&value;
        break;
    case D3DRENDERSTATE_FOGSTART:
        this->lighting.fog_start = *(D3DVALUE*)&value;
        UpdateFogFactor(this);
        break;
    case D3DRENDERSTATE_FOGEND:
        this->lighting.fog_end = *(D3DVALUE*)&value;
        UpdateFogFactor(this);
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        if (value)
            this->dwDeviceFlags |= D3DDEV_LOCALVIEWER;
        else
            this->dwDeviceFlags &= ~D3DDEV_LOCALVIEWER;
        this->dwFEFlags |= D3DFE_LIGHTS_DIRTY | D3DFE_FRONTEND_DIRTY;
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        if (value)
        {
            if (this->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING)
            {
                this->dwDeviceFlags &= ~D3DDEV_MODELSPACELIGHTING;
                this->dwFEFlags |= D3DFE_NEED_TRANSFORM_LIGHTS | D3DFE_FRONTEND_DIRTY;
            }
            this->dwDeviceFlags |= D3DDEV_NORMALIZENORMALS;
        }
        else
        {
            this->dwDeviceFlags &= ~D3DDEV_NORMALIZENORMALS;
            if (!(this->dwDeviceFlags & D3DDEV_MODELSPACELIGHTING))
                this->dwFEFlags |= D3DFE_NEEDCHECKWORLDVIEWVMATRIX | D3DFE_FRONTEND_DIRTY;
        }
        break;
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
        this->lighting.dwEmissiveSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwEmissiveSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwEmissiveSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
        this->lighting.dwDiffuseSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwDiffuseSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwDiffuseSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for DIFFUSEMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
        this->lighting.dwAmbientSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwAmbientSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwAmbientSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for AMBIENTMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
        this->lighting.dwSpecularSrcIndex = 2;
        switch (value)
        {
        case D3DMCS_COLOR1:
            this->lighting.dwSpecularSrcIndex = 0;
            break;
        case D3DMCS_COLOR2:
            this->lighting.dwSpecularSrcIndex = 1;
            break;
#if DBG
        case D3DMCS_MATERIAL:
            break;
        default:
            D3D_ERR("Illegal value for SPECULARMATERIALSOURCE");
            goto error_exit;
#endif
        }
        break;
    case D3DRENDERSTATE_VERTEXBLEND:
    {
        DWORD numBlendMatrices;

        switch (value)
        {
        case D3DVBLEND_DISABLE:
            numBlendMatrices = 0;
            break;
        case D3DVBLEND_1WEIGHT:
            numBlendMatrices = 2;
            break;
        case D3DVBLEND_2WEIGHTS:
            numBlendMatrices = 3;
            break;
        case D3DVBLEND_3WEIGHTS:
            numBlendMatrices = 4;
            break;
#if DBG
        default:
            D3D_ERR("Illegal value for D3DRENDERSTATE_VERTEXBLEND");
            goto error_exit;
#endif
        }
        this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY | D3DFE_FRONTEND_DIRTY;
    }
    break;
    case D3DRENDERSTATE_CLIPPLANEENABLE:
        {
            this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
            this->dwMaxUserClipPlanes = 0;
            break;
        }
    case D3DRENDERSTATE_SHADEMODE:
        rstates[type] = value;  // SetInterpolationFlags depends on the rstates
        SetInterpolationFlags(this);
        break;

    default:
        // WRAP render states could be re-mapped so we have to restore them before
        // setting a new value
        if (type >= D3DRENDERSTATE_WRAP0 &&  type <= D3DRENDERSTATE_WRAP7)
        {
            if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
            {
                RestoreTextureStages(this);
                ForceFVFRecompute();
            }
        }
        break;
    }
    rstates[type] = value;      // set rstates for all other cases
    return;

#if DBG
error_exit:
    throw DDERR_INVALIDPARAMS;
#endif
}
//---------------------------------------------------------------------
#if DBG
static  char ProfileStr[PROF_DRAWINDEXEDPRIMITIVEVB+1][32]=
{
    "Execute",
    "Begin",
    "BeginIndexed",
    "DrawPrimitive(Device2)",
    "DrawIndexedPrimitive(Device2)",
    "DrawPrimitiveStrided",
    "DrawIndexedPrimitiveStrided",
    "DrawPrimitive(Device7)",
    "DrawIndexedPrimitive(Device7)",
    "DrawPrimitiveVB",
    "DrawIndexedPrimitiveVB",
};
static  char PrimitiveStr[D3DPT_TRIANGLEFAN][16]=
{
    "POINTLIST",
    "LINELIST",
    "LINESTRIP",
    "TRIANGLELIST",
    "TRIANGLESTRIP",
    "TRIANGLEFAN",
};
static  char VertexStr[D3DVT_TLVERTEX][16]=
{
    "D3DVERTEX",
    "D3DLVERTEX",
    "D3DTLVERTEX",
};
#define PROFILE_LEVEL 0

void    DIRECT3DDEVICEI::Profile(DWORD caller, D3DPRIMITIVETYPE dwPrimitive, DWORD dwVertex)
{
    DWORD   bitwisecaller= 1 << caller;
    DWORD   bitwisePrimitive = 1 << (DWORD)dwPrimitive;
    DWORD   bitwiseVertex1 = 1 << (dwVertex & 0x001F);
    DWORD   bitwiseVertex2 = 1 << ((dwVertex & 0x03E0) >> 5);
    char    str[256];
    DDASSERT(PROF_DRAWINDEXEDPRIMITIVEVB >= caller);
    DDASSERT(D3DPT_TRIANGLEFAN >= dwPrimitive && D3DPT_POINTLIST<= dwPrimitive);
    if (dwCaller & bitwisecaller)
    {
        if (dwPrimitiveType[caller] & bitwisePrimitive)
        {
            if ((dwVertexType1[caller] & bitwiseVertex1) &&
                (dwVertexType2[caller] & bitwiseVertex2))
            {
                return; //matching a previous api call, no spew, could count stat though
            }
            else
            {
                dwVertexType1[caller] |= bitwiseVertex1;
                dwVertexType2[caller] |= bitwiseVertex2;
            }
        }
        else
        {
            dwPrimitiveType[caller] |= bitwisePrimitive;
            dwVertexType1[caller] |= bitwiseVertex1;
            dwVertexType2[caller] |= bitwiseVertex2;
        }
    }
    else
    {
        this->dwCaller |= bitwisecaller;
        dwPrimitiveType[caller] |= bitwisePrimitive;
        dwVertexType1[caller] |= bitwiseVertex1;
        dwVertexType2[caller] |= bitwiseVertex2;
    }
    wsprintf( (LPSTR) str, ProfileStr[caller]);
    strcat(str,":");
    strcat(str,PrimitiveStr[dwPrimitive-1]);
    if (dwVertex > D3DVT_TLVERTEX)
    {
        if (dwVertex == D3DFVF_VERTEX)
        {
            dwVertex = D3DVT_VERTEX;
        }
        else
        if (dwVertex == D3DFVF_LVERTEX)
        {
            dwVertex = D3DVT_LVERTEX;
        }
        else
        if (dwVertex == D3DFVF_TLVERTEX)
        {
            dwVertex = D3DVT_TLVERTEX;
        }
        else
        {
            D3D_INFO(PROFILE_LEVEL,"Profile:%s FVFType=%08lx",str,dwVertex);
            return;
        }
    }
    else
    {
        DDASSERT(dwVertex >= D3DVT_VERTEX);
    }
    strcat(str,":");
    strcat(str,VertexStr[dwVertex-1]);
    D3D_INFO(PROFILE_LEVEL,"Profile:%s",str);
}

#endif // DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::MultiplyTransform"

//    MultiplyTransform -- this preconcatenates the new matrix to the specified
//    transform matrix
//
//        this really screams for overloaded matrix ops...
//
HRESULT D3DAPI
DIRECT3DDEVICEI::MultiplyTransform(D3DTRANSFORMSTATETYPE dtsTransformState, LPD3DMATRIX lpMat)
{
#if DBG
    if (!VALID_D3DMATRIX_PTR(lpMat))
    {
        D3D_ERR( "Invalid matrix pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (MT only).
        D3DMATRIXI mResult;
        switch (dtsTransformState)
        {
        case D3DTRANSFORMSTATE_WORLD      :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[0]);
            break;
        case D3DTRANSFORMSTATE_WORLD1     :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[1]);
            break;
        case D3DTRANSFORMSTATE_WORLD2     :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[2]);
            break;
        case D3DTRANSFORMSTATE_WORLD3     :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.world[3]);
            break;
        case D3DTRANSFORMSTATE_VIEW       :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.view);
            break;
        case D3DTRANSFORMSTATE_PROJECTION :
            MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->transform.proj);
            break;
        case D3DTRANSFORMSTATE_TEXTURE0:
        case D3DTRANSFORMSTATE_TEXTURE1:
        case D3DTRANSFORMSTATE_TEXTURE2:
        case D3DTRANSFORMSTATE_TEXTURE3:
        case D3DTRANSFORMSTATE_TEXTURE4:
        case D3DTRANSFORMSTATE_TEXTURE5:
        case D3DTRANSFORMSTATE_TEXTURE6:
        case D3DTRANSFORMSTATE_TEXTURE7:
            {
                DWORD dwIndex = dtsTransformState - D3DTRANSFORMSTATE_TEXTURE0;
                MatrixProduct(&mResult, (D3DMATRIXI*)lpMat, &this->mTexture[dwIndex]);
                break;
            }
        default :
            D3D_ERR( "Invalid state value passed to MultiplyTransform" );
            return DDERR_INVALIDPARAMS; /* Work Item: Generate new meaningful return code */
        }
        SetTransformI(dtsTransformState, (D3DMATRIX*)&mResult);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::BeginStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::BeginStateBlock()
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("Already in the state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        if (m_pStateSets->StartNewSet() != D3D_OK)
            return DDERR_OUTOFMEMORY;

        this->dwFEFlags |= D3DFE_RECORDSTATEMODE;
#ifdef VTABLE_HACK
        VtblSetRenderStateRecord();
        VtblSetTextureStageStateRecord();
        VtblSetTextureRecord();
        VtblApplyStateBlockRecord();
#endif VTABLE_HACK
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::EndStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::EndStateBlock(LPDWORD pdwHandle)
{
    if (!VALID_PTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));

        if (!(this->dwFEFlags & D3DFE_RECORDSTATEMODE))
        {
            D3D_ERR("Not in state record mode");
            return D3DERR_NOTINBEGINSTATEBLOCK;
        }
        this->dwFEFlags &= ~D3DFE_RECORDSTATEMODE;
        m_pStateSets->EndSet();
#ifdef VTABLE_HACK
        if (IS_DP2HAL_DEVICE(this) && (!IS_MT_DEVICE(this)))
        {
            VtblSetRenderStateExecute();
            VtblSetTextureStageStateExecute();
            VtblSetTextureExecute();
            VtblApplyStateBlockExecute();
        }
#endif VTABLE_HACK
        this->WriteStateSetToDevice((D3DSTATEBLOCKTYPE)0);
        *pdwHandle = m_pStateSets->GetCurrentHandle();
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::DeleteStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::DeleteStateBlock(DWORD dwHandle)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        m_pStateSets->DeleteStateSet(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ApplyStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::ApplyStateBlock(DWORD dwHandle)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("We are in state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        return ApplyStateBlockInternal(dwHandle);
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ApplyStateBlockInternal"

HRESULT D3DAPI DIRECT3DDEVICEI::ApplyStateBlockInternal(DWORD dwHandle)
{
    try
    {
        m_pStateSets->Execute(this, dwHandle);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CaptureStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::CaptureStateBlock(DWORD dwHandle)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot capture when in the state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        m_pStateSets->Capture(this, dwHandle);
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::CreateStateBlock"

HRESULT D3DAPI DIRECT3DDEVICEI::CreateStateBlock(D3DSTATEBLOCKTYPE sbt, LPDWORD pdwHandle)
{
    if (!VALID_PTR(pdwHandle, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid DWORD pointer" );
        return DDERR_INVALIDPARAMS;
    }
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
        {
            D3D_ERR("Cannot create state block when in the state record mode");
            return D3DERR_INBEGINSTATEBLOCK;
        }
        if (m_pStateSets->StartNewSet() != D3D_OK)
            return DDERR_OUTOFMEMORY;
        m_pStateSets->CreatePredefined(this, sbt);
        m_pStateSets->EndSet();
        this->WriteStateSetToDevice(sbt);
        *pdwHandle = m_pStateSets->GetCurrentHandle();
        return D3D_OK;
    }
    catch (HRESULT ret)
    {
        m_pStateSets->Cleanup(m_pStateSets->GetCurrentHandle());
        *pdwHandle = 0xFFFFFFFF;
        return ret;
    }
}
//---------------------------------------------------------------------
// Input:
//    type      - FVF control dword
//
// Returns D3D_OK, if the control dword is valid.
// DDERR_INVALIDPARAMS otherwise
//
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ValidateFVF"

HRESULT DIRECT3DDEVICEI::ValidateFVF(DWORD type)
{
    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(type);
    DWORD vertexType = type & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if (type & g_TextureFormatMask[dwTexCoord])
    {
        D3D_ERR("FVF has incorrect texture format");
        goto error;
    }
    if (type & 0xFFFF0000 && vertexType == D3DFVF_XYZRHW &&
        this->deviceType < D3DDEVTYPE_DX7HAL)
    {
        D3D_ERR("The D3D device supports only two floats per texture coordinate set");
        goto error;
    }
    if (type & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) ||
        (type & D3DFVF_RESERVED1 && !(type & D3DFVF_LVERTEX)))
    {
        D3D_ERR("FVF has reserved bit(s) set");
        goto error;
    }
    if (!(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5))
    {
        D3D_ERR("FVF has incorrect position type");
        goto error;
    }

    if (vertexType == D3DFVF_XYZRHW && type & D3DFVF_NORMAL)
    {
        D3D_ERR("Normal should not be used with XYZRHW position type");
        goto error;
    }
    return D3D_OK;
error:
    D3D_ERR("ValidateFVF() returns DDERR_INVALIDPARAMS");
    return DDERR_INVALIDPARAMS;
}
//---------------------------------------------------------------------
// The function should bot be called by ProcessVertices.
// Computes nOutTexCoord and dwTextureIndexToCopy in case when a pre-DX6
// driver is used.
//
void ComputeTCI2CopyLegacy(LPDIRECT3DDEVICEI lpDevI,
                           DWORD  dwNumInpTexCoord,
                           DWORD* pdwInpTexCoordSize,
                           BOOL bVertexTransformed)
{
    lpDevI->dwTextureIndexToCopy = 0;
    lpDevI->nOutTexCoord = 0;
    lpDevI->dwTextureCoordSizeTotal = 0;
    lpDevI->dwTextureCoordSize[0] = 0;

    // If texture is enabled we care about texture gen mode and the texture
    // index to copy
    if (lpDevI->tsstates[0][D3DTSS_COLOROP] != D3DTOP_DISABLE)
    {
        DWORD dwTexIndex = lpDevI->tsstates[0][D3DTSS_TEXCOORDINDEX];
        DWORD dwTexGenMode = dwTexIndex & ~0xFFFF;
        dwTexIndex &= 0xFFFF;
        if (bVertexTransformed)
        {
            lpDevI->dwTextureIndexToCopy = dwTexIndex;
            // In case of clipping we need to clip as many texture
            // coordinates as set in the texture stage state.
            lpDevI->nOutTexCoord = min(dwNumInpTexCoord, lpDevI->dwTextureIndexToCopy+1);
            for (DWORD i=0; i < lpDevI->nOutTexCoord; i++)
            {
                lpDevI->dwTextureCoordSizeTotal += pdwInpTexCoordSize[i];
                lpDevI->dwTextureCoordSize[i] = pdwInpTexCoordSize[i];
            }
        }
        else
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
                lpDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL)
                lpDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION)
                lpDevI->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
            lpDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            LPD3DFE_TEXTURESTAGE pStage = &lpDevI->textureStage[0];
            pStage->dwInpCoordIndex = 0;
            pStage->dwTexGenMode = dwTexGenMode;
            pStage->dwOrgStage = 0;
            pStage->dwInpOffset = 0;
            pStage->dwOutCoordIndex = 0;
            if (lpDevI->dwFlags2 & __FLAGS2_TEXTRANSFORM0)
            {
                pStage->pmTextureTransform = &lpDevI->mTexture[0];
                pStage->dwTexTransformFuncIndex = MakeTexTransformFuncIndex(3, 2);
            }
            else
            {
                pStage->pmTextureTransform = NULL;
            }
            pStage->dwOrgWrapMode = lpDevI->rstates[D3DRENDERSTATE_WRAP0];
            // Texture index is used as an index to the new WRAP mode
            DWORD dwNewWrapMode = lpDevI->rstates[D3DRENDERSTATE_WRAP0 + dwTexIndex];
            if (dwNewWrapMode != pStage->dwOrgWrapMode)
            {
                lpDevI->rstates[D3DRENDERSTATE_WRAP0] = dwNewWrapMode;
                lpDevI->SetRenderStateI(D3DRENDERSTATE_WRAP0, dwNewWrapMode);
            }
            lpDevI->nOutTexCoord = 1;
            lpDevI->dwNumTextureStages = 1;
            lpDevI->dwTextureCoordSizeTotal = 8;
            lpDevI->dwTextureCoordSize[0] = 8;
        }
        else
        if (dwNumInpTexCoord != 0)
        {
            lpDevI->nOutTexCoord = 1;
            lpDevI->dwTextureIndexToCopy = dwTexIndex;
            lpDevI->dwTextureCoordSizeTotal = 8;
            lpDevI->dwTextureCoordSize[0] = 8;
        }
    }
}
//---------------------------------------------------------------------
// Computes output FVF id, based on input FVF id and device settingd
// Also computes nTexCoord field
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF sould
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetupFVFData"

HRESULT DIRECT3DDEVICEI::SetupFVFData(DWORD *pdwInpVertexSize)
{
    // We have to restore texture stage indices if previous primitive
    // re-mapped them
    if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
    }

    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    this->nTexCoord = FVF_TEXCOORD_NUMBER(this->dwVIDIn);

    DWORD dwInpTexSizeTotal = ComputeTextureCoordSize(this->dwVIDIn, this->dwInpTextureCoordSize);
    // Compute size of dwVIDIn
    DWORD dwInpVertexSize = GetVertexSizeFVF(this->dwVIDIn) + dwInpTexSizeTotal;
    if (pdwInpVertexSize)
    {
        *pdwInpVertexSize = dwInpVertexSize;
    }

    // Compute how many texture coordinates to copy
    ComputeTCI2CopyLegacy(this, this->nTexCoord, this->dwInpTextureCoordSize,
                          FVF_TRANSFORMED(this->dwVIDIn));

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        this->dwVIDOut = this->dwVIDIn;
        ComputeOutputVertexOffsets(this);
        this->dwOutputSize = dwInpVertexSize;
        return D3D_OK;
    }
    else
    {
        this->dwVIDOut = D3DFVF_TLVERTEX;
        this->dwOutputSize = sizeof(D3DTLVERTEX);
    }

    if (!(this->dwFlags & D3DPV_VBCALL))
        UpdateGeometryLoopData(this);

    this->dwDeviceFlags &= ~D3DDEV_TEXTURETRANSFORM;
    // Stage 0 bit is used for the texture transform
    if (this->dwFlags2 & __FLAGS2_TEXTRANSFORM0)
    {
        this->pmTexture[0] = &this->mTexture[0];
        this->dwDeviceFlags |= D3DDEV_TEXTURETRANSFORM;
        if ((this->tsstates[0][D3DTSS_TEXTURETRANSFORMFLAGS] & 0xFF) != 2)
        {
            D3D_ERR("The texture transform for the device should use 2 floats");
            return DDERR_INVALIDPARAMS;
        }
    }
    else
    if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        D3D_ERR("Cannot use texture generation without texture transform for pre-DX6 device");
        return DDERR_INVALIDPARAMS;
    }


    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    this->lighting.alpha = (DWORD)this->lighting.materialAlpha;
    this->lighting.alphaSpecular = (DWORD)this->lighting.materialAlphaS;

    return D3D_OK;
}
//---------------------------------------------------------------------
// Returns TRUE, if driver state should not be updated
//
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::UpdateInternalTextureStageState"

BOOL DIRECT3DDEVICEI::UpdateInternalTextureStageState
        (DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    BOOL ret = FALSE; // return TRUE if TSS should NOT be batched
    if(dwState == D3DTSS_COLOROP)
    {
        if(dwValue == D3DTOP_DISABLE || tsstates[dwStage][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            ForceFVFRecompute();
    }
    else
    if (dwState == D3DTSS_TEXCOORDINDEX)
    {
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            RestoreTextureStages(this);
            ForceFVFRecompute();
        }
        else
        if (TextureTransformEnabled(this))
        {
            // Force re-compute if a texture transfrom is enabled
            ForceFVFRecompute();
        }
        DWORD dwTexGenMode = 0;
        if (dwValue >= D3DDP_MAXTEXCOORD)
        {
            dwTexGenMode = dwValue & ~0xFFFF;
            if(!IS_TLHAL_DEVICE(this))
                ret = TRUE;
#if DBG
            DWORD dwTexIndex   = dwValue & 0xFFFF;
            if (!(dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
                  dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR) ||
                  dwTexIndex > D3DDP_MAXTEXCOORD)
            {
                D3D_ERR("Incorrect texture coordinate set index");
                throw DDERR_INVALIDPARAMS;
            }
#endif
        }
        DWORD dwTexGenBit = 0;
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            dwTexGenBit = __FLAGS2_TEXGEN0 << dwStage;   // To set internal "enable" dword
        }
        // Force to re-compute FVF only if enable state is changed
        if ((this->dwFlags2 & dwTexGenBit) != dwTexGenBit)
        {
            ForceFVFRecompute();
            this->dwFlags2 = (this->dwFlags2 & ~dwTexGenBit) | dwTexGenBit;
            this->dwDeviceFlags &= ~(D3DDEV_POSITIONINCAMERASPACE | D3DDEV_NORMALINCAMERASPACE);
        }
        if (!(this->dwDeviceFlags & D3DDEV_FVF))
        {
            ForceFVFRecompute();
            if (dwValue != 0)
                ret = TRUE;
        }
    }
    else
    if (dwState == D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        DWORD dwEnableBit = 1 << dwStage;   // To check internal "enable" dword
        // Force to re-compute FVF only if enable state is changed
        if (dwValue == D3DTTFF_DISABLE)
        {
            if (this->dwFlags2 & dwEnableBit)
            {
                ForceFVFRecompute();
                this->dwFlags2 &= ~dwEnableBit;
            }
        }
        else
        {
            if (!(this->dwFlags2 & dwEnableBit))
            {
                ForceFVFRecompute();
                this->dwFlags2 |= dwEnableBit;
            }
        }
        if(this->deviceType == D3DDEVTYPE_DP2HAL)
            ret = TRUE;
    }
    else if(dwState > D3DTSS_TEXTURETRANSFORMFLAGS)
    {
        if(this->deviceType == D3DDEVTYPE_DP2HAL)
            ret = TRUE;
    }
    // Update runtime copy of state.
    tsstates[dwStage][dwState] = dwValue;
    return ret;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetClipPlaneI"

void DIRECT3DDEVICEI::SetClipPlaneI(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
    D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
    p[0] = pPlaneEquation[0];
    p[1] = pPlaneEquation[1];
    p[2] = pPlaneEquation[2];
    p[3] = pPlaneEquation[3];
    this->dwFEFlags |= D3DFE_CLIPPLANES_DIRTY | D3DFE_FRONTEND_DIRTY;
    this->dwMaxUserClipPlanes = 0;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::SetClipPlane"

HRESULT D3DAPI
DIRECT3DDEVICEI::SetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
#if DBG
    if (dwPlaneIndex >= max(this->transform.dwMaxUserClipPlanes, __MAXUSERCLIPPLANES))
    {
        D3D_ERR("Plane index is too big");
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_PTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR( "Invalid plane pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        if (this->dwFEFlags & D3DFE_RECORDSTATEMODE)
            m_pStateSets->InsertClipPlane(dwPlaneIndex, pPlaneEquation);
        else
            SetClipPlaneI(dwPlaneIndex, pPlaneEquation);
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::GetClipPlane"

HRESULT D3DAPI
DIRECT3DDEVICEI::GetClipPlane(DWORD dwPlaneIndex, D3DVALUE* pPlaneEquation)
{
#if DBG
    if (dwPlaneIndex >= max(this->transform.dwMaxUserClipPlanes, __MAXUSERCLIPPLANES))
    {
        D3D_ERR("Plane index is too big");
        return DDERR_INVALIDPARAMS;
    }
    if (!VALID_PTR(pPlaneEquation, sizeof(D3DVALUE)*4))
    {
        D3D_ERR( "Invalid plane pointer" );
        return DDERR_INVALIDPARAMS;
    }
#endif
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));
        D3DVALUE *p = &this->transform.userClipPlane[dwPlaneIndex].x;
        pPlaneEquation[0] = p[0];
        pPlaneEquation[1] = p[1];
        pPlaneEquation[2] = p[2];
        pPlaneEquation[3] = p[3];
        return D3D_OK;
    }
    catch(HRESULT ret)
    {
        return ret;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\deviunk.cpp ===
/*==========================================================================;
*
*  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
*
*  File:    deviunk.c
*  Content: Direct3DDevice IUnknown
*@@BEGIN_MSINTERNAL
* 
*  $Id$
*
*  History:
*   Date    By  Reason
*   ====    ==  ======
*   07/12/95    stevela Merged Colin's changes.
*   10/12/95    stevela Removed AGGREGATE_D3D.
*@@END_MSINTERNAL
*
***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * D3DDev_QueryInterface
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::QueryInterface"
  
HRESULT D3DAPI DIRECT3DDEVICEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
    
    if (!VALID_OUTPTR(ppvObj)) {
        D3D_ERR( "Invalid pointer to object pointer" );
        return DDERR_INVALIDPARAMS;
    }
    
    D3D_INFO(3, "Direct3DDevice IUnknown QueryInterface");
    
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDirect3DDevice7))
    {
        AddRef();
        *ppvObj = static_cast<LPVOID>(this);
    }
    else
    {
        D3D_ERR("unknown interface");
        return (E_NOINTERFACE);
    }
    
    return (D3D_OK);
    
} /* D3DDev_QueryInterface */

/*
 * D3DDev_AddRef
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::AddRef"
  
ULONG D3DAPI DIRECT3DDEVICEI::AddRef()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    this->refCnt++;
    D3D_INFO(3, "Direct3DDevice IUnknown AddRef: Reference count = %d", this->refCnt);
    
    return (this->refCnt);
    
} /* D3DDev_AddRef */

/*
 * D3DDev_Release
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::Release"
  
ULONG D3DAPI DIRECT3DDEVICEI::Release()
{
    CLockD3D lockObject(DPF_MODNAME, REMIND(""));   // Takes D3D lock. 
                                                    // Release in the destructor
    
    /*
     * decrement the ref count. if we hit 0, free the object
     */
    this->refCnt--;
    
    D3D_INFO(3, "Direct3DDevice IUnknown Release: Reference count = %d", this->refCnt);
    
    if( this->refCnt == 0 )
    {
        delete this; // suicide
        return 0;
    }
    return this->refCnt;
    
} /* D3DDev_Release */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\dlld3d.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   dlld3d.cpp
 *  Content:    Direct3D startup
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   05/11/95   stevela Initial rev with this header.
 *   21/11/95   colinmc Added Direct3D interface ID.
 *   07/12/95   stevela Merged Colin's changes.
 *   10/12/95   stevela Removed AGGREGATE_D3D.
 *   02/03/96   colinmc Minor build fix.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Define the Direct3D IIDs.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "Direct3D Startup"

DPF_DECLARE(Direct3D);

#ifdef WIN95
LPVOID lpWin16Lock;
#endif

DWORD dwD3DTriBatchSize, dwTriBatchSize, dwLineBatchSize;
DWORD dwHWBufferSize, dwHWMaxTris, dwHWFewVertices;
HINSTANCE hGeometryDLL;
LPD3DFE_CONTEXTCREATE pfnFEContextCreate;
char szCPUString[13];

DWORD dwCPUFamily, dwCPUFeatures;

#ifdef _X86_
extern BOOL isX3Dprocessor(void);
#endif

void SetMostRecentApp(void);

#ifndef WIN95 // and Win98, WinME
//---------------------------------------------------------------------

BOOL bVBSwapEnabled = TRUE, bVBSwapWorkaround = FALSE;

void SetVBSwapStatus(void)
{
    OSVERSIONINFOEX osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx((LPOSVERSIONINFO)&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }

    if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0) // Check if Win2K Gold (2195)
        {
            if (osvi.wServicePackMajor == 0) // No service pack
            {
                D3D_INFO(1, "Win2K Gold detected - turning off VB swapping");
                bVBSwapEnabled = FALSE;
            }
            else
            {
                D3D_INFO(1, "Win2K SP1 or above detected - enabling VB swap workaround");
                bVBSwapEnabled = FALSE;
                bVBSwapWorkaround = TRUE;
            }
        }
        else // Whistler and above
        {
            /* ASSUMPTION: NO WORKAROUND NEEDED */
        }
    }
    else
    {
        // Should never get here
        DPF_ERR("OS Detection failed - turning off VB swapping");
        bVBSwapEnabled = FALSE;
        return;
    }
}
#endif // WIN95


#ifdef _X86_
// --------------------------------------------------------------------------
// Here's a routine helps us determine if we should try MMX or not
// --------------------------------------------------------------------------
BOOL _asm_isMMX()
{
    DWORD retval;
    _asm
        {
            xor         eax,eax         ; Clear out eax for return value
            pushad              ; CPUID trashes lots - save everything
            mov     eax,1           ; Check for MMX support

            ;;; We need to upgrade our compiler
            ;;; CPUID == 0f,a2
            _emit   0x0f
            _emit   0xa2

            test    edx,00800000h   ; Set flags before restoring registers

            popad               ; Restore everything

            setnz    al             ; Set return value
            mov     retval, eax
        };
    return retval;
}
#endif

static int isMMX = -1;

BOOL
isMMXprocessor(void)
{
    HKEY hKey;
    if ( RegOpenKey( HKEY_LOCAL_MACHINE,
                     RESPATH_D3D,
                     &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = 4;
        if ( RegQueryValueEx( hKey, "DisableMMX", NULL, &dwType, (LPBYTE) &dwValue, &dwSize) == ERROR_SUCCESS &&
             dwType == REG_DWORD &&
             dwValue != 0)
        {
            RegCloseKey( hKey );
            isMMX = 0;
            return FALSE;
        }
        RegCloseKey( hKey );
    }

    if (isMMX < 0)
    {
        isMMX = FALSE;
#ifdef _X86_
        D3D_WARN(0, "Executing processor detection code (benign first-chance exception possible)" );
#ifndef WIN95
        {
            // GetSystemInfo is not broken on WinNT.
            SYSTEM_INFO si;

            GetSystemInfo(&si);
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL &&
                si.wProcessorLevel >= 5)
            {
#endif
                __try
                    {
                        if( _asm_isMMX() )
                        {

                            // Emit an emms instruction.
                            // This file needs to compile for non-Pentium
                            // processors
                            // so we can't use use inline asm since we're in the
                            // wrong
                            // processor mode.
                            __asm __emit 0xf;
                            __asm __emit 0x77;
                            isMMX = TRUE;
                            D3D_INFO(0, "MMX detected");
                        }
                    }
                __except(GetExceptionCode() == STATUS_ILLEGAL_INSTRUCTION ?
                         EXCEPTION_EXECUTE_HANDLER :
                         EXCEPTION_CONTINUE_SEARCH)
                    {
                    }
#ifndef WIN95
            }

        }
#endif
#endif
    }
    return isMMX;
}

#ifdef _X86_

//---------------------------------------------------------------------
// Detects Intel SSE processor
//
#pragma optimize("", off)
#define CPUID _asm _emit 0x0f _asm _emit 0xa2

#define SSE_PRESENT 0x02000000                  // bit number 25
#define WNI_PRESENT 0x04000000                  // bit number 26

DWORD IsIntelSSEProcessor(void)
{
        DWORD retval = 0;
        DWORD RegisterEAX;
        DWORD RegisterEDX;
        char VendorId[12];

        __try
        {
                _asm {
            xor         eax,eax
            CPUID
                mov             RegisterEAX, eax
                mov             dword ptr VendorId, ebx
                mov             dword ptr VendorId+4, edx
                mov             dword ptr VendorId+8, ecx
                }
        } __except (1)
        {
                return retval;
        }

        // make sure EAX is > 0 which means the chip
        // supports a value >=1. 1 = chip info
        if (RegisterEAX == 0)
                return retval;

        // this CPUID can't fail if the above test passed
        __asm {
                mov eax,1
                CPUID
                mov RegisterEAX,eax
                mov RegisterEDX,edx
        }

        if (RegisterEDX  & SSE_PRESENT) {
                retval |= D3DCPU_SSE;
        }

        if (RegisterEDX  & WNI_PRESENT) {
                retval |= D3DCPU_WLMT;
        }

        return retval;
}

#pragma optimize("", on)

#ifdef WIN95 // and Win98...
//---------------------------------------------------------------------
BOOL
IsWin95(void)
{
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (!GetVersionEx(&osvi))
    {
        D3D_INFO(1,"GetVersionEx failed - assuming Win95");
        return TRUE;
    }

    if ( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {

        if( ( osvi.dwMajorVersion > 4UL ) ||
            ( ( osvi.dwMajorVersion == 4UL ) &&
              ( osvi.dwMinorVersion >= 10UL ) &&
              ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
        {
            // is Win98
            D3D_INFO(2,"Detected Win98");
            return FALSE;
        }
        else
        {
            // is Win95
            D3D_INFO(2,"Detected Win95");
            return TRUE;
        }
    }
    else if ( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        D3D_INFO(2,"Detected WinNT");
        return FALSE;
    }
    D3D_INFO(2,"OS Detection failed");
    return TRUE;
}
#endif  // WIN95

//---------------------------------------------------------------------
//
//  void GetProcessorFamily(LPDWORD lpdwFamily);
//
//      Passes back 3, 4, 5, 6 for 386, 486, Pentium, PPro class machines
//
#pragma optimize("", off)
void
GetProcessorFamily(LPDWORD lpdwFamily, LPDWORD lpdwCPUFeatures)
{
    SYSTEM_INFO si;
    __int64     start, end, freq;
    int         flags,family;
    int         time;
    int         clocks;
    DWORD       oldclass;
    HANDLE      hprocess;

    // guilty until proven otherwise
    *lpdwCPUFeatures = D3DCPU_BLOCKINGREAD;

    if ( isMMXprocessor() )
    {
        *lpdwCPUFeatures |= D3DCPU_MMX;
    }

    ZeroMemory(&si, sizeof(si));
    GetSystemInfo(&si);

    //Set the family. If wProcessorLevel is not specified, dig it out of dwProcessorType
    //Because wProcessor level is not implemented on Win95
    if (si.wProcessorLevel)
    {
        *lpdwFamily=si.wProcessorLevel;
    }
    else
    {
        //Ok, we're on Win95
        switch (si.dwProcessorType)
        {
            case PROCESSOR_INTEL_386:
                *lpdwFamily=3;
                break;

            case PROCESSOR_INTEL_486:
                *lpdwFamily=4;
                break;
            default:
                *lpdwFamily=0;
                break;
        }
    }

    //
    // make sure this is a INTEL Pentium (or clone) or higher.
    //
    if (si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
        return;

    if (si.dwProcessorType < PROCESSOR_INTEL_PENTIUM)
        return;

    //
    // see if this chip supports rdtsc before using it.
    //
    __try
    {
        _asm
        {
            xor     eax,eax
            _emit   00fh    ;; CPUID
            _emit   0a2h
            mov     dword ptr szCPUString,ebx
            mov     dword ptr szCPUString+8,ecx
            mov     dword ptr szCPUString+4,edx
            mov     byte ptr szCPUString+12,0
            mov     eax,1
            _emit   00Fh     ;; CPUID
            _emit   0A2h
            mov     flags,edx
            mov     family,eax
        }
    }
    __except(1)
    {
        flags = 0;
    }

    //check for support of CPUID and fail
    if (!(flags & 0x10))
        return;

    // fcomi and FPU features both set
    if ( (flags&(1<<15)) && (flags & (1<<0)) )
    {
        D3D_INFO(2, "Pentium Pro CPU features (fcomi, cmov) detected");
        *lpdwCPUFeatures |= D3DCPU_FCOMICMOV;
    }

    //If we don't have a family, set it now
    //Family is bits 11:8 of eax from CPU, with eax=1
    if (!(*lpdwFamily))
    {
       *lpdwFamily=(family& 0x0F00) >> 8;
    }
    // not aware of any non-Intel processors w/non blocking reads
    if ( (! strcmp(szCPUString, "GenuineIntel")) &&
         *lpdwFamily > 5)
    {
        *lpdwCPUFeatures &= ~D3DCPU_BLOCKINGREAD;
    }

    if ( isX3Dprocessor() )
    {
        D3D_INFO(2, "X3D Processor detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_X3D;
    }

    DWORD retval = IsIntelSSEProcessor();
    if (retval & D3DCPU_SSE)
    {
        D3D_INFO(2, "Streaming SIMD Extensions detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_SSE;
    }
    if (retval & D3DCPU_WLMT)
    {
        D3D_INFO(2, "Streaming SIMD Extensions 2 detected for PSGP");
        *lpdwCPUFeatures |= D3DCPU_WLMT;
    }

    return;
}
#pragma optimize("", on)

#endif // _X86_

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwType, dwSize = sizeof(dwHWFewVertices);
    char filename[_MAX_PATH];

    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( hModule );
        DPFINIT();
        MemInit();
#ifdef WIN95
        GetpWin16Lock(&lpWin16Lock);
#endif

#ifdef _X86_
        GetProcessorFamily(&dwCPUFamily, &dwCPUFeatures);
        D3D_INFO(3, "dwCPUFamily = %d, dwCPUFeatures = %d", dwCPUFamily, dwCPUFeatures);
        D3D_INFO(3, "szCPUString = %s", szCPUString);
#endif

#ifdef WIN95 // and Win98...
    // SSE (aka Katmai) does not work on Win95, so see if we are on Win95 and disable
    //
    {
        BOOL bIsWin95 = IsWin95();
        if (bIsWin95)
        {
            dwCPUFeatures &= ~(D3DCPU_SSE | D3DCPU_WLMT);
        }
    }
        // We need to workaround VB problems on Win2K
#else
        SetVBSwapStatus();
#endif
        // Unfounded default value. 128*40 (vertex+D3DTRIANGLE struct)=5K
        // The assumption is that the primary cache hasn't got much better
        // to do than contain the vertex and index data.
        dwD3DTriBatchSize = 80;
        // Work item: do something more intelligent here than assume that
        // MMX-enabled processors have twice as much primary cache.
        if ( isMMXprocessor() )
            dwD3DTriBatchSize *= 2;
        dwTriBatchSize = (dwD3DTriBatchSize * 4) / 3;
        dwLineBatchSize = dwD3DTriBatchSize * 2;
        dwHWBufferSize = dwD3DTriBatchSize * (sizeof(D3DTLVERTEX) + sizeof(D3DTRIANGLE));
        dwHWMaxTris = dwD3DTriBatchSize;
        lRet = RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey );
        if ( lRet == ERROR_SUCCESS )
        {
            lRet = RegQueryValueEx(hKey,
                                   "FewVertices",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) &dwHWFewVertices,
                                   &dwSize);
            if (lRet != ERROR_SUCCESS ||
                dwType != REG_DWORD ||
                dwHWFewVertices < 4 ||
                dwHWFewVertices > 128)

                dwHWFewVertices = 24;

#ifdef __D3D_PSGP_DLL__
            dwSize = sizeof(filename);
            lRet = RegQueryValueEx(hKey,
                                   "GeometryDriver",
                                   NULL,
                                   &dwType,
                                   (LPBYTE) filename,
                                   &dwSize);
            if (lRet == ERROR_SUCCESS && dwType == REG_SZ)
            {
                hGeometryDLL = LoadLibrary(filename);
                if (hGeometryDLL)
                {
                    pfnFEContextCreate = (LPD3DFE_CONTEXTCREATE) GetProcAddress(hGeometryDLL, "FEContextCreate");
                }
            }
#endif //__D3D_PSGP_DLL__

            RegCloseKey( hKey );
        }
        else
        {
            dwHWFewVertices = 24;
        }
        // Set the app name to reg.
        SetMostRecentApp();
        break;
    case DLL_PROCESS_DETACH:
        MemFini();
        if (NULL != hGeometryDLL)
            FreeLibrary(hGeometryDLL);
        break;
    default:
        ;
    }
    return TRUE;
}

// --------------------------------------------------------------------------
// This function is called at process attach time to put the name of current
// app to registry.
// --------------------------------------------------------------------------
void SetMostRecentApp(void)
{
    char    fname[_MAX_PATH];
    char    name[_MAX_PATH];
    int     i;
    HKEY    hKey;
    HANDLE  hFile;

    // Find out what process we are dealing with
    hFile =  GetModuleHandle( NULL );
    GetModuleFileName( (HINSTANCE)hFile, fname, sizeof( fname ) );
    DPF( 3, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
        i--;
    }
    i++;
    strcpy( name, &fname[i] );
    DPF( 3, "name       = %s", name );

    // Now write the name into some known place
        if( !RegCreateKey( HKEY_LOCAL_MACHINE,
             RESPATH_D3D "\\" REGSTR_KEY_LASTAPP, &hKey ) )
    {
        RegSetValueEx(hKey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\dpgen.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpgen.h
 *  Content:    Generate some functions for Draw Primitive 
 *
 ***************************************************************************/

#ifdef __DRAWPRIMFUNC

//---------------------------------------------------------------------
// Draws indexed and non-indexed primitives which do not require clipping
//
#ifdef  __DRAWPRIMINDEX
HRESULT CDirect3DDeviceIDP::DrawIndexPrim()
{
    D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumIndices;
#else
HRESULT CDirect3DDeviceIDP::DrawPrim()
{
    D3DHAL_DRAWONEPRIMITIVEDATA dpData;
    DWORD &dwNumElements = this->dwNumVertices;
#endif
    const WORD vertexType = D3DVT_TLVERTEX;    // XXX While we do not have DDI
    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        HRESULT ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    
    if (dwNumElements < LOWVERTICESNUMBERDP && 
        this->dwCurrentBatchVID == this->dwVIDOut)
    {
        LPD3DHAL_DRAWPRIMCOUNTS lpPC;
        lpPC = this->lpDPPrimCounts;
        if (lpPC->wNumVertices)
        {
            if ((lpPC->wPrimitiveType!=(WORD) this->primType) ||
                (lpPC->wVertexType != vertexType) ||
                (this->primType==D3DPT_TRIANGLESTRIP) ||
                (this->primType==D3DPT_TRIANGLEFAN) ||
                (this->primType==D3DPT_LINESTRIP))
            {
                lpPC = this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)
                       ((LPBYTE)this->lpwDPBuffer + this->dwDPOffset);
                memset( (char *)lpPC, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));
                // preserve 32 bytes alignment for vertices
                this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
                ALIGN32(this->dwDPOffset);
            }
        }
        else
        {
            // 32-byte align offset pointer, just in case states have been
            // recorded.
            ALIGN32(this->dwDPOffset);
        }
        ULONG ByteCount;
        if (FVF_DRIVERSUPPORTED(this))
            ByteCount = dwNumElements * this->dwOutputSize;
        else
            ByteCount = dwNumElements << 5;   // D3DTLVERTEX
        if (this->dwDPOffset + ByteCount  > this->dwDPMaxOffset)
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));  // Takes D3D lock (ST only).
            //DPF(0,"overflowed ByteCount=%08lx",ByteCount);
            HRESULT ret;
            ret = this->FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in Draw*Prim");
                return ret;
            }
            lpPC = this->lpDPPrimCounts;
            ALIGN32(this->dwDPOffset);
        }
        lpPC->wPrimitiveType = (WORD)this->primType;
        lpPC->wVertexType = (WORD)vertexType;
        lpPC->wNumVertices += (WORD)dwNumElements;
        BYTE *lpVertex = (BYTE*)((char *)this->lpwDPBuffer + this->dwDPOffset);
#ifdef __DRAWPRIMINDEX
        DWORD  i;
        BYTE *pV = (BYTE*)this->lpvOut;
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            for (i=0; i < this->dwNumIndices; i++)
            {
                memcpy(lpVertex, pV + this->lpwIndices[i] * this->dwOutputSize,
                       this->dwOutputSize);
                lpVertex += this->dwOutputSize;
            }
        else
            for (i=0; i < this->dwNumIndices; i++)
            {
                MapFVFtoTLVertex1(this, (D3DTLVERTEX*)lpVertex, 
                                  (DWORD*)(pV + this->lpwIndices[i] * 
                                           this->dwOutputSize));
                lpVertex += sizeof(D3DTLVERTEX);
            }
#else // !__DRAWPRIMINDEX
        if (FVF_DRIVERSUPPORTED(this) || this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpVertex, this->lpvOut, ByteCount);
        else
            MapFVFtoTLVertex(lpVertex);
#endif //__DRAWPRIMINDEX
        this->dwDPOffset += ByteCount;
        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        HRESULT ret;
        ret = this->FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in Draw*Prim");
            return ret;
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  this->dwFlags;
        dpData.PrimitiveType = this->primType;
        if (FVF_DRIVERSUPPORTED(this))
        {
            dpData.dwFVFControl = this->dwVIDOut;
            dpData.lpvVertices = this->lpvOut;
        }
        else
        {
            if (this->dwVIDOut == D3DFVF_TLVERTEX)
                dpData.lpvVertices = this->lpvOut;
            else
            {
                HRESULT ret;
#ifdef __DRAWPRIMINDEX
                if (this->dwNumIndices * INDEX_BATCH_SCALE < this->dwNumVertices)
                    ret = this->MapFVFtoTLVertexIndexed();
                else
#endif
                ret = MapFVFtoTLVertex(NULL);
                if (ret != D3D_OK)
                    return ret;
                dpData.lpvVertices = this->TLVbuf.GetAddress();
            }
            dpData.VertexType = (D3DVERTEXTYPE)vertexType;
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
        }
        dpData.dwNumVertices = this->dwNumVertices;
        dpData.ddrval = D3D_OK;
#ifdef __DRAWPRIMINDEX
        dpData.lpwIndices = this->lpwIndices;
        dpData.dwNumIndices = this->dwNumIndices;
#endif
        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
            DWORD dwRet;
        #ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                return (dwRet);
            }
        #endif //WIN95
#ifdef __DRAWPRIMINDEX
            CALL_HAL2ONLY(dwRet, this, DrawOneIndexedPrimitive, &dpData);
#else
            CALL_HAL2ONLY(dwRet, this, DrawOnePrimitive, &dpData);
#endif
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver not handled in DrawOnePrimitive" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }

        } while ( (this->dwFlags & D3DDP_WAIT) && (dpData.ddrval == DDERR_WASSTILLDRAWING) );
    }
    return dpData.ddrval;
}

#endif //__DRAWPRIMFUNC

#undef __DRAWPRIMFUNC
#undef __DRAWPRIMINDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\dp2hal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cbhal.cpp
 *  Content:    DrawPrimitive implementation for command buffer HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"
#include "pvvid.h"
#if DBG
// #define VALIDATE_DP2CMD
#endif

extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
                          LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
                          FLATPTR                   fpVidMem );

#ifndef WIN95
extern BOOL bVBSwapEnabled, bVBSwapWorkaround;
#endif // WIN95

// Command buffer size tuned to 16K to minimize flushes in Unreal
const DWORD CDirect3DDeviceIDP2::dwD3DDefaultCommandBatchSize = 16384; // * 1 = 16K bytes

inline void CDirect3DDeviceIDP2::ClearBatch(bool bWithinPrimitive)
{
    // Reset command buffer
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)lpvDP2Commands;
    dwDP2CommandLength = 0;
    dp2data.dwCommandOffset = 0;
    dp2data.dwCommandLength = 0;
    bDP2CurrCmdOP = 0;
    // Reset vertex buffer
    if (!bWithinPrimitive)
    {
        dp2data.dwVertexOffset = 0;
        this->dwDP2VertexCount = 0;
        dwVertexBase = 0;
        TLVbuf_Base() = 0;
        if (dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            // We are flushing a user mem primitive.
            // We need to clear dp2data.lpUMVertices
            // since we are done with it. We replace
            // it with TLVbuf.
            DDASSERT(lpDP2CurrBatchVBI == NULL);
            dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)TLVbuf_GetDDS())->lpLcl;
            lpDP2CurrBatchVBI = TLVbuf_GetVBI();
            lpDP2CurrBatchVBI->AddRef();
            dp2data.dwFlags &= ~D3DHALDP2_USERMEMVERTICES;
        }
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::CheckSurfaces()"
HRESULT CDirect3DDeviceIDP2::CheckSurfaces()
{
    HRESULT hr;
    if(this->lpDirect3DI->lpTextureManager->CheckIfLost())
    {
        D3D_ERR("Managed Textures lost");
        return DDERR_SURFACELOST;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->lpGbl->dwUsageCount ||
         (this->lpDDSZBuffer && ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->lpGbl->dwUsageCount) )
    {
        D3D_ERR("Render target or Z buffer locked");
        return DDERR_SURFACEBUSY;
    }
    if ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSTarget)->lpLcl->dwFlags & DDRAWISURF_INVALID )\
        {
            D3D_ERR("Render target buffer lost");
            return DDERR_SURFACELOST;
        }
    if ( this->lpDDSZBuffer && ( ((LPDDRAWI_DDRAWSURFACE_INT) this->lpDDSZBuffer)->lpLcl->dwFlags & DDRAWISURF_INVALID ) )
    {
        D3D_ERR("Z buffer lost");
        return DDERR_SURFACELOST;
    }
    if (!(this->dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES) && (this->dp2data.lpDDVertex) && (this->dp2data.lpDDVertex->dwFlags & DDRAWISURF_INVALID))
    {
        D3D_ERR("Vertex buffer lost");
        return DDERR_SURFACELOST;
    }
    if (this->TLVbuf_GetDDS())
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(this->TLVbuf_GetDDS()))->lpLcl;
        if (lpLcl->dwFlags & DDRAWISURF_INVALID)
        {
            D3D_ERR("Internal vertex buffer lost");
            return DDERR_SURFACELOST;
        }
    }
    if (this->dp2data.lpDDCommands->dwFlags & DDRAWISURF_INVALID)
    {
        D3D_ERR("Command buffer lost");
        return DDERR_SURFACELOST;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(void)"

HRESULT CDirect3DDeviceIDP2::FlushStates(bool bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (dwFlags & D3DPV_WITHINPRIMITIVE)
        bWithinPrimitive = true;
    if (dwDP2CommandLength) // Do we have some instructions to flush ?
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ++m_qwBatch;
        // So that currently bound textures get rebatched
        for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
        {
            LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
            if (NULL != lpTexI)
            {
                if(lpTexI->lpDDS != NULL)
                {
                    BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
                }
            }
        }
        // Check if render target and / or z buffer is lost
        if ((dwRet = CheckSurfaces()) != D3D_OK)
        { // If lost, we'll just chuck all this work into the bit bucket
            ClearBatch(bWithinPrimitive);
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                dwRet = D3D_OK;
            }
        }
        else
        {
            // Save since it will get overwritten by ddrval after DDI call
            DWORD dwVertexSize = dp2data.dwVertexSize;
            dp2data.dwVertexLength = this->dwDP2VertexCount;
            dp2data.dwCommandLength = dwDP2CommandLength;
            //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
            dwDP2CommandLength = 0;
            // Try and set these 2 values only once during initialization
            dp2data.dwhContext = this->dwhContext;
            dp2data.lpdwRStates = this->rstates;
            DDASSERT(dp2data.dwVertexSize != 0);
            D3D_INFO(6, "dwVertexType passed to the driver = 0x%08x", dp2data.dwVertexType);

            // If we need the same TLVbuf next time do not swap buffers.
            // Save and restore this bit
            bool bSwapVB = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) != 0;
            if (bWithinPrimitive)
            {
                dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
            }
            // At the end of the DP2 call we expect the VB to be unlocked if
            // 1. We cannot allow the driver to swap the VB
            // 2. We are using a VB (not USERMEMVERTICES)
            // 3. It is not TLVbuf
            // In this case we might as well tell the driver that it is unlocked.
            // More importantly, we need to let DDraw know that the VB is unlocked.
            if (!(dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER))
            {
                if ((lpDP2CurrBatchVBI) && (lpDP2CurrBatchVBI != TLVbuf_GetVBI()))
                {
                    lpDP2CurrBatchVBI->UnlockI();
                }
            }
#ifndef WIN95
            else if (bVBSwapWorkaround && lpDP2CurrBatchVBI != 0 && lpDP2CurrBatchVBI == TLVbuf_GetVBI())
            {
                lpDP2CurrBatchVBI->UnlockWorkAround();
            }
            if (!bVBSwapEnabled)  // Note: bVBSwapEnabled not the same as bSwapVB above.
                                  // bVBSwapEnabled is a global to indicate whether VB
                                  // VB swapping should be turned off due to broken
                                  // Win2K kernel implementation
            {
                dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
            }
            if (!dp2data.lpDDCommands->hDDSurface)
                CompleteCreateSysmemSurface(dp2data.lpDDCommands);
            if (!(dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES )
                && !dp2data.lpDDVertex->hDDSurface)
                CompleteCreateSysmemSurface(dp2data.lpDDVertex);
#else
            // Take Win 16 Lock here
            LOCK_HAL( dwRet, this );
#endif //WIN95

            // Spin waiting on the driver if wait requested
            do {
                // Need to set this since the driver may have overwrote it by
                // setting ddrval = DDERR_WASSTILLDRAWING
                dp2data.dwVertexSize = dwVertexSize;
                CALL_HAL3ONLY_NOLOCK(dwRet, this, DrawPrimitives2, &dp2data);
                if (dwRet != DDHAL_DRIVER_HANDLED)
                {
                    D3D_ERR ( "Driver not handled in DrawPrimitives2" );
                    // Need sensible return value in this case,
                    // currently we return whatever the driver stuck in here.
                }
            } while (dp2data.ddrval == DDERR_WASSTILLDRAWING);
            if (dp2data.ddrval == D3DERR_COMMAND_UNPARSED)
            { // This should never occur since the driver must understand
              // all the instruction we batch.
                D3D_ERR("Driver could not parse this batch!");
                dwRet = DDERR_GENERIC; // Some thing better here ?
            }
            else
            {
                dwRet= dp2data.ddrval;
                // update command buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPCOMMANDBUFFER))
                {
#ifdef WIN95
                    // Get Aliased vid mem pointer if it is a vid mem surf.
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMCOMMANDBUF)
                    {
                        D3D_INFO(7, "Got back new vid mem command buffer");
                        FLATPTR paliasbits = GetAliasedVidMem( dp2data.lpDDCommands->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDCommands, (FLATPTR) dp2data.lpDDCommands->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem command buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDCommands->lpGbl->dwLinearSize = 0;
                        }
                        lpvDP2Commands = (LPVOID)paliasbits;
                    }
                    else
#endif
                    {
                        D3D_INFO(7, "Got back new sys mem command buffer");
                        lpvDP2Commands = (LPVOID)dp2data.lpDDCommands->lpGbl->fpVidMem;
                    }
                    dwDP2CommandBufSize = dp2data.lpDDCommands->lpGbl->dwLinearSize;
                }
                // update vertex buffer pointer
                if ((dwRet == D3D_OK) && (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER) && dp2data.lpDDVertex)
                {
                    FLATPTR paliasbits;
#ifdef WIN95
                    if (dp2data.dwFlags & D3DHALDP2_VIDMEMVERTEXBUF)
                    {
                        paliasbits = GetAliasedVidMem( dp2data.lpDDVertex->lpSurfMore->lpDD_lcl,
                            dp2data.lpDDVertex, (FLATPTR) dp2data.lpDDVertex->lpGbl->fpVidMem );
                        if (paliasbits == NULL)
                        {
                            DPF_ERR("Could not get Aliased pointer for vid mem vertex buffer");
                            // Since we can't use this pointer, set it's size to 0
                            // That way next time around we will try and allocate a new one
                            dp2data.lpDDVertex->lpGbl->dwLinearSize = 0;
                        }
                    }
                    else
#endif
                    {
                        paliasbits = dp2data.lpDDVertex->lpGbl->fpVidMem;
                    }
                    if (lpDP2CurrBatchVBI == TLVbuf_GetVBI())
                    {
#if DBG
                        if(this->alignedBuf != (VOID*)paliasbits)
                        {
                            D3D_INFO(2, "Driver swapped TLVBuf pointer in FlushStates");
                        }
#endif //DBG
                        this->alignedBuf = (LPVOID)paliasbits;
                        this->TLVbuf_size = dp2data.lpDDVertex->lpGbl->dwLinearSize;
                    }
                    else
                    {
#if DBG
                        if(this->lpDP2CurrBatchVBI->position.lpvData != (VOID*)paliasbits)
                        {
                            D3D_INFO(2, "Driver swapped VB pointer in FlushStates");
                        }
#endif //DBG
                        this->lpDP2CurrBatchVBI->position.lpvData = (LPVOID)paliasbits;
                    }
                }
            }
#ifdef WIN95
            // Release Win16 Lock here
            UNLOCK_HAL( this );
#else
            if (!bWithinPrimitive && bSwapVB && bVBSwapWorkaround && lpDP2CurrBatchVBI != 0 && lpDP2CurrBatchVBI == TLVbuf_GetVBI())
            {
                HRESULT hr = lpDP2CurrBatchVBI->LockWorkAround(this);
                if (FAILED(hr))
                {
                    TLVbuf_base = 0;
                    TLVbuf_size = 0;
                    D3D_ERR("Driver failed Lock in FlushStates");
                    if (SUCCEEDED(dwRet))
                    {
                        dwRet = hr;
                    }
                }
            }
#endif
            // Restore flag if necessary
            if (bSwapVB)
                dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
            // Restore to value before the DDI call
            dp2data.dwVertexSize = dwVertexSize;
            ClearBatch(bWithinPrimitive);
        }
    }
    // There are situations when the command stream has no data, but there is data in
    // the vertex pool. This could happen, for instance if every triangle got rejected
    // while clipping. In this case we still need to "Flush out" the vertex data.
    else if (dp2data.dwCommandLength == 0)
    {
        ClearBatch(bWithinPrimitive);
    }
    return dwRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::FlushStates(DWORD)"

HRESULT CDirect3DDeviceIDP2::FlushStatesReq(DWORD dwReqSize)
{
    DWORD sav = (dp2data.dwFlags & D3DHALDP2_SWAPVERTEXBUFFER);
    dp2data.dwReqVertexBufSize = dwReqSize;
    dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE;
    HRESULT ret = FlushStates();
    dp2data.dwFlags &= ~(D3DHALDP2_SWAPVERTEXBUFFER | D3DHALDP2_REQVERTEXBUFSIZE);
    dp2data.dwFlags |= sav;
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::GrowCommandBuffer"
// Check and grow command buffer
HRESULT CDirect3DDeviceIDP2::GrowCommandBuffer(LPDIRECT3DI lpD3DI, DWORD dwSize)
{
    HRESULT ret;
    if (dwSize > dwDP2CommandBufSize)
    {
        if (lpDDSCB1)
        {
            lpDDSCB1->Release();
            lpDDSCB1 = NULL;
        }
        // Create command buffer through DirectDraw
        DDSURFACEDESC2 ddsd;
        memset(&ddsd, 0, sizeof(DDSURFACEDESC2));
        ddsd.dwSize = sizeof(DDSURFACEDESC2);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_CAPS;
        ddsd.dwWidth = dwSize;
        ddsd.ddsCaps.dwCaps = DDSCAPS_EXECUTEBUFFER;
        if (IS_HW_DEVICE(this))
            ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        else
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        ddsd.ddsCaps.dwCaps2 = DDSCAPS2_COMMANDBUFFER;
        // Try explicit video memory first
        D3D_INFO(7, "Trying to create a vid mem command buffer");
        ret = lpD3DI->lpDD7->CreateSurface(&ddsd, &lpDDSCB1, NULL);
        if (ret != DD_OK)
        {
            // If that failed, try explicit system memory
            ddsd.ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            D3D_INFO(7, "Trying to create a sys mem command buffer");
            ret = lpD3DI->lpDD7->CreateSurface(&ddsd, &lpDDSCB1, NULL);
            if (ret != DD_OK)
            {
                D3D_ERR("failed to allocate Command Buffer 1");
                dwDP2CommandBufSize = 0;
                return ret;
            }
        }
        // Lock command buffer
        ret = lpDDSCB1->Lock(NULL, &ddsd, DDLOCK_WAIT | DDLOCK_NOSYSLOCK, NULL);
        if (ret != DD_OK)
        {
            D3D_ERR("Could not lock command buffer.");
            lpDDSCB1->Release();
            lpDDSCB1 = NULL;
            dwDP2CommandBufSize = 0;
            return ret;
        }
        // update command buffer pointer
        lpvDP2Commands = ddsd.lpSurface;
        dp2data.lpDDCommands = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSCB1)->lpLcl;
        dwDP2CommandBufSize = dwSize;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::Init"

HRESULT CDirect3DDeviceIDP2::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, LPDIRECTDRAWSURFACE lpDDS,
                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    dwDP2CommandBufSize = 0;
    dwDP2Flags =0;
    lpDDSCB1 = NULL;
    lpvDP2Commands = NULL;
    TLVbuf_size = 0;
    allocatedBuf = 0;
    alignedBuf = 0;
    TLVbuf_base = 0;
    dwTLVbufChanges = 0;
    pNullVB = NULL;
    // We do this early in case of DP2 since GrowCommandBuffer depends on this check
    if (IsEqualIID(riid, IID_IDirect3DHALDevice) || IsEqualIID(riid, IID_IDirect3DTnLHalDevice))
    {
        this->dwFEFlags |=  D3DFE_REALHAL;
    }
    HRESULT ret = GrowCommandBuffer(lpD3DI, dwD3DDefaultCommandBatchSize);
    if (ret != D3D_OK)
        return ret;
    // Fill the dp2data structure with initial values
    dp2data.dwFlags = D3DHALDP2_SWAPCOMMANDBUFFER;
    dp2data.dwVertexType = D3DFVF_TLVERTEX; // Initial assumption
    dp2data.dwVertexSize = sizeof(D3DTLVERTEX); // Initial assumption
    ClearBatch(false);

    // Initialize the DDI independent part of the device
    ret = DIRECT3DDEVICEI::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
    {
        return ret;
    }

    // Since we plan to call TLV_Grow for the first time with "true"
    this->dwDeviceFlags |= D3DDEV_TLVBUFWRITEONLY;
    if (TLVbuf_Grow((__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX), true) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (TLVbuf)" );
        return DDERR_OUTOFMEMORY;
    }
    D3DVERTEXBUFFERDESC vbdesc;
    vbdesc.dwSize = sizeof(D3DVERTEXBUFFERDESC);
    vbdesc.dwCaps = D3DVBCAPS_SYSTEMMEMORY;
    vbdesc.dwFVF = D3DFVF_TLVERTEX;
    vbdesc.dwNumVertices = 1;
    ret = this->lpDirect3DI->CreateVertexBufferI(&vbdesc, &this->pNullVB, 0);
    if (ret != DD_OK)
    {
        return ret;
    }
#ifdef VTABLE_HACK
    if (!IS_MT_DEVICE(this))
    {
        // Make SetRS point to execute mode
        VtblSetRenderStateExecute();
        VtblSetTextureStageStateExecute();
        VtblSetTextureExecute();
        VtblApplyStateBlockExecute();
    }
#endif
    return ret;
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2"

CDirect3DDeviceIDP2::~CDirect3DDeviceIDP2()
{
    CleanupTextures();
    if (pNullVB)
        pNullVB->Release();
    if (allocatedBuf)
        allocatedBuf->Release();
    if (lpDDSCB1)
        lpDDSCB1->Release();
    if (lpDP2CurrBatchVBI)
    {
        lpDP2CurrBatchVBI->lpDevIBatched = NULL;
        lpDP2CurrBatchVBI->Release();
    }
}
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetRenderStateI"

HRESULT CDirect3DDeviceIDP2::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                             DWORD value)
{
    HRESULT ret = D3D_OK;
    if (bDP2CurrCmdOP == D3DDP2OP_RENDERSTATE)
    { // Last instruction is a renderstate, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2RENDERSTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->RenderState = dwStateType;
            lpRState->dwState = value;
            dwDP2CommandLength += sizeof(D3DHAL_DP2RENDERSTATE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2RENDERSTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();

            // Since we ran out of space, we were not able to put (dwStateType, value)
            // into the batch so rstates will reflect only the last batched
            // renderstate (since the driver updates rstates from the batch).
            // To fix this, we simply put the current (dwStateType, value) into rstates.
            this->rstates[dwStateType]=value;

            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetRenderStateI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_RENDERSTATE;
    bDP2CurrCmdOP = D3DDP2OP_RENDERSTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2RENDERSTATE lpRState = (LPD3DHAL_DP2RENDERSTATE)(lpDP2CurrCommand + 1);
    lpRState->RenderState = dwStateType;
    lpRState->dwState = value;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE);
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const iprim2cmdop[] = {
    0, // Invalid
    0, // Points are invalid too
    D3DDP2OP_INDEXEDLINELIST2,
    D3DDP2OP_INDEXEDLINESTRIP,
    D3DDP2OP_INDEXEDTRIANGLELIST2,
    D3DDP2OP_INDEXEDTRIANGLESTRIP,
    D3DDP2OP_INDEXEDTRIANGLEFAN
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawIndexPrim"

//---------------------------------------------------------------------
//
// The vertices are already in the vertex buffer.
//
HRESULT CDirect3DDeviceIDP2::DrawIndexPrim()
{
    HRESULT ret = D3D_OK;
    DWORD dwByteCount;          // Command length plus indices
    DWORD dwIndicesByteCount;   // Indices only
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    dwIndicesByteCount = sizeof(WORD) * this->dwNumIndices;
    dwByteCount = dwIndicesByteCount + sizeof(D3DHAL_DP2COMMAND) +
                  sizeof(D3DHAL_DP2STARTVERTEX);

    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Request the driver to grow the command buffer upon flush
        dp2data.dwReqCommandBufSize = dwByteCount;
        dp2data.dwFlags |= D3DHALDP2_REQCOMMANDBUFSIZE;
        ret = FlushStates(true);
        dp2data.dwFlags &= ~D3DHALDP2_REQCOMMANDBUFSIZE;
        if (ret != D3D_OK)
            return ret;
        // Check if the driver did give us what we need or do it ourselves
        ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
        if (ret != D3D_OK)
        {
            D3D_ERR("Could not grow Command Buffer");
            return ret;
        }
    }
    // Insert indexed primitive instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                       dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;

    LPBYTE pIndices = (BYTE*)(lpDP2CurrCommand + 1);     // Place for indices
    lpDP2CurrCommand->bCommand = (BYTE)iprim2cmdop[this->primType];
    ((LPD3DHAL_DP2STARTVERTEX)(lpDP2CurrCommand+1))->wVStart =
        (WORD)this->dwVertexBase;
    pIndices += sizeof(D3DHAL_DP2STARTVERTEX);

#if DBG
    if (lpDP2CurrCommand->bCommand == 0)
    {
        D3D_ERR("Illegal primitive type");
        return DDERR_GENERIC;
    }
#endif
    bDP2CurrCmdOP = lpDP2CurrCommand->bCommand;

    memcpy(pIndices, this->lpwIndices, dwIndicesByteCount);

    wDP2CurrCmdCnt = lpDP2CurrCommand->wPrimitiveCount;
    dwDP2CommandLength += dwByteCount;
    return ret;
}

// Map D3DPRIMITIVETYPE to D3DHAL_DP2OPERATION
const prim2cmdop[] = {
    0, // Invalid
    D3DDP2OP_POINTS,
    D3DDP2OP_LINELIST,
    D3DDP2OP_LINESTRIP,
    D3DDP2OP_TRIANGLELIST,
    D3DDP2OP_TRIANGLESTRIP,
    D3DDP2OP_TRIANGLEFAN
};
// Map D3DPRIMITIVETYPE to bytes needed in command stream
const prim2cmdsz[] = {
    0, // Invalid
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2POINTS),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2LINESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLELIST),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLESTRIP),
    sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TRIANGLEFAN)
};

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::DrawClippedPrim"

//---------------------------------------------------------------------
// This primitive is generated by the clipper.
// The vertices of this primitive are pointed to by the
// lpvOut member, which need to be copied into the
// command stream immediately after the command itself.
HRESULT CDirect3DDeviceIDP2::DrawClippedPrim()
{
    HRESULT ret = D3D_OK;
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    DWORD dwExtra = 0;
    LPVOID lpvVerticesImm;  // Place for vertices
    DWORD dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;
    if (this->primType == D3DPT_TRIANGLEFAN)
    {
        if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME &&
            this->dwFlags & D3DPV_NONCLIPPED)
        {
            // For unclipped (but pretended to be clipped) tri fans in
            // wireframe mode we generate 3-vertex tri fans to enable drawing of
            // interior edges
            BYTE vertices[__MAX_VERTEX_SIZE*3];
            BYTE *pV1 = vertices + this->dwOutputSize;
            BYTE *pV2 = pV1 + this->dwOutputSize;
            BYTE *pInput = (BYTE*)this->lpvOut;
            memcpy(vertices, pInput, this->dwOutputSize);
            pInput += this->dwOutputSize;
            const DWORD nTriangles = this->dwNumVertices - 2;
            this->dwNumVertices = 3;
            this->dwNumPrimitives = 1;
            this->lpvOut = vertices;
            this->dwFlags &= ~D3DPV_NONCLIPPED;  // Remove this flag for recursive call
            for (DWORD i = nTriangles; i; i--)
            {
                memcpy(pV1, pInput, this->dwOutputSize);
                memcpy(pV2, pInput+this->dwOutputSize, this->dwOutputSize);
                pInput += this->dwOutputSize;
                // To enable all edge flag we set the fill mode to SOLID.
                // This will prevent checking the clip flags in the clipper state.
                rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_SOLID;
                ret = DrawClippedPrim();
                rstates[D3DRENDERSTATE_FILLMODE] = D3DFILL_WIREFRAME;
                if (ret != D3D_OK)
                        return ret;
            }
            return D3D_OK;
        }
        dwExtra = sizeof(D3DHAL_DP2TRIANGLEFAN_IMM);
    }
    DWORD dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwDP2CommandLength + dwExtra) & 3;
    DWORD dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwPad + dwExtra + dwVertexPoolSize;

    // Check for space in the command buffer for commands & vertices
    if (dwDP2CommandLength + dwByteCount > dwDP2CommandBufSize)
    {
        // Flush the current batch but hold on to the vertices
        ret = FlushStates(true);
        if (ret != D3D_OK)
            return ret;
        if (dwByteCount > dwDP2CommandBufSize)
        {
            ret = GrowCommandBuffer(this->lpDirect3DI, dwByteCount);
            if (ret != D3D_OK)
            {
                D3D_ERR("Could not grow Command Buffer");
                return ret;
            }
        }

        dwPad = (sizeof(D3DHAL_DP2COMMAND) + dwExtra) & 3;
        dwByteCount = sizeof(D3DHAL_DP2COMMAND) + dwExtra + dwPad + dwVertexPoolSize;
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->wPrimitiveCount = (WORD)this->dwNumPrimitives;
    lpDP2CurrCommand->bReserved = 0;
    if (this->primType == D3DPT_TRIANGLEFAN)
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_TRIANGLEFAN_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        LPD3DHAL_DP2TRIANGLEFAN_IMM lpTriFanImm = (LPD3DHAL_DP2TRIANGLEFAN_IMM)(lpDP2CurrCommand + 1);
        if (rstates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
        {
            lpTriFanImm->dwEdgeFlags = 0;
            ClipVertex **clip = this->ClipperState.current_vbuf;
            // Look at the exterior edges and mark the visible ones
            for(DWORD i = 0; i < this->dwNumVertices; ++i)
            {
                if (clip[i]->clip & CLIPPED_ENABLE)
                    lpTriFanImm->dwEdgeFlags |= (1 << i);
            }
        }
        else
        {
            // Mark all exterior edges visible
            lpTriFanImm->dwEdgeFlags = 0xFFFFFFFF;
        }
        lpvVerticesImm = (LPBYTE)(lpTriFanImm + 1) + dwPad;
    }
    else
    {
        // Insert inline instruction and vertices
        bDP2CurrCmdOP = D3DDP2OP_LINELIST_IMM;
        lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
        lpvVerticesImm = (LPBYTE)(lpDP2CurrCommand + 1) + dwPad;
    }
    memcpy(lpvVerticesImm, this->lpvOut, dwVertexPoolSize);
    dwDP2CommandLength += dwByteCount;
    return ret;
}
//---------------------------------------------------------------------
HRESULT CDirect3DDeviceIDP2::DrawPrim()
{
    HRESULT ret = D3D_OK;
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }
    // Check for space in the command buffer for new command.
    // The vertices are already in the vertex buffer.
    if (dwDP2CommandLength + prim2cmdsz[this->primType] > dwDP2CommandBufSize)
    {
        ret = FlushStates(true);
        if (ret != D3D_OK)
            return ret;
    }
    // Insert non indexed primitive instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    bDP2CurrCmdOP = (BYTE)prim2cmdop[this->primType];
    lpDP2CurrCommand->bCommand = bDP2CurrCmdOP;
    lpDP2CurrCommand->bReserved = 0;
    if (bDP2CurrCmdOP == D3DDP2OP_POINTS)
    {
        wDP2CurrCmdCnt = 1;
        LPD3DHAL_DP2POINTS lpPoints = (LPD3DHAL_DP2POINTS)(lpDP2CurrCommand + 1);
        lpPoints->wCount = (WORD)this->dwNumVertices;
        lpPoints->wVStart = (WORD)this->dwVertexBase;
    }
    else
    {
        // Linestrip, trianglestrip, trianglefan, linelist and trianglelist are identical
        wDP2CurrCmdCnt = (WORD)this->dwNumPrimitives;
        LPD3DHAL_DP2LINESTRIP lpStrip = (LPD3DHAL_DP2LINESTRIP)(lpDP2CurrCommand + 1);
        lpStrip->wVStart = (WORD)this->dwVertexBase;
    }
    lpDP2CurrCommand->wPrimitiveCount = wDP2CurrCmdCnt;
    dwDP2CommandLength += prim2cmdsz[this->primType];
#ifdef VALIDATE_DP2CMD
    ValidateCommand(lpDP2CurrCommand);
#endif
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetTSSI"

HRESULT CDirect3DDeviceIDP2::SetTSSI(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    HRESULT ret = D3D_OK;

    // Filter unsupported states
    if (dwState >= m_tssMax)
        return D3D_OK;

    if (bDP2CurrCmdOP == D3DDP2OP_TEXTURESTAGESTATE)
    { // Last instruction is a texture stage state, append this one to it
        if (dwDP2CommandLength + sizeof(D3DHAL_DP2TEXTURESTAGESTATE) <= dwDP2CommandBufSize)
        {
            LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)((LPBYTE)lpvDP2Commands +
                dwDP2CommandLength + dp2data.dwCommandOffset);
            lpDP2CurrCommand->wStateCount = ++wDP2CurrCmdCnt;
            lpRState->wStage = (WORD)dwStage;
            lpRState->TSState = (WORD)dwState;
            lpRState->dwValue = dwValue;
            dwDP2CommandLength += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
            D3D_INFO(6, "Modify Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
            return ret;
        }
    }
    // Check for space
    if (dwDP2CommandLength + sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) > dwDP2CommandBufSize)
    {
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in SetTSSI");
                return ret;
            }
    }
    // Add new renderstate instruction
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
    bDP2CurrCmdOP = D3DDP2OP_TEXTURESTAGESTATE;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;
    D3D_INFO(6, "Write Ins:%08lx", *(LPDWORD)lpDP2CurrCommand);
    // Add renderstate data
    LPD3DHAL_DP2TEXTURESTAGESTATE lpRState = (LPD3DHAL_DP2TEXTURESTAGESTATE)(lpDP2CurrCommand + 1);
    lpRState->wStage = (WORD)dwStage;
    lpRState->TSState = (WORD)dwState;
    lpRState->dwValue = dwValue;
    dwDP2CommandLength += sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIDP2::ValidateDevice(LPDWORD lpdwNumPasses)
{
    try
    {
        // Holds D3D lock until exit.
        CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
        HRESULT ret;
        D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

        if (!VALID_DIRECT3DDEVICE_PTR(this))
        {
            D3D_ERR( "Invalid Direct3DDevice7 pointer" );
            return DDERR_INVALIDOBJECT;
        }
        if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
        {
            D3D_ERR( "Invalid lpdwNumPasses pointer" );
            return DDERR_INVALIDPARAMS;
        }

        // First, Update textures since drivers pass /fail this call based
        // on the current texture handles
        ret = UpdateTextures();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to update managed textures in ValidateDevice");
            return ret;
        }
        // First, flush states, so we can validate the current state
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to FlushStates in ValidateDevice");
            return ret;
        }

        // Now ask the driver!

        *lpdwNumPasses = 0;
        memset(&vbod, 0, sizeof(D3DHAL_VALIDATETEXTURESTAGESTATEDATA));
        vbod.dwhContext = this->dwhContext;
        if (this->lpD3DHALCallbacks3->ValidateTextureStageState)
        {
             CALL_HAL3ONLY(ret, this, ValidateTextureStageState, &vbod);
             if (ret != DDHAL_DRIVER_HANDLED)
                 return DDERR_UNSUPPORTED;

             *lpdwNumPasses = vbod.dwNumPasses;
             return vbod.ddrval;
        }
        else
        {
            D3D_ERR("Error: ValidateTextureStageState not supported by the driver.");
        }

        return DDERR_UNSUPPORTED;
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimVB"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called only if vertices from user memory are NOT used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimVB(LPDIRECT3DVERTEXBUFFERI lpVBI,
                                         DWORD dwStartVertex)
{
    HRESULT ret = D3D_OK;

    // If VID has been changed or new vertex buffer is used we flush the batch
    if (this->dwVIDOut != dp2data.dwVertexType ||
        lpDP2CurrBatchVBI != lpVBI ||
        dp2data.lpDDVertex != ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl)
    {
        ret = FlushStates();
        if (ret != D3D_OK)
            return ret;
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpVBI->GetDDS()))->lpLcl;
        // Release previously used vertex buffer (if any), because we do not
        // need it any more. We did AddRef() to TL buffer, so it is safe.
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->lpDevIBatched = NULL;
            lpDP2CurrBatchVBI->Release();
        }
        // If a vertex buffer is used for rendering, make sure that it is not
        // released by user. So do AddRef().
        lpDP2CurrBatchVBI = lpVBI;
        lpDP2CurrBatchVBI->AddRef();
    }
    if (this->TLVbuf_GetVBI() == lpVBI)
    {
        this->dwVertexBase = this->dwDP2VertexCount;
        DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
        dp2data.dwFlags |= D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwVertexBase + this->dwNumVertices;
#ifdef VTABLE_HACK
        VtblDrawPrimitiveVBDefault();
        VtblDrawIndexedPrimitiveVBDefault();
#endif VTABLE_HACK
    }
    else
    {
        this->dwVertexBase = dwStartVertex;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = max(this->dwDP2VertexCount, this->dwVertexBase + this->dwNumVertices);
#ifdef VTABLE_HACK
        VtblDrawPrimitiveDefault();
        VtblDrawIndexedPrimitiveDefault();
#endif VTABLE_HACK
    }
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::StartPrimUserMem"
//---------------------------------------------------------------------
// This function prepares the batch for new primitive.
// Called if vertices from user memory is used for rendering
//
HRESULT CDirect3DDeviceIDP2::StartPrimUserMem(LPVOID lpMem)
{
    HRESULT ret = D3D_OK;
    // We fail vid mem VB for clipping
    bool bWriteOnly = ((this->dwDeviceFlags & D3DDEV_DONOTCLIP) || IS_TLHAL_DEVICE(this))!=0;

    // If the primitive is small, we copy vertices into the TL buffer
        // ATTENTION: Dont do this if the device is a TL device ?
    if (this->dwNumVertices < LOWVERTICESNUMBER)
    {
        if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
        {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, bWriteOnly) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
        }
        // So now user memory is not used any more.
        ret = StartPrimVB(this->TLVbuf_GetVBI(), 0);
        if (ret != D3D_OK)
            return ret;
        LPVOID tmp = this->TLVbuf_GetAddress();
        memcpy(tmp, this->lpvOut, this->dwVertexPoolSize);
        // We have to update lpvOut, because it was set to user memory
        this->lpvOut = tmp;
    }
    else
    {
        // We can not mix user memory primitive with other primitives, so
        // flush the batch.
        // Do not forget to flush the batch after rendering this primitive
        ret = this->FlushStates();
        if (ret != D3D_OK)
            return ret;
        // Release previously used vertex buffer (if any), because we do not
        // it any more
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->lpDevIBatched = NULL;
            lpDP2CurrBatchVBI->Release();
            lpDP2CurrBatchVBI = NULL;
#ifdef VTABLE_HACK
            VtblDrawPrimitiveVBDefault();
            VtblDrawIndexedPrimitiveVBDefault();
            VtblDrawPrimitiveDefault();
            VtblDrawIndexedPrimitiveDefault();
#endif VTABLE_HACK
        }
        dp2data.dwVertexType = this->dwVIDOut;
        dp2data.dwVertexSize = this->dwOutputSize;
        dp2data.lpVertices = lpMem;
        dp2data.dwFlags |= D3DHALDP2_USERMEMVERTICES;
        dp2data.dwFlags &= ~D3DHALDP2_SWAPVERTEXBUFFER;
        this->dwDP2VertexCount = this->dwNumVertices;
        this->dwFlags |= D3DPV_USERMEMVERTICES;
    }
    return ret;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::EndPrim"
//---------------------------------------------------------------------
// This function should not be called from DrawVertexBufferVB
//
HRESULT CDirect3DDeviceIDP2::EndPrim()
{
    HRESULT ret = D3D_OK;
    if (this->dwFlags & D3DPV_USERMEMVERTICES)
        // We can not mix user memory primitive, so flush it.
        ret = this->FlushStates();
    else
    {
        // If TL buffer was used, we have to move its internal base pointer
        this->TLVbuf_Base() += this->dwVertexPoolSize;
        DDASSERT(TLVbuf_base <= TLVbuf_size);
        DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    }

    this->dwFlags &= ~D3DPV_USERMEMVERTICES;
    return ret;
}
//---------------------------------------------------------------------
//
//
void CDirect3DDeviceIDP2::UpdateDrvViewInfo(LPD3DVIEWPORT7 lpVwpData)
{
    LPD3DHAL_DP2VIEWPORTINFO pData;
    pData = (LPD3DHAL_DP2VIEWPORTINFO)GetHalBufferPointer(D3DDP2OP_VIEWPORTINFO, sizeof(*pData));
    pData->dwX = lpVwpData->dwX;
    pData->dwY = lpVwpData->dwY;
    pData->dwWidth = lpVwpData->dwWidth;
    pData->dwHeight = lpVwpData->dwHeight;
}
//---------------------------------------------------------------------
//
//
void CDirect3DDeviceIDP2::UpdateDrvWInfo()
{
    LPD3DHAL_DP2WINFO pData;
    pData = (LPD3DHAL_DP2WINFO)GetHalBufferPointer(D3DDP2OP_WINFO, sizeof(*pData));
    D3DMATRIXI &m = transform.proj;
    if( (m._33 == m._34) || (m._33 == 0.0f) )
    {
        D3D_WARN(1, "Cannot compute WNear and WFar from the supplied projection matrix.\n Setting wNear to 0.0 and wFar to 1.0" );
        pData->dvWNear = 0.0f;
        pData->dvWFar  = 1.0f;
        return;
    }

    pData->dvWNear = m._44 - m._43/m._33*m._34;
    pData->dvWFar  = (m._44 - m._43)/(m._33 - m._34)*m._34 + m._44;
}
//---------------------------------------------------------------------
// Initializes command header in the DP2 command buffer,
// reserves space for the command data and returns pointer to the command
// data
//
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::GetHalBufferPointer"

LPVOID CDirect3DDeviceIDP2::GetHalBufferPointer(D3DHAL_DP2OPERATION op, DWORD dwDataSize)
{
    DWORD dwCommandSize = sizeof(D3DHAL_DP2COMMAND) + dwDataSize;

    // Check to see if there is space to add a new command for space
    if (dwCommandSize + dwDP2CommandLength > dwDP2CommandBufSize)
    {
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in GetHalBufferPointer");
            throw ret;
        }
    }
    lpDP2CurrCommand = (LPD3DHAL_DP2COMMAND)((LPBYTE)lpvDP2Commands +
                        dwDP2CommandLength + dp2data.dwCommandOffset);
    lpDP2CurrCommand->bCommand = op;
    bDP2CurrCmdOP = op;
    lpDP2CurrCommand->bReserved = 0;
    lpDP2CurrCommand->wStateCount = 1;
    wDP2CurrCmdCnt = 1;

    dwDP2CommandLength += dwCommandSize;
    return (LPVOID)(lpDP2CurrCommand + 1);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::UpdateDriverStates"

HRESULT
CDirect3DDeviceIDP2::UpdateDriverStates()
{
    static D3DRENDERSTATETYPE dp2states[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_ZVISIBLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_COLORKEYENABLE,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STIPPLEENABLE,
        D3DRENDERSTATE_MONOENABLE,
        D3DRENDERSTATE_ROP2,
        D3DRENDERSTATE_PLANEMASK,
        D3DRENDERSTATE_WRAPU,
        D3DRENDERSTATE_WRAPV,
        D3DRENDERSTATE_ANTIALIAS,
        D3DRENDERSTATE_SUBPIXEL,
        D3DRENDERSTATE_SUBPIXELX,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_STIPPLEPATTERN00,
        D3DRENDERSTATE_STIPPLEPATTERN01,
        D3DRENDERSTATE_STIPPLEPATTERN02,
        D3DRENDERSTATE_STIPPLEPATTERN03,
        D3DRENDERSTATE_STIPPLEPATTERN04,
        D3DRENDERSTATE_STIPPLEPATTERN05,
        D3DRENDERSTATE_STIPPLEPATTERN06,
        D3DRENDERSTATE_STIPPLEPATTERN07,
        D3DRENDERSTATE_STIPPLEPATTERN08,
        D3DRENDERSTATE_STIPPLEPATTERN09,
        D3DRENDERSTATE_STIPPLEPATTERN10,
        D3DRENDERSTATE_STIPPLEPATTERN11,
        D3DRENDERSTATE_STIPPLEPATTERN12,
        D3DRENDERSTATE_STIPPLEPATTERN13,
        D3DRENDERSTATE_STIPPLEPATTERN14,
        D3DRENDERSTATE_STIPPLEPATTERN15,
        D3DRENDERSTATE_STIPPLEPATTERN16,
        D3DRENDERSTATE_STIPPLEPATTERN17,
        D3DRENDERSTATE_STIPPLEPATTERN18,
        D3DRENDERSTATE_STIPPLEPATTERN19,
        D3DRENDERSTATE_STIPPLEPATTERN20,
        D3DRENDERSTATE_STIPPLEPATTERN21,
        D3DRENDERSTATE_STIPPLEPATTERN22,
        D3DRENDERSTATE_STIPPLEPATTERN23,
        D3DRENDERSTATE_STIPPLEPATTERN24,
        D3DRENDERSTATE_STIPPLEPATTERN25,
        D3DRENDERSTATE_STIPPLEPATTERN26,
        D3DRENDERSTATE_STIPPLEPATTERN27,
        D3DRENDERSTATE_STIPPLEPATTERN28,
        D3DRENDERSTATE_STIPPLEPATTERN29,
        D3DRENDERSTATE_STIPPLEPATTERN30,
        D3DRENDERSTATE_STIPPLEPATTERN31,
        D3DRENDERSTATE_TEXTUREPERSPECTIVE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7
    };
    HRESULT ret;
    for (DWORD i=0;i<sizeof(dp2states)/sizeof(D3DRENDERSTATETYPE); ++i)
    {
        ret = this->SetRenderStateI(dp2states[i], this->rstates[dp2states[i]]);
        if (ret != D3D_OK)
            return ret;
    }
    // Update new states
    for (i=0; i<dwMaxTextureBlendStages; ++i)
        for (DWORD j=D3DTSS_COLOROP; j<=D3DTSS_BUMPENVLOFFSET; ++j) // D3DTSS_BUMPENVLOFFSET is the max. TSS understood by a DP2HAL (DX6) driver
        {
            D3D_INFO(6,"Calling SetTSSI(%d,%d,%08lx)",i,j, this->tsstates[i][j]);
            ret = this->SetTSSI(i, (D3DTEXTURESTAGESTATETYPE)j, this->tsstates[i][j]);
            if (ret != D3D_OK)
                return ret;
        }
    return D3D_OK;
}

//---------------------------------------------------------------------
// ProcessPrimitive processes indexed, non-indexed primitives or
// vertices only as defined by "op"
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
HRESULT CDirect3DDeviceIDP2::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret=D3D_OK;

// Grow clip flags buffer if we need clipping
//
    if (!(this->dwDeviceFlags & D3DDEV_DONOTCLIP))
    {
        DWORD size = this->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        // Pass vertices directly from the user memory
        this->dwVIDOut = this->dwVIDIn;
        this->dwOutputSize = this->position.dwStride;
        this->lpvOut = this->position.lpvData;
        this->dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;

        StartPrimUserMem(this->position.lpvData);
        if (ret != D3D_OK)
            return ret;
        if (this->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            if (!(this->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS))
                D3DFE_updateExtents(this);
#ifdef VTABLE_HACK
            else
                if (!IS_MT_DEVICE(this) && this->dwNumVertices < LOWVERTICESNUMBER)
                    if (op == __PROCPRIMOP_INDEXEDPRIM)
                        VtblDrawIndexedPrimitiveTL();
                    else
                        VtblDrawPrimitiveTL();
#endif // VTABLE_HACK
            if (op == __PROCPRIMOP_INDEXEDPRIM)
            {
                ret = this->DrawIndexPrim();
            }
            else
            {
                ret = this->DrawPrim();
            }
        }
        else
        {
            DWORD clip_intersect = D3DFE_GenClipFlags(this);
            D3DFE_UpdateClipStatus(this);
            if (!clip_intersect)
            {
                this->dwFlags |= D3DPV_TLVCLIP;
                if (op == __PROCPRIMOP_INDEXEDPRIM)
                {
                    ret = DoDrawIndexedPrimitive(this);
                }
                else
                {
                    ret = DoDrawPrimitive(this);
                }
            }
        }
    }
    else
    {
        this->dwVertexPoolSize = this->dwNumVertices * this->dwOutputSize;
        if (op == __PROCPRIMOP_INDEXEDPRIM)
        {
            if ((this->dwDeviceFlags & (D3DDEV_DONOTCLIP | D3DDEV_TLVBUFWRITEONLY))==D3DDEV_TLVBUFWRITEONLY)
            {
                if( FAILED(this->TLVbuf_Grow(this->dwVertexPoolSize, false)) )
                {
                    D3D_ERR( "Could not grow TL vertex buffer" );
                    return DDERR_OUTOFMEMORY;
                }
            }
            else if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
            {
                if (this->TLVbuf_Grow(this->dwVertexPoolSize,
                    (this->dwDeviceFlags & D3DDEV_DONOTCLIP)!=0) != D3D_OK)
                {
                    D3D_ERR( "Could not grow TL vertex buffer" );
                    ret = DDERR_OUTOFMEMORY;
                    return ret;
                }
            }
#ifdef VTABLE_HACK
            // Use fast path if single threaded device and not using strided API
            if (!(IS_MT_DEVICE(this) || (this->dwDeviceFlags & D3DDEV_STRIDE))
                && IS_FPU_SETUP(this))
                VtblDrawIndexedPrimitiveFE();
#endif // VTABLE_HACK
        }
        else
        {
            if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
            {
                if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
                {
                    D3D_ERR( "Could not grow TL vertex buffer" );
                    ret = DDERR_OUTOFMEMORY;
                    return ret;
                }
            }
#ifdef VTABLE_HACK
            // Use fast path if single threaded device and not using strided API
            if (!(IS_MT_DEVICE(this) || (this->dwDeviceFlags & D3DDEV_STRIDE))
                && IS_FPU_SETUP(this))
                VtblDrawPrimitiveFE();
#endif // VTABLE_HACK
        }

        ret = StartPrimVB(this->TLVbuf_GetVBI(), 0);
        if (ret != D3D_OK)
            return ret;
        this->lpvOut = this->TLVbuf_GetAddress();

        // Update Lighting and related flags
        DoUpdateState(this);

#ifdef VTABLE_HACK
        // Save the flags that can be persisted if state does not change
        this->dwLastFlags = this->dwFlags & D3DPV_PERSIST;
#endif // VTABLE_HACK

        // Call PSGP or our implementation
        if (op == __PROCPRIMOP_INDEXEDPRIM)
        {
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
        }
        else
        {
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
        }
        D3DFE_UpdateClipStatus(this);
    }
    if (ret != D3D_OK)
    {
        D3D_ERR("ProcessPrimitive failed");
        return ret;
    }
    return EndPrim();
}
//----------------------------------------------------------------------
// Growing aligned vertex buffer implementation.
//
HRESULT CDirect3DDeviceIDP2::TLVbuf_Grow(DWORD growSize, bool bWriteOnly)
{
    D3DVERTEXBUFFERDESC vbdesc = {sizeof(D3DVERTEXBUFFERDESC), 0, D3DFVF_TLVERTEX, 0};
    DWORD dwRefCnt = 1;
    DWORD bTLVbufIsCurr = static_cast<CDirect3DVertexBuffer*>(allocatedBuf) == lpDP2CurrBatchVBI; // Is ref cnt of TLVbuf 1 or 2 ?

    bool bDP2WriteOnly = (this->dwDeviceFlags & D3DDEV_TLVBUFWRITEONLY) != 0;
    // Avoid to many changes. Restrict TLVbuf to sys mem if too many changes
    if (this->dwTLVbufChanges >= D3D_MAX_TLVBUF_CHANGES)
    {
#if DBG
        if (this->dwTLVbufChanges == D3D_MAX_TLVBUF_CHANGES)
            DPF(1, "Too many changes: Limiting internal VB to sys mem.");
#endif
        bWriteOnly = false;
    }
    if (TLVbuf_base || (bWriteOnly != bDP2WriteOnly))
    {
        HRESULT ret;
        ret = FlushStatesReq(growSize);
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in CDirect3DDeviceIDP2::TLVbuf_Grow");
            return ret;
        }
        TLVbuf_base = 0;
    }
    if (growSize <= TLVbuf_size)
    {
        if (bWriteOnly == bDP2WriteOnly)
            return D3D_OK;
        else
            this->dwTLVbufChanges++;
    }
    if (allocatedBuf)
    {
        allocatedBuf->Release();
        allocatedBuf = NULL;
    }
    if (bTLVbufIsCurr)
    {
        if (lpDP2CurrBatchVBI)
        {
            lpDP2CurrBatchVBI->lpDevIBatched = NULL;
            lpDP2CurrBatchVBI->Release();
        }
        lpDP2CurrBatchVBI = NULL;
        dp2data.lpDDVertex = NULL;
    }
    // Make sure we do not shrink the VB since it will
    // grow it only as large to fit the largest primitive and might not
    // be enough to get good batching perf.
    DWORD size = max(growSize, TLVbuf_size);
    size = (DWORD)max(size, (__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX));
    vbdesc.dwNumVertices = (size + 31) / sizeof(D3DTLVERTEX);
    TLVbuf_size = vbdesc.dwNumVertices * sizeof(D3DTLVERTEX);
    if (!IS_HW_DEVICE(this))
    {
        vbdesc.dwCaps = D3DVBCAPS_SYSTEMMEMORY;
    }
    if (bWriteOnly)
    {
        vbdesc.dwCaps |= D3DVBCAPS_WRITEONLY;
        this->dwDeviceFlags |= D3DDEV_TLVBUFWRITEONLY;
    }
    else
    {
        this->dwDeviceFlags &= ~D3DDEV_TLVBUFWRITEONLY;
    }
    vbdesc.dwCaps |= D3DVBCAPS_DONOTCLIP;
    if (this->lpDirect3DI->CreateVertexBufferI(&vbdesc, &allocatedBuf, D3DVBFLAGS_CREATEMULTIBUFFER) != DD_OK)
    {
        // This should fail duirng mode switches or ulta-low memory situations. In either case,
        // we set allocatedBuf to a valid VB object since it gets dereferenced many places without
        // checking for it being NULL. WE use the special "NULL" VB created at init time for just 
        // this purpose
        allocatedBuf = pNullVB;
        if (pNullVB)
        {
            allocatedBuf->AddRef();
            if (bTLVbufIsCurr)
            {
                lpDP2CurrBatchVBI = static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
                lpDP2CurrBatchVBI->AddRef();
                dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpDP2CurrBatchVBI->GetDDS()))->lpLcl;
            }
        }
        TLVbuf_size = 0;
        alignedBuf = NULL; // Lets see if some one tries to use this...
        D3D_ERR("Could not allocate internal vertex buffer");
        return DDERR_OUTOFMEMORY;
    }
    // Update lpDP2CurrentBatchVBI if necessary
    if (bTLVbufIsCurr)
    {
        lpDP2CurrBatchVBI = static_cast<CDirect3DVertexBuffer*>(allocatedBuf);
        lpDP2CurrBatchVBI->AddRef();
        dp2data.lpDDVertex = ((LPDDRAWI_DDRAWSURFACE_INT)(lpDP2CurrBatchVBI->GetDDS()))->lpLcl;
    }
    if (allocatedBuf->Lock(DDLOCK_WAIT, &alignedBuf, NULL) != DD_OK)
    {
        D3D_ERR("Could not lock internal vertex buffer");
        TLVbuf_size = 0;
        alignedBuf = NULL; // Lets see if some one tries to use this...
        return DDERR_OUTOFMEMORY;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Computes the following data
//  - dwTextureCoordOffset[] offset of every input texture coordinates

static __inline void ComputeInpTexCoordOffsets(DWORD dwNumTexCoord,
                                               DWORD dwFVF,
                                               DWORD *pdwTextureCoordOffset)
{
    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = i << 3;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            pdwTextureCoordOffset[i] = dwOffset;
            dwOffset += g_TextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }
    return;
}
//---------------------------------------------------------------------
// Returns 2 bits of FVF texture format for the texture index
//
static inline DWORD FVFGetTextureFormat(DWORD dwFVF, DWORD dwTextureIndex)
{
    return (dwFVF >> (dwTextureIndex*2 + 16)) & 3;
}
//---------------------------------------------------------------------
// Returns texture format bits shifted to the right place
//
static inline DWORD FVFMakeTextureFormat(DWORD dwNumberOfCoordinates, DWORD dwTextureIndex)
{
    return g_dwTextureFormat[dwNumberOfCoordinates] << ((dwTextureIndex << 1) + 16);
}
//---------------------------------------------------------------------
inline DWORD GetOutTexCoordSize(DWORD *pdwStage, DWORD dwInpTexCoordSize)
{
    // Low byte has texture coordinate count
    const DWORD dwTextureTransformFlags = pdwStage[D3DTSS_TEXTURETRANSFORMFLAGS] & 0xFF;
    if (dwTextureTransformFlags == 0)
        return dwInpTexCoordSize;
    else
        return (dwTextureTransformFlags << 2);
}
//----------------------------------------------------------------------
// pDevI->nOutTexCoord should be initialized to the number of input texture coord sets
//
HRESULT EvalTextureTransforms(LPDIRECT3DDEVICEI pDevI, DWORD dwTexTransform,
                              DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat)
{
    DWORD dwOutTextureSize = 0;         // Used to compute output vertex size
    DWORD dwOutTextureFormat = 0;       // Used to compute output texture FVF
    // The bits are used to find out how the texture coordinates are used.
    const DWORD __USED_BY_TRANSFORM  = 1;
    const DWORD __USED               = 2;
    // The low 16 bits are for _USED bits. The high 16 bits will hold
    // re-mapped texture index for a stage
    DWORD dwTexCoordUsage[D3DDP_MAXTEXCOORD];
    memset(dwTexCoordUsage, 0, sizeof(dwTexCoordUsage));

    // Re-mapping buffer will contain only stages that use texture
    // This variable is used to count them
    pDevI->dwNumTextureStages = 0;
    DWORD dwNewIndex = 0;           // Used to generate output index
    // We need offsets for every input texture coordinate, because
    // we could access them in random order.
    // Offsets are not needed for strided input
    DWORD   dwTextureCoordOffset[D3DDP_MAXTEXCOORD];
    if (!(pDevI->dwDeviceFlags & D3DDEV_STRIDE))
    {
        ComputeInpTexCoordOffsets(pDevI->nTexCoord, pDevI->dwVIDIn, dwTextureCoordOffset);
    }
    DWORD dwOutTextureCoordSize[D3DDP_MAXTEXCOORD];
    // Go through all texture stages and find those which use texture coordinates
    for (DWORD i=0; i < D3DDP_MAXTEXCOORD; i++)
    {
        if (pDevI->tsstates[i][D3DTSS_COLOROP] == D3DTOP_DISABLE)
            break;

        DWORD dwIndex = pDevI->tsstates[i][D3DTSS_TEXCOORDINDEX];
        DWORD dwInpTextureFormat;
        DWORD dwInpTexSize;
        DWORD dwMapArrayIndex = pDevI->dwNumTextureStages;
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStage[dwMapArrayIndex];
        DWORD dwTexGenMode = dwIndex & ~0xFFFF;
        dwIndex = dwIndex & 0xFFFF; // Remove texture generation mode
        if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION ||
            dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
        {
            dwInpTextureFormat = D3DFVF_TEXCOORDSIZE3(dwIndex);
            dwInpTexSize = 3*sizeof(D3DVALUE);
            pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR)
                pDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE | D3DDEV_POSITIONINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACENORMAL)
                pDevI->dwDeviceFlags |= D3DDEV_NORMALINCAMERASPACE;
            else
            if (dwTexGenMode == D3DTSS_TCI_CAMERASPACEPOSITION)
                pDevI->dwDeviceFlags |= D3DDEV_POSITIONINCAMERASPACE;
        }
        else
        {
            if (dwIndex >= pDevI->nTexCoord)
            {
                D3D_ERR("Texture index in a stage is greater than number of input texture coordinates");
                return DDERR_GENERIC;
            }
            dwInpTextureFormat = FVFGetTextureFormat(pDevI->dwVIDIn, dwIndex);
            dwInpTexSize = pDevI->dwTextureCoordSize[dwIndex];
            pStage->dwInpOffset = dwTextureCoordOffset[dwIndex];
        }
        pStage->dwInpCoordIndex = dwIndex;
        pStage->dwTexGenMode = dwTexGenMode;
        pStage->dwOrgStage = i;
        DWORD dwOutTexCoordSize;    // Size of the texture coord set in bytes for this stage
        if (dwTexTransform & 1)
        {
            pDevI->dwDeviceFlags |= D3DDEV_TEXTURETRANSFORM;
            pStage->pmTextureTransform = &pDevI->mTexture[i];
            dwOutTexCoordSize = GetOutTexCoordSize((DWORD*)&pDevI->tsstates[i], dwInpTexSize);
            // If we have to add or remove some coordinates we go through
            // the re-mapping path
            if (dwOutTexCoordSize != dwInpTexSize)
                pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
        }
        else
        {
            pStage->pmTextureTransform = NULL;
            dwOutTexCoordSize = dwInpTexSize;
        }
        pStage->dwTexTransformFuncIndex = MakeTexTransformFuncIndex
                                         (dwInpTexSize >> 2, dwOutTexCoordSize >> 2);
        if ((dwTexCoordUsage[dwIndex] & 0xFFFF) == 0)
        {
            // Texture coordinate set is used first time
            if (dwTexTransform & 1)
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
            dwTexCoordUsage[dwIndex] |= __USED;
        }
        else
        {
            // Texture coordinate set is used second or more time
            if (dwTexTransform & 1)
            {
                // This set is used by two texture transforms or a
                // texture transform and without it, so we have to
                // generate an additional output texture coordinate
                dwTexCoordUsage[dwIndex] |= __USED_BY_TRANSFORM;
                pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
            }
            else
            {
                if (dwTexCoordUsage[dwIndex] & __USED_BY_TRANSFORM)
                {
                    // This set is used by two texture transforms or a
                    // texture transform and without it, so we have to
                    // generate an additional output texture coordinate
                    pDevI->dwDeviceFlags |= D3DDEV_REMAPTEXTUREINDICES;
                }
                else
                if (dwTexGenMode == 0)
                {
                    // We do not have to generate new texture coord for this,
                    // we can re-use the same input texture coordinate
                    DWORD dwOutIndex = dwTexCoordUsage[dwIndex] >> 16;
                    pStage->dwOutCoordIndex = dwOutIndex;
                    goto l_NoNewOutTexCoord;
                }
            }
        }
        // If we are here, we have to generate new output texture coordinate set
        pStage->dwOutCoordIndex = dwNewIndex;
        dwTexCoordUsage[dwIndex] |= dwNewIndex << 16;
        dwOutTextureSize += dwOutTexCoordSize;
        dwOutTextureCoordSize[dwNewIndex] = dwOutTexCoordSize;
        dwOutTextureFormat |= FVFMakeTextureFormat(dwOutTexCoordSize >> 2, dwNewIndex);
        dwNewIndex++;
l_NoNewOutTexCoord:
        pDevI->dwNumTextureStages++;
        dwTexTransform >>= 1;
    }
    if (pDevI->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        // Now, when we have to do re-mapping, we have to set new output texture
        // coordinate set sizes
        for (DWORD i=0; i < pDevI->dwNumTextureStages; i++)
        {
            pDevI->dwTextureCoordSize[i] = dwOutTextureCoordSize[i];
        }
        pDevI->nOutTexCoord = dwNewIndex;
    }
    *pdwOutTextureSize = dwOutTextureSize;
    *pdwOutTextureFormat = dwOutTextureFormat;
    return D3D_OK;
}
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPDIRECT3DDEVICEI pDevI)
{
    // Set texture transforms to NULL in case when some texture coordinates
    // are not used by texture stages
    memset(pDevI->pmTexture, 0, sizeof(pDevI->pmTexture));

    for (DWORD i=0; i < pDevI->dwNumTextureStages; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStage[i];
        pDevI->pmTexture[pStage->dwInpCoordIndex] = pStage->pmTextureTransform;
    }
}
//----------------------------------------------------------------------
HRESULT CDirect3DDeviceIDP2::SetupFVFData(DWORD *pdwInpVertexSize)
{
    if (this->dwDeviceFlags & D3DDEV_FVF)
        return DIRECT3DDEVICEI::SetupFVFDataCommon(pdwInpVertexSize);
    else
        return DIRECT3DDEVICEI::SetupFVFData(pdwInpVertexSize);
}
//----------------------------------------------------------------------
// Computes the following device data
//  - dwVIDOut, based on input FVF id and device settings
//  - nTexCoord
//  - dwTextureCoordSizeTotal
//  - dwTextureCoordSize[] array, based on the input FVF id
//  - dwOutputSize, based on the output FVF id
//
// The function is called from ProcessVertices and DrawPrimitives code paths
//
// The following variables should be set in the pDevI:
//  - dwVIDIn
//
// Number of texture coordinates is set based on dwVIDIn. ValidateFVF should
// make sure that it is not greater than supported by the driver
// Last settings for dwVIDOut and dwVIDIn are saved to speed up processing
//
#undef  DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP2::SetupFVFData"

HRESULT DIRECT3DDEVICEI::SetupFVFDataCommon(DWORD *pdwInpVertexSize)
{
    HRESULT ret;
    this->dwFEFlags &= ~D3DFE_FVF_DIRTY;
    // We have to restore texture stage indices if previous primitive
    // re-mapped them
    if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
    {
        RestoreTextureStages(this);
    }

// Compute number of the input texture coordinates

    this->nTexCoord = FVF_TEXCOORD_NUMBER(this->dwVIDIn);

// Compute size of input texture coordinates

    this->dwTextureCoordSizeTotal = ComputeTextureCoordSize(this->dwVIDIn, this->dwInpTextureCoordSize);

// This size is the same for input and output FVFs in case when we do not have to
// expand number of texture coordinates
    for (DWORD i=0; i < this->nTexCoord; i++)
        this->dwTextureCoordSize[i] = this->dwInpTextureCoordSize[i];

    if (pdwInpVertexSize)
    {
        *pdwInpVertexSize = GetVertexSizeFVF(this->dwVIDIn) + this->dwTextureCoordSizeTotal;
    }

    this->nOutTexCoord = this->nTexCoord;

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        // Set up vertex pointers
        this->dwVIDOut = this->dwVIDIn;
        ComputeOutputVertexOffsets(this);
        return D3D_OK;
    }

// Compute output FVF

    this->dwVIDOut = D3DFVF_XYZRHW;
    if (this->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
    {
        this->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        // If normal present we have to compute specular and duffuse
        // Otherwise set these bits the same as input.
        // Not that normal should not be present for XYZRHW position type
        if (this->dwDeviceFlags & D3DDEV_LIGHTING)
            this->dwVIDOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
        else
            this->dwVIDOut |= this->dwVIDIn & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR);
        // Always set specular flag if fog is enabled
        if (this->rstates[D3DRENDERSTATE_FOGENABLE])
            this->dwVIDOut |= D3DFVF_SPECULAR;
        else
        // Clear specular flag if specular disabled and we do not have specular in the input
        if (!this->rstates[D3DRENDERSTATE_SPECULARENABLE] && !(this->dwVIDIn & D3DFVF_SPECULAR))
            this->dwVIDOut &= ~D3DFVF_SPECULAR;
    }

    // Compute output vertex size without texture
    this->dwOutputSize = GetVertexSizeFVF(this->dwVIDOut);

// Compute number of the output texture coordinates

    // Transform enable bits
    DWORD dwTexTransform = this->dwFlags2 & __FLAGS2_TEXTRANSFORM;

    this->dwDeviceFlags &= ~D3DDEV_TEXTURETRANSFORM;
    // When texture transform is enabled or texture coordinates are taken from
    // the vertex data, output texture coordinates could be generated. so we go
    // and evaluate texture stages
    if ((dwTexTransform && this->nTexCoord > 0) ||
        this->dwFlags2 & __FLAGS2_TEXGEN)
    {
        DWORD dwOutTextureSize;         // Used to compute output vertex size
        DWORD dwOutTextureFormat;       // Used to compute output texture FVF
        // There are texture transforms.
        // Now we find out if some of the texture coordinates are used two or more
        // times and used by a texture transform. In this case we have expand number
        // of output texture coordinates.
        ret = EvalTextureTransforms(this, dwTexTransform, &dwOutTextureSize, &dwOutTextureFormat);
        if (ret != D3D_OK)
            return ret;
        if (this->dwDeviceFlags & D3DDEV_REMAPTEXTUREINDICES)
        {
            // For ProcessVertices calls user should set texture stages and
            // wrap modes himself
            if (!(this->dwFlags & D3DPV_VBCALL))
            {
                // dwVIDIn is used to force re-compute FVF in the
                // SetTextureStageState. so we save and restore it.
                DWORD dwVIDInSaved = this->dwVIDIn;
                // Re-map indices in the texture stages and wrap modes
                DWORD dwOrgWrapModes[D3DDP_MAXTEXCOORD];
                memcpy(dwOrgWrapModes, &this->rstates[D3DRENDERSTATE_WRAP0], sizeof(dwOrgWrapModes));
                for (DWORD i=0; i < this->dwNumTextureStages; i++)
                {
                    LPD3DFE_TEXTURESTAGE pStage = &this->textureStage[i];
                    DWORD dwOutIndex = pStage->dwOutCoordIndex;
                    DWORD dwInpIndex = pStage->dwInpCoordIndex;
                    if (dwOutIndex != dwInpIndex || pStage->dwTexGenMode)
                    {
                        DWORD dwState = D3DRENDERSTATE_WRAP0 + dwOutIndex;
                        pStage->dwOrgWrapMode = dwOrgWrapModes[dwOutIndex];
                        DWORD dwValue = dwOrgWrapModes[dwInpIndex];
                        // We do not call UpdateInternaState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        this->rstates[dwState] = dwValue;
                        this->SetRenderStateI((D3DRENDERSTATETYPE)dwState, dwValue);
                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        this->SetTSSI(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwOutIndex);
                        // We do not call UpdateInternalTextureStageState because it
                        // will call ForceRecomputeFVF and we do not want this.
                        // We set some invalid value to the internal array, because otherwise
                        // a new SetTextureStageState could be filtered as redundant
                        tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = 0xFFFFFFFF;
                    }
                }
                this->dwVIDIn = dwVIDInSaved;
            }
            this->dwVIDOut |= dwOutTextureFormat;
            this->dwOutputSize += dwOutTextureSize;
            this->dwTextureCoordSizeTotal = dwOutTextureSize;
        }
        else
        {   // We do not do re-mapping but we have to make correspondence between
            // texture sets and texture transforms
            SetupTextureTransforms(this);

            //  Copy input texture formats
            this->dwVIDOut |= this->dwVIDIn & 0xFFFF0000;
            this->dwOutputSize += this->dwTextureCoordSizeTotal;
        }
    }
    else
    {
        //  Copy input texture formats
        this->dwVIDOut |= this->dwVIDIn & 0xFFFF0000;
        this->dwOutputSize += this->dwTextureCoordSizeTotal;
    }

    if (this->dwDeviceFlags & D3DDEV_DONOTSTRIPELEMENTS)
    {
        if (this->nOutTexCoord == 0 && !(this->dwFlags & D3DPV_VBCALL))
        {
            this->dwOutputSize += 2*sizeof(D3DVALUE);
            this->dwTextureCoordSize[0] = 0;
            this->dwVIDOut |= (1 << D3DFVF_TEXCOUNT_SHIFT);
        }
    }
    // Set up number of output texture coordinates
    this->dwVIDOut |= (this->nOutTexCoord << D3DFVF_TEXCOUNT_SHIFT);
    if (this->dwVIDOut & 0xFFFF0000 && this->deviceType < D3DDEVTYPE_DX7HAL)
    {
        D3D_ERR("Texture format bits in the output FVF for this device should be 0");
        return DDERR_INVALIDPARAMS;
    }

    // Set up vertex pointers
    if (!(this->dwFlags & D3DPV_VBCALL))
        UpdateGeometryLoopData(this);

    // In case if COLORVERTEX is TRUE, the vertexAlpha could be overriden
    // by vertex alpha
    this->lighting.alpha = (DWORD)this->lighting.materialAlpha;
    this->lighting.alphaSpecular = (DWORD)this->lighting.materialAlphaS;

    this->dwFEFlags |= D3DFE_VERTEXBLEND_DIRTY;

    return D3D_OK;
}

#if DBG
void CDirect3DDeviceIDP2::ValidateVertex(LPDWORD lpdwVertex)
{
    if (FVF_TRANSFORMED(dp2data.dwVertexType))
    {
        float left, right, top, bottom;
        if (dwDeviceFlags & D3DDEV_GUARDBAND)
        {
            left   = lpD3DExtendedCaps->dvGuardBandLeft;
            right  = lpD3DExtendedCaps->dvGuardBandRight;
            top    = lpD3DExtendedCaps->dvGuardBandTop;
            bottom = lpD3DExtendedCaps->dvGuardBandBottom;
        }
        else
        {
            left   = (float)m_Viewport.dwX;
            top    = (float)m_Viewport.dwY;
            right  = (float)m_Viewport.dwX + m_Viewport.dwWidth;
            bottom = (float)m_Viewport.dwY + m_Viewport.dwHeight;
        }
        if (*(float*)lpdwVertex < left || *(float*)lpdwVertex++ > right)
            DPF_ERR("X coordinate out of range!");
        if (*(float*)lpdwVertex < top || *(float*)lpdwVertex++ > bottom)
            DPF_ERR("Y coordinate out of range!");
        if (rstates[D3DRENDERSTATE_ZENABLE] ||
            rstates[D3DRENDERSTATE_ZWRITEENABLE])
        {
            // Allow a little slack for those generating triangles exactly on the
            // depth limit.  Needed for Quake.
            if (*(float*)lpdwVertex < -0.00015f || *(float*)lpdwVertex++ > 1.00015f)
                DPF_ERR("Z coordinate out of range!");
        }
        if (FVF_TEXCOORD_NUMBER(dp2data.dwVertexType) > 0)
        {
            if (*(float*)lpdwVertex <= 0 )
            {
                DPF_ERR("RHW out of range!");
            }
        }
    }
}

void CDirect3DDeviceIDP2::ValidateCommand(LPD3DHAL_DP2COMMAND lpCmd)
{
    DWORD dwTexCoordSizeDummy[8];
    DWORD dwVertexSize = GetVertexSizeFVF(dp2data.dwVertexType) + ComputeTextureCoordSize(dp2data.dwVertexType, dwTexCoordSizeDummy);
    WORD wStart, wCount;
    switch (lpCmd->bCommand)
    {
    case D3DDP2OP_TRIANGLELIST:
        {
            LPD3DHAL_DP2TRIANGLELIST pTri = (LPD3DHAL_DP2TRIANGLELIST)(lpCmd + 1);
            wStart = pTri->wVStart;
            wCount =lpCmd->wPrimitiveCount * 3;
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
        {
            LPD3DHAL_DP2TRIANGLEFAN pFan = (LPD3DHAL_DP2TRIANGLEFAN)(lpCmd + 1);
            wStart = pFan->wVStart;
            wCount = lpCmd->wPrimitiveCount + 2;
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            wCount = lpCmd->wPrimitiveCount + 2;
            for (WORD i=0; i < wCount; ++i)
            {
                ValidateVertex((LPDWORD)((LPBYTE)(lpCmd + 1) + i * dwVertexSize));
            }
        }
        // Fall through
    default:
        return;
    }
    for (WORD i = wStart; i < wStart + wCount; ++i)
    {
        if( dp2data.dwFlags & D3DHALDP2_USERMEMVERTICES )
            ValidateVertex((LPDWORD)((LPBYTE)(dp2data.lpVertices) + i * dwVertexSize));
        else
            ValidateVertex((LPDWORD)((LPBYTE)(dp2data.lpDDVertex->lpGbl->fpVidMem) + i * dwVertexSize));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\drawprim.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop
#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

#ifndef WIN95
#include <ntgdistr.h>
#endif

#define ALIGN32(x) x = ((DWORD)(x + 31)) & (~31);
//---------------------------------------------------------------------
// Handles strides and FVF
//
#undef DPF_MODNAME
#define DPF_MODNAME "D3DFE_updateExtents"

void D3DFE_updateExtents(LPDIRECT3DDEVICEI lpDevI)
{
    int i;
    D3DVECTOR *v = (D3DVECTOR*)lpDevI->position.lpvData;
    DWORD stride = lpDevI->position.dwStride;
    for (i = lpDevI->dwNumVertices; i; i--)
    {
        if (v->x < lpDevI->rExtents.x1)
            lpDevI->rExtents.x1 = v->x;
        if (v->x > lpDevI->rExtents.x2)
            lpDevI->rExtents.x2 = v->x;
        if (v->y < lpDevI->rExtents.y1)
            lpDevI->rExtents.y1 = v->y;
        if (v->y > lpDevI->rExtents.y2)
            lpDevI->rExtents.y2 = v->y;
        v = (D3DVECTOR*)((char*)v + stride);
    }
}
#if DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawPrimitive"

HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI)
{
    D3DFE_PROCESSVERTICES* data = lpDevI;
    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (!data->dwNumVertices)
    {
        D3D_ERR( "Invalid dwNumVertices in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_POINTLIST:
                break;
    case D3DPT_LINELIST:
        if (data->dwNumVertices & 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumVertices == 1)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumVertices < 3)
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumVertices % 3) != 0 )
        {
            D3D_ERR( "DrawPrimitive: bad vertex count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }
    if (lpDevI->dwNumVertices > MAX_DX6_VERTICES)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K vertices");
        return D3DERR_TOOMANYVERTICES;
    }

    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CheckDrawIndexedPrimitive"

HRESULT
CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI, DWORD dwStartVertex)
{
    D3DFE_PROCESSVERTICES *data = lpDevI;
    DWORD i;

    HRESULT ret = CheckDeviceSettings(lpDevI);
    if (ret != D3D_OK)
        return ret;
    if (data->dwNumVertices <= 0 || data->dwNumIndices <= 0)
    {
        D3D_ERR( "Invalid dwNumVertices or dwNumIndices in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if (data->dwNumVertices > 65535ul )
    {
        D3D_ERR( "DrawIndexedPrimitive vertex array > 64K" );
        return DDERR_INVALIDPARAMS;
    }

    if((data->lpwIndices==NULL) || IsBadReadPtr(data->lpwIndices,data->dwNumIndices*sizeof(WORD))) {
        D3D_ERR( "Invalid lpwIndices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    if(data->position.lpvData==NULL) {
        D3D_ERR( "Invalid lpvVertices param in DrawIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }

    switch (data->primType)
    {
    case D3DPT_LINELIST:
        if (data->dwNumIndices & 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_LINESTRIP:
        if (data->dwNumIndices == 1)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (data->dwNumIndices < 3)
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    case D3DPT_TRIANGLELIST:
        if ( (data->dwNumIndices % 3) != 0 )
        {
            D3D_ERR( "DrawIndexedPrimitive: bad index count" );
            return DDERR_INVALIDPARAMS;
        }
        break;
    default:
        D3D_ERR( "Unknown or unsupported primitive type requested of DrawIndexedPrimitive" );
        return D3DERR_INVALIDPRIMITIVETYPE;
    }
    for (i=0; i < data->dwNumIndices; i++)
    {
        if (data->lpwIndices[i] >= data->dwNumVertices)
        {
            D3D_ERR( "Invalid index value in DrawIndexedPrimitive" );
            return DDERR_INVALIDPARAMS;
        }
    }
    if (lpDevI->dwNumPrimitives > MAX_DX6_PRIMCOUNT)
    {
        D3D_ERR("D3D for DX6 cannot handle greater than 64K sized primitives");
        return D3DERR_TOOMANYPRIMITIVES;
    }
    if (lpDevI->dwNumIndices * INDEX_BATCH_SCALE < lpDevI->dwNumVertices &&
        !FVF_TRANSFORMED(lpDevI->dwVIDIn))
    {
        D3D_WARN(1, "The number of indices is much less than the number of vertices.");
        D3D_WARN(1, "This will likely be inefficient. Consider using vertex buffers.");
    }
    return D3D_OK;
}
#endif // DBG
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawPrimitive"

HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_POINTLIST:
        ret = ProcessClippedPoints(pv);
        break;
    case D3DPT_LINELIST:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedTriangleList(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedTriangleStrip(pv);
        break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedTriangleFan(pv);
        break;
    default:
        D3D_ERR( "Unknown primitive type in DrawPrimitive" );
        ret = DDERR_GENERIC;
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoDrawIndexedPrimitive"

HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv)
{
    HRESULT ret;

    if (!CheckIfNeedClipping(pv))
        return pv->DrawIndexPrim();

    // Preserve primitive type for large begin-end primitives
    // Primitive type could be changed by the clipper
    D3DPRIMITIVETYPE oldPrimType = pv->primType;
    switch (pv->primType)
    {
    case D3DPT_LINELIST:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_LINESTRIP:
        ret = ProcessClippedIndexedLine(pv);
        break;
    case D3DPT_TRIANGLELIST:
        ret = ProcessClippedIndexedTriangleList(pv);
            break;
    case D3DPT_TRIANGLEFAN:
        ret = ProcessClippedIndexedTriangleFan(pv);
        break;
    case D3DPT_TRIANGLESTRIP:
        ret = ProcessClippedIndexedTriangleStrip(pv);
        break;
    default:
        break;
    }
    ClampExtents(pv);
    pv->primType = oldPrimType;
    return ret;
}
//---------------------------------------------------------------------
//                              API calls
//---------------------------------------------------------------------

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitiveStrided(
                             D3DPRIMITIVETYPE PrimitiveType,
                             DWORD dwVertexType,
                             LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                             DWORD dwNumVertices,
                             DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
    //note: this check should be done in retail as well as dbg build
        if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
            return D3DERR_INVALIDVERTEXTYPE;
        this->primType = PrimitiveType;
        this->position = lpDrawData->position;
        this->normal = lpDrawData->normal;
        this->diffuse = lpDrawData->diffuse;
        this->specular = lpDrawData->specular;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags;
        if (this->dwVIDIn != dwVertexType || !(this->dwDeviceFlags & D3DDEV_STRIDE))
        {
            this->dwDeviceFlags |= D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = this->SetupFVFData(NULL);
            if (ret != D3D_OK)
                return ret;
        }
        for (DWORD i=0; i < this->nTexCoord; i++)
            this->textures[i] = lpDrawData->textureCoords[i];

        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawPrimitive(this);

        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive();
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}   // end of DrawPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveStrided"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitiveStrided(
                                 D3DPRIMITIVETYPE PrimitiveType,
                                 DWORD dwVertexType,
                                 LPD3DDRAWPRIMITIVESTRIDEDDATA lpDrawData,
                                 DWORD dwNumVertices,
                                 LPWORD lpwIndices,
                                 DWORD dwNumIndices,
                                 DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.
    
#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVESTRIDED,PrimitiveType,dwVertexType);
#endif
        //note: this check should be done in retail as well as dbg build
        if((dwVertexType & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
            return D3DERR_INVALIDVERTEXTYPE;
        this->primType = PrimitiveType;
        this->position = lpDrawData->position;
        this->normal = lpDrawData->normal;
        this->diffuse = lpDrawData->diffuse;
        this->specular = lpDrawData->specular;
        this->dwNumVertices = dwNumVertices;
        this->lpwIndices = lpwIndices;
        this->dwNumIndices = dwNumIndices;
        this->dwFlags = dwFlags;
        if (this->dwVIDIn != dwVertexType || !(this->dwDeviceFlags & D3DDEV_STRIDE))
        {
            this->dwDeviceFlags |= D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = this->SetupFVFData(NULL);
            if (ret != D3D_OK)
                return ret;
        }
        for (DWORD i=0; i < this->nTexCoord; i++)
            this->textures[i] = lpDrawData->textureCoords[i];
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}   // end of DrawIndexedPrimitiveStrided()
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitive3"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif

        /* This stuff is mandatory for the call */
        this->primType = PrimitiveType;
        this->position.lpvData = lpvVertices;
        this->dwNumVertices = dwNumVertices;
        this->dwFlags = dwFlags;
        /* This stuff depends upon the vertex type */
        if (this->dwVIDIn != dwVertexType || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = SetupFVFData(&this->position.dwStride);
            if (ret != D3D_OK)
            {
                return ret;
            }
        }
        GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive();
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Direct3DDevice::DrawIndexedPrimitive"

HRESULT D3DAPI
DIRECT3DDEVICEI::DrawIndexedPrimitive(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT ret = D3D_OK;

    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
        // Mandatory part
        this->primType = PrimitiveType;
        this->dwNumVertices = dwNumVertices;
        this->lpwIndices = lpwIndices;
        this->dwNumIndices = dwNumIndices;
        this->dwFlags = dwFlags;
        this->position.lpvData = lpvVertices;

        // Stuff that depends upon dwVIDIn
        if (this->dwVIDIn != dwVertexType || this->dwDeviceFlags & D3DDEV_STRIDE)
        {
            this->dwDeviceFlags &= ~D3DDEV_STRIDE;
            this->dwVIDIn  = dwVertexType;
            ret = SetupFVFData(&this->position.dwStride);
            if (ret != D3D_OK)
            {
                return ret;
            }
        }
        GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives and update stats

#if DBG
        ret = CheckDrawIndexedPrimitive(this);
        if (ret != D3D_OK)
        {
            return ret;
        }
#endif
        return this->ProcessPrimitive(__PROCPRIMOP_INDEXEDPRIM);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}

#ifdef VTABLE_HACK
//----------------------------------------------------------------------
// Dedicated DrawPrimitive Implementation for TL vertex case
// Assumptions:
// No clipping
// No extents update
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveTL"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawPrimitiveTL(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        dwNumVertices >= LOWVERTICESNUMBER)
    {
        VtblDrawPrimitiveDefault();
        return DrawPrimitive(PrimitiveType, dwVertexType, lpvVertices, dwNumVertices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = dwFlags;
    this->dwNumVertices = dwNumVertices;
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
#if DBG
    this->position.lpvData = lpvVertices;
    ret = CheckDrawPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    DWORD vertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (vertexPoolSize > this->TLVbuf_GetSize())
    {
//        try
//        {
            if (this->TLVbuf_Grow(vertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
/*        }
        catch (HRESULT ret)
        {
            return ret;
        }
*/    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    memcpy(this->TLVbuf_GetAddress(), lpvVertices, vertexPoolSize);
//    try
//    {
        ret = this->DrawPrim();
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }
*/
    this->TLVbuf_Base() += vertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
//----------------------------------------------------------------------
// Dedicated DrawIndexedPrimitive Implementation for TL vertex case
// Assumptions:
// No clipping
// No extents update
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveTL"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawIndexedPrimitiveTL(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        dwNumVertices >= LOWVERTICESNUMBER)
    {
        VtblDrawIndexedPrimitiveDefault();
        return DrawIndexedPrimitive(PrimitiveType, dwVertexType, lpvVertices, 
            dwNumVertices, lpwIndices, dwNumIndices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = dwFlags;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->dwNumVertices = dwNumVertices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
#if DBG
    this->position.lpvData = lpvVertices;
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    DWORD vertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (vertexPoolSize > this->TLVbuf_GetSize())
    {
//        try
//        {
            if (this->TLVbuf_Grow(vertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
/*        }
        catch (HRESULT ret)
        {
            return ret;
        }
*/    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    memcpy(this->TLVbuf_GetAddress(), lpvVertices, vertexPoolSize);
//    try
//    {
        ret = this->DrawIndexPrim();
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }
*/
    this->TLVbuf_Base() += vertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
//----------------------------------------------------------------------
// Dedicated DrawPrimitive Implementation for non-TL vertex case
// Assumptions:
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveFE"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawPrimitiveFE(D3DPRIMITIVETYPE PrimitiveType,
                               DWORD dwVertexType,
                               LPVOID lpvVertices,
                               DWORD dwNumVertices,
                               DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
    if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
        return DDERR_INVALIDPARAMS;
    Profile(PROF_DRAWPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        this->dwFEFlags & D3DFE_FRONTEND_DIRTY)
    {
        VtblDrawPrimitiveDefault();
        return DrawPrimitive(PrimitiveType, dwVertexType, lpvVertices, dwNumVertices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = this->dwLastFlags | dwFlags;
    this->dwNumVertices = dwNumVertices;
    this->position.lpvData = lpvVertices;
#if DBG
    GetNumPrim(this, dwNumVertices); // Calculate dwNumPrimitives
    ret = CheckDrawPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
    {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, true) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
    }
    if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
    {
        if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
        {
            D3D_ERR( "Could not grow clip buffer" );
            ret = DDERR_OUTOFMEMORY;
            return ret;
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    this->lpvOut = this->TLVbuf_GetAddress();
//    try
//    {
        switch (this->primType)
        {
        case D3DPT_POINTLIST:
            this->dwNumPrimitives = dwNumVertices;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINELIST:
            this->dwNumPrimitives = dwNumVertices >> 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_LINESTRIP:
            this->dwNumPrimitives = dwNumVertices - 1;
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
            break;
        case D3DPT_TRIANGLEFAN:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleFan(this);
            break;
        case D3DPT_TRIANGLESTRIP:
            this->dwNumPrimitives = dwNumVertices - 2;
            ret = this->pGeometryFuncs->ProcessTriangleStrip(this);
            break;
        case D3DPT_TRIANGLELIST:
    #ifdef _X86_
            {
                DWORD tmp;
                __asm
                {
                    mov  eax, 0x55555555    // fractional part of 1.0/3.0
                    mul  dwNumVertices
                    add  eax, 0x80000000    // Rounding
                    adc  edx, 0
                    mov  tmp, edx
                }
                this->dwNumPrimitives = tmp;
            }
    #else
            this->dwNumPrimitives = dwNumVertices / 3;
    #endif
            ret = this->pGeometryFuncs->ProcessTriangleList(this);
            break;
        }
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }*/
    D3DFE_UpdateClipStatus(this);
    this->TLVbuf_Base() += this->dwVertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
//----------------------------------------------------------------------
// Dedicated DrawIndexedPrimitive Implementation for non-TL vertex case
// Assumptions:
// Single threaded app
// No state change since last call
// no FVF change since last call
//
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveFE"

HRESULT D3DAPI
CDirect3DDeviceIDP2::DrawIndexedPrimitiveFE(D3DPRIMITIVETYPE PrimitiveType,
                                      DWORD  dwVertexType,
                                      LPVOID lpvVertices, DWORD dwNumVertices,
                                      LPWORD lpwIndices, DWORD dwNumIndices,
                                      DWORD dwFlags)
{
    HRESULT        ret;
#if DBG
        if (ValidateFVF(dwVertexType) != D3D_OK || !IsDPFlagsValid(dwFlags))
            return DDERR_INVALIDPARAMS;
        Profile(PROF_DRAWINDEXEDPRIMITIVEDEVICE3,PrimitiveType,dwVertexType);
#endif
    /* Make sure we can use the fast path */
    if (this->dwVIDIn != dwVertexType || 
        this->dwDeviceFlags & D3DDEV_STRIDE || 
        this->dwFEFlags & D3DFE_FRONTEND_DIRTY)
    {
        VtblDrawIndexedPrimitiveDefault();
        return DrawIndexedPrimitive(PrimitiveType, dwVertexType, lpvVertices, 
            dwNumVertices, lpwIndices, dwNumIndices, dwFlags);
    }
    /* This stuff is mandatory for the call */
    this->primType = PrimitiveType;
    this->dwFlags = this->dwLastFlags | dwFlags;
    this->lpwIndices = lpwIndices;
    this->dwNumIndices = dwNumIndices;
    this->dwNumVertices = dwNumVertices;
    this->position.lpvData = lpvVertices;
    GetNumPrim(this, dwNumIndices); // Calculate dwNumPrimitives
#if DBG
    ret = CheckDrawIndexedPrimitive(this);
    if (ret != D3D_OK)
    {
        return ret;
    }
#endif

    this->dwVertexPoolSize = dwNumVertices * this->dwOutputSize;
    if (this->dwVertexPoolSize > this->TLVbuf_GetSize())
    {
//         try
//         {
            if (this->TLVbuf_Grow(this->dwVertexPoolSize, 
                (this->dwDeviceFlags & D3DDEV_DONOTCLIP)!=0) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
//         }
//         catch (HRESULT ret)
//         {
//             return ret;
//         }
    }
    if (dwNumVertices * sizeof(D3DFE_CLIPCODE) > this->HVbuf.GetSize())
    {
        if (this->HVbuf.Grow(dwNumVertices * sizeof(D3DFE_CLIPCODE)) != D3D_OK)
        {
            D3D_ERR( "Could not grow clip buffer" );
            ret = DDERR_OUTOFMEMORY;
            return ret;
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }
    this->dwVertexBase = this->dwDP2VertexCount;
    DDASSERT(this->dwVertexBase < MAX_DX6_VERTICES);
    this->dwDP2VertexCount = this->dwVertexBase + dwNumVertices;
    this->lpvOut = this->TLVbuf_GetAddress();
//    try
//    {
        ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
/*    }
    catch (HRESULT ret)
    {
        return ret;
    }*/
    D3DFE_UpdateClipStatus(this);
    this->TLVbuf_Base() += this->dwVertexPoolSize;
    DDASSERT(TLVbuf_base <= TLVbuf_size);
    DDASSERT(TLVbuf_base == this->dwDP2VertexCount * this->dwOutputSize);
    return ret;
}
#endif
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DIRECT3DDEVICEI::ComputeSphereVisibility"

HRESULT D3DAPI
DIRECT3DDEVICEI::ComputeSphereVisibility(LPD3DVECTOR lpCenters,
                                         LPD3DVALUE lpRadii,
                                         DWORD dwNumSpheres,
                                         DWORD dwFlags,
                                         LPDWORD lpdwReturnValues)
{
    try
    {
        CLockD3DMT lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock.

#if DBG
        if (dwFlags != 0 || dwNumSpheres == 0 ||
            IsBadWritePtr(lpdwReturnValues, dwNumSpheres * sizeof(DWORD)) ||
            IsBadWritePtr(lpRadii, dwNumSpheres * sizeof(D3DVALUE)) ||
            IsBadWritePtr(lpCenters, dwNumSpheres * sizeof(LPD3DVECTOR)))
        {
            return DDERR_INVALIDPARAMS;
        }
#endif

        this->dwFlags = 0;
        if (this->dwFEFlags & (D3DFE_TRANSFORM_DIRTY | D3DFE_CLIPPLANES_DIRTY))
        {
            DoUpdateState(this);
        }
        return this->pGeometryFuncs->ComputeSphereVisibility(this,
                                                              lpCenters,
                                                              lpRadii,
                                                              dwNumSpheres,
                                                              dwFlags,
                                                              lpdwReturnValues);
    }
    catch (HRESULT ret)
    {
        return ret;
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ID3DFE_PVFUNCS::ComputeSphereVisibility"

HRESULT
D3DFE_PVFUNCS::ComputeSphereVisibility(LPD3DFE_PROCESSVERTICES pv,
                                       LPD3DVECTOR lpCenters,
                                       LPD3DVALUE lpRadii,
                                       DWORD dwNumSpheres,
                                       DWORD dwFlags,
                                       LPDWORD lpdwReturnValues)
{
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);

    CD3DFPstate D3DFPstate;  // Sets optimal FPU state for D3D.

    for (DWORD i=0; i < dwNumSpheres; i++)
    {
        const D3DVALUE x = lpCenters[i].x;
        const D3DVALUE y = lpCenters[i].y;
        const D3DVALUE z = lpCenters[i].z;
        const D3DVALUE r = lpRadii[i];
        const D3DVALUE xmin = x-r;
        const D3DVALUE ymin = y-r;
        const D3DVALUE zmin = z-r;
        const D3DVALUE xmax = x+r;
        const D3DVALUE ymax = y+r;
        const D3DVALUE zmax = z+r;

        D3DVECTOR v[8] = 
        {
            {xmin, ymin, zmin},
            {xmax, ymin, zmin},
            {xmin, ymax, zmin},
            {xmax, ymax, zmin},
            {xmin, ymin, zmax},
            {xmax, ymin, zmax},
            {xmin, ymax, zmax},
            {xmax, ymax, zmax}
        };
        DWORD dwClipUnion =0;
        DWORD dwClipIntersection = ~0;
        lpDevI->CheckClipStatus((D3DVALUE*)v, sizeof(D3DVECTOR), 8, 
                                 &dwClipUnion, &dwClipIntersection);

        lpdwReturnValues[i] = dwClipUnion +  (dwClipIntersection << 12);
    }
    return D3D_OK;
}
/*
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ID3DFE_PVFUNCS::ComputeSphereVisibility"

HRESULT
D3DFE_PVFUNCS::ComputeSphereVisibility(LPD3DFE_PROCESSVERTICES pv,
                                       LPD3DVECTOR lpCenters,
                                       LPD3DVALUE lpRadii,
                                       DWORD dwNumSpheres,
                                       DWORD dwFlags,
                                       LPDWORD lpdwReturnValues)
{
    LPDIRECT3DDEVICEI lpDevI = static_cast<LPDIRECT3DDEVICEI>(pv);
    HRESULT ret = D3DERR_INVALIDMATRIX;

#define transform lpDevI->transform

    if (pv->dwFlags & D3DPV_FRUSTUMPLANES_DIRTY)
    {
        transform.dwFlags &= ~D3DTRANS_VALIDFRUSTUM;
        if (Inverse4x4((D3DMATRIX*)&lpDevI->mCTM,
                       (D3DMATRIX*)&transform.mCTMI))
        {
            D3D_ERR("Cannot invert current (World X View) matrix.");
            return ret;
        }
        // Transform the following clipping volume points to the model space by
        // multiplying by inverse CTM
        //
        // v1 = { 0, 0, 0, 1};
        // v2 = { 1, 0, 0, 1};
        // v3 = { 1, 1, 0, 1};
        // v4 = { 0, 1, 0, 1};
        // v5 = { 0, 0, 1, 1};
        // v6 = { 1, 0, 1, 1};
        // v7 = { 0, 1, 1, 1};
        //
        // We do it manually to speed up
        //
        D3DVECTORH v1 = {transform.mCTMI._41,
                         transform.mCTMI._42,
                         transform.mCTMI._43,
                         transform.mCTMI._44};
        D3DVECTORH v2 = {transform.mCTMI._11 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._44};
        D3DVECTORH v3 = {transform.mCTMI._11 + transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v4 = {transform.mCTMI._21 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._44};
        D3DVECTORH v5 = {transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v6 = {transform.mCTMI._11 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._12 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._13 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._14 + transform.mCTMI._34 + transform.mCTMI._44};
        D3DVECTORH v7 = {transform.mCTMI._21 + transform.mCTMI._31 + transform.mCTMI._41,
                         transform.mCTMI._22 + transform.mCTMI._32 + transform.mCTMI._42,
                         transform.mCTMI._23 + transform.mCTMI._33 + transform.mCTMI._43,
                         transform.mCTMI._24 + transform.mCTMI._34 + transform.mCTMI._44};

        // Convert vectors from homogeneous to 3D
        if (Vector4to3D(&v1))
            goto exit;
        if (Vector4to3D(&v2))
            goto exit;
        if (Vector4to3D(&v3))
            goto exit;
        if (Vector4to3D(&v4))
            goto exit;
        if (Vector4to3D(&v5))
            goto exit;
        if (Vector4to3D(&v6))
            goto exit;
        if (Vector4to3D(&v7))
            goto exit;
        // Build frustum planes
        // Left
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v4, (D3DVECTOR*)&v5, &transform.frustum[0]))
            goto exit;
        // Right
        if (MakePlane((D3DVECTOR*)&v2, (D3DVECTOR*)&v6, (D3DVECTOR*)&v3, &transform.frustum[1]))
            goto exit;
        // Top
        if (MakePlane((D3DVECTOR*)&v4, (D3DVECTOR*)&v3, (D3DVECTOR*)&v7, &transform.frustum[2]))
            goto exit;
        // Bottom
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v5, (D3DVECTOR*)&v2, &transform.frustum[3]))
            goto exit;
        // Near
        if (MakePlane((D3DVECTOR*)&v1, (D3DVECTOR*)&v2, (D3DVECTOR*)&v3, &transform.frustum[4]))
            goto exit;
        // Far
        if (MakePlane((D3DVECTOR*)&v6, (D3DVECTOR*)&v5, (D3DVECTOR*)&v7, &transform.frustum[5]))
            goto exit;

        transform.dwFlags |= D3DTRANS_VALIDFRUSTUM;
    }

    if (transform.dwFlags & D3DTRANS_VALIDFRUSTUM)
    {
        // Now we can check the spheres against the clipping planes

        for (DWORD i=0; i < dwNumSpheres; i++)
        {
            lpdwReturnValues[i] = CheckSphere(lpDevI, &lpCenters[i], lpRadii[i]);
        }
        return D3D_OK;
    }

exit:
    D3D_ERR("Non-orthogonal (world X view) matrix");
    return ret;
#undef transform
}
//---------------------------------------------------------------------
DWORD visResults[6][2] =
{
    D3DVIS_INTERSECT_LEFT   ,
    D3DVIS_OUTSIDE_LEFT     ,
    D3DVIS_INTERSECT_RIGHT  ,
    D3DVIS_OUTSIDE_RIGHT    ,
    D3DVIS_INTERSECT_TOP    ,
    D3DVIS_OUTSIDE_TOP      ,
    D3DVIS_INTERSECT_BOTTOM ,
    D3DVIS_OUTSIDE_BOTTOM   ,
    D3DVIS_INTERSECT_NEAR   ,
    D3DVIS_OUTSIDE_NEAR     ,
    D3DVIS_INTERSECT_FAR    ,
    D3DVIS_OUTSIDE_FAR
};
//---------------------------------------------------------------------
DWORD CheckSphere(LPDIRECT3DDEVICEI lpDevI, LPD3DVECTOR center, D3DVALUE radius)
{
    DWORD result = 0;
    for (int i=0; i < 6; i++)
    {
        // Compute a distance from the center to the plane
        D3DVALUE d = lpDevI->transform.frustum[i].x*center->x +
                     lpDevI->transform.frustum[i].y*center->y +
                     lpDevI->transform.frustum[i].z*center->z +
                     lpDevI->transform.frustum[i].w;
        if (d + radius < 0)
            result |= visResults[i][1];  // Outside
        else
        if (d - radius < 0)
            result |= visResults[i][0];  // Intersect
    }
    if (result & (D3DVIS_OUTSIDE_LEFT   |
                  D3DVIS_OUTSIDE_RIGHT  |
                  D3DVIS_OUTSIDE_TOP    |
                  D3DVIS_OUTSIDE_BOTTOM |
                  D3DVIS_OUTSIDE_NEAR   |
                  D3DVIS_OUTSIDE_FAR))
    {
        result |= D3DVIS_OUTSIDE_FRUSTUM;
    }
    else
    if (result)
        result |= D3DVIS_INTERSECT_FRUSTUM;

    return result;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\dpoldhal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpoldhal.c
 *  Content:    DrawPrimitive implementation for legacy (DX2) HALs
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#ifdef WIN95

#include "drawprim.hpp"
#include "clipfunc.h"
#include "commdrv.hpp"
#include "d3dfei.h"

extern D3DLINE LineListPrecomp[];
extern D3DLINE LineStripPrecomp[];
extern D3DTRIANGLE TriangleListPrecomp[];
extern D3DTRIANGLE TriangleStripPrecomp[];
extern D3DTRIANGLE TriangleFanPrecomp[];

#define BFCULLTEST_TVertTri(TLV0,TLV1,TLV2) (((TLV1).sx-(TLV0).sx)*((TLV2).sy-(TLV0).sy) -  \
                                         ((TLV2).sx-(TLV0).sx)*((TLV1).sy-(TLV0).sy))

#define ISCULLED(lpDevI, CullTestRes) ((CullTestRes==0.0) ||   \
                                   ((lpDevI->rstates[D3DRENDERSTATE_CULLMODE]==D3DCULL_CW) ^ (CullTestRes < 0.0)))
//---------------------------------------------------------------------
void WaitForFlip( LPDIRECT3DDEVICEI lpDevI )
{
    if (! (lpDevI->lpD3DHALGlobalDriverData->hwCaps.dwDevCaps  & D3DDEVCAPS_CANRENDERAFTERFLIP) )
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpLcl = ((LPDDRAWI_DDRAWSURFACE_INT) lpDevI->lpDDSTarget)->lpLcl;

        if (lpLcl->ddsCaps.dwCaps & DDSCAPS_FLIP) {
            HRESULT ret;
            D3D_INFO(5, "Waiting for flip");
            do {
                ret = lpDevI->lpDDSTarget->GetFlipStatus(DDGFS_ISFLIPDONE);
            } while (ret == DDERR_WASSTILLDRAWING);
        }
    }
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesHW"

HRESULT CDirect3DDeviceIHW::FlushStates(bool bWithinPrimitive)
{
    DWORD i;

    LPDWORD lpScan = (LPDWORD) this->lpwDPBuffer;
    LPD3DTRIANGLE lpTriScan = (LPD3DTRIANGLE) this->lpHWTris;

    DWORD dwRet;
    D3DHAL_RENDERSTATEDATA StateData;
    D3DHAL_RENDERPRIMITIVEDATA PrimitiveData;
    CDDSurfaceFromMem TLBuffer(NULL);
    CDDSurfaceFromMem ExeBuffer(lpTriScan);

    if (this->dwHWOffset == 0)    return D3D_OK;
    this->dwHWOffset = 0; //zeroed to prevent re-enter by drivers's locking surfaces

    ++m_qwBatch;
    // So that currently bound textures get rebatched
    for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
    {
        LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
        if (NULL != lpTexI)
        {
            if(lpTexI->lpDDS != NULL)
            {
                BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
            }
        }
    }

    // Legacy HAL, therefore we have to wait
    // until the render target has flipped.
    WaitForFlip(this);

    // Pick up Win16 lock
    LOCK_HAL( dwRet, this );
    LOCK_DIBENGINE(dwRet, this);
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE

    memset(&StateData, 0, sizeof(StateData) );
    memset(&PrimitiveData, 0, sizeof(PrimitiveData) );

    // dwHWNumCounts is the number of recorded structs with
    // primitives attached.
    for (i = 0; i < this->dwHWNumCounts+1; i += 1)
    {


        if ( this->lpHWCounts[i].wNumStateChanges )
        {
            TLBuffer.SetBits(lpScan);

            StateData.dwhContext = this->dwhContext;
            StateData.dwOffset = 0;
            StateData.dwCount = this->lpHWCounts[i].wNumStateChanges;
            StateData.lpExeBuf = TLBuffer.GetSurface();
            dwRet = (*this->lpD3DHALCallbacks->RenderState)(&StateData);
            // No provision for NOT_HANDLED

            lpScan += 2*this->lpHWCounts[i].wNumStateChanges;
            lpScan = (LPDWORD) ( (((DWORD) lpScan) + 31) & ~31);
        }

        if ( this->lpHWCounts[i].wNumVertices )
        {

            TLBuffer.SetBits((LPD3DTLVERTEX) this->lpwDPBuffer);
            ExeBuffer.SetBits(lpTriScan);

            PrimitiveData.dwhContext = this->dwhContext;
            PrimitiveData.dwOffset = 0;
            PrimitiveData.dwStatus = 0;
            PrimitiveData.lpExeBuf = ExeBuffer.GetSurface();
            PrimitiveData.dwTLOffset = 0;
            PrimitiveData.lpTLBuf = TLBuffer.GetSurface();
            PrimitiveData.diInstruction.bOpcode = D3DOP_TRIANGLE;
            PrimitiveData.diInstruction.bSize = sizeof(D3DTRIANGLE);
            PrimitiveData.diInstruction.wCount = (WORD) this->lpHWCounts[i].wNumTriangles;
            dwRet = (*this->lpD3DHALCallbacks->RenderPrimitive)(&PrimitiveData);
            // No provision for NOT_HANDLED
            lpScan = (LPDWORD)(((LPD3DTLVERTEX) lpScan) + this->lpHWCounts[i].wNumVertices);
            lpTriScan += this->lpHWCounts[i].wNumTriangles;
        }
    }
    UNLOCK_DIBENGINE( this );
    UNLOCK_HAL( this );
    this->dwHWTriIndex = 0;
    this->dwHWNumCounts = 0;
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
        return  D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveLegacyHalCall"

HRESULT
DrawPrimitiveLegacyHalCall(CDirect3DDeviceIHW * lpDevI,
                           LPD3DTLVERTEX lpVertices, LPVOID lpvData,
                           LPD3DINSTRUCTION ins, DWORD dwNumVertices, D3DVERTEXTYPE VtxType)
{
    DWORD dwRet;
    CDDSurfaceFromMem TLBuffer(lpVertices);
    CDDSurfaceFromMem ExeBuffer(lpvData);
    D3DHAL_RENDERPRIMITIVEDATA rdata;

    memset(&rdata, 0, sizeof(rdata) );

    rdata.dwhContext = lpDevI->dwhContext;
    rdata.dwOffset = 0;
    rdata.dwStatus = 0;
    rdata.lpExeBuf = ExeBuffer.GetSurface();
    rdata.dwTLOffset = 0;
    rdata.lpTLBuf = TLBuffer.GetSurface();
    rdata.diInstruction = *ins;
#ifndef WIN95
    if((dwRet = CheckContextSurface(lpDevI)) != D3D_OK)
    {
        return (dwRet);
    }
#endif //WIN95
#if _D3D_FORCEDOUBLE
    CD3DForceFPUDouble  ForceFPUDouble(lpDevI);
#endif  //_D3D_FORCEDOUBLE
    CALL_HALONLY(dwRet, lpDevI, RenderPrimitive, &rdata);
    if (dwRet != DDHAL_DRIVER_HANDLED)
    {
        D3D_ERR ( "Driver not handled in DrawPrimitive" );
        // Need sensible return value in this case,
        // currently we return whatever the driver stuck in here.
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "FillLegacyHalIndices"

void
FillLegacyHalIndices(D3DPRIMITIVETYPE PrimitiveType, LPVOID lpOut,
                     LPWORD lpwIndices, DWORD dwNumPrimitives)
{
    LPD3DLINE lpTmpLines;
    LPD3DTRIANGLE lpTmpTris;
    DWORD i;
    WORD wIndex = 0;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex++];
        }
        break;
    case D3DPT_LINESTRIP:
        lpTmpLines = (LPD3DLINE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpLines[i].v1 = lpwIndices[wIndex++];
            lpTmpLines[i].v2 = lpwIndices[wIndex];
        }
        break;
    case D3DPT_TRIANGLELIST:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }

        break;
    case D3DPT_TRIANGLESTRIP:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        for (i = 0; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpwIndices[wIndex++];
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpwIndices[wIndex++];
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            i++;
            if (i<dwNumPrimitives)
            {
                lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
                lpTmpTris[i].v2 = lpwIndices[wIndex--];
                lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
                lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        lpTmpTris = (LPD3DTRIANGLE) lpOut;
        lpTmpTris[0].v3 = lpwIndices[wIndex++];
        lpTmpTris[0].v1 = lpwIndices[wIndex++];
        lpTmpTris[0].v2 = lpwIndices[wIndex++];
        lpTmpTris[0].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        for (i = 1; i < dwNumPrimitives; i += 1)
        {
            lpTmpTris[i].v1 = lpTmpTris[i-1].v2;
            lpTmpTris[i].v2 = lpwIndices[wIndex++];
            lpTmpTris[i].v3 = lpTmpTris[i-1].v3;
            lpTmpTris[i].wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
        }
        break;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrimitiveInBatchesHW"

HRESULT
DrawPrimitiveInBatchesHW(CDirect3DDeviceIHW * lpDevI, D3DPRIMITIVETYPE PrimitiveType, D3DVERTEXTYPE VertexType, LPD3DTLVERTEX lpVertices, DWORD dwNumPrimitives)
{
    DWORD i;
    D3DTLVERTEX tmpV;
    LPD3DTLVERTEX lpFirstVertex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, LineStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleListPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleStripPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first vertex to spoof the driver
        lpFirstVertex = lpVertices;
        tmpV = lpVertices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpV = *lpVertices;
            *lpVertices = *lpFirstVertex;
            ret = DrawPrimitiveLegacyHalCall(lpDevI, lpVertices, TriangleFanPrecomp, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpVertices = tmpV;
            lpVertices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrimitiveInBatchesHW"

HRESULT
CDirect3DDeviceIHW::DrawIndexedPrimitiveInBatchesHW(
                                D3DPRIMITIVETYPE PrimitiveType,
                                D3DVERTEXTYPE VertexType,
                                LPD3DTLVERTEX lpVertices,
                                DWORD dwNumPrimitives,
                                LPWORD lpwIndices)
{
    DWORD i;
    WORD tmpW;
    LPWORD lpFirstIndex;
    D3DINSTRUCTION ins;
    HRESULT ret;

    switch (PrimitiveType)
    {
    case D3DPT_LINELIST:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount*2;
        }
        break;
    case D3DPT_LINESTRIP:
        ins.bOpcode = D3DOP_LINE;
        ins.bSize = sizeof(D3DLINE);
        for (i = 0; i < dwNumPrimitives; i += dwLineBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwLineBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpVertices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLELIST:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += 3*ins.wCount;
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            lpwIndices += ins.wCount;
        }
        break;
    case D3DPT_TRIANGLEFAN:
        ins.bOpcode = D3DOP_TRIANGLE;
        ins.bSize = sizeof(D3DTRIANGLE);
        // Save the first index to spoof the driver
        lpFirstIndex = lpwIndices;
        tmpW = lpwIndices[0];
        for (i = 0; i < dwNumPrimitives; i += dwD3DTriBatchSize)
        {
            ins.wCount = (WORD)min(dwNumPrimitives-i, dwD3DTriBatchSize);
            tmpW = *lpwIndices;
            *lpwIndices = *lpFirstIndex;
            FillLegacyHalIndices(PrimitiveType, this->wTriIndex, lpwIndices, ins.wCount);
            ret = DrawPrimitiveLegacyHalCall(this, lpVertices, this->wTriIndex, &ins, 0, VertexType);
            if (ret)
                return ret;
            *lpwIndices = tmpW;
            lpwIndices += ins.wCount;
        }
        break;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawIndexPrim()
{
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;
    DWORD dwNumVertices = this->dwNumVertices;
    DWORD dwNumPrimitives = this->dwNumPrimitives;
    WORD *lpwIndices = this->lpwIndices;
    HRESULT ret;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, then just batch them.
    if ( (this->primType == D3DPT_TRIANGLELIST ||
          this->primType == D3DPT_TRIANGLEFAN ||
          this->primType == D3DPT_TRIANGLESTRIP) &&
          this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut;
        DWORD i,dwTriOutCount,iV0,iV1,iV2;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset + dwNumVertices*sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + dwNumPrimitives >= dwHWMaxTris )
        {
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                      // Release in the destructor
            ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpwDPBuffer + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)lpvBatchAddress;
        }
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));

        dwTriOutCount=0;  bDoBFCulling=(this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0+=3,iV1+=3,iV2+=3)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLEFAN:
            iV0=1;  iV1=2; iV2=0;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        continue;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;
            }
            break;

        case D3DPT_TRIANGLESTRIP:
            iV0=0;  iV1=1;  iV2=2;
            for (i = 0; i < dwNumPrimitives; i++,iV0++,iV1++,iV2++)
            {
                if(bDoBFCulling)
                {
                    fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV1]],lpVertices[lpwIndices[iV2]]);
                    if(ISCULLED(this, fCullTestResult))
                        goto SecondTri;
                }

                lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                lpTriOut->v2 = lpwIndices[iV1] + wVertexOffset;
                lpTriOut->v3 = lpwIndices[iV2] + wVertexOffset;
                lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                lpTriOut += 1;
                dwTriOutCount++;

            SecondTri:

                i++;
                if(i < dwNumPrimitives)
                {
                    iV0++,iV1++,iV2++;

                    // swap vtx order for every 2nd tri

                    if(bDoBFCulling)
                    {
                        fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpwIndices[iV0]],lpVertices[lpwIndices[iV2]],lpVertices[lpwIndices[iV1]]);
                        if(ISCULLED(this, fCullTestResult))
                            continue;
                    }

                    lpTriOut->v1 = lpwIndices[iV0] + wVertexOffset;
                    lpTriOut->v2 = lpwIndices[iV2] + wVertexOffset;
                    lpTriOut->v3 = lpwIndices[iV1] + wVertexOffset;
                    lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
                    lpTriOut += 1;
                    dwTriOutCount++;
                }
            }
            break;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD) dwNumVertices;

        this->dwHWOffset += dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawIndexPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        ret = DrawIndexedPrimitiveInBatchesHW(this->primType,
                                              D3DVT_TLVERTEX, lpVertices,
                                              dwNumPrimitives, this->lpwIndices);
        return ret;
    }
}
//---------------------------------------------------------------------
// This is a call for a clipped primitive
//
HRESULT CDirect3DDeviceIHW::DrawPrim()
{
    D3DPOINT TmpPoint;
    D3DINSTRUCTION ins = {D3DOP_POINT, sizeof(D3DPOINT), 1};
    LPD3DTLVERTEX lpVertices = (LPD3DTLVERTEX)this->lpvOut;

    // Do we need to map new texture stage operations to DX5 renderstates?
    if(this->dwFEFlags & D3DFE_MAP_TSS_TO_RS) {
        MapTSSToRS();
        this->dwFEFlags &= ~D3DFE_MAP_TSS_TO_RS; // Reset request bit
    }
    if(this->dwFEFlags & D3DFE_NEED_TEXTURE_UPDATE)
    {
        HRESULT ret = UpdateTextures();
        if(ret != D3D_OK)
        {
            D3D_ERR("UpdateTextures failed. Device probably doesn't support current texture (check return code).");
            return ret;
        }
        this->dwFEFlags &= ~D3DFE_NEED_TEXTURE_UPDATE;
    }

    // If the number of vertices is small, and none require
    // clipping, then just batch them.
    if ((this->primType == D3DPT_TRIANGLELIST ||
         this->primType == D3DPT_TRIANGLEFAN ||
         this->primType == D3DPT_TRIANGLESTRIP) &&
         this->dwNumVertices < dwHWFewVertices)
    {
        LPD3DTRIANGLE lpTriOut, lpTriPrim;
        DWORD i, dwTriOutCount;
        WORD wVertexOffset;
        float fCullTestResult;
        BOOL bDoBFCulling;

        // Pad the offset, if needed.  But first save the offset to restore for
        // case in which no vertices are added to the buffer.  This is necessary
        // when renderstates are buffered before and after a non-visible primitive.
        DWORD dwHWOffsetSave = this->dwHWOffset;
        this->dwHWOffset = (this->dwHWOffset + 31) & ~31;

        if (this->dwHWOffset +
            this->dwNumVertices * sizeof(D3DTLVERTEX) >= dwHWBufferSize ||
            this->dwHWTriIndex + this->dwNumPrimitives >= dwHWMaxTris )
        {
            // Takes D3D lock (ST only).
            CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));
            HRESULT ret = FlushStates();
            if (ret != D3D_OK)
            {
                D3D_ERR("Error trying to render batched commands in DrawPrim");
                return ret;
            }
            dwHWOffsetSave = this->dwHWOffset;
        }

        LPVOID lpvBatchAddress = (char*)this->lpwDPBuffer + this->dwHWOffset;
        if (this->dwVIDOut == D3DFVF_TLVERTEX)
            memcpy(lpvBatchAddress, lpVertices,
                   this->dwNumVertices*sizeof(D3DTLVERTEX));
        else
        {
            // We have to map FVF vertices to the D3DTLVERTEX.
            // This is only the case when lpvOut points to the user input
            // buffer.
            HRESULT ret;
            // Output will be in the batch buffer
            if ((ret = MapFVFtoTLVertex(lpvBatchAddress)) != D3D_OK)
                return ret;
            lpVertices = (LPD3DTLVERTEX)lpvBatchAddress;
        }
        switch (this->primType)
        {
        case D3DPT_TRIANGLELIST:
            lpTriPrim = TriangleListPrecomp;
            break;
        case D3DPT_TRIANGLEFAN:
            lpTriPrim = TriangleFanPrecomp;
            break;
        case D3DPT_TRIANGLESTRIP:
            lpTriPrim = TriangleStripPrecomp;
            break;
        }
        wVertexOffset = (WORD) (this->dwHWOffset/sizeof(D3DTLVERTEX));
        lpTriOut = this->lpHWTris + this->dwHWTriIndex;

        bDoBFCulling = (this->rstates[D3DRENDERSTATE_CULLMODE]!=D3DCULL_NONE);

        for (dwTriOutCount=0, i = 0; i < this->dwNumPrimitives; i++, lpTriPrim += 1)
        {
            if(bDoBFCulling)
            {
                fCullTestResult = BFCULLTEST_TVertTri(lpVertices[lpTriPrim->v1],lpVertices[lpTriPrim->v2],lpVertices[lpTriPrim->v3]);
                if(ISCULLED(this, fCullTestResult))
                    continue;
            }

            lpTriOut->v1 = lpTriPrim->v1 + wVertexOffset;
            lpTriOut->v2 = lpTriPrim->v2 + wVertexOffset;
            lpTriOut->v3 = lpTriPrim->v3 + wVertexOffset;
            lpTriOut->wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE;
            lpTriOut += 1;
            dwTriOutCount++;
        }

        if(dwTriOutCount==0)
        {
            this->dwHWOffset = dwHWOffsetSave;    //  restore unpadded offset
            return D3D_OK;  // avoid adding unused verts to output
        }

        this->lpHWCounts[this->dwHWNumCounts].wNumTriangles += (WORD) dwTriOutCount;
        this->lpHWCounts[this->dwHWNumCounts].wNumVertices += (WORD)this->dwNumVertices;

        this->dwHWOffset += this->dwNumVertices * sizeof(D3DTLVERTEX);
        this->dwHWTriIndex += dwTriOutCount;

        return D3D_OK;
    }
    else
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                                  // Release in the destructor
        HRESULT ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in DrawPrim");
            return ret;
        }
        // We have to map FVF vertices to the D3DTLVERTEX.
        // This is only the case when lpvOut points to the user input buffer.
        if (this->dwVIDOut != D3DFVF_TLVERTEX)
        {
            HRESULT ret;
            // Output will be in the TL buffer
            if ((ret = MapFVFtoTLVertex(NULL)) != D3D_OK)
                return ret;
            lpVertices = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
        }
        if (this->primType == D3DPT_POINTLIST)
        {
            TmpPoint.wFirst = 0;
            TmpPoint.wCount = (WORD)this->dwNumPrimitives;
            return DrawPrimitiveLegacyHalCall(this, lpVertices, &TmpPoint,
                                              &ins, 0, D3DVT_TLVERTEX);
        }
        else
            return DrawPrimitiveInBatchesHW(this, this->primType,
                                            D3DVT_TLVERTEX, lpVertices,
                                            this->dwNumPrimitives);
    }
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetTSSI"

HRESULT
CDirect3DDeviceIHW::SetTSSI(DWORD dwStage, D3DTEXTURESTAGESTATETYPE dwState, DWORD dwValue)
{
    switch(dwState) {
    case D3DTSS_ADDRESS:
        return SetRenderStateInternal(D3DRENDERSTATE_TEXTUREADDRESS, dwValue);
    case D3DTSS_ADDRESSU:
        return SetRenderStateInternal(D3DRENDERSTATE_TEXTUREADDRESSU, dwValue);
    case D3DTSS_ADDRESSV:
        return SetRenderStateInternal(D3DRENDERSTATE_TEXTUREADDRESSV, dwValue);
    case D3DTSS_BORDERCOLOR:
        return SetRenderStateInternal(D3DRENDERSTATE_BORDERCOLOR, dwValue);
    case D3DTSS_MIPMAPLODBIAS:
        return SetRenderStateInternal(D3DRENDERSTATE_MIPMAPLODBIAS, dwValue);
    case D3DTSS_MAXANISOTROPY:
        return SetRenderStateInternal(D3DRENDERSTATE_ANISOTROPY, dwValue);
    }

    // Set a bit requesting mapping to DX5 renderstates
    this->dwFEFlags |= D3DFE_MAP_TSS_TO_RS;

    return D3D_OK; // return Ok for the time being?
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::MapTSSToRS"

HRESULT CDirect3DDeviceIHW::MapTSSToRS()
{
    DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
    DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
    DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];

    if(mip == D3DTFP_NONE) {
        if(min != D3DTFN_POINT && min != D3DTFN_LINEAR) {
            min = D3DTFN_LINEAR;
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, min);
    }
    else if(mip == D3DTFP_POINT) {
        if(min == D3DTFN_POINT) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPNEAREST);
        }
        else if(min == D3DTFN_LINEAR) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
        }
        else {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_MIPLINEAR);
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    else { // mip == D3DTFP_LINEAR
        if(min == D3DTFN_POINT) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPNEAREST);
        }
        else if(min == D3DTFN_LINEAR) {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
        }
        else {
            SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMIN, D3DFILTER_LINEARMIPLINEAR);
            D3D_WARN(2,"Unable to map D3DTSS_MINFILTER mode to driver. Rendering maybe incorrect");
        }
    }
    if(mag != D3DTFG_POINT && mag != D3DTFG_LINEAR) {
        mag = D3DTFG_LINEAR;
        D3D_WARN(2,"Unable to map D3DTSS_MAGFILTER mode to driver. Rendering maybe incorrect");
    }
    SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAG, mag);

    DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
    DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
    DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
    DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
    DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
    DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];

    // Current is the same as diffuse in stage 0
    if(ca2 == D3DTA_CURRENT)
        ca2 = D3DTA_DIFFUSE;
    if(aa2 == D3DTA_CURRENT)
        aa2 = D3DTA_DIFFUSE;

    // Check if we need to disable texturing
    if(cop == D3DTOP_DISABLE ||
        (cop == D3DTOP_SELECTARG2 && ca2 == D3DTA_DIFFUSE && ((aop == D3DTOP_SELECTARG2 && aa2 == D3DTA_DIFFUSE) || aop == D3DTOP_DISABLE))
        ) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREHANDLE, 0);
        this->dwFEFlags |= D3DFE_DISABLE_TEXTURES;
    }
    else
    {
        this->dwFEFlags &= ~D3DFE_DISABLE_TEXTURES; // re-enable textures
        m_dwStageDirty |= 1; // dirty the stage, so that UpdateTextures will send down the texture handle
        // Need to call UpdateTextures()
        this->dwFEFlags |= D3DFE_NEED_TEXTURE_UPDATE;
    }

    // Check if we need to decal
    if((ca1 == D3DTA_TEXTURE && cop == D3DTOP_SELECTARG1) &&
        (aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1)) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECAL);
    }
    // Check if we need to modulate
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        ((aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1) || (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2))) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATE);
    }
    // Check if we need to decal alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_BLENDTEXTUREALPHA &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_DECALALPHA);
    }
    // Check if we need to modulate alpha
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_MODULATE &&
        (aa2 == D3DTA_DIFFUSE && aa1 == D3DTA_TEXTURE) && aop == D3DTOP_MODULATE) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_MODULATEALPHA);
    }
    // Check if we need to add
    else if((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) && cop == D3DTOP_ADD &&
        (aa2 == D3DTA_DIFFUSE && aop == D3DTOP_SELECTARG2)) {
        SetRenderStateInternal(D3DRENDERSTATE_TEXTUREMAPBLEND, D3DTBLEND_ADD);
    }
    else {
#if DBG
        if(!(this->dwFEFlags & D3DFE_DISABLE_TEXTURES))
            D3D_WARN(2,"Mapping textureblend stage states to renderstates failed. Rendering maybe incorrect.");
#endif
    }

    return D3D_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::ValidateDevice"

HRESULT D3DAPI
CDirect3DDeviceIHW::ValidateDevice(LPDWORD lpdwNumPasses)
{
    // Holds D3D lock until exit.
    CLockD3DMT ldmLock(this, DPF_MODNAME, REMIND(""));
    HRESULT ret;
    D3DHAL_VALIDATETEXTURESTAGESTATEDATA vbod;

    if (!VALID_DIRECT3DDEVICE_PTR(this))
    {
        D3D_ERR( "Invalid Direct3DDevice7 pointer" );
        return DDERR_INVALIDOBJECT;
    }
    if (!VALID_PTR(lpdwNumPasses, sizeof(DWORD)))
    {
        D3D_ERR( "Invalid lpdwNumPasses pointer" );
        return DDERR_INVALIDPARAMS;
    }

    {
        DWORD mag = this->tsstates[0][D3DTSS_MAGFILTER];
        DWORD min = this->tsstates[0][D3DTSS_MINFILTER];
        DWORD mip = this->tsstates[0][D3DTSS_MIPFILTER];
        DWORD texcap = this->d3dDevDesc.dpcTriCaps.dwTextureFilterCaps;
        ret = D3DERR_UNSUPPORTEDTEXTUREFILTER;
        if(mip == D3DTFP_NONE) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                    goto err;
            }
            else
            {
                goto err;
            }
        }
        else if(mip == D3DTFP_POINT) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_MIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_MIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        else if(mip == D3DTFP_LINEAR) {
            if(min == D3DTFG_POINT) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPNEAREST))
                    goto err;
            }
            else if(min == D3DTFG_LINEAR) {
                if(!(texcap & D3DPTFILTERCAPS_LINEARMIPLINEAR))
                    goto err;
            }
            else
            {
                ret = D3DERR_CONFLICTINGTEXTUREFILTER;
                goto err;
            }
        }
        if(mag == D3DTFG_POINT) {
            if(!(texcap & D3DPTFILTERCAPS_NEAREST))
                goto err;
        }
        else if(mag == D3DTFG_LINEAR) {
            if(!(texcap & D3DPTFILTERCAPS_LINEAR))
                goto err;
        }
        else
        {
            goto err;
        }
    }

    {
        DWORD cop = this->tsstates[0][D3DTSS_COLOROP];
        DWORD ca1 = this->tsstates[0][D3DTSS_COLORARG1];
        DWORD ca2 = this->tsstates[0][D3DTSS_COLORARG2];
        DWORD aop = this->tsstates[0][D3DTSS_ALPHAOP];
        DWORD aa1 = this->tsstates[0][D3DTSS_ALPHAARG1];
        DWORD aa2 = this->tsstates[0][D3DTSS_ALPHAARG2];
        DWORD texcap = this->d3dDevDesc.dpcTriCaps.dwTextureBlendCaps;

        // Current is the same as diffuse in stage 0
        if(ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if(aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        switch (cop)
        {
        // Check decal
        case D3DTOP_SELECTARG1:
            if(!(texcap & D3DPTBLENDCAPS_DECAL))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG1)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_MODULATE:
            switch (aop)
            {
            // Check modulate
            case D3DTOP_SELECTARG1:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate (second case)
            case D3DTOP_SELECTARG2:
                if(!(texcap & D3DPTBLENDCAPS_MODULATE))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            // Check modulate alpha
            case D3DTOP_MODULATE:
                if(!(texcap & D3DPTBLENDCAPS_MODULATEALPHA))
                {
                    ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                    goto err;
                }
                if (ca1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (ca2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDCOLORARG;
                    goto err;
                }
                if (aa1 != D3DTA_TEXTURE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
                break;
            default:
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check decal alpha
        case D3DTOP_BLENDTEXTUREALPHA:
            if(!(texcap & D3DPTBLENDCAPS_DECALALPHA))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        case D3DTOP_ADD:
            if(!(texcap & D3DPTBLENDCAPS_ADD))
            {
                ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
                goto err;
            }
            if (ca1 != D3DTA_TEXTURE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aa2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDALPHAARG;
                goto err;
            }
            if (aop != D3DTOP_SELECTARG2)
            {
                ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                goto err;
            }
            break;
        // Check disable
        case D3DTOP_SELECTARG2:
            if (ca2 != D3DTA_DIFFUSE)
            {
                ret = D3DERR_UNSUPPORTEDCOLORARG;
                goto err;
            }
            if (aop != D3DTOP_DISABLE)
            {
                if (aop != D3DTOP_SELECTARG2)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAOPERATION;
                    goto err;
                }
                if (aa2 != D3DTA_DIFFUSE)
                {
                    ret = D3DERR_UNSUPPORTEDALPHAARG;
                    goto err;
                }
            }
            break;
        // Check disable
        case D3DTOP_DISABLE:
            break;
        default:
            ret = D3DERR_UNSUPPORTEDCOLOROPERATION;
            goto err;
        }
    }

    *lpdwNumPasses = 1;
    return D3D_OK;

err:
    D3D_INFO(0,"Failed to validate texture stage state.");
    *lpdwNumPasses = 0;
    return ret;
}
//---------------------------------------------------------------------
// Called by the destructor
//
CDirect3DDeviceIHW::~CDirect3DDeviceIHW()
{
    CleanupTextures();
    if (this->lpHWCounts)
        D3DFree(this->lpHWCounts);
    if (this->lpHWTris)
        D3DFree(this->lpHWTris);
    if (this->wTriIndex)
        D3DFree(this->wTriIndex);
};
//---------------------------------------------------------------------
HRESULT CDirect3DDeviceIHW::Init(REFCLSID riid, LPDIRECT3DI lpD3DI,
                                 LPDIRECTDRAWSURFACE lpDDS,
                                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    HRESULT ret;
    this->dwHWNumCounts = 0;
    this->dwHWOffset = 0;
    this->dwHWTriIndex = 0;
    if (IsEqualIID(riid, IID_IDirect3DHALDevice))
    {
        this->dwFEFlags |=  D3DFE_REALHAL;
    }
    if (D3DMalloc((void**)&this->wTriIndex, dwD3DTriBatchSize*4*sizeof(WORD)) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (wTriIndex)" );
        return DDERR_OUTOFMEMORY;
    }

    if (D3DMalloc((void**)&this->lpHWCounts, dwHWBufferSize*sizeof(D3DI_HWCOUNTS)/32 ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWCounts)" );
        return DDERR_OUTOFMEMORY;
    }
    memset(this->lpHWCounts, 0, sizeof(D3DI_HWCOUNTS) );
    if (D3DMalloc((void**)&this->lpHWTris, dwHWMaxTris*sizeof(D3DTRIANGLE) ) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (HWVertices)" );
        return DDERR_OUTOFMEMORY;
    }
    ret = DIRECT3DDEVICEI::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;
    if (TLVbuf.Grow(this, (__INIT_VERTEX_NUMBER*2)*sizeof(D3DTLVERTEX)) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate (TLVbuf)" );
        return DDERR_OUTOFMEMORY;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIHW::SetRenderStateI"

HRESULT
CDirect3DDeviceIHW::SetRenderStateI(D3DRENDERSTATETYPE dwState, DWORD value)
{
    LPDWORD lpRS;
    // map WRAP0 into legacy renderstate
    if (D3DRENDERSTATE_WRAP0 == dwState)
    {
        BOOLEAN ustate = (value & D3DWRAP_U) ? TRUE : FALSE;
        BOOLEAN vstate = (value & D3DWRAP_V) ? TRUE : FALSE;
        SetRenderStateI(D3DRENDERSTATE_WRAPU, ustate);
        SetRenderStateI(D3DRENDERSTATE_WRAPV, vstate);
        return D3D_OK;
    }
    if (dwState > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if (dwState > D3DRENDERSTATE_FLUSHBATCH && dwState < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwState);
        return D3D_OK;
    }
    if ( this->dwHWOffset + 8 >= dwHWBufferSize )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
                                                        // Release in the destructor
        HRESULT ret;
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in BeginIndexed");
            return ret;
        }
    }
    if (this->lpHWCounts[this->dwHWNumCounts].wNumVertices)
    {
        this->dwHWNumCounts += 1;
        memset(&this->lpHWCounts[this->dwHWNumCounts], 0, sizeof(D3DI_HWCOUNTS) );
    }

    lpRS = (LPDWORD) (((char *) this->lpwDPBuffer) + this->dwHWOffset);
    lpRS[0] = dwState;
    lpRS[1] = value;
    this->lpHWCounts[this->dwHWNumCounts].wNumStateChanges += 1;
    this->dwHWOffset += 8;

    return D3D_OK;
}

//---------------------------------------------------------------------
// ProcessPrimitive processes indexed, non-indexed primitives or
// vertices only as defined by "op"
//
// op = __PROCPRIMOP_NONINDEXEDPRIM by default
//
HRESULT CDirect3DDeviceIHW::ProcessPrimitive(__PROCPRIMOP op)
{
    HRESULT ret=D3D_OK;
    DWORD vertexPoolSize;

    // Grow clip flags buffer if we need clipping
    //
    if (!(this->dwDeviceFlags & D3DDEV_DONOTCLIP))
    {
        DWORD size = this->dwNumVertices * sizeof(D3DFE_CLIPCODE);
        if (size > this->HVbuf.GetSize())
        {
            if (this->HVbuf.Grow(size) != D3D_OK)
            {
                D3D_ERR( "Could not grow clip buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpClipFlags = (D3DFE_CLIPCODE*)this->HVbuf.GetAddress();
    }

    if (FVF_TRANSFORMED(this->dwVIDIn))
    {
        // Pass vertices directly from the user memory
        this->dwVIDOut = this->dwVIDIn;
        this->dwOutputSize = this->position.dwStride;
        this->lpvOut = this->position.lpvData;
        vertexPoolSize = this->dwNumVertices * this->dwOutputSize;

        if (this->dwDeviceFlags & D3DDEV_DONOTCLIP)
        {
            if (!(this->dwDeviceFlags & D3DDEV_DONOTUPDATEEXTENTS))
                D3DFE_updateExtents(this);

            if (op == __PROCPRIMOP_INDEXEDPRIM)
            {
                ret = this->DrawIndexPrim();
            }
            else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            {
                ret = this->DrawPrim();
            }
        }
        else
        {
            // Clear clip union and intersection flags
            DWORD clip_intersect = D3DFE_GenClipFlags(this);
            D3DFE_UpdateClipStatus(this);
            if (!clip_intersect)
            {
                this->dwFlags |= D3DPV_TLVCLIP;
                if (op == __PROCPRIMOP_INDEXEDPRIM)
                {
                    ret = DoDrawIndexedPrimitive(this);
                }
                else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
                {
                    ret = DoDrawPrimitive(this);
                }
            }
        }
    }
    else
    {
        // We need to grow TL vertex buffer if we have to transform vertices
        //
        vertexPoolSize = this->dwNumVertices * this->dwOutputSize;
        if (vertexPoolSize > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, vertexPoolSize) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                ret = DDERR_OUTOFMEMORY;
                return ret;
            }
        }
        this->lpvOut = this->TLVbuf.GetAddress();

        // Update Lighting and related flags
        DoUpdateState(this);

        // Call PSGP or our implementation
        if (op == __PROCPRIMOP_INDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessIndexedPrimitive(this);
        else if (op == __PROCPRIMOP_NONINDEXEDPRIM)
            ret = this->pGeometryFuncs->ProcessPrimitive(this);
        else
            ret = this->pGeometryFuncs->ProcessVertices(this);

        D3DFE_UpdateClipStatus(this);
    }
    return ret;
}
#endif // WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\dphal.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphal.c
 *  Content:    DrawPrimitive implementation for DrawPrimitive HALs
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#ifdef WIN95

#include "drawprim.hpp"
#include "clipfunc.h"
#include "d3dfei.h"

#define LOWVERTICESNUMBERDP  20

extern void SetDebugRenderState(DWORD value);

#define ALIGN32(x) x = ((DWORD)(x + 31)) & (~31);
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex1"

inline void MapFVFtoTLVertex1(LPDIRECT3DDEVICEI lpDevI, D3DTLVERTEX *pOut,
                              DWORD *pIn)
{
// Copy position
    pOut->sx  = *(D3DVALUE*)pIn++;
    pOut->sy  = *(D3DVALUE*)pIn++;
    pOut->sz  = *(D3DVALUE*)pIn++;
    pOut->rhw = *(D3DVALUE*)pIn++;
// Other fields: diffuse, specular, texture
    if (lpDevI->dwVIDOut & D3DFVF_DIFFUSE)
        pOut->color = *pIn++;
    else
    {
        pOut->color = __DEFAULT_DIFFUSE;
    }
    if (lpDevI->dwVIDOut & D3DFVF_SPECULAR)
        pOut->specular = *pIn++;
    else
    {
        pOut->specular= __DEFAULT_SPECULAR;
    }
    if (lpDevI->nOutTexCoord)
    {
        pIn = &pIn[lpDevI->dwTextureIndexToCopy << 1];
        pOut->tu = *(D3DVALUE*)&pIn[0];
        pOut->tv = *(D3DVALUE*)&pIn[1];
    }
    else
    {
        pOut->tu = 0;
        pOut->tv = 0;
    }
}
//---------------------------------------------------------------------
// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertex"

HRESULT CDirect3DDeviceIHW::MapFVFtoTLVertex(LPVOID lpAddress)
{
    int i;
    DWORD size = this->dwNumVertices * sizeof(D3DTLVERTEX);
    D3DTLVERTEX *pOut;
    if (lpAddress)
        pOut = (D3DTLVERTEX*)lpAddress;
    else
    {
    // See if TL buffer has sufficient space
        if (size > this->TLVbuf.GetSize())
        {
            if (this->TLVbuf.Grow(this, size) != D3D_OK)
            {
                D3D_ERR( "Could not grow TL vertex buffer" );
                return DDERR_OUTOFMEMORY;
            }
        }
        pOut = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
    }
// Map vertices
    DWORD *pIn = (DWORD*)this->lpvOut;
    for (i=this->dwNumVertices; i; i--)
    {
        MapFVFtoTLVertex1(this, pOut, pIn);
        pOut++;
        pIn = (DWORD*)((char*)pIn + this->dwOutputSize);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Vertices, corresponding to the primitive's indices, are converted to D3DTLVERTEX
// and copied to the TL buffer
//
#undef DPF_MODNAME
#define DPF_MODNAME "MapFVFtoTLVertexIndexed"

HRESULT CDirect3DDeviceIHW::MapFVFtoTLVertexIndexed()
{
    DWORD size = this->dwNumVertices * sizeof(D3DTLVERTEX);
    D3DTLVERTEX *pOut;
    // See if TL buffer has sufficient space
    if (size > this->TLVbuf.GetSize())
    {
        if (this->TLVbuf.Grow(this, size) != D3D_OK)
        {
            D3D_ERR( "Could not grow TL vertex buffer" );
            return DDERR_OUTOFMEMORY;
        }
    }
    pOut = (D3DTLVERTEX*)this->TLVbuf.GetAddress();
// Map vertices
    DWORD *pIn = (DWORD*)this->lpvOut;
    for (DWORD i = 0; i < this->dwNumIndices; i++)
    {
        DWORD *pInpVertex = (DWORD*)((BYTE*)pIn + this->lpwIndices[i] * this->dwOutputSize);
        MapFVFtoTLVertex1(this, &pOut[this->lpwIndices[i]], pInpVertex);
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// Draws non-indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawPrim"

#define __DRAWPRIMFUNC
#include "dpgen.h"
//---------------------------------------------------------------------
// Draws indexed primitives which do not require clipping
//
#undef DPF_MODNAME
#define DPF_MODNAME "DrawIndexedPrim"

#define __DRAWPRIMFUNC
#define __DRAWPRIMINDEX
#include "dpgen.h"

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::Init"

HRESULT CDirect3DDeviceIDP::Init(REFCLSID riid, LPDIRECT3DI lpD3DI, 
                                 LPDIRECTDRAWSURFACE lpDDS,
                                 IUnknown* pUnkOuter, LPUNKNOWN* lplpD3DDevice)
{
    HRESULT ret;
    ret = CDirect3DDeviceIHW::Init(riid, lpD3DI, lpDDS, pUnkOuter, lplpD3DDevice);
    if (ret != D3D_OK)
        return ret;

    return D3D_OK;
}
//---------------------------------------------------------------------
// ATTENTION - These two functions should be combined into one as soon
// as ContextCreate has the new private data mechanism built in.
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::halCreateContext"

HRESULT CDirect3DDeviceIDP::halCreateContext()
{
    HRESULT ret;
    ret = DIRECT3DDEVICEI::halCreateContext();
    if (ret != D3D_OK)
        return ret;

    this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
    memset( (char *)this->lpwDPBuffer, 0, sizeof(D3DHAL_DRAWPRIMCOUNTS));

    this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
    this->dwDPMaxOffset = dwD3DTriBatchSize * sizeof(D3DTRIANGLE)-sizeof(D3DTLVERTEX);

    return (D3D_OK);
}
//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "FlushStatesDP"

HRESULT
CDirect3DDeviceIDP::FlushStates(bool bWithinPrimitive)
{
    HRESULT dwRet=D3D_OK;
    if (this->dwDPOffset>sizeof(D3DHAL_DRAWPRIMCOUNTS))
    {
        ++m_qwBatch;
        // So that currently bound textures get rebatched
        for (DWORD dwStage = 0; dwStage < this->dwMaxTextureBlendStages; dwStage++)
        {
            LPDIRECT3DTEXTUREI lpTexI = this->lpD3DMappedTexI[dwStage];
            if (NULL != lpTexI)
            {
                if(lpTexI->lpDDS != NULL)
                {
                    BatchTexture(((LPDDRAWI_DDRAWSURFACE_INT)(lpTexI->lpDDS))->lpLcl);
                }
            }
        }
    
        if ((dwRet=CheckSurfaces()) != D3D_OK)
        {
            this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);
            this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
            memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS)); //Clear header also
            if (dwRet == DDERR_SURFACELOST)
            {
                this->dwFEFlags |= D3DFE_LOSTSURFACES;
                return D3D_OK;
            }
            return dwRet;
        }

        D3DHAL_DRAWPRIMITIVESDATA dpData;
        DWORD   dwDPOffset;
        if (this->lpDPPrimCounts->wNumVertices)    //this->lpDPPrimCounts->wNumVertices==0 means the end
        {                      //force it if not
            memset(((LPBYTE)this->lpwDPBuffer+this->dwDPOffset),0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        }
        dpData.dwhContext = this->dwhContext;
        dpData.dwFlags =  0;
        dpData.lpvData = this->lpwDPBuffer;
        if (FVF_DRIVERSUPPORTED(this))
            dpData.dwFVFControl = this->dwCurrentBatchVID;
        else
        {
            if (this->dwDebugFlags & D3DDEBUG_DISABLEFVF)
                dpData.dwFVFControl = D3DFVF_TLVERTEX;
            else
                dpData.dwFVFControl = 0;    //always zero for non-FVF drivers
        }
        dpData.ddrval = 0;
        dwDPOffset=this->dwDPOffset;  //save it in case Flush returns prematurely
#if 0
        if (D3DRENDERSTATE_TEXTUREHANDLE==*((DWORD*)this->lpwDPBuffer+2))
        DPF(0,"Flushing dwDPOffset=%08lx ddihandle=%08lx",dwDPOffset,*((DWORD*)this->lpwDPBuffer+3));
#endif  //0
        //we clear this to break re-entering as SW rasterizer needs to lock DDRAWSURFACE
        this->dwDPOffset = sizeof(D3DHAL_DRAWPRIMCOUNTS);

        // Spin waiting on the driver if wait requested
#if _D3D_FORCEDOUBLE
        CD3DForceFPUDouble  ForceFPUDouble(this);
#endif  //_D3D_FORCEDOUBLE
        do {
#ifndef WIN95
            if((dwRet = CheckContextSurface(this)) != D3D_OK)
            {
                this->dwDPOffset = dwDPOffset;
                return (dwRet);
            }
#endif //WIN95
            CALL_HAL2ONLY(dwRet, this, DrawPrimitives, &dpData);
            if (dwRet != DDHAL_DRIVER_HANDLED)
            {
                D3D_ERR ( "Driver call for DrawOnePrimitive failed" );
                // Need sensible return value in this case,
                // currently we return whatever the driver stuck in here.
            }
        } while (dpData.ddrval == DDERR_WASSTILLDRAWING);
        this->lpDPPrimCounts = (LPD3DHAL_DRAWPRIMCOUNTS)this->lpwDPBuffer;
        memset( (char *)this->lpwDPBuffer,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));   //Clear header also
        dwRet= dpData.ddrval;
        this->dwCurrentBatchVID = this->dwVIDOut;
    }
    return dwRet;
}

//---------------------------------------------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CDirect3DDeviceIDP::SetRenderStateI"

HRESULT 
CDirect3DDeviceIDP::SetRenderStateI(D3DRENDERSTATETYPE dwStateType,
                                    DWORD value)
{
    LPD3DHAL_DRAWPRIMCOUNTS lpPC;
    LPDWORD lpStateChange;
    HRESULT ret;
    // map WRAP0 into legacy renderstate
    if (D3DRENDERSTATE_WRAP0 == dwStateType)
    {
        BOOLEAN ustate = (value & D3DWRAP_U) ? TRUE : FALSE;
        BOOLEAN vstate = (value & D3DWRAP_V) ? TRUE : FALSE;
        SetRenderStateI(D3DRENDERSTATE_WRAPU, ustate);
        SetRenderStateI(D3DRENDERSTATE_WRAPV, vstate);
        return D3D_OK;
    }
    if (dwStateType > D3DRENDERSTATE_STIPPLEPATTERN31)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }
    if (dwStateType > D3DRENDERSTATE_FLUSHBATCH && dwStateType < D3DRENDERSTATE_STIPPLEPATTERN00)
    {
        D3D_WARN(4,"Trying to send invalid state %d to legacy driver",dwStateType);
        return D3D_OK;
    }

    lpPC = this->lpDPPrimCounts;
    if (lpPC->wNumVertices) //Do we already have Vertices filled in for this count ?
    {               //Yes, then Increment count
        lpPC=this->lpDPPrimCounts=(LPD3DHAL_DRAWPRIMCOUNTS)((LPBYTE)this->lpwDPBuffer+this->dwDPOffset);
        memset( (char *)lpPC,0,sizeof(D3DHAL_DRAWPRIMCOUNTS));
        this->dwDPOffset += sizeof(D3DHAL_DRAWPRIMCOUNTS);
    }
    if (this->dwDPOffset + 2*sizeof(DWORD)  > this->dwDPMaxOffset )
    {
        CLockD3DST lockObject(this, DPF_MODNAME, REMIND(""));   // Takes D3D lock (ST only).
        ret = FlushStates();
        if (ret != D3D_OK)
        {
            D3D_ERR("Error trying to render batched commands in SetRenderStateI");
            return ret;
        }
    }
    lpStateChange=(LPDWORD)((char *)this->lpwDPBuffer + this->dwDPOffset);
    *lpStateChange=dwStateType;
    lpStateChange ++;
    *lpStateChange=value;
    this->lpDPPrimCounts->wNumStateChanges ++;
    this->dwDPOffset += 2*sizeof(DWORD);
#if 0
    if (dwStateType == D3DRENDERSTATE_TEXTUREHANDLE && this->dwDPOffset== 0x10){
    DPF(0,"SRdwDPOffset=%08lx, dwStateType=%08lx value=%08lx ddihandle=%08lx lpStateChange=%08lx lpDPPrimCounts=%08lx",
    this->dwDPOffset,dwStateType,value,*lpStateChange,lpStateChange,this->lpDPPrimCounts);
        _asm int 3
    }
#endif //0

    return D3D_OK;
}

#endif // WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\halbuf.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halbuf.c
 *  Content:    Direct3D HAL buffer management
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id: halbuf.c,v 1.1 1995/11/21 15:12:30 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   06/11/95   stevela Initial rev.
 *   07/11/95   stevela stuff.
 *   17/02/96   colinmc Fixed build problem.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#ifndef USE_SURFACE_LOCK

HRESULT D3DHAL_LockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return D3D_OK;
#else
    HRESULT ret;
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }

    if (isbusy) {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
#endif
}

void D3DHAL_UnlockDibEngine(LPDIRECT3DDEVICEI lpDevI)
{
#ifndef WIN95
    return;
#else
    LPDDRAWI_DIRECTDRAW_GBL pdrv = lpDevI->lpDDGbl;
    *pdrv->lpwPDeviceFlags &= ~BUSY;
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifndef _DRAWPRIM_H_
#define _DRAWPRIM_H_

#define MAX_DX6_PRIMCOUNT   D3DMAXNUMPRIMITIVES
#define MAX_DX6_VERTICES    D3DMAXNUMVERTICES
#ifdef WIN95
#define LOWVERTICESNUMBER 128
#else
#define LOWVERTICESNUMBER 96
#endif
#define D3D_MAX_TLVBUF_CHANGES 5

extern HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv);
extern HRESULT CheckDrawPrimitive(LPDIRECT3DDEVICEI lpDevI);
extern HRESULT CheckDrawIndexedPrimitive(LPDIRECT3DDEVICEI lpDevI, DWORD dwStartVertex = 0);

// All vertices from lpDevI->lpVout are copied to the output buffer, expanding
// to D3DTLVERTEX.
// The output buffer is lpAddress if it is not NULL, otherwise it is TLVbuf
//
//---------------------------------------------------------------------
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_DRIVERSUPPORTED(lpDevI) (lpDevI->dwDeviceFlags & D3DDEV_FVF)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)
//----------------------------------------------------------------------
inline DWORD MakeTexTransformFuncIndex(DWORD dwNumInpTexCoord, DWORD dwNumOutTexCoord)
{
    DDASSERT(dwNumInpTexCoord <= 4 && dwNumOutTexCoord <= 4);
    return (dwNumInpTexCoord - 1) + ((dwNumOutTexCoord - 1) << 2);
}
//---------------------------------------------------------------------
// The function should not be called by ProcessVertices!!!
//
// Computes nOutTexCoord, dwTextureCoordSizeTotal, dwTextureCoordSize and
// dwTextureIndexToCopy in case when a pre-DX6 driver is used.
//
void ComputeTCI2CopyLegacy(LPDIRECT3DDEVICEI lpDevI,
                           DWORD  dwNumInpTexCoord,
                           DWORD* pdwInpTexCoordSize,
                           BOOL bVertexTransformed);
//---------------------------------------------------------------------
// Computes size in bytes of the position component of a vertex
//
__inline DWORD GetPositionSizeFVF(DWORD fvf)
{
    DWORD size = 3 << 2;
    switch (fvf & D3DFVF_POSITION_MASK)
    {
    case D3DFVF_XYZRHW: size += 4;      break;
    case D3DFVF_XYZB1:  size += 1*4;    break;
    case D3DFVF_XYZB2:  size += 2*4;    break;
    case D3DFVF_XYZB3:  size += 3*4;    break;
    case D3DFVF_XYZB4:  size += 4*4;    break;
    case D3DFVF_XYZB5:  size += 5*4;    break;
    }
    return size;
}
//---------------------------------------------------------------------
// Computes vertex size in bytes for a the vertex ID excluding size of
// texture oordinates
//
__inline DWORD GetVertexSizeFVF(DWORD fvf)
{
    DWORD size = GetPositionSizeFVF(fvf);
    if (fvf & D3DFVF_NORMAL)
        size += 3*4;
    if (fvf & D3DFVF_RESERVED1)
        size += 4;

    if (fvf & D3DFVF_DIFFUSE)
        size+= 4;
    if (fvf & D3DFVF_SPECULAR)
        size += 4;

    return size;
}
//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};
//---------------------------------------------------------------------
// Computes vertex size in bytes from the vertex ID
//
// Texture formats size        00   01   10   11
const BYTE g_TextureSize[4] = {2*4, 3*4, 4*4, 4};

//---------------------------------------------------------------------
// Index is number of floats in a texture coordinate set.
// Value is texture format bits
//
const DWORD g_dwTextureFormat[5] = {0, 3, 0, 1, 2};

//---------------------------------------------------------------------
// Returns total size of texture coordinates
// Computes dwTextureCoordSize[] array - size of every texture coordinate set
//
inline DWORD ComputeTextureCoordSize(DWORD dwFVF, DWORD *dwTextureCoordSize)
{
    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD dwTextureCoordSizeTotal;

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwTextureCoordSizeTotal = (BYTE)dwNumTexCoord * 2 * 4;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            dwTextureCoordSize[i] = 4*2;
        }
    }
    else
    {
        DWORD dwOffset = 0;
        dwTextureCoordSizeTotal = 0;
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = g_TextureSize[dwTextureFormats & 3];
            dwTextureCoordSize[i] = dwSize;
            dwTextureCoordSizeTotal += dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return dwTextureCoordSizeTotal;
}
//---------------------------------------------------------------------
#undef  DPF_MODNAME
#define DPF_MODNAME "CheckDeviceSettings"
inline HRESULT CheckDeviceSettings(LPDIRECT3DDEVICEI lpDevI)
{
#if DBG
    if (!(lpDevI->dwHintFlags & D3DDEVBOOL_HINTFLAGS_INSCENE))
    {
        D3D_ERR( "Not in scene" );
        return D3DERR_SCENE_NOT_IN_SCENE;
    }
#endif
    return D3D_OK;
}
//---------------------------------------------------------------------
// Computes the number of primtives and also updates the stats accordingly
// Input:  lpDevI->primType
//         dwNumVertices
// Output: lpDevI->dwNumPrimitives
//         return value = dwNumPrimitives
#undef DPF_MODNAME
#define DPF_MODNAME "GetNumPrim"

inline __declspec(nothrow) void GetNumPrim(LPDIRECT3DDEVICEI lpDevI, DWORD dwNumVertices)
{
    lpDevI->dwNumPrimitives = 0;
    switch (lpDevI->primType)
    {
    case D3DPT_POINTLIST:
        lpDevI->dwNumPrimitives = dwNumVertices;
        break;
    case D3DPT_LINELIST:
        lpDevI->dwNumPrimitives = dwNumVertices >> 1;
        break;
    case D3DPT_LINESTRIP:
        if (dwNumVertices < 2)
            return;
        lpDevI->dwNumPrimitives = dwNumVertices - 1;
        break;
    case D3DPT_TRIANGLEFAN:
    case D3DPT_TRIANGLESTRIP:
        if (dwNumVertices < 3)
            return;
        lpDevI->dwNumPrimitives = dwNumVertices - 2;
        break;
    case D3DPT_TRIANGLELIST:
#ifdef _X86_
        {
            DWORD tmp;
            __asm
            {
                mov  eax, 0x55555555    // fractional part of 1.0/3.0
                mul  dwNumVertices
                add  eax, 0x80000000    // Rounding
                adc  edx, 0
                mov  tmp, edx
            }
            lpDevI->dwNumPrimitives = tmp;
        }
#else
        lpDevI->dwNumPrimitives = dwNumVertices / 3;
#endif
        break;
    }
}
//---------------------------------------------------------------------
// Sets front-end flags every time fog state is changed
//
inline void DIRECT3DDEVICEI::SetFogFlags(void)
{
    // Call ForceFVFRecompute only if fog enable state has been changed
    BOOL bFogWasEnabled = this->dwDeviceFlags & D3DDEV_FOG;
    if (this->lighting.fog_mode != D3DFOG_NONE &&
        this->rstates[D3DRENDERSTATE_FOGENABLE])
    {
        this->dwDeviceFlags |= D3DDEV_FOG;
        if (!bFogWasEnabled)
            ForceFVFRecompute();
    }
    else
    {
        this->dwDeviceFlags &= ~D3DDEV_FOG;
        if (bFogWasEnabled)
            ForceFVFRecompute();
    }
}
//---------------------------------------------------------------------
// Validates DrawPrimitive flags
//
inline BOOL IsDPFlagsValid(DWORD dwFlags)
{
    if (dwFlags & ~(D3DDP_WAIT))
    {
        D3D_ERR( "Invalid bit set in DrawPrimitive flags" );
        return FALSE;
    }
    return TRUE;
}
//---------------------------------------------------------------------
// Restore indices in the texture stages which were re-mapped for texture
// transforms
// We have to do restore if
//  - Set or Get render state is issued with _WRAP parameter
//  - Set or Get texture stage is issued with TEXCOORDINDEX as a parameter
//
inline void RestoreTextureStages(LPDIRECT3DDEVICEI pDevI)
{
    // dwVIDIn is used to force re-compute FVF in the
    // SetTextureStageState. so we save and restore it.
    DWORD dwVIDInSaved = pDevI->dwVIDIn;
    pDevI->dwDeviceFlags &= ~D3DDEV_REMAPTEXTUREINDICES;
    for (DWORD i=0; i < pDevI->dwNumTextureStages; i++)
    {
        LPD3DFE_TEXTURESTAGE pStage = &pDevI->textureStage[i];
        // Texture generation mode was stripped out of pStage->dwInpCoordIndex
        DWORD dwInpIndex = pStage->dwInpCoordIndex + pStage->dwTexGenMode;
        if (dwInpIndex != pStage->dwOutCoordIndex)
        {
            // We do not call UpdateInternalTextureStageState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->tsstates[pStage->dwOrgStage][D3DTSS_TEXCOORDINDEX] = dwInpIndex;

            // Filter texgen modes for DX6 drivers
            if (!IS_TLHAL_DEVICE(pDevI) && dwInpIndex > 7)
                continue;

            CDirect3DDeviceIDP2 *pDevDP2 = static_cast<CDirect3DDeviceIDP2*>(pDevI);
            pDevDP2->SetTSSI(pStage->dwOrgStage, D3DTSS_TEXCOORDINDEX, dwInpIndex);
        }
        DWORD dwState = D3DRENDERSTATE_WRAP0 + pStage->dwOutCoordIndex;
        if (pStage->dwOrgWrapMode != pDevI->rstates[dwState])
        {
            // We do not call UpdateInternaState because it
            // will call ForceRecomputeFVF and we do not want this.
            pDevI->rstates[dwState] = pStage->dwOrgWrapMode;
            pDevI->SetRenderStateI((D3DRENDERSTATETYPE)dwState, pStage->dwOrgWrapMode);
        }
    }
    pDevI->dwVIDIn = dwVIDInSaved;
}
//---------------------------------------------------------------------
// the function works when there are texture transforms.
// It computes number of output texture coordinates, texture coordinate size and format.
// It prepares texture stages to re-map texture coordinates
//
HRESULT EvalTextureTransforms(LPDIRECT3DDEVICEI pDevI, DWORD dwTexTransform,
                              DWORD *pdwOutTextureSize, DWORD *pdwOutTextureFormat);
//----------------------------------------------------------------------
// Sets texture transform pointer for every input texture coordinate set
//
void SetupTextureTransforms(LPDIRECT3DDEVICEI pDevI);
//----------------------------------------------------------------------
inline BOOL TextureTransformEnabled(LPDIRECT3DDEVICEI pDevI)
{
    return __TEXTURETRANSFORMENABLED(pDevI);
}
//---------------------------------------------------------------------
inline void ComputeOutputVertexOffsets(LPD3DFE_PROCESSVERTICES pv)
{
    DWORD i = 4*sizeof(D3DVALUE);
    pv->diffuseOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
        i += sizeof(DWORD);
    pv->specularOffsetOut = i;
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
        i += sizeof(DWORD);
    pv->texOffsetOut = i;
}

#endif _DRAWPRIM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\haldrv.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997, 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       haldrv.cpp
 *  Content:    Direct3D HAL Driver
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

#include "commdrv.hpp"
#include "d3dfei.h"
#include "tlhal.h"

#ifndef WIN95
#include <ntgdistr.h>
#endif

void Destroy(LPDIRECT3DDEVICEI lpDevI);
//---------------------------------------------------------------------
int
GenGetExtraVerticesNumber( LPDIRECT3DDEVICEI lpDevI )
{
    LPD3DHAL_GLOBALDRIVERDATA lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    return (int)(lpGlob->dwNumVertices ?
        lpGlob->dwNumVertices : D3DHAL_DEFAULT_TL_NUM);

}
//---------------------------------------------------------------------
HRESULT CalcDDSurfInfo(LPDIRECT3DDEVICEI lpDevI, BOOL bUpdateZBufferFields)
{
    DDSURFACEDESC ddsd;
    HRESULT ddrval;
    DWORD dwWidth, dwHeight;
    unsigned long m;
    int s;

    // Get info from the surface

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    ddrval = lpDevI->lpDDSTarget->GetSurfaceDesc(&ddsd);
    if (ddrval != DD_OK) {
        return ddrval;
    }

    dwWidth = ddsd.dwWidth;
    dwHeight = ddsd.dwHeight;
    if ((ddsd.ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8)) == 0) {
        // palettized pixfmts will not have valid RGB Bitmasks, so avoid computing this for them

        lpDevI->red_mask = ddsd.ddpfPixelFormat.dwRBitMask;
        lpDevI->green_mask = ddsd.ddpfPixelFormat.dwGBitMask;
        lpDevI->blue_mask = ddsd.ddpfPixelFormat.dwBBitMask;
        
        if ((lpDevI->red_mask == 0x0)  ||
            (lpDevI->green_mask == 0x0) ||
            (lpDevI->blue_mask == 0x0))
        {
            D3D_ERR("All the color masks in the Render target's pixel-format must be non-zero");
            return DDERR_INVALIDPIXELFORMAT;
        }

        // these are used by Clear
        for (s = 0, m = lpDevI->red_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->red_shift = s;
        lpDevI->red_scale = 255 / (lpDevI->red_mask >> s);
        for (s = 0, m = lpDevI->green_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->green_shift = s;
        lpDevI->green_scale = 255 / (lpDevI->green_mask >> s);
        for (s = 0, m = lpDevI->blue_mask; !(m & 1); s++, m >>= 1) ;
        lpDevI->blue_shift = s;
        lpDevI->blue_scale = 255 / (lpDevI->blue_mask >> s);

        if ( (lpDevI->red_scale==0) ||
             (lpDevI->green_scale==0) ||
             (lpDevI->blue_scale==0) )
            return DDERR_INVALIDPIXELFORMAT;

        // If there is Alpha in this format
        if (ddsd.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)
        {
            lpDevI->alpha_mask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
            for (s = 0, m = lpDevI->alpha_mask; !(m & 1); s++, m >>= 1) ;
            lpDevI->alpha_shift = s;
            lpDevI->alpha_scale = 255 / (lpDevI->alpha_mask >> s);
        }
        else
        {
            lpDevI->alpha_shift = lpDevI->alpha_scale = lpDevI->alpha_mask = 0;
        }
        
        lpDevI->bDDSTargetIsPalettized=FALSE;
    } else
        lpDevI->bDDSTargetIsPalettized=TRUE;

    if (lpDevI->lpDDSZBuffer_DDS7 && bUpdateZBufferFields) {
        // Get info from the surface

        DDSURFACEDESC2 ddsd2;

        memset(&ddsd2, 0, sizeof(ddsd2));
        ddsd2.dwSize = sizeof(ddsd2);
        ddrval = lpDevI->lpDDSZBuffer_DDS7->GetSurfaceDesc(&ddsd2);
        if (ddrval != DD_OK) {
            return ddrval;
        }

        if( ddsd2.ddpfPixelFormat.dwZBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwZBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->zmask_shift=s;
        } else {
            lpDevI->zmask_shift=0;     // if ZBitMask isn't being set, then Clear2 will never be used,
                                      // so zbuf_shift/stencil_shift wont be needed anyway
        }

        if( ddsd2.ddpfPixelFormat.dwStencilBitMask!=0x0) {
            for (s = 0, m = ddsd2.ddpfPixelFormat.dwStencilBitMask; !(m & 0x1); s++, m >>= 1) ;
            lpDevI->stencilmask_shift=s;
        } else {
            lpDevI->stencilmask_shift=0;
        }
    }

    return D3D_OK;
}

// called by DDRAW
extern "C" HRESULT __stdcall Direct3D_HALCleanUp(LPD3DHAL_CALLBACKS lpD3DHALCallbacks, DWORD dwPID)
{
    D3DHAL_CONTEXTDESTROYALLDATA data;
    HRESULT ret;

    DDASSERT(lpD3DHALCallbacks!=NULL);
    if (lpD3DHALCallbacks->ContextDestroyAll==NULL) {
        // no cleanup necessary (running on d3d hel)
    return D3D_OK;
    }

    memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYALLDATA));
    data.dwPID = dwPID;

    // I'd prefer to use CALL_HALONLY() to do the locking (to avoid doing it for the SW rasterizers),
    // but that requires a pDevI which I can't get to from the caller, which is a ddraw cleanup routine

#ifdef WIN95
    _EnterSysLevel(lpWin16Lock);
#endif

    ret = (*lpD3DHALCallbacks->ContextDestroyAll)(&data);

#ifdef WIN95
    _LeaveSysLevel(lpWin16Lock);
#endif

    return ret;
}

// ATTENTION - These two functions should be combined into one as soon
// as ContextCreate has the new private data mechanism built in.
#ifdef WIN95
HRESULT DIRECT3DDEVICEI::halCreateContext()
{
    D3DHAL_CONTEXTCREATEDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", this);

    memset(&data, 0, sizeof(D3DHAL_CONTEXTCREATEDATA));
    //
    // From DX7 onwards, drivers should be accepting
    // Surface Locals instead of the Surface interfaces
    // this future-proofs the drivers
    //
    if (IS_DX7HAL_DEVICE(this))
    {
        if (this->lpDD)
            data.lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl;
        else
            data.lpDDLcl = NULL;

        if (lpDDSTarget)
            data.lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSTarget)->lpLcl;
        else
            data.lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            data.lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZBuffer)->lpLcl;
        else
            data.lpDDSZLcl = NULL;

    }
    else
    {
        data.lpDDGbl = this->lpDDGbl;
        data.lpDDS = this->lpDDSTarget;
        data.lpDDSZ = this->lpDDSZBuffer;
    }

    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    data.dwhContext = 3;
    data.dwPID  = GetCurrentProcessId();
    // Hack Alert!! ddrval is used to inform the driver which driver type
    // the runtime thinks it is (DriverStyle registry setting)
    data.ddrval = this->deviceType;

    if (!IS_HW_DEVICE(this))
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        data.dwPID = (DWORD)this->rstates;
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     * 3 for DX7 devices.
     */

    CALL_HALONLY(ret, this, ContextCreate, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR( "Driver did not handle ContextCreate" );
        return (DDERR_GENERIC);
    }
    this->dwhContext = data.dwhContext;

    if (D3DMalloc ((void**)&this->lpwDPBufferAlloced,
                   max(dwD3DTriBatchSize*4*sizeof(WORD),
                       dwHWBufferSize) +32) != DD_OK)
    {
        D3D_ERR( "Out of memory in DeviceCreate" );
        return (DDERR_OUTOFMEMORY);
    }
    this->lpwDPBuffer = (LPWORD) (((DWORD) this->lpwDPBufferAlloced+31) & (~31));

    // save the surface handle for later checks
    this->hSurfaceTarget = ((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->lpSurfMore->dwSurfaceHandle;

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", data.dwhContext);

    return (D3D_OK);
}
#else
    /*
     * On NT the kernel code creates the buffer to be used
     * for DrawPrim batching and returns it as extra data
     * in the ContextCreate request.
     */
HRESULT DIRECT3DDEVICEI::halCreateContext()
{
    D3DNTHAL_CONTEXTCREATEI ntData;
    D3DHAL_CONTEXTCREATEDATA *lpData =
        (D3DHAL_CONTEXTCREATEDATA *)&ntData;
    HRESULT ret;

    D3D_INFO(6, "in halCreateContext. Creating Context for driver = %08lx", this);

    /*
     * AnanKan: Assert here that the D3DNTHAL_CONTEXTCREATEI structure is
     * 2 DWORDS bigger than D3DHAL_CONTEXTCREATEDATA. This will be a good
     * consistency check for NT kernel updates.
     */
    memset(&ntData, 0, sizeof(ntData));
    if (IS_DX7HAL_DEVICE(this) || (dwFEFlags & D3DFE_REALHAL))
    {
        if (this->lpDD)
            lpData->lpDDLcl = ((LPDDRAWI_DIRECTDRAW_INT)(this->lpDD))->lpLcl;
        else
            lpData->lpDDLcl = NULL;

        if (lpDDSTarget)
            lpData->lpDDSLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSTarget)->lpLcl;
        else
            lpData->lpDDSLcl = NULL;

        if (lpDDSZBuffer)
            lpData->lpDDSZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)lpDDSZBuffer)->lpLcl;
        else
            lpData->lpDDSZLcl = NULL;

    }
    else
    {
        lpData->lpDDGbl = lpDDGbl;
        lpData->lpDDS = lpDDSTarget;
        lpData->lpDDSZ = lpDDSZBuffer;
    }

    // Hack Alert!! dwhContext is used to inform the driver which version
    // of the D3D interface is calling it.
    lpData->dwhContext = 3;
    lpData->dwPID = GetCurrentProcessId();
    // Hack Alert!! ddrval is used to inform the driver which driver type
    // the runtime thinks it is (DriverStyle registry setting)
    lpData->ddrval = this->deviceType;

    if (IS_HW_DEVICE(this))
    {
        // The new software rasterizers want to share IM's state vector so
        // we need to pass them the rstates pointer.  They don't
        // care about dwPID so stick the pointer in there.
        lpData->dwPID = (DWORD)((ULONG_PTR)this->rstates);
    }

    /* 0 for pre-DX5 devices.
     * 1 for DX5 devices.
     * 2 for DX6 devices.
     * 3 for DX7 devices.
     */
    ntData.cjBuffer = this->dwDPBufferSize;
    ntData.pvBuffer = NULL;

    CALL_HALONLY(ret, this, ContextCreate, lpData);
    if (ret != DDHAL_DRIVER_HANDLED || lpData->ddrval != DD_OK) {
        D3D_ERR( "Driver did not handle ContextCreate" );
        return (DDERR_GENERIC);
    }
    this->dwhContext = (DWORD)((ULONG_PTR)lpData->dwhContext);

    // If the this chose not to allocate a DrawPrim buffer do
    // it for them.
    if (ntData.pvBuffer == NULL)
    {
        this->dwDPBufferSize =
            dwD3DTriBatchSize * 4 * sizeof(WORD);
        if (this->dwDPBufferSize < dwHWBufferSize)
        {
            this->dwDPBufferSize = dwHWBufferSize;
        }

        ret = D3DMalloc((void**)&this->lpwDPBufferAlloced,
                        this->dwDPBufferSize + 32);
        if (ret != DD_OK)
        {
            return ret;
        }

        ntData.pvBuffer = (LPVOID)
            (((ULONG_PTR)this->lpwDPBufferAlloced + 31) & ~31);
        ntData.cjBuffer = this->dwDPBufferSize + 32 -
            (DWORD)((ULONG_PTR)ntData.pvBuffer -
                    (ULONG_PTR)this->lpwDPBufferAlloced);
    }
    else if( (this->dwDPBufferSize &&
              ntData.cjBuffer < this->dwDPBufferSize) ||
             ntData.cjBuffer < sizeof(D3DHAL_DRAWPRIMCOUNTS) )
    {
        D3D_ERR( "Driver did not correctly allocate DrawPrim buffer");
        return (DDERR_GENERIC);
    }

    // Need to save the buffer space provided and its size
    this->lpwDPBuffer = (LPWORD)ntData.pvBuffer;

    // save the surface handle for later checks
    this->hSurfaceTarget = (DWORD)(((LPDDRAWI_DDRAWSURFACE_INT)this->lpDDSTarget)->lpLcl->hDDSurface);

    D3D_INFO(6, "in halCreateContext. Succeeded. dwhContext = %d", lpData->dwhContext);

    return (D3D_OK);
}
#endif  //WIN95

void halDestroyContext(LPDIRECT3DDEVICEI lpDevI)
{
    D3DHAL_CONTEXTDESTROYDATA data;
    HRESULT ret;

    D3D_INFO(6, "in halCreateDestroy. Destroying Context for driver = %08lx", lpDevI);
    D3D_INFO(6, "                     dwhContext = %d", lpDevI->dwhContext);

    if(lpDevI->dwhContext!=NULL) {
        memset(&data, 0, sizeof(D3DHAL_CONTEXTDESTROYDATA));
        data.dwhContext = lpDevI->dwhContext;

        CALL_HALONLY(ret, lpDevI, ContextDestroy, &data);
        if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
            D3D_WARN(0,"Failed ContextDestroy HAL call in halDestroyContext");
            return;
        }
    }
}
//---------------------------------------------------------------------
HRESULT D3DFE_Create(LPDIRECT3DDEVICEI lpDevI,
                     LPDIRECTDRAW lpDD,
                     LPDIRECTDRAW7 lpDD7,
                     LPDIRECTDRAWSURFACE lpDDS,
                     LPDIRECTDRAWSURFACE lpZ,
                     LPDIRECTDRAWPALETTE lpPal)
{
    DDSURFACEDESC ddsd;
    HRESULT hr;
    LPD3DHAL_GLOBALDRIVERDATA lpGlob;

    /*
     * Allocate and check validity of DirectDraw surfaces
     */

    lpDevI->lpDD = lpDD;
    lpDevI->lpDDGbl = ((LPDDRAWI_DIRECTDRAW_INT)lpDD)->lpLcl->lpGbl;
    lpDevI->lpDDSTarget = lpDDS;

    // Get DDS7 Interfaces for RenderTarget/ZBuffer

    HRESULT ret = lpDDS->QueryInterface(IID_IDirectDrawSurface7, (LPVOID*)&lpDevI->lpDDSTarget_DDS7);

    if(FAILED(ret)) {
          D3D_ERR("QI for RenderTarget DDS7 Interface failed ");
          return ret;
    }

    if(lpZ!=NULL) {
        ret = lpZ->QueryInterface(IID_IDirectDrawSurface7, (LPVOID*)&lpDevI->lpDDSZBuffer_DDS7);

        if(FAILED(ret)) {
              D3D_ERR("QI for ZBuffer DDS7 Interface failed ");

              return ret;
        }
        lpDevI->lpDDSZBuffer_DDS7->Release();
    }

    LPD3DHAL_D3DEXTENDEDCAPS lpCaps = lpDevI->lpD3DExtendedCaps;
    if (NULL == lpCaps || 0.0f == lpCaps->dvExtentsAdjust)
    {
        lpDevI->dvExtentsAdjust = 1.0f;
    }
    else
    {
        lpDevI->dvExtentsAdjust = lpCaps->dvExtentsAdjust;
    }
    lpDevI->dwClipMaskOffScreen = 0xFFFFFFFF;
    if (lpCaps != NULL)
    {
        if (lpCaps->dvGuardBandLeft   != 0.0f ||
            lpCaps->dvGuardBandRight  != 0.0f ||
            lpCaps->dvGuardBandTop    != 0.0f ||
            lpCaps->dvGuardBandBottom != 0.0f)
        {
            lpDevI->dwDeviceFlags |= D3DDEV_GUARDBAND;
            lpDevI->dwClipMaskOffScreen = ~__D3DCLIP_INGUARDBAND;
            DWORD v;
            if (GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) &&
                v != 0)
            {
                lpDevI->dwDeviceFlags &= ~D3DDEV_GUARDBAND;
                lpDevI->dwClipMaskOffScreen = 0xFFFFFFFF;
            }
#if DBG
            // Try to get test values for the guard band
            char value[80];
            if (GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandLeft);
            if (GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandRight);
            if (GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandTop);
            if (GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
                value[0] != 0)
                sscanf(value, "%f", &lpCaps->dvGuardBandBottom);
#endif // DBG
        }
    }

    if (!lpDevI->lpD3DHALCallbacks || ! lpDevI->lpD3DHALGlobalDriverData)
    {
        return DDERR_INVALIDOBJECT;
    }

    if (IS_HW_DEVICE(lpDevI))
    {
        // We do texture management (and hence clipped Blts) only for a real HAL.
        hr = lpDD7->CreateClipper(0, &lpDevI->lpClipper, NULL);
        if(hr != DD_OK)
        {
            D3D_ERR("Failed to create a clipper");
            return hr;
        }
    }
    else
    {
        lpDevI->lpClipper = 0;
    }

    lpGlob = lpDevI->lpD3DHALGlobalDriverData;

    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpZ)
    {
        if ((hr = lpZ->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on z");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "Z buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "Z buffer is in video memory.");
        }
        else
        {
            D3D_ERR("Z buffer not in video or system?");
        }
    }
    memset(&ddsd, 0, sizeof(DDSURFACEDESC));
    ddsd.dwSize = sizeof(DDSURFACEDESC);
    if (lpDDS)
    {
        if ((hr = lpDDS->GetSurfaceDesc(&ddsd)) != DD_OK)
        {
            D3D_ERR("Failed to getsurfacedesc on back buffer");
            return hr;
        }
        if (ddsd.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            D3D_INFO(1, "back buffer is in system memory.");
        }
        else if (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            D3D_INFO(1, "back buffer is in video memory.");
        }
        else
        {
            D3D_ERR("back buffer not in video or system?");
        }
        if (!(lpGlob->hwCaps.dwDeviceRenderBitDepth &
              BitDepthToDDBD(ddsd.ddpfPixelFormat.dwRGBBitCount)))
        {
            D3D_ERR("Rendering surface's RGB bit count not supported "
                    "by hardware device");
            return DDERR_INVALIDOBJECT;
        }
    }

    if (lpGlob->dwNumVertices
        && lpGlob->dwNumClipVertices < D3DHAL_NUMCLIPVERTICES)
    {
        D3D_ERR("In global driver data, dwNumClipVertices "
                "< D3DHAL_NUMCLIPVERTICES");
        lpGlob->dwNumClipVertices = D3DHAL_NUMCLIPVERTICES;
    }

    if ((hr = CalcDDSurfInfo(lpDevI,TRUE)) != DD_OK)
    {
        return hr;
    }

    RESET_HAL_CALLS(lpDevI);

    /*
     * Create our context in the HAL driver
     */
    if ((hr = lpDevI->halCreateContext()) != D3D_OK)
    {
        return hr;
    }
// Initialize the transform and lighting state
    D3DMATRIXI m;
    setIdentity(&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_VIEW, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_PROJECTION, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD,  (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD1, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD2, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_WORLD3, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE0, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE1, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE2, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE3, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE4, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE5, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE6, (D3DMATRIX*)&m);
    lpDevI->SetTransformI(D3DTRANSFORMSTATE_TEXTURE7, (D3DMATRIX*)&m);

    LIST_INITIALIZE(&lpDevI->specular_tables);
    lpDevI->specular_table = NULL;

    lpDevI->lightVertexFuncTable = &lightVertexTable;
    lpDevI->lighting.activeLights = NULL;

    lpDevI->iClipStatus = D3DSTATUS_DEFAULT;
    lpDevI->rExtents.x1 = D3DVAL(2048);
    lpDevI->rExtents.x2 = D3DVAL(0);
    lpDevI->rExtents.y1 = D3DVAL(2048);
    lpDevI->rExtents.y2 = D3DVAL(0);

    return S_OK;
}

void D3DFE_Destroy(LPDIRECT3DDEVICEI lpDevI)
{
// Destroy lighting data

    SpecularTable *spec;
    SpecularTable *spec_next;

    for (spec = LIST_FIRST(&lpDevI->specular_tables); spec; spec = spec_next)
    {
        spec_next = LIST_NEXT(spec,list);
        D3DFree(spec);
    }

    if(lpDevI->lpClipper)
    {
        lpDevI->lpClipper->Release();
    }

    delete [] lpDevI->m_pLights;

    if (lpDevI->lpD3DHALCallbacks) {
        halDestroyContext(lpDevI);
    }

#ifdef TRACK_HAL_CALLS
    D3D_INFO(0, "Made %d HAL calls", lpDevI->hal_calls);
#endif
}

void BltFillRects(LPDIRECT3DDEVICEI lpDevI, DWORD count, LPD3DRECT rect, D3DCOLOR dwFillColor)
{
    LPDIRECTDRAWSURFACE lpDDS = lpDevI->lpDDSTarget;
    HRESULT ddrval;
    DDBLTFX bltfx;
    RECT tr;
    DWORD i;
    DWORD r, g, b, a;

    // Fill with background color

    memset(&bltfx, 0, sizeof(bltfx));
    bltfx.dwSize = sizeof(bltfx);

// unlike clear callback, which just takes pure 32-bit ARGB word and forces the driver to scale it for
// the pixelformat, here we need to compute the exact fill word, depending on surface's R,G,B bitmasks

    if(lpDevI->bDDSTargetIsPalettized)
    {
         // map 24-bit color to 8-bit index used by 8bit RGB rasterizer
         CallRastService(lpDevI, RAST_SERVICE_RGB8COLORTOPIXEL, dwFillColor, &bltfx.dwFillColor);
    }
    else
    {
        DDASSERT((lpDevI->red_scale!=0)&&(lpDevI->green_scale!=0)&&(lpDevI->blue_scale!=0));
        r = RGB_GETRED(dwFillColor) / lpDevI->red_scale;
        g = RGB_GETGREEN(dwFillColor) / lpDevI->green_scale;
        b = RGB_GETBLUE(dwFillColor) / lpDevI->blue_scale;
        bltfx.dwFillColor = (r << lpDevI->red_shift) | (g << lpDevI->green_shift) | (b << lpDevI->blue_shift);
        if( lpDevI->alpha_scale!=0 )
        {
            a = RGBA_GETALPHA(dwFillColor) / lpDevI->alpha_scale;
            bltfx.dwFillColor |= (a << lpDevI->alpha_shift);
        }
    }

    for (i = 0; i < count; i++,rect++) {
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDDS->Blt(&tr, NULL, NULL, DDBLT_COLORFILL, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

void BltFillZRects(LPDIRECT3DDEVICEI lpDevI, unsigned long Zpixel,
                    DWORD count, LPD3DRECT rect, DWORD dwWriteMask)
{
    HRESULT ddrval;
    DDBLTFX bltfx;
    DWORD i;
    RECT tr;
    DWORD dwExtraFlags=0;

#if DBG
    if (lpDevI->lpDDSZBuffer == NULL)  // should be checked prior to call
        return;
#endif

    memset(&bltfx, 0, sizeof(DDBLTFX));
    bltfx.dwSize = sizeof(DDBLTFX);
    bltfx.dwFillDepth = Zpixel;

    // hack to pass DepthBlt WriteMask through ddraw/ddhel to blitlib
    if(dwWriteMask!=0) {
        bltfx.dwZDestConstBitDepth=dwWriteMask;
        dwExtraFlags = DDBLT_DEPTHFILLWRITEMASK;
    }

    for(i=0;i<count;i++,rect++) {
        D3D_INFO(4, "Z Clearing x1 = %d, y1 = %d, x2 = %d, y2 = %d, WriteMask %X", rect->x1, rect->y1, rect->x2, rect->y2, bltfx.dwReserved);
        tr.left = rect->x1;
        tr.right = rect->x2;
        tr.top = rect->y1;
        tr.bottom = rect->y2;
        do {
            ddrval = lpDevI->lpDDSZBuffer->Blt(&tr, NULL, NULL, DDBLT_DEPTHFILL | dwExtraFlags, &bltfx);
        } while (ddrval == DDERR_WASSTILLDRAWING);
    }
}

//---------------------------------------------------------------------
struct CHandle
{
    DWORD   m_Next;     // Used to make list of free handles
#if DBG
    DWORD   m_Tag;      // 1 - empty; 2 = taken
#endif
};

CHandleFactory::~CHandleFactory()
{
    if (m_Handles)
        delete m_Handles;
}

HRESULT CHandleFactory::Init(DWORD dwInitialSize, DWORD dwGrowSize)
{
    m_Handles = CreateHandleArray(dwInitialSize);
    if (m_Handles == NULL)
        return DDERR_OUTOFMEMORY;
    m_dwArraySize = dwInitialSize;
    m_dwGrowSize = dwGrowSize;
    m_Free = 0;
    return D3D_OK;
}

DWORD CHandleFactory::CreateNewHandle()
{
    DWORD handle = m_Free;
    if (m_Free != __INVALIDHANDLE)
    {
        m_Free = m_Handles[m_Free].m_Next;
    }
    else
    {
        handle = m_dwArraySize;
        m_Free = m_dwArraySize + 1;
        m_dwArraySize += m_dwGrowSize;
        CHandle * newHandles = CreateHandleArray(m_dwArraySize);
#if DBG
        memcpy(newHandles, m_Handles,
               (m_dwArraySize - m_dwGrowSize)*sizeof(CHandle));
#endif
        delete m_Handles;
        m_Handles = newHandles;
    }
    DDASSERT(m_Handles[handle].m_Tag == 1);
#if DBG
    m_Handles[handle].m_Tag = 2;    // Mark as taken
#endif
    return handle;
}

void CHandleFactory::ReleaseHandle(DWORD handle)
{
    DDASSERT(handle < m_dwArraySize);
    DDASSERT(m_Handles[handle].m_Tag == 2);
#if DBG
    m_Handles[handle].m_Tag = 1;    // Mark as empty
#endif

    m_Handles[handle].m_Next = m_Free;
    m_Free = handle;
}

CHandle* CHandleFactory::CreateHandleArray(DWORD dwSize)
{
    CHandle *handles = new CHandle[dwSize];
    DDASSERT(handles != NULL);
    if ( NULL == handles ) return NULL;
    for (DWORD i=0; i < dwSize; i++)
    {
        handles[i].m_Next = i+1;
#if DBG
        handles[i].m_Tag = 1;   // Mark as empty
#endif
    }
    handles[dwSize-1].m_Next = __INVALIDHANDLE;
    return handles;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\object.h ===
/*
 * $Id: object.h,v 1.2 1995/06/21 12:38:55 sjl Exp $
 *
 * Copyright (c) Microsoft Corp. 1993-1997
 * Version 1.1
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#ifndef _OBJECT_H_
#define _OBJECT_H_

#include <stdlib.h>

#ifdef _WIN32
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#include "d3dcom.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Data structures
 */
#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
struct ID3DObject;
typedef struct ID3DObject   *LPD3DOBJECT;

#else

typedef struct ID3DObject   *LPD3DOBJECT;

#endif

/*
 * ID3DObject
 */
#undef INTERFACE
#define INTERFACE ID3DObject
DECLARE_INTERFACE(ID3DObject)
{
    /*
     * ID3DObject methods
     */
    STDMETHOD(Initialise) (THIS_ LPVOID arg) PURE;
    STDMETHOD(Destroy) (THIS_ LPVOID arg) PURE;
};

#ifdef __cplusplus
};
#endif

#endif /* _OBJECT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\halscene.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   halscene.c
 *  Content:    Direct3D HAL scene capture
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/12/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

HRESULT D3DHAL_SceneCapture(LPDIRECT3DDEVICEI lpDevI,
                            BOOL bState)
{
    D3DHAL_SCENECAPTUREDATA data;
    HRESULT ret;

    if (!lpDevI->lpD3DHALCallbacks->SceneCapture) {
        return (D3D_OK);
    }

    D3D_INFO(6, "SceneCapture, setting %d dwhContext = %d",
             bState, lpDevI->dwhContext);

    memset(&data, 0, sizeof(D3DHAL_SCENECAPTUREDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwFlag = bState ? D3DHAL_SCENE_CAPTURE_START : D3DHAL_SCENE_CAPTURE_END;

    CALL_HALONLY(ret, lpDevI, SceneCapture, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle SceneCapture");
        return (data.ddrval);
    }

    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\init.c ===
#define INITGUID

#include <objbase.h>
DEFINE_GUID( IID_IDirectDrawSurfaceNew, 0x1bab8e96,0x9cfe,0x4ce3,0xbc,0x72,0xd7,0xe9,0xe9,0x9a,0x21,0x75 );
#include <d3dp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\haltex.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   haltex.c
 *  Content:    Direct3D HAL texture handling
 *@@BEGIN_MSINTERNAL
 *
 *  $Id: haltex.c,v 1.1 1995/11/21 15:12:43 sjl Exp $
 *
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   07/11/95   stevela Initial rev.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/*
 * Texture functionality is not emulated.
 */

HRESULT D3DHAL_TextureCreate(LPDIRECT3DDEVICEI lpDevI,
                             LPD3DTEXTUREHANDLE lphTex,
                             LPDIRECTDRAWSURFACE lpDDS)
{
    D3DHAL_TEXTURECREATEDATA data;
    HRESULT ret;

    if (!lpDevI->lpD3DHALCallbacks->TextureCreate) {
        D3D_ERR("TextureCreate called, but no texture support.");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    memset(&data, 0, sizeof(D3DHAL_TEXTURECREATEDATA));
    data.dwhContext = lpDevI->dwhContext;

    data.lpDDS = lpDDS;

    D3D_INFO(6, "TextureCreate, creating texture dwhContext = %08lx, lpDDS = %08lx",
        data.dwhContext, data.lpDDS);

    CALL_HALONLY(ret, lpDevI, TextureCreate, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle TextureCreate");
        return (D3DERR_TEXTURE_CREATE_FAILED);
    }

    *lphTex = data.dwHandle;
    D3D_INFO(6, "TextureCreate, created texture hTex = %08lx", data.dwHandle);
    return (D3D_OK);
}

HRESULT D3DHAL_TextureDestroy(LPD3DI_TEXTUREBLOCK lpBlock)
{
    LPDIRECT3DDEVICEI lpDevI=lpBlock->lpDevI;
    D3DTEXTUREHANDLE  hTex=lpBlock->hTex;

    DDASSERT(!IS_DX7HAL_DEVICE(lpDevI));

    if (!(lpDevI->lpD3DHALCallbacks->TextureDestroy))
    {
        D3D_ERR("TextureDestroy called, but no texture support.");
        return (D3DERR_TEXTURE_NO_SUPPORT);
    }

    // The following code ensures that before we ask the driver to unmap
    // the texture, we set the stages to NULL if the texture is still present
    // in any stage. This is probably not necessary, but we are just trying
    // to be extra cautious here. The CAVEAT here is that it is possible that
    // D3DHAL_TextureDestroy() is being called from DestroyDevice() and hence
    // IT COULD BE REALLY BAD TO BATCH additional commands to the device at
    // this stage. (snene - 3/2/98)
    BOOL bNeedFlush = FALSE;
    if (IS_DP2HAL_DEVICE(lpDevI)) {
        int dwStage;
        CDirect3DDeviceIDP2 *dp2dev = static_cast<CDirect3DDeviceIDP2 *>(lpDevI);

        // Find out the first stage with hTex and NULL out all the stages after
        for (dwStage=0;dwStage<(int)lpDevI->dwMaxTextureBlendStages; dwStage++)
        {
            if (hTex == lpDevI->tsstates[dwStage][D3DTSS_TEXTUREMAP])
            {
                // We need to do this backwards because we cannot have a texture bound to
                // stage i + 1 when there is no texture bound to stage i.
                for(int iCurStage=lpDevI->dwMaxTextureBlendStages-1; iCurStage>=dwStage; iCurStage--)
                {
                    if (lpDevI->tsstates[iCurStage][D3DTSS_TEXTUREMAP] != 0)
                    {
                        dp2dev->SetTSSI(iCurStage, (D3DTEXTURESTAGESTATETYPE)D3DTSS_TEXTUREMAP, 0);
                        bNeedFlush = TRUE;
                    }
                }
                break;
            }
        }
    }
    if (lpDevI->rstates[D3DRENDERSTATE_TEXTUREHANDLE] == hTex)
    {
        lpDevI->rstates[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
        lpDevI->SetRenderStateI(D3DRENDERSTATE_TEXTUREHANDLE, 0);
        bNeedFlush = TRUE;
    }

    // Make sure that we send down the command immediately to guarantee
    // that the driver gets it before we call it with Destroy
    if(bNeedFlush)
    {
        if(lpDevI->FlushStates())
        {
            D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
        }
    }
    else // Now we decide whether to flush due to a referenced texture in the batch or not
    {
        if(lpDevI->m_qwBatch <= ((LPDDRAWI_DDRAWSURFACE_INT)(lpBlock->lpD3DTextureI->lpDDS))->lpLcl->lpSurfMore->qwBatch.QuadPart)
        {
            if(lpDevI->FlushStates())
            {
                D3D_ERR("Error trying to render batched commands in D3DHAL_TextureDestroy");
            }
        }
    }

    D3DHAL_TEXTUREDESTROYDATA data;
    HRESULT ret;
    memset(&data, 0, sizeof(D3DHAL_TEXTUREDESTROYDATA));
    data.dwhContext = lpDevI->dwhContext;
    data.dwHandle = hTex;
    
    D3D_INFO(6, "TextureDestroy, destroying texture dwhContext = %08lx, hTex = %08lx",
        data.dwhContext, hTex);
    
    CALL_HALONLY(ret, lpDevI, TextureDestroy, &data);
    if (ret != DDHAL_DRIVER_HANDLED || data.ddrval != DD_OK) {
        D3D_ERR("HAL failed to handle TextureDestroy");
        return (D3DERR_TEXTURE_DESTROY_FAILED);
    }

    D3D_INFO(6, "TextureDestroy, destroyed texture hTex = %08lx", hTex);
    lpBlock->hTex=0;
    return (D3D_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\hwprov.cpp ===
/*
 *
 * Copyright (c) Microsoft Corp. 1997
 *
 * All rights reserved.
 *
 * This file contains private, unpublished information and may not be
 * copied in part or in whole without express permission of
 * Microsoft Corp.
 *
 */

#include "pch.cpp"
#pragma hdrstop
#include <hwprov.h>

#define nullPrimCaps {                          \
    sizeof(D3DPRIMCAPS), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0          \
}                                               \

#define nullLightCaps {                         \
    sizeof(D3DLIGHTINGCAPS), 0, 0, 0 \
}

#define transformCaps { sizeof(D3DTRANSFORMCAPS), D3DTRANSFORMCAPS_CLIP }

#define THIS_MODEL D3DLIGHTINGMODEL_RGB

#define lightingCaps {                                                  \
        sizeof(D3DLIGHTINGCAPS),                                        \
        (D3DLIGHTCAPS_POINT                                             \
         | D3DLIGHTCAPS_SPOT                                            \
         | D3DLIGHTCAPS_DIRECTIONAL),                                   \
        THIS_MODEL,                     /* dwLightingModel */           \
        0,                              /* dwNumLights (infinite) */    \
}

/*
 * Software Driver caps
 */

static D3DDEVICEDESC7 devDesc =
{
    D3DDEVCAPS_FLOATTLVERTEX,   /* devCaps */
    nullPrimCaps,               /* lineCaps */
    nullPrimCaps,               /* triCaps */
    0,                          /* dwDeviceRenderBitDepth */
    0                           /* dwDeviceZBufferBitDepth */
};

//----------------------------------------------------------------------------
//
// HwHalProvider::QueryInterface
//
// Internal interface, no need to implement.
//
//----------------------------------------------------------------------------

STDMETHODIMP HwHalProvider::QueryInterface(THIS_ REFIID riid, LPVOID* ppvObj)
{
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::AddRef
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::AddRef(THIS)
{
    return 1;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::Release
//
// Static implementation, no real refcount.
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) HwHalProvider::Release(THIS)
{
    return 0;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCaps
//
// Returns the HAL caps.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetCaps(LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion)
{
    D3DDeviceDescConvert(pHwDesc,
                         &pDdGbl->lpD3DGlobalDriverData->hwCaps,
                         pDdGbl->lpD3DExtendedCaps);
    *pHelDesc = devDesc;

    // Since this is HAL, it can atleast rasterize in HW
    pHwDesc->dwDevCaps |= D3DDEVCAPS_HWRASTERIZATION;

    // Set D3DPRASTERCAPS_WFOG, texture op caps and texture stage caps
    // for legacy hal drivers off device7.
    LPD3DHAL_CALLBACKS3 lpD3DHALCallbacks3 =
        (LPD3DHAL_CALLBACKS3)pDdGbl->lpD3DHALCallbacks3;
    if (dwVersion >= 3 &&
        (lpD3DHALCallbacks3 == NULL || lpD3DHALCallbacks3->DrawPrimitives2 == NULL))
    {
        pHwDesc->dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_WFOG;
        D3D_INFO(2, "Setting D3DPRASTERCAPS_WFOG for legacy HAL driver off Device7");

        pHwDesc->dwMaxAnisotropy = 1;
        pHwDesc->wMaxTextureBlendStages = 1;
        pHwDesc->wMaxSimultaneousTextures = 1;
        D3D_INFO(2, "Setting texture stage state info for legacy HAL driver off Device7");


        pHwDesc->dwTextureOpCaps = D3DTEXOPCAPS_DISABLE;
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECAL) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_COPY))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_SELECTARG1;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATE) ||
            (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_MODULATEALPHA))
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_MODULATE;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_ADD)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_ADD;
        }
        if (pHwDesc->dpcTriCaps.dwTextureBlendCaps & D3DPTBLENDCAPS_DECALALPHA)
        {
            pHwDesc->dwTextureOpCaps |= D3DTEXOPCAPS_BLENDTEXTUREALPHA;
        }
        D3D_INFO(2, "Setting textureop caps for legacy HAL driver off Device7");

        // map texture filter operations to DX6 set
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_NEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFPOINT;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MINFLINEAR;
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MAGFLINEAR;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_MIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFPOINT;
        }
        if ((pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPNEAREST) ||
            (pHwDesc->dpcTriCaps.dwTextureFilterCaps & D3DPTFILTERCAPS_LINEARMIPLINEAR))
        {
            pHwDesc->dpcTriCaps.dwTextureFilterCaps |= D3DPTFILTERCAPS_MIPFLINEAR;
        }
        D3D_INFO(2, "Setting texturefilter caps for legacy HAL driver off Device7");
    }

#ifdef __POINTSPRITES   // may need this for DX8
    // DX6 drivers will handle DrawPrim2 and will be setting extended caps, but
    // won't be setting dvMaxPointSize yet.  Therefore, dvMaxPointSize will be 0
    // from DDraw's initial clear of lpD3DExtendedCaps.
    if ((dwVersion >= 3) && (pHwDesc->dvMaxPointSize == 0.0f))
    {
        // set max point size to pre-DX7 1.0f
        pHwDesc->dvMaxPointSize = 1.0f;
        D3D_INFO(2, "Setting dvMaxPointSize cap for legacy HAL driver off Device7");
    }
#endif

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// HwHalProvider::GetCallbacks
//
// Returns the HAL callbacks in the given DDraw global.
//
//----------------------------------------------------------------------------

STDMETHODIMP
HwHalProvider::GetInterface(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion)
{
    pInterfaceData->pGlobalData = pDdGbl->lpD3DGlobalDriverData;
    pInterfaceData->pExtCaps = pDdGbl->lpD3DExtendedCaps;
    pInterfaceData->pCallbacks  = pDdGbl->lpD3DHALCallbacks;
    pInterfaceData->pCallbacks2 = pDdGbl->lpD3DHALCallbacks2;

    pInterfaceData->pCallbacks3 = pDdGbl->lpD3DHALCallbacks3;

    if( pDdGbl->lpDDCBtmp )
        pInterfaceData->pfnGetDriverState =
            pDdGbl->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState;
    else
        pInterfaceData->pfnGetDriverState = NULL;

    return S_OK;
}

//----------------------------------------------------------------------------
//
// GetHwHalProvider
//
// Returns the hardware HAL provider.
//
//----------------------------------------------------------------------------

static HwHalProvider g_HwHalProvider;

STDAPI
GetHwHalProvider(REFIID riid, IHalProvider **ppHalProvider, HINSTANCE *phDll,  LPDDRAWI_DIRECTDRAW_GBL pDdGbl)
{
    *phDll = NULL;
    if ( (IsEqualIID(riid,IID_IDirect3DHALDevice) ||
          IsEqualIID(riid,IID_IDirect3DTnLHalDevice)) &&
        D3DI_isHALValid(pDdGbl->lpD3DHALCallbacks))
    {
        *ppHalProvider = &g_HwHalProvider;
    }
    else
    {
        *ppHalProvider = NULL;
        return E_NOINTERFACE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\hwprov.h ===
//----------------------------------------------------------------------------
//
// hwprov.h
//
// Base hardware HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _HWPROV_H_
#define _HWPROV_H_

//----------------------------------------------------------------------------
//
// HwHalProvider
//
// Implements the base HAL provider for hardware renderers.
//
//----------------------------------------------------------------------------

class HwHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    // IHalProvider.
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
};

#endif // #ifndef _HWPROV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\subwtype.h ===
#if !defined(_SUBWTYPE_H_) && !defined(__wtypes_h__)
#define _SUBWTYPE_H_

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif // !FALSE
#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
			/* size is 1 */
typedef unsigned char BYTE;

#endif // !_BYTE_DEFINED
#ifndef _WORD_DEFINED
#define _WORD_DEFINED
			/* size is 2 */
typedef unsigned short WORD;

#endif // !_WORD_DEFINED
			/* size is 4 */
typedef /* [transmit] */ unsigned int UINT;

			/* size is 4 */
typedef /* [transmit] */ int INT;

			/* size is 4 */
typedef long BOOL, *LPBOOL;

#ifndef _LONG_DEFINED
#define _LONG_DEFINED
			/* size is 4 */
typedef long LONG;

#endif // !_LONG_DEFINED
#ifndef _WPARAM_DEFINED
#define _WPARAM_DEFINED
			/* size is 4 */
typedef UINT WPARAM;

#endif // _WPARAM_DEFINED
#ifndef _DWORD_DEFINED
#define _DWORD_DEFINED
			/* size is 4 */
typedef unsigned long DWORD;

#endif // !_DWORD_DEFINED
#ifndef _LPARAM_DEFINED
#define _LPARAM_DEFINED
			/* size is 4 */
typedef LONG LPARAM;

#endif // !_LPARAM_DEFINED
#ifndef _LRESULT_DEFINED
#define _LRESULT_DEFINED
			/* size is 4 */
typedef LONG LRESULT;

#endif // !_LRESULT_DEFINED
#ifndef _LPWORD_DEFINED
#define _LPWORD_DEFINED
			/* size is 4 */
typedef WORD *LPWORD;

#endif // !_LPWORD_DEFINED
#ifndef _LPDWORD_DEFINED
#define _LPDWORD_DEFINED
			/* size is 4 */
typedef DWORD *LPDWORD;

#endif // !_LPDWORD_DEFINED
			/* size is 4 */
typedef void*	LPVOID;
typedef void	VOID;

typedef /* [string] */ char *LPSTR;

			/* size is 4 */
typedef /* [string] */ const char *LPCSTR;

			/* size is 1 */
typedef unsigned char UCHAR;

			/* size is 2 */
typedef short SHORT;

			/* size is 2 */
typedef unsigned short USHORT;

			/* size is 4 */
typedef DWORD ULONG;

			/* size is 4 */
typedef LONG HRESULT;

#ifndef GUID_DEFINED
#define GUID_DEFINED
			/* size is 16 */
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    }	GUID;

#endif // !GUID_DEFINED
#if !defined( __LPGUID_DEFINED__ )
#define __LPGUID_DEFINED__
			/* size is 4 */
typedef GUID *LPGUID;

#endif // !__LPGUID_DEFINED__
#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED
#define _OBJECTID_DEFINED
			/* size is 20 */
typedef struct  _OBJECTID
    {
    GUID Lineage;
    unsigned long Uniquifier;
    }	OBJECTID;

#endif // !_OBJECTID_DEFINED
#if !defined( __IID_DEFINED__ )
#define __IID_DEFINED__
			/* size is 16 */
typedef GUID IID;

			/* size is 4 */
typedef IID *LPIID;

#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
			/* size is 16 */
typedef GUID CLSID;

			/* size is 4 */
typedef CLSID *LPCLSID;

#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID &
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID &
#endif // !_REFCLSID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#ifndef _REFIID_DEFINED
#define _REFIID_DEFINED
#define REFIID              const IID * const
#endif // !_REFIID_DEFINED
#ifndef _REFCLSID_DEFINED
#define _REFCLSID_DEFINED
#define REFCLSID            const CLSID * const
#endif // !_REFCLSID_DEFINED
#endif // !__cplusplus
#endif // !__IID_DEFINED__

#endif /* _SUBWTYPE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dxg\d3d\dx7\fe\lists.hpp ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef _LISTS_H
#define _LISTS_H

#define LIST_ROOT(name, type) struct name {type *Root;}

#define LIST_MEMBER(type) struct { type **Prev; type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
    (root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    if ((element)->field.Prev)\
    {\
        *(element)->field.Prev = (element)->field.Next;\
        (element)->field.Prev = 0;\
    }\
    (element)->field.Next = 0;\
}

#define LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   type *First;\
    type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   type *Next;\
    type **Prev;    /* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   type *Last;\
    type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   type *Prev;\
    type *Next;\
}

#define CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
    (root)->Last->field.Next = (element);\
    else\
    (root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
    (root)->First->field.Prev = (element);\
    else\
    (root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
    (current_element)->field.Prev->field.Next = (element);\
    else\
    (root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
    (element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
    (root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
    (element)->field.Prev->field.Next = (element)->field.Next;\
    else\
    (root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CI