eadSrcFormat = FALSE;

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    DC->uStatFrameCount = 0;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

    /* Get the Options
     */
    GetDecoderOptions(DC);

    if (CodecID == H263_CODEC)
    {
        // Notice: Decoder memory is stored in YVU order.  This simplifies 
        //         working with the color converters which use YVU12.  
        // LONG TERM: We may want to change this someday because the encoder 
        //            stores data in YUV order.  Or perhaps the encoder should 
        //            change?

        lOffset =  INSTANCE_DATA_FIXED_SIZE;
        DC->Ticker = 127;

        //instance dependent table here
        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X16_BlkActionStream = lOffset;
        lOffset += u32SizeBlkActionStream;

        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->CurrFrame.X32_YPlane = lOffset;
        lOffset += DC->uSz_YPlane;

        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->CurrFrame.X32_VPlane = lOffset;
        DC->CurrFrame.X32_UPlane = DC->CurrFrame.X32_VPlane + PITCH / 2;
        ASSERT((DC->CurrFrame.X32_UPlane & 0x7) == 0);  // QWORD alignment
        lOffset += DC->uSz_VUPlanes;

        //no padding is needed 
        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PrevFrame.X32_YPlane = lOffset;
        lOffset += DC->uSz_YPlane;

        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PrevFrame.X32_VPlane = lOffset;
        DC->PrevFrame.X32_UPlane = DC->PrevFrame.X32_VPlane + PITCH / 2;
        ASSERT((DC->PrevFrame.X32_UPlane & 0x7) == 0);  // QWORD alignment
        lOffset += DC->uSz_VUPlanes;

        // B Frame
        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PBFrame.X32_YPlane = lOffset;
        lOffset += DC->uSz_YPlane;
                   
        ASSERT((lOffset & 0x7) == 0);                   //  QWORD alignment
        DC->PBFrame.X32_VPlane = lOffset;
        DC->PBFrame.X32_UPlane = DC->PBFrame.X32_VPlane + PITCH / 2;
        ASSERT((DC->PBFrame.X32_UPlane & 0x7) == 0);    // QWORD alignment
        lOffset += DC->uSz_VUPlanes;

        // Bitstream
        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_BitStream = lOffset;
        lOffset += uSizeBitStreamBuffer;
        DC->uSizeBitStreamBuffer = uSizeBitStreamBuffer;

        DC->uMBBuffer = lOffset;
        // MMX IDCT writes its output to (DC->uMBBuffer + BLOCK_BUFFER_OFFSET)
        // and so it must be aligned at QWORD
        ASSERT((( (U32)DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET) & 0x7) == 0);
        lOffset += MB_MC_BUFFER_SIZE;

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_InverseQuant = lOffset; 
        lOffset += u32SizeT_IQ_INDEXBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_pN = lOffset; 
        lOffset += u32SizepNBuffer; 

        ASSERT((lOffset & 0x3) == 0);                   //  DWORD alignment
        DC->X32_uMBInfoStream = lOffset; 
        lOffset += u32SizeMBInfoStream; 

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
		// Decode Timing Info
		DC->X32_DecTimingInfo = lOffset;
		lOffset += (DEC_TIMING_INFO_FRAME_COUNT+4) * sizeof (DEC_TIMING_INFO);
#endif // } LOG_DECODE_TIMINGS_ON

        // init the data
        
        ASSERT((U32)lOffset <= u32TotalSize);
        pInitLimit = (U32  *) (P32Inst + lOffset);
        pInitPtr = (U32  *) (P32Inst + DC->CurrFrame.X32_YPlane);
        for (;pInitPtr < pInitLimit;pInitPtr++)    *pInitPtr =0;

		// Fill the Y,U,V Previous Frame space with black, this way
		// even if we lose an I frame, the background will remain black
		ZeroFill((HPBYTE)P32Inst + DC->PrevFrame.X32_YPlane + Y_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_UPlane + UV_START,
				(HPBYTE)P32Inst + DC->PrevFrame.X32_VPlane + UV_START,           
				PITCH,
				DC->uFrameWidth,
				DC->uFrameHeight);

        // H263InitializeBlockActionStream(DC);

    } // H263

#ifdef NEW_BEF // { NEW_BEF
	// Initialize de-blocking filter
	{
		int i,j;

		for (j = 0; j < 19; j++) {
			for (i = 0; i < 23; i++) {
				coded_map[j][i] = 0;
			}
		}
		InitEdgeFilterTab();
	}	 
#endif // } NEW_BEF

    lpInst->Initialized = TRUE;
    iReturn = ICERR_OK;

done:
    return iReturn;
}

/***********************************************************************
 *  ZeroFill
 *    Fill the YVU data area with black.
 ***********************************************************************/
static void	ZeroFill(HPBYTE hpbY, HPBYTE hpbU, HPBYTE hpbV, int iPitch, U32 uWidth, U32 uHeight)
{
    U32 w,h;
    int y,u,v;
    U32 uNext;
    HPBYTE pY, pU, pV;

    y = 32;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pY = hpbY;
        for (w = 0; w < uWidth ; w++) {
            *hpbY++ = (U8)16;
        }
        hpbY += uNext;
    }
    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8)128;
            *hpbU++ = (U8)128;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
}

/***********************************************************************
 *  TestFill
 *    Fill the YVU data area with a test pattern.
 ***********************************************************************/
#if 0
static void
TestFill(
    HPBYTE hpbY,
    HPBYTE hpbU,
    HPBYTE hpbV,
    int    iPitch,
    U32    uWidth,
    U32    uHeight)
{
    U32 w,h;
    int y,u,v;
    U32 uNext;
    HPBYTE pY, pU, pV;

    y = 32;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pY = hpbY;
        for (w = 0; w < uWidth ; w++) {
            *hpbY++ = (U8) (y + (w & ~0xF));
        }
        hpbY += uNext;
    }
    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    u = 0x4e * 2;
    v = 44;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8) v;
            *hpbU++ = (U8) u;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
} /* end TestFill */
static void
TestFillUV(
    HPBYTE hpbU,
    HPBYTE hpbV,
    int iPitch,
    U32 uWidth,
    U32 uHeight)
{
    U32 w,h;
    int u,v;
    U32 uNext;
    HPBYTE pU, pV;

    uWidth = uWidth / 2;
    uHeight = uHeight / 2;
    u = 128;
    v = 128;
    uNext = iPitch - uWidth;
    for (h = 0 ; h < uHeight ; h++) {
        pV = hpbV;
        pU = hpbU;
        for (w = 0; w < uWidth ; w++) {
            *hpbV++ = (U8) v;
            *hpbU++ = (U8) u;
        }
        hpbV += uNext;
        hpbU += uNext;
    }
} // end TestFill
#endif


/*********************************************************************
 *  H263Decompress
 *    This function drives the decompress and display of one frame
 *********************************************************************/
LRESULT H263Decompress(
    LPDECINST            lpInst, 
    ICDECOMPRESSEX FAR * lpicDecEx, 
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    BOOL                 bIsDCI,
	BOOL				 bRealDecompress)
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    BOOL                 bIsDCI)
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

{
    LRESULT                iReturn = ICERR_ERROR;
    U8 FAR               * fpSrc;
    U8 FAR               * P32Inst;
    U8 FAR               * fpu8MaxPtr;
    LPVOID                 pDecoderInstance = NULL;
    T_H263DecoderCatalog * DC = NULL;
    I32                    iNumberOfGOBs, iNumberOfMBs, iBlockNumber = 0;
    T_BlkAction FAR      * fpBlockAction;
    LONG                   lOutput;
    int                    intPitch; 
    U32                    uNewOffsetToLine0, uNewFrameHeight;
    BOOL                   bShapingFlag, bMirror;
    U32                    uYPitch, uUVPitch;

    T_IQ_INDEX           * pRUN_INVERSE_Q;  
    U32                  * pN;                     
    T_MBInfo FAR         * fpMBInfo;      
    
    U32                    uSaveHeight, uSaveWidth, utemp, uYPlane, uUPlane;
	I32                    uVPlane;
    U8                   * pFrame;

    U32                   uWork;                 //  variables for reading bits
    U32                   uBitsReady; 
    BITSTREAM_STATE       bsState;
    BITSTREAM_STATE FAR * fpbsState = &bsState;
    I32                   gob_start = 1, mb_start = 1, b_skip;
	I8                    p8MVs[4]={0,0,0,0};
#ifdef H263P
	BOOL bTmpPostProcessBEF;
#endif

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32	uDecodeTime = 0;
	U32 uBEFTime = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	U32 uDecIDCTCoeffs = 0;
	U32 uHeaders = 0;
	U32 uMemcpy = 0;
	U32 uFrameCopy = 0;
	U32 uOutputCC = 0;
	U32 uIDCTandMC = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
#endif // } LOG_DECODE_TIMINGS_ON

	FX_ENTRY("H263Decompress");

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	if (bRealDecompress)
	{
		TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
	}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

    // check the input pointers
    if (IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO))||
        IsBadReadPtr((LPVOID)lpicDecEx, sizeof(ICDECOMPRESSEX)))
    {
		ERRORMESSAGE(("%s: Bad input parameter!\r\n", _fx_));
        iReturn = ICERR_BADPARAM;
        goto done;
    }
    
    // Check for a bad length
    if (lpicDecEx->lpbiSrc->biSizeImage == 0) {
		ERRORMESSAGE(("%s: Bad image size!\r\n", _fx_));
        iReturn = ICERR_BADIMAGESIZE;    
        goto done;
    }

    // set local pointer to global memory
    pDecoderInstance = lpInst->pDecoderInst;

    // Set the frame mirroring flag
    bMirror = FALSE;
    if (lpicDecEx->lpbiDst != 0)
    {
        if(lpicDecEx->lpbiSrc->biWidth * lpicDecEx->lpbiDst->biWidth < 0)
            bMirror = TRUE;
    }

    // Build the decoder catalog pointer 
    P32Inst = (U8 FAR *) pDecoderInstance;
    P32Inst = (U8 FAR *) ((((U32) P32Inst) + 31) & ~0x1F);
    DC = (T_H263DecoderCatalog FAR *) P32Inst;

    if (DC->DecoderType == H263_CODEC)
    {

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
		if (bRealDecompress)
		{
			if ((DC->uStatFrameCount <= DEC_TIMING_INFO_FRAME_COUNT) && (DC->ColorConvertor != YUV12ForEnc))
			{
				if (DC->X32_DecTimingInfo > 0)
					DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *)( ((U8 FAR *)P32Inst) + DC->X32_DecTimingInfo );
				DC->uStartLow = uStartLow;
				DC->uStartHigh = uStartHigh;
			}
			else
			{	
				DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *) NULL;
			}
			DC->bTimingThisFrame = bTimingThisFrame;
		}
#endif // } LOG_DECODE_TIMINGS_ON

		// Check if h263test.ini has been used to override custom message
		// for block edge filter. If BlockEdgeFilter is not specified in
		// the [Decode] section of h263test.ini, DC->bUseBlockEdgeFilter 
		// will be set to 2, and the value specified in a custom message
		// will be chosen.
		if (DC->bUseBlockEdgeFilter == 2) {	 
			DC->bUseBlockEdgeFilter = lpInst->bUseBlockEdgeFilter;
		}


        // First check to see if we are just going to return the P frame
        // which we have already decoded.
        
        /*********************************************************************
         *
         *  Hack for the special "Null" P frames for Windows
         *
         *********************************************************************/
        if (lpicDecEx->lpbiSrc->biSizeImage != 8)
        {

            /* Is there room to copy the bitstream data? */
            // OLD: ASSERT(lpicDecEx->lpbiSrc->biSizeImage <= DC->uSizeBitStreamBuffer);
            // RH:  Make sure that the bitstream can be fit in our allocated buffer. If
            // not, return an error.
            
            if ( lpicDecEx->lpbiSrc->biSizeImage > DC->uSizeBitStreamBuffer) {
				ERRORMESSAGE(("%s: Internal buffer (%ld bytes) too small for input data (%ld bytes)!\r\n", _fx_, DC->uSizeBitStreamBuffer, lpicDecEx->lpbiSrc->biSizeImage));
				if (!H263RTP_VerifyBsInfoStream(DC,
					                           (U8 *) lpicDecEx->lpSrc,
					                            lpicDecEx->lpbiSrc->biSizeImage)) 
				{
					ERRORMESSAGE(("%s: Input buffer too big without RTP extention!\r\n", _fx_));
					iReturn = ICERR_ERROR;
                    goto done;
				}
				else
				 lpicDecEx->lpbiSrc->biSizeImage= DC->uSizeBitStreamBuffer;
            }

            // Copy the source data to the bitstream region.
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            fpSrc = (U8 FAR *)(P32Inst + DC->X32_BitStream);
            memcpy((char FAR *)fpSrc, (const char FAR *) lpicDecEx->lpSrc, 
                   lpicDecEx->lpbiSrc->biSizeImage);  

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMemcpy)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            // Initialize the bit stream reader 
            GET_BITS_INIT(uWork, uBitsReady);

//#ifdef LOSS_RECOVERY
            DC->Sz_BitStream = lpicDecEx->lpbiSrc->biSizeImage;
            // H263RTP_VerifyBsInfoStream(DC,fpSrc,DC->Sz_BitStream);
            //RtpForcePacketLoss(fpSrc,lpicDecEx->lpbiSrc->biSizeImage,0);
//#endif    
            //  Initialize pointers to data structures which carry info 
            //  between passes
            pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);
            pN             = (U32 *)(P32Inst + DC->X32_pN);
            fpMBInfo       = (T_MBInfo FAR *) (P32Inst + DC->X32_uMBInfoStream);

            // Initialize block action stream  pointer
            iBlockNumber = 0;
            fpBlockAction = (T_BlkAction FAR *)(P32Inst + DC->X16_BlkActionStream);

            // Decode the Picture Header
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            iReturn = H263DecodePictureHeader(DC, fpSrc, uBitsReady, uWork, 
                                              fpbsState);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uHeaders)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            if (iReturn == PACKET_FAULT) 
            {
				ERRORMESSAGE(("%s: PSC lost!\r\n", _fx_));
                iReturn = RtpGetPicHeaderFromBsExt(DC);
                if (iReturn != ICERR_OK)
                    goto done;

                iReturn = RtpH263FindNextPacket(DC, fpbsState, &pN, 
                              &DC->uPQuant, (int *)&mb_start, (int *)&gob_start,p8MVs);
                if (iReturn == NEXT_MODE_A) 
                {    
                    //trick it for now, do not change without consulting Chad
                    gob_start++;
					mb_start++;  
                    ERRORMESSAGE(("%s: Next packet following lost PSC is in MODE A\r\n", _fx_));
                }
                else if ((iReturn == NEXT_MODE_B) || (iReturn == NEXT_MODE_C))
                {
					int k;
  					if (iReturn == NEXT_MODE_B) 
					{
						k=1;
						ERRORMESSAGE(("%s: Next packet in MODE B\r\n", _fx_));
					}
					else
					{
						ERRORMESSAGE(("%s: Next packet in MODE C\r\n", _fx_));
						k=2;
					}

#ifdef H263P
					// The number of MB's is merely (width / 16)
					iNumberOfMBs = DC->uFrameWidth >> 4;
#else
                    iNumberOfMBs = iNumberOfMBsInAGOBBySourceFormat[DC->uSrcFormat];
#endif

                    b_skip = (gob_start* iNumberOfMBs + mb_start)*6*k;
                    for ( k=0; k < b_skip; k++)  *pN++=0;
                    fpBlockAction += b_skip;
                    iBlockNumber  += b_skip;
                    fpMBInfo  += b_skip/6;
                    mb_start++;
                    gob_start++;
					/*for (k=0;k<6;k++)
					{
						fpBlockAction[k].i8MVx2 = p8MVs[0];
						fpBlockAction[k].i8MVy2 = p8MVs[1];
					} */

                }
                else 
                {
                    iReturn = ICERR_UNSUPPORTED;
                    goto done;
                }
            }
            else
            //old code before merging
            if (iReturn != ICERR_OK)
            {
				ERRORMESSAGE(("%s: Error reading the picture header!\r\n", _fx_));
                goto done;
            }
    
            // Set a limit for testing for bitstream over-run
            fpu8MaxPtr = fpSrc;
            fpu8MaxPtr += (lpicDecEx->lpbiSrc->biSizeImage - 1);  
            
            // Initialize some constants
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
			if (DC->uFrameHeight < 500)
				// Each GOB consists of 16 lines
				iNumberOfGOBs = DC->uFrameHeight >> 4;
			else if (DC->uFrameHeight < 996)
				// Each GOB consists of 32 lines
				iNumberOfGOBs = DC->uFrameHeight >> 5;
			else
				// Each GOB consists of 64 lines
				iNumberOfGOBs = DC->uFrameHeight >> 6;

			iNumberOfMBs = DC->uFrameWidth >> 4;
#else
            iNumberOfGOBs = iNumberOfGOBsBySourceFormat[DC->uSrcFormat];
            iNumberOfMBs = iNumberOfMBsInAGOBBySourceFormat[DC->uSrcFormat];
#endif
            DC->iNumberOfMBsPerGOB = iNumberOfMBs;
            
            /* 
             * Check dimensions:
             *  In H263 a GOB is a single row of MB, and a MB is 16x16 
             */
            ASSERT(((U32)iNumberOfGOBs * 16) == DC->uFrameHeight);
            ASSERT(((U32)iNumberOfMBs * 16) == DC->uFrameWidth);
            
            /*****************************************************************
              FIRST PASS - bitream parsing and IDCT prep work
              ***************************************************************/
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

#ifdef USE_MMX // { USE_MMX
            if (DC->bMMXDecoder)
            {
                __asm {
                    _emit 0x0f 
                    _emit 0x77  //  emms
                }
            }
#endif // } USE_MMX
            iReturn = IAPass1ProcessFrame(DC, 
                                          fpBlockAction, 
                                          fpMBInfo,
                                          fpbsState,
                                          fpu8MaxPtr,
                                          pN,
                                          pRUN_INVERSE_Q,
                                          iNumberOfGOBs,
                                          iNumberOfMBs,
                                          gob_start, 
                                          mb_start);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
                // decode and inverse quantize the transform coefficients
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecIDCTCoeffs)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            if (iReturn != ICERR_OK) {
				ERRORMESSAGE(("%s: Error during first pass - bitream parsing and IDCT prep work!\r\n", _fx_));
                goto done;
            }
            
            /*****************************************************************
              SECOND PASS - IDCT and motion compensation (MC)
              ***************************************************************/
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

            if (DC->bAdvancedPrediction || DC->bUnrestrictedMotionVectors)
            {
                //  Change parameter profile once Bob is finished making
                //  changes to ExpandPlane routine : AG
                ExpandPlane((U32) (P32Inst + DC->PrevFrame.X32_YPlane + Y_START),
                            (U32) (DC->uFrameWidth),
                            (U32) (DC->uFrameHeight), 
                            16); // TODO 16  number of pels to expand by
                
                ExpandPlane((U32) (P32Inst + DC->PrevFrame.X32_VPlane + UV_START),
                            (U32) (DC->uFrameWidth>>1), 
                            (U32) (DC->uFrameHeight>>1), 
                            8); // TODO 8
                
                ExpandPlane((U32) (P32Inst + DC->PrevFrame.X32_UPlane + UV_START),
                            (U32) (DC->uFrameWidth>>1), 
                            (U32) (DC->uFrameHeight>>1), 
                            8);  // TODO 8
            }

            fpBlockAction  = (T_BlkAction FAR *) (P32Inst + DC->X16_BlkActionStream);
            pRUN_INVERSE_Q = (T_IQ_INDEX *)(P32Inst + DC->X32_InverseQuant);  
            pN             = (U32 *)(P32Inst + DC->X32_pN);                               
            fpMBInfo       = (T_MBInfo FAR *)(P32Inst + DC->X32_uMBInfoStream);

            IAPass2ProcessFrame(DC,
                                fpBlockAction,
                                fpMBInfo,
                                pN,
                                pRUN_INVERSE_Q,
                                iNumberOfGOBs,
                                iNumberOfMBs);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uIDCTandMC)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

#ifdef H263P
            if (DC->bDeblockingFilter) {
				// In the loop deblocking filter.
				// Annex J, document LBC-96-358
				// If the filtering is performed inside the loop, we
				// do not also perform a post-process block edge filter.

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
				if (bRealDecompress)
				{
					TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
				}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

				bTmpPostProcessBEF = DC->bUseBlockEdgeFilter;
				DC->bUseBlockEdgeFilter = FALSE;

				EdgeFilter((U8 *)DC + DC->CurrFrame.X32_YPlane + Y_START,
                           (U8 *)DC + DC->CurrFrame.X32_VPlane + UV_START,
                           (U8 *)DC + DC->CurrFrame.X32_UPlane + UV_START,
                           DC->uFrameWidth,
                           DC->uFrameHeight,
                           PITCH);

	            if (DC->bPBFrame) 
				{
					// Filtering of B frames is not a manner of standardization.
					// We do it since we assume that it will yield improved
					// picture quality.
					// TODO, verify this assumption.
					EdgeFilter((U8 *)DC + DC->PBFrame.X32_YPlane + Y_START,
							   (U8 *)DC + DC->PBFrame.X32_VPlane + UV_START,
							   (U8 *)DC + DC->PBFrame.X32_UPlane + UV_START,
							   DC->uFrameWidth,
							   DC->uFrameHeight,
							   PITCH);
				}

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
				if (bRealDecompress)
				{
					TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uBEFTime)
				}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

			} // if (DC->bDeblockingFilter)
#endif // H263P

            //copy to the reference frame to prepare for the next frame
            // Decide which frame to display
            if (DC->bPBFrame)
            {    // Set pointers to return B frame for PB pair
                DC->DispFrame.X32_YPlane = DC->PBFrame.X32_YPlane;
                DC->DispFrame.X32_VPlane = DC->PBFrame.X32_VPlane;
                DC->DispFrame.X32_UPlane = DC->PBFrame.X32_UPlane;
            }
            else 
            { // Set pointers to return future P of PB pair
                DC->DispFrame.X32_YPlane = DC->CurrFrame.X32_YPlane;
                DC->DispFrame.X32_VPlane = DC->CurrFrame.X32_VPlane;
                DC->DispFrame.X32_UPlane = DC->CurrFrame.X32_UPlane;
            }
            
            utemp                    = DC->CurrFrame.X32_YPlane;
            DC->CurrFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
            DC->PrevFrame.X32_YPlane = utemp;
            
            utemp                    = DC->CurrFrame.X32_VPlane ;
            DC->CurrFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
            DC->PrevFrame.X32_VPlane = utemp;
            
            utemp                    = DC->CurrFrame.X32_UPlane ;
            DC->CurrFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
            DC->PrevFrame.X32_UPlane = utemp;
        }
        /*********************************************************************
         *
         *  Hack for the special "Null" P frames for Windows
         *
         *********************************************************************/
        else  //  lpicDecEx->lpbiSrc->biSizeImage == 8
        { // Set pointers to return P frame for PB pair
#ifdef _DEBUG
            if (!DC->bPBFrame)
			{
                ERRORMESSAGE(("%s: Null frame received even though previous was not PB\r\n", _fx_));
            }
#endif
            DC->DispFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
            DC->DispFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
            DC->DispFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
        }
    }  // end of H263_CODEC
    else
    {    // why is this here???  Is it really needed for YUV12 display? 
        DC->DispFrame.X32_YPlane = DC->PrevFrame.X32_YPlane;
        DC->DispFrame.X32_VPlane = DC->PrevFrame.X32_VPlane;
        DC->DispFrame.X32_UPlane = DC->PrevFrame.X32_UPlane;
    }
    
    // Return if there is no need to update screen yet.
    if(lpicDecEx->dwFlags & ICDECOMPRESS_HURRYUP) {
        iReturn = ICERR_DONTDRAW;
        goto done;
    }

    if (DC->ColorConvertor == YUV12ForEnc) 
    {
        /* NOTICE: This color converter reverses the order of the data in 
         *         memory.  The decoder uses YVU order and the encoder uses 
         *         YUV order.
         */
        //  TODO can this be DispFrame ????  Trying to get rid of 
        //  references to PrevFrame and CurrFrame after this point  
        H26x_YUV12ForEnc ((HPBYTE)P32Inst,
                          DC->PrevFrame.X32_YPlane + Y_START,
                          DC->PrevFrame.X32_VPlane + UV_START,
                          DC->PrevFrame.X32_UPlane + UV_START,
                          DC->uFrameWidth,
                          DC->uFrameHeight,
                          PITCH,
                          (HPBYTE)lpicDecEx->lpDst,
                          (DWORD)Y_START,
                          (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START + PITCH / 2,
                          (DWORD)(MAX_HEIGHT + 2L*UMV_EXPAND_Y) * PITCH + 8 + UV_START);
        iReturn = ICERR_OK;
        goto done;
    }

#if 0
    // Fill the Y,U,V Current Frame space with a test pattern
    TestFill((HPBYTE)P32Inst + DC->DispFrame.X32_YPlane + Y_START,
             (HPBYTE)P32Inst + DC->DispFrame.X32_UPlane + UV_START,
             (HPBYTE)P32Inst + DC->DispFrame.X32_VPlane + UV_START,           
                 PITCH,
             DC->uFrameWidth,
             DC->uFrameHeight);
#endif

#if MAKE_GRAY
    // Fill the U,V Current Frame space with a test pattern
    TestFillUV((HPBYTE)P32Inst + DC->DispFrame.X32_UPlane + UV_START,
               (HPBYTE)P32Inst + DC->DispFrame.X32_VPlane + UV_START,           
                   PITCH,
               DC->uFrameWidth,
               DC->uFrameHeight);
#endif

    /* Special case the YVU12 for the encoder because it should not include 
     * BEF, Shaping or aspect ratio correction...
     */

    // Copy Planes to Post Processing area, and block edge filter.
    if (DC->DecoderType == H263_CODEC)
    {
        //  3/5/96: Steve asserted that mirroring is not needed for the remote 
        //  stream (i.e. H263_CODEC)  -a.g.
        //  But I will leave this code in.
        uYPitch  = PITCH;
        uUVPitch = PITCH;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		if (bRealDecompress)
		{
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
		}
#endif // } DETAILED_DECODE_TIMINGS_ON

        if(bMirror) 
        {
            // copy with mirroring
            pFrame  = (U8 *)DC->p16InstPostProcess;
            uYPlane = DC->PostFrame.X32_YPlane;
            uUPlane = DC->PostFrame.X32_UPlane;
            uVPlane = DC->PostFrame.X32_VPlane;

            FrameMirror((U8 *)DC + DC->DispFrame.X32_YPlane + Y_START,
                ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
#ifdef H263P
				DC->uActualFrameHeight,
				DC->uActualFrameWidth,
#else
                DC->uFrameHeight,
                DC->uFrameWidth,
#endif
                PITCH);
            FrameMirror((U8 *)DC + DC->DispFrame.X32_UPlane + UV_START,
                ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
#ifdef H263P
				DC->uActualFrameHeight/2,
				DC->uActualFrameWidth/2,
#else
                DC->uFrameHeight/2,
                DC->uFrameWidth/2,
#endif
                PITCH);
            FrameMirror((U8 *)DC + DC->DispFrame.X32_VPlane + UV_START,
                ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
#ifdef H263P
				DC->uActualFrameHeight/2,
				DC->uActualFrameWidth/2,
#else
                DC->uFrameHeight/2,
                DC->uFrameWidth/2,
#endif
                PITCH);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			if (bRealDecompress)
			{
				TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
			}
#endif // } DETAILED_DECODE_TIMINGS_ON

        }
        else 
        { // no mirroring

            // check for 320x240 still
            if (DC->uIs320x240) {
                // save frame size, set 320 x 240 size, then copy as normal
                uSaveWidth = DC->uFrameWidth;
                uSaveHeight = DC->uFrameHeight;
                DC->uFrameWidth = 320;
                DC->uFrameHeight = 240;

                FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_YPlane + Y_START,
                    ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
                   DC->uFrameHeight,
                   DC->uFrameWidth,
                   PITCH);
                FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_UPlane + UV_START,
                   ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
                   DC->uFrameHeight/2,
                   DC->uFrameWidth/2,
                   PITCH);
                FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_VPlane + UV_START,
                   ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
                   DC->uFrameHeight/2,
                   DC->uFrameWidth/2,
                   PITCH);

                pFrame  = (U8 *)DC->p16InstPostProcess;
                uYPlane = DC->PostFrame.X32_YPlane;
                uUPlane = DC->PostFrame.X32_UPlane;
                uVPlane = DC->PostFrame.X32_VPlane;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
				if (bRealDecompress)
				{
					TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
				}
#endif // } DETAILED_DECODE_TIMINGS_ON

            }
            else
            {
				// Added checks for adjusting video effects. Since pFrame must be
				// set to DC->p16InstPostProcess to call AdjustPels, the FrameCopy
				// must be done.
				if (!(DC->bUseBlockEdgeFilter || DC->bAdjustLuma || DC->bAdjustChroma)) 
				{
					//  New color convertors do not destroy Y plane input and so
					//  we do not have to do a frame copy
	            	pFrame  = (U8 *)DC;
	            	uYPlane = DC->DispFrame.X32_YPlane + Y_START;
	            	uUPlane = DC->DispFrame.X32_UPlane + UV_START;
	            	uVPlane = DC->DispFrame.X32_VPlane + UV_START;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
					if (bRealDecompress)
					{
						TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
					}
#endif // } DETAILED_DECODE_TIMINGS_ON

				}
				else
				{
					// The block edge filtered frame can not be used as a reference
					// and we need to make a copy of the frame before doing the
					// block edge filtering.
					// This is also true for adjusting pels.
			    	FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_YPlane + Y_START,
				           ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_YPlane,
						   DC->uFrameHeight,
						   DC->uFrameWidth,
						   PITCH);
		            FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_UPlane + UV_START,
				           ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_UPlane,
			               DC->uFrameHeight/2,
						   DC->uFrameWidth/2,
						   PITCH);
			    	FrameCopy (((HPBYTE) P32Inst) + DC->DispFrame.X32_VPlane + UV_START,
				           ((HPBYTE) DC->p16InstPostProcess) + DC->PostFrame.X32_VPlane,
			               DC->uFrameHeight/2,
						   DC->uFrameWidth/2,
						   PITCH);
					pFrame  = (U8 *)DC->p16InstPostProcess;
	            	uYPlane = DC->PostFrame.X32_YPlane;
	            	uUPlane = DC->PostFrame.X32_UPlane;
	            	uVPlane = DC->PostFrame.X32_VPlane;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
					if (bRealDecompress)
					{
						TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFrameCopy)
					}
#endif // } DETAILED_DECODE_TIMINGS_ON

					if (DC->bUseBlockEdgeFilter) {
						// C version of block edge filter
						// should this be added to the mirrored case?
						// it should not be added to the b320x240 case
						// since we want that to be as sharp as possible
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
						if (bRealDecompress)
						{
							TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
						}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

						EdgeFilter((unsigned char *)(pFrame + uYPlane),
								   (unsigned char *)(pFrame + uUPlane),
								   (unsigned char *)(pFrame + uVPlane),
#ifndef NEW_BEF // { NEW_BEF
								   DC->uPQuant,
#endif // } NEW_BEF
								   DC->uFrameWidth,
								   DC->uFrameHeight,
								   PITCH);

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
						if (bRealDecompress)
						{
							TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uBEFTime)
						}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
					}
				}
			}
		} // end no mirroring case
#ifdef H263P
		if (DC->bDeblockingFilter) {
			// Restore post-process (i.e., outside of loop) block edge filter flag
			DC->bUseBlockEdgeFilter = bTmpPostProcessBEF;
		}
#endif
    }
    else   // YUV12
    {
        const U32 uHeight = DC->uFrameHeight;
        const U32 uWidth  = DC->uFrameWidth;
        const U32 uYPlaneSize = uHeight*uWidth;

        uYPitch  = uWidth;
        uUVPitch = uWidth >> 1;

        if(bMirror) // mirroring and YUV12
        {
            HPBYTE pSource, pDestination;

            pFrame  = DC->p16InstPostProcess;
            uYPlane = DC->PostFrame.X32_YPlane;
            uUPlane = uYPlane + uYPlaneSize;
            uVPlane = uUPlane + (uYPlaneSize>>2);

            pSource = (HPBYTE)lpicDecEx->lpSrc;
            pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
            FrameMirror (pSource, pDestination, uHeight, uWidth, uWidth);

            pSource      += uYPlaneSize;
            pDestination += uYPlaneSize;
            FrameMirror (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);

            pSource += (uYPlaneSize>>2);
            pDestination += (uYPlaneSize>>2);
            FrameMirror (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);
        }
        else // no mirroring
        {
            HPBYTE pSource, pDestination;
            if (DC->bAdjustLuma || DC->bAdjustChroma) {

				pFrame  = DC->p16InstPostProcess;
				uYPlane = DC->PostFrame.X32_YPlane;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

				pSource = (HPBYTE)lpicDecEx->lpSrc;
				pDestination = (HPBYTE)(DC->p16InstPostProcess + (DWORD)DC->PostFrame.X32_YPlane);
				FrameCopy (pSource, pDestination, uHeight, uWidth, uWidth);

				pSource      += uYPlaneSize;
				pDestination += uYPlaneSize;
				FrameCopy (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);

				pSource += (uYPlaneSize>>2);
				pDestination += (uYPlaneSize>>2);
				FrameCopy (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);
			} else {
				// Copy the V plane from the source buffer into DC because the
				// input buffer may end at the end of a section. The assembler versions
				// of the color convertors are optimized to read ahead, in which case
				// a GPF occurs if the buffer is at the end of a section.
				pFrame  = (HPBYTE)lpicDecEx->lpSrc;
				uYPlane = 0;
				uUPlane = uYPlane + uYPlaneSize;
				uVPlane = uUPlane + (uYPlaneSize>>2);

                pSource = (HPBYTE)lpicDecEx->lpSrc + uYPlane + uYPlaneSize + (uYPlaneSize >> 2);
                pDestination = (HPBYTE)DC->p16InstPostProcess + DC->PostFrame.X32_YPlane +
					uYPlaneSize + (uYPlaneSize >> 2);
                FrameCopy (pSource, pDestination, uHeight>>1, uWidth>>1, uWidth>>1);
				uVPlane += (pDestination - pSource);
			}
        }
         
    }  //  else YUV12

    // Check if we are to do aspect ration correction on this frame.
    if (DC->bForceOnAspectRatioCorrection || lpInst->bCorrectAspectRatio) {
        bShapingFlag = 1;
        uNewFrameHeight = (DC->uFrameHeight * 11 / 12);
    } else {
        bShapingFlag = 0;
        uNewFrameHeight = DC->uFrameHeight;
    }

    // Do the PEL color adjustments if necessary.
    if(DC->bAdjustLuma) 
    {
        // width is rounded up to a multiple of 8
        AdjustPels(pFrame,
                   uYPlane,
                   DC->uFrameWidth,
                   uYPitch,
                   DC->uFrameHeight,
                   (U32) DC->X16_LumaAdjustment);
    }
    if(DC->bAdjustChroma) 
    {
        // width = Y-Width / 4 and then rounded up to a multiple of 8
        AdjustPels(pFrame,
                   uUPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                  (U32) DC->X16_ChromaAdjustment);
        AdjustPels(pFrame,
                   uVPlane,
                   (DC->uFrameWidth >> 1),
                   uUVPitch,
                   (DC->uFrameHeight >> 1),
                   (U32) DC->X16_ChromaAdjustment);
    }

    // Determine parameters need for color conversion.
    if(lpicDecEx->lpbiDst->biCompression == FOURCC_YUY2)  /* output pitch, offset */
    {
		intPitch = (lpicDecEx->lpbiDst->biBitCount >> 3) * abs ((int)(lpicDecEx->lpbiDst->biWidth));
		lOutput = 0;                                       /* for YUY2 format */
		uNewOffsetToLine0 = DC->CCOffsetToLine0;
		bShapingFlag=FALSE;
    }
    else if ((lpicDecEx->lpbiDst->biCompression == FOURCC_YUV12) || (lpicDecEx->lpbiDst->biCompression == FOURCC_IYUV))  /* output pitch, offset */
    {
		intPitch = 0xdeadbeef;  // should not be used
		lOutput = 0;                                       /* for YUV format */
		uNewOffsetToLine0 = DC->CCOffsetToLine0;
		bShapingFlag=FALSE;
    }
    else  // not YUY2
    {
        // this call also sets intPitch
        lOutput = DibXY(lpicDecEx, &intPitch, lpInst->YScale);

        if (DC->uIs320x240)
            uNewOffsetToLine0 = DC->CCOffset320x240;
        else
            uNewOffsetToLine0 = DC->CCOffsetToLine0;

        if (!bIsDCI)
        {
             uNewOffsetToLine0 += 
                ( (U32)DC->uFrameHeight - (U32)uNewFrameHeight ) * (U32)intPitch;

            if(lpInst->YScale == 2)
                 uNewOffsetToLine0 += 
                    ( (U32)DC->uFrameHeight - (U32)uNewFrameHeight ) * (U32)intPitch;

        }  // end if (!bIsDCI)

    } // end if (YUY2) ... else ...

    // Call the H26x color convertors 
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

#ifdef USE_MMX // { USE_MMX
    ColorConvertorCatalog[DC->ColorConvertor].ColorConvertor[DC->bMMXDecoder ? MMX_CC : PENTIUM_CC](
#else // }{ USE_MMX
    ColorConvertorCatalog[DC->ColorConvertor].ColorConvertor[PENTIUM_CC](
#endif // } USE_MMX
        (LPSTR) pFrame+uYPlane,                  // Y plane
        (LPSTR) pFrame+uVPlane,                  // V plane
        (LPSTR) pFrame+uUPlane,                  // U plane
#ifdef H263P
		// The actual frame dimensions are needed for the color conversion
		(UN) DC->uActualFrameWidth,
		(UN) DC->uActualFrameHeight,
#else
        (UN) DC->uFrameWidth,
        (UN) DC->uFrameHeight,
#endif
        (UN) uYPitch,
        (UN) uUVPitch,
        (UN) (bShapingFlag ? 12 : 9999),         // Aspect Adjustment Counter
        (LPSTR) lpicDecEx->lpDst,                // Color Converted Frame
        (U32) lOutput,                           // DCI offset
        (U32) uNewOffsetToLine0,                 // Color converter offset to line 0
        (int) intPitch,                          // Color converter pitch
        DC->ColorConvertor);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uOutputCC);
#endif // } DETAILED_DECODE_TIMINGS_ON

    // check for 320x240 still
    if (DC->uIs320x240) {
        // restore frame size for next frame
        DC->uFrameWidth = uSaveWidth;
        DC->uFrameHeight = uSaveHeight;
    }

    iReturn = ICERR_OK;

done:
#ifdef USE_MMX // { USE_MMX
	if(NULL != DC)
	{
		if (DC->bMMXDecoder)
		{
			__asm {
				_emit 0x0f 
				_emit 0x77  //  emms
			}
		}
	}
#endif // } USE_MMX

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	if (bRealDecompress)
	{
		TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uDecodeTime);
		if (bTimingThisFrame)
		{
			// Update the decompression timings counter
			#pragma message ("Current decode timing computations assume P5/90Mhz")
			UPDATE_COUNTER(g_pctrDecompressionTimePerFrame, (uDecodeTime + 45000UL) / 90000UL);
			UPDATE_COUNTER(g_pctrBEFTimePerFrame, (uBEFTime + 45000UL) / 90000UL);

			DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: Decompression time: %ld\r\n", _fx_, (uDecodeTime + 45000UL) / 90000UL));
			DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: Block Edge Filtering time: %ld\r\n", _fx_, (uBEFTime + 45000UL) / 90000UL));
		}
	}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (bRealDecompress)
	{
		if (bTimingThisFrame)
		{
			pDecTimingInfo = DC->pDecTimingInfo + DC->uStatFrameCount;
			pDecTimingInfo->uDecodeFrame = uDecodeTime;
			pDecTimingInfo->uBEF = uBEFTime;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			pDecTimingInfo->uHeaders = uHeaders;
			pDecTimingInfo->uMemcpy = uMemcpy;
			pDecTimingInfo->uFrameCopy = uFrameCopy;
			pDecTimingInfo->uIDCTandMC = uIDCTandMC;
			pDecTimingInfo->uOutputCC = uOutputCC;
			pDecTimingInfo->uDecIDCTCoeffs = uDecIDCTCoeffs;
#endif // } DETAILED_DECODE_TIMINGS_ON
			DC->uStatFrameCount++;
		}
	}
#endif // } LOG_DECODE_TIMINGS_ON

    return iReturn;
}


/************************************************************************
 *  H263TermDecoderInstance
 *    This function frees the space allocated for an instance of the H263 
 *    decoder.
 ************************************************************************/
LRESULT H263TermDecoderInstance(
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    LPDECINST lpInst,
	BOOL bRealDecompress)
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
    LPDECINST lpInst)
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
{ 
    LRESULT iReturn=ICERR_OK;
    T_H263DecoderCatalog * DC;

	FX_ENTRY("H263TermDecoderInstance");
    
    if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
    {
		ERRORMESSAGE(("%s: Bad input parameter!\r\n", _fx_));
        iReturn = ICERR_BADPARAM;
    }
    if(lpInst->Initialized == FALSE)
    {
		ERRORMESSAGE(("%s: Uninitialized instance!\r\n", _fx_));
        return(ICERR_OK);
    }
    
    lpInst->Initialized = FALSE;
    
    DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);
    
    if (DC->_p16InstPostProcess != NULL)
    {
		HeapFree(GetProcessHeap(), 0, DC->_p16InstPostProcess);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)DC->_p16InstPostProcess);
#endif
		// PhilF: Also freed in H263TerminateDecoderInstance! For now set to NULL to avoid second HeapFree.
		// Investigate reason for 2nd call later...
		DC->_p16InstPostProcess = NULL;
    }  
    
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (bRealDecompress && DC->X32_DecTimingInfo)
	{
		DC->pDecTimingInfo = (DEC_TIMING_INFO FAR *)( ((U8 FAR *)DC) + DC->X32_DecTimingInfo );
		OutputDecodeTimingStatistics("c:\\decode.txt", DC->pDecTimingInfo, DC->uStatFrameCount);
	}
#endif // } LOG_DECODE_TIMINGS_ON

    HeapFree(GetProcessHeap(), 0, lpInst->pDecoderInst);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpInst->pDecoderInst);
#endif

    return iReturn;
}

/***********************************************************************
 *  Description:
 *    This routine parses the bit-stream and initializes two major streams:
 *      1) pN: no of coefficients in each of the block (biased by 65 for INTRA)
 *      2) pRun_INVERSE_Q: de-quantized coefficient stream for the frame;
 *           MMX stream is scaled because we use scaled IDCT.
 *    Other information (e.g. MVs) is kept in decoder catalog, block action 
 *    stream, and MB infor stream.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    fpbsState:     bit-stream state pointer
 *    fpu8MaxPtr:    sentinel value to check for bit-stream overruns
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *    iGOB_start:    
 *    iMB_start:     
 *  Note:
 ***********************************************************************/
#pragma code_seg("IACODE1")
static LRESULT IAPass1ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    BITSTREAM_STATE      *fpbsState,
    U8                   *fpu8MaxPtr,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs,
    const I32             iGOB_start,
    const I32             iMB_start)
{
    I32 g, m, gg, mm, iReturn, iBlockNumber = 0 ;
#if 1  
    I32 mb_start = iMB_start;
    I32 old_g, old_m, b_skip;
    U32 *pNnew;
	I8  p8MVs[4]={0,0,0,0};

	FX_ENTRY("IAPass1ProcessFrame");

    //  In case of H.263, iGOB_start will be 1; H.263RTP may have value
    //  larger than 1

    for (g = 1; g < iGOB_start; g++, fpBlockAction += iNumberOfMBs*6)
        H263InitializeGOBBlockActionStream(DC, g, fpBlockAction);        

    for (g = iGOB_start; g <= iNumberOfGOBs; g++) 
    {
        iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        if (iReturn != ICERR_OK) 
        {
			ERRORMESSAGE(("%s: Error reading GOB header!\r\n", _fx_));
            goto error;
        }

        if (g != 1) g = DC->uGroupNumber + 1;
         
        fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
		fpBlockAction += (g - 1)* iNumberOfMBs*6;

        H263InitializeGOBBlockActionStream(DC, g, fpBlockAction);        
        //  re-sync uBlockNum fpBlockAction, fpMBInfo at this point
        iBlockNumber  = (g - 1)* iNumberOfMBs*6+(mb_start-1)*6;
        fpBlockAction = (T_BlkAction FAR *)((U8 *)DC + DC->X16_BlkActionStream);
        fpMBInfo      = (T_MBInfo FAR *) ((U8 *)DC + DC->X32_uMBInfoStream);    
        fpBlockAction += iBlockNumber;
        fpMBInfo      += iBlockNumber/6;
        if (DC->bPBFrame)
		 pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber*2;
        else
		 pNnew         = (U32 *)((U8 *)DC + DC->X32_pN) + iBlockNumber;

        while (pN < pNnew ) *pN++ = 0;
        
        // For each MB do ...
        for (m = mb_start; m <= iNumberOfMBs; m++, iBlockNumber += 6, fpBlockAction += 6, fpMBInfo++) 
        {
            if (mb_start != 1) mb_start = 1;     //use it only once     ?
            
            iReturn = H263DecodeMBHeader(DC, fpbsState, &pN, fpMBInfo);   // NEW - added pN

            if (iReturn == PACKET_FAULT)
            {
				ERRORMESSAGE(("%s: H263DecodeMBHeader() failed!\r\n", _fx_));

                old_g = g;
                old_m = m;
                //Find the next good packet and find GOB and MB lost
                iReturn = RtpH263FindNextPacket(DC, fpbsState, &pN, 
					                            &DC->uPQuant,(int *)&m, (int *)&g,
												p8MVs);
                if (iReturn == NEXT_MODE_A) 
                {
					ERRORMESSAGE(("%s: Next packet in MODE A\r\n", _fx_));
					MVAdjustment(fpBlockAction, iBlockNumber, old_g-1, old_m-1, g, m,iNumberOfMBs); //Chad,7/22/96
                    break;
                }
                else if ((iReturn == NEXT_MODE_B) ||(iReturn == NEXT_MODE_C) ) 
                {//lost multiple of MBs, could belong to more than one GOB
  					if (iReturn == NEXT_MODE_B) 
					{
					ERRORMESSAGE(("%s: Next packet in MODE B\r\n", _fx_));
					  b_skip = ((g - old_g+1)* iNumberOfMBs + m - old_m + 1)*6;
                      for (int k = 0; k < b_skip; k++)  *pN++ = 0;
					}
					else
					{
					ERRORMESSAGE(("%s: Next packet in MODE C\r\n", _fx_));
					  b_skip = ((g - old_g+1)* iNumberOfMBs + m - old_m + 1)*6*2;
                      for (int k = 0; k < b_skip; k++)  *pN++ = 0;
					  b_skip = b_skip /2;
                    }
					
                    for (int k=0;k< b_skip /6;k++)
					{
						fpMBInfo->i8MVDBx2=0;
						fpMBInfo->i8MVDBy2=0;
						fpMBInfo->i8MBType =0;
						fpMBInfo++;
                    }
					fpMBInfo--;
                    b_skip -= 6;     //this is a tricky one since the parameter 
                                     //below will be adjust again later
                                     //Chad, 8/28/96
                    fpBlockAction += b_skip;
                    iBlockNumber  += b_skip;
					g++;    //because g start with 1 instead of 0 as specified by H.263
					for (k=0;k<6;k++)
					{
						fpBlockAction[k].i8MVx2 = p8MVs[0];
						fpBlockAction[k].i8MVy2 = p8MVs[1];
					}

                }
                else //Added by Chad.
                if (iReturn == NEXT_MODE_LAST)
                { 
                    int ii, jj, kk;   //last packet found
                                    //set all the rest of MB and GOB to NOT CODED.
					ERRORMESSAGE(("%s: Last packet lost\r\n", _fx_));
                    for ( ii = m;ii <= iNumberOfMBs; ii++) 
                        for (kk = 0; kk < 6; kk++) 
                            *pN++ = 0;
                    for ( jj = g; jj <= iNumberOfGOBs; jj++)
                        for (ii = 0; ii <= iNumberOfMBs; ii++)
                            for (kk = 0; kk<6; kk++) 
                                *pN++ = 0;
                    m = iNumberOfMBs;
                    g = iNumberOfMBs;
                }
			    DC->bCoded = FALSE;
			}
            else if (iReturn != ICERR_OK) 
            {
				ERRORMESSAGE(("%s: Error reading MB header!\r\n", _fx_));
                goto error;
            }
            
#ifdef NEW_BEF // { NEW_BEF
            gg = (g - 1);
            mm = (m - 1);
#else // }{ NEW_BEF
			gg = (g-1)<<1;
			mm = (m-1)<<1;
#endif // } NEW_BEF
            if (DC->bCoded) 
            {
				// coded_map is used by the block edge filter to indicate
				// which blocks are coded, and which are not coded.
#ifdef NEW_BEF // { NEW_BEF
                coded_map[gg+1][mm+1]   = 1;
				QP_map[gg][mm] = (char)DC->uGQuant;
#else // }{ NEW_BEF
				coded_map[gg]  [mm]   = 1;
				coded_map[gg+1][mm]   = 1;
				coded_map[gg]  [mm+1] = 1;
				coded_map[gg+1][mm+1] = 1;
#endif // } NEW_BEF

                // decode and inverse quantize the transform coefficients
                iReturn = H263DecodeIDCTCoeffs(DC, 
                                               fpBlockAction, 
                                               iBlockNumber, 
                                               fpbsState, 
                                               fpu8MaxPtr,
                                               &pN,
                                               &pRUN_INVERSE_Q);
                
                if (iReturn != ICERR_OK) {
					ERRORMESSAGE(("%s: Error parsing MB data!\r\n", _fx_));
                    goto error;
                }
            }  //  end if DC->bCoded
			else
			{
#ifdef NEW_BEF // { NEW_BEF
                coded_map[gg+1][mm+1]   = 0;
#else // }{ NEW_BEF
				coded_map[gg]  [mm]   = 0;
				coded_map[gg+1][mm]   = 0;
				coded_map[gg]  [mm+1] = 0;
				coded_map[gg+1][mm+1] = 0;
#endif // } NEW_BEF
			}

        } // end for each MB
        
        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        if (fpbsState->fpu8 > fpu8MaxPtr+4)
            goto error;
        //  The test matrix includes the debug version of the driver.  The 
        //  following assertion creates a problem when testing with VideoPhone
        //  and so please do not check-in a version with the assertion 
        //  uncommented.
        // ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);
        
    } // End for each GOB
    DC->iVerifiedBsExt=FALSE;

#else
//old code  
    for (g = 1; g <= iNumberOfGOBs; g++) 
    {
        iReturn = H263DecodeGOBHeader(DC, fpbsState, g);
        if (iReturn != ICERR_OK) {
			ERRORMESSAGE(("%s: Error reading GOB header!\r\n", _fx_));
            goto error;
        }
        H263InitializeGOBBlockActionStream(DC, g, fpBlockAction);        
        
        /* For each MB do ...
         */
        for (m = 1; m <= iNumberOfMBs; 
             m++, iBlockNumber+=6, fpBlockAction += 6, fpMBInfo++) 
        {
            iReturn = H263DecodeMBHeader(DC, fpbsState, &pN, fpMBInfo);
            
            if (iReturn != ICERR_OK) {
				ERRORMESSAGE(("%s: Error reading MB header!\r\n", _fx_));
                goto error;
            }
            
            if (DC->bCoded) {
                // decode and inverse quantize the transform coefficients
                iReturn = H263DecodeIDCTCoeffs(DC, 
                                               fpBlockAction, 
                                               iBlockNumber, 
                                               fpbsState, 
                                               fpu8MaxPtr,
                                               &pN,
                                               &pRUN_INVERSE_Q);
                if (iReturn != ICERR_OK) 
                {
					ERRORMESSAGE(("%s: Error parsing MB data!\r\n", _fx_));
                    goto error;
                }
            }  //  end if DC->bCoded
        } // end for each MB
        
        /* allow the pointer to address up to four beyond the end - reading
         * by DWORD using postincrement.
         */
        ASSERT(fpbsState->fpu8 <= fpu8MaxPtr+4);
        
    } // End for each GOB
#endif

    return ICERR_OK;

error:
    return ICERR_ERROR;
}
#pragma code_seg()


/***********************************************************************
 *  Description:
 *    This routines does IDCT and motion compensation.
 *  Parameters:
 *    DC:            Decoder catalog ptr
 *    fpBlockAction: block action stream ptr
 *    fpMBInfo:      Macroblock info ptr
 *    pN:            stream of no. of coeffs (biased by block type) for each block
 *    pRun_INVERSE_Q:stream of de-quantized (and scaled if using MMX) coefficients
 *    iNumberOfGOBs: no. of GOBs in the frame
 *    iNumberOfMBs:  no. of MBs in a GOB in the frame
 *  Note:
 ***********************************************************************/
#pragma code_seg("IACODE2")
static void IAPass2ProcessFrame(
    T_H263DecoderCatalog *DC,
    T_BlkAction          *fpBlockAction,
    T_MBInfo             *fpMBInfo,
    U32                  *pN,
    T_IQ_INDEX           *pRUN_INVERSE_Q,
    const I32             iNumberOfGOBs,
    const I32             iNumberOfMBs
)
{
    I32 g, m, b, uBlockNumber = 0, iEdgeFlag=0;
    U32 pRef[6];

    // for each GOB do
    for (g = 1 ; g <= iNumberOfGOBs; g++) 
    {
        // for each MB do
        for (m = 1; m <= iNumberOfMBs; m++, fpBlockAction+=6, fpMBInfo++) 
        {
            //  Motion Vectors need to be clipped if they point outside the 
            //  16 pels wide edge
            if (DC->bUnrestrictedMotionVectors)   
            {
                iEdgeFlag = 0;
                if (m == 1)
                    iEdgeFlag |= LEFT_EDGE;
                if (m == DC->iNumberOfMBsPerGOB)
                    iEdgeFlag |= RIGHT_EDGE;
                if (g == 1)
                    iEdgeFlag |= TOP_EDGE;
                if (g == iNumberOfGOBsBySourceFormat[DC->uSrcFormat])
                    iEdgeFlag |= BOTTOM_EDGE;
            }
            // for each block do
            for (b = 0; b < 6; b++) 
            {     // AP-NEW
                // do inverse transform & motion compensation for the block
                H263IDCTandMC(DC, fpBlockAction, b, m, g, pN, pRUN_INVERSE_Q, 
                              fpMBInfo, iEdgeFlag); // AP-NEW
                // Adjust pointers for next block     
                if ( *pN >= 65 )
                    pRUN_INVERSE_Q += *pN - 65;
                else
                    pRUN_INVERSE_Q += *pN;
                pN++;
            }  // end for each block
            
            // if this is a PB Frame
            if (DC->bPBFrame) 
            {
                // Compute the B Frame motion vectors
                H263BBlockPrediction(DC, fpBlockAction, pRef, fpMBInfo, 
                                     iEdgeFlag);  // AP-NEW
                // For each B block
                for (b = 0; b < 6; b++) 
                {
                    //  perform inverse transform & bi-directional motion 
                    //  compensation
                    H263BFrameIDCTandBiMC(DC, fpBlockAction, b, pN, 
                                          pRUN_INVERSE_Q, pRef);
                    // Adjust pointers for next block     
                    pRUN_INVERSE_Q += *pN;
                    pN++;
                }  // end for each B block
            }  // end if PB Frame
        }  // end for each MB
    }  // End for each GOB
}
#pragma code_seg()


/****************************************************************************
 *  DibXY
 *    This function is used to map color converted output to the screen.
 *    note: this function came from the H261 code base.
 ****************************************************************************/
static long DibXY(ICDECOMPRESSEX FAR *lpicDecEx, LPINT lpiPitch, UINT yScale)
{
    int                 iPitch;             /* width of DIB                */
    long                lOffset = 0;
    LPBITMAPINFOHEADER  lpbi = lpicDecEx->lpbiDst;

    iPitch = ( ( (abs((int)lpbi->biWidth) * (int)lpbi->biBitCount) >> 3) + 3) & ~3;

    if(lpicDecEx->xDst > 0)                 /* go to proper X position     */
        lOffset += ((long)lpicDecEx->xDst * (long)lpbi->biBitCount) >> 3;

    if(lpbi->biHeight * lpicDecEx->dxSrc < 0) { /* DIB is bottom to top    */
        lOffset +=  (long) abs((int)lpbi->biWidth) * 
                    (long) abs((int)lpbi->biHeight) *
                    ((long) lpbi->biBitCount >> 3) - 
                    (long) iPitch;

    /************************************************************************
     *  This next line is used to subtract the amount that Brian added
     *  to CCOffsetToLine0 in COLOR.C during initialization.  This is 
     *  needed because, for DCI, the pitch he used is incorrect. 
     ***********************************************************************/

        lOffset -=    ((long) yScale * (long) lpicDecEx->dySrc - 1) *     
                    (long) lpicDecEx->dxDst * ((long) lpbi->biBitCount >> 3);  

        iPitch *= -1;
    }

    if(lpicDecEx->yDst > 0)                 /* go to proper Y position     */
        lOffset += ((long)lpicDecEx->yDst * (long)iPitch);

    if(lpicDecEx->dxSrc > 0) {
        lOffset += ((long)lpicDecEx->dyDst * (long)iPitch) - (long)iPitch;
        iPitch *= -1;
    }

    if( (lpicDecEx->dxDst == 0) && (lpicDecEx->dyDst == 0) )
        *lpiPitch = -iPitch;
    else
        *lpiPitch = iPitch;
  
    return(lOffset);
}


/************************************************************************
 *  GetDecoderOptions:
 *    Get the options, saving them in the catalog
 ***********************************************************************/
static void GetDecoderOptions(
    T_H263DecoderCatalog * DC)
{
    /* Default Options
     */
#ifdef NO_BEF // { NO_BEF
    DC->bUseBlockEdgeFilter = 0;
#else // }{ NO_BEF
    DC->bUseBlockEdgeFilter = 1;
#endif // } NO_BEF
    DC->bForceOnAspectRatioCorrection = 0;
#ifdef USE_MMX // { USE_MMX
    DC->bMMXDecoder = MMxVersion;
#endif // } USE_MMX

	FX_ENTRY("GetDecoderOptions");

    /* Can only use force aspect ratio correction on if SQCIF, QCIF, or CIF
     */
    if (DC->bForceOnAspectRatioCorrection)
    {
        if (! ( ((DC->uFrameWidth == 128) && (DC->uFrameHeight ==  96)) ||
                ((DC->uFrameWidth == 176) && (DC->uFrameHeight == 144)) ||
                ((DC->uFrameWidth == 352) && (DC->uFrameHeight == 288)) ) )
        {
			ERRORMESSAGE(("%s: Aspect ratio correction can not be forced on unless the dimensions are SQCIF, QCIF, or CIF!\r\n", _fx_));
            DC->bForceOnAspectRatioCorrection = 0;
        }
    }

    /* Display the options
     */
    if (DC->bUseBlockEdgeFilter)
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (BlockEdgeFilter) is ON\r\n", _fx_));
    }
    else
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (BlockEdgeFilter) is OFF\r\n", _fx_));
    }
    if (DC->bForceOnAspectRatioCorrection)
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (ForceOnAspectRatioCorrection) is ON\r\n", _fx_));
    }
    else
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (ForceOnAspectRatioCorrection) is OFF\r\n", _fx_));
    }
#ifdef USE_MMX // { USE_MMX
    if (DC->bMMXDecoder)
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (MMXDecoder) is ON\r\n", _fx_));
    }
    else
    {
		DEBUGMSG (ZONE_INIT, ("%s: Decoder option (MMXDecoder) is OFF\r\n", _fx_));
    }
#else // }{ USE_MMX
	DEBUGMSG (ZONE_INIT, ("%s: Decoder option (MMXDecoder) is OFF\r\n", _fx_));
#endif // } USE_MMX
} /* end GetDecoderOptions() */


#if !defined(H263P)
#ifdef NEW_BEF // { NEW_BEF
/**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs deblocking filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *      Modified for annex J in H.263+: 961120   Karl O. Lillevold
 *
 ***********************************************************************/
static void EdgeFilter(unsigned char *lum, 
                       unsigned char *Cb, 
                       unsigned char *Cr, 
                       int width, int height, int pitch
                      )
{

    /* Luma */
    HorizEdgeFilter(lum, width, height, pitch, 0);
    VertEdgeFilter (lum, width, height, pitch, 0);

    /* Chroma */
    HorizEdgeFilter(Cb, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cb, width>>1, height>>1, pitch, 1);
    HorizEdgeFilter(Cr, width>>1, height>>1, pitch, 1);
    VertEdgeFilter (Cr, width>>1, height>>1, pitch, 1);

    return;
}

/***********************************************************************/
static void HorizEdgeFilter(unsigned char *rec, 
                            int width, int height, int pitch, int chr)
{
  int i,j,k;    
  int delta;
  int mbc, mbr, do_filter;
  unsigned char *r_2, *r_1, *r, *r1;
  signed char *deltatab;

  /* horizontal edges */
  r = rec + 8*pitch;
  r_2 = r - 2*pitch;
  r_1 = r - pitch;
  r1 = r + pitch;

  for (j = 8; j < height; j += 8) {
    for (i = 0; i < width; i += 8) {

      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }

      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr][mbc+1];

      if (do_filter) {
        for (k = i; k < i+8; k++) {
          delta = (int)deltatab[ (( (int)(*(r_2 + k) * 3) -
                                    (int)(*(r_1 + k) * 8) +
                                    (int)(*(r   + k) * 8) -
                                    (int)(*(r1  + k) * 3)) >>4)];
                        
          *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
          *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

        }
      }
    }
    r   += (pitch<<3);
    r1  += (pitch<<3);
    r_1 += (pitch<<3);
    r_2 += (pitch<<3);
  }
  return;
}

/***********************************************************************/
static void VertEdgeFilter(unsigned char *rec, 
                           int width, int height, int pitch, int chr)
{
  int i,j,k;
  int delta;
  int mbc, mbr;
  int do_filter;
  signed char *deltatab;
  unsigned char *r;

  /* vertical edges */
  for (i = 8; i < width; i += 8) 
  {
    r = rec;
    for (j = 0; j < height; j +=8) 
    {
      if (!chr) {
        mbr = (j >> 4); 
        mbc = (i >> 4);
      }
      else {
        mbr = (j >> 3); 
        mbc = (i >> 3);
      }
        
      deltatab = dtab + 176 + 351 * (QP_map[mbr][mbc] - 1);

      do_filter = coded_map[mbr+1][mbc+1] || coded_map[mbr+1][mbc];

      if (do_filter) {
        for (k = 0; k < 8; k++) {
          delta = (int)deltatab[(( (int)(*(r + i-2 ) * 3) - 
                                   (int)(*(r + i-1 ) * 8) + 
                                   (int)(*(r + i   ) * 8) - 
                                   (int)(*(r + i+1 ) * 3)  ) >>4)];

          *(r + i   ) = ClampTbl[ (int)(*(r + i  )) - delta + CLAMP_BIAS];
          *(r + i-1 ) = ClampTbl[ (int)(*(r + i-1)) + delta + CLAMP_BIAS]; 
          r   += pitch;
        }
      }
      else {
        r += (pitch<<3);
      }
    }
  }
  return;
}

#define sign(a)        ((a) < 0 ? -1 : 1)

static void InitEdgeFilterTab()   
{
  int i,QP;
  
  for (QP = 1; QP <= 31; QP++) {
    for (i = -176; i <= 175; i++) {
      dtab[i+176 +(QP-1)*351] = sign(i) * (max(0,abs(i)-max(0,2*abs(i) - QP)));
    }
  }
}

#else // }{ NEW_BEF

/**********************************************************************
 *
 *      Name:           EdgeFilter
 *      Description:    performs in the loop edge-filtering on
 *                      reconstructed frames
 *      
 *      Input:          pointers to reconstructed frame and difference 
 *                      image
 *      Returns:       
 *      Side effects:
 *
 *      Date: 951129    Author: Gisle.Bjontegaard@fou.telenor.no
 *                              Karl.Lillevold@nta.no
 *
 ***********************************************************************/
void EdgeFilter(unsigned char *lum, unsigned char *Cb, unsigned char *Cr, int QP, int pels, int lines, int pitch)
{

  int dtab[512];
  int *deltatab;
  int i;

  deltatab = &dtab[0] + 256;

  for (i=-256; i < 0; i++)
    deltatab[i] = min(0,i-min(0,((i + (QP>>1))<<1)));   
  for (i=0; i < 256; i++)
    deltatab[i] = max(0,i-max(0,((i - (QP>>1))<<1)));

  /* Luma */
  HorizEdgeFilter(lum, pels, lines, pitch, QP, 0, deltatab);
  VertEdgeFilter (lum, pels, lines, pitch, QP, 0, deltatab);

  /* Chroma */
  HorizEdgeFilter(Cb,  pels>>1, lines>>1, pitch, QP, 1, deltatab);
  VertEdgeFilter (Cb,  pels>>1, lines>>1, pitch, QP, 1, deltatab);
  HorizEdgeFilter(Cr,  pels>>1, lines>>1, pitch, QP, 1, deltatab);
  VertEdgeFilter (Cr,  pels>>1, lines>>1, pitch, QP, 1, deltatab);

  /* that's it */
  return;
}

/***********************************************************************/
void HorizEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                     int chr, int *deltatab)
{
  int i,j,k;
  int delta;
  int mbc, mbr, do_filter;
  int coded1, coded2;
  unsigned char *r_2, *r_1, *r, *r1;


  /* horizontal edges */
  r = rec + 8*pitch;
  r_2 = r - 2*pitch;
  r_1 = r - pitch;
  r1 = r + pitch;

  if (!chr) {
    for (j = 8; j < height; j += 8) {
      for (i = 0; i < width; i += 8) {

        mbr = (j >> 3); 
        mbc = (i >> 3);

          do_filter = coded_map[mbr][mbc] | coded_map[mbr-1][mbc];

        if (do_filter) {
          for (k = i; k < i+8; k++) {
              delta = deltatab[ (( (int)(*(r_2 + k)) +
                                   (int)(*(r_1 + k) * (-3)) +
                                   (int)(*(r   + k) * ( 3)) -
                                   (int)(*(r1  + k) )) >>3)];

              *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
              *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

          }
        }
      }
      r   += (pitch<<3);
      r1  += (pitch<<3);
      r_1 += (pitch<<3);
      r_2 += (pitch<<3);
    }
  }
  else { /* chr */
    for (j = 8; j < height; j += 8) {
      for (i = 0; i < width; i += 8) {

        mbr = (j >> 3); 
        mbc = (i >> 3);

          coded1 = 
            coded_map[2*mbr][2*mbc] |
            coded_map[2*mbr][2*mbc+1] |
            coded_map[2*mbr+1][2*mbc] |
            coded_map[2*mbr+1][2*mbc+1];
          coded2 = 
            coded_map[2*(mbr-1)][2*mbc] |
            coded_map[2*(mbr-1)][2*mbc+1] |
            coded_map[2*(mbr-1)+1][2*mbc] |
            coded_map[2*(mbr-1)+1][2*mbc+1];
          do_filter = coded1 | coded2;

        if (do_filter) {
          for (k = i; k < i+8; k++) {
              delta = deltatab[ (( (int)(*(r_2 + k)) +
                                   (int)(*(r_1 + k) * (-3)) +
                                   (int)(*(r   + k) * ( 3)) -
                                   (int)(*(r1  + k) )) >>3)];

              *(r + k) = ClampTbl[ (int)(*(r + k)) - delta + CLAMP_BIAS];
              *(r_1 + k) = ClampTbl[ (int)(*(r_1 + k)) + delta + CLAMP_BIAS];

          }
        }
      }
      r   += (pitch<<3);
      r1  += (pitch<<3);
      r_1 += (pitch<<3);
      r_2 += (pitch<<3);
    }
  }
  return;
}

/***********************************************************************/
void VertEdgeFilter(unsigned char *rec, int width, int height, int pitch, int QP, 
                    int chr, int *deltatab)
{
  int i,j,k;
  int delta;
  int mbc, mbr;
  int do_filter, coded1, coded2;
  unsigned char *r;
  extern const U8 ClampTbl[CLAMP_BIAS+256+CLAMP_BIAS];

  /* vertical edges */
  for (i = 8; i < width; i += 8) {
    r = rec;
    for (j = 0; j < height; j +=8) {
      mbr = (j >> 3); 
      mbc = (i >> 3);

      if (!chr) {
        do_filter = coded_map[mbr][mbc] | coded_map[mbr][mbc-1];
      }
      else {
        coded1 = 
          coded_map[2*mbr][2*mbc] |
          coded_map[2*mbr][2*mbc+1] |
          coded_map[2*mbr+1][2*mbc] |
          coded_map[2*mbr+1][2*mbc+1];
        coded2 = 
          coded_map[2*mbr][2*(mbc-1)] |
          coded_map[2*mbr][2*(mbc-1)+1] |
          coded_map[2*mbr+1][2*(mbc-1)] |
          coded_map[2*mbr+1][2*(mbc-1)+1];
        do_filter = coded1 | coded2;
      }
      if (do_filter) {
        for (k = 0; k < 8; k++) {

          delta = deltatab[(( (int)(*(r + i-2 )       ) + 
                              (int)(*(r + i-1 ) * (-3)) + 
                              (int)(*(r + i   ) * ( 3)) - 
                              (int)(*(r + i+1 ) )  ) >>3)];


          *(r + i   ) = ClampTbl[ (int)(*(r + i  )) - delta + CLAMP_BIAS];
          *(r + i-1 ) = ClampTbl[ (int)(*(r + i-1)) + delta + CLAMP_BIAS]; 
          r   += pitch;
        }
      }
      else {
        r += (pitch<<3);
      }
    }
  }
  return;
}
#endif // } NEW_BEF
#endif

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
void OutputDecodeTimingStatistics( char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, U32 uStatFrameCount)
{
	FILE * pFile;
	DEC_TIMING_INFO * pTempDecTimingInfo;
	DEC_TIMING_INFO dtiTemp;
	int i;
	int iCount;

	FX_ENTRY("OutputDecodeTimingStatistics")

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
		ERRORMESSAGE("%s: Error opening decode stat file\r\n", _fx_));
		goto done;
	}

	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	// for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < uStatFrameCount ; i++, pTempDecTimingInfo++ )
	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < DEC_TIMING_INFO_FRAME_COUNT ; i++, pTempDecTimingInfo++ )
	{
		if (pTempDecTimingInfo->uDecodeFrame != 0)
		{
			fprintf(pFile, "Frame %d Detail Timing Information\n", i);
			OutputDecTimingDetail(pFile, pTempDecTimingInfo);
		}
	}

	/* Compute the total information
	 */
	memset(&dtiTemp, 0, sizeof(DEC_TIMING_INFO));
	iCount = 0;

	// for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < uStatFrameCount ; i++, pTempDecTimingInfo++ )
	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < DEC_TIMING_INFO_FRAME_COUNT ; i++, pTempDecTimingInfo++ )
	{
		if (pTempDecTimingInfo->uDecodeFrame != 0)
		{
			iCount++;

			dtiTemp.uDecodeFrame  += pTempDecTimingInfo->uDecodeFrame;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			dtiTemp.uHeaders	  += pTempDecTimingInfo->uHeaders;
			dtiTemp.uMemcpy       += pTempDecTimingInfo->uMemcpy;
			dtiTemp.uFrameCopy    += pTempDecTimingInfo->uFrameCopy;
			dtiTemp.uOutputCC     += pTempDecTimingInfo->uOutputCC;
			dtiTemp.uIDCTandMC    += pTempDecTimingInfo->uIDCTandMC;
			dtiTemp.uDecIDCTCoeffs+= pTempDecTimingInfo->uDecIDCTCoeffs;
#endif // } DETAILED_DECODE_TIMINGS_ON
			dtiTemp.uBEF          += pTempDecTimingInfo->uBEF;
		}
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);

		/* Compute the average
		*/
		dtiTemp.uDecodeFrame  = (dtiTemp.uDecodeFrame + (iCount / 2)) / iCount;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		dtiTemp.uHeaders	  = (dtiTemp.uHeaders + (iCount / 2)) / iCount;
		dtiTemp.uMemcpy       = (dtiTemp.uMemcpy + (iCount / 2)) / iCount;
		dtiTemp.uFrameCopy    = (dtiTemp.uFrameCopy + (iCount / 2)) / iCount;
		dtiTemp.uOutputCC     = (dtiTemp.uOutputCC + (iCount / 2)) / iCount;
		dtiTemp.uIDCTandMC    = (dtiTemp.uIDCTandMC+ (iCount / 2)) / iCount;
		dtiTemp.uDecIDCTCoeffs= (dtiTemp.uDecIDCTCoeffs+ (iCount / 2)) / iCount;
#endif // } DETAILED_DECODE_TIMINGS_ON
		dtiTemp.uBEF          = (dtiTemp.uBEF + (iCount / 2)) / iCount;

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo)
{
	U32 uOther;
	U32 uRoundUp;
	U32 uDivisor;

	fprintf(pFile, "\tDecode Frame =      %10d (%d milliseconds at 90Mhz)\n", pDecTimingInfo->uDecodeFrame,
			(pDecTimingInfo->uDecodeFrame + 45000) / 90000);
	uOther = pDecTimingInfo->uDecodeFrame;
	
	/* This is needed because of the integer truncation.
	 */
	uDivisor = pDecTimingInfo->uDecodeFrame / 100; // to yield a percent
	uRoundUp = uDivisor / 2;
	
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	fprintf(pFile, "\tmemcpy =            %10d (%2d%%)\n", pDecTimingInfo->uMemcpy, 
			(pDecTimingInfo->uMemcpy + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uMemcpy;
								   
	fprintf(pFile, "\tHeaders =           %10d (%2d%%)\n", pDecTimingInfo->uHeaders, 
			(pDecTimingInfo->uHeaders + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uHeaders;
								   
	fprintf(pFile, "\tFrameCopy =         %10d (%2d%%)\n", pDecTimingInfo->uFrameCopy, 
			(pDecTimingInfo->uFrameCopy + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uFrameCopy;

	fprintf(pFile, "\tDecode DCT Coeffs = %10d (%2d%%)\n", pDecTimingInfo->uDecIDCTCoeffs, 
			(pDecTimingInfo->uDecIDCTCoeffs + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uDecIDCTCoeffs;

	fprintf(pFile, "\tIDCT and MC       = %10d (%2d%%)\n", pDecTimingInfo->uIDCTandMC, 
			(pDecTimingInfo->uIDCTandMC + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uIDCTandMC;
#endif // } DETAILED_DECODE_TIMINGS_ON

	fprintf(pFile, "\tBlock Edge Filter = %10d (%2d%%)\n", pDecTimingInfo->uBEF, 
			(pDecTimingInfo->uBEF + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uBEF;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	fprintf(pFile, "\tOutput CC =         %10d (%2d%%)\n", pDecTimingInfo->uOutputCC, 
			(pDecTimingInfo->uOutputCC + uRoundUp) / uDivisor);
	uOther -= pDecTimingInfo->uOutputCC;
#endif // } DETAILED_DECODE_TIMINGS_ON

	fprintf(pFile, "\tOther =             %10d (%2d%%)\n", uOther, 
			(uOther + uRoundUp) / uDivisor);

}
#endif // } LOG_DECODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3coltbl.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// D3COLTBL.H - The color tables need to be declared here in order that the
//              assembly object files can find them.  If they are declared
//              in a CPP file the names will be mangled.   This table was
//				taken from part of MRV's COLOR.C.
//
// $Header:   S:\h26x\src\dec\d3coltbl.h_v   1.7   05 Feb 1996 13:35:44   BNICKERS  $
//
// $Log:   S:\h26x\src\dec\d3coltbl.h_v  $
;// 
;//    Rev 1.7   05 Feb 1996 13:35:44   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.6   27 Dec 1995 14:36:12   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.5   03 Nov 1995 11:49:46   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.4   30 Oct 1995 17:15:40   BNICKERS
// Fix color shift in RGB24 color convertors.
// 
//    Rev 1.3   27 Oct 1995 17:30:58   BNICKERS
// Fix RGB16 color convertors.
// 
//    Rev 1.2   26 Oct 1995 18:54:40   BNICKERS
// Fix color shift in recent YUV12 to RGB color convertors.
// 
//    Rev 1.1   25 Oct 1995 18:05:46   BNICKERS
// 
// Change to YUV12 color convertors.
// 
//    Rev 1.0   23 Aug 1995 12:35:12   DBRUCKS
// Initial revision.

#ifndef __D3COLTBL_H__
#define __D3COLTBL_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
	   
U32 UVDitherLine01[64];
U32 UVDitherLine23[64];
U8  YDither[262];
U8  Padding1[26];
U32 YDitherZ2[256];
#ifdef WIN32
U8  RValLo555[304];
U8  GValLo555[262];
U8  BValLo555[350];
U8  RValHi555[304];
U8  GValHi555[262];
U8  BValHi555[350];
U8  Padding2[216];
U8  RValLo565[304];
U8  GValLo565[262];
U8  BValLo565[350];
U8  RValHi565[304];
U8  GValHi565[262];
U8  BValHi565[350];
U8  Padding3[216];
U8  RValLo655[304];
U8  GValLo655[262];
U8  BValLo655[350];
U8  RValHi655[304];
U8  GValHi655[262];
U8  BValHi655[350];
U8  Padding4[216];
U8  RValLo664[304];
U8  GValLo664[262];
U8  BValLo664[350];
U8  RValHi664[304];
U8  GValHi664[262];
U8  BValHi664[350];
U8  Padding5[24];
U32 UVContrib[512];
U32 RValZ2555[304];
U32 GValZ2555[262];
U32 BValZ2555[350];
U32 Padding6[108];
U32 RValZ2565[304];
U32 GValZ2565[262];
U32 BValZ2565[350];
U32 Padding7[108];
U32 RValZ2655[304];
U32 GValZ2655[262];
U32 BValZ2655[350];
U32 Padding8[108];
U32 RValZ2664[304];
U32 GValZ2664[262];
U32 BValZ2664[350];
U8  Padding9[16];
U8  B24Value[701];
U8  Padding10[3];
U32 UV24Contrib[512];
#endif
int dummy;

} T_H26xColorConvertorTables;

extern T_H26xColorConvertorTables H26xColorConvertorTables;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3gob.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3gob.h
 *
 *  Description:
 *		Interface to GOB header processing.  
 */

/*
 * $Header:   S:\h26x\src\dec\d3gob.h_v   1.2   27 Dec 1995 14:36:14   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\d3gob.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
 */

#ifndef __D3GOB_H__
#define __D3GOB_H__

extern I32 H263DecodeGOBHeader(T_H263DecoderCatalog FAR * DC, 
							   BITSTREAM_STATE FAR * fpbsState,
							   U32 uAssumedGroupNumber);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3gob.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3gob.cpp
 *
 *  Description:
 *		This modules contains the GOB header support routines
 *
 *	Routines:
 *		H263SetGOBHeaderInfo
 *		
 *  Data:
 */

/*
 * $Header:   S:\h26x\src\dec\d3gob.cpv   1.13   20 Oct 1996 15:51:00   AGUPTA2  $
 * $Log:   S:\h26x\src\dec\d3gob.cpv  $
// 
//    Rev 1.13   20 Oct 1996 15:51:00   AGUPTA2
// Adjusted DbgLog trace levels; 4:Frame, 5:GOB, 6:MB, 8:everything
// 
//    Rev 1.12   20 Oct 1996 13:21:00   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.11   03 May 1996 13:07:26   CZHU
// 
// Remove assertion of GOB number because of packet loss
// 
//    Rev 1.10   28 Apr 1996 17:34:12   BECHOLS
// Fixed warning due to iLength declaration.  This variable was only used
// by a piece of code that was wrapped with IFDEF DEBUG_GOB, so I wrapped
// it with the same define.
// 
//    Rev 1.9   08 Mar 1996 16:46:14   AGUPTA2
// Changed defines to const int declarations.  Added pragmas code_seg and
// data_seg.  ifdef'd wsprintf call.
// 
// 
//    Rev 1.8   27 Dec 1995 14:36:04   RMCKENZX
// Added copyright notice
 */

#include "precomp.h"

/* BIT field Constants
 */

#define BITS_GOB_STARTCODE         17
#define BITS_GROUP_NUMBER          5
#define BITS_GFID                  2
#define BITS_GQUANT                5
#define MAX_GBSC_LOOKAHEAD_NUMBER  7

/* GBSC_VALUE - 0000 0000 0000 0000 - 1xxx xxxx xxxx xxxx 
 */
#define GBSC_VALUE  (0x00008000 >> (32-BITS_GOB_STARTCODE))

/*****************************************************************************
 *
 * 	H263DecodeGOBHeader
 *
 *  Set the GOB header information in the decoder catalog.  GOB numbers 2 thru
 *  N may have a GOB header.  Look for one if it is there read it storing the
 *  information in the catalog.  If a GOB header is not there set the information
 *  to default values.
 *
 *  Returns an ICERR_STATUS
 */
#pragma data_seg("IADATA1")

#pragma code_seg("IACODE1")
extern I32 H263DecodeGOBHeader(
	T_H263DecoderCatalog FAR * DC,
	BITSTREAM_STATE FAR * fpbsState,
	U32 uAssumedGroupNumber)
{
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	I32 iReturn;
	U32 uResult;
	int iLookAhead;
	U32 uData;

	FX_ENTRY("H263DecodeGOBHeader")

	// Decrement group number since the standard counts from 0
	// but this decoder counts from 1.
	--uAssumedGroupNumber;
    DC->bGOBHeaderPresent=0;

	if (uAssumedGroupNumber == 0) {
		//  Initialize the flag
		DC->bFoundGOBFrameID = 0;
	} 
    else 
    {
		//  Look for the GOB header Start Code
		GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	
		GET_FIXED_BITS((U32) BITS_GOB_STARTCODE, fpu8, uWork, uBitsReady, 
					   uResult);
		iLookAhead = 0;
		while (uResult != GBSC_VALUE) 
        {
			uResult = uResult << 1;
			uResult &= GetBitsMask[BITS_GOB_STARTCODE];
			GET_ONE_BIT(fpu8, uWork, uBitsReady, uData);
			uResult |= uData;
			iLookAhead++;
			if (iLookAhead >= MAX_GBSC_LOOKAHEAD_NUMBER) {
				break;	// only look ahead so far
			}
		}
		if (uResult == GBSC_VALUE)
		{
		    DC->bGOBHeaderPresent=1;
		}
	}
	
	if (DC->bGOBHeaderPresent) 
    {
		//  GN
		GET_FIXED_BITS((U32) BITS_GROUP_NUMBER, fpu8, uWork, uBitsReady,
				       uResult);
//		ASSERT(uResult == uAssumedGroupNumber);
		DC->uGroupNumber = uResult;
		/* I am assuming that GOB numbers start at 1 because if it starts at 
         * zero it makes the GOB start code look like a picture start code.
		 * Correction by TRG: GOB numbers start at 0, but there can't be a
		 * GOB header for the 0th GOB.
		 */
		// ASSERT(DC->uGroupNumber > 0);
		if (DC->uGroupNumber == 0) 
        {
			ERRORMESSAGE(("%s: There can't be a GOB header for the 0th GOB\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		//  GLCI
		if (DC->bCPM) 
        {
			ERRORMESSAGE(("%s: CPM is not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		//  GFID
		GET_FIXED_BITS((U32) BITS_GFID, fpu8, uWork, uBitsReady, uResult);
		if (DC->bFoundGOBFrameID) 
        {
			if (uResult != DC->uGOBFrameID) 
            {
				ERRORMESSAGE(("%s: GOBFrameID mismatch\r\n", _fx_));
				iReturn = ICERR_ERROR;
				goto done;
			}
			/* Should we also check it against the GOBFrameID of the previous
			 * picture when the PTYPE has not changed?
			 */
		}
		DC->uGOBFrameID = uResult;
		DC->bFoundGOBFrameID = 1;

		//  GQUANT
		GET_FIXED_BITS((U32) BITS_GQUANT, fpu8, uWork, uBitsReady, uResult);
		DC->uGQuant = uResult;
		DC->uPQuant = uResult;
		//  Save the modified bitstream state
		GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
	} 
	else 
	{
		//  We can only assume
		DC->uGroupNumber = uAssumedGroupNumber;
		/* If we already found the GOBFrameID leave it alone.  Otherwise
		 * clear it using a value indicating that it is not valid.
		 */ 
		if (! DC->bFoundGOBFrameID)
			DC->uGOBFrameID = 12345678;
		//  Default the group Quantization to the picture Quant
		DC->uGQuant = DC->uPQuant;
	}	

	DEBUGMSG(ZONE_DECODE_GOB_HEADER, (" %s: HeaderPresent=%ld GN=%ld GFID=%ld GQ=%ld\r\n", _fx_, DC->bGOBHeaderPresent, DC->uGroupNumber, DC->uGOBFrameID, DC->uGQuant));

	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodeGOBHeader() */
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3dec.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;//
;// $Author:   JMCVEIGH  $
;// $Date:   05 Feb 1997 12:24:16  $
;// $Archive:   S:\h26x\src\dec\d3dec.h_v  $
;// $Header:   S:\h26x\src\dec\d3dec.h_v   1.40   05 Feb 1997 12:24:16   JMCVEIGH  $
;//	$Log:   S:\h26x\src\dec\d3dec.h_v  $
;// 
;//    Rev 1.40   05 Feb 1997 12:24:16   JMCVEIGH
;// Support for latest H.263+ draft bitstream spec.
;// 
;//    Rev 1.39   16 Dec 1996 17:42:44   JMCVEIGH
;// Flag for improved PB-frame mode.
;// 
;//    Rev 1.38   09 Dec 1996 18:02:08   JMCVEIGH
;// Added support for arbitrary frame sizes.
;// 
;//    Rev 1.37   26 Sep 1996 09:40:54   BECHOLS
;// Added Snapshot fields to the Decoder Catalog, and Snapshot constants.
;// 
;//    Rev 1.36   10 Sep 1996 10:31:46   KLILLEVO
;// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
;// 
;//    Rev 1.35   03 May 1996 13:08:06   CZHU
;// 
;// Added fields in decoder catalog for RTP packet loss recovery
;// 
;//    Rev 1.34   22 Mar 1996 17:21:40   AGUPTA2
;// Added bMMXDecoder field in the decoder catalog.
;// 
;//    Rev 1.33   23 Feb 1996 09:46:28   KLILLEVO
;// fixed decoding of Unrestricted Motion Vector mode
;// 
;//    Rev 1.32   12 Jan 1996 15:00:14   TRGARDOS
;// Added aspect ration correction logic and code to force
;// aspect ration correction on based on INI file settings.
;// 
;//    Rev 1.31   11 Jan 1996 14:06:22   RMCKENZX
;// Added CCOffset320x240 member to the decoder catalog to support stills.
;// 
;//    Rev 1.30   06 Jan 1996 18:39:54   RMCKENZX
;// Updated copyright
;// 
;//    Rev 1.29   06 Jan 1996 18:35:08   RMCKENZX
;// Added uIs320x240 to Decoder Catalog to support still frames at
;// 320x240 resolution
;// 
;//    Rev 1.28   20 Dec 1995 15:59:14   RMCKENZX
;// Added prototype for FrameMirror to support mirror imaging
;// 
;//    Rev 1.27   18 Dec 1995 12:45:28   RMCKENZX
;// added copyright notice
;// 
;//    Rev 1.26   13 Dec 1995 11:00:46   RHAZRA
;// No change.
;// 
;//    Rev 1.25   11 Dec 1995 11:32:06   RHAZRA
;// 12-10-95 changes: added AP stuff
;// 
;//    Rev 1.24   09 Dec 1995 17:23:44   RMCKENZX
;// updated to support decoder re-architecture
;// added X32_uMBInfoStream to decoder catalog &
;// T_MBInfo structure for PB Frames.
;// added X32_pN & X32_InverseQuant to catalog for 2nd pass.
;// 
;//    Rev 1.22   26 Oct 1995 11:21:52   CZHU
;// Added uTempRefPrev to save TR for previous frame
;// 
;//    Rev 1.21   25 Oct 1995 18:09:34   BNICKERS
;// 
;// Switch to YUV12 color convertors.  Clean up archival stuff.
;// 
;//    Rev 1.20   13 Oct 1995 16:05:32   CZHU
;// First version that supports PB frames. Display B or P frames under
;// VfW for now. 
;// 
;//    Rev 1.19   11 Oct 1995 13:25:50   CZHU
;// Added code to support PB frame
;// 
;//    Rev 1.18   26 Sep 1995 15:32:36   CZHU
;// 
;// Adjust tempory buffers for motion compensation
;// 
;//    Rev 1.17   20 Sep 1995 14:47:42   CZHU
;// Added iNumberOfMBsPerGOB in decoder catalog
;// 
;//    Rev 1.16   11 Sep 1995 16:42:52   CZHU
;// Added uMBBuffer for storage used for motion compensation
;// 
;//    Rev 1.15   11 Sep 1995 14:31:12   CZHU
;// Name and type change for MV info
;// 
;//    Rev 1.14   08 Sep 1995 11:47:50   CZHU
;// 
;// Added MV info, and changed the name for motion vectors
;// 
;//    Rev 1.13   01 Sep 1995 09:49:12   DBRUCKS
;// checkin partial ajdust pels changes
;// 
;//    Rev 1.12   29 Aug 1995 16:48:12   DBRUCKS
;// add YVU9_VPITCH
;// 
;//    Rev 1.11   28 Aug 1995 10:15:04   DBRUCKS
;// update to 5 July Spec and 8/25 Errata
;// 
;//    Rev 1.10   23 Aug 1995 12:25:10   DBRUCKS
;// Turn on the color converters
;// 
;//    Rev 1.9   14 Aug 1995 16:38:30   DBRUCKS
;// add hung type and clarify pCurBlock
;// 
;//    Rev 1.8   11 Aug 1995 17:30:00   DBRUCKS
;// copy source to bitstream
;// 
;//    Rev 1.7   11 Aug 1995 15:13:00   DBRUCKS
;// ready to integrate block level
;// 
;//    Rev 1.6   04 Aug 1995 15:56:32   TRGARDOS
;// 
;// Put definition of PITCH into CDRVDEFS.H so that encoder
;// doesn't get a redefinition of MACRO warning.
;// 
;//    Rev 1.5   03 Aug 1995 10:37:54   TRGARDOS
;// 
;// Moved picture header structure definition to cdrvsdef.h.
;// 
;//    Rev 1.4   02 Aug 1995 15:31:02   DBRUCKS
;// added GOB header fields and cleaned up comments
;// 
;//    Rev 1.3   01 Aug 1995 16:24:58   DBRUCKS
;// add the picture header fields
;// 
;//    Rev 1.2   31 Jul 1995 16:28:12   DBRUCKS
;// move loacl BITS defs to D3DEC.CPP
;// 
;//    Rev 1.1   31 Jul 1995 15:51:12   CZHU
;// 
;// added quant field in the BlockActionStream structure.
;// 
;//    Rev 1.0   31 Jul 1995 13:00:06   DBRUCKS
;// Initial revision.
;// 
;//    Rev 1.2   28 Jul 1995 13:59:54   CZHU
;// 
;// Added block action stream definition and defines for constants
;// 
;//    Rev 1.1   24 Jul 1995 14:59:30   CZHU
;// 
;// Defined decoder catalog for H.263. Also defined block action stream
;// 
;//    Rev 1.0   17 Jul 1995 14:46:24   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   17 Jul 1995 14:14:40   CZHU
;// Initial revision.
;////////////////////////////////////////////////////////////////////////////
#ifndef __DECLOCS_H__
#define __DECLOCS_H__

/*
  This file declares structs which catalog the locations of various
  tables, structures, and arrays needed by the H263 decoder.
*/
//#define PITCH         384
#define YVU9_VPITCH	  336 
#define U_OFFSET      192 
#define UMV_EXPAND_Y  16
#define UMV_EXPAND_UV 8		   //expanding for Unrestricted MV in each direction
#define Y_START		(UMV_EXPAND_Y * PITCH + UMV_EXPAND_Y)
#define UV_START	(UMV_EXPAND_UV * PITCH + UMV_EXPAND_UV)
#define INSTANCE_DATA_FIXED_SIZE  512
//#define BLOCK_BUFFER_SIZE	 8*8*4*6
//Block stores for the MB are included in MB_MC_BUFFER
#define MB_MC_BUFFER_SIZE    PITCH*8
#define BLOCK_BUFFER_OFFSET  6*8

#define LEFT_EDGE   0x1
#define RIGHT_EDGE  0x2
#define TOP_EDGE    0x4
#define BOTTOM_EDGE 0x8

typedef struct {

    U32 X32_YPlane;              /* X32_-pointer to Y, V, and U planes.       */
    U32 X32_VPlane;              /* Base plus offset is 32-bit aligned  for   */
    U32 X32_UPlane;              /* all planes.                               */

} YUVFrame;

#define SRC_FORMAT_FORBIDDEN 0
#define SRC_FORMAT_SQCIF 	 1
#define SRC_FORMAT_QCIF  	 2
#define SRC_FORMAT_CIF		 3 
#define SRC_FORMAT_4CIF		 4
#define SRC_FORMAT_16CIF	 5
#define SRC_FORMAT_RES_1	 6
#define SRC_FORMAT_RES_2	 7

#ifdef H263P
// H.263+ draft, document LBC-96-358
#define SRC_FORMAT_CUSTOM    6		// Replaces SRC_FORMAT_RES_1
#define SRC_FORMAT_EPTYPE    7		// Replaces SRC_FORMAT_RES_2
#define SRC_FORMAT_RESERVED  7		// Reserved value in extened PTYPE

#define PARC_SQUARE          1
#define PARC_CIF             2
#define PARC_10_11           3
#define PARC_16_11           4
#define PARC_40_33           5
#define PARC_EXTENDED        16
#endif

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
/* Decoder Timing Data - per frame
*/
typedef struct {
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	U32	uDecodeFrame;
	U32 uBEF;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	U32	uHeaders;
	U32	uMemcpy;
	U32	uFrameCopy;
	U32	uOutputCC;
	U32	uIDCTandMC;
	U32	uDecIDCTCoeffs;
#endif // } DETAILED_DECODE_TIMINGS_ON
} DEC_TIMING_INFO;
#endif // } LOG_DECODE_TIMINGS_ON

typedef struct {
    /* Here's the data about the frame shape and location.                    */

    YUVFrame CurrFrame;  		 /* Current frame.                            */
    YUVFrame PrevFrame;  		 /* Previous frame.                           */
    YUVFrame PBFrame;	 		 /* frame to hold B blocks for H.263          */
	YUVFrame DispFrame;			 /* current frame being displayed             */

    YUVFrame PostFrame;          /* Buffer for post process and color convert.*/

    LPVOID  _p16InstPostProcess;  /* Segment containing PostFrm.               */
    U8 *     p16InstPostProcess;  /* Segment containing PostFrm (aligned)       */

    U32 uFrameHeight;            /* Actual dimensions of image.               */
    U32 uFrameWidth;			 
    U32 uYActiveHeight;          /* Dimensions of image for which blocks are  */
    U32 uYActiveWidth;           /* actually encoded.  I.e. height and width  */
    U32 uUVActiveHeight;         /* padded to multiple of eight.              */
    U32 uUVActiveWidth;

#ifdef H263P
	U32 uActualFrameHeight;		 /* Actual frame dimensions used for display  */
	U32 uActualFrameWidth;		 /* purposes one.                             */
#endif

    U32 uSz_VUPlanes;            /* Space allocated for V and U planes.       */
    U32 uSz_YPlane;              /* Space allocated for Y plane.              */
    U32 uSz_YVUPlanes;           /* Space allocated for all planes.           */
	U32 uIs320x240;				 /* Flag to indicate 320x240 frames (padded
	                                to CIF, used for stills                   */
    
    /* The data pointed to below is NOT instance specific.  On 16-bit Windows
       it is copied to the per-instance data segment.  On 32-bit Windows, it
       is in the one and only data segment, and is just pointed to here.      */
	
	U32 uMBBuffer;				 /* storage for a block                       */
    U32 X16_BlkDir;              /* Ptr array of type T_BlkDir                */
    U32 X16_BlkActionStream;     /* Params for each block                     */
    
    X32 X32_BEFDescr;            /* Catalogs eagerness & willingness to BEF   */
    X32 X32_BEFDescrCopy;        /* Address of copy of BEFDescr in BEF seg.   */
    X32 X32_BEFApplicationList;  /* List of blocks to do Block Edge Filter    */

    U32 X32_BitStream;           /* Huffman encoded bitstream for one frame.  */
	U32 uSizeBitStreamBuffer;	 /* Number of bytes allocated for this frame. */

	U32 uSrcFormat;				 /* Picture header information				  */
	U32 uPrevSrcFormat;
	U32 uTempRef;	
	U32 uTempRefPrev;
	U32 uBFrameTempRef;	 
	U32 uPQuant;
	U32 uDBQuant;
    U16 bCameraOn;
    U16 bSplitScreen;				 
	U16 bFreezeRelease;
	U16 bKeyFrame;
	U16 bUnrestrictedMotionVectors;
	U16 bArithmeticCoding;
	U16 bAdvancedPrediction;
	U16 bPBFrame;

#ifdef H263P
	// H.263+ draft, document LBC-96-358

	U16 bImprovedPBFrames;
	U16 bAdvancedIntra;
	U16 bDeblockingFilter;
	U16 bSliceStructured;
	U16 bCustomPCF;
	U16 bBackChannel;
	U16 bScalability;
	U16 bTrueBFrame;
	U16 bResampling;
	U16 bResUpdate;

	U32 uPARWidth;
	U32 uPARHeight;
#endif

	U16 bCPM;
	U16 bReadSrcFormat;

	I32 iNumberOfMBsPerGOB;
	U32 uGroupNumber;			 /* GOB header information                    */
	U32 uGOBFrameID;
	U32 uGQuant;
	U16 bFoundGOBFrameID;
	
	U16 bCoded;					 /* MB header information                     */
	U32 uMBType;

	U32  uCBPC;
	U32  uCBPY;
	U32  uDQuant;

    U8  u8CBPB;					/* 6 bit to hold CBP for 6 B blocks           */
	U8  u8Pad;
	U16 u16Pad;

	I8  i8MVDBx2;
	I8  i8MVDBy2;
	I8  i8MVD2x2;
	I8  i8MVD2y2;

	I8  i8MVD3x2;
	I8  i8MVD3y2;
	I8  i8MVD4x2;
	I8  i8MVD4y2;

    I8  i8MVDx2; 				 /* horizontal motion- mult by two             */
    I8  i8MVDy2;				 /* vertical motion - mult by two for half pel */
    U16 bPrevFrameLost;          /* Flag affecting temporal filter.           */
	
	U32 bGOBHeaderPresent;
		
    U32 Sz_BitStream;            /* Space allocated for copy of BitStream.    */
    U32 Ticker;                  /* Frame counter.                            */
    
	U32 bDisplayBFrame;          /* flag indicates that B frame displayed     */
    U16 ColorConvertor;          /* Index of color convertor to use.          */
    U16 CCOutputPitch;           /* Pitch for color converted output frame.   */
    U32 CCOffsetToLine0;         /* Offest to first line of color conv frame. */
	U32 CCOffset320x240;		 /* Color Convertor Offset to line 0
										for special Still Frame size   		  */
    
    U16 DecoderType;             /* Pick from H263, YUV9.                     */

    X16 X16_LumaAdjustment;      /* Table to adjust brightness and contrast.  */
    X16 X16_ChromaAdjustment;    /* Table to adjust saturation.               */
	/* The control code points to the flags with pointer to a BOOL
	 */
    BOOL bAdjustLuma;            /* Set if adjusting brightness and contrast. */
    BOOL bAdjustChroma;          /* Set if adjusting saturation.              */
    U16 BrightnessSetting;       /* Value used to build adjustment tables.    */
    U16 ContrastSetting;         /* Value used to build adjustment tables.    */
    U16 SaturationSetting;       /* Value used to build adjustment tables.    */
    U16 SuppressChecksum;        /* Flag indicates if should skip checksum.   */
    U16 iAPColorConvPrev;
    LPVOID pAPInstPrev;          /* Pointer  PostFrm for prev AP               */

	X32 X32_InverseQuant;               //  NEW
	X32 X32_pN;					        //  NEW
    X32 X32_uMBInfoStream;              //  PB-NEW

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	/* Timing Statistics Variables */
	X32 X32_DecTimingInfo;		 		/* Offset to */
	DEC_TIMING_INFO * pDecTimingInfo;	/* pointer, set after locking catalog */
	U32 uStatFrameCount;				/* statistics frame counter */
	/* The following are needed in lower level routines */
	int bTimingThisFrame;						
	U32 uStartLow;
	U32 uStartHigh;		
#endif // } LOG_DECODE_TIMINGS_ON

//#ifdef LOSS_RECOVERY
    I32  iVerifiedBsExt; //flat indicating whether verification is performed
	I32  iValidBsExt;    //flag indicating valid extension of bitstream
	void *pBsTrailer;    //point to the trailer of the extended bs
	void *pBsInfo;	     //point to the beginning of the BSINFO stream
	U32  uNumOfPackets;  //Number of Packets for this frame;
//#endif 
	/* Options */
	int bForceOnAspectRatioCorrection;
	int bUseBlockEdgeFilter;
#ifdef USE_MMX // { USE_MMX
    BOOL bMMXDecoder;
#endif // } USE_MMX
	
} T_H263DecoderCatalog;

typedef struct {                           // NEW
	U32   dInverseQuant;                   // NEW
    U32   dTotalRun;                       // NEW
} T_IQ_INDEX;							   // NEW

/* MBInfo
 *
 * A stream of T_MBInfo structs provides a place to hold information 
 * about the macroblocks gathered during the first pass so it can
 * be used during the second pass for B-frame bi-directional motion
 * prediction.  Each struct deals with one macroblock.
 */
typedef struct {                            // PB-NEW
    I8  i8MBType;                           // AP-NEW added by Raj
	I8  i8MVDBx2;
	I8  i8MVDBy2;
#ifdef H263P
	U8  bForwardPredOnly;		/* Flag indicating only forward prediction of B-block */
#endif
} T_MBInfo;                                 // PB-NEW


/* Block Type defines
 */
#define BT_INTRA_DC		0	// Intra block without TCOEFF
							// assembly code assumes INTRA_DC is zero
#define BT_INTRA		1  	// Intra block
#define BT_INTER		2	// Inter block
#define BT_EMPTY		3	// Inter block without TCOEFF
#define BT_ERROR		4


/* T_BlkAction
 * 
 * A stream of T_BlkAction structs provides information about the blocks to
 * be processed for a slice.  Each struct deals with one block.
 */
typedef struct {
    U8 	u8BlkType;			/* block type */ 
    I8  i8MVx2; 		    /* horizontal motion - mult by two for half pel */
    I8  i8MVy2;				/* vertical motion - mult by two for half pel */
	U8  u8Quant;		    /* quantization level for this block */
    U32 pCurBlock;			/* current image. */
    U32 pRefBlock;			/* reference image. */
	U32 pBBlock;		  	/* B block image */
	U32 uBlkNumber;			/* for debugging */
 } T_BlkAction;


typedef struct {

    X32 X32_BlkAddr;               /* Addr of block in current frame buffer. */
    
} T_BlkDir;

#ifdef WIN32
#else

/* Return offsets for these structures. */

U32 FAR H263DOffset_DequantizerTables ();

/* Return size of fixed-size tables at start of instance data. */

U32 FAR H263DSizeOf_FixedPart();

#endif

extern "C" {
void FAR ASM_CALLTYPE FrameCopy (
              HPBYTE InputPlane,	    /* Address of input data.          */
		      HPBYTE OuptutPlane,       /* Address of output data.         */
              UN FrameHeight,           /* Lines to copy.                  */
              UN FrameWidth,            /* Columns to copy.                */
			  UN Pitch);                /* Pitch.                          */

void FAR ASM_CALLTYPE FrameMirror (
              HPBYTE InputPlane,	    /* Address of input data.          */
		      HPBYTE OuptutPlane,       /* Address of output data.         */
              UN FrameHeight,           /* Lines to copy.                  */
              UN FrameWidth,            /* Columns to copy.                */
			  UN Pitch);                /* Pitch.                          */
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3halfmc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 16:46:18  $
// $Archive:   S:\h26x\src\dec\d3halfmc.cpv  $
// $Header:   S:\h26x\src\dec\d3halfmc.cpv   1.15   08 Mar 1996 16:46:18   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3halfmc.cpv  $
// 
//    Rev 1.15   08 Mar 1996 16:46:18   AGUPTA2
// Added pragma code_seg.
// 
// 
//    Rev 1.14   29 Jan 1996 17:53:56   RMCKENZX
// Completely re-wrote all 3 routines.  The loops no longer use pseudo
// SIMD logic and have been tightened to 256, 169, and 169 cycles
// for half-half, half-int, and int-half respectively.
// 
//    Rev 1.13   19 Jan 1996 17:40:36   RMCKENZX
// fixed half-int so it will correctly round
// 
//    Rev 1.12   19 Jan 1996 13:29:32   RHAZRA
// Fixed halfpixel prediction by bilinear interpolation in ASM code
// 
//    Rev 1.11   27 Dec 1995 14:36:06   RMCKENZX
// Added copyright notice
// 
//    Rev 1.10   09 Oct 1995 09:43:36   CZHU
// Fixed bug in (half,half) interpolation optimization
// 
//    Rev 1.9   08 Oct 1995 13:40:14   CZHU
// Added C version of (half,half) and use it for now until we fix the bug
// in the optimized version
// 
//    Rev 1.8   03 Oct 1995 15:06:30   CZHU
// 
// Adding debug assistance
// 
//    Rev 1.7   28 Sep 1995 15:32:22   CZHU
// Fixed bugs mast off bits after shift
// 
//    Rev 1.6   26 Sep 1995 11:13:36   CZHU
// 
// Adjust pitch back to normal, and changed UINT to U32
// 
//    Rev 1.5   25 Sep 1995 09:04:14   CZHU
// Added and cleaned some comments 
// 
//    Rev 1.4   22 Sep 1995 16:42:00   CZHU
// 
// improve pairing
// 
//    Rev 1.3   22 Sep 1995 15:59:48   CZHU
// finished first around coding of half pel interpolation and tested
// with the standalone program
// 
//    Rev 1.2   21 Sep 1995 16:56:28   CZHU
// Unit tested (half, int) case
// 
//    Rev 1.1   21 Sep 1995 12:06:22   CZHU
// More development
// 
//    Rev 1.0   20 Sep 1995 16:27:56   CZHU
// Initial revision.
// 

#include "precomp.h"

#define FRAMEPOINTER		esp

//Interpolat_Int_half interpolated the pels from the pRef block 
//Write to pNewRef.
//Assumes that pRef area has been expanded
// Todo: Loop control and setup the stack for locals,CZHU,9/20/95
//       preload output cache lines, 9/21
//       Cache preload is no longer needed, 9/21/95
// Cycles count: 50*4 =200 cycles

#pragma code_seg("IACODE2")
__declspec(naked)
void Interpolate_Half_Int (U32 pRef, U32 pNewRef)
{		
__asm {
	push	ebp
	 push	ebx
	push	edi
	 push	esi

	mov 	esi, [esp+20] 		// pRef = esp + 4 pushes + ret
	 mov	edi, [esp+24]		// pNewRef = esp + 4 pushes + ret + pRef
	sub 	edi, PITCH			// pre-decrement destination
	 mov	ebp, 8				// loop counter
	xor 	eax, eax			// clear registers
	 xor 	ebx, ebx
	xor 	ecx, ecx
	 xor	edx, edx

//--------------------------------------------------------------------------//
//
//	This loop is, basically, a 4 instruction, 2 cycle loop.
//	It is 3-folded, meaning that it works on 3 results per each 
//	2 cycle unit.  It is 8-unrolled, meaning that it does 8 results
//	(one block's row) per loop iteration.  The basic calculations
//	follow this pattern:
//
//	   pass-> 1      2       3
//	cycle	
//	  1     load |       | shift
//	      -----------------------
//	  2          |  add  | store 
//
//	This assumes that the prior pell's value was loaded and 
//	preserved from the prior result's calculation.  Therefore
//	each result uses 2 registers -- one to load (and preserve)
//	the right-hand pell, and the other (overwriting the previous
//	result's stored pell value) to add into, shift, and store out
//	of.  The add is accomplished with the lea instruction, allowing
//	a round bit to be added in without using a separate instruction.
//	
//	The preamble loads & adds for the first result, and loads 
//	for the second.  The body executes the basic pattern six times.
//	The postamble shifts and stores for the seventh result and 
//	adds, shifts, and stores for the eighth.
//
//	Timing:
//		  4	preamble (including bank conflict)
//		 12	body
//		  4	postamble
//		----------------
//		 20	per loop
//		x 8	loops
//		----------------
//		160 subtotal
//		  6	initialize
//	 	  3	finalize
//		================
//		169 total cycles
//--------------------------------------------------------------------------//

main_loop:	
// preamble
	mov 	al, 0[esi]
	 mov	bl, 1[esi]			// probable BANK CONFLICT
	mov 	dl, 0[edi]			// heat the cache
	 add	edi, PITCH			// increment destination at top
	lea 	eax, [1+eax+ebx]	// use a regular add in the preamble
	 mov	cl, 2[esi]

// body (6 pels)
	shr 	eax, 1
	 mov	dl, 3[esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	0[edi], al

	shr 	ebx, 1
	 mov	al, 4[esi]
	lea 	ecx, [ecx+edx+1]
	 mov	1[edi], bl

	shr 	ecx, 1
	 mov	bl, 5[esi]
	lea 	edx, [edx+eax+1]
	 mov	2[edi], cl

	shr 	edx, 1
	 mov	cl, 6[esi]
	lea 	eax, [eax+ebx+1]
	 mov	3[edi], dl

	shr 	eax, 1
	 mov	dl, 7[esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	4[edi], al

	shr 	ebx, 1
	 mov	al, 8[esi]
	lea 	ecx, [ecx+edx+1]
	 mov	5[edi], bl

// postamble
	shr 	ecx, 1
	 lea 	edx, [edx+eax+1]
	shr 	edx, 1
	 mov	6[edi], cl
	add 	esi, PITCH			// increment source pointer
	 mov	7[edi], dl
	dec 	ebp					// loop counter
	 jne	main_loop

// restore registers and return
	pop 	esi
	 pop	edi
	pop 	ebx
	 pop	ebp
	ret
  }	 //end of asm
}
// end Interpolate_Half_Int()
//--------------------------------------------------------------------------//


__declspec(naked)
void Interpolate_Int_Half (U32 pRef, U32 pNewRef)
{		
__asm {
	push	ebp
	 push	ebx
	push	edi
	 push	esi

	mov 	esi, [esp+20] 		// pRef = esp + 4 pushes + ret
	 mov	edi, [esp+24]		// pNewRef = esp + 4 pushes + ret + pRef
	dec 	edi					// pre-decrement destination
	 mov	ebp, 8				// loop counter
	xor 	eax, eax			// clear registers
	 xor 	ebx, ebx
	xor 	ecx, ecx
	 xor	edx, edx

//--------------------------------------------------------------------------//
//
//	This loop is, basically, a 4 instruction, 2 cycle loop.
//	It is 3-folded, meaning that it works on 3 results per each 
//	2 cycle unit.  It is 8-unrolled, meaning that it does 8 results
//	(one block's row) per loop iteration.  The basic calculations
//	follow this pattern:
//
//	   pass-> 1      2       3
//	cycle	
//	  1     load |       | shift
//	      -----------------------
//	  2          |  add  | store 
//
//	This assumes that the prior pell's value was loaded and 
//	preserved from the prior result's calculation.  Therefore
//	each result uses 2 registers -- one to load (and preserve)
//	the right-hand pell, and the other (overwriting the previous
//	result's stored pell value) to add into, shift, and store out
//	of.  The add is accomplished with the lea instruction, allowing
//	a round bit to be added in without using a separate instruction.
//	
//	The preamble loads & adds for the first result, and loads 
//	for the second.  The body executes the basic pattern six times.
//	The postamble shifts and stores for the seventh result and 
//	adds, shifts, and stores for the eighth.
//
//	Timing:
//		  4	preamble (including bank conflict)
//		 12	body
//		  4	postamble
//		----------------
//		 20	per loop
//		x 8	loops
//		----------------
//		160 subtotal
//		  6	initialize
//	 	  3	finalize
//		================
//		169 total cycles
//--------------------------------------------------------------------------//

main_loop:	
// preamble
	mov 	al, [esi]
	 mov	bl, PITCH[esi]		// probable BANK CONFLICT
	mov 	dl, [edi]			// heat the cache
	 inc	edi					// increment destination at top
	lea 	eax, [1+eax+ebx]	// use a regular add in the preamble
	 mov	cl, [2*PITCH+esi]

// body (6 pels)
	shr 	eax, 1
	 mov	dl, [3*PITCH+esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	[edi], al

	shr 	ebx, 1
	 mov	al, [4*PITCH+esi]
	lea 	ecx, [ecx+edx+1]
	 mov	[PITCH+edi], bl

	shr 	ecx, 1
	 mov	bl, [5*PITCH+esi]
	lea 	edx, [edx+eax+1]
	 mov	[2*PITCH+edi], cl

	shr 	edx, 1
	 mov	cl, [6*PITCH+esi]
	lea 	eax, [eax+ebx+1]
	 mov	[3*PITCH+edi], dl

	shr 	eax, 1
	 mov	dl, [7*PITCH+esi]
	lea 	ebx, [ebx+ecx+1]
	 mov	[4*PITCH+edi], al

	shr 	ebx, 1
	 mov	al, [8*PITCH+esi]
	lea 	ecx, [ecx+edx+1]
	 mov	[5*PITCH+edi], bl

// postamble
	shr 	ecx, 1
	 lea 	edx, [edx+eax+1]
	shr 	edx, 1
	 mov	[6*PITCH+edi], cl
	inc 	esi					// increment source pointer
	 mov	[7*PITCH+edi], dl
	dec 	ebp					// loop counter
	 jne	main_loop

// restore registers and return
	pop 	esi
	 pop	edi
	pop 	ebx
	 pop	ebp
	ret
  }	 // end of asm
}
// end Interpolate_Int_Half()
//--------------------------------------------------------------------------//


__declspec(naked)
void Interpolate_Half_Half (U32 pRef, U32 pNewRef)
{		
__asm {
	push	ebp
	 push	ebx
	push	edi
	 push	esi

	mov 	esi, [esp+20] 		// pRef = esp + 4 pushes + ret
	 mov	edi, [esp+24]		// pNewRef = esp + 4 pushes + ret + pRef
	mov		ebp, 8				// loop counter
	 sub 	edi, PITCH			// pre-decrement destination pointer
	xor 	ecx, ecx
	 xor	edx, edx

//--------------------------------------------------------------------------//
//
//	This loop is, basically, a 6 instruction, 3 cycle loop.
//	It is 3-folded, meaning that it works on 3 results per each 
//	3 cycle unit.  It is 8-unrolled, meaning that it does 8 results
//	(one block's row) per loop iteration.  The basic calculations
//	follow this pattern:
//
//	   pass-> 1        2        3
//	cycle	
//	  1     load | add left | 
//	      ----------------------------
//	  2     load |          | shift
//	      ----------------------------
//	  3          | add  all | store 
//
//	Five registers are used to preserve values from one pass to the next: 
//	  cl & dl		hold the last two pell values
//	  ebp or ebx	holds the sum of the two left-hand pells + 1
//	  eax			holds the sum of all four pells
//	Both adds are accomplished with the lea instruction.  For the sum
//	of the two left-hand pells, this allows a rounding bit to be added
//	in without using a separate instruction.  For both sums it allows
//	the result to be placed into a register independent of the sources'.
//	Since the sum of the two left-hand pells is used twice, it is place
//	alternately into ebx and ebp.
//	
//	The preamble does two preliminary loads plus passes 1 & 2 for the
//   first result, and pass 1 for the second.  The body executes the basic 
//	pattern six times.  The postamble does pass 3 for the  
//	seventh result and passes 2 & 3 for the eighth.
//
//	Due to the need for five registers, the loop counter is kept on
//	the stack.
//
//	Timing:
//		  8	preamble
//		 18	body
//		  5	postamble
//		----------------
//		 31	per loop
//		x 8	loops
//		----------------
//		248 subtotal
//		  5	initialize
//	 	  3	finalize
//		================
//		256 total cycles
//--------------------------------------------------------------------------//

main_loop:	
// preamble
	mov 	cl, [esi]					// pell 0
	 xor	eax, eax
	mov 	al, [esi+PITCH]				// pell 0
	 xor	ebx, ebx
	mov 	dl, [esi+1]					// pell 1
	 add 	eax, ecx					// partial sum 0 sans round
	mov 	bl, [esi+PITCH+1]			// pell 1
	 inc 	eax							// partial sum 0
	mov 	cl, [esi+2]					// pell 2
	 add	ebx, edx					// partial sum 1 sans round
	mov 	dl, [esi+PITCH+2]			// pell 2
	 inc	ebx							// partial sum 1
	add 	eax, ebx					// full sum 0
	 push	ebp							// save loop counter on stack
 	mov 	ebp, [edi+PITCH]			// heat the cache
	 add 	edi, PITCH					// increment dst. pointer at top of loop

// body (x 6)
	lea 	ebp, [ecx+edx+1]			// partial sum 2 with round
	 mov	cl, [esi+3]					// pell 3
	shr 	eax, 2						// value 0
	 mov	dl, [esi+PITCH+3]			// pell 3
	mov 	[edi], al					// write value 0
	 lea	eax, [ebx+ebp]				// full sum 1

	lea 	ebx, [ecx+edx+1]			// partial sum 3 with round
	 mov	cl, [esi+4]					// pell 4
	shr 	eax, 2						// value 1
	 mov	dl, [esi+PITCH+4]			// pell 4
	mov 	[edi+1], al					// write value 1
	 lea	eax, [ebx+ebp]				// full sum 2

	lea 	ebp, [ecx+edx+1]			// partial sum 4 with round
	 mov	cl, [esi+5]					// pell 5
	shr 	eax, 2						// value 2
	 mov	dl, [esi+PITCH+5]			// pell 5
	mov 	[edi+2], al					// write value 2
	 lea	eax, [ebx+ebp]				// full sum 3

	lea 	ebx, [ecx+edx+1]			// partial sum 5 with round
	 mov	cl, [esi+6]					// pell 6
	shr 	eax, 2						// value 3
	 mov	dl, [esi+PITCH+6]			// pell 6
	mov 	[edi+3], al					// write value 3
	 lea	eax, [ebx+ebp]				// full sum 4

	lea 	ebp, [ecx+edx+1]			// partial sum 6 with round
	 mov	cl, [esi+7]					// pell 7
	shr 	eax, 2						// value 4
	 mov	dl, [esi+PITCH+7]			// pell 7
	mov 	[edi+4], al					// write value 4
	 lea	eax, [ebx+ebp]				// full sum 5

	lea 	ebx, [ecx+edx+1]			// partial sum 7 with round
	 mov	cl, [esi+8]					// pell 8
	shr 	eax, 2						// value 5
	 mov	dl, [esi+PITCH+8]			// pell 8
	mov 	[edi+5], al					// write value 5
	 lea	eax, [ebx+ebp]				// full sum 6

// postamble
	shr 	eax, 2						// value 6
	 lea 	ebp, [ecx+edx+1]			// partial sum 8 with round
	mov 	[edi+6], al					// write value 6
	 add	esi, PITCH					// increment read pointer
	lea		eax, [ebx+ebp]				// full sum 7
	 pop	ebp							// restore loop counter
	shr 	eax, 2						// value 7
	 dec	ebp							// decrement loop counter
	mov 	[edi+7], al					// write value 7
	 jne	main_loop					// loop if not done

// restore registers and return
	pop 	esi
	 pop	edi
	pop 	ebx
	 pop	ebp
	ret
  }	 //end of asm
}
#pragma code_seg()
// end Interpolate_Half_Half()
//--------------------------------------------------------------------------//


/*
void Interpolate_Half_Half_C (U32 pRef, U32 pNewRef)
{
  U8 * pSrc = (U8 *) pRef;
  U8 * pDst = (U8 *) pNewRef;
  int i, j;

  for (i=0; i<8; i++, pDst+=PITCH, pSrc+=PITCH)
   	 for (j=0; j<8; j++)
	 	pDst[j] = (pSrc[j] + pSrc[j+1] + pSrc[PITCH+j] + pSrc[PITCH+j+1] + 2) >> 2;
}

void Interpolate_Int_Half_C (U32 pRef, U32 pNewRef)
{
  U8 * pSrc = (U8 *) pRef;
  U8 * pDst = (U8 *) pNewRef;
  int i, j;

  for (i=0; i<8; i++, pDst+=PITCH, pSrc+=PITCH)
   	 for (j=0; j<8; j++)
	 	pDst[j] = (pSrc[j] + pSrc[PITCH+j] + 1) >> 1;
}

void Interpolate_Half_Int_C (U32 pRef, U32 pNewRef)
{
  U8 * pSrc = (U8 *) pRef;
  U8 * pDst = (U8 *) pNewRef;
  int i, j;

  for (i=0; i<8; i++, pDst+=PITCH, pSrc+=PITCH)
   	 for (j=0; j<8; j++)
	 	pDst[j] = (pSrc[j] + pSrc[j+1] + 1) >> 1;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3idct.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   14 Mar 1996 14:56:42  $
// $Archive:   S:\h26x\src\dec\d3idct.h_v  $
// $Header:   S:\h26x\src\dec\d3idct.h_v   1.5   14 Mar 1996 14:56:42   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3idct.h_v  $
;// 
;//    Rev 1.5   14 Mar 1996 14:56:42   AGUPTA2
;// 
;//    Rev 1.4   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.3   09 Dec 1995 17:34:26   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB Frames)
// 
//    Rev 1.1   27 Nov 1995 13:13:32   CZHU
// 
// 
//    Rev 1.0   27 Nov 1995 13:08:34   CZHU
// Initial revision.

////////////////////////////////////////////////////////////////////////////////
// Input: 
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index 
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//       
//////////////////////////////////////////////////////////////////////////////////
#ifndef _DECODE_BLOCK_IDCT_INC
#define _DECODE_BLOCK_IDCT_INC

extern U32 DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                                 U32 No_Coeff, 
                                 U32 pIntraBuf, 
                                 U32 pInterBuf);

#ifdef USE_MMX // { USE_MMX
extern "C" void _fastcall MMX_DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                                 U32 No_Coeff, 
                                 U32 pInterBuf);
#endif // } USE_MMX
		
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3idct.cpp ===
//  version 003; everything except 1) segment
//                                                                         
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   25 Oct 1996 13:32:28  $
// $Archive:   S:\h26x\src\dec\d3idct.cpv  $
// $Header:   S:\h26x\src\dec\d3idct.cpv   1.11   25 Oct 1996 13:32:28   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3idct.cpv  $
// 
//    Rev 1.11   25 Oct 1996 13:32:28   AGUPTA2
// Re-scheduled butterfky code; re-arranged local var declarations.
// 
//    Rev 1.10   30 Aug 1996 08:39:56   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.9   17 Jul 1996 15:33:18   AGUPTA2
// Increased the size of clamping table ClampTbl to 128+256+128.
// 
//    Rev 1.8   08 Mar 1996 16:46:20   AGUPTA2
// Added pragma code_seg.  Rolled the initialization code.  Got rid of most
// of 32-bit displacements in instructions.  Aligned frequently executed loops
// at 4-byte boundary.  Made changes to reflect new size of MapMatrix.  Removed
// nop instructions.  Deleted code that prefetches output lines in case of
// INTRA blocks. Use ClampTbl instead of ClipPixIntra.  Do not clip output
// of INTER blocks; clipping is done in dxblkadd().  
// 
// 
//    Rev 1.7   27 Dec 1995 14:36:06   RMCKENZX
// Added copyright notice
// 
//    Rev 1.6   09 Dec 1995 17:33:20   RMCKENZX
// Re-checked in module to support decoder re-architecture (thru PB Frames)
// 
//    Rev 1.4   30 Nov 1995 18:02:14   CZHU
// Save and restore register before and after idct_acc
// 
//    Rev 1.1   27 Nov 1995 13:13:28   CZHU
// 
// 
//    Rev 1.0   27 Nov 1995 13:08:24   CZHU
// Initial revision.
// 
//Block level decoding for H.26x decoder
#include "precomp.h"

/////////////////////////////////////////////////////////////////////////
// Decode each none-empty block
// Input:  lpInst:       decoder instance,
//         lpSrc:        input bitstream,
//         lpBlockAction:
//                       the pointer to the block action stream structure
//         bitsread:     number of bits in the buffer already,
/////////////////////////////////////////////////////////////////////////

// local variable definitions
#define FRAMEPOINTER		esp
//////////////////////////////////////////////////////////////
//  L_ACCUM MUST BE LAST 256 BYTES OF A PAGE
/////////////////////////////////////////////////////////////
#define L_PRODUCT           FRAMEPOINTER    + 0 // 20 DWORD  
#define L_INPUT_INTER       L_PRODUCT       + 20*4 // DWORD
#define L_esi           	L_INPUT_INTER   + 1*4  // DWORD
#define L_NO_COEFF          L_esi           + 1*4  // DWORD
#define L_DESTBLOCK         L_NO_COEFF      + 1*4  // DWORD
#define L_LOOPCOUNTER       L_DESTBLOCK     + 1*4  // DWORD
#define L_STASHESP          L_LOOPCOUNTER   + 1*4  // DWORD
#define L_dummy             L_STASHESP      + 1*4  // 6 DWORDS
#define L_ACCUM             L_dummy         + 6*4  // 64 DWORD
#define LOCALSIZE		    (96*4)  // 96 DWORDS;multiple of cache line size

////////////////////////////////////////////////////////////////////////////////
// Input: 
//       pIQ_INDEX,   pointer to pointer for Inverse quantization and index 
//                    for the current block.
//       No_Coeff,    A 32 bit number indicate block types, etc.
//                    0--63,   inter block, number of coeff
//                    64--127  64+ intra block, number of coeff
//       pIntraBuf,   Buffer pointer for intra blocks.
//
//       pInterBuf,   Buffer pointer for inter blocks.
//
//
// return:
//       
//////////////////////////////////////////////////////////////////////////////////
#pragma code_seg("IACODE2")
__declspec(naked)
U32 DecodeBlock_IDCT ( U32 pIQ_INDEX, 
                       U32 No_Coeff, 
                       U32 pIntraBuf, 
                       U32 pInterBuf)
{		
__asm 
 {
////////////////////////////////////////////////////////////////
//  DON'T CHANGE LOCAL DECLARATIONS OR STACK POINTER ADJUSTMENT 
//  CODE WITHOUT TALKING TO ATUL
////////////////////////////////////////////////////////////////
    push    ebp                     // save callers frame pointer
      mov	ebp, esp                // make parameters accessible 
    push    esi			            // assumed preserved 
      push  edi			
    push    ebx
      mov   eax, pInterBuf			
	mov     edx, esp                // Save old ESP in edx
	  and   esp, -4096              // align at page boundary
    xor     esi, esi                // loop init
	  sub   esp, LOCALSIZE			// last 96 DWORDS of page
    lea     edi, [L_ACCUM]
      mov   ebx, 64                 // loop init
	mov     [L_STASHESP], edx       // Save old esp
      mov   edx, No_Coeff
    mov     [L_INPUT_INTER], eax
      mov   eax, ROUNDER            // loop init
	;
/////////////////////////////////////////////////////////////////
//  There is no point in pre-loading the cache.  That is because
//  after the first block it is likely to be in the cache.
//  
loop_for_init:
    mov     [edi], eax
      mov   [edi+4], eax
    mov     [edi+ebx], esi
      mov   [edi+ebx+4], esi
    mov     [edi+ebx+8], esi
      mov   [edi+ebx+12], esi
    mov     [edi+ebx+16], esi
      mov   [edi+ebx+20], esi
    add     edi, 8
      add   ebx, 16
    cmp     ebx, 192
      jl    loop_for_init

/////////////////////////////////////////////////////////////////////
// end of new init code

//end of IDCT init.
    
	cmp     edx, 65
	  jg    intra_block

    mov     ebx, pInterBuf
      jmp   pre_acc_loop

intra_block:
    mov     ebx, pIntraBuf
	  sub   edx, 65

// register:
// ebp: loop counter
// ebx: inverse quant
// ecx: index [0,63]

pre_acc_loop:
	mov     esi, pIQ_INDEX
	  mov   [L_DESTBLOCK], ebx
    mov     [L_esi], esi

ALIGN 4
acc_loop:
    mov     ebx,[esi+edx*8-8]           //Invserse Quant
	  mov   ecx,[esi+edx*8-4]           //Coeff index
    mov     [L_NO_COEFF], edx
	  call  idct_acc
	mov     esi, [L_esi]
	  mov   edx, [L_NO_COEFF]
	dec     edx
      jnz   acc_loop

	mov     edx, [L_DESTBLOCK]
	  mov   ecx, [L_INPUT_INTER]
	cmp     edx, ecx
	  jnz   call_intra_bfly

	call    idct_bfly_inter

	mov     esp, [L_STASHESP]	            // free locals  		
	  add   eax, edi 
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret

 
call_intra_bfly:
    call    idct_bfly_intra

	mov	    esp, [L_STASHESP]	            // free locals  		
	  add   eax, edi 
	pop	    ebx
	  pop   edi
	pop	    esi
	  pop   ebp
	ret
     
///////////////////////////////////////////////////////////////
// assume parameter passed in by registers
// ebx, inverse quant
// ecx, index [0,63]
idct_acc:
       
;   For every non-zero coefficient:
;     LoopCounter, on local stack, has index
;     ecx = index (0-63)
;     ebx = non-zero input
;   Note i = index
; 	 	   	 
    and ecx, 03fh				    ; Chad added to prevent GPF
     mov   [L_LOOPCOUNTER+4], ecx   ; Store Loop counter
    xor     edx, edx                ; zero out for byte read, use as dword
      mov   esi, ecx                ; move index to esi
    lea     eax, Unique             ; eax = Address of Unique[0]
      mov   ebp, ecx                ; move index to ebp
    shl     esi, 3                  ; index*8
      add   ecx, ecx                ; index*2
    add     esi, ecx                ; index*10
      lea   ecx, KernelCoeff        ; get KernelCoeff[0][0]
    lea     edi, [L_PRODUCT+4]      ; edi = address of product[0]
      mov   dl,  [eax+ebp]          ; get Unique[i]
    lea     esi, [ecx+4*esi]        ; address of KernelCoeff[i][0]
      mov   ebp, edx                ; ebp = Unique[i]
    lea     eax, [edi+edx*4]        ; eax = address of product[totalU]
      nop

;   ----------------------------------------------------------------------

;   Register usage
;     eax = addr of product[Unique[i]]
;     ebx = input[i]
;     ecx = 0, -product[x]
;     edx = KernelCoeff[i][x], product[x]= KernelCoeff[i][x] * input[i]
;     ebp = x
;     edi = addr of product[0]
;     esi = addr of KernelCoeff[i][x]
ALIGN 4
loop_for_x:
    xor     ecx, ecx
      mov   edx, [esi+ebp*4-4]      ; read KernelCoeff[i][x]
    imul    edx, ebx                ; KernelCoeff[i][x] * input[i]
    mov     [edi+ebp*4-4], edx      ; product[x] = result of imul
      sub   ecx, edx          
    mov     [eax+ebp*4-4], ecx      ; product[totalU+x] = -product[x]
     dec    ebp                       ; decrement x
    jnz    loop_for_x

;   ----------------------------------------------------------------------

;   Register usage
;     eax = MapMatrix[0][0]
;     ebx = PClass[0], accum[xxx]
;     ecx = LoopCounter, addr of MapMatrix[i][0]
;     edx = product[0], accum[PClass[i][0-15]]
;     ebp = addr of accum[0], product[MapMatrix[i][0-15]]
;     edi = addr of product[0]
;     esi = PClass[i], address of accum[PClass[i]]

    mov     ecx, [L_LOOPCOUNTER+4]   ; get i
   	 and ecx, 0ffh				    ; Chad added to prevent GPF
    lea     ebx, PClass         ; get addr of PClass[0]
      mov   esi, ecx
    shl     ecx, 4
      lea   eax, MapMatrix      ; get addr of MapMatrix[0][0]
    xor     edx, edx
      nop
    mov     dl,  [ebx+esi]          ; get PClass[i]
      lea   ecx, [eax+1*ecx]        ; get addr of MapMatrix[i][0]
    shl     edx, 2                  ; esi*4
      lea   esi, [L_ACCUM+4]          ; get addr of accum[0]
;   ----------------------------------------------------------------------
    xor     eax, eax                ; get MapMatrix[i][0]
      add   esi, edx                ; esi = address of accum[PClass[i]]
    mov     al,  [ecx]
      mov   ebx, [esi]              ; get accum[PClass[i]]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[0]]
      mov   al,  [ecx+1]            ; get pNKernel->matrix[1]
    add     ebx, ebp                ; accum[pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[0]]
      mov   edx, [esi+4]            ; get accum[1+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[1]]
      mov   al,  [ecx+2]            ; get pNKernel->matrix[2]
    add     edx, ebp                ; accum[1+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[1]] 
      mov   [esi], ebx              ; store accum[pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[0]]
    mov     [esi+4], edx            ; store accum[1+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[1]]
      mov   ebx, [esi+8]            ; get accum[2+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[2]]
      mov   al,  [ecx+3]           ; get pNKernel->matrix[3]
    add     ebx, ebp                ; accum[2+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[2]]
      mov   edx, [esi+12]           ; get accum[3+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[3]]
      mov   al,  [ecx+4]           ; get pNKernel->matrix[4]
    add     edx, ebp                ; accum[3+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[3]]
      mov   [esi+8], ebx            ; store accum[2+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[2]]
    mov     [esi+12], edx           ; store accum[3+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[3]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+16]           ; get accum[4+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[4]]
      mov   al,  [ecx+5]           ; get pNKernel->matrix[5]
    add     ebx, ebp                ; accum[4+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[4]]
      mov   edx, [esi+20]           ; get accum[5+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[5]]
      mov   al,  [ecx+6]           ; get pNKernel->matrix[6]
    add     edx, ebp                ; accum[5+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[5]] 
      mov   [esi+16], ebx           ; store accum[4+pNKernel->PClass] += 
                                    ;       product[pNKernel->matrix[4]]
    mov     [esi+20], edx           ; store accum[5+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[5]]
      mov   ebx, [esi+24]           ; get accum[6+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[6]]
      mov   al,  [ecx+7]           ; get pNKernel->matrix[7]
    add     ebx, ebp
      mov   edx, [esi+28]           ; get accum[7+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[7]]
      mov   al,  [ecx+8]           ; get pNKernel->matrix[8]
    add     edx, ebp                ; accum[7+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[7]]   
      mov   [esi+24], ebx           ; store accum[6+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[6]]
    mov     [esi+28], edx           ; store accum[7+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[7]]

;   ----------------------------------------------------------------------
      mov   ebx, [esi+32]           ; get accum[8+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[8]]
      mov   al,  [ecx+9]           ; get pNKernel->matrix[9]
    add     ebx, ebp                ; accum[8+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[8]]
      mov   edx, [esi+36]           ; get accum[9+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[9]]
      mov   al,  [ecx+10]           ; get pNKernel->matrix[10]
    add     edx, ebp                ; accum[9+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[9]] 
      mov   [esi+32], ebx           ; store accum[8+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[8]]
    mov     [esi+36], edx           ; store accum[9+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[9]]
      mov   ebx, [esi+40]           ; get accum[10+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[10]]
      mov   al,  [ecx+11]           ; get pNKernel->matrix[11]
    add     ebx, ebp
      mov   edx, [esi+44]           ; get accum[11+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[11]]
                                    ;       product[pNKernel->matrix[11]]
      mov   al,  [ecx+12]           ; get pNKernel->matrix[12]
    add     edx, ebp                ; accum[11+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[11]]
      mov   [esi+40], ebx           ; store accum[10+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[10]]
    mov     [esi+44], edx           ; store accum[11+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[11]]
;   ----------------------------------------------------------------------
      mov   ebx, [esi+48]           ; get accum[12+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[12]]
      mov   al,  [ecx+13]           ; get pNKernel->matrix[13]
    add     ebx, ebp                ; accum[12+pNKernel->PClass] += product[
                                    ;         pNKernel->matrix[12]]
      mov   edx, [esi+52]           ; get accum[13+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[13]]
      mov   al,  [ecx+14]           ; get pNKernel->matrix[14]
    add     edx, ebp                ; accum[13+pNkernel->PClass] += product[
                                    ;       pNKernel->matrix[13]] 
      mov   [esi+48], ebx           ; store accum[pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[13]]
    mov     [esi+52], edx           ; store accum[13+pNKernel->PClass] += 
                                    ;      product[pNKernel->matrix[13]]
      mov   ebx, [esi+56]           ; get accum[14+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[14]]
      mov   al,  [ecx+15]           ; get pNKernel->matrix[15]
    add     ebx, ebp
      mov   edx, [esi+60]           ; get accum[15+pNKernel->PClass]
    mov     ebp, [edi+eax*4]        ; get product[pNKernel->matrix[15]]
      mov   [esi+56], ebx           ; store accum[14+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[14]]
    add     edx, ebp                ; accum[15+pNKernel->PClass] += product[
                                    ;       pNKernel->matrix[15]]
      mov   [esi+60], edx           ; store accum[15+pNKernel->PClass] +=
                                    ;       product[pNKernel->matrix[15]]
	ret
////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers


idct_bfly_intra:
   
;   ----------------------------------------------------------------------
;   INTRA ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of DWORDS, ClipPixIntra
;   Writes to Output matrix of BYTES, OutputCoeff
;
;   Process 4 outputs per group, 0-15
;   0

    lea     esi, [L_ACCUM+4]        ; get addr of accum[0]
      mov   edi, [L_DESTBLOCK+4]    ; edi gets Base addr of OutputCoeff
    add     esi, 128
      nop
    mov     eax, [esi-128]          ; get acc[0]
      mov   ebx, [esi+64-128]       ; get acc[16]
    mov     ebp, [esi+128-128]      ; get acc[32]
      mov   edx, [esi+192-128]      ; get acc[48]
    lea     ecx, [eax+ebx]          ; acc[0]+acc[16]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi], dl      ; output[0][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+7], cl    ; output[0][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH], bl  ; output[7][0] = tmp3
      mov   ebx, [esi+68-128]       ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     BYTE PTR [edi+7*PITCH+7], al  ; output[7][7] = tmp4
      mov   eax, [esi+4-128]        ; get acc[1]
    mov     ebp, [esi+132-128]      ; get acc[33]
      mov   edx, [esi+196-128]      ; get acc[49]
    lea     ecx, [eax+ebx]          ; acc[1]+acc[17]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+1], dl    ; output[0][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+6], cl    ; output[0][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH+1], bl  ; output[7][1] = tmp3
      mov   ebx, [esi+72-128]       ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     BYTE PTR [edi+7*PITCH+6], al  ; output[7][6] = tmp4
      mov   eax, [esi+8-128]        ; get acc[2]
    mov     ebp, [esi+136-128]      ; get acc[34]
      mov   edx, [esi+200-128]      ; get acc[50]
    lea     ecx, [eax+ebx]          ; acc[2]+acc[18]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    nop
      nop
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2], dl    ; output[0][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+5], cl    ; output[0][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH+2], bl  ; output[7][2] = tmp3
      mov   ebx, [esi+76-128]       ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     BYTE PTR [edi+7*PITCH+5], al  ; output[7][5] = tmp4
      mov   eax, [esi+12-128]       ; get acc[3]
    mov     ebp, [esi+140-128]      ; get acc[35]
      mov   edx, [esi+204-128]      ; get acc[51]
    lea     ecx, [eax+ebx]          ; acc[3]+acc[19]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3], dl    ; output[0][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+4], cl    ; output[0][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+7*PITCH+3], bl  ; output[7][3] = tmp3
      mov   ebx, [esi+80-128]       ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     BYTE PTR [edi+7*PITCH+4], al  ; output[7][4] = tmp4
      mov   eax, [esi+16-128]       ; get acc[4]
    mov     ebp, [esi+144-128]      ; get acc[36]
      mov   edx, [esi+208-128]      ; get acc[52]
    lea     ecx, [eax+ebx]          ; acc[4]+acc[20]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH], dl   ; output[1][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+7], cl   ; output[1][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH], bl   ; output[6][0] = tmp3
      mov   ebx, [esi+84-128]       ; get acc[21]

;   -------------------------------------------------------------------------
;   5
    mov     BYTE PTR [edi+6*PITCH+7], al  ; output[6][7] = tmp4
      mov   eax, [esi+20-128]       ; get acc[5]
    mov     ebp, [esi+148-128]      ; get acc[37]
      mov   edx, [esi+212-128]      ; get acc[53]
    lea     ecx, [eax+ebx]          ; acc[5]+acc[21]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+1], dl   ; output[1][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+6], cl   ; output[1][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH+1], bl   ; output[6][1] = tmp3
      mov   ebx, [esi+88-128]       ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     BYTE PTR [edi+6*PITCH+6], al  ; output[6][6] = tmp4
      mov   eax, [esi+24-128]       ; get acc[6]
    mov     ebp, [esi+152-128]      ; get acc[38]
      mov   edx, [esi+216-128]      ; get acc[54]
    lea     ecx, [eax+ebx]          ; acc[6]+acc[22]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+2], dl   ; output[1][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+5], cl   ; output[1][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH+2], bl  ; output[6][2] = tmp3
      mov   ebx, [esi+92-128]       ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     BYTE PTR [edi+6*PITCH+5], al  ; output[6][5] = tmp4
      mov   eax, [esi+28-128]       ; get acc[7]
    mov     ebp, [esi+156-128]      ; get acc[39]
      mov   edx, [esi+220-128]      ; get acc[55]
    lea     ecx, [eax+ebx]          ; acc[7]+acc[23]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+PITCH+3], dl   ; output[1][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+PITCH+4], cl   ; output[1][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+6*PITCH+3], bl  ; output[6][3] = tmp3
      mov   ebx, [esi+96-128]       ; get acc[24]
;   -------------------------------------------------------------------------
;   8
    mov     BYTE PTR [edi+6*PITCH+4], al  ; output[6][4] = tmp4
      mov   eax, [esi+32-128]       ; get acc[8]
    mov     ebp, [esi+160-128]      ; get acc[40]
      mov   edx, [esi+224-128]      ; get acc[56]
    lea     ecx, [eax+ebx]          ; acc[8]+acc[24]
      sub   eax, ebx                ; acc[8]-acc[24]
    lea     ebx, [ebp+edx]          ; acc[40]+acc[56]
      sub   ebp, edx                ; acc[40]-acc[56]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[8]+acc[24] + acc[40]+acc[56]
      sub   ecx, ebx                ; tmp2 = acc[8]+acc[24] - (acc[40]+acc[56])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[8]-acc[24] + (acc[40]-acc[56])
      sub   eax, ebp                ; tmp4 = acc[8]-acc[24] - (acc[40]-acc[56])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH], dl   ; output[2][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+7], cl   ; output[2][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH], bl   ; output[5][0] = tmp3
      mov   ebx, [esi+100-128]      ; get acc[25]

;   -------------------------------------------------------------------------
;   9
    mov     BYTE PTR [edi+5*PITCH+7], al   ; output[5][7] = tmp4
      mov   eax, [esi+36-128]       ; get acc[9]
    mov     ebp, [esi+164-128]      ; get acc[41]
      mov   edx, [esi+228-128]      ; get acc[57]
    lea     ecx, [eax+ebx]          ; acc[9]+acc[25]
      sub   eax, ebx                ; acc[9]-acc[25]
    lea     ebx, [ebp+edx]          ; acc[41]+acc[57]
      sub   ebp, edx                ; acc[41]-acc[57]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[9]+acc[25] + acc[41]+acc[57]
      sub   ecx, ebx                ; tmp2 = acc[9]+acc[25] - (acc[41]+acc[57])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[9]-acc[25] + (acc[41]-acc[57])
      sub   eax, ebp                ; tmp4 = acc[9]-acc[25] - (acc[41]-acc[57])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH+1], dl   ; output[2][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+6], cl   ; output[2][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH+1], bl   ; output[5][1] = tmp3
      mov   ebx, [esi+104-128]      ; get acc[26]
;   -------------------------------------------------------------------------
;   10
    mov     BYTE PTR [edi+5*PITCH+6], al   ; output[5][6] = tmp4
      mov   eax, [esi+40-128]       ; get acc[10]
    mov     ebp, [esi+168-128]      ; get acc[42]
      mov   edx, [esi+232-128]      ; get acc[58]
    lea     ecx, [eax+ebx]          ; acc[10]+acc[26]
      sub   eax, ebx                ; acc[10]-acc[26]
    lea     ebx, [ebp+edx]          ; acc[42]+acc[58]
      sub   ebp, edx                ; acc[42]-acc[58]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[10]+acc[26] + acc[42]+acc[58]
      sub   ecx, ebx                ; tmp2 = acc[10]+acc[26] - (acc[42]+acc[58])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[10]-acc[26] + (acc[42]-acc[58])
      sub   eax, ebp                ; tmp4 = acc[10]-acc[26] - (acc[42]-acc[58])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH+2], dl   ; output[2][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+5], cl   ; output[2][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH+2], bl   ; output[5][2] = tmp3
      mov   ebx, [esi+108-128]      ; get acc[27]
;   -------------------------------------------------------------------------
;   11
    mov     BYTE PTR [edi+5*PITCH+5], al   ; output[5][5] = tmp4
      mov   eax, [esi+44-128]       ; get acc[11]
    mov     ebp, [esi+172-128]      ; get acc[43]
      mov   edx, [esi+236-128]      ; get acc[59]
    lea     ecx, [eax+ebx]          ; acc[11]+acc[27]
      sub   eax, ebx                ; acc[11]-acc[27]
    lea     ebx, [ebp+edx]          ; acc[43]+acc[59]
      sub   ebp, edx                ; acc[43]-acc[59]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[11]+acc[27] + acc[43]+acc[59]
      sub   ecx, ebx                ; tmp2 = acc[11]+acc[27] - (acc[43]+acc[59])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[11]-acc[27] + (acc[43]-acc[59])
      sub   eax, ebp                ; tmp4 = acc[11]-acc[27] - (acc[43]-acc[59])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+2*PITCH+3], dl   ; output[2][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+2*PITCH+4], cl   ; output[2][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+5*PITCH+3], bl   ; output[5][3] = tmp3
      mov   ebx, [esi+112-128]      ; get acc[28]
;   -------------------------------------------------------------------------
;   12
    mov     BYTE PTR [edi+5*PITCH+4], al   ; output[5][4] = tmp4
      mov   eax, [esi+48-128]       ; get acc[12]
    mov     ebp, [esi+176-128]      ; get acc[44]
      mov   edx, [esi+240-128]      ; get acc[60]
    lea     ecx, [eax+ebx]          ; acc[12]+acc[28]
      sub   eax, ebx                ; acc[12]-acc[28]
    lea     ebx, [ebp+edx]          ; acc[44]+acc[60]
      sub   ebp, edx                ; acc[44]-acc[60]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[12]+acc[28] + acc[44]+acc[60]
      sub   ecx, ebx                ; tmp2 = acc[12]+acc[28] - (acc[44]+acc[60])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[12]-acc[28] + (acc[44]-acc[60])
      sub   eax, ebp                ; tmp4 = acc[12]-acc[28] - (acc[44]-acc[60])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;lea   esi, [L_ACCUM+4]        ; get addr of accum[0]
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH], dl   ; output[3][0] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+7], cl   ; output[3][7] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH], bl   ; output[4][0] = tmp3
      mov   ebx, [esi+116-128]      ; get acc[29]

;   -------------------------------------------------------------------------
;   13
    mov     BYTE PTR [edi+4*PITCH+7], al   ; output[4][7] = tmp4
      mov   eax, [esi+52-128]       ; get acc[13]
    mov     ebp, [esi+180-128]      ; get acc[45]
      mov   edx, [esi+244-128]      ; get acc[61]
    lea     ecx, [eax+ebx]          ; acc[13]+acc[29]
      sub   eax, ebx                ; acc[13]-acc[29]
    lea     ebx, [ebp+edx]          ; acc[45]+acc[61]
      sub   ebp, edx                ; acc[45]-acc[61]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[13]+acc[29] + acc[45]+acc[61]
      sub   ecx, ebx                ; tmp2 = acc[13]+acc[29] - (acc[45]+acc[61])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[13]-acc[29] + (acc[45]-acc[61])
      sub   eax, ebp                ; tmp4 = acc[13]-acc[29] - (acc[45]-acc[61])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH+1], dl   ; output[3][1] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+6], cl   ; output[3][6] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH+1], bl   ; output[4][1] = tmp3
      mov   ebx, [esi+120-128]      ; get acc[30]
;   -------------------------------------------------------------------------
;   14
    mov     BYTE PTR [edi+4*PITCH+6], al   ; output[4][6] = tmp4
      mov   eax, [esi+56-128]       ; get acc[14]
    mov     ebp, [esi+184-128]      ; get acc[46]
      mov   edx, [esi+248-128]      ; get acc[62]
    lea     ecx, [eax+ebx]          ; acc[14]+acc[30]
      sub   eax, ebx                ; acc[14]-acc[30]
    lea     ebx, [ebp+edx]          ; acc[46]+acc[62]
      sub   ebp, edx                ; acc[46]-acc[62]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[14]+acc[30] + acc[46]+acc[62]
      sub   ecx, ebx                ; tmp2 = acc[14]+acc[30] - (acc[46]+acc[62])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[14]-acc[30] + (acc[46]-acc[62])
      sub   eax, ebp                ; tmp4 = acc[14]-acc[30] - (acc[46]-acc[62])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH+2], dl   ; output[3][2] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+5], cl   ; output[3][5] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH+2], bl   ; output[4][2] = tmp3
      mov   ebx, [esi+124-128]      ; get acc[31]
;   -------------------------------------------------------------------------
;   15
    mov     BYTE PTR [edi+4*PITCH+5], al   ; output[4][5] = tmp4
      mov   eax, [esi+60-128]       ; get acc[15]
    mov     ebp, [esi+188-128]      ; get acc[47]
      mov   edx, [esi+252-128]      ; get acc[63]
    lea     ecx, [eax+ebx]          ; acc[15]+acc[31]
      sub   eax, ebx                ; acc[15]-acc[31]
    lea     ebx, [ebp+edx]          ; acc[47]+acc[63]
      sub   ebp, edx                ; acc[47]-acc[63]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[15]+acc[31] + acc[47]+acc[63]
      sub   ecx, ebx                ; tmp2 = acc[15]+acc[31] - (acc[47]+acc[63])
    lea     ebx, [eax+ebp]          ; tmp3 = acc[15]-acc[31] + (acc[47]-acc[63])
      sub   eax, ebp                ; tmp4 = acc[15]-acc[31] - (acc[47]-acc[63])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebp, ClampTbl-1024+CLAMP_BIAS  ; ecx gets Base addr of ClipPixIntra
    sar     ecx, SCALER             ; tmp2 >> 13
      ;
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   dl,  [ebp+edx]          ; tmp1 = ClipPixIntra[tmp1]
    sar     eax, SCALER             ; tmp4 >> 13
      mov   cl,  [ebp+ecx]          ; tmp2 = ClipPixIntra[tmp2]
    mov     BYTE PTR [edi+3*PITCH+3], dl   ; output[3][3] = tmp1
      mov   bl,  [ebp+ebx]          ; tmp3 = ClipPixIntra[tmp3]
    mov     BYTE PTR [edi+3*PITCH+4], cl   ; output[3][4] = tmp2
      mov   al,  [ebp+eax]          ; tmp4 = ClipPixIntra[tmp4]
    mov     BYTE PTR [edi+4*PITCH+3], bl   ; output[4][3] = tmp3
      mov   BYTE PTR [edi+4*PITCH+4], al   ; output[4][4] = tmp4
    ret

////////////////////////////////////////////////////////////////////////////
//assume parameters passed in by registers

idct_bfly_inter:

;   ----------------------------------------------------------------------
;   INTER ONLY Butterfly and clamp
;   Uses all registers.
;   Uses all accumulators[64], accum
;   Uses ClipPixIntra[2048] of DWORDS, ClipPixIntra
;   Writes to Intermediate matrix [8][8] of DWORDS, Intermediate
;   NOTE:
;     Code assumes that Intermediate and accumulator arrays are aligned at
;     cache-line boundary
;   Process 4 outputs per group, 0-15
;   0

    mov     edi, [L_DESTBLOCK+4]    ; edi gets Base addr of Intermediate
      lea   esi, [L_ACCUM+4+128]    ; get addr of accum[0] biased by 128
    add     edi, 128
	  nop
    mov     ebx, [esi+64-128]       ; get acc[16]
      mov   eax, [esi-128]          ; get acc[0]  bank conflict
;	mov     edx, [edi-128]          ; pre-fetch line 0; 4 to avoid bank conflict
;	  mov   ecx, [edi+1*32-128+4]   ; pre-fetch line 1
;	mov     edx, [edi+2*32-128]     ; pre-fetch line 2
;	  mov   ecx, [edi+3*32-128+4]   ; pre-fetch line 3
;	mov     edx, [edi+4*32-128]     ; pre-fetch line 4
;	  mov   ecx, [edi+5*32-128+4]   ; pre-fetch line 5
;	mov     edx, [edi+6*32-128]     ; pre-fetch line 6
;	  mov   ecx, [edi+7*32-128+4]   ; pre-fetch line 7
	mov     ebp, [esi+128-128]      ; get acc[32]
     lea    ecx, [eax+ebx]          ; acc[0]+acc[16]
    mov     edx, [esi+192-128]      ; get acc[48]
      sub   eax, ebx                ; acc[0]-acc[16]
    lea     ebx, [ebp+edx]          ; acc[32]+acc[48]
      sub   ebp, edx                ; acc[32]-acc[48]
	lea     edx, [ecx+ebx]          ; tmp1 = acc[0]+acc[16] + acc[32]+acc[48]
      sub   ecx, ebx                ; tmp2 = acc[0]+acc[16] - (acc[32]+acc[48])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[0]-acc[16] + (acc[32]-acc[48])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[0]-acc[16] - (acc[32]-acc[48])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi-128], edx           ; Intermediate[0][0] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+7*4-128], ecx       ; Intermediate[0][7] = tmp2
    mov     DWORD PTR [edi+7*32-128], ebx      ; Intermediate[7][0] = tmp3
      mov   ebx, [esi+68-128]                  ; get acc[17]

;   -------------------------------------------------------------------------
;   1
    mov     DWORD PTR [edi+7*32+7*4-128], eax  ; Intermediate[7][7] = tmp4
      mov   eax, [esi+4-128]        ; get acc[1]
    mov     ebp, [esi+132-128]      ; get acc[33]
      lea   ecx, [eax+ebx]          ; acc[1]+acc[17]
    mov     edx, [esi+196-128]      ; get acc[49]
      sub   eax, ebx                ; acc[1]-acc[17]
    lea     ebx, [ebp+edx]          ; acc[33]+acc[49]
      sub   ebp, edx                ; acc[33]-acc[49]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[1]+acc[17] + acc[33]+acc[49]
      sub   ecx, ebx                ; tmp2 = acc[1]+acc[17] - (acc[33]+acc[49])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[1]-acc[17] + (acc[33]-acc[49])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[1]-acc[17] - (acc[33]-acc[49])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi+1*4-128], edx       ; Intermediate[0][1] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+6*4-128], ecx       ; Intermediate[0][6] = tmp2
    mov   DWORD PTR [edi+7*32+1*4-128], ebx    ; Intermediate[7][1] = tmp3
      mov   ebx, [esi+72-128]                  ; get acc[18]
;   -------------------------------------------------------------------------
;   2
    mov     DWORD PTR [edi+7*32+6*4-128], eax  ; Intermediate[7][6] = tmp4
      mov   eax, [esi+8-128]        ; get acc[2]
    mov     ebp, [esi+136-128]      ; get acc[34]
      lea   ecx, [eax+ebx]          ; acc[2]+acc[18]
    mov     edx, [esi+200-128]      ; get acc[50]
      sub   eax, ebx                ; acc[2]-acc[18]
    lea     ebx, [ebp+edx]          ; acc[34]+acc[50]
      sub   ebp, edx                ; acc[34]-acc[50]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[2]+acc[18] + acc[34]+acc[50]
      sub   ecx, ebx                ; tmp2 = acc[2]+acc[18] - (acc[34]+acc[50])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[2]-acc[18] + (acc[34]-acc[50])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[2]-acc[18] - (acc[34]-acc[50])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi+2*4-128], edx       ; Intermediate[0][2] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+5*4-128], ecx       ; Intermediate[0][5] = tmp2
    mov     DWORD PTR [edi+7*32+2*4-128], ebx  ; Intermediate[7][2] = tmp3
      mov   ebx, [esi+76-128]                  ; get acc[19]
;   -------------------------------------------------------------------------
;   3
    mov     DWORD PTR [edi+7*32+5*4-128], eax  ; Intermediate[7][5] = tmp4
      mov   eax, [esi+12-128]       ; get acc[3]
    mov     ebp, [esi+140-128]      ; get acc[35]
      lea   ecx, [eax+ebx]          ; acc[3]+acc[19]
    mov     edx, [esi+204-128]      ; get acc[51]
      sub   eax, ebx                ; acc[3]-acc[19]
    lea     ebx, [ebp+edx]          ; acc[35]+acc[51]
      sub   ebp, edx                ; acc[35]-acc[51]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[3]+acc[19] + acc[35]+acc[51]
      sub   ecx, ebx                ; tmp2 = acc[3]+acc[19] - (acc[35]+acc[51])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[3]-acc[19] + (acc[35]-acc[51])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[3]-acc[19] - (acc[35]-acc[51])
    sar     ebx, SCALER                        ; tmp3 >> 13
      mov   DWORD PTR [edi+3*4-128], edx       ; Intermediate[0][3] = tmp1
    sar     eax, SCALER                        ; tmp4 >> 13
      mov   DWORD PTR [edi+4*4-128], ecx       ; Intermediate[0][4] = tmp2
    mov     DWORD PTR [edi+7*32+3*4-128], ebx  ; Intermediate[7][3] = tmp3
      mov   ebx, [esi+80-128]                  ; get acc[20]
;   -------------------------------------------------------------------------
;   4
    mov     DWORD PTR [edi+7*32+4*4-128], eax  ; Intermediate[7][4] = tmp4
      mov   eax, [esi+16-128]       ; get acc[4]
    mov     ebp, [esi+144-128]      ; get acc[36]
      lea   ecx, [eax+ebx]          ; acc[4]+acc[20]
    mov     edx, [esi+208-128]      ; get acc[52]
      sub   eax, ebx                ; acc[4]-acc[20]
    lea     ebx, [ebp+edx]          ; acc[36]+acc[52]
      sub   ebp, edx                ; acc[36]-acc[52]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[4]+acc[20] + acc[36]+acc[52]
      sub   ecx, ebx                ; tmp2 = acc[4]+acc[20] - (acc[36]+acc[52])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[4]-acc[20] + (acc[36]-acc[52])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[4]-acc[20] - (acc[36]-acc[52])
    sar     ebx, SCALER                     ; tmp3 >> 13
      mov   DWORD PTR [edi+32-128], edx     ; Intermediate[1][0] = tmp1
    sar     eax, SCALER                     ; tmp4 >> 13
      mov   DWORD PTR [edi+32+7*4-128], ecx ; Intermediate[1][7] = tmp2
    mov     DWORD PTR [edi+6*32-128], ebx   ; Intermediate[6][0] = tmp3
      mov   ebx, [esi+84-128]               ; get acc[21]
;   -------------------------------------------------------------------------
;   5
    mov     DWORD PTR [edi+6*32+7*4-128], eax ; Intermediate[6][7] = tmp4
      mov   eax, [esi+20-128]       ; get acc[5]
    mov     ebp, [esi+148-128]      ; get acc[37]
      lea   ecx, [eax+ebx]          ; acc[5]+acc[21]
    mov     edx, [esi+212-128]      ; get acc[53]
      sub   eax, ebx                ; acc[5]-acc[21]
    lea     ebx, [ebp+edx]          ; acc[37]+acc[53]
      sub   ebp, edx                ; acc[37]-acc[53]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[5]+acc[21] + acc[37]+acc[53]
      sub   ecx, ebx                ; tmp2 = acc[5]+acc[21] - (acc[37]+acc[53])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[5]-acc[21] + (acc[37]-acc[53])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[5]-acc[21] - (acc[37]-acc[53])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+32+1*4-128], edx   ; Intermediate[1][1] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+32+6*4-128], ecx   ; Intermediate[1][6] = tmp2
    mov     DWORD PTR [edi+6*32+1*4-128], ebx ; Intermediate[6][1] = tmp3
      mov   ebx, [esi+88-128]                 ; get acc[22]
;   -------------------------------------------------------------------------
;   6
    mov     DWORD PTR [edi+6*32+6*4-128], eax ; Intermediate[6][6] = tmp4
      mov   eax, [esi+24-128]       ; get acc[6]  Bank conflict
    mov     ebp, [esi+152-128]      ; get acc[38]
      lea   ecx, [eax+ebx]          ; acc[6]+acc[22]
    mov     edx, [esi+216-128]      ; get acc[54]
      sub   eax, ebx                ; acc[6]-acc[22]
    lea     ebx, [ebp+edx]          ; acc[38]+acc[54]
      sub   ebp, edx                ; acc[38]-acc[54]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[6]+acc[22] + acc[38]+acc[54]
      sub   ecx, ebx                ; tmp2 = acc[6]+acc[22] - (acc[38]+acc[54])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[6]-acc[22] + (acc[38]-acc[54])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[6]-acc[22] - (acc[38]-acc[54])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+32+2*4-128], edx   ; Intermediate[1][2] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+32+5*4-128], ecx   ; Intermediate[1][5] = tmp2
    mov     DWORD PTR [edi+6*32+2*4-128], ebx ; Intermediate[6][2] = tmp3
      mov   ebx, [esi+92-128]                 ; get acc[23]
;   -------------------------------------------------------------------------
;   7
    mov     DWORD PTR [edi+6*32+5*4-128], eax ; Intermediate[6][5] = tmp4
      mov   eax, [esi+28-128]       ; get acc[7]
    mov     ebp, [esi+156-128]      ; get acc[39]
      lea   ecx, [eax+ebx]          ; acc[7]+acc[23]
    mov     edx, [esi+220-128]      ; get acc[55]
      sub   eax, ebx                ; acc[7]-acc[23]
    lea     ebx, [ebp+edx]          ; acc[39]+acc[55]
      sub   ebp, edx                ; acc[39]-acc[55]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[7]+acc[23] + acc[39]+acc[55]
      sub   ecx, ebx                ; tmp2 = acc[7]+acc[23] - (acc[39]+acc[55])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[7]-acc[23] + (acc[39]-acc[55])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[7]-acc[23] - (acc[39]-acc[55])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+32+3*4-128], edx   ; Intermediate[1][3] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+32+4*4-128], ecx   ; Intermediate[1][4] = tmp2
    mov     DWORD PTR [edi+6*32+3*4-128], ebx ; Intermediate[6][3] = tmp3
      mov   ebx, [esi+96-128]                 ; get acc[24]
;   -------------------------------------------------------------------------
;   8
    mov     DWORD PTR [edi+6*32+4*4-128], eax ; Intermediate[6][4] = tmp4
      mov   eax, [esi+32-128]       ; get acc[8]
    mov     ebp, [esi+160-128]      ; get acc[40]
      lea   ecx, [eax+ebx]          ; acc[8]+acc[24]
    mov     edx, [esi+224-128]      ; get acc[56]
      sub   eax, ebx                ; acc[8]-acc[24]
    lea     ebx, [ebp+edx]          ; acc[40]+acc[56]
      sub   ebp, edx                ; acc[40]-acc[56]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[8]+acc[24] + acc[40]+acc[56]
      sub   ecx, ebx                ; tmp2 = acc[8]+acc[24] - (acc[40]+acc[56])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[8]-acc[24] + (acc[40]-acc[56])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[8]-acc[24] - (acc[40]-acc[56])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32-128], edx     ; Intermediate[2][0] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+7*4-128], ecx ; Intermediate[2][7] = tmp2
    mov     DWORD PTR [edi+5*32-128], ebx     ; Intermediate[5][0] = tmp3
      mov   ebx, [esi+100-128]                ; get acc[25]
;   -------------------------------------------------------------------------
;   9
    mov     DWORD PTR [edi+5*32+7*4-128], eax ; Intermediate[5][7] = tmp4
      mov   eax, [esi+36-128]       ; get acc[9]
    mov     ebp, [esi+164-128]      ; get acc[41]
      lea   ecx, [eax+ebx]          ; acc[9]+acc[25]
    mov   edx, [esi+228-128]        ; get acc[57]
      sub   eax, ebx                ; acc[9]-acc[25]
    lea     ebx, [ebp+edx]          ; acc[41]+acc[57]
      sub   ebp, edx                ; acc[41]-acc[57]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[9]+acc[25] + acc[41]+acc[57]
      sub   ecx, ebx                ; tmp2 = acc[9]+acc[25] - (acc[41]+acc[57])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[9]-acc[25] + (acc[41]-acc[57])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[9]-acc[25] - (acc[41]-acc[57])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32+1*4-128], edx ; Intermediate[2][1] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+6*4-128], ecx ; Intermediate[2][6] = tmp2
    mov     DWORD PTR [edi+5*32+1*4-128], ebx ; Intermediate[5][1] = tmp3
      mov   ebx, [esi+104-128]                ; get acc[26]
;   -------------------------------------------------------------------------
;   10
    mov     DWORD PTR [edi+5*32+6*4-128], eax ; Intermediate[5][6] = tmp4
      mov   eax, [esi+40-128]       ; get acc[10]
    mov     ebp, [esi+168-128]      ; get acc[42]
      lea   ecx, [eax+ebx]          ; acc[10]+acc[26]
    mov     edx, [esi+232-128]      ; get acc[58]
      sub   eax, ebx                ; acc[10]-acc[26]
    lea     ebx, [ebp+edx]          ; acc[42]+acc[58]
      sub   ebp, edx                ; acc[42]-acc[58]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[10]+acc[26] + acc[42]+acc[58]
      sub   ecx, ebx                ; tmp2 = acc[10]+acc[26] - (acc[42]+acc[58])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[10]-acc[26] + (acc[42]-acc[58])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[10]-acc[26] - (acc[42]-acc[58])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32+2*4-128], edx ; Intermediate[2][2] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+5*4-128], ecx ; Intermediate[2][5] = tmp2
    mov     DWORD PTR [edi+5*32+2*4-128], ebx ; Intermediate[5][2] = tmp3
      mov   ebx, [esi+108-128]                ; get acc[27]
;   -------------------------------------------------------------------------
;   11
    mov     DWORD PTR [edi+5*32+5*4-128], eax ; Intermediate[5][5] = tmp4
      mov   eax, [esi+44-128]       ; get acc[11]
    mov     ebp, [esi+172-128]      ; get acc[43]
      lea   ecx, [eax+ebx]          ; acc[11]+acc[27]
    mov   edx, [esi+236-128]        ; get acc[59]
      sub   eax, ebx                ; acc[11]-acc[27]
    lea     ebx, [ebp+edx]          ; acc[43]+acc[59]
      sub   ebp, edx                ; acc[43]-acc[59]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[11]+acc[27] + acc[43]+acc[59]
      sub   ecx, ebx                ; tmp2 = acc[11]+acc[27] - (acc[43]+acc[59])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[11]-acc[27] + (acc[43]-acc[59])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[11]-acc[27] - (acc[43]-acc[59])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+2*32+3*4-128], edx ; Intermediate[2][3] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+2*32+4*4-128], ecx ; Intermediate[2][4] = tmp2
    mov     DWORD PTR [edi+5*32+3*4-128], ebx ; Intermediate[5][3] = tmp3
      mov   ebx, [esi+112-128]                ; get acc[28]
;   -------------------------------------------------------------------------
;   12
    mov     DWORD PTR [edi+5*32+4*4-128], eax ; Intermediate[5][4] = tmp4
      mov   eax, [esi+48-128]       ; get acc[12] Bank conflict
    mov     ebp, [esi+176-128]      ; get acc[44]
      lea   ecx, [eax+ebx]          ; acc[12]+acc[28]
    mov     edx, [esi+240-128]      ; get acc[60]
      sub   eax, ebx                ; acc[12]-acc[28]
    lea     ebx, [ebp+edx]          ; acc[44]+acc[60]
      sub   ebp, edx                ; acc[44]-acc[60]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[12]+acc[28] + acc[44]+acc[60]
      sub   ecx, ebx                ; tmp2 = acc[12]+acc[28] - (acc[44]+acc[60])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[12]-acc[28] + (acc[44]-acc[60])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[12]-acc[28] - (acc[44]-acc[60])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32-128], edx     ; Intermediate[3][0] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+7*4-128], ecx ; Intermediate[3][7] = tmp2
    mov     DWORD PTR [edi+4*32-128], ebx     ; Intermediate[4][0] = tmp3
      mov   ebx, [esi+116-128]                ; get acc[29]

;   -------------------------------------------------------------------------
;   13
    mov     DWORD PTR [edi+4*32+7*4-128], eax ; Intermediate[4][7] = tmp4
      mov   eax, [esi+52-128]       ; get acc[13]
    mov     ebp, [esi+180-128]      ; get acc[45]
      lea   ecx, [eax+ebx]          ; acc[13]+acc[29]
    mov     edx, [esi+244-128]      ; get acc[61]
      sub   eax, ebx                ; acc[13]-acc[29]
    lea     ebx, [ebp+edx]          ; acc[45]+acc[61]
      sub   ebp, edx                ; acc[45]-acc[61]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[13]+acc[29] + acc[45]+acc[61]
      sub   ecx, ebx                ; tmp2 = acc[13]+acc[29] - (acc[45]+acc[61])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[13]-acc[29] + (acc[45]-acc[61])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[13]-acc[29] - (acc[45]-acc[61])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32+1*4-128], edx ; Intermediate[3][1] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+6*4-128], ecx ; Intermediate[3][6] = tmp2
    mov     DWORD PTR [edi+4*32+1*4-128], ebx ; Intermediate[4][1] = tmp3
      mov   ebx, [esi+120-128]                ; get acc[30]
;   -------------------------------------------------------------------------
;   14
    mov     DWORD PTR [edi+4*32+6*4-128], eax ; Intermediate[4][6] = tmp4
      mov   eax, [esi+56-128]       ; get acc[14]  Bank conflict
    mov     ebp, [esi+184-128]      ; get acc[46]
      lea   ecx, [eax+ebx]          ; acc[14]+acc[30]
    mov     edx, [esi+248-128]      ; get acc[62]
      sub   eax, ebx                ; acc[14]-acc[30]
    lea     ebx, [ebp+edx]          ; acc[46]+acc[62]
      sub   ebp, edx                ; acc[46]-acc[62]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[14]+acc[30] + acc[46]+acc[62]
      sub   ecx, ebx                ; tmp2 = acc[14]+acc[30] - (acc[46]+acc[62])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[14]-acc[30] + (acc[46]-acc[62])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[14]-acc[30] - (acc[46]-acc[62])
    sar     ebx, SCALER                       ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32+2*4-128], edx ; Intermediate[3][2] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+5*4-128], ecx ; Intermediate[3][5] = tmp2
    mov     DWORD PTR [edi+4*32+2*4-128], ebx ; Intermediate[4][2] = tmp3
      mov   ebx, [esi+124-128]                ; get acc[31]
;   -------------------------------------------------------------------------
;   15
    mov     DWORD PTR [edi+4*32+5*4-128], eax ; Intermediate[4][5] = tmp4
      mov   eax, [esi+60-128]       ; get acc[15]
    mov     ebp, [esi+188-128]      ; get acc[47]
      lea   ecx, [eax+ebx]          ; acc[15]+acc[31]
    mov     edx, [esi+252-128]      ; get acc[63]
      sub   eax, ebx                ; acc[15]-acc[31]
    lea     ebx, [ebp+edx]          ; acc[47]+acc[63]
      sub   ebp, edx                ; acc[47]-acc[63]
    lea     edx, [ecx+ebx]          ; tmp1 = acc[15]+acc[31] + acc[47]+acc[63]
      sub   ecx, ebx                ; tmp2 = acc[15]+acc[31] - (acc[47]+acc[63])
    sar     edx, SCALER             ; tmp1 >> 13
      lea   ebx, [eax+ebp]          ; tmp3 = acc[15]-acc[31] + (acc[47]-acc[63])
    sar     ecx, SCALER             ; tmp2 >> 13
      sub   eax, ebp                ; tmp4 = acc[15]-acc[31] - (acc[47]-acc[63])
    sar     ebx, SCALER             ; tmp3 >> 13
      mov   DWORD PTR [edi+3*32+3*4-128], edx ; Intermediate[3][3] = tmp1
    sar     eax, SCALER                       ; tmp4 >> 13
      mov   DWORD PTR [edi+3*32+4*4-128], ecx ; Intermediate[3][4] = tmp2
    mov     DWORD PTR [edi+4*32+3*4-128], ebx ; Intermediate[4][3] = tmp3
      mov   DWORD PTR [edi+4*32+4*4-128], eax ; Intermediate[4][4] = tmp4
    ret
	} //end of asm

}
 
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3mblk.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   JMCVEIGH  $
// $Date:   21 Jan 1997 08:53:16  $
// $Archive:   S:\h26x\src\dec\d3mblk.cpv  $
// $Header:   S:\h26x\src\dec\d3mblk.cpv   1.60   21 Jan 1997 08:53:16   JMCVEIGH  $
// $Log:   S:\h26x\src\dec\d3mblk.cpv  $
// 
//    Rev 1.60   21 Jan 1997 08:53:16   JMCVEIGH
// Before we calculated the interpolated index for MC prior to 
// clipping for UMV. We might then reference outside of the 16 pel
// wide padded border. Moved calculation of interp_index to after
// UMV clipping.
// 
//    Rev 1.59   16 Dec 1996 17:45:26   JMCVEIGH
// Proper motion vector decoding and prediction for forward prediction
// in B portion of improved PB-frame.
// 
//    Rev 1.58   09 Dec 1996 15:54:10   GMLIM
// 
// Added a debug message in H263BBlockPrediction() for the case where
// TR == TR_Prev.  Set iTRD = 256 to avoid divide by 0.
// 
//    Rev 1.57   27 Sep 1996 17:29:24   KLILLEVO
// 
// added clipping of extended motion vectors for MMX
// 
//    Rev 1.56   26 Sep 1996 13:56:52   KLILLEVO
// 
// fixed a totally bogus version of the extended motion vectors
// 
//    Rev 1.55   26 Sep 1996 11:32:16   KLILLEVO
// extended motion vectors now work for AP on the P54C chip
// 
//    Rev 1.54   25 Sep 1996 08:05:32   KLILLEVO
// initial extended motion vectors support 
// does not work for AP yet
// 
//    Rev 1.53   09 Jul 1996 16:46:00   AGUPTA2
// MMX code now clears DC value for INTRA blocks and adds it back during
// ClipANdMove; this is to solve overflow problem.
// 
//    Rev 1.52   29 May 1996 10:18:36   AGUPTA2
// MMX need not be defd to use MMX decoder.
// 
//    Rev 1.51   04 Apr 1996 11:06:16   AGUPTA2
// Added calls to MMX_BlockCopy().
// 
//    Rev 1.50   01 Apr 1996 13:05:28   RMCKENZX
// Added MMx functionality for Advance Prediction and PB Frames.
// 
//    Rev 1.49   22 Mar 1996 17:50:30   AGUPTA2
// MMX support.  MMX support is included only if MMX defined. MMX is
// not defined by default so that we do not impact IA code size.
// 
//    Rev 1.48   08 Mar 1996 16:46:22   AGUPTA2
// Added pragmas code_seg and data_seg to place code and data in appropriate 
// segments.  Created a function table of interpolation rtns.; interpolation
// rtns. are now called thru this function table.  Commented out the clipping of
// MV code.  It is not needed now and it needs to be re-written to be more
// efficient.
// 
// 
//    Rev 1.47   23 Feb 1996 09:46:54   KLILLEVO
// fixed decoding of Unrestricted Motion Vector mode
// 
//    Rev 1.46   29 Jan 1996 17:50:48   RMCKENZX
// Reorganized logic in H263IDCTandMC for AP, optimizing the changes 
// made for revision 1.42 and simplifying logic for determining iNext[i].
// Also corrected omission for UMV decoding in H263BBlockPrediction.
// 
//    Rev 1.0   29 Jan 1996 12:44:00   RMCKENZX
// Initial revision.
// 
//    Rev 1.45   24 Jan 1996 13:22:06   BNICKERS
// Turn OBMC back on.
// 
//    Rev 1.44   16 Jan 1996 11:46:22   RMCKENZX
// Added support for UMV -- to correctly decode B-block
// motion vectors when UMV is on
// 
//    Rev 1.43   15 Jan 1996 14:34:32   BNICKERS
// 
// Temporarily turn off OBMC until encoder can be changed to do it too.
// 
//    Rev 1.42   12 Jan 1996 16:29:48   BNICKERS
// 
// Correct OBMC to be spec compliant when neighbor is Intra coded.
// 
//    Rev 1.41   06 Jan 1996 18:36:58   RMCKENZX
// Simplified rounding logic for chroma motion vector computation
// using MUCH smaller tables (at the cost of a shift, add, and mask
// per vector).
// 
//    Rev 1.40   05 Jan 1996 15:59:12   RMCKENZX
// 
// fixed bug in decoding forward b-frame motion vectors
// so that they will stay within the legal ranges.
// re-organized the BBlockPredict function - using only
// one test for 4 motion vectors and a unified call to
// do the backward prediction for both lumina and chroma blocks.
// 
//    Rev 1.39   21 Dec 1995 17:05:24   TRGARDOS
// Added comments about descrepancy with H.263 spec.
// 
//    Rev 1.38   21 Dec 1995 13:24:28   RMCKENZX
// Fixed bug on pRefL, re-architected IDCTandMC 
// 
//    Rev 1.37   18 Dec 1995 12:46:34   RMCKENZX
// added copyright notice
// 
//    Rev 1.36   16 Dec 1995 20:34:04   RHAZRA
// 
// Changed declaration of pRefX to U32
// 
//    Rev 1.35   15 Dec 1995 13:53:32   RHAZRA
// 
// AP cleanup
// 
//    Rev 1.34   15 Dec 1995 10:51:38   RHAZRA
// 
// Changed reference block addresses in AP
// 
//    Rev 1.33   14 Dec 1995 17:04:16   RHAZRA
// 
// Cleanup in the if-then-else structure in the OBMC part
// 
//    Rev 1.32   13 Dec 1995 22:11:56   RHAZRA
// AP cleanup
// 
//    Rev 1.31   13 Dec 1995 10:59:26   RHAZRA
// More AP+PB fixes
// 
//    Rev 1.29   11 Dec 1995 11:33:12   RHAZRA
// 12-10-95 changes: added AP stuff
// 
//    Rev 1.28   09 Dec 1995 17:31:22   RMCKENZX
// Gutted and re-built file to support decoder re-architecture.
// New modules are:
// H263IDCTandMC
// H263BFrameIDCTandBiMC
// H263BBlockPrediction
// This module now contains code to support the second pass of the decoder.
// 
//    Rev 1.27   23 Oct 1995 13:28:42   CZHU
// Use the right quant for B blocks and call BlockAdd for type 3/4 too
// 
//    Rev 1.26   17 Oct 1995 17:18:24   CZHU
// Fixed the bug in decoding PB block CBPC 
// 
//    Rev 1.25   13 Oct 1995 16:06:20   CZHU
// First version that supports PB frames. Display B or P frames under
// VfW for now. 
// 
//    Rev 1.24   11 Oct 1995 17:46:28   CZHU
// Fixed bitstream bugs
// 
//    Rev 1.23   11 Oct 1995 13:26:00   CZHU
// Added code to support PB frame
// 
//    Rev 1.22   27 Sep 1995 16:24:14   TRGARDOS
// 
// Added debug print statements.
// 
//    Rev 1.21   26 Sep 1995 15:33:52   CZHU
// 
// Adjusted buffers used for MB for inter frame motion compensation
// 
//    Rev 1.20   19 Sep 1995 10:37:04   CZHU
// 
// Cleaning up
// 
//    Rev 1.19   15 Sep 1995 09:39:34   CZHU
// 
// Update both GOB Quant and Picture Quant after DQUANT
// 
//    Rev 1.18   14 Sep 1995 10:11:48   CZHU
// Fixed bugs updating Quant for the picture
// 
//    Rev 1.17   13 Sep 1995 11:57:08   CZHU
// 
// Fixed bugs in calling Chroma BlockAdd parameters.
// 
//    Rev 1.16   12 Sep 1995 18:18:40   CZHU
// Call BlockAdd finally.
// 
//    Rev 1.15   12 Sep 1995 11:12:38   CZHU
// Call blockCopy for MB that is not coded.
// 
//    Rev 1.14   11 Sep 1995 16:43:26   CZHU
// Changed interface to DecodeBlock. Added interface calls to BlockCopy and Bl
// 
//    Rev 1.13   11 Sep 1995 14:30:12   CZHU
// MVs decoding.
// 
//    Rev 1.12   08 Sep 1995 11:48:12   CZHU
// Added support for Delta frames, also fixed early bugs regarding INTER CBPY
// 
//    Rev 1.11   25 Aug 1995 09:16:32   DBRUCKS
// add ifdef DEBUG_MBLK
// 
//    Rev 1.10   23 Aug 1995 19:12:02   AKASAI
// Fixed gNewTAB_CBPY table building.  Was using 8 as mask instead of 0xf.
// 
//    Rev 1.9   18 Aug 1995 15:03:22   CZHU
// 
// Output more error message when DecodeBlock returns error.
// 
//    Rev 1.8   16 Aug 1995 14:26:54   CZHU
// 
// Changed DWORD adjustment back to byte oriented reading.
// 
//    Rev 1.7   15 Aug 1995 09:54:18   DBRUCKS
// improve stuffing handling and add debug msg
// 
//    Rev 1.6   14 Aug 1995 18:00:40   DBRUCKS
// add chroma parsing
// 
//    Rev 1.5   11 Aug 1995 17:47:58   DBRUCKS
// cleanup
// 
//    Rev 1.4   11 Aug 1995 16:12:28   DBRUCKS
// add ptr check to MB data
// 
//    Rev 1.3   11 Aug 1995 15:10:58   DBRUCKS
// finish INTRA mb header parsing and callblock
// 
//    Rev 1.2   03 Aug 1995 14:30:26   CZHU
// Take block level operations out to d3block.cpp
// 
//    Rev 1.1   02 Aug 1995 10:21:12   CZHU
// Added asm codes for VLD of TCOEFF, inverse quantization, run-length decode.
// 
//    Rev 1.0   31 Jul 1995 13:00:08   DBRUCKS
// Initial revision.
// 
//    Rev 1.2   31 Jul 1995 11:45:42   CZHU
// changed the parameter list
// 
//    Rev 1.1   28 Jul 1995 16:25:52   CZHU
// 
// Added per block decoding framework.
// 
//    Rev 1.0   28 Jul 1995 15:20:16   CZHU
// Initial revision.

//Block level decoding for H.26x decoder

#include "precomp.h"

extern "C" {
    void H263BiMotionComp(U32, U32, I32, I32, I32);
    void H263OBMC(U32, U32, U32, U32, U32, U32);
}

#ifdef USE_MMX // { USE_MMX
extern "C" {
	void MMX_AdvancePredict(T_BlkAction FAR *, int *, U8 *, I8 *, I8 *);
	void MMX_BiMotionComp(U32, U32, I32, I32, I32);
}
#endif // } USE_MMX

void AdvancePredict(T_BlkAction FAR *fpBlockAction, int *iNext, U8 *pDst, int, int, BOOL);

#pragma data_seg("IARDATA2")
char QuarterPelRound[] =
    {0, 1, 0, 0};
char SixteenthPelRound[] =
    {0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1};
void (*Interpolate_Table[4])(U32, U32) = 
    {NULL, 
     Interpolate_Half_Int, 
     Interpolate_Int_Half, 
     Interpolate_Half_Half};
#ifdef USE_MMX // { USE_MMX
void (_fastcall *  MMX_Interpolate_Table[4])(U32, U32) = 
    {NULL, 
     MMX_Interpolate_Half_Int, 
     MMX_Interpolate_Int_Half, 
     MMX_Interpolate_Half_Half};
#endif // } USE_MMX

I8 i8EMVClipTbl_NoClip[128] = {
-64,-63,-62,-61,-60,-59,-58,-57,
-56,-55,-54,-53,-52,-51,-50,-49,
-48,-47,-46,-45,-44,-43,-42,-41,
-40,-39,-38,-37,-36,-35,-34,-33,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10, -9,
 -8, -7, -6, -5, -4, -3, -2, -1,
  0,  1,  2,  3,  4,  5,  6,  7,
  8,  9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23,
 24, 25, 26, 27, 28, 29, 30, 31,
 32, 33, 34, 35, 36, 37, 38, 39,
 40, 41, 42, 43, 44, 45, 46, 47,
 48, 49, 50, 51, 52, 53, 54, 55,
 56, 57, 58, 59, 60, 61, 62, 63,
}; 
I8 i8EMVClipTbl_HiClip[128] = {
-64,-63,-62,-61,-60,-59,-58,-57,
-56,-55,-54,-53,-52,-51,-50,-49,
-48,-47,-46,-45,-44,-43,-42,-41,
-40,-39,-38,-37,-36,-35,-34,-33,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10, -9,
 -8, -7, -6, -5, -4, -3, -2, -1,
  0,  1,  2,  3,  4,  5,  6,  7,
  8,  9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23,
 24, 25, 26, 27, 28, 29, 30, 31,
 32, 32, 32, 32, 32, 32, 32, 32,
 32, 32, 32, 32, 32, 32, 32, 32,
 32, 32, 32, 32, 32, 32, 32, 32,
 32, 32, 32, 32, 32, 32, 32, 32,
};
I8 i8EMVClipTbl_LoClip[128] = {
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-32,-32,-32,-32,-32,-32,-32,
-32,-31,-30,-29,-28,-27,-26,-25,
-24,-23,-22,-21,-20,-19,-18,-17,
-16,-15,-14,-13,-12,-11,-10, -9,
 -8, -7, -6, -5, -4, -3, -2, -1,
  0,  1,  2,  3,  4,  5,  6,  7,
  8,  9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23,
 24, 25, 26, 27, 28, 29, 30, 31,
 32, 33, 34, 35, 36, 37, 38, 39,
 40, 41, 42, 43, 44, 45, 46, 47,
 48, 49, 50, 51, 52, 53, 54, 55,
 56, 57, 58, 59, 60, 61, 62, 63,
};

#pragma data_seg(".data")

#pragma code_seg("IACODE2")
// doing this as a function instead of a macro should save
// some codespace.
void UmvOnEdgeClipMotionVectors2(I32 *mvx, I32 *mvy, int EdgeFlag, int BlockNo) 
{   
	int MaxVec;

	if (BlockNo < 4)
		MaxVec = 32;
	else 
		MaxVec = 16;

	if (EdgeFlag & LEFT_EDGE)  
	{
		if (*mvx < -MaxVec) 
			*mvx = -MaxVec; 
	}
	if (EdgeFlag & RIGHT_EDGE) 
	{
		if (*mvx > MaxVec ) 
			*mvx = MaxVec ;
	}
	if (EdgeFlag & TOP_EDGE) 
	{
		if (*mvy < -MaxVec )
			*mvy = -MaxVec ; 
	}
	if (EdgeFlag & BOTTOM_EDGE)
	{
		if (*mvy > MaxVec )
			*mvy = MaxVec ;
	}
}
#pragma code_seg()

/*****************************************************************************
 *
 *  H263IDCTandMC
 *
 *  Inverse Discrete Cosine Transform and
 *  Motion Compensation for each block
 *
 */

#pragma code_seg("IACODE2")
void H263IDCTandMC(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction, 
    int                       iBlock,
    int                       iMBNum,     // AP-NEW
    int                       iGOBNum, // AP-NEW
    U32                      *pN,                         
    T_IQ_INDEX               *pRUN_INVERSE_Q,
    T_MBInfo                 *fpMBInfo,      // AP-NEW
    int                       iEdgeFlag
)
{
    I32 pRef;
    int iNext[4];            // Left-Right-Above-Below
    I32 mvx, mvy;
    U32 pRefTmp;
    int i;

    ASSERT(*pN != 65);
    
    if (*pN < 65) // Inter block
    {
		int interp_index;

		// first do motion compensation
		// result will be pointed to by pRef

		pRef = (U32) DC + DC->uMBBuffer;
		mvx = fpBlockAction[iBlock].i8MVx2;
		mvy = fpBlockAction[iBlock].i8MVy2;

		// Clip motion vectors pointing outside active image area
		if (DC->bUnrestrictedMotionVectors)  
		{
			UmvOnEdgeClipMotionVectors2(&mvx,&mvy,iEdgeFlag,iBlock);
		}

		pRefTmp = fpBlockAction[iBlock].pRefBlock +
				(I32) (mvx >> 1) +
				PITCH * (I32) (mvy >> 1); 

		// Must calculate AFTER UMV clipping
		interp_index = ((mvy & 0x1)<<1) | (mvx & 0x1);

		// Do non-OBMC prediction if this is a chroma block OR
		// a luma block in non-AP mode of operation
		if ( (!DC->bAdvancedPrediction) || (iBlock > 3) )
		{
			if (interp_index)
			{
			//  TODO
#ifdef USE_MMX // { USE_MMX
			if (DC->bMMXDecoder)
				(*MMX_Interpolate_Table[interp_index])(pRefTmp, pRef);
			else
				(*Interpolate_Table[interp_index])(pRefTmp, pRef);
#else // }{ USE_MMX
				(*Interpolate_Table[interp_index])(pRefTmp, pRef);
#endif // } USE_MMX
			}
			else
				pRef = pRefTmp;
		}
		else  // Overlapped block motion compensation
		{
      
			ASSERT (DC->bAdvancedPrediction);
			ASSERT ( (iBlock <= 3) );

			//  Compute iNext[i] which will point at the adjacent blocks.

			// Left & Right blocks
			if (iBlock & 1)    { // blocks 1 or 3, on right
				iNext[0] = -1;
				if ( iMBNum == DC->iNumberOfMBsPerGOB )
					iNext[1] = 0;
				else
					iNext[1] = 5;
			}
			else { // blocks 0 or 2, on left
				iNext[1] = 1;
				if (iMBNum == 1)
					iNext[0] = 0;
				else
					iNext[0] = -5;
			}

			// Above & Below blocks
			if (iBlock > 1)    { // blocks 2 or 3, on bottom
				iNext[2] = -2;
				iNext[3] = 0;
			}
			else { // blocks 0 or 1, on top
				iNext[3] = 2;
				if (iGOBNum == 1)
					iNext[2] = 0;
				else
					iNext[2] = -6*DC->iNumberOfMBsPerGOB + 2;
			}

			//  When PB frames are OFF
			//    if there is a neighbor and it is INTRA, use this block's vector instead.
			if (!DC->bPBFrame) 
				for (i=0; i<4; i++)
					// block types:  0=INTRA_DC, 1=INTRA, 2=INTER, 3=EMPTY, 4=ERROR
					if (iNext[i] && fpBlockAction[iBlock+iNext[i]].u8BlkType < 2) 
						iNext[i] = 0;
      
			// Now do overlapped motion compensation; output to pRef
#ifdef USE_MMX // { USE_MMX
			if (DC->bMMXDecoder)
			{

				I8 *pClipX, *pClipY;

				pClipY = pClipX = &i8EMVClipTbl_NoClip[0];
				if (DC->bUnrestrictedMotionVectors)
				{
					if (iEdgeFlag & TOP_EDGE)
						pClipY = &i8EMVClipTbl_LoClip[0];
					else if (iEdgeFlag & BOTTOM_EDGE)
						pClipY = &i8EMVClipTbl_HiClip[0];
					if (iEdgeFlag & LEFT_EDGE)
						pClipX = &i8EMVClipTbl_LoClip[0];
					else if (iEdgeFlag & RIGHT_EDGE)
						pClipX = &i8EMVClipTbl_HiClip[0];
				}
				MMX_AdvancePredict(fpBlockAction+iBlock, iNext, (U8*)pRef, pClipX, pClipY);
			}
			else
				AdvancePredict(fpBlockAction+iBlock, iNext, (U8*)pRef, iEdgeFlag, iBlock, DC->bUnrestrictedMotionVectors);
#else // }{ USE_MMX
				AdvancePredict(fpBlockAction+iBlock, iNext, (U8*)pRef, iEdgeFlag, iBlock, DC->bUnrestrictedMotionVectors);
#endif // } USE_MMX

		} // end OBMC
                                                         
		// now do the inverse transform (where appropriate) & combine
		if (*pN > 0) // and, of course, < 65.
		{
		// Get residual block; output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
		// Finally add the residual to the reference block
		//  TODO
#ifdef USE_MMX // { USE_MMX
		if (DC->bMMXDecoder)
		{
			MMX_DecodeBlock_IDCT(
				(U32)pRUN_INVERSE_Q, 
				*pN,
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter  output
			MMX_BlockAdd(
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // output
				pRef,                                            // prediction
				fpBlockAction[iBlock].pCurBlock);                // destination
		}
		else
		{
			DecodeBlock_IDCT(
				(U32)pRUN_INVERSE_Q, 
				*pN,
				fpBlockAction[iBlock].pCurBlock,                // not used here
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);// inter  output
			BlockAdd(
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET, // output
				pRef,                                           // prediction
				fpBlockAction[iBlock].pCurBlock);               // destination
		}
#else // }{ USE_MMX
			DecodeBlock_IDCT(
				(U32)pRUN_INVERSE_Q, 
				*pN,
				fpBlockAction[iBlock].pCurBlock,                // not used here
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);// inter  output
			BlockAdd(
				(U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET, // output
				pRef,                                           // prediction
				fpBlockAction[iBlock].pCurBlock);               // destination
#endif // } USE_MMX
		}
		else  // *pN == 0, so no transform coefficients for this block
		{
		// Just copy motion compensated reference block
#ifdef USE_MMX // { USE_MMX
			if (DC->bMMXDecoder)
				MMX_BlockCopy(
					fpBlockAction[iBlock].pCurBlock,                    // destination 
					pRef);                                              // prediction
			else
				BlockCopy(
					fpBlockAction[iBlock].pCurBlock,                   // destination
					pRef);                                             // prediction
#else // }{ USE_MMX
				BlockCopy(
					fpBlockAction[iBlock].pCurBlock,                   // destination
					pRef);                                             // prediction
#endif // } USE_MMX
		}
                                                               
    }
    else  // *pN >= 65, hence intRA
    {
      //  TODO
#ifdef USE_MMX // { USE_MMX
      if (DC->bMMXDecoder)
      {
        U32 ScaledDC = pRUN_INVERSE_Q->dInverseQuant;
       
        pRUN_INVERSE_Q->dInverseQuant = 0;
        MMX_DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q,  //
            *pN - 65,             //  No. of coeffs
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
        MMX_ClipAndMove((U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,
            fpBlockAction[iBlock].pCurBlock, (U32)ScaledDC);
      }
      else
        DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN, 
            fpBlockAction[iBlock].pCurBlock,      // INTRA transform output
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
#else // }{ USE_MMX
        DecodeBlock_IDCT(
            (U32)pRUN_INVERSE_Q, 
            *pN, 
            fpBlockAction[iBlock].pCurBlock,      // INTRA transform output
            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET);
#endif // } USE_MMX
    }  // end if (*pN < 65) ... else ...
                         
}
//  End IDCTandMC
////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()


/*****************************************************************************
 *
 *  AdvancePredict
 *
 *  Motion Compensation for Advance Prediction
 *    This module is only called in the non-MMx case.
 *    In the MMx case, MMX_AdvancePredict is called instead.
 *
 ****************************************************************************/

#pragma code_seg("IACODE2")
void AdvancePredict(
    T_BlkAction FAR          *fpBlockAction, 
    int                      *iNext,
    U8                       *pDst,
	int                      iEdgeFlag,
	int                      iBlock,
	BOOL                     bUnrestrictedMotionVectors
)
{

    U32 pRefC, pRefN[4];    // Left-Right-Above-Below
    I32 mvx, mvy;
    U32 pRefTmp;
    int i;
	int interp_index;
    
	mvx = fpBlockAction->i8MVx2;
	mvy = fpBlockAction->i8MVy2;

	// Clip motion vectors pointing outside active image area
	if (bUnrestrictedMotionVectors)  
	{
		UmvOnEdgeClipMotionVectors2(&mvx,&mvy,iEdgeFlag,iBlock);
	}     

	interp_index = ((mvy & 0x1)<<1) | (mvx & 0x1);

	pRefTmp = fpBlockAction->pRefBlock +
	        (I32) (mvx >> 1) +
	        PITCH * (I32) (mvy >> 1); 

	pRefC    = (U32) pDst +  8;
	pRefN[0] = (U32) pDst + 16;
	pRefN[1] = (U32) pDst + 24;
	pRefN[2] = (U32) pDst + 32;
	pRefN[3] = (U32) pDst + 40;

	// Current block
	if (interp_index)
		(*Interpolate_Table[interp_index])(pRefTmp, pRefC);
	else
		pRefC = pRefTmp;
      
        //  Compute and apply motion vectors
        //  Prediction is placed at pRefN[i]
        for (i=0; i<4; i++) {

			if (iNext[i]) {

				// Get the motion vector components.
				// Note that for macroblocks that were not coded, THESE MUST BE 0!
				// (Which is what H263InitializeBlockActionStream sets them to.)
				mvx = fpBlockAction[iNext[i]].i8MVx2;
				mvy = fpBlockAction[iNext[i]].i8MVy2;
              
				// Clip motion vectors pointing outside active image area
				if (bUnrestrictedMotionVectors)  
				{
					UmvOnEdgeClipMotionVectors2(&mvx,&mvy,iEdgeFlag,iBlock);
				}     
  
	            // apply motion vector to get reference block at pRefN[i]
	            pRefTmp = fpBlockAction->pRefBlock +
	                        (I32) (mvx >> 1) +
	                        PITCH * (I32) (mvy >> 1);
                         
				// do interpolation if needed
				interp_index = ((mvy & 0x1)<<1) | (mvx & 0x1);
				if (interp_index)
					(*Interpolate_Table[interp_index])(pRefTmp, pRefN[i]);
				else
					pRefN[i] = pRefTmp;

			}  // end if (iNext[i])
			else { // use this block's reference
				pRefN[i] = pRefC;
			} // end if (iNext[i] && ...) ... else ...

		}  // end for (i=0; i<4; i++) {}
      
		// Now do overlapped motion compensation.
		H263OBMC(pRefC, pRefN[0], pRefN[1], pRefN[2], pRefN[3], (U32)pDst);
                         
}
//  End AdvancePredict
////////////////////////////////////////////////////////////////////////////////
#pragma code_seg()



/*****************************************************************************
 *
 *  BBlockPrediction
 *
 *  Compute the predictions from the "forward" and "backward" motion vectors.
 *
 ****************************************************************************/
#pragma code_seg("IACODE2")    
void H263BBlockPrediction(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction,
    U32                       pRef[],
    T_MBInfo FAR             *fpMBInfo,
    int                       iEdgeFlag
)
{
    //find out the MVf and MVb first from TR

  	I32 mv_f_x[6], mv_b_x[6], mv_f_y[6], mv_b_y[6];
    I32 mvx_expectation, mvy_expectation;
    I32 iTRD, iTRB;
    I32 i;
    U32 pRefTmp;

    int mvfx, mvbx, mvfy, mvby;

	FX_ENTRY("H263BBlockPrediction")

    iTRB = DC->uBFrameTempRef;
    iTRD = DC->uTempRef - DC->uTempRefPrev;

    if (!iTRD)
    {
		DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: Warning: given TR == last TR, set TRD = 256\r\n", _fx_));
        iTRD = 256;
    }
    else
    if (iTRD < 0) 
        iTRD += 256;

    // final MVD for P blocks is in 
    //    fpBlockAction[0].i8MVx2,... and fpBlockAction[3].i8MVx2, and
    //    fpBlockAction[0].i8MVy2,... and fpBlockAction[3].i8MVy2.

    // check for 4 motion vectors per macroblock
    //  TODO can motion vector calculation be done in the first pass
    if (fpMBInfo->i8MBType == 2) 
    {  // yep, we got 4 of 'em

#ifdef H263P
		// If H.263+, we can have 8x8 MV's if the deblocking filter 
		// was selected.
        ASSERT(DC->bAdvancedPrediction || DC->bDeblockingFilter);
#else
        ASSERT(DC->bAdvancedPrediction);
#endif

        // Do luma vectors first
        for (i=0; i<4; i++)
        {
#ifdef H263P
			// If we are using improved PB-frame mode (H.263+) and the B-block
			// was signalled to be predicted in the forward direction only,
			// the motion vector contained in MVDB is the actual forward MV -
			// no prediction is used.
			if (DC->bImprovedPBFrames == TRUE && 
				fpMBInfo->bForwardPredOnly == TRUE) 
			{
				// Zero-out the expectation (the motion vector prediction)
				mvx_expectation = 0;
				mvy_expectation = 0;
			} 
			else
#endif 
			{
				// compute forward expectation
				mvx_expectation = ( iTRB * (I32)fpBlockAction[i].i8MVx2 / iTRD ); 
				mvy_expectation = ( iTRB * (I32)fpBlockAction[i].i8MVy2 / iTRD );
			}
      
            // add in differential
            mv_f_x[i] = mvx_expectation + fpMBInfo->i8MVDBx2; 
            mv_f_y[i] = mvy_expectation + fpMBInfo->i8MVDBy2;

            // check to see if the differential carried us too far
            if (DC->bUnrestrictedMotionVectors) 
            {
                if (mvx_expectation > 32) 
                {
                    if (mv_f_x[i] > 63) mv_f_x[i] -=64;
                }  
                else if (mvx_expectation < -31) 
                {
                    if (mv_f_x[i] < -63) mv_f_x[i] +=64;
                } // always use "first column" when expectation lies in [-31, +32] 

                if (mvy_expectation > 32) 
                {
                    if (mv_f_y[i] > 63) mv_f_y[i] -=64;
                }  
                else if (mvy_expectation < -31) 
                {
                    if (mv_f_y[i] < -63) mv_f_y[i] +=64;
                }  
            }
            else  // UMV off
            {
                if (mv_f_x[i] >= 32) mv_f_x[i] -= 64;
                else if (mv_f_x[i] < -32) mv_f_x[i] += 64;

                if (mv_f_y[i] >= 32) mv_f_y[i] -= 64;
                else if (mv_f_y[i] < -32) mv_f_y[i] += 64;
            } // end if (UMV) ... else ...

            // Do backwards motion vectors
			// Backward vectors are not required if using improved PB-frame mode
			// and the B-block uses only forward prediction. We will keep the calculation
			// of mv_b_{x,y} here since it doesn't harm anything.
            //  TODO
            if (fpMBInfo->i8MVDBx2)
                mv_b_x[i] = mv_f_x[i] - fpBlockAction[i].i8MVx2;
            else
                mv_b_x[i] = ( (iTRB - iTRD) * (I32)fpBlockAction[i].i8MVx2 / iTRD );
            if (fpMBInfo->i8MVDBy2)
                mv_b_y[i] = mv_f_y[i] - fpBlockAction[i].i8MVy2;
            else
                mv_b_y[i] = ( (iTRB - iTRD) * (I32)fpBlockAction[i].i8MVy2 / iTRD );

        }  // end for(i=0; i<4; i++){}
      
        // Now do the chromas
        //   first get average times 4
        for (i=0, mvfx=mvbx=mvfy=mvby=0; i<4; i++) 
        {
            mvfx += mv_f_x[i];
            mvfy += mv_f_y[i];
            mvbx += mv_b_x[i];
            mvby += mv_b_y[i];
        }
   
        //   now interpolate
        mv_f_x[4] = mv_f_x[5] = (mvfx >> 3) + SixteenthPelRound[mvfx & 0x0f];
        mv_f_y[4] = mv_f_y[5] = (mvfy >> 3) + SixteenthPelRound[mvfy & 0x0f];
        mv_b_x[4] = mv_b_x[5] = (mvbx >> 3) + SixteenthPelRound[mvbx & 0x0f];
        mv_b_y[4] = mv_b_y[5] = (mvby >> 3) + SixteenthPelRound[mvby & 0x0f];
   
    }
    else  // only 1 motion vector for this macroblock
    {

#ifdef H263P
		// If we are using improved PB-frame mode (H.263+) and the B-block
		// was signalled to be predicted in the forward direction only,
		// the motion vector contained in MVDB is the actual forward MV -
		// no prediction is used.
		if (DC->bImprovedPBFrames == TRUE && 
			fpMBInfo->bForwardPredOnly == TRUE) 
		{
			// Zero-out the expectation (the motion vector prediction)
			mvx_expectation = 0;
			mvy_expectation = 0;
		} 
		else
#endif
		{
			// compute forward expectation
			mvx_expectation = ( iTRB * (I32)fpBlockAction[0].i8MVx2 / iTRD ); 
			mvy_expectation = ( iTRB * (I32)fpBlockAction[0].i8MVy2 / iTRD );
		}
      
        // add in differential
        mv_f_x[0] = mvx_expectation + fpMBInfo->i8MVDBx2; 
        mv_f_y[0] = mvy_expectation + fpMBInfo->i8MVDBy2;

        // check to see if the differential carried us too far
        // TODO: Clipping of motion vector needs to happen when decoder needs 
        //       to interoperate
        if (DC->bUnrestrictedMotionVectors) 
        {
            if (mvx_expectation > 32) 
            {
                if (mv_f_x[0] > 63) mv_f_x[0] -=64;
            }  
            else if (mvx_expectation < -31) 
            {
                if (mv_f_x[0] < -63) mv_f_x[0] +=64;
            } // always use "first column" when expectation lies in [-31, +32] 

            if (mvy_expectation > 32) 
            {
                if (mv_f_y[0] > 63) mv_f_y[0] -=64;
            }  
            else if (mvy_expectation < -31) 
            {
                if (mv_f_y[0] < -63) mv_f_y[0] +=64;
            }
        }
        else // UMV off, decode normally
        {
            if (mv_f_x[0] >= 32) mv_f_x[0] -= 64;
            else if (mv_f_x[0] < -32) mv_f_x[0] += 64;

            if (mv_f_y[0] >= 32) mv_f_y[0] -= 64;
            else if (mv_f_y[0] < -32) mv_f_y[0] += 64;
        } // finished decoding

        // copy for other 3 motion vectors
        mv_f_x[1] = mv_f_x[2] = mv_f_x[3] = mv_f_x[0];
        mv_f_y[1] = mv_f_y[2] = mv_f_y[3] = mv_f_y[0];

        // do backwards motion vectors
		// Backward vectors are not required if using improved PB-frame mode
		// and the B-block uses only forward prediction. We will keep the calculation
		// of mv_b_{x,y} here since it doesn't harm anything.
        // TODO
        if (fpMBInfo->i8MVDBx2)
            mv_b_x[0] = mv_f_x[0] - fpBlockAction[0].i8MVx2;
        else
            mv_b_x[0] = ( (iTRB - iTRD) * (I32)fpBlockAction[0].i8MVx2 / iTRD );

        if (fpMBInfo->i8MVDBy2)
            mv_b_y[0] = mv_f_y[0] - fpBlockAction[0].i8MVy2;
        else
            mv_b_y[0] = ( (iTRB - iTRD) * (I32)fpBlockAction[0].i8MVy2 / iTRD );

        // copy for other 3 motion vectors
        mv_b_x[1] = mv_b_x[2] = mv_b_x[3] = mv_b_x[0];
        mv_b_y[1] = mv_b_y[2] = mv_b_y[3] = mv_b_y[0];

        // interpolate for chroma
        mv_f_x[4] = mv_f_x[5] = (mv_f_x[0] >> 1) + QuarterPelRound[mv_f_x[0] & 0x03];
        mv_f_y[4] = mv_f_y[5] = (mv_f_y[0] >> 1) + QuarterPelRound[mv_f_y[0] & 0x03];
        mv_b_x[4] = mv_b_x[5] = (mv_b_x[0] >> 1) + QuarterPelRound[mv_b_x[0] & 0x03];
        mv_b_y[4] = mv_b_y[5] = (mv_b_y[0] >> 1) + QuarterPelRound[mv_b_y[0] & 0x03];

    }  // end else 1 motion vector per macroblock

    // Prediction from Previous decoder P frames, referenced by RefBlock
    // Note: The previous decoder P blocks in in RefBlock, and
    //       the just decoder P blocks are in CurBlock
    //       the target B blocks are in BBlock

    // translate MV into address of reference blocks.
    pRefTmp = (U32) DC + DC->uMBBuffer;
    for (i=0; i<6; i++) 
    {
        pRef[i] =  pRefTmp;
        pRefTmp += 8;
    }


    // Do the forward predictions
    for (i=0; i<6; i++)
    {
        int interp_index;
      
		// in UMV mode: clip MVs pointing outside 16 pels wide edge
		if (DC->bUnrestrictedMotionVectors) 
		{
			UmvOnEdgeClipMotionVectors2(&mv_f_x[i],&mv_f_y[i], iEdgeFlag, i);
			// no need to clip backward vectors
		}

        // Put forward predictions at addresses pRef[0], ..., pRef[5].
        pRefTmp = fpBlockAction[i].pRefBlock + (I32)(mv_f_x[i]>>1) +  
                  PITCH * (I32)(mv_f_y[i]>>1);
        // TODO
        interp_index = ((mv_f_y[i] & 0x1)<<1) | (mv_f_x[i] & 0x1);
        if (interp_index)
        {
#ifdef USE_MMX // { USE_MMX
            if (DC->bMMXDecoder)
                (*MMX_Interpolate_Table[interp_index])(pRefTmp, pRef[i]);
            else
                (*Interpolate_Table[interp_index])(pRefTmp, pRef[i]);
#else // }{ USE_MMX
                (*Interpolate_Table[interp_index])(pRefTmp, pRef[i]);
#endif // } USE_MMX
        }
        else
        {
#ifdef USE_MMX // { USE_MMX
            if (DC->bMMXDecoder)
                MMX_BlockCopy(
                    pRef[i],     // destination 
                    pRefTmp);    // prediction
            else
                BlockCopy(pRef[i], pRefTmp);
#else // }{ USE_MMX
                BlockCopy(pRef[i], pRefTmp);
#endif // } USE_MMX
        }
        
#ifdef H263P
		// If we are using improved PB-frame mode (H.263+) and the B-block
		// was signalled to be predicted in the forward direction only,
		// we do not adjust with the backward prediction from the future.
		if (DC->bImprovedPBFrames == FALSE || 
			fpMBInfo->bForwardPredOnly == FALSE)
#endif
		{
#ifdef USE_MMX // { USE_MMX
        if (DC->bMMXDecoder)
    	    // adjust with bacward prediction from the future
    	    MMX_BiMotionComp(
                pRef[i],
                fpBlockAction[i].pCurBlock, 
                (I32) mv_b_x[i], 
                (I32) mv_b_y[i], 
                i);
        else
    	    // adjust with bacward prediction from the future
    	H263BiMotionComp(
            pRef[i],
            fpBlockAction[i].pCurBlock, 
            (I32) mv_b_x[i], 
            (I32) mv_b_y[i], 
            i);
#else // }{ USE_MMX
    	    // adjust with bacward prediction from the future
    	H263BiMotionComp(
            pRef[i],
            fpBlockAction[i].pCurBlock, 
            (I32) mv_b_x[i], 
            (I32) mv_b_y[i], 
            i);
#endif // } USE_MMX
		}

    } // end for (i=0; i<6; i++) {}
}
#pragma code_seg()

/*****************************************************************************
 *
 *  H263BFrameIDCTandBiMC
 *
 *  B Frame IDCT and 
 *  Bi-directional MC for B blocks
 */

#pragma code_seg("IACODE2")
void H263BFrameIDCTandBiMC(
    T_H263DecoderCatalog FAR *DC,
    T_BlkAction FAR          *fpBlockAction, 
    int                       iBlock,
    U32                      *pN,                         
    T_IQ_INDEX               *pRUN_INVERSE_Q,
    U32                      *pRef
)     
{
    ASSERT(*pN < 65);
                                                        
    // do the inverse transform (where appropriate) & combine
    if (*pN > 0) {

#ifdef USE_MMX // { USE_MMX
        if (DC->bMMXDecoder)
        {
            MMX_DecodeBlock_IDCT(
                (U32)pRUN_INVERSE_Q, 
                *pN,
                (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter  output

            MMX_BlockAdd(
                (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // output
                pRef[iBlock],                                    // prediction
                fpBlockAction[iBlock].pBBlock);                  // destination
        }
        else
        {
	      	// Get residual block; put output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
			DecodeBlock_IDCT(
	            (U32)pRUN_INVERSE_Q, 
	            *pN,
	            fpBlockAction[iBlock].pBBlock,                   // intRA not used here
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter output

	        // Add the residual to the reference block
			BlockAdd(
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // transform output 
	            pRef[iBlock],                                    // prediction
	            fpBlockAction[iBlock].pBBlock);                  // destination

        }
#else // }{ USE_MMX
	      	// Get residual block; put output at DC+DC->uMBBuffer+BLOCK_BUFFER_OFFSET 
			DecodeBlock_IDCT(
	            (U32)pRUN_INVERSE_Q, 
	            *pN,
	            fpBlockAction[iBlock].pBBlock,                   // intRA not used here
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET); // inter output

	        // Add the residual to the reference block
			BlockAdd(
	            (U32) DC + DC->uMBBuffer + BLOCK_BUFFER_OFFSET,  // transform output 
	            pRef[iBlock],                                    // prediction
	            fpBlockAction[iBlock].pBBlock);                  // destination
#endif // } USE_MMX

    }
    else 
    {
      	// No transform coefficients for this block,
      	// copy the prediction to the output.
#ifdef USE_MMX // { USE_MMX
      	if (DC->bMMXDecoder)
            MMX_BlockCopy(
          		fpBlockAction[iBlock].pBBlock,   // destination 
          		pRef[iBlock]);                   // prediction
      	else
      	  	BlockCopy(
 		  		fpBlockAction[iBlock].pBBlock,   // destination
            	pRef[iBlock]);                   // prediction
#else // }{ USE_MMX
      	  	BlockCopy(
 		  		fpBlockAction[iBlock].pBBlock,   // destination
            	pRef[iBlock]);                   // prediction
#endif // } USE_MMX
    }                       
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3halfmc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   14 Mar 1996 14:57:40  $
// $Archive:   S:\h26x\src\dec\d3halfmc.h_v  $
// $Header:   S:\h26x\src\dec\d3halfmc.h_v   1.4   14 Mar 1996 14:57:40   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3halfmc.h_v  $
;// 
;//    Rev 1.4   14 Mar 1996 14:57:40   AGUPTA2
;// Added decls for MMX rtns.
;// 
;//    Rev 1.3   27 Dec 1995 14:36:14   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   08 Oct 1995 13:44:40   CZHU
// 
// Declare the C versions of interpolation for debugging
// 
//    Rev 1.1   27 Sep 1995 11:55:50   CZHU
// 
// Changed UINT backto U32
// 
//    Rev 1.0   26 Sep 1995 11:09:38   CZHU
// Initial revision.
// 

#ifndef __D3HALFMC_H__
#define __D3HALFMC_H__

extern void Interpolate_Half_Int (U32 pRef,U32 pNewRef);
extern void Interpolate_Int_Half (U32 pRef,U32 pNewRef);
extern void Interpolate_Half_Half (U32 pRef,U32 pNewRef);
extern "C" void _fastcall MMX_Interpolate_Half_Int (U32 pRef,U32 pNewRef);
extern "C" void _fastcall MMX_Interpolate_Int_Half (U32 pRef,U32 pNewRef);
extern "C" void _fastcall MMX_Interpolate_Half_Half (U32 pRef,U32 pNewRef);
extern void Interpolate_Half_Half_C (U32 pRef,U32 pNewRef);
extern void Interpolate_Half_Int_C (U32 pRef,U32 pNewRef);
extern void Interpolate_Int_Half_C (U32 pRef,U32 pNewRef);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3pict.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/


/*****************************************************************************
 * 
 *  d3pict.h
 *
 *  Description:
 *		Interface to the picture header reader
 */

/*
 * $Header:   S:\h26x\src\dec\d3pict.h_v   1.3   27 Dec 1995 14:36:16   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\d3pict.h_v  $
;// 
;//    Rev 1.3   27 Dec 1995 14:36:16   RMCKENZX
;// Added copyright notice
 */

#ifndef __D3PICT_H__
#define __D3PICT_H__

extern I32 H263DecodePictureHeader(T_H263DecoderCatalog FAR * DC, 
								   U8 FAR * fpu8, 
								   U32 uBitsReady,
								   U32 uWork, 
								   BITSTREAM_STATE FAR * fpbsState);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\dec\d3rtp.cpv   1.6   06 Nov 1996 15:23:02   CZHU  $
// $Log:   S:\h26x\src\dec\d3rtp.cpv  $
// 
//    Rev 1.6   06 Nov 1996 15:23:02   CZHU
// 
// Returning MVs in FindNextPacket()
// 
//    Rev 1.5   03 Nov 1996 18:41:40   gmlim
// Modified RTPH263FindNextPacket() to support mode c.
// 
//    Rev 1.4   23 Jul 1996 11:22:16   CZHU
// 
// Added a MV recovery. Hursitic will be added in later.
// 
//    Rev 1.3   15 Jul 1996 16:22:42   CZHU
// Added checking bitstream extension when PSC is lost.
// 
//    Rev 1.2   03 May 1996 13:04:22   CZHU
// Change logic such that bitstream verification is invoked only when bit erro
// is encountered.
// 
//    Rev 1.1   28 Apr 1996 21:18:58   BECHOLS
// Removed ifdef RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:08   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:35:58   CZHU
// 
// Added subroutine to recover picture header information from extended bitstr
// 
//    Rev 1.6   29 Mar 1996 14:39:56   CZHU
// 
// cleaning 
// 
//    Rev 1.5   29 Mar 1996 13:39:16   CZHU
// 
// Moved bs verification to c3rtp.cpp
// 
//    Rev 1.4   28 Mar 1996 18:40:28   CZHU
// Support packet loss recovery
// 
//    Rev 1.3   23 Feb 1996 16:21:22   CZHU
// No change.
// 
//    Rev 1.2   15 Feb 1996 12:01:50   CZHU
// 
// More clean up
// 
//    Rev 1.1   14 Feb 1996 15:00:10   CZHU
// Added support Mode A and Mode B
// 
//    Rev 1.0   12 Feb 1996 17:05:56   CZHU
// Initial revision.
// 
//    Rev 1.2   25 Jan 1996 16:13:54   CZHU
// changed name to the spec
// 
//    Rev 1.1   15 Dec 1995 13:07:30   CZHU
// 
//  
// 
//    Rev 1.0   11 Dec 1995 14:54:22   CZHU
// Initial revision.
*/

#include "precomp.h"

/*
 * RtpH263FindNextPacket() look through the extended bitstream and
 * find the next BITSTREAM_INFO structure that point to a valid packet
 * return indicates what mode the next packet is in mode A, or mode B,
 * mode C is not supported at this point.Chad, 3/28/96
 * 
 * Mode C is supported now. And a special case LAST packet is lost is also
 * covered. Chad, 11/6/96
 *
 */

I32 RtpH263FindNextPacket( //DC, fpbsState, &pN, fpMBInfo, &uNewMB, &uNewGOB)
	T_H263DecoderCatalog FAR * DC, 														  
	BITSTREAM_STATE FAR * fpbsState,
	U32 **pN,
	U32 *pQuant,
	int *pMB,
	int *pGOB,
	I8 MVs[4]
	)                      

{  I32 iret=ICERR_OK; 
//#ifdef LOSS_RECOVERY
   U32 u; 
   U32 uBitOffset;
   U32 uBitstream = (U32)((U32)DC + DC->X32_BitStream);
   T_RTP_H263_BSINFO *pBsInfo;
   U32 mask[]={0xff,0x7f, 0x3f, 0x1f,0x0f, 0x07, 0x03,0x01};
     //verify bitstream extension first

   if (!DC->iVerifiedBsExt)
   	 H263RTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);

   if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
   }

   uBitOffset =  ((U32)fpbsState->fpu8 - uBitstream)*8 - 8 + fpbsState->uBitsReady;
   //travser through the BITSTREAM_INFO to find the next PACKET.
   //update pNewMB and pNewGOB if succeed, return Ok otherwise return error
   pBsInfo=(T_RTP_H263_BSINFO*)DC->pBsInfo;
   for ( u=0; u<DC->uNumOfPackets;u++)
   {
	 if (!(pBsInfo->uFlags & RTP_H26X_PACKET_LOST))
	 {
	   if (uBitOffset < pBsInfo->uBitOffset) break;
	 }
	 pBsInfo++;
   }
   //find it?
   if (u<DC->uNumOfPackets) //find next packet
   {
    if (pBsInfo->u8Mode == RTP_H263_MODE_A) 
    {	//adjust bit stream pointer according to received packet
		fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset /8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;
			   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;

		iret = NEXT_MODE_A;

    }
	else //read Quant, GOB, MBA, MVs, from Payload Header
	{  
	   //update m, g, MV in fpBlockAction, fpMBInfo for block type
	   *pGOB    = pBsInfo->u8GOBN;
	   *pMB     = pBsInfo->u8MBA;
	   *pQuant  = pBsInfo->u8Quant;
	   //update the bit pointer and offset 
	   	fpbsState->fpu8 = (U8 *)(uBitstream + pBsInfo->uBitOffset /8 );
		fpbsState->uBitsReady =	8 - pBsInfo->uBitOffset % 8;
		if (fpbsState->uBitsReady) 
		{
		fpbsState->uWork =(U32)*fpbsState->fpu8++;
		fpbsState->uWork &= mask[8- fpbsState->uBitsReady];
		}
		else
		 fpbsState->uWork =0;

		//recovery MVs depending on AP, 
		MVs[0] = pBsInfo->i8HMV1;
		MVs[1] = pBsInfo->i8VMV1;
		MVs[2] = pBsInfo->i8HMV2;
		MVs[3] = pBsInfo->i8VMV2;

		iret = pBsInfo->u8Mode == RTP_H263_MODE_B ? NEXT_MODE_B :
                                                    NEXT_MODE_C;
	   //file MV indexed by fpBlockAction,
	}

   }
   else // no more valid packet in this frame
   {	// need to set all the rest of MB to be not coded
	   iret = NEXT_MODE_LAST;
   }
done:
//#endif
   return iret;
}

/*
 * Use the extended bitstream to get the information lost
 * in the picture header
 */

I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * DC)
{I32 iret = ICERR_OK;
//#ifdef LOSS_RECOVERY
 T_H263_RTP_BSINFO_TRAILER *pTrailer;

 if (!DC->iVerifiedBsExt)
 {
  H263RTP_VerifyBsInfoStream(DC,(U8 *)((U8 *)DC + DC->X32_BitStream),DC->Sz_BitStream);
 }

 if (!DC->iValidBsExt) {
    iret=ICERR_UNSUPPORTED;
	goto done;
 }
 pTrailer = ( T_H263_RTP_BSINFO_TRAILER *)DC->pBsTrailer;
 //update DC info for Pict header.Src, INTRA, TR, etc.
 DC->uTempRef   = pTrailer->u8TR;
 DC->uSrcFormat = pTrailer->u8Src;
 DC->bFreezeRelease = 0;
 DC->bCameraOn = 0;
 DC->bSplitScreen = 0;
 DC->bKeyFrame = (U16) (pTrailer->uFlags & RTP_H26X_INTRA_CODED) ;//(U16) !uResult;
 //DC->bUnrestrictedMotionVectors = pTrailer->uFlags & ;
 DC->bArithmeticCoding = (U16)(pTrailer->uFlags & RTP_H263_SAC);
 DC->bAdvancedPrediction = (U16)(pTrailer->uFlags & RTP_H263_AP);
 DC->bPBFrame = (U16)(pTrailer->uFlags & RTP_H263_PB);
 //Mode C reovery PB related header info.
 // to be added for TRB,u8DBQ,
 DC->uBFrameTempRef=(U32)pTrailer->u8TRB;	 
 DC->uDBQuant      =(U32)pTrailer->u8DBQ;

done:
//#endif
return iret;
}

/*
 * MVAdjustment(pBlackAction, iBlock, old_g, old_m, new_g, new_m)
 * reuse the motion vector from the GOB above, when current is lost
 * EXPERIMENTAL
 */
void MVAdjustment(
T_BlkAction  *fpBlockAction,
int iBlockNum, //block number
int iOld_gob,
int iOld_mb,
int iNew_gob,
int iNew_mb,
const int iNumberOfMBs
)
{ int i,j;
  T_BlkAction *pBA=fpBlockAction;
  int iAbove = -6 * iNumberOfMBs;

  for (i=iOld_gob*iNumberOfMBs+iOld_mb;i<iNew_gob*iNumberOfMBs+iNew_mb; i++,pBA += 6)
  {
   if ((i+iAbove) >= 0) 
	 for (j=0;j<6;j++)
     {   pBA[i+j].i8MVx2 = pBA[iAbove+i+j].i8MVx2;
	     pBA[i+j].i8MVy2 = pBA[iAbove+i+j].i8MVy2;
     }
  }
  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3mblk.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3mblk.h
 *
 *  Description:
 *		Interface to macro block header processing.  
 */

/*
 * $Header:   S:\h26x\src\dec\d3mblk.h_v   1.11   25 Sep 1996 08:05:36   KLILLEVO  $
 * $Log:   S:\h26x\src\dec\d3mblk.h_v  $
;// 
;//    Rev 1.11   25 Sep 1996 08:05:36   KLILLEVO
;// initial extended motion vectors support 
;// does not work for AP yet
;// 
;//    Rev 1.10   09 Jul 1996 16:47:26   AGUPTA2
;// MMX_ClipAndMove now addas DC value to the result; IDCT for INTRA blocks
;// works with DC value set to zero.  Also, BlockCopy is done in chunks of
;// 4 loads followed by 4 stores.
;// Changed code to adhere to coding convention in the decoder.
;// 
;//    Rev 1.9   04 Apr 1996 11:05:56   AGUPTA2
;// Added decl for MMX_BlockCopy().
;// 
;//    Rev 1.8   14 Mar 1996 17:03:10   AGUPTA2
;// Added decls for MMX rtns.
;// 
;//    Rev 1.7   08 Mar 1996 16:46:24   AGUPTA2
;// Changed function declarations.
;// 
;// 
;//    Rev 1.6   23 Feb 1996 09:46:50   KLILLEVO
;// fixed decoding of Unrestricted Motion Vector mode
;// 
;//    Rev 1.5   18 Dec 1995 12:47:52   RMCKENZX
;// added copyright notice and header & log keywords
 */

#ifndef __D3MB_H__
#define __D3MB_H__

extern void H263IDCTandMC(T_H263DecoderCatalog FAR *DC,	   // NEW function
				T_BlkAction FAR * fpBlockAction,
				int b,
				int m,
				int g,
				U32 *pN,
				T_IQ_INDEX *pRUN_INVERSE_Q,
				T_MBInfo *fpMBInfo,
				int iEdgeFlag);


extern void H263BFrameIDCTandBiMC(                           // PB-NEW function
				T_H263DecoderCatalog FAR *DC,
				T_BlkAction FAR * fpBlockAction,
				int b,
				U32 *pN,
				T_IQ_INDEX *pRUN_INVERSE_Q,
				U32 *pRef);

extern void H263BBlockPrediction(
				T_H263DecoderCatalog FAR *DC,
				T_BlkAction FAR *fpBlockAction,
				U32 *pRef,
				T_MBInfo FAR *fpMBInfo,
				int iEdgeFlag);

extern void __fastcall BlockCopy(U32 uDstBlock, U32 uSrcBlock);
#ifdef USE_MMX // { USE_MMX
extern "C" void __fastcall MMX_BlockCopy(U32 uDstBlock, U32 uSrcBlock);
#endif // } USE_MMX
extern void BlockAdd(
      U32 uResidual, 
      U32 uRefBlock, 
      U32 uDstBlock);
#ifdef USE_MMX // { USE_MMX
extern "C" void __fastcall MMX_BlockAdd(
      U32 uResidual,   // pointer to IDCT output
      U32 uRefBlock,   // pointer to predicted values
      U32 uDstBlock);  // pointer to destination

extern "C" void __fastcall MMX_ClipAndMove(
      U32 uResidual,   // pointer to IDCT output
      U32 uDstBlock,   // pointer to destination
      U32 ScaledDC);   // Scaled DC
#endif // } USE_MMX

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3mvdec.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 17:29:46  $
// $Archive:   S:\h26x\src\dec\d3mvdec.h_v  $
// $Header:   S:\h26x\src\dec\d3mvdec.h_v   1.8   08 Mar 1996 17:29:46   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3mvdec.h_v  $
;// 
;//    Rev 1.8   08 Mar 1996 17:29:46   AGUPTA2
;// Changed BlockCopy interface.
;// 
;//    Rev 1.7   18 Dec 1995 12:43:10   RMCKENZX
;// added copyright notice
;// 
;//    Rev 1.6   13 Dec 1995 11:00:22   RHAZRA
;// No change.
;// 
;//    Rev 1.5   11 Dec 1995 11:34:40   RHAZRA
;// No change.
;// 
;//    Rev 1.4   09 Dec 1995 17:30:58   RMCKENZX
;// Gutted and re-built file to support decoder re-architecture.
;// New modules are:
;// H263ComputeMotionVectors
;// H263DecodeMBHeader
;// H263DecodeIDCTCoeffs
;// This module now contains code to support the first pass of the decoder
;// 
;//    Rev 1.3   11 Oct 1995 13:26:04   CZHU
;// Added code to support PB frame
;// 
;//    Rev 1.2   03 Oct 1995 12:22:14   CZHU
;// Fixed bug found by Tom in GetVariableBits for Code 0xC0
;// 
;//    Rev 1.1   11 Sep 1995 17:21:34   CZHU
;// Changed the interface
;// 
;//    Rev 1.0   08 Sep 1995 11:46:02   CZHU
;// Initial revision.

/////////////////////////////////////////////////////////////////////////// 
//  d3mvdec.h
//
//  Description:
//		Interface to motion vector decoding.  
//
// 


#ifndef __D3MVD_H__
#define __D3MVD_H__

#define GET_VARIABLE_BITS_MV(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpMajorTable, fpMinorTable) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* calculate how much to shift off */	\
	/* and get the code */					\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);				\
	/* read the data */						\
	if (uCode >= 0xc0)						\
	{ uCode = uCode >> 5 ;                   \
	  uResult = fpMajorTable[uCode];		\
	}										\
	else									\
	  uResult = fpMinorTable[uCode];        \
	/* count of bits used */   				\
	uBitCount = uResult & 0xFF;				\
	/* bits remaining */					\
	uBitsReady = uBitsReady - uBitCount;	\
	uWork &= GetBitsMask[uBitsReady];		\
}

extern 	I32 H263ComputeMotionVectors(
			T_H263DecoderCatalog FAR * DC,
			T_BlkAction FAR * fpBlockAction);

extern I32 H263DecodeMBHeader(
			T_H263DecoderCatalog FAR * DC, 
			BITSTREAM_STATE FAR * fpbsState,
			U32 **pN,                         // NEW
			T_MBInfo FAR * fpMBInfo);         // PB-New

extern I32 H263DecodeIDCTCoeffs(
			T_H263DecoderCatalog FAR * DC,	  // Old function munged
			T_BlkAction FAR * fpBlockAction, 
			U32 uBlockNumber,
			BITSTREAM_STATE FAR * fpbsState,
			U8 FAR * fpu8MaxPtr,
			U32 **pN,
			T_IQ_INDEX **pRUN_INVERSE_Q); // NEW 

// extern void BlockCopy(U32 uDstBlock, U32 uSrcBlock);

// select the medium value
#define MEDIAN(x,y,z,a) {if (y < x) {a=y;y=x;x=a;} if (y > z) { y= (x < z)? z:x;}}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3mvdec.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   CZHU  $
// $Date:   06 Feb 1997 15:35:30  $
// $Archive:   S:\h26x\src\dec\d3mvdec.cpv  $
// $Header:   S:\h26x\src\dec\d3mvdec.cpv   1.47   06 Feb 1997 15:35:30   CZHU  $
// $Log:   S:\h26x\src\dec\d3mvdec.cpv  $
// 
//    Rev 1.47   06 Feb 1997 15:35:30   CZHU
// Changed | to ||
// 
//    Rev 1.46   24 Jan 1997 13:32:56   CZHU
// 
// Added fix to check uBitsReady when return from DecodingMB header for 
// packet loss detection.
// 
//    Rev 1.45   19 Dec 1996 16:07:44   JMCVEIGH
// 
// Added initialization of forward-prediction-only flag if a block
// is not coded. This is used in H.263+ only.
// 
//    Rev 1.44   16 Dec 1996 17:44:00   JMCVEIGH
// Allow 8x8 motion vectors if deblocking filter selected and
// support for decoding of improved PB-frame MODB.
// 
//    Rev 1.43   20 Oct 1996 15:51:06   AGUPTA2
// Adjusted DbgLog trace levels; 4:Frame, 5:GOB, 6:MB, 8:everything
// 
//    Rev 1.42   20 Oct 1996 13:21:20   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.41   11 Jul 1996 15:13:16   AGUPTA2
// Changed assertion failures into errors when decoder goes past end of 
// the bitstream.
// 
//    Rev 1.40   03 May 1996 13:05:34   CZHU
// 
// Check errors at MB header for packet faults and return PACKET_FAULT
// 
//    Rev 1.39   22 Mar 1996 17:25:18   AGUPTA2
// Changes to accomodate MMX rtns.
// 
//    Rev 1.38   08 Mar 1996 16:46:28   AGUPTA2
// Added pragmas code_seg and data_seg.  Changed the size of some of local data.
// 
// 
//    Rev 1.37   23 Feb 1996 09:46:56   KLILLEVO
// fixed decoding of Unrestricted Motion Vector mode
// 
//    Rev 1.36   17 Jan 1996 12:44:26   RMCKENZX
// Added support for decoding motion vectors for UMV
// Reorganized motion vector decoding processes, especially
// for AP and eliminating the large HALF_PEL conversion tables.
// 
//    Rev 1.35   02 Jan 1996 17:55:50   RMCKENZX
// 
// Updated copyright notice
// 
//    Rev 1.34   02 Jan 1996 15:48:54   RMCKENZX
// Added code to preserve the Block Type in the block action stream
// for P blocks when PB frames is on.  This is read in H263IDCTandMC
// when AP is on.
// 
//    Rev 1.33   18 Dec 1995 12:42:12   RMCKENZX
// added copyright notice
// 
//    Rev 1.32   13 Dec 1995 22:10:06   RHAZRA
// AP bug fix
// 
//    Rev 1.31   13 Dec 1995 22:01:26   TRGARDOS
// 
// Added more parentheses to a logical statement.
// 
//    Rev 1.30   13 Dec 1995 15:10:08   TRGARDOS
// Changed MV assert to be -32 <= MV <= 31, instead of strict
// inequalities.
// 
//    Rev 1.29   13 Dec 1995 10:59:58   RHAZRA
// 
// AP+PB changes
// 
//    Rev 1.28   11 Dec 1995 11:34:20   RHAZRA
// 12-10-95 changes: added AP stuff
// 
//    Rev 1.27   09 Dec 1995 17:28:38   RMCKENZX
// Gutted and re-built file to support decoder re-architecture.
// New modules are:
// H263ComputeMotionVectors
// H263DecodeMBHeader
// H263DecodeIDCTCoeffs
// This module now contains code to support the first pass of the decoder
// 
//    Rev 1.26   05 Dec 1995 09:12:28   CZHU
// Added fixes for proper MV prediction when GOB header is present
// 
//    Rev 1.25   22 Nov 1995 13:43:42   RMCKENZX
// 
// changed calls to utilize assembly modules for bi-directional
// motion compensation & removed corresponding C modules
// 
//    Rev 1.24   17 Nov 1995 12:58:22   RMCKENZX
// added missing ()s to adjusted_mvx & adjusted_mvy in H263BiMotionCompLuma
// 
//    Rev 1.23   07 Nov 1995 11:01:10   CZHU
// Include Fixes for boundary of bi-directional predictions
// 
//    Rev 1.22   26 Oct 1995 11:22:10   CZHU
// Compute backward MV based on TRD, not TR
// 
//    Rev 1.21   13 Oct 1995 16:06:22   CZHU
// First version that supports PB frames. Display B or P frames under
// VfW for now. 
// 
//    Rev 1.20   13 Oct 1995 13:42:46   CZHU
// Added back the #define for debug messages.
// 
//    Rev 1.19   11 Oct 1995 17:51:00   CZHU
// 
// Fixed bugs in passing MV back with DC.
// 
//    Rev 1.18   11 Oct 1995 13:26:08   CZHU
// Added code to support PB frame
// 
//    Rev 1.17   09 Oct 1995 09:44:04   CZHU
// 
// Use the optimized version of (half,half) interpolation
// 
//    Rev 1.16   08 Oct 1995 13:45:10   CZHU
// 
// Optionally use C version of interpolation
// 
//    Rev 1.15   03 Oct 1995 15:05:26   CZHU
// Cleaning up.
// 
//    Rev 1.14   02 Oct 1995 09:58:56   TRGARDOS
// Added #ifdef to debug print statement.
// 
//    Rev 1.13   29 Sep 1995 16:22:06   CZHU
// 
// Fixed the bug in GOB 0 when compute MV2
// 
//    Rev 1.12   29 Sep 1995 09:02:56   CZHU
// Rearrange Chroma blocks processing
// 
//    Rev 1.11   28 Sep 1995 15:33:04   CZHU
// 
// Call the right version of interpolation based on MV
// 
//    Rev 1.10   27 Sep 1995 11:54:50   CZHU
// Integrated half pel motion compensation
// 
//    Rev 1.9   26 Sep 1995 15:33:06   CZHU
// 
// Put place holder in for half pel interpolation
// 
//    Rev 1.8   20 Sep 1995 14:47:50   CZHU
// Made the number of MBs in GOB a variableD
// 
//    Rev 1.7   19 Sep 1995 13:53:34   CZHU
// Added assertion for half-pel motion vectors
// 
//    Rev 1.6   18 Sep 1995 10:20:58   CZHU
// Scale the motion vectors for UV planes too. 
// 
//    Rev 1.5   14 Sep 1995 10:12:36   CZHU
// 
// Cleaning
// 
//    Rev 1.4   13 Sep 1995 11:56:30   CZHU
// Fixed bugs in finding the predictors for motion vector.
// 
//    Rev 1.3   12 Sep 1995 18:18:58   CZHU
// 
// Modified table for looking up UV MV's
// 
//    Rev 1.2   11 Sep 1995 16:41:14   CZHU
// Added reference block address calculation
// 
//    Rev 1.1   11 Sep 1995 14:31:30   CZHU
// Started to add function to calculate MVs and Reference block addresses.
// 
//    Rev 1.0   08 Sep 1995 11:45:56   CZHU
// Initial revision.

#include "precomp.h"

/* MCBPC table format
 *
 * layout     
 *
 *     unused   mbtype  cbpc  bits
 *     15-13   	12-10   9-8   7-0
 */
#pragma data_seg("IADATA1")

#define MCBPC_MBTYPE(d) ((d>>10) & 0x7)
#define MCBPC_CBPC(d) ((d>>8) & 0x3)
#define MCBPC_BITS(d) (d & 0xFF)
#define MCBPC_ENTRY(m,c,b) \
	( ((m & 0x7) <<10) | ((c & 0x3) << 8) | (b & 0xFF) )

U16 gNewTAB_MCBPC_INTRA[64] = {
	/* index 8 - stuffing */
	MCBPC_ENTRY(0,0,9),
	/* index 5 */ 
	MCBPC_ENTRY(4,1,6),
	/* index 6 */ 
	MCBPC_ENTRY(4,2,6),
	/* index 7 */ 
	MCBPC_ENTRY(4,3,6), 

	/* index 4; 0001XX */
	MCBPC_ENTRY(4,0,4), MCBPC_ENTRY(4,0,4), MCBPC_ENTRY(4,0,4), MCBPC_ENTRY(4,0,4),

	/* index 1; 001XXX */
	MCBPC_ENTRY(3,1,3), MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),
	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),	MCBPC_ENTRY(3,1,3),

	/* index 2; 010XXX */
	MCBPC_ENTRY(3,2,3), MCBPC_ENTRY(3,2,3), MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),
	MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),	MCBPC_ENTRY(3,2,3),

	/* index 3; 011XXX */
	MCBPC_ENTRY(3,3,3), MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),
	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),	MCBPC_ENTRY(3,3,3),

	/* index 0; 1XXXXX */
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 

	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 

	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 

	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1), 
	MCBPC_ENTRY(3,0,1), MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1),	MCBPC_ENTRY(3,0,1) 
};

/* MCBPC table for INTER frame
 *
 * Format same as MCBPC for INTRA
 * layout     
 *
 *     unused   mbtype  cbpc  bits
 *     15-13   	12-10   9-8   7-0 
 *
 */

U16 gNewTAB_MCBPC_INTER[512] = {
	/* invalid code */
	MCBPC_ENTRY(0,0,0),
	MCBPC_ENTRY(0,0,9), //index 20, stuffing
	MCBPC_ENTRY(4,3,9), //19,
	MCBPC_ENTRY(4,2,9), //18
	MCBPC_ENTRY(4,1,9), //17
	MCBPC_ENTRY(1,3,9), //7
	//2 index 14
	MCBPC_ENTRY(3,2,8),MCBPC_ENTRY(3,2,8), //14
	//2 index 13
	MCBPC_ENTRY(3,1,8),MCBPC_ENTRY(3,1,8), //13
	//2 index 11
	MCBPC_ENTRY(2,3,8),MCBPC_ENTRY(2,3,8), //11
	//4 index 15
	MCBPC_ENTRY(3,3,7),MCBPC_ENTRY(3,3,7),MCBPC_ENTRY(3,3,7),MCBPC_ENTRY(3,3,7), //15
	//4 index 10
	MCBPC_ENTRY(2,2,7),MCBPC_ENTRY(2,2,7),MCBPC_ENTRY(2,2,7),MCBPC_ENTRY(2,2,7), //10
	//4 index 9
	MCBPC_ENTRY(2,1,7),MCBPC_ENTRY(2,1,7),MCBPC_ENTRY(2,1,7),MCBPC_ENTRY(2,1,7), //9
	//4 index 6
	MCBPC_ENTRY(1,2,7),MCBPC_ENTRY(1,2,7),MCBPC_ENTRY(1,2,7),MCBPC_ENTRY(1,2,7), //6
	//4 index 5
	MCBPC_ENTRY(1,1,7),MCBPC_ENTRY(1,1,7),MCBPC_ENTRY(1,1,7),MCBPC_ENTRY(1,1,7), //5
	//8 index 16
	MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),//16
	MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),MCBPC_ENTRY(4,0,6),
	//8 index 3
	MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),//3
	MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),MCBPC_ENTRY(0,3,6),//3
	//16 index 12
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),//12
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),
	MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),MCBPC_ENTRY(3,0,5),
	//32 INDEX 2
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),
	MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),MCBPC_ENTRY(0,2,4),

	//32 index 1
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
	MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),MCBPC_ENTRY(0,1,4),
 

	//64 index 8
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),

	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),
	MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),MCBPC_ENTRY(2,0,3),



	//64 index 4
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),

	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),
	MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),MCBPC_ENTRY(1,0,3),


	//256 index 0
	//0--63
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	//64--127
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	//128--128+64=192
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	//192--255
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),
	MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1),MCBPC_ENTRY(0,0,1)
};

/* CBPY table format
 *
 * layout     
 *
 *     intra  inter  bits
 *     15-12  11-8   7-0
 *
 * unused entries should have zero data
 */
#define CBPY_INTRA(d) ((d>>12) & 0xf)
#define CBPY_INTER(d) ((d>>8) & 0xf)
#define CBPY_BITS(d) (d & 0xff)
#define CBPY_ENTRY(a,r,b) \
	( ((a & 0xf) <<12) | ((r & 0xf) << 8) | (b & 0xFF) )
#define CBPY_NOT_USED() CBPY_ENTRY(0,0,0)

U16 gNewTAB_CBPY[64] = {
	/* NotUsed - 0000 0X */
	CBPY_NOT_USED(), CBPY_NOT_USED(),

	/* Index 6 - 0000 10 */
	CBPY_ENTRY(6,9,6),

	/* Index 9 - 0000 11 */
	CBPY_ENTRY(9,6,6),

	/* Index 8 - 0001 0x */
	CBPY_ENTRY(8,7,5), CBPY_ENTRY(8,7,5),

	/* Index 4 - 0001 1x */
	CBPY_ENTRY(4,11,5),	CBPY_ENTRY(4,11,5),

	/* Index 2 - 0010 0x */
	CBPY_ENTRY(2,13,5),	CBPY_ENTRY(2,13,5),

	/* Index 1 - 0010 1x */
	CBPY_ENTRY(1,14,5),	CBPY_ENTRY(1,14,5),

	/* Index 0 - 0011 xx */
	CBPY_ENTRY(0,15,4),	CBPY_ENTRY(0,15,4), CBPY_ENTRY(0,15,4), CBPY_ENTRY(0,15,4),

	/* Index 12- 0100 xx */
	CBPY_ENTRY(12,3,4),	CBPY_ENTRY(12,3,4), CBPY_ENTRY(12,3,4), CBPY_ENTRY(12,3,4),

	/* Index 10- 0101 xx */
	CBPY_ENTRY(10,5,4),	CBPY_ENTRY(10,5,4), CBPY_ENTRY(10,5,4), CBPY_ENTRY(10,5,4),

	/* Index 14- 0110 xx */
	CBPY_ENTRY(14,1,4),	CBPY_ENTRY(14,1,4), CBPY_ENTRY(14,1,4), CBPY_ENTRY(14,1,4),

	/* Index 5 - 0111 xx */
	CBPY_ENTRY(5,10,4), CBPY_ENTRY(5,10,4), CBPY_ENTRY(5,10,4), CBPY_ENTRY(5,10,4),

	/* Index 13- 1000 xx */
	CBPY_ENTRY(13,2,4),	CBPY_ENTRY(13,2,4),	CBPY_ENTRY(13,2,4),	CBPY_ENTRY(13,2,4),

	/* Index 3 - 1001 xx */
	CBPY_ENTRY(3,12,4),	CBPY_ENTRY(3,12,4),	CBPY_ENTRY(3,12,4),	CBPY_ENTRY(3,12,4),

	/* Index 11- 1010 xx */
	CBPY_ENTRY(11,4,4),	CBPY_ENTRY(11,4,4),	CBPY_ENTRY(11,4,4),	CBPY_ENTRY(11,4,4),

	/* Index 7 - 1011 xx */
	CBPY_ENTRY(7,8,4),	CBPY_ENTRY(7,8,4), CBPY_ENTRY(7,8,4), CBPY_ENTRY(7,8,4),

	/* Index 15- 11xx xx */
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),
	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2),	CBPY_ENTRY(15,0,2)
};

I16 gNewTAB_DQUANT[4] = { -1, -2, 1, 2 };

#ifdef USE_MMX // { USE_MMX
T_pFunc_VLD_RLD_IQ_Block pFunc_VLD_RLD_IQ_Block[2] = {VLD_RLD_IQ_Block, MMX_VLD_RLD_IQ_Block};
#endif // } USE_MMX

#pragma data_seg(".data")
/*****************************************************************************
 *
 *  H263DecodeMBHeader
 *
 *  Decode the MB header
 */
#pragma code_seg("IACODE1")
I32 H263DecodeMBHeader(
	T_H263DecoderCatalog FAR * DC, 														  
	BITSTREAM_STATE FAR * fpbsState,
	U32                     **pN,
	T_MBInfo FAR * fpMBInfo)
{
	I32 iReturn = ICERR_ERROR;
	U8 FAR * fpu8;
	U32 uBitsReady;
	U32 uWork;
	U32 uResult;
	U32 uCode;
	U32 uBitCount;
	U32 uMBType;
	U32 bCoded;
	U32 bStuffing;
	U32 bGetCBPB;
	U32 bGetMVDB;
	U32 i;

	FX_ENTRY("H263DecodeMBHeader");

	GET_BITS_RESTORE_STATE(fpu8, uWork, uBitsReady, fpbsState)

	// COD -----------------------------------------------------
ReadCOD:
	if (! DC->bKeyFrame) 
	{
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		bCoded = !uResult; /* coded when bit is set to zero */
	} 
	else
		bCoded = 1;
	DC->bCoded = (U16) bCoded;

	if (!bCoded) 
	{
		/* when a block is not coded, "the remaining part of the macroblock
		 * layer is empty; in that case the decoder shall treat the macroblock
		 * as in INTER block with motion vector for the whole block equal to 
		 * zero and with no coefficient data" (5.3.1 p 16).
		 */
		DC->uMBType = 0;

		fpMBInfo->i8MBType = 0;       // AP-NEW

		DC->uCBPC = 0;
		DC->uCBPY = 0;

		/* Now update the pN array. Since the block is not coded, write 0
		 *  for all blocks in the macroblock.
		 */
		if (DC->bPBFrame) 
		{	 // 12 blocks for a PB frame
			fpMBInfo->i8MVDBx2 = fpMBInfo->i8MVDBy2 = 0;
			for (i=0; i<12; i++)
			{ // PB-NEW
				**pN = 0;
				(*pN)++;
			}
		}
		else 
		{  // only 6 blocks for non PB frame
			for (i=0; i<6; i++)
			{ // NEW
				**pN = 0;
				(*pN)++;
			}
		}

#ifdef H263P
		// If block is not coded, we use the original PB-frame method in Annex G.
		// In other words, use bidirectional prediction (not forward only)
		fpMBInfo->bForwardPredOnly = FALSE;		 
#endif

		GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
		iReturn = ICERR_OK;
		goto done;
	}

	//  MCBPC ---------------------------------------------------
	bStuffing = 0;
	if (DC->bKeyFrame) 
	{
		GET_VARIABLE_BITS(6, fpu8, uWork, uBitsReady, uResult, 
						  uCode, uBitCount, gNewTAB_MCBPC_INTRA);
		if (uCode == 0) 
		{
			/* start of the stuffing code - read the next 3-bits
			*/
			GET_FIXED_BITS(3, fpu8, uWork, uBitsReady, uResult);
			if (uResult == 1)
				bStuffing = 1;
			else 
			{
				ERRORMESSAGE(("%s: Incorrect key frame stuffing bits!\r\n", _fx_));
				//#ifdef LOSS_RECOVERY
// Always True				if (uBitsReady <0) uBitsReady += 9;//trick and trap, do not change it without consulting Chad
				GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
				iReturn = PACKET_FAULT;
				//#else
				//			    iReturn = ICERR_ERROR;
				//#endif
				goto done;
			}
		}
	} 
	else 
	{
		//  Delta Frame
		//  mcpbc, VLD
		GET_VARIABLE_BITS(9, fpu8, uWork, uBitsReady, uResult, 
		uCode, uBitCount, gNewTAB_MCBPC_INTER);

		if (uCode == 1) 
			bStuffing = 1;
		//#ifdef LOSS_RECOVERY
		else if (uCode == 0)	   //catch the illegal code
		{
			ERRORMESSAGE(("%s: Incorrect stuffing bits!\r\n", _fx_));
// Always True			if (uBitsReady <0) uBitsReady += 9;//trick and trap, do not change it without consulting Chad
			GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)
			iReturn = PACKET_FAULT;
			goto done;
		}
		//#endif

	}

	/*  When MCBPC==Stuffing, the remaining part of the macroblock layer is
	*  skipped and the macroblock number is not incremented (5.3.2 p18)"
	*  We support this by jumping to the start - to look for COD 
	*/
	if (bStuffing)
		goto ReadCOD;

	uMBType = MCBPC_MBTYPE(uResult);
	if (DC->bKeyFrame && (uMBType != 3 && uMBType != 4)) 
	{
		ERRORMESSAGE(("%s: Bad key frame MBType!\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

	DC->uMBType = uMBType;

	fpMBInfo->i8MBType = (I8) uMBType;

	DC->uCBPC = MCBPC_CBPC(uResult);

	//  MODB ----------------------------------------------------
	bGetCBPB = 0;
	bGetMVDB = 0;

	if (DC->bPBFrame) 
    {
	    ASSERT( !DC->bKeyFrame);

#ifdef H263P
		// Default is to use original PB-frame method in Annex G.
		fpMBInfo->bForwardPredOnly = FALSE;		 

		if (DC->bImprovedPBFrames)
		{
			// See modified TABLE 8/H.263, Annex M, document LBC-96-358
			GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
			if (uResult)
			{
				// 1xx
				GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
				bGetCBPB = uResult;
				if (!uResult) 
					// 10x
					bGetMVDB = 1;
				else 
				{
					// 11x
					GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
					bGetMVDB = !uResult;
				}
			}
			if (bGetMVDB)
				// B-block is forward predicted (otherwise it is bidirectionally predicted)
				fpMBInfo->bForwardPredOnly = TRUE;		 
		}
		else 
#endif // H263P
		{
			GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
			bGetCBPB = uResult;			// see section 5.3.3 table 7/H.263
			if (bGetCBPB) 
			{
				bGetMVDB = 1;
				GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult);
				bGetCBPB = uResult;
			}
		}
	} 

	// CBPB ----------------------------------------------------
	DC->u8CBPB = 0;
	if (bGetCBPB) 
	{
		ASSERT(!DC->bKeyFrame);
		GET_FIXED_BITS(6, fpu8, uWork, uBitsReady, uResult);
		DC->u8CBPB = (U8)uResult;
	}

	// CBPY ----------------------------------------------------
	GET_VARIABLE_BITS(6, fpu8, uWork, uBitsReady, uResult, 
					  uCode, uBitCount, gNewTAB_CBPY);
	if (uResult == 0) 
	{
		ERRORMESSAGE(("%s:  Undefined CBPY variable code!\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}
	if (DC->uMBType > 2)		//INTRA MB, not intra frame
		DC->uCBPY = CBPY_INTRA(uResult); 
	else
		DC->uCBPY = CBPY_INTER(uResult);

	// DQUANT --------------------------------------------------
	if (DC->uMBType == 1 || DC->uMBType == 4) 
	{
		GET_FIXED_BITS(2, fpu8, uWork, uBitsReady, uResult);
		DC->uDQuant = gNewTAB_DQUANT[uResult];
		DC->uGQuant += DC->uDQuant;
		DC->uPQuant =  DC->uGQuant;
	} else
		DC->uDQuant = 0;

	DEBUGMSG(ZONE_DECODE_MB_HEADER, ("  %s: MBType = %ld, MCBPC = 0x%lX, CBPY = 0x%lX, DQuant = 0x%lX\r\n", _fx_, DC->uMBType, DC->uCBPC, DC->uCBPY, DC->uDQuant));

	// MVD -----------------------------------------------------
	DC->i8MVDx2=DC->i8MVDy2=0;	 //Zero init it anyway.

	if ( DC->bPBFrame || DC->uMBType <= 2) 
	{
	    GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Undefined Motion Vector code!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVDx2 = (I8)(uResult>>8);

	    GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVDy2 = (I8)(uResult>>8);
	}

	// MVD 2-4 -------------------------------------------------
#ifdef H263P
	// In H.263+, 8x8 motion vectors are possible if the deblocking
	// filter is selected.
	if ((DC->bAdvancedPrediction || DC->bDeblockingFilter)
		&& (DC->uMBType == 2) ) 
#else
	if (DC->bAdvancedPrediction && (DC->uMBType == 2) ) 
#endif
	{
		DC->i8MVD2x2 = DC->i8MVD2y2 = 0;

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD2x2 = (I8)(uResult>>8);

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD2y2 = (I8)(uResult>>8);

		DC->i8MVD3x2 = DC->i8MVD3y2 = 0;

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD3x2 = (I8)(uResult>>8);

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD3y2 = (I8)(uResult>>8);

		DC->i8MVD4x2 = DC->i8MVD4y2 = 0;

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD4x2 = (I8)(uResult>>8);

		GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Block Motion Vector VLC!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->i8MVD4y2 = (I8)(uResult>>8);

		DEBUGMSG(ZONE_DECODE_MB_HEADER, ("  %s: MVD2x2 = %d, MVD2y2 = %d, MVD3x2 = %d, MVD3y2 = %d, MVD4x2 = %d, MVD4y2 = %d\r\n", _fx_, DC->i8MVD2x2, DC->i8MVD2y2, DC->i8MVD3x2, DC->i8MVD3y2, DC->i8MVD4x2, DC->i8MVD4y2));
	}

	// MVDB ----------------------------------------------------
	DC->i8MVDBx2 = DC->i8MVDBy2 = 0;	 //Zero init it anyway.
	fpMBInfo->i8MVDBx2 = fpMBInfo->i8MVDBy2 = 0;
	if (bGetMVDB) 
	{
		ASSERT(DC->bPBFrame);
		ASSERT(!DC->bKeyFrame);
        GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Motion Vector MVDB!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		fpMBInfo->i8MVDBx2 = DC->i8MVDBx2 = (I8)(uResult>>8);

	    GET_VARIABLE_BITS_MV(13, fpu8, uWork, uBitsReady, uResult,uCode, 
                             uBitCount, gTAB_MVD_MAJOR, gTAB_MVD_MINOR);
		if (!uResult) 
		{
			ERRORMESSAGE(("%s:  Bad Motion Vector MVDB!\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		fpMBInfo->i8MVDBy2 = DC->i8MVDBy2 = (I8)(uResult>>8);
	}

	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState)

	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodeMBHeader() */
#pragma code_seg()


/*****************************************************************************
 *
 *  H263DecodeIDCTCoeffs
 *
 *  Decode each of the blocks in this macro block
 */
#pragma code_seg("IACODE1")
I32 H263DecodeIDCTCoeffs(
	T_H263DecoderCatalog FAR * DC,
	T_BlkAction FAR * fpBlockAction, 
	U32 uBlockNumber,
	BITSTREAM_STATE FAR * fpbsState,
	U8 FAR * fpu8MaxPtr,
	U32 **pN,                           // NEW
	T_IQ_INDEX **pRUN_INVERSE_Q)        // NEW
{
	I32 iResult = ICERR_ERROR;
	int iBlockPattern;
	int i;
	U8 u8PBlkType;
	U32 uBitsReady;
	U32 uBitsReadIn;
	U32 uBitsReadOut;
	U8  u8Quant;				// quantization level for this Mblock 
	U8 FAR * fpu8;
	U32 uByteCnt;
	T_BlkAction FAR * pActionStream;
#ifdef USE_MMX // { USE_MMX
    T_pFunc_VLD_RLD_IQ_Block pFunc_VLD = pFunc_VLD_RLD_IQ_Block[DC->bMMXDecoder];
#else // }{ USE_MMX
    T_pFunc_VLD_RLD_IQ_Block pFunc_VLD = VLD_RLD_IQ_Block;
#endif // } USE_MMX

	pActionStream = fpBlockAction;

	FX_ENTRY("H263DecodeIDCTCoeffs");

	/* On input the pointer points to the next byte.  We need to change it to 
	 * point to the current word on a 32-bit boundary.  
	 */

	fpu8 = fpbsState->fpu8 - 1;				/* point to the current byte */
	uBitsReady = fpbsState->uBitsReady;

	while (uBitsReady >= 8) 
	{
		fpu8--;
		uBitsReady -= 8;
	}

	uBitsReadIn = 8 - uBitsReady;
	u8Quant = (U8) (DC->uGQuant); 	

	if ( (DC->bPBFrame) || ((!DC->bKeyFrame) && (DC->uMBType <= 2))) 
	{
		// calculate motion vectors for the 6 blocks in this MB
		iResult = H263ComputeMotionVectors(DC, fpBlockAction);         // NEW

		if (iResult != ICERR_OK) 
		{ 
			ERRORMESSAGE(("%s: Error decoding MV!\r\n", _fx_));
			goto done;
		}

	} // endif PB or (inter and not key)

    // create block pattern from CBPY & CBPC
    iBlockPattern = ( (int) DC->uCBPY ) << 2;
    iBlockPattern |=  (int) DC->uCBPC;

	// Decode all 6 blocks up to, but not including, IDCT.
	for (i=0; i<6; i++) 
	{
		if (iBlockPattern & 0x20) 
		{
			if (DC->uMBType >= 3)  
				fpBlockAction->u8BlkType = BT_INTRA;
			else
				fpBlockAction->u8BlkType = BT_INTER;
		}
		else 
		{
			if (DC->uMBType >= 3)  
				fpBlockAction->u8BlkType = BT_INTRA_DC;
			else
				fpBlockAction->u8BlkType = BT_EMPTY;
		}

		if (fpBlockAction->u8BlkType != BT_EMPTY) 
		{
			fpBlockAction->u8Quant = u8Quant;
			ASSERT(fpBlockAction->pCurBlock != NULL);
			ASSERT(fpBlockAction->uBlkNumber == uBlockNumber);

			uBitsReadOut = (*pFunc_VLD)(
										fpBlockAction,
										fpu8,
										uBitsReadIn,
										(U32 *) *pN,
										(U32 *) *pRUN_INVERSE_Q);


			if (uBitsReadOut == 0) 
			{
				ERRORMESSAGE(("%s: Error decoding P block: VLD_RLD_IQ_Block return 0 bits read...\r\n", _fx_));
				goto done;
			}

			ASSERT( **pN < 65);		

			*pRUN_INVERSE_Q += **pN;                       // NEW
			if (fpBlockAction->u8BlkType != BT_INTER)      // NEW
				**pN += 65;								   // NEW
			(*pN)++;

			uByteCnt = uBitsReadOut >> 3; 		/* divide by 8 */
			uBitsReadIn = uBitsReadOut & 0x7; 	/* mod 8 */
			fpu8 += uByteCnt;      		

			//  allow the pointer to address up to four beyond the end - reading
			//  by DWORD using postincrement; otherwise we have bitstream error.
			if (fpu8 > fpu8MaxPtr+4)
				goto done;

			//  The test matrix includes the debug version of the driver.  The 
			//  following assertion creates a problem when testing with VideoPhone
			//  and so please do not check-in a version with the assertion 
			//  uncommented.
			// ASSERT(fpu8 <= fpu8MaxPtr+4);

		}
		else 
		{ // block type is empty 
			**pN = 0;	                // NEW
			(*pN)++;
		}

		fpBlockAction++;
		iBlockPattern <<= 1;
		uBlockNumber++;

	} // end for (i=0; i<6; i++)


	//--------------------------------------------------------------------
	//
	//      Now do the 6 B-blocks -- if needed
	//
	//--------------------------------------------------------------------
	if (DC->bPBFrame) 
	{ // we are doing PB frames
		fpBlockAction = pActionStream;    // recover the block action stream pointer
		uBlockNumber -= 6;
		iBlockPattern = (int) DC->u8CBPB; // block pattern
		u8Quant = (U8) ( DC->uPQuant * (5 + DC->uDBQuant) / 4 );
		if (u8Quant > 31) u8Quant = 31;
		if (u8Quant <  1) u8Quant =  1;

		// Decode all 6 blocks up to, but not including, IDCT.
		for (i=0; i<6; i++) 
		{
			// if the block is coded
            if (iBlockPattern & 0x20) {
				// preserve the block type of the P-frame block
				u8PBlkType = fpBlockAction->u8BlkType;

				fpBlockAction->u8BlkType = BT_INTER;
				fpBlockAction->u8Quant = u8Quant;

				ASSERT(fpBlockAction->pBBlock != NULL);
				ASSERT(fpBlockAction->uBlkNumber == uBlockNumber);

				uBitsReadOut = (*pFunc_VLD)(
											fpBlockAction,
											fpu8,
											uBitsReadIn,
											(U32 *) *pN,
											(U32 *) *pRUN_INVERSE_Q);

                if (uBitsReadOut == 0) {
					ERRORMESSAGE(("%s: Error decoding B block: VLD_RLD_IQ_Block return 0 bits read...\r\n", _fx_));
					goto done;
				}

				ASSERT( **pN < 65);			// no B-frame Intra blocks		
				*pRUN_INVERSE_Q += **pN;							// NEW
				(*pN)++;

				uByteCnt = uBitsReadOut >> 3; 		// divide by 8
				uBitsReadIn = uBitsReadOut & 0x7; 	// mod 8
				fpu8 += uByteCnt;      		

				// allow the pointer to address up to four beyond the 
				// end - reading  by DWORD using postincrement; otherwise we 
				// have bitstream error.
				if (fpu8 > fpu8MaxPtr+4)
					goto done;

				//  The test matrix includes the debug version of the driver.  
				//  The following assertion creates a problem when testing with
				// VideoPhone and so please do not check-in a version with the 
				// assertion uncommented.
				// ASSERT(fpu8 <= fpu8MaxPtr+4);

				// restore the block type of the P-frame block
				fpBlockAction->u8BlkType = u8PBlkType;

			}
			else 
			{ // block is not coded
				**pN = 0;	                // NEW
				(*pN)++;
			}  // end if block is coded ... else ...

			fpBlockAction++;
			iBlockPattern <<= 1;
			uBlockNumber++;

		} // end for (i=0; i<6; i++)

	}  // end if (DC->bPBFrame)


	/* restore the scanning pointers to point to the next byte and set the 
	 * uWork and uBitsReady values.
	 */

	while (uBitsReadIn > 8)
	{
		fpu8++;
		uBitsReadIn -= 8;
	}
	fpbsState->uBitsReady = 8 - uBitsReadIn;
	fpbsState->uWork = *fpu8++;	   /* store the data and point to next byte */
	fpbsState->uWork &= GetBitsMask[fpbsState->uBitsReady];
	fpbsState->fpu8 = fpu8; 

	iResult = ICERR_OK;

done:
	return iResult;

} /* END H263DecodeIDCTCoeffs() */
#pragma code_seg()

#pragma code_seg("IACODE1")
I32 H263ComputeMotionVectors(T_H263DecoderCatalog FAR * DC,
	                         T_BlkAction FAR * fpBlockAction)
	       
{ 
	I32 mvx1, mvy1, mvx2, mvy2, mvx3, mvy3;  //predictors
	// motion vector predictors for AP
	I32 mvxp[3], mvyp[3];
	// motion vector differences for AP
	I32 mvxd[4], mvyd[4];
	int iAbove;       // takes you up one GOB (-1 * # of blocks in a GOB)
	I32 iMBNum;
	I32 iMBOffset;
	I32  mvx, mvy, scratch;
	int i;
	I32 iNumberOfMBsPerGOB;	  //assume QCIF for Now
	BOOL bNoAbove, bNoRight, bUMV;

	const char QuarterPelRound[] = {0, 1, 0, 0};
    const char SixteenthPelRound[] = 
        {0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1};

	FX_ENTRY("H263ComputeMotionVectors");

	DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: MB# = %d, BlockNumber = %d, (MVDx2,MVDy2) = (%d, %d)\r\n", _fx_, fpBlockAction->uBlkNumber/6, fpBlockAction->uBlkNumber, DC->i8MVDx2, DC->i8MVDy2));

#ifdef _DEBUG
	if (DC->uMBType == 2)
	{
		DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: (MVD2x2,MVD2y2) = (%d, %d), (MVD3x2,MVD3y2) = (%d, %d), (MVD4x2,MVD4y2) = (%d, %d)\r\n", _fx_, DC->i8MVD2x2, DC->i8MVD2y2, DC->i8MVD3x2, DC->i8MVD3y2, DC->i8MVD4x2, DC->i8MVD4y2));
	}
#endif

	iNumberOfMBsPerGOB = DC->iNumberOfMBsPerGOB;
	iMBNum             = fpBlockAction->uBlkNumber / 6;
	iMBOffset          = iMBNum % iNumberOfMBsPerGOB;
	iAbove			 = -6 * iNumberOfMBsPerGOB;
	bNoAbove           = (DC->bGOBHeaderPresent) || (iMBNum < iNumberOfMBsPerGOB);
	bNoRight			 = iMBOffset == (iNumberOfMBsPerGOB - 1);
	bUMV 				 = DC->bUnrestrictedMotionVectors;

	if (DC->uMBType != 2) 
	{    // One motion vector per macroblock
		// when either a GOB header is present or
		// we are on the first GOB, only look to the left
		if ( bNoAbove ) 
		{
			// only one predictor
			if (iMBOffset == 0)							// when on the left edge,
				mvx2 = mvy2 = 0;							// use 0, else
			else 
			{
				mvx2 = fpBlockAction[-6 + 1].i8MVx2;		// use upper right corner
				mvy2 = fpBlockAction[-6 + 1].i8MVy2;		// of MB to the left
			}
		}

		// no GOB header and not the first GOB
		// need all three predictors
		else 
		{ 
			// left predictor
			if (iMBOffset == 0)							// when on the left edge, 
				mvx1 = mvy1 = 0;							// use 0, else
			else 
			{ 
				mvx1 = fpBlockAction[-6 + 1].i8MVx2;		// use upper right corner
				mvy1 = fpBlockAction[-6 + 1].i8MVy2;		// of MB to the left
			}

			// above predictor
			// use lower left corner 
			// of MB directly above
			mvx2 = fpBlockAction[iAbove + 2].i8MVx2;
			mvy2 = fpBlockAction[iAbove + 2].i8MVy2;

			// upper right predictor
			if ( bNoRight )	// when on the right edge
				mvx3 = mvy3 = 0;							// use 0
			else
			{	// else use lower left corner
				// of MB above & to the right
				mvx3 = fpBlockAction[iAbove + 8].i8MVx2;
				mvy3 = fpBlockAction[iAbove + 8].i8MVy2;
			}

			// select the medium value and place it in mvx2 & mvy2
			MEDIAN(mvx1, mvx2, mvx3, scratch);
			MEDIAN(mvy1, mvy2, mvy3, scratch);

		}  // end if (header or 1st GOB) ... else ...

		//  mvx2 and mvy2 have the medium predictors compute the motion vector 
		//  by adding in the difference
		mvx = DC->i8MVDx2 + mvx2;
		mvy = DC->i8MVDy2 + mvy2; 

		//  check for Unrestricted Motion Vector mode and adjust the motion 
		//  vector if necessary using the appropriate strategy, finishing
		//  the decoding process.
		if (bUMV) 
		{
			if (mvx2 > 32) 
			{
				if (mvx > 63) mvx -=64;
			}  
			else if (mvx2 < -31) 
			{
				if (mvx < -63) mvx +=64;
			}  

			if (mvy2 > 32) 
			{
				if (mvy > 63) mvy -=64;
			}  
			else if (mvy2 < -31) 
			{
				if (mvy < -63) mvy +=64;
			}
		}
		else 
		{  // UMV off
			if (mvx > 31)	  mvx -= 64;
			else if (mvx < -32)  mvx += 64;
			if (mvy > 31)  mvy -= 64;
			else if (mvy < -32) mvy += 64;
		}

		// save into the block action stream,
		// duplicating for the other 3 Y blocks.
		fpBlockAction[0].i8MVx2 = 
		fpBlockAction[1].i8MVx2 = 
		fpBlockAction[2].i8MVx2 = 
		fpBlockAction[3].i8MVx2 = (I8)mvx;

		fpBlockAction[0].i8MVy2 =
		fpBlockAction[1].i8MVy2 = 
		fpBlockAction[2].i8MVy2 = 
		fpBlockAction[3].i8MVy2 = (I8)mvy;


		// Chroma motion vectors
		// divide by 2 and round according to spec
		fpBlockAction[4].i8MVx2 = 
		fpBlockAction[5].i8MVx2 = 
		(mvx >> 1) + QuarterPelRound[mvx & 0x03];
		fpBlockAction[4].i8MVy2 = 
		fpBlockAction[5].i8MVy2 =
		(mvy >> 1) + QuarterPelRound[mvy & 0x03];

	} // end one motion vector per macroblock
	else 
	{
		// fpBlockAction[iNext[i][j]] points to block #i's (j+1)th predictor
		int iNext[4][3] = {-5,2,8, 0,3,8, -3,0,1, 2,0,1};

		// adjust iNext pointers which need to point to the GOB above
		iNext[0][1] += iAbove;		// block 0, mv2 -- block 2 of above MB
		iNext[0][2] += iAbove;		// block 0, mv3	-- block 2 of above-right MB
		iNext[1][1] += iAbove;		// block 1, mv2 -- block 3 of above MB
		iNext[1][2] += iAbove;		// block 1, mv3	-- block 2 of above-right MB

		// fetch motion vector differences
		mvxd[0] = DC->i8MVDx2;
		mvyd[0] = DC->i8MVDy2;
		mvxd[1] = DC->i8MVD2x2;
		mvyd[1] = DC->i8MVD2y2;
		mvxd[2] = DC->i8MVD3x2;
		mvyd[2] = DC->i8MVD3y2;
		mvxd[3] = DC->i8MVD4x2;
		mvyd[3] = DC->i8MVD4y2;

		// loop on Lumina blocks in this MB
		for (i=0, mvx=0, mvy=0; i<4; i++) 
		{
			// get predictor 1
			if ( (i&1) || (iMBOffset) ) 
			{ // not on left edge
				mvxp[0] = fpBlockAction[iNext[i][0]].i8MVx2; 
				mvyp[0] = fpBlockAction[iNext[i][0]].i8MVy2;
			}
			else 
			{ // on left edge, zero the predictor
				mvxp[0] = mvyp[0] = 0;
			}

			// for predictors 2 and 3, check if we can 
			// look above and that we are on blocks 0 or 1
			if ( (bNoAbove) && (i < 2) ) 
			{
				// set predictor 2 equal to predictor 1
				mvxp[1] = mvxp[0]; 
				mvyp[1] = mvyp[0];

				if (bNoRight) 
				{
					// if on the right edge, zero predictor 3
					mvxp[2] = mvyp[2] = 0;
				}
				else 
				{ // else set predictor 3 equal to predictor 1
					mvxp[2] = mvxp[0]; 
					mvyp[2] = mvyp[0];
				} // end predictor 3

			}
			else 
			{ // okay to look up
				// get predictor 2
				mvxp[1] = fpBlockAction[iNext[i][1]].i8MVx2;
				mvyp[1] = fpBlockAction[iNext[i][1]].i8MVy2;

				// get predictor 3
                if ( (bNoRight) && (i < 2) ) { 
					// if on the right edge, zero predictor 3
					mvxp[2] = mvyp[2] = 0;
				}
				else 
				{ // else fetch it from the block action stream
					mvxp[2] = fpBlockAction[iNext[i][2]].i8MVx2;
					mvyp[2] = fpBlockAction[iNext[i][2]].i8MVy2;
				} // end predictor 3

			} // end predictors 2 & 3

			// got all of the candidate predictors now get the median
			// output in mv-p[1]
			MEDIAN( mvxp[0], mvxp[1], mvxp[2], scratch);
			MEDIAN( mvyp[0], mvyp[1], mvyp[2], scratch);

			// add in the difference,
			// put the freshly constructed motion vector in mv-p[0]
			// leaving the predictors in mv-p[1] for use if UMV is on.
			mvxp[0] = mvxp[1] + mvxd[i];
			mvyp[0] = mvyp[1] + mvyd[i]; 

			// check for Unrestricted Motion Vector mode
			// and, if necessary, adjust the motion vector according
			// to the appropriate decoding strategy, thereby
			// finishing the decoding process.
			if ( bUMV ) 
			{
				if (mvxp[1] > 32) 
				{
					if (mvxp[0] > 63) mvxp[0] -=64;
				}  
				else if (mvxp[1] < -31) 
				{
					if (mvxp[0] < -63) mvxp[0] +=64;
				}  

				if (mvyp[1] > 32) 
				{
					if (mvyp[0] > 63) mvyp[0] -=64;
				}  
				else if (mvyp[1] < -31) 
				{
					if (mvyp[0] < -63) mvyp[0] +=64;
				}
			}
			else 
			{  // UMV off
				if (mvxp[0] > 31)	  mvxp[0] -= 64;
				else if (mvxp[0] < -32)  mvxp[0] += 64;

				if (mvyp[0] > 31)  mvyp[0] -= 64;
				else if (mvyp[0] < -32) mvyp[0] += 64;
			}

			// finally store the result in the block action stream and
			// accumulate the sum of Lumina for the Chroma 
			mvx += (fpBlockAction[i].i8MVx2 = (I8)mvxp[0]);
			mvy += (fpBlockAction[i].i8MVy2 = (I8)mvyp[0]);

		} // end Lumina vectors

		// Compute the Chroma vectors
		// divide sum of Lumina by 8 and round according to spec
		fpBlockAction[4].i8MVx2 = 
		fpBlockAction[5].i8MVx2 = 
		(mvx >> 3) + SixteenthPelRound[mvx & 0x0f];
		fpBlockAction[4].i8MVy2 = 
		fpBlockAction[5].i8MVy2 = 
		(mvy >> 3) + SixteenthPelRound[mvy & 0x0f];

	} // end 4 motion vectors per macroblock


	DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: Motion vector = (%d, %d)\r\n", _fx_, fpBlockAction->i8MVx2, fpBlockAction->i8MVy2));

#ifdef _DEBUG
	if (DC->uMBType == 2)
	{
		for (int i = 1; i < 6; i++)
		{
			DEBUGMSG(ZONE_DECODE_COMPUTE_MOTION_VECTORS, ("   %s: Motion vector %d = (%d, %d)\r\n", _fx_, i, fpBlockAction[i].i8MVx2, fpBlockAction[i].i8MVy2));
		}
	}
#endif

	return ICERR_OK;
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3tables.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 16:46:30  $
// $Archive:   S:\h26x\src\dec\d3tables.cpv  $
// $Header:   S:\h26x\src\dec\d3tables.cpv   1.10   08 Mar 1996 16:46:30   AGUPTA2  $
// $Log:   S:\h26x\src\dec\d3tables.cpv  $
// 
//    Rev 1.10   08 Mar 1996 16:46:30   AGUPTA2
// Removed tables gTAB_MCBPC_INTRA, gTAB_MCBPC_INTER, gTAB_CBPY_INTRA, and
// gTAB_CBPY_INTER. Added pragma data_seg to put all the tables in the Pass 1
// data segment.
// 
// 
//    Rev 1.9   27 Dec 1995 14:36:08   RMCKENZX
// Added copyright notice
// 
//    Rev 1.8   08 Oct 1995 13:41:58   CZHU
// 
// Fixed zz-run table with two wrong entries, 
// 
//    Rev 1.7   18 Sep 1995 08:40:28   CZHU
// Fixed bugs with table entries for negative val
// 
//    Rev 1.6   07 Sep 1995 09:46:40   CZHU
// fixed one bug in TCOEFF minor table
// 
//    Rev 1.5   31 Aug 1995 16:42:48   CZHU
// Changed the format of MVD variable length decoder tables: major and minor
// 
//    Rev 1.4   24 Aug 1995 15:34:28   CZHU
// Fixed bugs in the inverse quant table, and TCOEFF minor tables 
// 
//    Rev 1.3   22 Aug 1995 17:39:00   CZHU
// 
// Modified the TCOEFF_MAJOR and MINOR tables for embedded run values.
// 
//    Rev 1.2   18 Aug 1995 15:01:00   CZHU
// Added run length tables ready for joint opt IDCT and RLD+ZZ
// 
//    Rev 1.1   16 Aug 1995 14:25:10   CZHU
// 
// Rebuild the tables for IQ, RLD for Transform coefficients
// 
//    Rev 1.0   11 Aug 1995 15:50:56   CZHU
// Initial revision.
;// 
;//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
;// 
;// Added table for inverse quantization and RLD-ZZ
;// 
;//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
;// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here

#include "precomp.h"

/*
U16 gTAB_MCBPC_INTRA[512]= {

0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x0, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1409, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1206, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1106, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1306, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01, 0x1004, 
0xc01, 0xd03, 0xc01, 0xe03, 0xc01, 0xf03, 0xc01 
};   //total 1024

U16 gTAB_MCBPC_INTER[512]={

0x0,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xd08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1109,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1309,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xb08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xe08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1409,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xd08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x709,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x1209,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xa07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xb08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x607,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xe08,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x1006,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x907,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0xf07,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0x306,
0x1,0x803,0x1,0x104,0x1,0x403,0x1,0x507,
0x1,0x803,0x1,0x204,0x1,0x403,0x1,0xc05,
0x1,0x803,0x1,0x104,0x1,0x403,0x1


};   //total 1024


U16 gTAB_CBPY_INTRA[64]={

0x0,  0xd04,0xc04,0xf02,0x205,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02, 
0x606,0xd04,0xc04,0xf02,0x105,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02, 
0x0,  0xd04,0xc04,0xf02,0x205,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02, 
0x906,0xd04,0xc04,0xf02,0x105,0xb04,0xe04,0xf02, 
0x705,0x705,0x705,0xf02,0x705,0x705,0x705,0xf02
};		    //total 128

U16 gTAB_CBPY_INTER[64]={

0x0,  0x204,0x304,0x2,0xd05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2, 
0x906,0x204,0x304,0x2,0xe05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2, 
0x0,  0x204,0x304,0x2,0xd05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2, 
0x606,0x204,0x304,0x2,0xe05,0x404,0x104,0x2, 
0x805,0x805,0x805,0x2,0x805,0x805,0x805,0x2 

};		    //total 128
*/

#pragma data_seg("IADATA1")
U16 gTAB_MVD_MAJOR[256]={
0x0,
0x0,0x0,0x0,0x0,0x0,0x708,0xf908,0x608,
0xfa08,0x508,0xfb08,0x407,0x407,0xfc07,0xfc07,0x305,
0x305,0x305,0x305,0x305,0x305,0x305,0x305,0xfd05,
0xfd05,0xfd05,0xfd05,0xfd05,0xfd05,0xfd05,0xfd05,0x204,
0x204,0x204,0x204,0x204,0x204,0x204,0x204,0x204,
0x204,0x204,0x204,0x204,0x204,0x204,0x204,0xfe04,
0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,
0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0xfe04,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0x103,
0x103,0x103,0x103,0x103,0x103,0x103,0x103,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,
0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0xff03,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,
0x1,0x1,0x1,0x1,0x1,0x1,0x1
};     //total 512

U16 gTAB_MVD_MINOR[256]={

0x0,
0x0,0x0,0x0,0x0,0xe00d,0x1f0d,0xe10d,0x1e0c,
0x1e0c,0xe20c,0xe20c,0x1d0c,0x1d0c,0xe30c,0xe30c,0x1c0c,
0x1c0c,0xe40c,0xe40c,0x1b0c,0x1b0c,0xe50c,0xe50c,0x1a0c,
0x1a0c,0xe60c,0xe60c,0x190c,0x190c,0xe70c,0xe70c,0x180b,
0x180b,0x180b,0x180b,0xe80b,0xe80b,0xe80b,0xe80b,0x170b,
0x170b,0x170b,0x170b,0xe90b,0xe90b,0xe90b,0xe90b,0x160b,
0x160b,0x160b,0x160b,0xea0b,0xea0b,0xea0b,0xea0b,0x150b,
0x150b,0x150b,0x150b,0xeb0b,0xeb0b,0xeb0b,0xeb0b,0x140b,
0x140b,0x140b,0x140b,0xec0b,0xec0b,0xec0b,0xec0b,0x130b,
0x130b,0x130b,0x130b,0xed0b,0xed0b,0xed0b,0xed0b,0x120b,
0x120b,0x120b,0x120b,0xee0b,0xee0b,0xee0b,0xee0b,0x110b,
0x110b,0x110b,0x110b,0xef0b,0xef0b,0xef0b,0xef0b,0x100b,
0x100b,0x100b,0x100b,0xf00b,0xf00b,0xf00b,0xf00b,0xf0b,
0xf0b,0xf0b,0xf0b,0xf10b,0xf10b,0xf10b,0xf10b,0xe0b,
0xe0b,0xe0b,0xe0b,0xf20b,0xf20b,0xf20b,0xf20b,0xd0b,
0xd0b,0xd0b,0xd0b,0xf30b,0xf30b,0xf30b,0xf30b,0xc0b,
0xc0b,0xc0b,0xc0b,0xf40b,0xf40b,0xf40b,0xf40b,0xb0b,
0xb0b,0xb0b,0xb0b,0xf50b,0xf50b,0xf50b,0xf50b,0xa0a,
0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xf60a,
0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0x90a,
0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0xf70a,
0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0x80a,
0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0xf80a,
0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xc0b,
0xc0b,0xc0b,0xc0b,0xf40b,0xf40b,0xf40b,0xf40b,0xb0b,
0xb0b,0xb0b,0xb0b,0xf50b,0xf50b,0xf50b,0xf50b,0xa0a,
0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xa0a,0xf60a,
0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0xf60a,0x90a,
0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0x90a,0xf70a,
0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0xf70a,0x80a,
0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0x80a,0xf80a,
0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a,0xf80a

};     //total 512

U32 gTAB_TCOEFF_MAJOR[256]={
0x3,
0x3,0x3,0x3,0x3,0x3,0x1,0x1,0x3,
0x3,0x3,0x3,0x3,0x3,0x203,0x203,0x3,
0x3,0x3,0x3,0x3,0x3,0x203,0x203,0x3,
0x3,0x3,0x3,0x3,0x3,0x203,0x203,0x221204,
0x221206,0x221004,0x221006,0x220e04,0x220e06,0x220c04,0x220c06,0x201a04,
0x201a06,0x201804,0x201806,0x201604,0x201606,0x200210,0x200212,0x1e0a04,
0x1e0a04,0x1e0a06,0x1e0a06,0x1e0804,0x1e0804,0x1e0806,0x1e0806,0x1e0604,
0x1e0604,0x1e0606,0x1e0606,0x1e0404,0x1e0404,0x1e0406,0x1e0406,0x1c1404,
0x1c1404,0x1c1406,0x1c1406,0x1c1204,0x1c1204,0x1c1206,0x1c1206,0x1c1004,
0x1c1004,0x1c1006,0x1c1006,0x1c0e04,0x1c0e04,0x1c0e06,0x1c0e06,0x1c0408,
0x1c0408,0x1c040a,0x1c040a,0x1c020c,0x1c020c,0x1c020e,0x1c020e,0x180c04,
0x180c04,0x180c04,0x180c04,0x180c06,0x180c06,0x180c06,0x180c06,0x180a04,
0x180a04,0x180a04,0x180a04,0x180a06,0x180a06,0x180a06,0x180a06,0x180804,
0x180804,0x180804,0x180804,0x180806,0x180806,0x180806,0x180806,0x160204,
0x160204,0x160204,0x160204,0x160204,0x160204,0x160204,0x160204,0x160206,
0x160206,0x160206,0x160206,0x160206,0x160206,0x160206,0x160206,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,
0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0204,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,
0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0xc0206,0x100404,
0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,
0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100404,0x100406,
0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,
0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x100406,0x140604,
0x140604,0x140604,0x140604,0x140604,0x140604,0x140604,0x140604,0x140606,
0x140606,0x140606,0x140606,0x140606,0x140606,0x140606,0x140606,0x140208,
0x140208,0x140208,0x140208,0x140208,0x140208,0x140208,0x140208,0x14020a,
0x14020a,0x14020a,0x14020a,0x14020a,0x14020a,0x14020a,0x14020a

};  //total 1024

U32 gTAB_TCOEFF_MINOR[1024]={
0x100,
0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x100,
0x100,0x100,0x100,0x100,0x100,0x100,0x100,0x190204,
0x190204,0x190205,0x190205,0x190106,0x190106,0x190107,0x190107,0x180116,
0x180116,0x180117,0x180117,0x180114,0x180114,0x180115,0x180115,0x171d02,
0x171d02,0x171d02,0x171d02,0x171d03,0x171d03,0x171d03,0x171d03,0x171c02,
0x171c02,0x171c02,0x171c02,0x171c03,0x171c03,0x171c03,0x171c03,0x171b02,
0x171b02,0x171b02,0x171b02,0x171b03,0x171b03,0x171b03,0x171b03,0x171a02,
0x171a02,0x171a02,0x171a02,0x171a03,0x171a03,0x171a03,0x171a03,0x160a04,
0x160a04,0x160a04,0x160a04,0x160a05,0x160a05,0x160a05,0x160a05,0x160904,
0x160904,0x160904,0x160904,0x160905,0x160905,0x160905,0x160905,0x160804,
0x160804,0x160804,0x160804,0x160805,0x160805,0x160805,0x160805,0x160704,
0x160704,0x160704,0x160704,0x160705,0x160705,0x160705,0x160705,0x160604,
0x160604,0x160604,0x160604,0x160605,0x160605,0x160605,0x160605,0x160406,
0x160406,0x160406,0x160406,0x160407,0x160407,0x160407,0x160407,0x160306,
0x160306,0x160306,0x160306,0x160307,0x160307,0x160307,0x160307,0x160208,
0x160208,0x160208,0x160208,0x160209,0x160209,0x160209,0x160209,0x180118,
0x180118,0x180119,0x180119,0x18020a,0x18020a,0x18020b,0x18020b,0x181802,
0x181802,0x181803,0x181803,0x181902,0x181902,0x181903,0x181903,0x191e02,
0x191e02,0x191e03,0x191e03,0x191f02,0x191f02,0x191f03,0x191f03,0x192002,
0x192002,0x192003,0x192003,0x192102,0x192102,0x192103,0x192103,0x1a020c,
0x1a020d,0x1a0308,0x1a0309,0x1a0506,0x1a0507,0x1a0606,0x1a0607,0x1a0706,
0x1a0707,0x1a0b04,0x1a0b05,0x1a1a02,0x1a1a03,0x1a1b02,0x1a1b03,0x1b2202,
0x1b2203,0x1b2302,0x1b2303,0x1b2402,0x1b2403,0x1b2502,0x1b2503,0x1b2602,
0x1b2603,0x1b2702,0x1b2703,0x1b2802,0x1b2803,0x1b2902,0x1b2903,0x180118,
0x180118,0x180119,0x180119,0x18020a,0x18020a,0x18020b,0x18020b,0x181802,
0x181802,0x181803,0x181803,0x181902,0x181902,0x181903,0x181903,0x191e02,
0x191e02,0x191e03,0x191e03,0x191f02,0x191f02,0x191f03,0x191f03,0x192002,
0x192002,0x192003,0x192003,0x192102,0x192102,0x192103,0x192103,0x1a020c,
0x1a020d,0x1a0308,0x1a0309,0x1a0506,0x1a0507,0x1a0606,0x1a0607,0x1a0706,
0x1a0707,0x1a0b04,0x1a0b05,0x1a1a02,0x1a1a03,0x1a1b02,0x1a1b03,0x1b2202,
0x1b2203,0x1b2302,0x1b2303,0x1b2402,0x1b2403,0x1b2502,0x1b2503,0x1b2602,
0x1b2603,0x1b2702,0x1b2703,0x1b2802,0x1b2803,0x1b2902,0x1b2903,0x160112,
0x160112,0x160112,0x160112,0x160113,0x160113,0x160113,0x160113,0x160110,
0x160110,0x160110,0x160110,0x160111,0x160111,0x160111,0x160111,0x151902,
0x151902,0x151902,0x151902,0x151902,0x151902,0x151902,0x151902,0x151903,
0x151903,0x151903,0x151903,0x151903,0x151903,0x151903,0x151903,0x151802,
0x151802,0x151802,0x151802,0x151802,0x151802,0x151802,0x151802,0x151803,
0x151803,0x151803,0x151803,0x151803,0x151803,0x151803,0x151803,0x151702,
0x151702,0x151702,0x151702,0x151702,0x151702,0x151702,0x151702,0x151703,
0x151703,0x151703,0x151703,0x151703,0x151703,0x151703,0x151703,0x151602,
0x151602,0x151602,0x151602,0x151602,0x151602,0x151602,0x151602,0x151603,
0x151603,0x151603,0x151603,0x151603,0x151603,0x151603,0x151603,0x151502,
0x151502,0x151502,0x151502,0x151502,0x151502,0x151502,0x151502,0x151503,
0x151503,0x151503,0x151503,0x151503,0x151503,0x151503,0x151503,0x151402,
0x151402,0x151402,0x151402,0x151402,0x151402,0x151402,0x151402,0x151403,
0x151403,0x151403,0x151403,0x151403,0x151403,0x151403,0x151403,0x151302,
0x151302,0x151302,0x151302,0x151302,0x151302,0x151302,0x151302,0x151303,
0x151303,0x151303,0x151303,0x151303,0x151303,0x151303,0x151303,0x151202,
0x151202,0x151202,0x151202,0x151202,0x151202,0x151202,0x151202,0x151203,
0x151203,0x151203,0x151203,0x151203,0x151203,0x151203,0x151203,0x150104,
0x150104,0x150104,0x150104,0x150104,0x150104,0x150104,0x150104,0x150105,
0x150105,0x150105,0x150105,0x150105,0x150105,0x150105,0x150105,0x141702,
0x141702,0x141702,0x141702,0x141702,0x141702,0x141702,0x141702,0x141703,
0x141703,0x141703,0x141703,0x141703,0x141703,0x141703,0x141703,0x141602,
0x141602,0x141602,0x141602,0x141602,0x141602,0x141602,0x141602,0x141603,
0x141603,0x141603,0x141603,0x141603,0x141603,0x141603,0x141603,0x141502,
0x141502,0x141502,0x141502,0x141502,0x141502,0x141502,0x141502,0x141503,
0x141503,0x141503,0x141503,0x141503,0x141503,0x141503,0x141503,0x141402,
0x141402,0x141402,0x141402,0x141402,0x141402,0x141402,0x141402,0x141403,
0x141403,0x141403,0x141403,0x141403,0x141403,0x141403,0x141403,0x141302,
0x141302,0x141302,0x141302,0x141302,0x141302,0x141302,0x141302,0x141303,
0x141303,0x141303,0x141303,0x141303,0x141303,0x141303,0x141303,0x141202,
0x141202,0x141202,0x141202,0x141202,0x141202,0x141202,0x141202,0x141203,
0x141203,0x141203,0x141203,0x141203,0x141203,0x141203,0x141203,0x141102,
0x141102,0x141102,0x141102,0x141102,0x141102,0x141102,0x141102,0x141103,
0x141103,0x141103,0x141103,0x141103,0x141103,0x141103,0x141103,0x141002,
0x141002,0x141002,0x141002,0x141002,0x141002,0x141002,0x141002,0x141003,
0x141003,0x141003,0x141003,0x141003,0x141003,0x141003,0x141003,0x140504,
0x140504,0x140504,0x140504,0x140504,0x140504,0x140504,0x140504,0x140505,
0x140505,0x140505,0x140505,0x140505,0x140505,0x140505,0x140505,0x140404,
0x140404,0x140404,0x140404,0x140404,0x140404,0x140404,0x140404,0x140405,
0x140405,0x140405,0x140405,0x140405,0x140405,0x140405,0x140405,0x14010e,
0x14010e,0x14010e,0x14010e,0x14010e,0x14010e,0x14010e,0x14010e,0x14010f,
0x14010f,0x14010f,0x14010f,0x14010f,0x14010f,0x14010f,0x14010f,0x14010c,
0x14010c,0x14010c,0x14010c,0x14010c,0x14010c,0x14010c,0x14010c,0x14010d,
0x14010d,0x14010d,0x14010d,0x14010d,0x14010d,0x14010d,0x14010d,0x131102,
0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,
0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131102,0x131103,
0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,
0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131103,0x131002,
0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,
0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131002,0x131003,
0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,
0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x131003,0x130f02,
0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,
0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f02,0x130f03,
0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,
0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130f03,0x130e02,
0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,
0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e02,0x130e03,
0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,
0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130e03,0x130d02,
0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,
0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d02,0x130d03,
0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,
0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130d03,0x130c02,
0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,
0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c02,0x130c03,
0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,
0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130c03,0x130b02,
0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,
0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b02,0x130b03,
0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,
0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130b03,0x130a02,
0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,
0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a02,0x130a03,
0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,
0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x130a03,0x120f02,
0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,
0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f02,0x120f03,
0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,
0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120f03,0x120e02,
0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,
0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e02,0x120e03,
0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,
0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120e03,0x120304,
0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,
0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120304,0x120305,
0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,
0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120305,0x120206,
0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,
0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120206,0x120207,
0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,
0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x120207,0x12010a,
0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,
0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010a,0x12010b,
0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,
0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b,0x12010b

}; //total 4096

I16 gTAB_INVERSE_Q[1024] = { 
  0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    0,    0,    0,    0,    0,    0,    0, 
   0,    3,   -3,    5,   -5,    7,   -7,    9, 
  -9,   11,  -11,   13,  -13,   15,  -15,   17, 
 -17,   19,  -19,   21,  -21,   23,  -23,   25, 
 -25,   27,  -27,   29,  -29,   31,  -31,    0, 
   0,    5,   -5,    9,   -9,   13,  -13,   17, 
 -17,   21,  -21,   25,  -25,   29,  -29,   33, 
 -33,   37,  -37,   41,  -41,   45,  -45,   49, 
 -49,   53,  -53,   57,  -57,   61,  -61,    0, 
   0,    9,   -9,   15,  -15,   21,  -21,   27, 
 -27,   33,  -33,   39,  -39,   45,  -45,   51, 
 -51,   57,  -57,   63,  -63,   69,  -69,   75, 
 -75,   81,  -81,   87,  -87,   93,  -93,    0, 
   0,   11,  -11,   19,  -19,   27,  -27,   35, 
 -35,   43,  -43,   51,  -51,   59,  -59,   67, 
 -67,   75,  -75,   83,  -83,   91,  -91,   99, 
 -99,  107, -107,  115, -115,  123, -123,    0, 
   0,   15,  -15,   25,  -25,   35,  -35,   45, 
 -45,   55,  -55,   65,  -65,   75,  -75,   85, 
 -85,   95,  -95,  105, -105,  115, -115,  125, 
-125,  135, -135,  145, -145,  155, -155,    0, 
   0,   17,  -17,   29,  -29,   41,  -41,   53, 
 -53,   65,  -65,   77,  -77,   89,  -89,  101, 
-101,  113, -113,  125, -125,  137, -137,  149, 
-149,  161, -161,  173, -173,  185, -185,    0, 
   0,   21,  -21,   35,  -35,   49,  -49,   63, 
 -63,   77,  -77,   91,  -91,  105, -105,  119, 
-119,  133, -133,  147, -147,  161, -161,  175, 
-175,  189, -189,  203, -203,  217, -217,    0, 
   0,   23,  -23,   39,  -39,   55,  -55,   71, 
 -71,   87,  -87,  103, -103,  119, -119,  135, 
-135,  151, -151,  167, -167,  183, -183,  199, 
-199,  215, -215,  231, -231,  247, -247,    0, 
   0,   27,  -27,   45,  -45,   63,  -63,   81, 
 -81,   99,  -99,  117, -117,  135, -135,  153, 
-153,  171, -171,  189, -189,  207, -207,  225, 
-225,  243, -243,  261, -261,  279, -279,    0, 
   0,   29,  -29,   49,  -49,   69,  -69,   89, 
 -89,  109, -109,  129, -129,  149, -149,  169, 
-169,  189, -189,  209, -209,  229, -229,  249, 
-249,  269, -269,  289, -289,  309, -309,    0, 
   0,   33,  -33,   55,  -55,   77,  -77,   99, 
 -99,  121, -121,  143, -143,  165, -165,  187, 
-187,  209, -209,  231, -231,  253, -253,  275, 
-275,  297, -297,  319, -319,  341, -341,    0, 
   0,   35,  -35,   59,  -59,   83,  -83,  107, 
-107,  131, -131,  155, -155,  179, -179,  203, 
-203,  227, -227,  251, -251,  275, -275,  299, 
-299,  323, -323,  347, -347,  371, -371,    0, 
   0,   39,  -39,   65,  -65,   91,  -91,  117, 
-117,  143, -143,  169, -169,  195, -195,  221, 
-221,  247, -247,  273, -273,  299, -299,  325, 
-325,  351, -351,  377, -377,  403, -403,    0, 
   0,   41,  -41,   69,  -69,   97,  -97,  125, 
-125,  153, -153,  181, -181,  209, -209,  237, 
-237,  265, -265,  293, -293,  321, -321,  349, 
-349,  377, -377,  405, -405,  433, -433,    0, 
   0,   45,  -45,   75,  -75,  105, -105,  135, 
-135,  165, -165,  195, -195,  225, -225,  255, 
-255,  285, -285,  315, -315,  345, -345,  375, 
-375,  405, -405,  435, -435,  465, -465,    0, 
   0,   47, -47,   79,  -79,  111, -111,  143, 
-143,  175, -175,  207, -207,  239, -239,  271, 
-271,  303, -303,  335, -335,  367, -367,  399, 
-399,  431, -431,  463, -463,  495, -495,    0, 
   0,   51,  -51,   85,  -85,  119, -119,  153, 
-153,  187, -187,  221, -221,  255, -255,  289, 
-289,  323, -323,  357, -357,  391, -391,  425, 
-425,  459, -459,  493, -493,  527, -527,    0, 
   0,   53,  -53,   89,  -89,  125, -125,  161, 
-161,  197, -197,  233, -233,  269, -269,  305, 
-305,  341, -341,  377, -377,  413, -413,  449, 
-449,  485, -485,  521, -521,  557, -557,    0, 
   0,   57,  -57,   95,  -95,  133, -133,  171, 
-171,  209, -209,  247, -247,  285, -285,  323, 
-323,  361, -361,  399, -399,  437, -437,  475, 
-475,  513, -513,  551, -551,  589, -589,    0, 
   0,   59,  -59,   99,  -99,  139, -139,  179, 
-179,  219, -219,  259, -259,  299, -299,  339, 
-339,  379, -379,  419, -419,  459, -459,  499, 
-499,  539, -539,  579, -579,  619, -619,    0, 
   0,   63,  -63,  105, -105,  147, -147,  189, 
-189,  231, -231,  273, -273,  315, -315,  357, 
-357,  399, -399,  441, -441,  483, -483,  525, 
-525,  567, -567,  609, -609,  651, -651,    0, 
   0,   65,  -65,  109, -109,  153, -153,  197, 
-197,  241, -241,  285, -285,  329, -329,  373, 
-373,  417, -417,  461, -461,  505, -505,  549, 
-549,  593, -593,  637, -637,  681, -681,    0, 
   0,   69,  -69,  115, -115,  161, -161,  207, 
-207,  253, -253,  299, -299,  345, -345,  391, 
-391,  437, -437,  483, -483,  529, -529,  575, 
-575,  621, -621,  667, -667,  713, -713,    0, 
   0,   71,  -71,  119, -119,  167, -167,  215, 
-215,  263, -263,  311, -311,  359, -359,  407, 
-407,  455, -455,  503, -503,  551, -551,  599, 
-599,  647, -647,  695, -695,  743, -743,    0, 
   0,   75,  -75,  125, -125,  175, -175,  225, 
-225,  275, -275,  325, -325,  375, -375,  425, 
-425,  475, -475,  525, -525,  575, -575,  625, 
-625,  675, -675,  725, -725,  775, -775,    0, 
   0,   77,  -77,  129, -129,  181, -181,  233, 
-233,  285, -285,  337, -337,  389, -389,  441, 
-441,  493, -493,  545, -545,  597, -597,  649, 
-649,  701, -701,  753, -753,  805, -805,    0, 
   0,   81,  -81,  135, -135,  189, -189,  243, 
-243,  297, -297,  351, -351,  405, -405,  459, 
-459,  513, -513,  567, -567,  621, -621,  675, 
-675,  729, -729,  783, -783,  837, -837,    0, 
   0,   83,  -83,  139, -139,  195, -195,  251, 
-251,  307, -307,  363, -363,  419, -419,  475, 
-475,  531, -531,  587, -587,  643, -643,  699, 
-699,  755, -755,  811, -811,  867, -867,    0, 
   0,   87,  -87,  145, -145,  203, -203,  261, 
-261,  319, -319,  377, -377,  435, -435,  493, 
-493,  551, -551,  609, -609,  667, -667,  725, 
-725,  783, -783,  841, -841,  899, -899,    0, 
   0,   89,  -89,  149, -149,  209, -209,  269, 
-269,  329, -329,  389, -389,  449, -449,  509, 
-509,  569, -569,  629, -629,  689, -689,  749, 
-749,  809, -809,  869, -869,  929, -929,    0, 
   0,   93,  -93,  155, -155,  217, -217,  279, 
-279,  341, -341,  403, -403,  465, -465,  527, 
-527,  589, -589,  651, -651,  713, -713,  775, 
-775,  837, -837,  899, -899,  961, -961
};


U32 gTAB_ZZ_RUN[64]= { 0,  1,  8,  16, 9,  2,  3,  10,
                       17, 24, 32, 25, 18, 11, 4,  5,
					   12, 19, 26, 33, 40, 48, 41, 34, 
					   27, 20, 13, 6,  7,  14, 21, 28, 
					   35, 42, 49, 56, 57, 50, 43, 36, 
					   29, 22, 15, 23, 30, 37, 44, 51, 
					   58, 59, 52, 45, 38, 31, 39, 46,
					   53, 60, 61, 54, 47, 55, 62, 63
}
; //input is the cumulative run value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
;// $Header:   S:\h26x\src\dec\d3rtp.h_v   1.4   06 Nov 1996 16:27:40   gmlim  $
;// $Log:   S:\h26x\src\dec\d3rtp.h_v  $
;// 
;//    Rev 1.4   06 Nov 1996 16:27:40   gmlim
;// Removed H263ModeC.
;// 
;//    Rev 1.3   06 Nov 1996 15:17:16   CZHU
;// changed FindNextPacket interface to return MVs.
;// 
;//    Rev 1.2   03 Nov 1996 18:39:08   gmlim
;// Added NEXT_MODE_C.
;// 
;//    Rev 1.1   23 Jul 1996 11:22:42   CZHU
;// 
;// Added a MV recovery. Hursitic will be added in later.
;// 
;//    Rev 1.0   22 Apr 1996 16:44:06   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.7   10 Apr 1996 13:35:30   CZHU
;// 
;// Added subroutine to recover picture header information from extended bitstr
;// 
;//    Rev 1.6   29 Mar 1996 14:40:00   CZHU
;// 
;// cleaning 
;// 
;//    Rev 1.5   29 Mar 1996 13:39:00   CZHU
;// 
;// Moved bs verification to c3rtp.cpp
;// 
;//    Rev 1.4   28 Mar 1996 18:40:18   CZHU
;// Support packet loss recovery
;// 
;//    Rev 1.3   23 Feb 1996 16:21:26   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:01:56   CZHU
;// 
;// More clean up
;// 
;//    Rev 1.1   14 Feb 1996 15:00:20   CZHU
;// Added support Mode A and Mode B
;// 
;//    Rev 1.0   12 Feb 1996 17:05:58   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   11 Dec 1995 14:54:26   CZHU
;// Initial revision.

#ifndef _H263_D3RTP_H_
#define _H263_D3RTP_H_

const long PACKET_FAULT     = ICERR_CUSTOM -1;
const long NEXT_MODE_A      = ICERR_CUSTOM -2;
const long NEXT_MODE_B      = ICERR_CUSTOM -3;
const long NEXT_MODE_C      = ICERR_CUSTOM -4;
const long NEXT_MODE_LAST   = ICERR_CUSTOM -5;

extern  I32 RtpH263FindNextPacket( 
          T_H263DecoderCatalog FAR * , BITSTREAM_STATE FAR * , U32 **, U32 *, int *, int *,I8 *
	    );                      
extern I32 RtpGetPicHeaderFromBsExt(T_H263DecoderCatalog FAR * );
void MVAdjustment(T_BlkAction *,int ,int,  int ,int , int , const int );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3pict.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  d3pict.cpp
 *
 *  Description:
 *		This modules contains the picture header parsing routines
 *
 *	Routines:
 *		H263ReadPictureHeader
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\dec\d3pict.cpv   1.21   05 Feb 1997 12:24:30   JMCVEIGH  $
 * $Log:   S:\h26x\src\dec\d3pict.cpv  $
// 
//    Rev 1.21   05 Feb 1997 12:24:30   JMCVEIGH
// Support for latest H.263+ draft bitstream spec.
// 
//    Rev 1.20   16 Dec 1996 17:42:56   JMCVEIGH
// Existence of extended PTYPE implies improved PB-frame mode if
// a PB-frame. Also, initialized H.263+ optional flags if EPTYPE not
// read.
// 
//    Rev 1.19   11 Dec 1996 14:59:12   JMCVEIGH
// 
// Allow deblocking filter in reading of picture header.
// 
//    Rev 1.18   09 Dec 1996 18:02:10   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.17   31 Oct 1996 10:18:22   KLILLEVO
// changed one (commented out) DBOUT to DbgLog
// 
//    Rev 1.16   20 Oct 1996 15:49:50   AGUPTA2
// Adjusted DbgLog trace levels; 4:Frame, 5:GOB, 6:MB, 8:everything
// 
//    Rev 1.15   20 Oct 1996 14:05:54   AGUPTA2
// Minor change in one of the DbgLog calls.
// 
// 
//    Rev 1.14   20 Oct 1996 13:21:44   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.13   30 May 1996 10:16:32   KLILLEVO
// removed to variables only needed for DEBUG_DECODER
// 
//    Rev 1.12   30 May 1996 10:14:44   KLILLEVO
// removed one debug statement
// 
//    Rev 1.11   24 May 1996 10:47:00   KLILLEVO
// added ifdef _DEBUG arounf wsprintf
// 
//    Rev 1.10   03 May 1996 13:06:36   CZHU
// 
// Check bit 2 for packet loss errors to trigger packet loss recovery
// 
//    Rev 1.9   18 Dec 1995 12:49:54   RMCKENZX
// added copyright notice & log stamp
 */

#include "precomp.h"

/* BIT field Constants
 */
const int BITS_PICTURE_STARTCODE = 22;
#ifdef SIM_OUT_OF_DATE
const int BITS_TR = 5;
#else
const int BITS_TR = 8;
#endif
const int BIT_ONE_VAL = 1;
const int BIT_TWO_VAL = 0;
const int BITS_PTYPE_SOURCE_FORMAT = 3;

#ifdef H263P
// H.263+ draft, document LBC-96-358R3
const int BITS_EPTYPE_RESERVED = 5;
const int EPTYPE_RESERVED_VAL = 1;

const int BITS_CSFMT_PARC  = 4;		// Custom source format pixel aspect ratio code
const int BITS_CSFMT_FWI   = 9;     // Custom source format frame width indication
const int BIT_CSFMT_14_VAL = 1;		// Prevents start code emulation
const int BITS_CSFMT_FHI   = 9;     // Custom source format frame height indication

const int BITS_PAR_WIDTH   = 8;     // Pixel aspect ratio width
const int BITS_PAR_HEIGHT  = 8;		// Pixel aspect ratio height
#endif

const int BITS_PQUANT = 5;
const int BITS_TRB = 3;
const int BITS_DBQUANT = 2;
const int BITS_PSPARE = 8; //not includeing the following PEI

/* PSC_VALUE - 0000 0000 0000 0000 - 1000 00xx xxxx xxxx 
 */
const U32 PSC_VALUE = (0x00008000 >> (32-BITS_PICTURE_STARTCODE));
/* We only want to search so far before it is considered an error 
 */
const int MAX_LOOKAHEAD_NUMBER = 256; /* number of bits */
  
/*****************************************************************************
 *
 * 	H263DecodePictureHeader
 *
 *  Read and parse the picture header - updating the fpbsState if the read
 *	succeeds.
 *
 *  Returns an ICERR_STATUS
 */
extern I32 
H263DecodePictureHeader(
	T_H263DecoderCatalog FAR * DC,
	U8 FAR * fpu8,
	U32 uBitsReady, 
	U32 uWork,
	BITSTREAM_STATE FAR * fpbsState)
{
	I32 iReturn;
	int iLookAhead;
	U32 uResult;
	U32 uData;
	int iSpareCount;

	FX_ENTRY("H263DecodePictureHeader")

	//  PSC ----------------------------------------
	GET_FIXED_BITS((U32) BITS_PICTURE_STARTCODE, fpu8, uWork, uBitsReady, 
				   uResult);
	iLookAhead = 0;
	while (uResult != PSC_VALUE) 
	{
		uResult = uResult << 1;
		uResult &= GetBitsMask[BITS_PICTURE_STARTCODE];
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uData);
		uResult |= uData;
		iLookAhead++;
		if (iLookAhead > MAX_LOOKAHEAD_NUMBER) 
		{
			ERRORMESSAGE(("%s: Missing PSC\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
	}

	GET_FIXED_BITS((U32) BITS_TR, fpu8, uWork, uBitsReady, uResult);
	DC->uTempRefPrev = DC->uTempRef;
	DC->uTempRef = uResult;

	// PTYPE ----------------------------------------
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult != BIT_ONE_VAL) 
	{
		ERRORMESSAGE(("%s: PTYPE bit 1 error\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	if (uResult != BIT_TWO_VAL) 
	{
		ERRORMESSAGE(("%s: PTYPE bit 2 error\r\n", _fx_));
//#ifdef LOSS_RECOVERY
		GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState);
		iReturn = PACKET_FAULT;
//#endif
		goto done;
	}

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bSplitScreen = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bCameraOn = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bFreezeRelease = (U16) uResult;

	GET_FIXED_BITS((U32) BITS_PTYPE_SOURCE_FORMAT, fpu8, uWork, uBitsReady, 
                   uResult);

#ifdef H263P
	// We don't need to check that the frame dimensions are supported here. 
	// This is handled in DecompressQuery() 
	// Custom format is forbidden in PTYPE
	if (uResult == SRC_FORMAT_FORBIDDEN || uResult == SRC_FORMAT_CUSTOM)
	{
		ERRORMESSAGE(("%s: Forbidden src format\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}
#else
#ifdef USE_BILINEAR_MSH26X
	if (uResult == SRC_FORMAT_FORBIDDEN) 
#else
	if (uResult == SRC_FORMAT_FORBIDDEN || uResult > SRC_FORMAT_CIF) 
#endif
	{
		ERRORMESSAGE(("%s: Src format not supported\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}
#endif

	DC->uPrevSrcFormat = DC->uSrcFormat; 
	DC->uSrcFormat = uResult;

#ifdef H263P
	// We don't support changes in the source format between frames. However,
	// if either the current or previous source format in PTYPE indicates
	// extended PTYPE, we do not know if the actual format (i.e., frame size)
	// has changed, yet
	if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat &&
		DC->uSrcFormat != SRC_FORMAT_EPTYPE)
#else
	if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat) 
#endif
	{
		ERRORMESSAGE(("%s: Src format not supported\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

#ifdef H263P
	// The actual source format has not been read if this is the 
	// first frame and we detected an extended PTYPE
	if (DC->bReadSrcFormat || DC->uSrcFormat != SRC_FORMAT_EPTYPE)
		// We have read the actual source format, so mark flag as true.
		DC->bReadSrcFormat = 1;
#else
		DC->bReadSrcFormat = 1;
#endif

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bKeyFrame = (U16) !uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bUnrestrictedMotionVectors = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bArithmeticCoding = (U16) uResult;

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bAdvancedPrediction = (U16) uResult;
	// If bit 12 is set to "1", bit 10 shall be set to "1" as well. (5.1.3 p14)
	/* if (DC->bAdvancedPrediction && !DC->bUnrestrictedMotionVectors) {
	ERRORMESSAGE(("%s: Warning: bit 12 is one and bit 10 is zero\r\n", _fx_));
	iReturn = ICERR_ERROR;
	goto done;
	} */

	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bPBFrame = (U16) uResult;
	// If bit 9 is set to "0", bit 13 shall be set to "0" as well." (5.1.3 p11)
	if (DC->bKeyFrame && DC->bPBFrame) 
	{
		ERRORMESSAGE(("%s: A key frame can not be a PB frame\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

#ifdef H263P
	// EPTYPE --------------------------------------
	if (DC->uSrcFormat == SRC_FORMAT_EPTYPE)
	{
		// Extended PTYPE detected in PTYPE. 

		// We need to read the source format (again) and the optional mode flags.
		GET_FIXED_BITS((U32) BITS_PTYPE_SOURCE_FORMAT, fpu8, uWork, uBitsReady,
					    uResult);
		if (uResult == SRC_FORMAT_FORBIDDEN || uResult == SRC_FORMAT_RESERVED)
		{
			ERRORMESSAGE(("%s: Forbidden or reserved src format\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		DC->uSrcFormat = uResult;		// DC->uPrevSrcFormat has already been saved

		// Check to make sure that the picture size has not changed between frames.
		if (DC->bReadSrcFormat && DC->uPrevSrcFormat != DC->uSrcFormat)
		{
			ERRORMESSAGE(("%s: Src format changed\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
		DC->bReadSrcFormat = 1;		// The actual source format has finally been read

		// Optional modes:

		// Custom PCF ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bCustomPCF = (U16) uResult;
		if (DC->bCustomPCF)
		{
			ERRORMESSAGE(("%s: Custom PCF not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Advanced intra coding ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bAdvancedIntra = (U16) uResult;
		if (DC->bAdvancedIntra)
		{
			ERRORMESSAGE(("%s: Advanced intra coding not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Deblocking filter ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bDeblockingFilter = (U16) uResult;

		// Slice structured ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bSliceStructured = (U16) uResult;
		if (DC->bSliceStructured)
		{
			ERRORMESSAGE(("%s: Slice structured mode not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Improved PB-frames ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bImprovedPBFrames = (U16) uResult;

		// Back channel operation ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bBackChannel = (U16) uResult;
		if (DC->bBackChannel)
		{
			ERRORMESSAGE(("%s: Back-channel operation not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Scalability ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bScalability = (U16) uResult;
		if (DC->bScalability)
		{
			ERRORMESSAGE(("%s: Scalability mode not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// True B-frame mode ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bTrueBFrame = (U16) uResult;
		if (DC->bTrueBFrame)
		{
			ERRORMESSAGE(("%s: True B-frames not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Reference-picture resampling ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bResampling = (U16) uResult;
		if (DC->bResampling)
		{
			ERRORMESSAGE(("%s: Reference-picture resampling not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Reduced-resolution update ---------------------------------------
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		DC->bResUpdate = (U16) uResult;
		if (DC->bResUpdate)
		{
			ERRORMESSAGE(("%s: Reduced resolution update not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Resevered bits
		GET_FIXED_BITS((U32) BITS_EPTYPE_RESERVED, fpu8, uWork, uBitsReady, uResult);
		if (uResult != EPTYPE_RESERVED_VAL)
		{
			ERRORMESSAGE(("%s: Invalid reserved code in EPTYPE\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}
	} // end if (DC->uSrcFormat == SRC_FORMAT_EPTYPE)
	else	// end if (DC->uSrcFormat == SRC_FORMAT_EPTYPE)
	{
		// We might never read these optional flags, so set them to
		// false if not extended PTYPE
		DC->bImprovedPBFrames = FALSE;
		DC->bAdvancedIntra = FALSE;
		DC->bDeblockingFilter = FALSE;
		DC->bSliceStructured = FALSE;
		DC->bCustomPCF = FALSE;
		DC->bBackChannel = FALSE;
		DC->bScalability = FALSE;
		DC->bTrueBFrame = FALSE;
		DC->bResampling = FALSE;
		DC->bResUpdate = FALSE;
	}

	// CSFMT --------------------------------------
	if (DC->uSrcFormat == SRC_FORMAT_CUSTOM)
	{
		// Custom source format detected. We need to read the aspect ratio
		// code and the frame width and height indications.

		// Pixel aspect ratio code
		GET_FIXED_BITS((U32) BITS_CSFMT_PARC, fpu8, uWork, uBitsReady, uResult);
		U16 uPARC = (U16)uResult;

		// Frame width indication
		GET_FIXED_BITS((U32) BITS_CSFMT_FWI, fpu8, uWork, uBitsReady, uResult);
		// The number of pixels per line is given by (FWI+1)*4. We do not
		// support cases where the picture width differs from that given in the
		// DC->uActualFrameWidth parameter.
		if (DC->uActualFrameWidth != ((uResult + 1) << 2))
		{
			ERRORMESSAGE(("%s: Frame width change not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Bit 13 must be "1" to prevent start code emulation
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		if (uResult != BIT_CSFMT_14_VAL)
		{
			ERRORMESSAGE(("%s: CSFMT bit 13 != 1\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		// Frame height indication
		GET_FIXED_BITS((U32) BITS_CSFMT_FHI, fpu8, uWork, uBitsReady, uResult);
		// The number of lines is given by (FHI+1)*4. We do not
		// support cases where the picture height differs from that given in the
		// DC->uActualFrameHeight parameter.
		if (DC->uActualFrameHeight != ((uResult + 1) << 2))
		{
			ERRORMESSAGE(("%s: Frame height change not supported\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

		switch (uPARC) {
		case PARC_SQUARE:
			DC->uPARWidth = 1;
			DC->uPARHeight = 1;
			break;
		case PARC_CIF:
			DC->uPARWidth = 12;
			DC->uPARHeight = 11;
			break;
		case PARC_10_11:
			DC->uPARWidth = 10;
			DC->uPARHeight = 11;
			break;
		case PARC_EXTENDED:
			GET_FIXED_BITS((U32) BITS_PAR_WIDTH, fpu8, uWork, uBitsReady, uResult);
			DC->uPARWidth = uResult;
			if (DC->uPARWidth == 0) 
			{
				ERRORMESSAGE(("%s: Forbidden pixel aspect ratio width\r\n", _fx_));
				iReturn = ICERR_ERROR;
				goto done;
			}
			GET_FIXED_BITS((U32) BITS_PAR_HEIGHT, fpu8, uWork, uBitsReady, uResult);
			DC->uPARHeight = uResult;
			if (DC->uPARHeight == 0) 
			{
				ERRORMESSAGE(("%s: Forbidden pixel aspect ratio height\r\n", _fx_));
				iReturn = ICERR_ERROR;
				goto done;
			}
			break;
		default:
			ERRORMESSAGE(("%s: Unsupported pixel aspect ratio code\r\n", _fx_));
			iReturn = ICERR_ERROR;
			goto done;
		}

	} // end if (DC->uSrcFormat == SRC_FORMAT_CUSTOM)

#endif // H263P

	// PQUANT --------------------------------------
	GET_FIXED_BITS((U32) BITS_PQUANT, fpu8, uWork, uBitsReady, uResult);
	DC->uPQuant = uResult;

	// CPM -----------------------------------------
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	DC->bCPM = (U16) uResult;
	if (DC->bCPM) 
	{
		ERRORMESSAGE(("%s: Continuous Presence Multipoint is not supported\r\n", _fx_));
		iReturn = ICERR_ERROR;
		goto done;
	}

	// PLCI ----------------------------------------
	if (DC->bCPM) 
	{
		//  TBD("TBD: PLCI");
		iReturn = ICERR_ERROR;
		goto done;
	}

	if (DC->bPBFrame) 
	{
		GET_FIXED_BITS((U32) BITS_TRB, fpu8, uWork, uBitsReady, uResult);
		DC->uBFrameTempRef = uResult;

		GET_FIXED_BITS((U32) BITS_DBQUANT, fpu8, uWork, uBitsReady, uResult);
		DC->uDBQuant = uResult;
	} 
	else 
	{
		DC->uBFrameTempRef = 12345678; /* clear the values */
		DC->uDBQuant = 12345678;
	}

	//  skip spare bits
	iSpareCount = 0;
	GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
	while (uResult) 
	{
		GET_FIXED_BITS((U32) BITS_PSPARE, fpu8, uWork, uBitsReady, uResult);
		GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult);
		iSpareCount += BITS_PSPARE;
	}

	DEBUGMSG(ZONE_DECODE_PICTURE_HEADER, ("%s: TR=%ld SS=%d CAM=%d FRZ=%d SRC=%ld PCT=%d UMV=%d AC=%d AP=%d PB=%d CPM=%d PQ=%ld TRB=%ld DBQ=%ld Spare=%d\r\n", _fx_, DC->uTempRef, DC->bSplitScreen, DC->bCameraOn, DC->bFreezeRelease, DC->uSrcFormat, !DC->bKeyFrame, DC->bUnrestrictedMotionVectors, DC->bArithmeticCoding, DC->bAdvancedPrediction, DC->bPBFrame, DC->bCPM, DC->uPQuant, DC->uBFrameTempRef, DC->uDBQuant, iSpareCount));

#ifdef H263P
	DEBUGMSG(ZONE_DECODE_PICTURE_HEADER, ("%s: DF=%d TB=%d\r\n", _fx_, DC->bDeblockingFilter, DC->bTrueBFrame));

	if (DC->uSrcFormat == SRC_FORMAT_CUSTOM)
	{
		DEBUGMSG(ZONE_DECODE_PICTURE_HEADER, ("%s: PARW=%ld PARH=%ld FWI=%ld FHI=%ld\r\n", _fx_, DC->uPARWidth, DC->uPARHeight, (DC->uActualFrameWidth >> 2) - 1, (DC->uActualFrameHeight >> 2) - 1));
	}
#endif // H263P

	GET_BITS_SAVE_STATE(fpu8, uWork, uBitsReady, fpbsState);
	iReturn = ICERR_OK;

done:
	return iReturn;
} /* end H263DecodePictureHeader() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\d3tables.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:36:16  $
// $Archive:   S:\h26x\src\dec\d3tables.h_v  $
// $Header:   S:\h26x\src\dec\d3tables.h_v   1.4   27 Dec 1995 14:36:16   RMCKENZX  $
// $Log:   S:\h26x\src\dec\d3tables.h_v  $
;// 
;//    Rev 1.4   27 Dec 1995 14:36:16   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.3   16 Aug 1995 14:25:44   CZHU
// 
// Changed inverse quantization table to I16
// 
//    Rev 1.2   11 Aug 1995 15:50:26   CZHU
// Moved the tables to d3tables.cpp, leave only extern defs.
// 
//    Rev 1.1   02 Aug 1995 11:47:04   CZHU
// 
// Added table for inverse quantization and RLD-ZZ
// 
//    Rev 1.0   31 Jul 1995 15:46:20   CZHU
// Initial revision.

//Initialize global tables shared by all decoder instances:
//Huffman tables, etc
//declare the global static tables here
#ifndef _GLOBAL_TABLES_
#define _GLOBAL_TABLES_

extern U16 gTAB_MCBPC_INTRA[512];   //total 1024

extern U16 gTAB_MCBPC_INTER[512];   //total 1024

extern U16 gTAB_CBPY_INTRA[64];		//total 128

extern U16 gTAB_CBPY_INTER[64];	    //total 128

extern U16 gTAB_MVD_MAJOR[256];     //total 512

extern U32 gTAB_TCOEFF_MAJOR[256];  //total 1024

extern U16 gTAB_MVD_MINOR[256];     //total 512

extern U32 gTAB_TCOEFF_MINOR[1024]; //total 4096

extern I16 gTAB_INVERSE_Q[1024] ;


extern U32 gTAB_ZZ_RUN[64]; //input is the cumulative run value
                     //returns the offset to the starting address of the block
					 //total at 256
  					   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxap.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
// $Header:   S:\h26x\src\dec\dxap.cpv   1.4   20 Oct 1996 13:22:12   AGUPTA2  $
//
// $Log:   S:\h26x\src\dec\dxap.cpv  $
// 
//    Rev 1.4   20 Oct 1996 13:22:12   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.3   27 Aug 1996 11:20:06   KLILLEVO
// changed GlobalAlloc/GLobalLock to HeapAlloc
// 
//    Rev 1.2   27 Dec 1995 14:36:10   RMCKENZX
// Added copyright notice
// 
//    Rev 1.1   10 Nov 1995 14:45:02   CZHU
// 
// 
//    Rev 1.0   10 Nov 1995 13:54:28   CZHU
// Initial revision.

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
char gsz4[32];
char gsz5[32];
#endif

U8 gUTable[256] =
{
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,
42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,
128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,
136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,
138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,
160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,
162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,
168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,
170,170,170,170,170,170,170,170,170,170,170,170,170,170,170
};

U8 gVTable[256]=
{
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,65,
68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,68,
69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,
80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,80,
81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,81,
84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,84,
85,85,85,85,85,85,85,85,85,85,85,85,85,85,85,85

};

/***************************************************************************
 * ComputeDymanicClut() computes the clut tables on the fly, based on the  *
 * current palette[];                                                      *
 * called from InitColorConvertor, when CLUTAP is selected                 *
 ***************************************************************************/
LRESULT ComputeDynamicClutNew(U8 *pAPTable, 
                              U8 *pActivePalette, 
                              int iPalSize)
{  

	/* 
	* The dynamic clut consists of 4 entries which MUST be
	* contiguous in memory:
	*
	*    ClutTable: 65536 1-byte entries
	*               Each entry is the closest pPalette entry, as
	*               indexed by a 14 bit value: uvuvuvuv0yyyyyyy,
	*               dithered
	*
	*    TableU:    256   4-byte entries
	*               Each entry is u0u0u0u0:u0u0u0u0:u0u0u0u0:u0u0u0u0,
	*               each uuuu is a 4 bit dithered u value for the
	*               index, which is a u value in the range 8-120
	*
	*    TableV:    256   4-byte entries
	*               Same as TableU, except the values are arranged
	*               0v0v0v0v:0v0v0v0v:0v0v0v0v:0v0v0v0v.
	*/

	Color   *pPalette;
	U8 *pTmpPtr; 
	U8  pYSlice[YSIZ][256],  *pYYPtr;
	I32 *pYCnt;
	U32 *pDiff, *dptr, *delta, *deptr;
	I32 i,j,yseg,y,u,v,mini,yo,uo,vo,ycount,yi; 
	U32 addr1,addr2,ind;
	U32 d,min;     // since 3*128^2 = 49K
	PALETTEENTRY   *lpPal,   *palptr;
	Color   *colptr;
	I32 Y, U, V;
	I32 U_0, U_1, U_2, U_3;
	I32 V_0, V_1, V_2, V_3;
   
	I32 Umag, Vmag;
	/* dist max is 128*128*3 = 49152 */
	U32 dist;
	U32 close_dist[MAG_NUM_NEAREST];
	I32 palindex;
	I32 R, G, B;
	I32 k, p, tmp, iu, iv;
	/* Ubias and Vbias max is (128 * 4 * BIAS_PAL_SAMPLES) = 65536 */
	/* even the worst palette (all black except the reserved colors) */
	/* would not achieve this. */
	I32 Ubias, Vbias;
	U32 Udither, Vdither;
	U32 *TableUptr,  *TableVptr;

	FX_ENTRY("ComputeDynamicClutNew")	

	DEBUGMSG(ZONE_DECODE_DETAILS, ("%s: ComputeDynamic CLUT8 index tables\r\n", _fx_));

	/* allocate some memory */
	pPalette = (Color *)HeapAlloc(GetProcessHeap(), NULL, sizeof(Color)*256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "DXAP: %7ld Ln %5ld\0", sizeof(Color)*256, __LINE__);
	AddName((unsigned int)pPalette, gsz1);
#endif

	pYCnt    = (I32 *)  HeapAlloc(GetProcessHeap(), NULL, sizeof(I32)  *YSIZ);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz2, "DXAP: %7ld Ln %5ld\0", sizeof(I32)  *YSIZ, __LINE__);
	AddName((unsigned int)pYCnt, gsz2);
#endif

	pDiff    = (U32 *)  HeapAlloc(GetProcessHeap(), NULL, sizeof(U32)  *256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz3, "DXAP: %7ld Ln %5ld\0", sizeof(U32)  *256, __LINE__);
	AddName((unsigned int)pDiff, gsz3);
#endif

	delta    = (U32 *)  HeapAlloc(GetProcessHeap(), NULL, sizeof(U32)  *256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz4, "DXAP: %7ld Ln %5ld\0", sizeof(U32)  *256, __LINE__);
	AddName((unsigned int)delta, gsz4);
#endif

	lpPal    = (PALETTEENTRY *)HeapAlloc(GetProcessHeap(), NULL, sizeof(PALETTEENTRY)*256);

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz5, "DXAP: %7ld Ln %5ld\0", sizeof(PALETTEENTRY)*256, __LINE__);
	AddName((unsigned int)lpPal, gsz5);
#endif

	if (!pPalette || !pYCnt || !pDiff || !delta || !lpPal)
		return (ICERR_MEMORY);

	for (i=-256; i<256; i++)
		squares[256+i] = i*i;

	memcpy((U8 *)lpPal, pActivePalette, iPalSize);

    palptr = lpPal;
    colptr = pPalette;
    for (i = 0; i < 256; i++) {
		/* In BGR (RGBQuad) order. */
	 B = palptr->peRed;
	 G = palptr->peGreen;
	 R = palptr->peBlue; 
	 
	 colptr->y = YFROM(R, G, B);
	 colptr->u = UFROM(R, G, B);
	 colptr->v = VFROM(R, G, B);
	palptr++;
	colptr++;
    }

	for (i=0; i<YSIZ; i++)
		pYCnt[i] = 0;

	for (i=0; i<256; i++)
	{
		yseg = pPalette[i].y >> 4;
		pYSlice[yseg][ pYCnt[yseg]++ ] = (U8) i;
	}


// Do exhaustive search on all U,V points and a coarse grid in Y

	for (u=0; u<256; u+=UVSTEP)
	{
		for (v=0; v<256; v+=UVSTEP)
		{
			ind = TBLIDX(0,u,v);
			pTmpPtr = pAPTable+ind;
			for (y=0; y<256; y+=YSTEP)
			{
				colptr = pPalette;
				min = 0x0FFFFFFF;
				for (i=0; i<NCOL; i++, colptr++)
				{
					d = (3*squares[256+y - colptr->y])>>1;
					if (d > min)
						continue;
					
					d += squares[256+u - colptr->u];
					if (d > min)
						continue;

					d += squares[256+v - colptr->v];
					if (d < min)
					{
						min = d;
						mini = i;
					}
				}
				*pTmpPtr = (U8) mini;  
			    pTmpPtr += YSTEP;

			}
		}
	}
#ifdef STATISTICS
#if defined USE_STAT_BOARD
	dwStopTime = ReadElapsed()>>2;
#else
	dwStopTime = bentime();
#endif /* USE_STAT_BOARD */
	dwElapsedTime = dwStopTime - dwStartTime2 - dwOverheadTime;
	DPF("CoarseSearch() time = %lu microseconds",dwElapsedTime);
#endif

// Go thru points not yet done, and search
//  (1) The closest point to the prev and next Y in coarse grid
//  (2) All the points in this Y slice
//
// Also, take advantage of the fact that we can do distance computation
// incrementally.  Keep all N errors in an array, and update each
// time we change Y.


	for (u=0; u<256; u+=UVSTEP)
	{
		for (v=0; v<256; v+=UVSTEP)
		{
			for (y=YGAP; y<256; y+=YSTEP)
			{
				yseg = y >> 4;
				ycount = pYCnt[yseg] + 2;  // +2 is 'cause we add 2 Y endpoints

				pYYPtr = (U8   *)pYSlice[yseg];
				
				addr1 = TBLIDX(yseg*16,u,v);
				pYYPtr[ycount-2] = *(U8 *)(pAPTable +addr1);

				addr2 = TBLIDX((yseg+(yseg < (YSIZ -1)))*16,u,v);
				pYYPtr[ycount-1] = *(U8 *)(pAPTable +addr2);

				dptr  = pDiff;
				deptr = delta;
				for (i=0; i<ycount; i++, pYYPtr++, dptr++, deptr++)
				{
					j = *pYYPtr; /* pYSlice[yseg][i]; */
					colptr = pPalette+j;
					yo = colptr->y;
					uo = colptr->u;
					vo = colptr->v;
					*dptr = ( 3*squares[256+y-yo] + 2*(squares[256+u-uo] + squares[256+v-vo]));
					*deptr =( 3*(((y-yo)<<1) + 1));
				}

				ind = TBLIDX(y,u,v);
				pTmpPtr = pAPTable+ind;
				for (yi=0; yi<YSTEP-1; yi += YGAP)
				{
					min = 0x0FFFFFFF;
					pYYPtr = (U8 *)pYSlice[yseg];
					dptr  = pDiff;
					deptr = delta;
					for (i=0; i<ycount; i++, pYYPtr++, dptr++, deptr++)
					{
						if (*dptr < min)
						{
							min = *dptr;
							mini = *pYYPtr; /* pYSlice[yseg][i]; */
						}
						*dptr += *deptr;
						*deptr += 6;
					}
					*pTmpPtr = (U8) mini;
					pTmpPtr++;

				}
			}
		}
	}

       /* now do U and V dither tables and shift lookup table*/
       /* NOTE: All Y, U, V values are 7 bits */

	Umag = Vmag = 0;
	Ubias = Vbias = 0;

	/* use srand(0) and rand() to generate a repeatable series of */
	/* pseudo-random numbers */
	srand((unsigned)1);
	
	for (p = 0; p < MAG_PAL_SAMPLES; ++p)               // 32
	{
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)            // 6
	   {
	      close_dist[i] = 0x7FFFL;
	   }
	    
	   palindex = RANDOM(235) + 10; /* random palette index, unreserved colors */
	   colptr = &pPalette[palindex];
	   Y = colptr->y;
	   U = colptr->u;
	   V = colptr->v;
	    
	   colptr = pPalette;
	   for (i = 0; i < 255; ++i)
	   {
	      if (i != palindex)
	      {
		   dist = squares[256+(Y - colptr->y)] +
			      squares[256+(U - colptr->u)] +
			      squares[256+(V - colptr->v)];
	       
		 /* keep a sorted list of the nearest MAG_NUM_NEAREST entries */
		 for (j = 0; j < MAG_NUM_NEAREST; ++j)         //6
		 {
		    if (dist < close_dist[j])
		    {
		       /* insert new entry; shift others down */
		       for (k = (MAG_NUM_NEAREST-1); k > j; k--)
		       {
			      close_dist[k] = close_dist[k-1];
		       }
		       close_dist[j] = dist;
		       break; /* out of for j loop */
		    }
		 } /* for j */
	      } /* if i */
	      ++colptr;
	   } /* for i */
	   
	   /* now calculate Umag as the average of (U - U[1-6]) */
	   /* calculate Vmag in the same way */
	   
	   for (i = 0; i < MAG_NUM_NEAREST; ++i)
	   {
	      /* there are (MAG_PAL_SAMPLES * MAG_NUM_NEAREST) sqrt() */
	      /* calls in this method */
	      Umag += (I32)sqrt((double)close_dist[i]);
	   }
	} /* for p */

	Umag /= (MAG_NUM_NEAREST * MAG_PAL_SAMPLES);
	Vmag = Umag;
	
	for (p = 0; p < BIAS_PAL_SAMPLES; ++p)            //132
	{

		/* now calculate the average bias (use random RGB points) */
		R = RANDOM(255);
		G = RANDOM(255);
		B = RANDOM(255);
	   
		Y = YFROM(R, G, B);
		U = UFROM(R, G, B);
		V = VFROM(R, G, B);
	   
		for (d = 0; d < 4; d++)   
		{
			U_0 = U + (dither[d].Udither*Umag)/3;
			V_0 = V + (dither[d].Vdither*Vmag)/3;
	      
			/* Clamp values */
			if (U_0 > 255) U_0 = 255;
			if (V_0 > 255) V_0 = 255;
					
			/* (Y, U_0, V_0) is the dithered YUV for the RGB point */
			/* colptr points to the closest palette entry to the dithered */
			/* RGB */
			/* colptr = &pPalette[pAPTable[TBLIDX(Y, U_0+(UVSTEP>>1), V_0+(UVSTEP>>1))]]; */
		    pTmpPtr= (U8 *)(pAPTable + (U32)TBLIDX(Y, U_0, V_0)) ;
		    palindex=*pTmpPtr;
		    colptr = &pPalette[palindex];
      
			Ubias +=  (U - colptr->u);
			Vbias +=  (V - colptr->v);
		}
	} /* for p */
	
	Ubias =(I32) (Ubias+BIAS_PAL_SAMPLES*2)/(I32)(BIAS_PAL_SAMPLES * 4);
	Vbias =(I32) (Vbias+BIAS_PAL_SAMPLES*2)/(I32)(BIAS_PAL_SAMPLES * 4);
	


    U_0 = (2*(I32)Umag/3); V_0 = (1*(I32)Vmag/3);
    U_1 = (1*(I32)Umag/3); V_1 = (2*(I32)Vmag/3);
    U_2 = (0*(I32)Umag/3); V_2 = (3*(I32)Vmag/3);
    U_3 = (3*(I32)Umag/3); V_3 = (0*(I32)Vmag/3);

    TableUptr = (U32 *)(pAPTable+ (U32)65536L);
    TableVptr = TableUptr + 256;    
       
    iu = Ubias /* + (UVSTEP>>1) */;
    iv = Vbias /* + (UVSTEP>>1) */;

    for (i = 0; i < 256; i++, iu++, iv++)
    {
	 /* dither: u0u0u0u0, 0v0v0v0v */
	 tmp = iu + U_0; 
	 Udither  = gUTable[CLAMP8(tmp)]; 
	 Udither <<= 8; 
	 tmp = iu + U_1; 
	 Udither |= gUTable[CLAMP8(tmp)]; Udither <<= 8; tmp = iu      ; 
	 Udither |= gUTable[CLAMP8(tmp)]; Udither <<= 8; tmp = iu + U_3; 
	 Udither |= gUTable[CLAMP8(tmp)];
	 *TableUptr++ = Udither ; 
	  
	 tmp = iv + V_0; 
	 Vdither  = gVTable[CLAMP8(tmp)]; 
	 Vdither <<= 8;
	 tmp = iv + V_1; Vdither |= gVTable[CLAMP8(tmp)]; Vdither <<= 8;
	 tmp = iv + V_2; Vdither |= gVTable[CLAMP8(tmp)]; Vdither <<= 8;
	 tmp = iv      ; Vdither |= gVTable[CLAMP8(tmp)];                /* V_3 == 0 */ 
	 *TableVptr++ = Vdither; 

    }

	//adjust color for 0--8 and 120-128 for luma
	// 0--16, 241-255 plus dither for chroma

    TableUptr = (U32 *)(pAPTable+ (U32)65536L);
    TableVptr = TableUptr + 256;    
	for (i=0; i<16;i++)
	{
	  TableUptr[i]= TableUptr[16];
	  TableVptr[i]= TableVptr[16];
	}

	for (i=241;i<256;i++)
	{
	  TableUptr[i]= TableUptr[240];
	  TableVptr[i]= TableVptr[240];
	}

	for (u = 0; u < 256; u += UVSTEP) {
	 for (v = 0; v < 256; v += UVSTEP) {
		pTmpPtr= (U8 *)(pAPTable + (U32)TBLIDX(16, u, v)) ;
		mini = *pTmpPtr;

		for (y = Y_DITHER_MIN; y < 16; y += 2) 
		{
			pTmpPtr--;
			*pTmpPtr = (U8)mini;
		}

		pTmpPtr= (U8 *)(pAPTable + (U32)TBLIDX(240, u, v)) ;
		mini = *pTmpPtr;

		for (y = 241; y < 256+Y_DITHER_MAX; y +=2)
		{
			pTmpPtr++;
			*pTmpPtr = (U8)mini;
		}
	 } /* for v... */
	} /* for u... */


	/* free memory allocated */
	HeapFree(GetProcessHeap(), NULL, pPalette);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)pPalette);
#endif
	HeapFree(GetProcessHeap(), NULL, pYCnt);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)pYCnt);
#endif
	HeapFree(GetProcessHeap(), NULL, pDiff);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)pDiff);
#endif
	HeapFree(GetProcessHeap(), NULL, delta);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)delta);
#endif
	HeapFree(GetProcessHeap(), NULL, lpPal);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpPal);
#endif

	return (ICERR_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxblkadd.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   30 Aug 1996 08:39:58  $
// $Archive:   S:\h26x\src\dec\dxblkadd.cpv  $
// $Header:   S:\h26x\src\dec\dxblkadd.cpv   1.7   30 Aug 1996 08:39:58   KLILLEVO  $
// $Log:   S:\h26x\src\dec\dxblkadd.cpv  $
// 
//    Rev 1.7   30 Aug 1996 08:39:58   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.6   17 Jul 1996 15:33:56   AGUPTA2
// Increased the size of clamping table ClampTbl to 128+256+128.
// 
//    Rev 1.5   08 Mar 1996 16:46:32   AGUPTA2
// Moved the ClampTbl to be common between this module and IDCT.  Reduced
// the size of the ClampTbl from 256+256+256 to 64+256+64.  IDCT INTER coeffs
// are biased by 1024 and is taken care of when accessing ClampTbl.  Added
// pragma code_seg to place the rtn in Pass 2 code segment.
// 
// 
//    Rev 1.4   22 Dec 1995 13:52:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.3   25 Sep 1995 09:03:36   CZHU
// Added comments on cycle counts
// 
//    Rev 1.2   13 Sep 1995 08:46:44   AKASAI
// Set loopcounter back to 8.  Intermediate is 8x8 of DWORDS so TEMPPITCH4
// should be 32 not 64.
// 
//    Rev 1.1   12 Sep 1995 18:19:20   CZHU
// 
// Changed loop from 8 to 7 to start with.
// 
//    Rev 1.0   11 Sep 1995 16:52:20   CZHU
// Initial revision.


// -------------------------------------------------------------------------
// T is routine performs a block(8 8) addition.
//       output = clamp[reference + current]
//
// Input I32 *current (output of FMIDCT)
//       U8  *reference (Motion Compensated address of reference)
//       U8  *output  (Output buffer)
//
// Assumption:  reference and output use PITCH  
//              current  as some other pitch 
// -------------------------------------------------------------------------

#include "precomp.h"

#define TEMPPITCH4 32

#pragma data_seg("IADATA2")
#define FRAMEPOINTER		esp
#define L_LOOPCOUNTER    	FRAMEPOINTER	+    0	// 4 byte
#define LOCALSIZE		    4		                // keep aligned

#pragma code_seg("IACODE2") 
__declspec(naked)
void BlockAdd (U32 uResidual, U32 uRefBlock,U32 uDstBlock)
{		
__asm {
	push  ebp			         // save callers frame pointer
	mov	ebp,esp		             // make parameters accessible 
    push  esi			         // assumed preserved 
	push  edi			
    push  ebx 			
	sub	esp,LOCALSIZE	          // reserve local storage 

  mov     edi, uDstBlock         ;// edi gets Base addr of OutputBuffer
      mov   ecx, 8
    mov     esi, uRefBlock;      ;// esi gets Base addr of Current
      mov   ebp, uResidual       ;// ebp gets Base addr of Reference
    mov     ebx, [edi]           ;// pre-fetch output
      xor   eax, eax             

// Cylces counts: 26 x 8=208 without cache miss
//                czhu, 9/25/95
loop_for_i:
    mov     [L_LOOPCOUNTER], ecx        ; save loop counter in temporary
      mov   ebx, [ebp+8]                ; 1) fetch current[i+2]
    mov     al, BYTE PTR[esi+2]         ; 1) fetch ref[i+2]
      xor   ecx, ecx                    ; 2)
    mov     cl, BYTE PTR[esi+3]         ; 2) fetch ref[i+3]
      mov   edx, [ebp+12]               ; 2) fetch current[i+3]
    add     eax, ebx                    ; 1) result2 = ref[i+2] + current[i+2]
      xor   ebx, ebx                    ; 3)
    add     ecx, edx                    ; 2) result3= ref[i+3] + current[i+3]
      mov   bl, BYTE PTR[esi+0]         ; 3) fetch ref[i]
    mov     dl, ClampTbl[CLAMP_BIAS+eax-1024]  ; 1) fetch clamp[result2]
      mov   eax, [ebp+0]                ; 3) fetch current[i]
    add     ebx, eax                    ; 3) result0 = ref[i] + current[i]
      xor   eax, eax                    ; 4)
    mov     dh, ClampTbl[CLAMP_BIAS+ecx-1024]  ; 2) fetch clamp[result3]
      mov   al, [esi+1]                 ; 4) fetch ref[i+1]
    shl     edx, 16                     ; move 1st 2 results to high word
      mov   ecx, [ebp+4]                ; 4) fetch current[i+1]
    mov     dl, ClampTbl[CLAMP_BIAS+ebx-1024]  ; 3) fetch clamp[result0]
      add   eax, ecx                    ; 4) result1 = ref[i+1] + current[i+1]
    xor     ecx, ecx                    ; 4+1)
      mov   ebx, [ebp+24]               ; 4+1) fetch current[i+6]
    mov     dh, ClampTbl[CLAMP_BIAS+eax-1024]  ; 4) fetch clamp[result1]
      mov   cl, BYTE PTR[esi+6]         ; 4+1) fetch ref[i+6]
    mov     [edi], edx                  ; store 4 output pixels
      xor   eax, eax                    ; 4+2)
    mov     al, BYTE PTR[esi+7]         ; 4+2) fetch ref[i+7]
      mov   edx, [ebp+28]               ; 4+2) fetch current[i+7]
    add     ecx, ebx                    ; 4+1) result6 = ref[i+6] + current[i+6]
      xor   ebx, ebx                    ; 4+3)
    add     eax, edx                    ; 4+2) result7= ref[i+7] + current[i+7]
      mov   bl, BYTE PTR[esi+4]         ; 4+3) fetch ref[i+4]
    mov     dl, ClampTbl[CLAMP_BIAS+ecx-1024]  ; 4+1) fetch clamp[result6]
      mov   ecx, [ebp+16]               ; 4+3) fetch current[i+4]
    add     ebx, ecx                    ; 4+3) result4 = ref[i+4] + current[i+4]
      xor   ecx, ecx                    ; 4+4)
    mov     dh, ClampTbl[CLAMP_BIAS+eax-1024]  ; 4+2) fetch clamp[result7]
      mov   cl, [esi+5]                 ; 4+4) fetch ref[i+5]
    shl     edx, 16                     ; move 3rd 2 results to high word
      mov   eax, [ebp+20]               ; 4+4) fetch current[i+5]
    add     ecx, eax                    ; 4+4) result5 = ref[i+5] + current[i+5]
      add   esi, PITCH                  ; Update address of next line
    mov     dl, ClampTbl[CLAMP_BIAS+ebx-1024]  ; 4+3) fetch clamp[result4]
      add   ebp, TEMPPITCH4             ; Update address of current to next line
    mov     dh, ClampTbl[CLAMP_BIAS+ecx-1024]  ; 4+4) fetch clamp[result5]
      mov   ecx, [L_LOOPCOUNTER]        ; get loop counter
    mov     [edi+4], edx                ; store 4 output pixels
      add   edi, PITCH                  ; Update address of output to next line
    xor     eax, eax                    ; 1)
      dec   ecx
    mov     ebx, [edi]                  ; pre-fetch output
      jnz   loop_for_i


	add esp,LOCALSIZE	           // free locals 
    pop	ebx 
	 pop edi
	pop	esi
	 pop ebp
	ret   
  }	 //end of asm

}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxblkcpy.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995, 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   AGUPTA2  $
// $Date:   08 Mar 1996 16:46:34  $
// $Archive:   S:\h26x\src\dec\dxblkcpy.cpv  $
// $Header:   S:\h26x\src\dec\dxblkcpy.cpv   1.4   08 Mar 1996 16:46:34   AGUPTA2  $
// $Log:   S:\h26x\src\dec\dxblkcpy.cpv  $
// 
//    Rev 1.4   08 Mar 1996 16:46:34   AGUPTA2
// Rewritten to reduce code size by avoiding 32-bit displacements.  Added
// pragma code_seg.  May need to optimize for misaligned case.
// 
// 
//    Rev 1.3   31 Jan 1996 13:15:14   RMCKENZX
// Rewrote file to avoid bank conflicts.  Fully unrolled the loop.
// Module now really will execute in 52 cycles if the cache is hot.
// 
//    Rev 1.2   22 Dec 1995 13:51:06   KMILLS
// added new copyright notice
// 
//    Rev 1.1   25 Sep 1995 09:03:22   CZHU
// Added comments on cycle counts
// 
//    Rev 1.0   11 Sep 1995 16:52:26   CZHU
// Initial revision.
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//
// Note:
//	-	BlockCopy reads and writes in DWORDS.
//	-	The __fastcall convention is used.
//	-	Code re-written to minimize code size.
//	-	We assume the output frame to NOT be in cache.
//	-	The constants PITCH and U32 are defined internally (no include files used).
//
// Registers used: 
//	eax		accumulator
//	ebx		accumulator		
//	ecx		destination address
//	edx		source address
//	ebp		PITCH			
//
// Pentium cycle count (input cache hot, output cache cold):  
//	33 + 8*(cache miss time)		input aligned
//	81 + 8*(cache miss time)		input mis-aligned
//
//------------------------------------------------------------------------------

#include "precomp.h"

#define U32 unsigned long
// Already defined in precomp.h
#define DXPITCH 384

#pragma code_seg("IACODE2")
/*
 *  Notes:
 *    The parameter uDstBlock is in ecx and uSrcBlock is in edx.
 */
__declspec(naked)
void __fastcall BlockCopy (U32 uDstBlock, U32 uSrcBlock)
{		
__asm {
    push    edi
     push    ebx
    push    ebp
     mov     ebp, DXPITCH
    // row 0
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 1
    add     ecx, ebp
     mov     eax, [edx]
    mov     ebx, [edx+4]
     add     edx, ebp
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     add     ecx, ebp
    // row 2
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 3
    add     ecx, ebp
     mov     eax, [edx]
    mov     ebx, [edx+4]
     add     edx, ebp
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     add     ecx, ebp
    // row 4
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 5
    add     ecx, ebp
     mov     eax, [edx]
    mov     ebx, [edx+4]
     add     edx, ebp
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     add     ecx, ebp
    // row 6
    mov     eax, [edx]
     mov     ebx, [edx+4]
    add     edx, ebp
     mov     edi, [ecx]            // heat output cache
    mov     [ecx], eax
     mov     [ecx+4], ebx
    // row 7
    add     ecx, ebp
     pop     ebp
    mov     eax, [edx]
     mov     ebx, [edx+4]
    mov     edi, [ecx]            // heat output cache
     mov     [ecx], eax
    mov     [ecx+4], ebx
     pop     ebx
    pop     edi
     ret        
    }     // end of asm
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxap.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
// $Header:   S:\h26x\src\dec\dxap.h_v   1.2   27 Dec 1995 14:36:18   RMCKENZX  $
//
// $Log:   S:\h26x\src\dec\dxap.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:36:18   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.1   10 Nov 1995 14:45:10   CZHU
// 
// 
//    Rev 1.0   10 Nov 1995 13:56:14   CZHU
// Initial revision.


// ComputeDynamicClut8 Index and UV dither table
#ifndef _AP_INC_
#define _AP_INC_

#define NCOL 256
#define YSIZ   16
#define YSTEP  16
//#define USE_744
extern U8 gUTable[];
extern U8 gVTable[];

/* table index is uvuvuvuvxyyyyyyy */
#define UVSTEP  8
#define YGAP    1
//#define TBLIDX(y,u,v) (((v)>>3<<12) + ((u)>>3<<8) + (y))
#define TBLIDX(y,u,v) ( ((gVTable[v] + gUTable[u]) <<8) + (y>>1))

#if 1

#define YFROM(R, G, B) (U32)((( 16843 * R) + ( 33030 * G) + (  6423 * B) + 65536*16) /65536)
#define UFROM(R, G, B) (U32)((( -9699 * R) + (-19071 * G) + ( 28770 * B) + 65536*128)/65536)
#define VFROM(R, G, B) (U32)((( 28770 * R) + (-24117 * G) + ( -4653 * B) + 65536*128)/65536)

#else

#define YFROM(R, G, B) ( I32)(( 0.257 * R) + ( 0.504 * G) + ( 0.098 * B) + 16.)
#define UFROM(R, G, B) ( I32)((-0.148 * R) + (-0.291 * G) + ( 0.439 * B) + 128.)
#define VFROM(R, G, B) ( I32)(( 0.439 * R) + (-0.368 * G) + (-0.071 * B) + 128.)

#endif

#define CLAMP8(x) (U8)((x) > 255 ? 255 : ((x) < 0 ? 0 : (x)))

/* parameters for generating the U and V dither magnitude and bias */
#define MAG_NUM_NEAREST         6       /* # nearest neighbors to check */
#define MAG_PAL_SAMPLES         32      /* # random palette samples to check */
#define BIAS_PAL_SAMPLES        128     /* number of pseudo-random RGB samples to check */

#define Y_DITHER_MIN 0
#define Y_DITHER_MAX 14

#define RANDOM(x) (int)((((long)(x)) * (long)rand())/(long)RAND_MAX)

typedef struct {  int palindex; long  distance; } close_t;
typedef struct {  int y,u,v; } Color;
/* squares[] is constant values are filled in at run time, so can be global */
static U32 squares[512];
static struct { U8 Udither, Vdither; } dither[4] = {{2, 1}, {1, 2}, {0, 3}, {3, 0}};


;/***************************************************************************/
;/* ComputeDymanicClut() computes the clut tables on the fly, based on the  */
;/* current palette[];                                                      */
;/* called from InitColorConvertor, when CLUTAP is selected                 */
;/***************************************************************************/
LRESULT ComputeDynamicClutNew(unsigned char BIGG *table,
                              unsigned char FAR *APalette, 
                              int APaletteSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxgetbit.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 13:54:10  $
;// $Archive:   S:\h26x\src\dec\dxgetbit.cpv  $
;// $Header:   S:\h26x\src\dec\dxgetbit.cpv   1.2   22 Dec 1995 13:54:10   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxgetbit.cpv  $
// 
//    Rev 1.2   22 Dec 1995 13:54:10   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   01 Aug 1995 12:28:10   DBRUCKS
// change to read most sig bit first and to not read too many bytes
// 
//    Rev 1.0   31 Jul 1995 13:00:16   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   28 Jul 1995 09:46:26   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////// 

#include "precomp.h"

const U32 GetBitsMask[33] = {
	0x00000000, 0x00000001, 0x00000003, 0x00000007,
	0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
	0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
	0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
	0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
	0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
	0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
	0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
	0xffffffff
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxgetbit.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  dxgetbit.h
 *
 *  Description:
 *	  bit reading interface
 */

/*
 * $Header:   S:\h26x\src\dec\dxgetbit.h_v   1.5   27 Dec 1995 14:36:20   RMCKENZX  $
 * $Log:   S:\h26x\src\dec\dxgetbit.h_v  $
;// 
;//    Rev 1.5   27 Dec 1995 14:36:20   RMCKENZX
;// Added copyright notice
 */

#ifndef __DXGETBIT_H__
#define __DXGETBIT_H__

/*****************************************************************************
 *
 *  DESCRIPTION:
 *    The bit reading functions support reading from 1 to 24 bits from a 
 *    stream of bytes.  The most significant bit is read first.
 *
 *  VARIABLES:
 *    U8 FAR * fpu8 - pointer to a stream of bytes
 *	  U32 uWork - working storage
 *    U32 uBitsReady - the number of bits that have been read into the 
 *					   working storage
 * 	  U32 uCount - the number of bits
 *    U32 uResult - the output value
 *    BITSTREAM_STATE FAR * fpbsState - the bitstream state.
 *    U32 uCode - the code used to look up the uResult
 *    U32 uBitCount - number of bits in the code
 */

/*****************************************************************************
 * 
 *  The GetBitsMask is an array of masks indexed by the number of valid bits
 */
extern const U32 GetBitsMask[33]; 

/*****************************************************************************
 *
 *  The state of a stream can be represented using the following structure.
 *  This state structure can be passed between functions and used to initialize
 *  or reinitialize the bitstream.
 */
typedef struct {
	U8 FAR * fpu8;
	U32 uWork;
	U32 uBitsReady;
} BITSTREAM_STATE;

/*****************************************************************************
 *
 *  GET_BITS_INIT
 *
 *  Initialize the bit reading functions.
 *
 *  Parameters:
 *	  uBitsReady - OUT parameter
 *    uWork - OUT parameter
 */
#define GET_BITS_INIT(uWork, uBitsReady) {	\
	uBitsReady = 0;		 					\
	uWork = 0;								\
}

/*****************************************************************************
 *
 *  GET_BITS_SAVE_STATE
 *  
 *  Save the state
 *
 *  Parameters
 *    fpu8 - IN
 *    uBitsReady - IN
 *    uWork - IN
 *    fpbsState - OUT
 */
#define GET_BITS_SAVE_STATE(fp, uW, uBR, fpbs) { \
	fpbs->fpu8 = fp;				\
	fpbs->uBitsReady = uBR;			\
	fpbs->uWork = uW;				\
}

/*****************************************************************************
 *
 *  GET_BITS_RESTORE_STATE
 *
 *  Restore the state
 *
 *  Parameters
 */
#define GET_BITS_RESTORE_STATE(fp, uW, uBR, fpbs) { \
	 fp = fpbs->fpu8;				\
	 uBR = fpbs->uBitsReady;		\
	 uW = fpbs->uWork;				\
}

/*****************************************************************************
 *
 *  GET_FIXED_BITS
 *
 *  Read from 1 to 24 bits from the pointer.
 * 
 *  Parameters:
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_FIXED_BITS(uCount, fpu8, uWork, uBitsReady, uResult) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* setup uBitsReady for next time */	\
	uBitsReady = uBitsReady - uCount;		\
	uResult = (uWork >> uBitsReady);		\
	uWork &= GetBitsMask[uBitsReady];		\
}

/*****************************************************************************
 *
 *  GET_ONE_BIT
 *
 *  Read 1 bit from the pointer. This is a special case of GET_FIXED_BITS 
 *  provided because of the possible assembly optimization advantages.
 * 
 *  Parameters:
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 */
#define GET_ONE_BIT(fpu8, uWork, uBitsReady, uResult) {		\
	GET_FIXED_BITS(1, fpu8, uWork, uBitsReady, uResult)		\
}


/*****************************************************************************
 *
 *  GET_VARIABLE_BITS
 *
 *  Read a variable number of bits using a lookup table.	
 *
 *  The input count should be the number of bits used to index the table.  
 *  The output count is the number of bits in that symbol.
 *
 *  The table should be initialized such that all don't care symbols match to 
 *  the same value.  Thus if the table is indexed by 6-bits a two bit symbol 
 *  01XX XX will be used to initialize all entries 0100 00 -> 0111 11.  These
 *  entries will include an 8-bit length in the least significant byte.
 *
 *    uCount - IN
 *    fpu8 - IN and OUT
 *    uWork - IN and OUT
 *    uBitsReady - IN and OUT
 *    uResult - OUT
 *    uCode - OUT
 *    fpTable - IN
 */
#define GET_VARIABLE_BITS(uCount, fpu8, uWork, uBitsReady, uResult, uCode, uBitCount, fpTable) { \
	while (uBitsReady < uCount) {			\
		uWork <<= 8;						\
		uBitsReady += 8;					\
		uWork |= *fpu8++;					\
	}										\
	/* calculate how much to shift off */	\
	/* and get the code */					\
	uCode = uBitsReady - uCount;			\
	uCode = (uWork >> uCode);				\
	/* read the data */						\
	uResult = fpTable[uCode];				\
	/* count of bits used */   				\
	uBitCount = uResult & 0xFF;				\
	/* bits remaining */					\
	uBitsReady = uBitsReady - uBitCount;	\
	uWork &= GetBitsMask[uBitsReady];		\
}

#endif /* __DXGETBIT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxctrls.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;//
;// Description:    This module implements the following functions.
;//                     CustomChangeBrightness();
;//                     CustomChangeContrast();
;//                     CustomChangeSaturation();
;//                     CustomResetBrightness();
;//                     CustomResetContrast();
;//                     CustomResetSaturation();
;//                     CustomGetBrightness();
;//                     CustomGetContrast();
;//                     CustomGetSaturation();
;//
;// $Author:   BECHOLS  $
;// $Date:   09 Dec 1996 08:51:44  $
;// $Archive:   S:\h26x\src\dec\dxctrls.cpv  $
;// $Header:   S:\h26x\src\dec\dxctrls.cpv   1.14   09 Dec 1996 08:51:44   BECHOLS  $
;//	$Log:   S:\h26x\src\dec\dxctrls.cpv  $
// 
//    Rev 1.14   09 Dec 1996 08:51:44   BECHOLS
// Fixed reset saturation, so that it modified chroma table, not luma.
// 
//    Rev 1.13   20 Oct 1996 13:33:32   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.12   10 Sep 1996 10:31:38   KLILLEVO
// changed all GlobalAlloc/GlobalLock calls to HeapAlloc
// 
//    Rev 1.11   11 Jul 1996 14:09:18   SCDAY
// Added comments re: CustomGetB/C/S functions
// 
//    Rev 1.10   10 Jul 1996 08:21:26   SCDAY
// Added functions for CustomGetBrightness/Contrast/Saturation (DBrucks)
// 
//    Rev 1.9   04 Jun 1996 09:04:00   AKASAI
// Fixed bug in CustomResetSaturation where it was reseting the LumaTable
// instead of the ChromaTable.  This was discovered in Quartz testing.
// 
//    Rev 1.8   01 Feb 1996 10:16:24   BNICKERS
// Fix the "knobs".
// 
//    Rev 1.7   22 Dec 1995 13:53:06   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.6   17 Nov 1995 15:22:12   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.5   01 Nov 1995 16:52:24   TRGARDOS
// Fixed unmatched GlobalUnlocks.
// 
//    Rev 1.4   25 Oct 1995 18:14:02   BNICKERS
// 
// Clean up archive stuff.
// 
//    Rev 1.3   20 Sep 1995 09:23:52   SCDAY
// 
// added #ifdef for #include d?dec.h
// 
//    Rev 1.2   01 Sep 1995 09:49:36   DBRUCKS
// checkin partial ajdust pels changes
// 
//    Rev 1.1   23 Aug 1995 12:24:04   DBRUCKS
// change to H26X_DEFAULT_* from H263_ as these are shared values.
// 
//    Rev 1.0   31 Jul 1995 13:00:14   DBRUCKS
// Initial revision.
// 
//    Rev 1.1   24 Jul 1995 15:00:40   CZHU
// 
// Adjust the changes to the decoder catalog structure
// 
//    Rev 1.0   17 Jul 1995 14:46:18   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#define SCALE               128
#define ACTIVE_RANGE        256
#define OFFSET_TABLE_COPY   256 + 16

typedef BOOL FAR *LPBOOL;
typedef struct {
    LPBYTE  LumaTable;
    LPBOOL  LumaFlag;
    LPBYTE  ChromaTable;
    LPBOOL  ChromaFlag;
    LPBYTE  Brightness;
    LPBYTE  Contrast;
    LPBYTE  Saturation;
    } PIXDAT, FAR *LPPIXDAT;

/**********************************************************************
 * static WORD LockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This function locks the memory and fills the Pixel Data
 *                 Structure with valid pointers to the tables that I need
 *                 to adjust.
 * History:        06/29/94 -BEN-
 **********************************************************************/
static LRESULT LockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	FX_ENTRY("LockLCTables")

	if(IsBadWritePtr((LPVOID)lpInst, sizeof(DECINSTINFO)))
	{
		ERRORMESSAGE(("%s: ICERR_BADPARAM\r\n", _fx_));
		return(ICERR_BADPARAM);
	}
	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)(DC->p16InstPostProcess +
								    DC->X16_LumaAdjustment);
	lpPixData->ChromaTable = (LPBYTE)(DC->p16InstPostProcess +
									  DC->X16_ChromaAdjustment);
	lpPixData->LumaFlag = (LPBOOL)&(DC->bAdjustLuma);
	lpPixData->ChromaFlag = (LPBOOL)&(DC->bAdjustChroma);
	lpPixData->Brightness = (LPBYTE)&(DC->BrightnessSetting);
	lpPixData->Contrast = (LPBYTE)&(DC->ContrastSetting);
	lpPixData->Saturation = (LPBYTE)&(DC->SaturationSetting);

	return(ICERR_OK);
}

/*********************************************************************
 * static LRESULT UnlockLCTables(LPDECINST, LPPIXDAT);
 * Description:    This funtion unlocks
 * History:        06/30/94 -BEN-
 **********************************************************************/
static LRESULT UnlockLCTables(LPDECINST lpInst, LPPIXDAT lpPixData)
{
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	lpPixData->LumaTable = (LPBYTE)NULL;
	lpPixData->ChromaTable = (LPBYTE)NULL;
	lpPixData->LumaFlag = (LPBOOL)NULL;
	lpPixData->ChromaFlag = (LPBOOL)NULL;

	return(ICERR_OK);
}

/**********************************************************************
 * static VOID MassageContrast(BYTE, PBYTE);
 * Description:    input is 0 to 255, 1/SCALE to 256/SCALE inclusive
 *                 0 = 1/SCALE
 *                 1 = 2/SCALE
 *                 n = (n + 1) / SCALE
 *                 SCALE - 1 = 1        yields no change
 *                 255 = 256/SCALE
 *                 if the response is too coarse, SCALE can be increased
 *                 if the response is too fine, SCALE can be decreased
 *
 * History:        02/22/94 -BEN-  Added header.
 **********************************************************************/
static VOID MassageContrast(BYTE offsetfactor, LPBYTE table)
    {
    int i;
    long temp, contrastfactor;

    contrastfactor = ((long)((DWORD)offsetfactor)) + 1; // 1 - 256
    contrastfactor = (contrastfactor * ACTIVE_RANGE) / 256L;
    for(i = 0; i < 256; i++)
        {
        temp = (long)((DWORD)table[i]);
        temp -= (ACTIVE_RANGE / 2L);                    // add centering
        temp *= contrastfactor;
        temp /= SCALE;
        temp += (ACTIVE_RANGE / 2L);                    // remove centering
        if(temp < 0)                                    // and clamp
            table[i] = 0;
        else if(temp <= 255)
            table[i] = (unsigned char) temp;
        else
            table[i] = 255;
        table[i+OFFSET_TABLE_COPY] = table[i];
        }
    return;
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeBrightness(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeBrightness(LPDECINST lpInst, BYTE offsetdelta)
    {
    LRESULT lRes;
    int     delta, temp, i;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetBrightness(lpInst);
        if(offsetdelta != H26X_DEFAULT_BRIGHTNESS)
            {
            delta = ((offsetdelta - 128) * ACTIVE_RANGE) / 256; // -128 to 127
            for(i = 0; i < 256; i++)
                {
                temp = (int)PixData.LumaTable[i] + delta;
                if(temp < 0) PixData.LumaTable[i] = 0;
                else if(temp <= 255) PixData.LumaTable[i] = (BYTE)temp;
                else PixData.LumaTable[i] = 255;
                PixData.LumaTable[i+OFFSET_TABLE_COPY] = PixData.LumaTable[i];
                }
            *(PixData.Brightness) = offsetdelta;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeContrast(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeContrast(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetContrast(lpInst);
        if(offsetfactor != H26X_DEFAULT_CONTRAST)
            {
            MassageContrast(offsetfactor, PixData.LumaTable);
            *(PixData.Contrast) = offsetfactor;
            *(PixData.LumaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomChangeSaturation(LPDECINST, BYTE);
;//
;// Description:    Added header.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomChangeSaturation(LPDECINST lpInst, BYTE offsetfactor)
    {
    LRESULT lRes;
    PIXDAT  PixData;

    lRes = LockLCTables(lpInst, &PixData);
    if(lRes == ICERR_OK)
        {
        CustomResetSaturation(lpInst);
        if(offsetfactor != H26X_DEFAULT_SATURATION)
            {
            MassageContrast(offsetfactor, PixData.ChromaTable);
            *(PixData.Saturation) = offsetfactor;
            *(PixData.ChromaFlag) = TRUE;
            }
        lRes = UnlockLCTables(lpInst, &PixData);
        }

    return(lRes);
    }
#ifdef QUARTZ

/************************************************************************
 *  CustomGetBrightness
 *
 *  Gets the current brightness value
 ***********************************************************************/
LRESULT CustomGetBrightness(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->BrightnessSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetBrightness() */

/************************************************************************
 *  CustomGetContrast
 *
 *  Gets the current contrast value
 ***********************************************************************/
LRESULT CustomGetContrast(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->ContrastSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetContrast() */

/************************************************************************
 *
 *  CustomGetSaturation
 *
 *  Gets the current saturation value
 ***********************************************************************/
LRESULT CustomGetSaturation(
	LPDECINST lpInst,
	BYTE * pValue)
{
	LRESULT lResult = ICERR_ERROR;
	T_H263DecoderCatalog *DC;

	DC = (T_H263DecoderCatalog *) ((((U32) lpInst->pDecoderInst) + 31) & ~0x1F);

	*pValue = (BYTE) DC->SaturationSetting;
	
	lResult = ICERR_OK;

	return lResult;
} /* end CustomGetSaturation() */

#endif /* QUARTZ */


;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetBrightness(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetBrightness(LPDECINST lpInst)
{
	LRESULT lRes;
	int i;
	PIXDAT  PixData;

	lRes = LockLCTables(lpInst, &PixData);
	if(lRes == ICERR_OK)
	{
		for(i = 0; i < 256; i++)
		{
			PixData.LumaTable[i] = i;
			PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
		}
		*(PixData.LumaFlag) = FALSE;
		*(PixData.Brightness) = H26X_DEFAULT_BRIGHTNESS;
		if(*(PixData.Contrast) != H26X_DEFAULT_CONTRAST)
			CustomChangeContrast(lpInst, *(PixData.Contrast));
		lRes = UnlockLCTables(lpInst, &PixData);
	}

	return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetContrast(LPDECINST lpInst);
;//
;// Description:    Sets the luminance table to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetContrast(LPDECINST lpInst)
{
	LRESULT lRes;
	int i;
	PIXDAT  PixData;

	lRes = LockLCTables(lpInst, &PixData);
	if(lRes == ICERR_OK)
	{
		for(i = 0; i < 256; i++)
		{
			PixData.LumaTable[i] = i;
			PixData.LumaTable[i+OFFSET_TABLE_COPY] = i;
		}
		*(PixData.LumaFlag) = FALSE;
		*(PixData.Contrast) = H26X_DEFAULT_CONTRAST;
		if(*(PixData.Brightness) != H26X_DEFAULT_BRIGHTNESS)
			CustomChangeBrightness(lpInst, *(PixData.Brightness));
		lRes = UnlockLCTables(lpInst, &PixData);
	}

	return(lRes);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       LRESULT CustomResetSaturation(LPDECINST);
;//
;// Description:    Sets chroma tables to identity, and resets
;//                 flag indicating need to use.
;//
;// History:        02/22/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
LRESULT CustomResetSaturation(LPDECINST lpInst)
{
	LRESULT lRes;
	int i;
	PIXDAT  PixData;

	lRes = LockLCTables(lpInst, &PixData);
	if(lRes == ICERR_OK)
	{
		for(i = 0; i < 256; i++)
		{
			PixData.ChromaTable[i] = i;
			PixData.ChromaTable[i+OFFSET_TABLE_COPY] = i;
		}
		*(PixData.ChromaFlag) = FALSE;
		*(PixData.Saturation) = H26X_DEFAULT_SATURATION;
		lRes = UnlockLCTables(lpInst, &PixData);
	}

	return(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxcolori.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MBODART  $
// $Date:   17 Dec 1996 10:36:46  $
// $Archive:   S:\h26x\src\dec\dxcolori.h_v  $
// $Header:   S:\h26x\src\dec\dxcolori.h_v   1.21   17 Dec 1996 10:36:46   MBODART  $
// $Log:   S:\h26x\src\dec\dxcolori.h_v  $
;// 
;//    Rev 1.21   17 Dec 1996 10:36:46   MBODART
;// Exlude function prototypes that either aren't used, or do not match,
;// those for H.261.
;// 
;//    Rev 1.20   16 Dec 1996 13:53:48   MDUDA
;// Adjusted output color convertor table to account for H263' problem
;// with MMX output color convertors (MMX width must be multiple of 8).
;// 
;//    Rev 1.19   09 Dec 1996 09:35:54   MDUDA
;// 
;// Some re-arrangement for H263P.
;// 
;//    Rev 1.18   29 Oct 1996 13:45:34   MDUDA
;// Added prototype for MMX_YUV12ToYUY2.
;// 
;//    Rev 1.17   06 Sep 1996 16:10:18   BNICKERS
;// 
;// Added Pentium Pro color convertor function prototypes.
;// 
;//    Rev 1.16   18 Jul 1996 09:24:56   KLILLEVO
;// implemented YUV12 color convertor (pitch changer) in assembly
;// and added it as a normal color convertor function, via the
;// ColorConvertorCatalog() call.
;// 
;//    Rev 1.15   19 Jun 1996 14:27:54   RHAZRA
;// 
;// added #define YUY2DDRAW 33, added YUY2 Init color convertor function
;// and the YUY2 color convertor to the list of color convertors.
;// 
;//    Rev 1.14   14 Jun 1996 17:27:48   AGUPTA2
;// Updated the color convertor table.
;// 
;//    Rev 1.13   30 May 1996 15:16:44   KLILLEVO
;// added YUV12 output
;// 
;//    Rev 1.12   30 May 1996 11:26:44   AGUPTA2
;// Added support for MMX color convertors.
;// 
;//    Rev 1.11   01 Apr 1996 10:26:36   BNICKERS
;// Add YUV12 to RGB32 color convertors.  Disable IF09.
;// 
;//    Rev 1.10   18 Mar 1996 09:58:52   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.9   05 Feb 1996 13:35:50   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.8   27 Dec 1995 14:36:18   RMCKENZX
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

#define YUV12ForEnc           0   // Keep these assignments consistent with
#define CLUT8                 1   // assembly .inc file
#define CLUT8DCI              2
#define CLUT8ZoomBy2          3
#define CLUT8ZoomBy2DCI       4
#define RGB24                 5
#define RGB24DCI              6
#define RGB24ZoomBy2          7
#define RGB24ZoomBy2DCI       8
#define RGB16555              9
#define RGB16555DCI          10
#define RGB16555ZoomBy2      11
#define RGB16555ZoomBy2DCI   12  
#define IF09                 13
#define RGB16664             14
#define RGB16664DCI          15
#define RGB16664ZoomBy2      16
#define RGB16664ZoomBy2DCI   17 
#define RGB16565             18
#define RGB16565DCI          19
#define RGB16565ZoomBy2      20
#define RGB16565ZoomBy2DCI   21 
#define RGB16655             22
#define RGB16655DCI          23
#define RGB16655ZoomBy2      24
#define RGB16655ZoomBy2DCI   25 
#define CLUT8APDCI           26
#define CLUT8APZoomBy2DCI    27
#define RGB32                28
#define RGB32DCI             29
#define RGB32ZoomBy2         30
#define RGB32ZoomBy2DCI      31
#define YUV12NOPITCH         32
#define YUY2DDRAW            33

#define H26X_DEFAULT_BRIGHTNESS  128
#define H26X_DEFAULT_CONTRAST    128
#define H26X_DEFAULT_SATURATION  128

#if !defined(H263P)
enum {PENTIUM_CC = 0, PENTIUMPRO_CC, MMX_CC};
#endif

typedef struct {
  LRESULT (* Initializer) (      /* Ptr to color conv initializer function.   */
                           T_H263DecoderCatalog FAR *, UN);
#if defined(H263P)
  void (FAR ASM_CALLTYPE * ColorConvertor[2][3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#else
  void (FAR ASM_CALLTYPE * ColorConvertor[3]) (  /* Ptr to color conv func.   */
        LPSTR YPlane,
        LPSTR VPlane,
        LPSTR UPlane,
        UN  FrameWidth,
        UN  FrameHeight,
        UN  YPitch,
        UN  VPitch,
        UN  AspectAdjustmentCount,
        LPSTR ColorConvertedFrame,
        U32 DCIOffset,
        U32 CCOffsetToLine0,
        int CCOPitch,
        int CCType);
#endif
} T_H263ColorConvertorCatalog;

extern T_H263ColorConvertorCatalog ColorConvertorCatalog[];

LRESULT H26X_YVU12ForEnc_Init (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUY2_Init        (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_YUV_Init         (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB16_Init       (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_RGB24_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_RGB32_Init       (T_H263DecoderCatalog FAR *, UN); 
LRESULT H26X_CLUT8AP_Init     (T_H263DecoderCatalog FAR *, UN);
LRESULT H26X_CLUT8AP_InitReal (LPDECINST,T_H263DecoderCatalog FAR * , UN, BOOL);

extern "C" {
#if !defined(H261)
	long Convert_Y_8to7_Bit(HPBYTE, DWORD, DWORD, DWORD, HPBYTE, DWORD);
	long AspectCorrect(HPBYTE,HPBYTE,HPBYTE,DWORD,DWORD,WORD FAR *,
			           DWORD,HPBYTE,HPBYTE,DWORD,DWORD);
	void FAR ASM_CALLTYPE BlockEdgeFilter (
              U8 FAR * P16Instance,        /* Base of instance data.          */
              U8 FAR * P16InstPostProcess, /* Base of PostFrm.                */
              X32 X32_YPlane,              /* Offset to YPlane to filter.     */
              X32 X32_BEFDescr,            /* BEF Descriptors.                */
              UN BEFDescrPitch,            /* BEF Descriptor Pitch.           */
              X32 X32_BEFApplicationList,  /* BEF work space.                 */
              UN YPitch,                   /* Pitch of Y plane.               */
              UN YOperatingWidth);         /* Portion of Y line actually used.*/
#endif
	void FAR ASM_CALLTYPE AdjustPels (
              U8 FAR * P16InstPostProcess, /* Base of PostFrm.                */
              X32 X32_Plane,               /* Offset to plane to adjust.      */
              DWORD Width,                 /* Width of plane.                 */
              DWORD Pitch,                 /* Pitch of plane.                 */
              DWORD Height,                /* Height of plane.                */
              X32 X16_AdjustmentTable);    /* Lookup table to do adjustment.  */
}

											 
extern "C" {

#if defined(H263P)
void FAR ASM_CALLTYPE
MMX_H26x_YUV12ForEnc   (U8 FAR*,X32,X32,X32,UN,UN,UN,U8 FAR *,X32,X32,X32);
#endif

void FAR ASM_CALLTYPE
H26x_YUV12ForEnc     (U8 FAR*,X32,X32,X32,UN,UN,UN,U8 FAR *,X32,X32,X32);
void FAR ASM_CALLTYPE
YUV12ToCLUT8         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB32ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB24ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16         (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToRGB16ZoomBy2  (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToIF09          (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8AP       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToCLUT8APZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUY2          (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
YUV12ToYUV           (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
#ifdef USE_MMX // { USE_MMX
//  MMX routines
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB32       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB32ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB24       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB24ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB16       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToRGB16ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToCLUT8       (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToCLUT8ZoomBy2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
void FAR ASM_CALLTYPE
MMX_YUV12ToYUY2        (LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
#endif // } USE_MMX
}

// For now the YUY2 color convertor is in C

// extern void FAR ASM_CALLTYPE YUV12ToYUY2(LPSTR,LPSTR,LPSTR,UN,UN,UN,UN,UN,LPSTR,U32,U32,int,int);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
//
// $Author:   CLORD  $
// $Date:   17 Apr 1997 16:50:04  $
// $Archive:   S:\h26x\src\dec\dxbase.cpv  $
// $Header:   S:\h26x\src\dec\dxbase.cpv   1.48   17 Apr 1997 16:50:04   CLORD  $
//	$Log:   S:\h26x\src\dec\dxbase.cpv  $
// 
//    Rev 1.48   17 Apr 1997 16:50:04   CLORD
// moved updating xres and yres from DecompressQuery to DecompressBegin,
// this fixes VPhone frame dimension changes, when a Query was sent after the 
// DecompressEnd and before the DecompressBegin
// 
//    Rev 1.47   27 Mar 1997 12:32:48   MDUDA
// No longer checking input compression in Decompress. This change
// is to fix problem where DVP nulls out compression field between
// calls to DecompressBegin and Decompress.
// 
//    Rev 1.46   24 Mar 1997 15:00:34   mbodart
// Fix PVCS tracker bug 150 in the H.263 bug base:  allow a change of
// dimensions in "redundant" DecompressBegin's.
// 
//    Rev 1.45   18 Mar 1997 16:21:10   MDUDA
// Commented out call to H263TermColorConvertor in DecompressEnd.
// This fixes a Graphedt problem where starts and stops cause a hang.
// 
//    Rev 1.44   18 Mar 1997 10:43:28   mbodart
// Quick one-line fix to previous change.  Note that there are still problems
// in graphedt, when trying a bunch of play-pause-stop-play... combinations.
// We need to re-evaluate how DecompressBegin/DecompressEnd deal with
// memory allocation and initialization.
// 
// Also rearranged some DbgLog messages in DecompressQuery to give more
// condensed information.
// 
//    Rev 1.43   14 Mar 1997 19:01:36   JMCVEIGH
// Removed H263TermDecoderInstance from DecompressEnd. Some apps.
// send a DecompressEnd, but then restart decompressing at the
// middle of the sequence (i.e., not a the previous keyframe). We
// therefore need to retain the reference frame. The instance is
// free in DrvClose.
// 
//    Rev 1.42   07 Mar 1997 09:07:42   mbodart
// Added a missing '#ifndef H261' in DecompressQuery.
// Added a call to _clearfp() in the Decompress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.41   14 Jan 1997 11:16:22   JMCVEIGH
// Put flag for old still-frame mode backward compatibility under
// #ifdef H263P
// 
//    Rev 1.40   13 Jan 1997 10:51:14   JMCVEIGH
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.39   10 Jan 1997 18:30:24   BECHOLS
// Changed decompress query so that it will accept negative heights.
// 
//    Rev 1.38   06 Jan 1997 17:40:24   JMCVEIGH
// Added support to ensure backward compatibility with old
// still-frame mode (crop CIF image to 320x240). Since 320x240 size
// is valid with arbitrary frame size support in H.263+, we check
// for this case by either comparing the source/destination header
// sizes or the source header size and the size contained in the
// picture header of the bitstream.
// 
//    Rev 1.37   03 Jan 1997 15:05:16   JMCVEIGH
// Re-inserted check in DecompressQuery that allows a H263 bitstream
// with frame dimensions 320x240 in non-prime decoder to be
// supported. This undos the elimination of this check in rev. 1.33.
// 
//    Rev 1.36   11 Dec 1996 16:02:34   MBODART
// 
// In Decompress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.35   09 Dec 1996 18:02:10   JMCVEIGH
// Added support for arbitrary frame sizes.
// 
//    Rev 1.34   27 Nov 1996 13:55:18   MBODART
// Added a comment to DecompressQuery that explicitly enumerates the
// formats and transformations that H.261 supports.
// 
//    Rev 1.33   21 Nov 1996 17:27:18   MDUDA
// Disables YUV12 output zoom by 2 and removed 160x120, 240x180,
// and 320x240 acceptance of H263 input.
// 
//    Rev 1.32   15 Nov 1996 08:39:56   MDUDA
// Added 640x480 frame size for H263 and FOURCC_YUV12.
// 
//    Rev 1.31   14 Nov 1996 09:22:34   MBODART
// Disable the ability to select a DCI color convertor, they don't exist!
// However, DCI col. conv. initialization does exist, and differs from
// non-DCI initialization.
// 
//    Rev 1.30   13 Nov 1996 10:58:32   RHAZRA
// H.261 YUV12 decoder now accepts CIF, QCIF, 160x120, 320x240 and 640x480
// 
//    Rev 1.29   12 Nov 1996 08:47:12   JMCVEIGH
// Removed initial arbitrary frame size support, i.e., reverted back
// to rev 1.27. Will hold off on custom picture format support until
// branch for release candidate for PS 3.0.
// 
//    Rev 1.28   11 Nov 1996 11:51:14   JMCVEIGH
// Added initial support for arbitrary frame sizes (H.263+ draft,
// document LBC-96-263). Define H263P to allow frame sizes from
// 4 <= width <= 352 and 4 <= height <= 288, where both width and
// height are multiples of 4.
// 
//    Rev 1.27   20 Oct 1996 13:31:46   AGUPTA2
// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
// 
// 
//    Rev 1.26   26 Sep 1996 09:46:00   BECHOLS
// 
// Turned on Snapshot for H263.  This code merely sets up for the Snapshot
// copy, and waits on an event for the decoder to do the copy.  When the
// event is signaled, the Snapshot trigger wakes up and returns the status
// of the copy to the caller.
// 
//    Rev 1.25   25 Sep 1996 17:30:32   BECHOLS
// changed the snapshot code to wait on an event while the decoder
// does the snapshot copy.
// 
//    Rev 1.24   24 Sep 1996 13:51:42   BECHOLS
// 
// Added Snapshot() implementation.
// 
//    Rev 1.23   03 Sep 1996 16:29:22   CZHU
// enable DDRAW, removed define
// 
//    Rev 1.22   18 Jul 1996 09:24:36   KLILLEVO
// implemented YUV12 color convertor (pitch changer) in assembly
// and added it as a normal color convertor function, via the
// ColorConvertorCatalog() call.
// 
//    Rev 1.21   01 Jul 1996 10:05:10   RHAZRA
// 
// Turn off aspect ratio correction for YUY2 color conversion.
// 
//    Rev 1.20   19 Jun 1996 16:38:54   RHAZRA
// 
// Added a #ifdef to coditionally disable DDRAW (YUY2) support
// 
//    Rev 1.19   19 Jun 1996 14:26:28   RHAZRA
// Added code to (i) accept YUY2 as a valid output format (ii) select
// YUY2 color convertor in SelectColorConvertor()
// 
//    Rev 1.18   30 May 1996 17:08:52   RHAZRA
// Added SQCIF support for H263.
// 
//    Rev 1.17   30 May 1996 15:16:38   KLILLEVO
// added YUV12 output
// 
//    Rev 1.16   30 May 1996 10:13:00   KLILLEVO
// 
// removed one cluttering debug statement
// 
//    Rev 1.15   01 Apr 1996 10:26:34   BNICKERS
// Add YUV12 to RGB32 color convertors.  Disable IF09.
// 
//    Rev 1.14   09 Feb 1996 10:09:22   AKASAI
// Added ifndef RING0 around code in DecompressGetPalette to eliminate
// warning in building RING0 release version of codec.
// 
//    Rev 1.13   11 Jan 1996 16:59:14   DBRUCKS
// 
// cleaned up DecompressQuery
// added setting of bProposedCorrectAspectRatio (in Query) and
// bCorrectAspectRatio (in Begin) if the source dimensions are SQCIF,
// QCIF, or CIF and the destination dimensions are the aspect ratio
// sizes with a possible zoom by two.
// 
//    Rev 1.12   18 Dec 1995 12:51:38   RMCKENZX
// added copyright notice
// 
//    Rev 1.11   13 Dec 1995 13:22:54   DBRUCKS
// 
// Add assertions to verify that the source size is not changing on
// a begin.
// 
//    Rev 1.10   07 Dec 1995 13:02:52   DBRUCKS
// fix spx release build
// 
//    Rev 1.9   17 Nov 1995 15:22:30   BECHOLS
// 
// Added ring 0 stuff.
// 
//    Rev 1.8   15 Nov 1995 15:57:24   AKASAI
// Remove YVU9 from decompress and decompress_query.
// (Integration point)
// 
//    Rev 1.7   25 Oct 1995 18:12:36   BNICKERS
// Add YUV12 color convertors.  Eliminate YUV9 looking glass support.
// 
//    Rev 1.6   17 Oct 1995 17:31:24   CZHU
// 
// Fixed a bug in DecompressQuery related to YUV12
// 
//    Rev 1.5   18 Sep 1995 08:40:50   CZHU
// 
// Added support for YUV12
// 
//    Rev 1.4   08 Sep 1995 12:11:12   CZHU
// Output compressed size for debugging
// 
//    Rev 1.3   25 Aug 1995 13:58:06   DBRUCKS
// integrate MRV R9 changes
// 
//    Rev 1.2   23 Aug 1995 12:25:12   DBRUCKS
// Turn on the color converters
// 
//    Rev 1.1   01 Aug 1995 12:27:38   DBRUCKS
// add PSC parsing
// 
//    Rev 1.0   31 Jul 1995 13:00:12   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:14   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:26   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

extern BYTE PalTable[236*4];

#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)

/***************************************************************************
 *
 * Build16bitModeID().
 *
 * given red, green and blue values showing their maximum value,
 * count the bits standing and then form a decimal digit which lists
 * the number of red bits in the hundreds position, green in the tens
 * position and blue in the ones position.
 *
 * This code is used when the RGB16 table is built so the correct
 * field size will be used.
 *
 * returns the 16 bit mode ID
 *
 * Prototype in rgb16cct.h
 *
 ***************************************************************************/
int Build16bitModeID(I32 red, I32 green, I32 blue)
{
int rval;
int Rbits, Gbits, Bbits;
U32 i;

	for (Rbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Rbits += (red & i) ? 1 : 0;
	for (Gbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Gbits += (green & i) ? 1 : 0;
	for (Bbits = 0,i = 1; i < (1L << 30); i = i << 1)
		Bbits += (blue & i) ? 1 : 0;
	rval = Rbits * 100 + Gbits * 10 + Bbits;

return(rval);
}


/***********************************************************************
 * SelectConvertor(LPDECINST, BOOL);
 * History:        03/18/94 -BEN-
 ***********************************************************************/
static UINT SelectConvertor(
    LPDECINST lpInst,
    LPBITMAPINFOHEADER lpbiDst, 
    BOOL bIsDCI)
{
	UINT    uiCnvtr = 0xFFFF;
	DWORD FAR * pDW = (DWORD FAR *)((LPBYTE)lpbiDst+sizeof(BITMAPINFOHEADER));
	int RequestedMode;

	FX_ENTRY("SelectConvertor")

	/* Force off the DCI color converters because we can not be sure that the
	 * archive data has not changed.
	 * Also, we have no DCI color convertors, so don't select one!
	 */

	bIsDCI = 0;		 

	switch(lpInst->outputDepth)
	{
	case    12:
		if ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV))
		{
			DEBUGMSG(ZONE_INIT, ("%s: Selected 12 bits color convertor: raw YUV12 output\r\n", _fx_));
			uiCnvtr = YUV12NOPITCH;  // YUV12 output
		}
		break;

    case    8:  
		DEBUGMSG(ZONE_INIT, ("%s: Selected  8 bits color convertor\r\n", _fx_));
		if (lpInst->UseActivePalette==0)
		{
			switch(lpInst->XScale)
			{
			case 1:
				if(bIsDCI == TRUE)
				{
					uiCnvtr = CLUT8DCI;
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8DCI convertors selected\r\n", _fx_));
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8 convertors selected\r\n", _fx_));
					uiCnvtr = CLUT8; 
				}
				break;

			case 2:
				if(bIsDCI == TRUE)
				{   
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8ZoomBy2DCI convertors selected\r\n", _fx_));
					uiCnvtr = CLUT8ZoomBy2DCI;
				}
				else 
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8ZoomBy2 convertors selected\r\n", _fx_));
					uiCnvtr = CLUT8ZoomBy2; 
				}
				break;
			} 
		}
		else
		{
			switch(lpInst->XScale)
			{
			case 1:
				if(bIsDCI == TRUE)
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUTAPDCI is selected\r\n", _fx_));
					uiCnvtr = CLUT8APDCI;                                       
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUTAPDCI  is selected\r\n", _fx_));
					uiCnvtr = CLUT8APDCI;
				}
				break;

			case 2: 
				if(bIsDCI == TRUE)
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8APZoomBy2DCI is selected\r\n", _fx_));
					uiCnvtr = CLUT8APZoomBy2DCI;                                       
				}
				else
				{
					DEBUGMSG(ZONE_INIT, ("%s: CLUT8APZoomBy2DCI is selected\r\n", _fx_));
					uiCnvtr = CLUT8APZoomBy2DCI;
				}
				break;
			}   
		}
		break;
 
	case 16:
		// check which mode is
		if (lpbiDst->biCompression == FOURCC_YUY2)
		{
			DEBUGMSG(ZONE_INIT, ("%s: Selected  16 bits YUY2 color convertor\r\n", _fx_));
			uiCnvtr = YUY2DDRAW;
			break;
		}
		else
		{
			if (lpbiDst->biCompression == BI_RGB)
				RequestedMode = 555; /* default rgb16 mode */
			else //if (lpbiDst->biCompression == BI_BITFIELDS)
				RequestedMode = Build16bitModeID(pDW[0], pDW[1], pDW[2]);

			switch (RequestedMode)
			{
				case 555:  
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 555 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16555DCI;
						else
							uiCnvtr = RGB16555;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 555 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16555ZoomBy2DCI;
						else
							uiCnvtr = RGB16555ZoomBy2;
						break;
					}   //end of 555
					break; 

				case 664:   
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 664 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16664DCI;
						else
							uiCnvtr = RGB16664;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 664 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16664ZoomBy2DCI;
						else
							uiCnvtr = RGB16664ZoomBy2;
						break;
					}   //end of 664
					break; 

				case 565:  
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 565 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16565DCI;
						else
							uiCnvtr = RGB16565;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 565 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16565ZoomBy2DCI;
						else
							uiCnvtr = RGB16565ZoomBy2;
						break;
					}   //end of 565
					break; 

				case 655:   
					switch(lpInst->XScale)
					{
						case 1:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16 in 655 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16655DCI;
						else
							uiCnvtr = RGB16655;
						break;

						case 2:
						DEBUGMSG(ZONE_INIT, ("%s: RGB16x2 in 655 color convertor\r\n", _fx_));
						if(bIsDCI == TRUE)
							uiCnvtr = RGB16655ZoomBy2DCI;
						else
							uiCnvtr = RGB16655ZoomBy2;
						break;
					}   //end of 655
					break; 

				default:
				break;

				} // switch

	    } // else
	        		           
		break;

	case    24:   
		switch(lpInst->XScale)
		{
			case 1:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 24 bits color convertor\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB24DCI;
			else
				uiCnvtr = RGB24;
			break;

			case 2:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 24 bits color convertor, x2\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB24ZoomBy2DCI;
			else
				uiCnvtr = RGB24ZoomBy2;
			break;
		}
		break;

	case    32:   
		switch(lpInst->XScale)
		{
			case 1:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 32 bits color convertor\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB32DCI;
			else
				uiCnvtr = RGB32;
			break;

			case 2:
			DEBUGMSG(ZONE_INIT, ("%s: Selected 32 bits color convertor, x2\r\n", _fx_));
			if(bIsDCI == TRUE)
				uiCnvtr = RGB32ZoomBy2DCI;
			else
				uiCnvtr = RGB32ZoomBy2;
			break;
		}
		break;
	}

    return(uiCnvtr);
}

/***********************************************************************
 *   DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
 * History:        02/18/94 -BEN-
 *
 * The following table summarizes the transformations that the H.261 decoder
 * and I420 color convertor support.
 *
 * H.261 Decoder Inputs and Outputs
 *
+--------------------------+-------------------------------------------------+
| Input Format             | Supported Output Formats for this Input Format  |
+--------------------------+-------------------------------------------------+
| H.261 FCIF (352 x 288)   | 352 x 288 RGBnn, YUV12 or YUY2                  |
|          or              | 352 x 264 RGBnn (aspect ratio correction)       |
| YUV12 FCIF (352 x 288)   | 704 x 576 RGBnn (zoom by 2)                     |
|                          | 704 x 528 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| H.261 QCIF (176 x 144)   | 176 x 144 RGBnn, YUV12 or YUY2                  |
|          or              | 176 x 132 RGBnn (aspect ratio correction)       |
| YUV12 QCIF (176 x 144)   | 352 x 288 RGBnn (zoom by 2)                     |
|                          | 352 x 264 RGBnn (zoom by 2, aspect ratio corr.) |
+--------------------------+-------------------------------------------------+
| YUV12  640 x 480         |  640 x 480 RGBnn, YUV12 or YUY2                 |
|                          | 1280 x 960 RGBnn (zoom by 2)                    |
+--------------------------+-------------------------------------------------+
| YUV12  320 x 240         | 320 x 240 RGBnn, YUV12 or YUY2                  |
|                          | 640 x 480 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
| YUV12  160 x 120         | 160 x 120 RGBnn, YUV12 or YUY2                  |
|                          | 320 x 240 RGBnn (zoom by 2)                     |
+--------------------------+-------------------------------------------------+
 *
 *  Notes:
 *    o RGBnn represents RGB8, RGB16, RGB24 and RGB32.
 *    o Zoom by 2 and aspect ratio correction are not supported with YUY2 and
 *      YUV12 *output*.
 *    o Aspect ratio correction on output is only supported
 *      when the *input* resolution is exactly QCIF or FCIF.
 *
 ***********************************************************************/
DWORD PASCAL DecompressQuery(
	LPDECINST            lpInst, 
	ICDECOMPRESSEX FAR * lpicDecEx, 
	BOOL                 bIsDCI)
{
    LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;
	int iSrcWidth;
	int iSrcHeight;
	int iDstWidth;
	int iDstHeight;
	BOOL bSupportedSrcDimensions;

	FX_ENTRY("DecompressQuery")

	// Check for NULL pointers
    if ((lpicDecEx == NULL) || (lpicDecEx->lpbiSrc == NULL))
		return (DWORD)ICERR_ERROR;

	// Set source and destination bitmap info headers
	lpbiSrc = lpicDecEx->lpbiSrc;
    lpbiDst = lpicDecEx->lpbiDst;

	// Check the source dimensions
	iSrcWidth = lpbiSrc->biWidth;
	iSrcHeight = lpbiSrc->biHeight;
	bSupportedSrcDimensions = FALSE;
	if (lpbiSrc->biCompression == FOURCC_H263)
	{
		/* H261 supports CIF and QCIF 
		 * H263 supports CIF, SQCIF, and QCIF.
		 * H263 also may need 160x120, 240x180, and 320x240 as Tom put special
		 * code into exbase to accept these.
		 */
#ifdef H263P
		/* H.263+ supports custom picture format with width [4,...,352],
		 * height [4,...,288], and both a multiple of 4.
		 */
		if ((iSrcWidth <= 352 && iSrcHeight <= 288) &&
			(iSrcWidth >= 4   && iSrcHeight >= 4)   &&
			(iSrcWidth & ~3) == iSrcWidth           &&
			(iSrcHeight & ~3) == iSrcHeight)

			bSupportedSrcDimensions = TRUE;
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
#ifndef H261
#ifdef USE_BILINEAR_MSH26X
			(iSrcWidth == 80 && iSrcHeight == 64)  ||
#endif
			(iSrcWidth == 128 && iSrcHeight == 96)  ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 240 && iSrcHeight == 180) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
#endif
			(iSrcWidth == 176 && iSrcHeight == 144))
			bSupportedSrcDimensions = TRUE;
#endif // H263P
	}
#ifdef USE_BILINEAR_MSH26X
	else if (lpbiSrc->biCompression == FOURCC_H26X)
	{
		/* H.263+ supports custom picture format with width [4,...,352],
		 * height [4,...,288], and both a multiple of 4.
		 */
		if ((iSrcWidth <= 352 && iSrcHeight <= 288) &&
			(iSrcWidth >= 4   && iSrcHeight >= 4)   &&
			(iSrcWidth & ~3) == iSrcWidth           &&
			(iSrcHeight & ~3) == iSrcHeight)

			bSupportedSrcDimensions = TRUE;
	}
#endif
	else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
#ifndef H261
		if (((iSrcWidth <= 352 && iSrcHeight <= 288) &&
		     (iSrcWidth >= 4 && iSrcHeight >= 4) &&
			 ((iSrcWidth & ~3) == iSrcWidth) &&
			 ((iSrcHeight & ~3) == iSrcHeight)) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#else
		if ((iSrcWidth == 352 && iSrcHeight == 288) ||
            (iSrcWidth == 176 && iSrcHeight == 144) ||
			(iSrcWidth == 160 && iSrcHeight == 120) ||
			(iSrcWidth == 320 && iSrcHeight == 240) ||
			(iSrcWidth == 640 && iSrcHeight == 480))
#endif
			bSupportedSrcDimensions = TRUE;
	}
	
	if (! bSupportedSrcDimensions )
	{
		ERRORMESSAGE(("%s: Unsupported source dimensions in query\r\n", _fx_));
		return (DWORD)ICERR_UNSUPPORTED;
	}
	
	/* Stop if just querying input
	 */
    if (lpbiDst == NULL)
		return ICERR_OK;                               

	/* Check the bit depth
	 */
	switch (lpbiDst->biBitCount)
	{
	case 8:  
		DEBUGMSG(ZONE_INIT, ("%s: Checking 8 bits\r\n", _fx_));
		if (lpbiDst->biCompression != BI_RGB)
			return((DWORD)ICERR_BADFORMAT); 
		break;

	case 12: 
		DEBUGMSG(ZONE_INIT, ("%s: Checking 12 bits\r\n", _fx_));
		if ((lpbiDst->biCompression != FOURCC_YUV12) && (lpbiDst->biCompression != FOURCC_IYUV)) 
	    	return((DWORD)ICERR_BADFORMAT); 
		break;
 

	case 16:  
		DEBUGMSG(ZONE_INIT, ("%s: Checking 16 bits\r\n", _fx_));
		switch (lpicDecEx->lpbiDst->biCompression)
		{
		case BI_RGB: 
			DEBUGMSG(ZONE_INIT, ("%s: BI_RGB\r\n", _fx_));
			break;
		case BI_BITFIELDS: 
			DEBUGMSG(ZONE_INIT, ("%s: BI_BITFIELDS\r\n", _fx_));
			break;
		/*
		 * This definition of BI_BITMAP is here because MS has not provided
		 * a "standard" definition. When MS does provide it, it will likely be
		 * in compddk.h. At that time this definition should be removed.
		 */
		#define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
		case BI_BITMAP:  
			DEBUGMSG(ZONE_INIT, ("%s: Checking BI_BITMAP\r\n", _fx_));
			if (lpicDecEx->lpbiDst->biYPelsPerMeter != 0)
            {   
                // output shouldn't cross a segment boundary in a scan line.
	    		return((DWORD)ICERR_BADFORMAT); 
			}
	    break;

		case FOURCC_YUY2:
			DEBUGMSG(ZONE_INIT, ("%s: Checking YUY2 for DirectDraw\r\n", _fx_));
		break;
		default:
			return((DWORD)ICERR_BADFORMAT); 
		} // switch biCompression
  		break;

	case 24:
		DEBUGMSG(ZONE_INIT, ("%s: Checking 24 bits\r\n", _fx_));
		if (lpbiDst->biCompression != BI_RGB)
		{
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	case 32:
		DEBUGMSG(ZONE_INIT, ("%s: Checking 32 bits\r\n", _fx_));
		if (lpbiDst->biCompression != BI_RGB)
		{
			return((DWORD)ICERR_BADFORMAT); 
		}
		break;

	default:
	    return((DWORD)ICERR_BADFORMAT); 
		break;
	}

/*
    if(lpbiDst->biCompression != BI_RGB && lpbiDst->biCompression != FOURCC_IF09)    // check color space
	{
#define BI_BITMAP mmioFOURCC('B', 'I', 'T', 'M')
	if(lpbiDst->biCompression != BI_BITMAP)
	    return (DWORD)ICERR_UNSUPPORTED;
	if(lpbiDst->biYPelsPerMeter != 0)
	    {   
		
	    return (DWORD)ICERR_UNSUPPORTED;
	    }
	}
*/

   	//  Find the destination dimensions
	if (bIsDCI == TRUE)
	{
		iDstWidth = lpicDecEx->dxDst;
		iDstHeight = lpicDecEx->dyDst;
	}
	else
	{
		iDstWidth = lpbiDst->biWidth;
		iDstHeight = lpbiDst->biHeight;
	}

	DEBUGMSG(ZONE_INIT, ("%s: Query destination %d,%d\r\n", _fx_, iDstWidth, iDstHeight));

	// For the sake of the checks below, we need to take the absolute value
	// of the destination height.
	if(iDstHeight < 0)
	{
		iDstHeight = -iDstHeight;
	}

	// Check out the instance pointer
	if (!lpInst)
		return ICERR_ERROR;

	// Check the destination dimensions
	if ((iSrcWidth == iDstWidth) && (iSrcHeight == iDstHeight))
	{
		lpInst->pXScale = lpInst->pYScale = 1;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if ( ((iSrcWidth<<1) == iDstWidth) && ((iSrcHeight<<1) == iDstHeight) )
	{
		lpInst->pXScale = lpInst->pYScale = 2;
		lpInst->bProposedCorrectAspectRatio = FALSE;
	}
	else if (
#ifndef H261
	         ((iSrcWidth == 128) && (iSrcHeight ==  96)) ||
#endif
	         ((iSrcWidth == 176) && (iSrcHeight == 144)) ||
			     ((iSrcWidth == 352) && (iSrcHeight == 288))
			 )
	{
		/* Support aspect ratio correction for SQCIF, QCIF, and CIF
		 */
		if ( (iSrcWidth == iDstWidth) && ((iSrcHeight*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 1;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else if ( ((iSrcWidth<<1) == iDstWidth) && 
		          (((iSrcHeight<<1)*11/12) == iDstHeight) )
		{
			lpInst->pXScale = lpInst->pYScale = 2;
			lpInst->bProposedCorrectAspectRatio = TRUE;
		}
		else
		{
			return(DWORD)ICERR_UNSUPPORTED;
		}
	}
	else
	{
	    return(DWORD)ICERR_UNSUPPORTED;
	}

    /* check color depth 
     */
    if(lpbiDst->biBitCount !=  8 &&
       lpbiDst->biBitCount != 16 &&
       lpbiDst->biBitCount != 12  &&   // raw YUV12 output
       lpbiDst->biBitCount != 24 &&
       lpbiDst->biBitCount != 32)
	{
		return(DWORD)ICERR_UNSUPPORTED;
	}

    lpInst->xres = (WORD)lpbiSrc->biWidth;
    lpInst->yres = (WORD)lpbiSrc->biHeight;

	/* aspect ratio correction with YUV12 is not supported 
	 */
	if (lpInst->bProposedCorrectAspectRatio && 
	    ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)))
	{
		return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming in DirectDraw */

	if ( ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     (lpbiDst->biCompression == FOURCC_YUY2) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}

	/* No driver zooming for YUV12 */

	if ( ((lpInst->pXScale == 2) && (lpInst->pYScale == 2)) &&
	     ((lpbiDst->biCompression == FOURCC_YUV12) || (lpbiDst->biCompression == FOURCC_IYUV)) )
	{
		 return (DWORD)ICERR_UNSUPPORTED;
	}
    return (DWORD)ICERR_OK;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.
;//
;// History:        02/18/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL DecompressGetPalette(
    LPDECINST lpInst, 
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
    DWORD dw;
    LPBYTE lpPalArea, PalStart;  
#ifndef RING0
    HDC hDC;
#endif
    BYTE tmp;
    int i;
//    int iUseActivePalette;
    ICDECOMPRESSEX icDecEx;

	FX_ENTRY("DecompressGetPalette")

    icDecEx.lpbiSrc = lpbiSrc;
    icDecEx.lpbiDst = lpbiDst;
    if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
        return dw;

	if (lpbiDst == NULL) 
	{
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
        return (DWORD)ICERR_ERROR;
	}

    if(lpbiDst->biBitCount != 8)
    {
		ERRORMESSAGE(("%s: called with biBitCount != 8\r\n", _fx_));
        return (DWORD)ICERR_ERROR;
    }
    lpbiDst->biClrUsed = 256;        /* specify all used */
    lpbiDst->biClrImportant = 0;

#ifndef RING0
    /* copy system palette entries (valid entries are 0-9 and 246-255) */
	hDC = GetDC(NULL);
	lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
	GetSystemPaletteEntries(hDC, 0, 256, (PALETTEENTRY FAR *)lpPalArea);
	ReleaseDC(NULL, hDC);  
#endif
/*
#ifdef DEBUG
	iUseActivePalette = GetPrivateProfileInt("indeo", "UseActivePalette", 0, "system.ini");
	if (iUseActivePalette) {
		for (i = 0; i < 256; i++) {
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea += 4;
		}
		lpPalArea = (unsigned char FAR *)lpbiDst + (int)lpbiDst->biSize;
		_fmemcpy(lpInst->ActivePalette, lpPalArea, sizeof(lpInst->ActivePalette));
		lpInst->UseActivePalette = 1;
	}
#endif
*/

	if (!lpInst)
		return ICERR_ERROR;

#ifndef RING0
    if (lpInst->UseActivePalette == 1) 
      {
		#ifdef WIN32
        memcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
		#else
        _fmemcpy(lpPalArea,lpInst->ActivePalette, sizeof(lpInst->ActivePalette));
		#endif
		DEBUGMSG(ZONE_INIT, ("%s: Return the current active palette saved...\r\n", _fx_));
	}  
	else
	{  
#endif
	DEBUGMSG(ZONE_INIT, ("%s: return the fixed palette...\r\n", _fx_));
	PalStart = (LPBYTE)lpbiDst + (int)lpbiDst->biSize;
	lpPalArea = PalStart + 40;        // fill in starting from the 10th
	for(i = 0; i < (236 << 2); i++)
		*lpPalArea++ = PalTable[i]; 

	lpPalArea = PalStart;   // reverse r&b: dealing with DIBs
	for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
							// fixed by CZHU, 1/23/95
	{
		tmp = *lpPalArea;
		*lpPalArea = *(lpPalArea+2);
		*(lpPalArea+2) = tmp;
		lpPalArea+=4;
	} 
#ifndef RING0
   }
#endif

    return (DWORD)ICERR_OK;
}


/***********************************************************************
 * DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER,
 *                                  LPBITMAPINFOHEADER);
 * Description:    This allows us to suggest a good format to decompress to.
 *
 * History:        02/18/94 -BEN-
 ***********************************************************************/
DWORD PASCAL DecompressGetFormat(
#ifdef USE_BILINEAR_MSH26X
    LPINST             pi, 
#else
    LPDECINST          lpInst, 
#endif
    LPBITMAPINFOHEADER lpbiSrc, 
    LPBITMAPINFOHEADER lpbiDst)
{
#ifdef USE_BILINEAR_MSH26X
	LPDECINST lpInst = (LPDECINST)pi->DecompPtr;
#endif
	DWORD dw;
	ICDECOMPRESSEX icDecEx;
	LPBYTE lpPalArea;
	int i;
	BYTE tmp;
	HDC hDC;
	BOOL f8Bit;

	FX_ENTRY("DecompressGetFormat")

	// check input format - dont check output: being asked to give one back
	icDecEx.lpbiSrc = lpbiSrc;
	icDecEx.lpbiDst = NULL;
	if(dw = DecompressQuery(lpInst, &icDecEx, FALSE))
		return dw;

	// If the current disply mode is 8 bit return a size large enough
	// to hold a 256 palette after the BMIh
	hDC = GetDC(NULL);
	f8Bit = (8 == GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES));
	ReleaseDC(NULL, hDC);
#ifdef FORCE_8BIT_OUTPUT // { FORCE_8BIT_OUTPUT
	f8Bit = TRUE;
#endif // } FORCE_8BIT_OUTPUT
#if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT) // { if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)
	f8Bit = FALSE;
#endif // } if defined(FORCE_16BIT_OUTPUT) || defined(FORCE_24BIT_OUTPUT)

	// if lpbiDst == NULL return size required to hold a output format
	// (add palette size)
	if (lpbiDst == NULL) 
		return(sizeof(BITMAPINFOHEADER) + (int)(f8Bit ? 1024 : 0));

	// check for NULL parameter
	if (lpbiSrc == NULL) 
	{
		// This was probably verified in DecompressQuery, but just to be safe...
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
		return (DWORD)ICERR_ERROR;
	}

	lpbiDst->biSize = sizeof(BITMAPINFOHEADER);
#ifdef USE_BILINEAR_MSH26X
	if (pi->fccHandler == FOURCC_H26X)
	{
		lpbiDst->biWidth  = lpbiSrc->biWidth << 1;
		lpbiDst->biHeight = lpbiSrc->biHeight << 1;
	}
	else
	{
#endif
#ifdef FORCE_ZOOM_BY_2 // { FORCE_ZOOM_BY_2
		lpbiDst->biWidth  = lpbiSrc->biWidth << 1;
		lpbiDst->biHeight = lpbiSrc->biHeight << 1;
#else // }{ FORCE_ZOOM_BY_2
		lpbiDst->biWidth  = lpbiSrc->biWidth;
		lpbiDst->biHeight = lpbiSrc->biHeight;
#endif // } FORCE_ZOOM_BY_2
#ifdef USE_BILINEAR_MSH26X
	}
#endif
#ifdef FORCE_16BIT_OUTPUT // { FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = 16;
#else // }{ FORCE_16BIT_OUTPUT
	lpbiDst->biBitCount = (int)(f8Bit ? 8 : 24);
#endif // } FORCE_16BIT_OUTPUT
	lpbiDst->biPlanes = 1;
	lpbiDst->biCompression =  BI_RGB;
	lpbiDst->biXPelsPerMeter = 0;
	lpbiDst->biYPelsPerMeter = 0;
	lpbiDst->biSizeImage = (DWORD) WIDTHBYTES(lpbiDst->biWidth * lpbiDst->biBitCount) * lpbiDst->biHeight;
	lpbiDst->biClrUsed = lpbiDst->biClrImportant = 0;

	if (f8Bit)
	{
		// Copy the palette
		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER) + 40;        // fill in starting from the 10th
		for(i = 0; i < (236 << 2); i++)
			*lpPalArea++ = PalTable[i]; 

		lpPalArea = (LPBYTE)lpbiDst + sizeof(BITMAPINFOHEADER);   // reverse r&b: dealing with DIBs
		for(i = 0; i < 256; i++)// for all the entries,from PALENTRY to RGBQUAD
								// fixed by CZHU, 1/23/95
		{
			tmp = *lpPalArea;
			*lpPalArea = *(lpPalArea+2);
			*(lpPalArea+2) = tmp;
			lpPalArea+=4;
		}
	}

	return ICERR_OK;
}

/**********************************************************************
 * DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL)
 *  Description:    Provides codec indication to prepare to receive
 *                 decompress requests for a particular input to output
 *                 conversion.  Begins arrive asynchronously, and should
 *                 result in the codec adapting to the changes specified,
 *                 if any.
 *
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressBegin(
    LPDECINST           lpInst, 
    ICDECOMPRESSEX FAR *lpicDecEx, 
    BOOL                bIsDCI)
{
	int     CodecID;
	DWORD   dw;
	UINT    ClrCnvtr;
	LPBITMAPINFOHEADER lpbiSrc;
	LPBITMAPINFOHEADER lpbiDst;

	FX_ENTRY("DecompressBegin")

	// Check for NULL parameters
	if (lpInst == NULL || lpicDecEx == NULL) 
	{
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
		return (DWORD)ICERR_ERROR;
	}

	// Set source and destination pointers
	lpbiSrc = lpicDecEx->lpbiSrc;
	lpbiDst = lpicDecEx->lpbiDst;

    // at begin need to know input and output sizes
    if (lpbiSrc == NULL || lpbiDst == NULL)
	{
		ERRORMESSAGE(("%s: NULL parameter\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if(lpInst->Initialized == TRUE)	
    {
		/* We assume the source dimensions never change.  If they do change
		 * we should terminate the instance because the allocations are
		 * based on dimensions.  Until we add code to do that we need this
		 * assertion.
		 */
    	ASSERT(lpInst->xres == (WORD)lpbiSrc->biWidth);
    	ASSERT(lpInst->yres == (WORD)lpbiSrc->biHeight);
		
		if(lpbiDst != NULL)	
        { 
		    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
            {
				return(dw);    // error
			} 
            else 
            {    // apply changes
				lpInst->XScale = lpInst->pXScale;
				lpInst->YScale = lpInst->pYScale;
				lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
				lpInst->outputDepth = lpbiDst->biBitCount;
				ClrCnvtr = SelectConvertor(lpInst,lpbiDst, bIsDCI); 
				if (ClrCnvtr != lpInst->uColorConvertor ) 
                {
					if((dw = H263TermColorConvertor(lpInst)) == ICERR_OK)
					    dw = H263InitColorConvertor(lpInst, ClrCnvtr); 
					lpInst->uColorConvertor=ClrCnvtr; 
				}
				return(dw);
			}
	    }
	}

    // first time begin - check if this is a format I like
    if(dw = DecompressQuery(lpInst, lpicDecEx, bIsDCI))	
    {
		return(dw);    // error
	} 
    else 
    {    // apply proposed format to 'current' format
		lpInst->XScale = lpInst->pXScale;
		lpInst->YScale = lpInst->pYScale;
		lpInst->bCorrectAspectRatio = lpInst->bProposedCorrectAspectRatio;
		lpInst->outputDepth = lpbiDst->biBitCount;
	}
    
#ifdef USE_BILINEAR_MSH26X
    if ((lpbiSrc->biCompression == FOURCC_H263) || (lpbiSrc->biCompression == FOURCC_H26X))
#else
    if  (lpbiSrc->biCompression == FOURCC_H263)
#endif
    {
         CodecID = H263_CODEC;
    }
    else if ((lpbiSrc->biCompression == FOURCC_YUV12) || (lpbiSrc->biCompression == FOURCC_IYUV))
	{
	     CodecID = YUV12_CODEC;
	}

    if(dw = H263InitDecoderInstance(lpInst, CodecID))
	{
		return(dw);
	}
    ClrCnvtr = SelectConvertor(lpInst, lpbiDst, bIsDCI);
    dw = H263InitColorConvertor(lpInst, ClrCnvtr);
    
    return(dw);
}


/**********************************************************************
 * DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESS FAR *, DWORD);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL Decompress(
	LPDECINST           lpInst, 
	ICDECOMPRESSEX FAR *lpicDecEx, 
	DWORD               dwSize,
	BOOL                bIsDCI)
{
	DWORD ret = (DWORD) ICERR_ERROR;

	FX_ENTRY("Decompress")

	// Check for NULL parameters
    if ((lpInst == NULL) || (lpInst->Initialized != TRUE) || (lpicDecEx == NULL) ||
		(lpicDecEx->lpbiSrc == NULL) || (lpicDecEx->lpbiDst == NULL)) 
    {
		ret = (DWORD) ICERR_ERROR;
		goto done;
 	} 

#ifdef USE_BILINEAR_MSH26X
    if ((lpicDecEx->lpbiSrc->biCompression == FOURCC_H263) || (lpicDecEx->lpbiSrc->biCompression == FOURCC_H26X)
#else
    if ((lpicDecEx->lpbiSrc->biCompression == FOURCC_H263) 
#endif
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_YUV12)
        || (lpicDecEx->lpbiSrc->biCompression == FOURCC_IYUV) )
	{ 
		try
		{
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			ret = H263Decompress(lpInst, lpicDecEx, bIsDCI, TRUE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
			ret = H263Decompress(lpInst, lpicDecEx, bIsDCI);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		}
		catch (...)
		{
			// For a DEBUG build, display a message and pass the exception up.
			// For a release build, stop the exception here and return an error
			// code.  This gives upstream code a chance to gracefully recover.
			// We also need to clear the floating point control word, otherwise
			// the upstream code may incur an exception the next time it tries
			// a floating point operation (presuming this exception was due
			// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
			ERRORMESSAGE(("%s: Exception during H263Decompress!!!\r\n", _fx_));
			throw;
#else
			_clearfp();
			ret = (DWORD) ICERR_ERROR;
#endif
		}
	}

done:
	return ret;
}


/**********************************************************************
 * DWORD PASCAL DecompressEnd(LPDECINST);
 * History:        02/18/94 -BEN-
 **********************************************************************/
DWORD PASCAL DecompressEnd(LPDECINST lpInst)
{
	if(lpInst && lpInst->Initialized == TRUE)
	{
		H263TermColorConvertor(lpInst);
#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		H263TermDecoderInstance(lpInst, TRUE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
		H263TermDecoderInstance(lpInst);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	}

	return ICERR_OK;
}


/*****************************************************************************
 *
 * DecompressSetPalette() is called from the ICM_DECOMPRESS_SET_PALETTE
 * message.
 *
 * Fill in the palette using lpParam1.
 *
 ****************************************************************************/
DWORD PASCAL DecompressSetPalette(LPDECINST pinst,
						 LPBITMAPINFOHEADER lpbi,
						 LPBITMAPINFOHEADER unused)
{
	int i;
	unsigned char FAR * palette;
	RGBQUAD FAR *palptr;

	FX_ENTRY("DecompressSetPalette")

	// Check for NULL parameter
	if (pinst == NULL)
	{
		return (DWORD)ICERR_ERROR;
	}

	pinst->InitActivePalette = 0;	/* must re-init AP at Begin */
	pinst->UseActivePalette = 0;	/* must re-init AP at Begin */

	if (lpbi && (lpbi->biBitCount == 8 && lpbi->biCompression == 0))
	{
		palette = (unsigned char FAR *)lpbi + (int)lpbi->biSize;

		// Check if palette passed is identity
		for (i = 0*4, palptr = (RGBQUAD FAR *)PalTable; i < 236*4; 
             i += 4, palptr++)
		{
			if (palette[i+40] != palptr->rgbRed ||
				palette[i+41] != palptr->rgbGreen ||
				palette[i+42] != palptr->rgbBlue
               )
			break;
		}

		if (i < 236*4)
		{	/* broke early - not the identity palette */
			/* Actually RGBQUAD (BGR) format. */
			if (
#ifdef WIN32
				memcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
#else
				_fmemcmp((unsigned char FAR *)pinst->ActivePalette, (unsigned char FAR *)lpbi + (int)lpbi->biSize,	(int)lpbi->biClrUsed * sizeof(RGBQUAD)) == 0
#endif
				)
			{	/* same as last palette - don't re-init AP */
				DEBUGMSG(ZONE_INIT, ("%s: Use current active palette\r\n", _fx_));
				pinst->UseActivePalette  = 1;
				pinst->InitActivePalette = 1;
			}
			else
			{
				DEBUGMSG(ZONE_INIT, ("%s: Use new active palette\r\n", _fx_));
#ifdef WIN32
				memcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
#else
				_fmemcpy((unsigned char FAR *)pinst->ActivePalette,	(unsigned char FAR *)lpbi + (int)lpbi->biSize, (int)lpbi->biClrUsed * sizeof(RGBQUAD));
#endif
				pinst->UseActivePalette = 1;
			}
		}
		else
		{   
			DEBUGMSG(ZONE_INIT, ("%s: Use fixed palette\r\n", _fx_));
		}
	}
	else
	{      
		DEBUGMSG(ZONE_INIT, ("%s: Use NULL (fixed) palette\r\n", _fx_));
	}

	return ICERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxfm.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

//////////////////////////////////////////////////////////////////////////
// $Author:   KLILLEVO  $
// $Date:   30 Aug 1996 08:41:42  $
// $Archive:   S:\h26x\src\dec\dxfm.h_v  $
// $Header:   S:\h26x\src\dec\dxfm.h_v   1.6   30 Aug 1996 08:41:42   KLILLEVO  $
// $Log:   S:\h26x\src\dec\dxfm.h_v  $
;// 
;//    Rev 1.6   30 Aug 1996 08:41:42   KLILLEVO
;// changed bias in ClampTbl from 128 to CLAMP_BIAS (defined to 128)
;// 
;//    Rev 1.5   17 Jul 1996 15:34:14   AGUPTA2
;// Increased the size of clamping table ClampTbl to 128+256+128.
;// 
;//    Rev 1.4   08 Mar 1996 16:46:34   AGUPTA2
;// Modified the definition of CLIP_RANGE.  Commented out decls for
;// ClipPixIntra and ClipPixInter.
;// 
;// 
;//    Rev 1.3   27 Dec 1995 14:36:20   RMCKENZX
;// Added copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:40:40   AKASAI
// 
// Changed ClipPix to ClipPixIntra and added ClipPixInter.
// 
//    Rev 1.1   22 Aug 1995 10:29:32   CZHU
// 
// Added #define to prevent multiple inclusion.
// 
//    Rev 1.0   21 Aug 1995 14:38:48   CZHU
// Initial revision.

#ifndef _DXFMIDCT_
#define _DXFMIDCT_


#define NUM_ELEM	64	// Number of elements in the block (8x8)
#define KERNEL_SIZE	16	// Number of elements needed in kernel
#define CLAMP_BIAS  128 // Bias in clamping table 
#define CLIP_RANGE	CLAMP_BIAS + 256 + CLAMP_BIAS
                        
#define SCALER 13

extern const I32 	ROUNDER;

extern const I8  Unique[];
extern const I8  PClass[];
extern const I32 KernelCoeff[NUM_ELEM][10];
extern const I8 MapMatrix[NUM_ELEM][KERNEL_SIZE];
extern const U8 ClampTbl[CLIP_RANGE];
#endif //_DXFMIDCT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxidctab.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   30 Aug 1996 08:39:54  $
// $Archive:   S:\h26x\src\dec\dxidctab.cpv  $
// $Header:   S:\h26x\src\dec\dxidctab.cpv   1.6   30 Aug 1996 08:39:54   KLILLEVO  $
// $Log:   S:\h26x\src\dec\dxidctab.cpv  $
// 
//    Rev 1.6   30 Aug 1996 08:39:54   KLILLEVO
// added C version of block edge filter, and changed the bias in 
// ClampTbl[] from 128 to CLAMP_BIAS (defined to 128)
// The C version of the block edge filter takes up way too much CPU time
// relative to the rest of the decode time (4 ms for QCIF and 16 ms
// for CIF on a P120, so this needs to coded in assembly)
// 
//    Rev 1.5   17 Jul 1996 15:34:06   AGUPTA2
// Increased the size of clamping table ClampTbl to 128+256+128.
// 
//    Rev 1.4   08 Mar 1996 16:46:36   AGUPTA2
// Added data_seg pragma. Added ClampTbl def; used by IDCT and dxblkadd.cpp.
// Deleted ClipPixIntra, ClipPixInter.  MapMatrix is an array of bytes instead of 
// DWORDs.
// 
// 
//    Rev 1.3   22 Dec 1995 13:55:56   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.2   12 Sep 1995 13:39:18   AKASAI
// 
// Changed ClipPix tables to ClipPixIntra table and added
// ClipPixInter table.
// 
//    Rev 1.1   22 Aug 1995 10:29:08   CZHU
// Fixed include file dxfm.h instead of fm.h
// 
//    Rev 1.0   21 Aug 1995 14:39:02   CZHU
// Initial revision.


// FMapIDCT tables

#include "precomp.h"

#pragma data_seg("IARDATA2")
const I32 ROUNDER = 0x801000;

const I8  Unique[NUM_ELEM] = {
0x1, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x4, 0x2, 0x4, 0x2, 0x4, 0x2, 0x4,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
0x2, 0x8, 0x3, 0x8, 0x2, 0x8, 0x3, 0x8,
0x4, 0xa, 0x8, 0xa, 0x4, 0xa, 0x8, 0xa,
};    // 64 elements


const I8  PClass[NUM_ELEM] = {
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
0x10, 0x30, 0x10, 0x30, 0x10, 0x30, 0x10, 0x30,
};    // 64 elements


const I32 KernelCoeff[NUM_ELEM][10] = {
0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x07b2, 0x0686, 0x045b, 0x0187, 0x0587, 0x03b2, 0x014c, 0x0278, 0x00dd, 0x004d,
0x073f, 0x0300, 0x0625, 0x028b, 0x041b, 0x01b3, 0x0171, 0x0098, 0x0000, 0x0000,
0x0686, 0x0187, 0x07b2, 0x045b, 0x0587, 0x014c, 0x03b2, 0x00dd, 0x0278, 0x004d,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x07b2, 0x0187, 0x0686, 0x03b2, 0x014c, 0x0587, 0x0278, 0x00dd, 0x004d,
0x0300, 0x073f, 0x028b, 0x0625, 0x01b3, 0x041b, 0x0098, 0x0171, 0x0000, 0x0000,
0x0187, 0x045b, 0x0686, 0x07b2, 0x014c, 0x03b2, 0x0587, 0x00dd, 0x0278, 0x004d,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x073f, 0x0625, 0x041b, 0x0171, 0x0300, 0x028b, 0x01b3, 0x0098, 0x0000, 0x0000,
0x06d4, 0x02d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0625, 0x0171, 0x073f, 0x041b, 0x028b, 0x0098, 0x0300, 0x01b3, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x041b, 0x073f, 0x0171, 0x0625, 0x01b3, 0x0300, 0x0098, 0x028b, 0x0000, 0x0000,
0x02d4, 0x06d4, 0x012b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0171, 0x041b, 0x0625, 0x073f, 0x0098, 0x01b3, 0x028b, 0x0300, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0686, 0x0587, 0x03b2, 0x014c, 0x0187, 0x00dd, 0x004d, 0x07b2, 0x045b, 0x0278,
0x0625, 0x028b, 0x0171, 0x0098, 0x073f, 0x0300, 0x041b, 0x01b3, 0x0000, 0x0000,
0x0587, 0x014c, 0x0686, 0x03b2, 0x004d, 0x0187, 0x00dd, 0x07b2, 0x045b, 0x0278,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x03b2, 0x0686, 0x014c, 0x0587, 0x00dd, 0x0187, 0x004d, 0x045b, 0x07b2, 0x0278,
0x028b, 0x0625, 0x0098, 0x0171, 0x0300, 0x073f, 0x01b3, 0x041b, 0x0000, 0x0000,
0x014c, 0x03b2, 0x0587, 0x0686, 0x004d, 0x00dd, 0x0187, 0x045b, 0x07b2, 0x0278,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x058c, 0x04b4, 0x0324, 0x011a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0539, 0x022a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x04b4, 0x011a, 0x058c, 0x0324, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0400, 0x03ff, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x045b, 0x03b2, 0x0278, 0x00dd, 0x07b2, 0x0686, 0x0187, 0x014c, 0x004d, 0x0587,
0x041b, 0x01b3, 0x073f, 0x0300, 0x0171, 0x0098, 0x0625, 0x028b, 0x0000, 0x0000,
0x03b2, 0x00dd, 0x045b, 0x0278, 0x0686, 0x0187, 0x07b2, 0x014c, 0x004d, 0x0587,
0x0324, 0x058c, 0x011a, 0x04b4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0278, 0x045b, 0x00dd, 0x03b2, 0x07b2, 0x0187, 0x0686, 0x004d, 0x014c, 0x0587,
0x01b3, 0x041b, 0x0300, 0x073f, 0x0098, 0x0171, 0x028b, 0x0625, 0x0000, 0x0000,
0x00dd, 0x0278, 0x03b2, 0x045b, 0x0187, 0x0686, 0x07b2, 0x004d, 0x014c, 0x0587,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0300, 0x028b, 0x01b3, 0x0098, 0x073f, 0x0625, 0x041b, 0x0171, 0x0000, 0x0000,
0x02d4, 0x012b, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x028b, 0x0098, 0x0300, 0x01b3, 0x0625, 0x0171, 0x073f, 0x041b, 0x0000, 0x0000,
0x022a, 0x0539, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x01b3, 0x0300, 0x0098, 0x028b, 0x041b, 0x073f, 0x0171, 0x0625, 0x0000, 0x0000,
0x012b, 0x02d4, 0x06d4, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0098, 0x01b3, 0x028b, 0x0300, 0x0171, 0x041b, 0x0625, 0x073f, 0x0000, 0x0000,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x0187, 0x014c, 0x00dd, 0x004d, 0x045b, 0x03b2, 0x0278, 0x0686, 0x0587, 0x07b2,
0x0171, 0x0098, 0x041b, 0x01b3, 0x0625, 0x028b, 0x073f, 0x0300, 0x0000, 0x0000,
0x014c, 0x004d, 0x0187, 0x00dd, 0x03b2, 0x045b, 0x0278, 0x0587, 0x0686, 0x07b2,
0x011a, 0x0324, 0x04b4, 0x058c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
0x00dd, 0x0187, 0x004d, 0x014c, 0x0278, 0x045b, 0x03b2, 0x0686, 0x0587, 0x07b2,
0x0098, 0x0171, 0x01b3, 0x041b, 0x028b, 0x0625, 0x0300, 0x073f, 0x0000, 0x0000,
0x004d, 0x00dd, 0x014c, 0x0187, 0x0278, 0x03b2, 0x045b, 0x0587, 0x0686, 0x07b2,
};    // [64][10] elements


const I8 MapMatrix[NUM_ELEM][KERNEL_SIZE] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x01, 0x03, 0x02, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x05, 0x06, 0x07, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x02, 0x02, 0x01, 0x00, 0x02, 0x02, 0x01,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x05, 0x02, 0x03, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x05, 0x02, 0x07, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x01, 0x04, 0x05, 0x06,
0x02, 0x05, 0x07, 0x08, 0x03, 0x06, 0x08, 0x09,
0x00, 0x01, 0x09, 0x08, 0x02, 0x03, 0x0b, 0x0a,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x04, 0x0f, 0x0a, 0x10,
0x06, 0x11, 0x0d, 0x12, 0x05, 0x13, 0x0b, 0x11,
0x00, 0x04, 0x04, 0x00, 0x01, 0x05, 0x05, 0x01,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x04, 0x0d, 0x05, 0x06,
0x07, 0x0a, 0x08, 0x04, 0x08, 0x0c, 0x09, 0x05,
0x00, 0x09, 0x01, 0x08, 0x02, 0x0b, 0x03, 0x0a,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x04, 0x0f, 0x06, 0x0c,
0x07, 0x12, 0x05, 0x0b, 0x09, 0x11, 0x04, 0x0a,
0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x01, 0x02, 0x05, 0x04,
0x04, 0x05, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x04, 0x0d, 0x0e, 0x0f,
0x0c, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x01, 0x03, 0x03, 0x01,
0x03, 0x01, 0x01, 0x03, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x04, 0x0d, 0x06, 0x07,
0x0c, 0x05, 0x0e, 0x0f, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x02, 0x03, 0x00, 0x05,
0x05, 0x00, 0x03, 0x02, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x04, 0x0d, 0x06, 0x0f,
0x0c, 0x05, 0x0e, 0x07, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0d, 0x0f, 0x10,
0x11, 0x0a, 0x12, 0x0e, 0x12, 0x0c, 0x13, 0x0f,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x0c, 0x0d, 0x05, 0x04, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0b, 0x04, 0x05, 0x06,
0x0c, 0x05, 0x07, 0x08, 0x0d, 0x06, 0x08, 0x09,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x06, 0x02, 0x02, 0x06, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x10, 0x0c,
0x11, 0x08, 0x0f, 0x0b, 0x13, 0x07, 0x0e, 0x0a,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x0c, 0x05, 0x0d, 0x04, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x05, 0x0a, 0x06,
0x10, 0x07, 0x0d, 0x08, 0x0f, 0x09, 0x0b, 0x07,
0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02,
0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01,
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,
0x00, 0x01, 0x03, 0x02, 0x02, 0x03, 0x01, 0x00,
0x02, 0x03, 0x01, 0x00, 0x00, 0x01, 0x03, 0x02,
0x00, 0x05, 0x06, 0x07, 0x04, 0x01, 0x02, 0x03,
0x04, 0x01, 0x02, 0x03, 0x00, 0x05, 0x06, 0x07,
0x00, 0x02, 0x02, 0x01, 0x03, 0x01, 0x00, 0x03,
0x02, 0x00, 0x00, 0x02, 0x01, 0x03, 0x03, 0x01,
0x00, 0x05, 0x02, 0x03, 0x04, 0x01, 0x06, 0x07,
0x04, 0x01, 0x06, 0x07, 0x00, 0x05, 0x02, 0x03,
0x00, 0x03, 0x01, 0x02, 0x02, 0x01, 0x03, 0x00,
0x02, 0x01, 0x03, 0x00, 0x00, 0x03, 0x01, 0x02,
0x00, 0x05, 0x02, 0x07, 0x04, 0x01, 0x06, 0x03,
0x04, 0x01, 0x06, 0x03, 0x00, 0x05, 0x02, 0x07,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x0a, 0x10,
0x06, 0x07, 0x03, 0x08, 0x05, 0x09, 0x01, 0x07,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x06, 0x07, 0x0f, 0x0e,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x05, 0x06, 0x02,
0x07, 0x12, 0x0f, 0x0b, 0x09, 0x11, 0x0e, 0x0a,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x03, 0x07, 0x07, 0x03,
0x00, 0x0b, 0x02, 0x03, 0x0b, 0x04, 0x0f, 0x10,
0x02, 0x0f, 0x07, 0x08, 0x03, 0x10, 0x08, 0x09,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x06, 0x0f, 0x07, 0x0e,
0x00, 0x0b, 0x02, 0x0d, 0x0e, 0x03, 0x0f, 0x06,
0x07, 0x0a, 0x08, 0x0e, 0x08, 0x0c, 0x09, 0x0f,
0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03,
0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f,
0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
0x00, 0x01, 0x04, 0x03, 0x05, 0x03, 0x00, 0x02,
0x02, 0x00, 0x03, 0x05, 0x03, 0x04, 0x01, 0x00,
0x00, 0x09, 0x0a, 0x0b, 0x0c, 0x05, 0x06, 0x07,
0x04, 0x0d, 0x0e, 0x0f, 0x08, 0x01, 0x02, 0x03,
0x00, 0x02, 0x02, 0x00, 0x03, 0x01, 0x01, 0x03,
0x01, 0x03, 0x03, 0x01, 0x02, 0x00, 0x00, 0x02,
0x00, 0x09, 0x02, 0x03, 0x0c, 0x05, 0x0e, 0x0f,
0x04, 0x0d, 0x06, 0x07, 0x08, 0x01, 0x0a, 0x0b,
0x00, 0x04, 0x01, 0x03, 0x04, 0x02, 0x05, 0x01,
0x01, 0x05, 0x02, 0x04, 0x03, 0x01, 0x04, 0x00,
0x00, 0x09, 0x02, 0x0b, 0x0c, 0x05, 0x0e, 0x07,
0x04, 0x0d, 0x06, 0x0f, 0x08, 0x01, 0x0a, 0x03,
0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05,
0x02, 0x02, 0x02, 0x02, 0x07, 0x07, 0x07, 0x07,
0x00, 0x01, 0x02, 0x03, 0x0e, 0x0f, 0x10, 0x0c,
0x07, 0x08, 0x05, 0x01, 0x13, 0x11, 0x0e, 0x0a,
0x00, 0x01, 0x09, 0x08, 0x0a, 0x0b, 0x03, 0x02,
0x04, 0x05, 0x0d, 0x0c, 0x0e, 0x0f, 0x07, 0x06,
0x00, 0x0b, 0x0c, 0x0d, 0x0e, 0x03, 0x05, 0x06,
0x07, 0x0a, 0x12, 0x0e, 0x12, 0x02, 0x09, 0x05,
0x00, 0x04, 0x04, 0x00, 0x05, 0x01, 0x01, 0x05,
0x02, 0x06, 0x06, 0x02, 0x07, 0x03, 0x03, 0x07,
0x00, 0x0b, 0x02, 0x03, 0x0e, 0x05, 0x0a, 0x10,
0x06, 0x11, 0x03, 0x08, 0x0f, 0x09, 0x0b, 0x11,
0x00, 0x09, 0x01, 0x08, 0x0a, 0x03, 0x0b, 0x02,
0x04, 0x0d, 0x05, 0x0c, 0x0e, 0x07, 0x0f, 0x06,
0x00, 0x0b, 0x02, 0x0d, 0x0b, 0x04, 0x0f, 0x06,
0x02, 0x0f, 0x07, 0x12, 0x0d, 0x06, 0x12, 0x09,
};    // [64][16] elements

const U8 ClampTbl[CLIP_RANGE] = {
             0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 
            ,0x00 ,0x01 ,0x02 ,0x03 ,0x04 ,0x05 ,0x06 ,0x07 
            ,0x08 ,0x09 ,0x0a ,0x0b ,0x0c ,0x0d ,0x0e ,0x0f 
            ,0x10 ,0x11 ,0x12 ,0x13 ,0x14 ,0x15 ,0x16 ,0x17 
            ,0x18 ,0x19 ,0x1a ,0x1b ,0x1c ,0x1d ,0x1e ,0x1f 
            ,0x20 ,0x21 ,0x22 ,0x23 ,0x24 ,0x25 ,0x26 ,0x27 
            ,0x28 ,0x29 ,0x2a ,0x2b ,0x2c ,0x2d ,0x2e ,0x2f 
            ,0x30 ,0x31 ,0x32 ,0x33 ,0x34 ,0x35 ,0x36 ,0x37 
            ,0x38 ,0x39 ,0x3a ,0x3b ,0x3c ,0x3d ,0x3e ,0x3f 
            ,0x40 ,0x41 ,0x42 ,0x43 ,0x44 ,0x45 ,0x46 ,0x47 
            ,0x48 ,0x49 ,0x4a ,0x4b ,0x4c ,0x4d ,0x4e ,0x4f 
            ,0x50 ,0x51 ,0x52 ,0x53 ,0x54 ,0x55 ,0x56 ,0x57 
            ,0x58 ,0x59 ,0x5a ,0x5b ,0x5c ,0x5d ,0x5e ,0x5f 
            ,0x60 ,0x61 ,0x62 ,0x63 ,0x64 ,0x65 ,0x66 ,0x67 
            ,0x68 ,0x69 ,0x6a ,0x6b ,0x6c ,0x6d ,0x6e ,0x6f 
            ,0x70 ,0x71 ,0x72 ,0x73 ,0x74 ,0x75 ,0x76 ,0x77 
            ,0x78 ,0x79 ,0x7a ,0x7b ,0x7c ,0x7d ,0x7e ,0x7f 
            ,0x80 ,0x81 ,0x82 ,0x83 ,0x84 ,0x85 ,0x86 ,0x87 
            ,0x88 ,0x89 ,0x8a ,0x8b ,0x8c ,0x8d ,0x8e ,0x8f 
            ,0x90 ,0x91 ,0x92 ,0x93 ,0x94 ,0x95 ,0x96 ,0x97 
            ,0x98 ,0x99 ,0x9a ,0x9b ,0x9c ,0x9d ,0x9e ,0x9f 
            ,0xa0 ,0xa1 ,0xa2 ,0xa3 ,0xa4 ,0xa5 ,0xa6 ,0xa7 
            ,0xa8 ,0xa9 ,0xaa ,0xab ,0xac ,0xad ,0xae ,0xaf 
            ,0xb0 ,0xb1 ,0xb2 ,0xb3 ,0xb4 ,0xb5 ,0xb6 ,0xb7 
            ,0xb8 ,0xb9 ,0xba ,0xbb ,0xbc ,0xbd ,0xbe ,0xbf 
            ,0xc0 ,0xc1 ,0xc2 ,0xc3 ,0xc4 ,0xc5 ,0xc6 ,0xc7 
            ,0xc8 ,0xc9 ,0xca ,0xcb ,0xcc ,0xcd ,0xce ,0xcf 
            ,0xd0 ,0xd1 ,0xd2 ,0xd3 ,0xd4 ,0xd5 ,0xd6 ,0xd7 
            ,0xd8 ,0xd9 ,0xda ,0xdb ,0xdc ,0xdd ,0xde ,0xdf 
            ,0xe0 ,0xe1 ,0xe2 ,0xe3 ,0xe4 ,0xe5 ,0xe6 ,0xe7 
            ,0xe8 ,0xe9 ,0xea ,0xeb ,0xec ,0xed ,0xee ,0xef 
            ,0xf0 ,0xf1 ,0xf2 ,0xf3 ,0xf4 ,0xf5 ,0xf6 ,0xf7 
            ,0xf8 ,0xf9 ,0xfa ,0xfb ,0xfc ,0xfd ,0xfe ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
            ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff ,0xff 
   };

/*
U8 ClipPixIntra[64+256+64] = {
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x02, 0x03,
0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b,
0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13,
0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b,
0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23,
0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b,
0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33,
0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b,
0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43,
0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b,
0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53,
0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b,
0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63,
0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b,
0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73,
0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b,
0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83,
0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b,
0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93,
0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b,
0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3,
0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab,
0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3,
0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb,
0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3,
0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb,
0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3,
0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb,
0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3,
0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb,
0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3,
0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb,
0xfc, 0xfd, 0xfe, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff,
};    // 64+256+64 elements

I32 ClipPixInter[CLIP_RANGE] = {
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff00, 0xffffff00, 0xffffff00,
0xffffff00, 0xffffff01, 0xffffff02, 0xffffff03,
0xffffff04, 0xffffff05, 0xffffff06, 0xffffff07,
0xffffff08, 0xffffff09, 0xffffff0a, 0xffffff0b,
0xffffff0c, 0xffffff0d, 0xffffff0e, 0xffffff0f,
0xffffff10, 0xffffff11, 0xffffff12, 0xffffff13,
0xffffff14, 0xffffff15, 0xffffff16, 0xffffff17,
0xffffff18, 0xffffff19, 0xffffff1a, 0xffffff1b,
0xffffff1c, 0xffffff1d, 0xffffff1e, 0xffffff1f,
0xffffff20, 0xffffff21, 0xffffff22, 0xffffff23,
0xffffff24, 0xffffff25, 0xffffff26, 0xffffff27,
0xffffff28, 0xffffff29, 0xffffff2a, 0xffffff2b,
0xffffff2c, 0xffffff2d, 0xffffff2e, 0xffffff2f,
0xffffff30, 0xffffff31, 0xffffff32, 0xffffff33,
0xffffff34, 0xffffff35, 0xffffff36, 0xffffff37,
0xffffff38, 0xffffff39, 0xffffff3a, 0xffffff3b,
0xffffff3c, 0xffffff3d, 0xffffff3e, 0xffffff3f,
0xffffff40, 0xffffff41, 0xffffff42, 0xffffff43,
0xffffff44, 0xffffff45, 0xffffff46, 0xffffff47,
0xffffff48, 0xffffff49, 0xffffff4a, 0xffffff4b,
0xffffff4c, 0xffffff4d, 0xffffff4e, 0xffffff4f,
0xffffff50, 0xffffff51, 0xffffff52, 0xffffff53,
0xffffff54, 0xffffff55, 0xffffff56, 0xffffff57,
0xffffff58, 0xffffff59, 0xffffff5a, 0xffffff5b,
0xffffff5c, 0xffffff5d, 0xffffff5e, 0xffffff5f,
0xffffff60, 0xffffff61, 0xffffff62, 0xffffff63,
0xffffff64, 0xffffff65, 0xffffff66, 0xffffff67,
0xffffff68, 0xffffff69, 0xffffff6a, 0xffffff6b,
0xffffff6c, 0xffffff6d, 0xffffff6e, 0xffffff6f,
0xffffff70, 0xffffff71, 0xffffff72, 0xffffff73,
0xffffff74, 0xffffff75, 0xffffff76, 0xffffff77,
0xffffff78, 0xffffff79, 0xffffff7a, 0xffffff7b,
0xffffff7c, 0xffffff7d, 0xffffff7e, 0xffffff7f,
0xffffff80, 0xffffff81, 0xffffff82, 0xffffff83,
0xffffff84, 0xffffff85, 0xffffff86, 0xffffff87,
0xffffff88, 0xffffff89, 0xffffff8a, 0xffffff8b,
0xffffff8c, 0xffffff8d, 0xffffff8e, 0xffffff8f,
0xffffff90, 0xffffff91, 0xffffff92, 0xffffff93,
0xffffff94, 0xffffff95, 0xffffff96, 0xffffff97,
0xffffff98, 0xffffff99, 0xffffff9a, 0xffffff9b,
0xffffff9c, 0xffffff9d, 0xffffff9e, 0xffffff9f,
0xffffffa0, 0xffffffa1, 0xffffffa2, 0xffffffa3,
0xffffffa4, 0xffffffa5, 0xffffffa6, 0xffffffa7,
0xffffffa8, 0xffffffa9, 0xffffffaa, 0xffffffab,
0xffffffac, 0xffffffad, 0xffffffae, 0xffffffaf,
0xffffffb0, 0xffffffb1, 0xffffffb2, 0xffffffb3,
0xffffffb4, 0xffffffb5, 0xffffffb6, 0xffffffb7,
0xffffffb8, 0xffffffb9, 0xffffffba, 0xffffffbb,
0xffffffbc, 0xffffffbd, 0xffffffbe, 0xffffffbf,
0xffffffc0, 0xffffffc1, 0xffffffc2, 0xffffffc3,
0xffffffc4, 0xffffffc5, 0xffffffc6, 0xffffffc7,
0xffffffc8, 0xffffffc9, 0xffffffca, 0xffffffcb,
0xffffffcc, 0xffffffcd, 0xffffffce, 0xffffffcf,
0xffffffd0, 0xffffffd1, 0xffffffd2, 0xffffffd3,
0xffffffd4, 0xffffffd5, 0xffffffd6, 0xffffffd7,
0xffffffd8, 0xffffffd9, 0xffffffda, 0xffffffdb,
0xffffffdc, 0xffffffdd, 0xffffffde, 0xffffffdf,
0xffffffe0, 0xffffffe1, 0xffffffe2, 0xffffffe3,
0xffffffe4, 0xffffffe5, 0xffffffe6, 0xffffffe7,
0xffffffe8, 0xffffffe9, 0xffffffea, 0xffffffeb,
0xffffffec, 0xffffffed, 0xffffffee, 0xffffffef,
0xfffffff0, 0xfffffff1, 0xfffffff2, 0xfffffff3,
0xfffffff4, 0xfffffff5, 0xfffffff6, 0xfffffff7,
0xfffffff8, 0xfffffff9, 0xfffffffa, 0xfffffffb,
0xfffffffc, 0xfffffffd, 0xfffffffe, 0xffffffff,
0x00000000, 0x00000001, 0x00000002, 0x00000003,
0x00000004, 0x00000005, 0x00000006, 0x00000007,
0x00000008, 0x00000009, 0x0000000a, 0x0000000b,
0x0000000c, 0x0000000d, 0x0000000e, 0x0000000f,
0x00000010, 0x00000011, 0x00000012, 0x00000013,
0x00000014, 0x00000015, 0x00000016, 0x00000017,
0x00000018, 0x00000019, 0x0000001a, 0x0000001b,
0x0000001c, 0x0000001d, 0x0000001e, 0x0000001f,
0x00000020, 0x00000021, 0x00000022, 0x00000023,
0x00000024, 0x00000025, 0x00000026, 0x00000027,
0x00000028, 0x00000029, 0x0000002a, 0x0000002b,
0x0000002c, 0x0000002d, 0x0000002e, 0x0000002f,
0x00000030, 0x00000031, 0x00000032, 0x00000033,
0x00000034, 0x00000035, 0x00000036, 0x00000037,
0x00000038, 0x00000039, 0x0000003a, 0x0000003b,
0x0000003c, 0x0000003d, 0x0000003e, 0x0000003f,
0x00000040, 0x00000041, 0x00000042, 0x00000043,
0x00000044, 0x00000045, 0x00000046, 0x00000047,
0x00000048, 0x00000049, 0x0000004a, 0x0000004b,
0x0000004c, 0x0000004d, 0x0000004e, 0x0000004f,
0x00000050, 0x00000051, 0x00000052, 0x00000053,
0x00000054, 0x00000055, 0x00000056, 0x00000057,
0x00000058, 0x00000059, 0x0000005a, 0x0000005b,
0x0000005c, 0x0000005d, 0x0000005e, 0x0000005f,
0x00000060, 0x00000061, 0x00000062, 0x00000063,
0x00000064, 0x00000065, 0x00000066, 0x00000067,
0x00000068, 0x00000069, 0x0000006a, 0x0000006b,
0x0000006c, 0x0000006d, 0x0000006e, 0x0000006f,
0x00000070, 0x00000071, 0x00000072, 0x00000073,
0x00000074, 0x00000075, 0x00000076, 0x00000077,
0x00000078, 0x00000079, 0x0000007a, 0x0000007b,
0x0000007c, 0x0000007d, 0x0000007e, 0x0000007f,
0x00000080, 0x00000081, 0x00000082, 0x00000083,
0x00000084, 0x00000085, 0x00000086, 0x00000087,
0x00000088, 0x00000089, 0x0000008a, 0x0000008b,
0x0000008c, 0x0000008d, 0x0000008e, 0x0000008f,
0x00000090, 0x00000091, 0x00000092, 0x00000093,
0x00000094, 0x00000095, 0x00000096, 0x00000097,
0x00000098, 0x00000099, 0x0000009a, 0x0000009b,
0x0000009c, 0x0000009d, 0x0000009e, 0x0000009f,
0x000000a0, 0x000000a1, 0x000000a2, 0x000000a3,
0x000000a4, 0x000000a5, 0x000000a6, 0x000000a7,
0x000000a8, 0x000000a9, 0x000000aa, 0x000000ab,
0x000000ac, 0x000000ad, 0x000000ae, 0x000000af,
0x000000b0, 0x000000b1, 0x000000b2, 0x000000b3,
0x000000b4, 0x000000b5, 0x000000b6, 0x000000b7,
0x000000b8, 0x000000b9, 0x000000ba, 0x000000bb,
0x000000bc, 0x000000bd, 0x000000be, 0x000000bf,
0x000000c0, 0x000000c1, 0x000000c2, 0x000000c3,
0x000000c4, 0x000000c5, 0x000000c6, 0x000000c7,
0x000000c8, 0x000000c9, 0x000000ca, 0x000000cb,
0x000000cc, 0x000000cd, 0x000000ce, 0x000000cf,
0x000000d0, 0x000000d1, 0x000000d2, 0x000000d3,
0x000000d4, 0x000000d5, 0x000000d6, 0x000000d7,
0x000000d8, 0x000000d9, 0x000000da, 0x000000db,
0x000000dc, 0x000000dd, 0x000000de, 0x000000df,
0x000000e0, 0x000000e1, 0x000000e2, 0x000000e3,
0x000000e4, 0x000000e5, 0x000000e6, 0x000000e7,
0x000000e8, 0x000000e9, 0x000000ea, 0x000000eb,
0x000000ec, 0x000000ed, 0x000000ee, 0x000000ef,
0x000000f0, 0x000000f1, 0x000000f2, 0x000000f3,
0x000000f4, 0x000000f5, 0x000000f6, 0x000000f7,
0x000000f8, 0x000000f9, 0x000000fa, 0x000000fb,
0x000000fc, 0x000000fd, 0x000000fe, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
0x000000ff, 0x000000ff, 0x000000ff, 0x000000ff,
};    // 2048 elements
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3enc.cpp ===
#define P6Version 0
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * e3enc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  H263InitEncoderInstance
 * 	H263Compress
 *  H263TermEncoderInstance
 *
 */
//
// $Author:   JMCVEIGH	$
// $Date:   22 Apr 1997 10:44:58  $
// $Archive:   S:\h26x\src\enc\e3enc.cpv  $
// $Header:   S:\h26x\src\enc\e3enc.cpv   1.185   22 Apr 1997 10:44:58   gmlim  $
// $Log:   S:\h26x\src\enc\e3enc.cpv  $
// 
//    Rev 1.185   22 Apr 1997 10:44:58   gmlim
// Change to not return an ICERR_ERROR in H263Compress() when a PB frame
// is dropped due to 8k/32k buffer size overflow.  ICERR_OK will be
// returned and the encoded P frame will be output.
//
//	  Rev 1.184   18 Apr 1997 10:45:18	 JMCVEIGH
// Clean-up of InitMEState when resiliency is turned on. Before, we
// would duplicate the number of GOBs forced to be intra if packet
// loss was requested.
//
//	  Rev 1.183   18 Apr 1997 08:43:22	 gmlim
// Fixed a bug where uAdjCumFrmSize was not being updated when RTP was
// disabled.
//
//	  Rev 1.182   17 Apr 1997 17:12:20	 gmlim
// Added u32sizeBSnEBS to indicate the total buffer size.  Changed
// u32sizeBitBuffer to indicate the 8k/32k frame size without the
// RTP extension and trailer.  Added check for buffer overflow before
// attaching the EBS and trailer to a PB frame.  Also, added
// uAdjCumFrmSize to be used with rate control in the IA case.
//
//	  Rev 1.181   17 Mar 1997 20:22:06	 MDUDA
// Adjusted calls to motion estimation to use pseudo stack space.
// Moved local storage to encoder catalog from H263Compress.
// This fixes were needed to support 16-bit apps that had insufficient
// stack space.
//
//	  Rev 1.180   12 Mar 1997 16:51:02	 CLORD
// now check for NULL in H263TermEncoder
//
//	  Rev 1.179   11 Mar 1997 13:47:36	 JMCVEIGH
// Catch AVIIF_KEYFRAME flag for coding as an INTRA frame. Some
// apps. use ICCOMPRESS_KEYFRAME, others AVIIF_KEYFRAME.
//
//	  Rev 1.178   10 Feb 1997 11:43:26	 JMCVEIGH
//
// Support for new interpretation of blocking filter -
// allow for motion vectors outside of the reference picture.
//
//	  Rev 1.177   05 Feb 1997 13:07:44	 JMCVEIGH
//
// Further clean-up of improved PB.
//
//	  Rev 1.176   05 Feb 1997 12:18:16	 JMCVEIGH
// Pass GOBHeaderPresent parameter to MMxEDTQ() for EMV bug fix
// support latest H.263+ draft bitstream spec, and support for
// separate improved PB-frame flag.
//
//	  Rev 1.175   20 Jan 1997 17:02:16	 JMCVEIGH
//
// Allow UMV without AP (MMX only).
//
//	  Rev 1.174   14 Jan 1997 17:55:04	 JMCVEIGH
// Allow in-the-loop deblocking filter on IA encoder.
//
//	  Rev 1.173   09 Jan 1997 13:49:46	 MDUDA
// Put emms instruction at end of H263Compress for MMX.
//
//	  Rev 1.172   08 Jan 1997 11:37:22	 BECHOLS
// Changed ini file name to H263Test.ini
//
//	  Rev 1.171   30 Dec 1996 19:54:08	 MDUDA
// Passing input format to encoder initializer so input color convertors
// can be initialized.
//
//	  Rev 1.170   19 Dec 1996 16:32:52	 MDUDA
// Modified call to colorCnvtFrame to support H263 backward compatibility.
//
//	  Rev 1.169   19 Dec 1996 16:01:38	 JMCVEIGH
// Fixed turning off of deblocking filter if not MMX.
//
//	  Rev 1.168   16 Dec 1996 17:50:00	 JMCVEIGH
// Support for improved PB-frame mode and 8x8 motion vectors if
// deblocking filter selected (no OBMC unless advanced prediction
// also selected).
//
//	  Rev 1.167   16 Dec 1996 13:34:46	 MDUDA
// Added support for H263' codec plus some _CODEC_STATS changes.
//
//	  Rev 1.166   11 Dec 1996 15:02:06	 JMCVEIGH
// 
// Turning on of deblocking filter and true B-frames. Currently
// only deblocking filter is implemented. Also, we do not automatically
// turn on 8x8 motion vectors when the deblocking filter is selected.
// Will use 8x8 vectors when the OBMC part of AP can be selectively
// turned off.
// 
//    Rev 1.165   09 Dec 1996 17:57:24   JMCVEIGH
// Added support for arbitrary frame size support.
// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
// Normally, application will pass identical (arbitrary) frame
// sizes in lParam1 and lParam2 of CompressBegin(). If 
// cropping/stretching desired to convert to standard frame sizes,
// application should pass the desired output size in lParam2 and
// the input size in lParam1.
// 
//    Rev 1.164   09 Dec 1996 09:49:56   MDUDA
// 
// Modified for H263P.
// 
//    Rev 1.163   05 Dec 1996 16:49:46   GMLIM
// Changed the way RTP packetization was done to guarantee proper packet
// size.  Modifications made to RTP related function calls in H263Compress().
// 
//    Rev 1.162   03 Dec 1996 08:53:22   GMLIM
// Move the check for TR==TRPrev a few lines forward so that it is done
// before any write to the bitstream buffer.
// 
//    Rev 1.161   03 Dec 1996 08:47:36   KLILLEVO
// improved overflow resiliency for PB-frames. Still not perfect, since
// that would require re-encoding of parts of the P-frames as well as the
// corresponding parts of the B-frames.
// 
//    Rev 1.160   27 Nov 1996 16:15:50   gmlim
// Modified RTP bitstream bufferring to improve efficiency and also to
// avoid internal bitstream buffer overflow.
// 
//    Rev 1.159   26 Nov 1996 16:28:30   GMLIM
// Added error checking for TR == TRPrev.  Merged two sections of identical
// code into one block common to both MMX and non-MMX cases.
//
//    Rev 1.157   11 Nov 1996 09:14:26   JMCVEIGH
// Fixed bug that caused all blocks in interframes to be intra coded
// after the second I frame in a sequence. Now the ME states are
// re-initialized when the previous frame was an I frame and the current
// frame is a non-intra frame (also reinitialized when the AP state
// changes).
// 
//    Rev 1.156   06 Nov 1996 16:29:20   gmlim
// Removed H263ModeC.
// 
//    Rev 1.155   05 Nov 1996 13:33:22   GMLIM
// Added mode c support for mmx case.
// 
//    Rev 1.154   03 Nov 1996 18:56:46   gmlim
// Added mode c support for rtp bs ext.
// 
//    Rev 1.153   24 Oct 1996 15:25:54   KLILLEVO
// 
// removed two string allocations no longer needed
// 
//    Rev 1.152   24 Oct 1996 15:19:40   KLILLEVO
// 
// changed loglevel for instance events to 2 (from 4)
// 
//    Rev 1.151   23 Oct 1996 17:13:36   KLILLEVO
// 
// typo in one DbgLog statement fixed
// 
//    Rev 1.150   23 Oct 1996 17:11:36   KLILLEVO
// changed to DbgLog()
// 
//    Rev 1.149   22 Oct 1996 14:51:10   KLILLEVO
// Blocktype initialization in InitMEState() is  now only called if
// the AP mode has changed from the previous picture.
// 
//    Rev 1.148   18 Oct 1996 16:57:00   BNICKERS
// Fixes for EMV
// 
//    Rev 1.147   10 Oct 1996 16:43:00   BNICKERS
// Initial debugging of Extended Motion Vectors.
// 
//    Rev 1.146   04 Oct 1996 17:05:22   BECHOLS
// When we set the output flags lpdwFlags to AVIIF_KEYFRAME, we also set
// dwFlags to ICCOMPRESS_KEYFRAME, to support changes Sylvia Day made to
// CXQ_MAIN.CPP
// 
//    Rev 1.145   04 Oct 1996 08:47:40   BNICKERS
// Add EMV.
// 
//    Rev 1.144   16 Sep 1996 16:49:52   CZHU
// Changed interface for RTP BS initialization for smaller packet size
// 
//    Rev 1.143   13 Sep 1996 12:48:30   KLILLEVO
// cleaned up intra update code to make it more understandable
// 
//    Rev 1.142   12 Sep 1996 14:46:14   KLILLEVO
// finished baseline+PB
// 
//    Rev 1.141   12 Sep 1996 14:09:58   KLILLEVO
// started baseline+PB changes (not finished)
// added PVCS log
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
char gsz2[32];
char gsz3[32];
#endif

#define DUMPFILE 0

/* QP level for which the AP mode is turned off for IA */
/* on MMX AP is always used if the caller asks for it */
const int AP_MODE_QP_LEVEL = 11;



/*
  Pick a resiliency strategy.
*/

#define REQUESTED_KEY_FRAME 0
#define PERIODIC_KEY_FRAME  1
#define FAST_RECOVERY       2
#define SLOW_RECOVERY       3

#define RESILIENCY_STRATEGY PERIODIC_KEY_FRAME

#define PERIODIC_KEY_FRAME_PERIODICITY 15     // Select periodicity (max 32767)

#define UNRESTRICTED_MOTION_FRAMES 16 // Number of frames that don't have an
                                      // Intra slice.  0 for FAST_RECOVERY.
                                      // Modest amount for SLOW_RECOVERY.
                                      // Unimportant for other strategies.

#define REUSE_DECODE 1  // Set to one if second decode (as under Videdit)
                        // can reuse the encoder's decode.

/* 
 * Need this hack to allow temporarily turning off PB frames
 * when they are turned on usin the INI file.
 */
#define	TEMPORARILY_FALSE  88

#ifdef STAT
#define STATADDRESS 0x250
#define ELAPSED_ENCODER_TIME 1  // Must be set for other timers to work right.
#define SAMPLE_RGBCONV_TIME  0  // Time conversion of RGB24 to YUV9 step.
#define SAMPLE_MOTION_TIME   0  // Time motion estimation step.
#define SAMPLE_ENCBLK_TIME   0  // Time encode block layer step.
#define SAMPLE_ENCMBLK_TIME  0  // Time encode macroblock layer step.
#define SAMPLE_ENCVLC_TIME   0  // Time encode VLC step.
#define SAMPLE_COMPAND_TIME  1  // Time decode of encoded block step.
#else
#define STATADDRESS 0x250
#define ELAPSED_ENCODER_TIME 0  // Must be set for other timers to work right.
#define SAMPLE_RGBCONV_TIME  0  // Time conversion of RGB24 to YUV9 step.
#define SAMPLE_MOTION_TIME   0  // Time motion estimation step.
#define SAMPLE_ENCBLK_TIME   0  // Time encode block layer step.
#define SAMPLE_ENCMBLK_TIME  0  // Time encode macroblock layer step.
#define SAMPLE_ENCVLC_TIME   0  // Time encode VLC step.
#define SAMPLE_COMPAND_TIME  0  // Time decode of encoded block step.
#endif

//#pragma warning(disable:4101)
//#pragma warning(disable:4102)

#if ELAPSED_ENCODER_TIME
// #include "statx.h"	 --- commented out to allow updating dependencies

DWORD Elapsed, Sample;
DWORD TotalElapsed, TotalSample, TimedIterations;

#endif

//#define PITCH  384
#define PITCHL 384L
#define DEFAULT_DCSTEP 8
#define DEFAULT_QUANTSTEP 36
#define DEFAULT_QUANTSTART 30

#define LEFT        0
#define INNERCOL    1
#define NEARRIGHT   2
#define RIGHT       3

#define TOP         0
#define INNERROW    4
#define NEARBOTTOM  8
#define BOTTOM     12

#ifdef USE_MMX // { USE_MMX
extern BOOL MMxVersion;   // from ccpuvsn.cpp

BOOL MMX_Enabled = MMxVersion;
#endif // } USE_MMX

BOOL ToggleAP = TRUE;
BOOL TogglePB = TRUE;

U8 u8QPMax;

#ifdef REUSE_DECODE
extern struct {               // Communicate Encoder's decode to display decode.
  U8 FAR * Address;                    // Addr at which encoded frame is placed.
  DECINSTINFO BIGG * PDecoderInstInfo; // Encoder's decoder instance.
  unsigned int  FrameNumber;           // Frame number last encoded, mod 128.
} CompandedFrame;
#endif

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
#pragma message ("Current log encode timing computations handle 105 frames max")
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo);
void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo);
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

/*
 * Look up table for quarter pel to half pel conversion of chroma MV's.
 * The motion vectors value is half the index value. The input to the
 * array must be biased by +64.
 */
const char QtrPelToHalfPel[] = {
-32, -31, -31, -31, -30, -29, -29, -29, -28, -27, -27, -27, -26, -25, -25, -25,
-24, -23, -23, -23, -22, -21, -21, -21, -20, -19, -19, -19, -18, -17, -17, -17,
-16, -15, -15, -15, -14, -13, -13, -13, -12, -11, -11, -11, -10,  -9,  -9,  -9, 
 -8,  -7,  -7,  -7,  -6,  -5,  -5,  -5,  -4,  -3,  -3,  -3,  -2,  -1,  -1,  -1,
  0,   1,   1,   1,   2,   3,   3,   3,   4,   5,   5,   5,   6,   7,   7,   7,
  8,   9,   9,   9,  10,  11,  11,  11,  12,  13,  13,  13,  14,  15,  15,  15,
 16,  17,  17,  17,  18,  19,  19,  19,  20,  21,  21,  21,  22,  23,  23,  23,
 24,  25,  25,  25,  26,  27,  27,  27,  28,  29,  29,  29,  30,  31,  31,  31};

/*
 * Look-up table for converting the sum of four motion vectors to a chroma 
 * motion vector. Since motion vectors are in the range [-32,31.5], their
 * indices are in the range [-64,63]. Hence the sum are in the range [-256,248].
 * The input to the array must be biased by +256.
 */
const char SixteenthPelToHalfPel[] = {
-32, -32, -32, -31, -31, -31, -31, -31, -31, -31, -31, -31, -31, -31, -30, -30,
-30, -30, -30, -29, -29, -29, -29, -29, -29, -29, -29, -29, -29, -29, -28, -28,
-28, -28, -28, -27, -27, -27, -27, -27, -27, -27, -27, -27, -27, -27, -26, -26,
-26, -26, -26, -25, -25, -25, -25, -25, -25, -25, -25, -25, -25, -25, -24, -24,
-24, -24, -24, -23, -23, -23, -23, -23, -23, -23, -23, -23, -23, -23, -22, -22,
-22, -22, -22, -21, -21, -21, -21, -21, -21, -21, -21, -21, -21, -21, -20, -20,
-20, -20, -20, -19, -19, -19, -19, -19, -19, -19, -19, -19, -19, -19, -18, -18,
-18, -18, -18, -17, -17, -17, -17, -17, -17, -17, -17, -17, -17, -17, -16, -16,
-16, -16, -16, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -14, -14,
-14, -14, -14, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -12, -12,
-12, -12, -12, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -10, -10,
-10, -10, -10,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -8,  -8,
 -8,  -8,  -8,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -6,  -6,
 -6,  -6,  -6,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -4,  -4,
 -4,  -4,  -4,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -2,  -2,
 -2,  -2,  -2,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   0,   0,
  0,   0,   0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,
  2,   2,   2,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,   4,   4,
  4,   4,   4,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   6,   6,
  6,   6,   6,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   8,   8,
  8,   8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  10,
 10,  10,  10,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  11,  12,  12,
 12,  12,  12,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  13,  14,  14,
 14,  14,  14,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  15,  16,  16,
 16,  16,  16,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  18,  18,
 18,  18,  18,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  20,  20,
 20,  20,  20,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  21,  22,  22,
 22,  22,  22,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  23,  24,  24,
 24,  24,  24,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  25,  26,  26,
 26,  26,  26,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  27,  28,  28,
 28,  28,  28,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  29,  30,  30,
 30,  30,  30,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  32,  32};

void InitMEState(T_H263EncoderCatalog *EC, ICCOMPRESS *lpicComp, T_CONFIGURATION * pConfiguration);

UN FindNewQuant(
	T_H263EncoderCatalog *EC, 
	UN gquant_prev,
	UN uComFrmSize,
	UN GOB,
	U8 u8QPMax,
	U8 u8QPMin,
	BOOL bBitRateControl,
	BOOL bGOBoverflowWarning
	);

static void encodeFrameHeader(
    T_H263EncoderCatalog *  EC,
    U8                   ** ppCurBitStream,
    U8                   *  u8BitOffset,
    BOOL                    bPBframe
);

/*
static void copyEdgePels(T_H263EncoderCatalog *  EC);
*/

extern "C" {
  void ExpandPlane(U32, U32, U32, U32);
}

#ifdef USE_MMX // { USE_MMX
static void Check_InterCodeCnt_MMX(T_H263EncoderCatalog *, U32);
#endif // } USE_MMX

static void Check_InterCodeCnt    (T_H263EncoderCatalog *, U32);

static void calcGOBChromaVectors(
	T_H263EncoderCatalog *EC,
	U32             StartingMB,
	T_CONFIGURATION *pConfiguration
);

static void calcBGOBChromaVectors(
	 T_H263EncoderCatalog *EC,
	 const U32             StartingMB
);

static void GetEncoderOptions(T_H263EncoderCatalog * EC);

/*static U8 StillImageQnt[] = {
	31, 29, 27, 26, 25, 24, 23, 22, 21, 20, 
	19, 18, 17, 16, 15, 14, 14, 13, 13, 12,
	12, 11, 11, 10, 10,  9,  9,  8,  8,  7,
	 7,  6,  6,  6,  5,  5,  5,  4,  4,  4,
	 3,  3,  3,  3}; */
  
static U8 StillImageQnt[] = {
	31, 18, 12,	10, 8, 6, 5, 4, 4, 3}; //ia

#ifdef USE_MMX // { USE_MMX
static U8 StillImageQnt_MMX[] = {
	31, 12, 10,	8, 6, 4, 3, 3, 3, 2};  //mmx
#endif // } USE_MMX
  
const int numStillImageQnts = 10;

#ifdef COUNT_BITS
static void InitBits(T_H263EncoderCatalog * EC);
void InitCountBitFile();
void WriteCountBitFile(T_BitCounts *Bits);
#endif


#ifdef USE_MMX // { USE_MMX
/*
 * Exception Filter for access violations in MMxEDTQ B-frame motion estimation
 * No memory is allocation before run-time, it is only reserved.
 * Then, when an access violation occurs, more memory is allocated,
 * provided the access violation is withing the reserved memory area.
 */


int ExceptionFilterForMMxEDTQ(
	LPEXCEPTION_POINTERS exc, 
	LPVOID lpMBRVS,
	BOOL fLuma)
{
	DWORD dwCode;
	LPVOID lpAddress;

	FX_ENTRY("ExceptionFilterForMMxEDTQ")

	dwCode = exc->ExceptionRecord->ExceptionCode;

	// check that this is an access violation
	if (dwCode != EXCEPTION_ACCESS_VIOLATION)
		return EXCEPTION_CONTINUE_SEARCH;

	lpAddress = (LPVOID)exc->ExceptionRecord->ExceptionInformation[1];

	// check for access violation outside address range
	if (lpAddress < lpMBRVS)
		return EXCEPTION_CONTINUE_SEARCH;  // this exception is not handled here  

	if (fLuma)
	{
		if ((DWORD)lpAddress > ((DWORD)lpMBRVS + 18*65*22*3*4))
			return EXCEPTION_CONTINUE_SEARCH;	// this exception is not handled here
	}
	else
	{
		if ((DWORD)lpAddress > ((DWORD)lpMBRVS + 18*65*22*3*2))
			return EXCEPTION_CONTINUE_SEARCH;	// this exception is not handled here
	}

	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Access Violation. Don't worry - be happy - committing another page\r\n", _fx_));

	// commit another page
	if (VirtualAlloc(lpAddress,4095,MEM_COMMIT,PAGE_READWRITE) == NULL)
	{
		return EXCEPTION_CONTINUE_SEARCH;	// could not commit
		// this should never happen, since RESERVE was successfull
	}

	// return and try instruction causing the access violation again
	return EXCEPTION_CONTINUE_EXECUTION;
}
#endif // } USE_MMX


/*******************************************************************************
H263InitEncoderGlobal -- This function initializes the global tables used by
                        the H263 encoder.  Note that in 16-bit Windows, these
                        tables are copied to the per-instance data segment, so
                        that they can be used without segment override prefixes.
                        In 32-bit Windows, the tables are left in their staticly
                        allocated locations.
*******************************************************************************/
LRESULT H263InitEncoderGlobal(void)
{
    // Initialize fixed length tables for INTRADC
    InitVLC();

    return ICERR_OK;
}

/*******************************************************************************
H263InitEncoderInstance -- This function allocates and initializes the
                          per-instance tables used by the H263 encoder.
*******************************************************************************/
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER lpbiInput, LPCODINST lpCompInst)
#else
LRESULT H263InitEncoderInstance(LPCODINST lpCompInst)
#endif
{

	LRESULT ret;

	UN i;

  	U32 Sz;

  	T_H263EncoderInstanceMemory * P32Inst;
  	T_H263EncoderCatalog * EC;

#if ELAPSED_ENCODER_TIME
  	TotalElapsed = 0;
  	TotalSample = 0;
  	TimedIterations = 0;
#endif

	T_CONFIGURATION * pConfiguration;
	UN uIntraQP;
	UN uInterQP;

	FX_ENTRY("H263InitEncoderInstance")

  /*
   * Allocate memory if instance is not initialized.
   * TO ADD: If instance IS intialized, we have to check to see
   * if important parameters have changed, such as frame size, and
   * then reallocate memory if necessary.
   */
  	if(lpCompInst->Initialized == FALSE)
  	{
    	/*
     	* Calculate size of encoder instance memory needed. We add the size
     	* of a MacroBlock Action Descriptor to it since we want the MacroBlock
        * Action Stream (which is the first element of the memory structure)
        * to be aligned to a boundary equal to the size of a descriptor.
     	*/
    	Sz = sizeof(T_H263EncoderInstanceMemory) + sizeof(T_MBlockActionStream);

    	/*
     	* Allocate the memory.
     	*/
//    	lpCompInst->hEncoderInst = GlobalAlloc(GHND, Sz);

		// VirtualAlloc automatically zeros memory. The bitstream
		// needs to be zeroed when I change this to HeapAlloc.
    	lpCompInst->hEncoderInst = VirtualAlloc(
    		NULL,  // can be allocated anywhere
    		Sz,    // number of bytes to allocate
    		MEM_RESERVE | MEM_COMMIT,  // reserve & commit memory
    		PAGE_READWRITE);	 // protection

#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		wsprintf(gsz1, "E3ENC: (VM) %7ld Ln %5ld\0", Sz, __LINE__);
		AddName((unsigned int)lpCompInst->hEncoderInst, gsz1);
#endif

		/* Indicate that we have allocated memory for the compressor instance. */
		lpCompInst->Initialized = TRUE;
  	}
/*  else
  	{
    	// check if parameters have changed, thay may make us have
		// to reallocate memory.
  	}	
*/

//  	lpCompInst->EncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
  	lpCompInst->EncoderInst = lpCompInst->hEncoderInst;
  	if (lpCompInst->hEncoderInst == NULL)
  	{
    	ret = ICERR_MEMORY;
    	goto  done;
  	}

   /*
   	* Calculate the 32 bit instance pointer starting at required boundary.
   	*/
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) lpCompInst->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
   /*
   	* The encoder catalog is at the start of the per-instance data.
   	*/
  	EC = &(P32Inst->EC);

	#ifdef COUNT_BITS
	InitCountBitFile();
	#endif

	#ifdef ENCODE_STATS
	InitQuantStats();
	InitFrameSizeStats();
	InitPSNRStats();
	#endif /* ENCODE_STATS */

	/* Initialize the Configuration information 
	 */
	pConfiguration = &(lpCompInst->Configuration);
#if 0
	if (LoadConfiguration(pConfiguration) == FALSE)
		GetConfigurationDefaults(pConfiguration);
#endif
	pConfiguration->bInitialized = TRUE;
	pConfiguration->bCompressBegin = TRUE;
	EC->hBsInfoStream= NULL;

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	// We really want those timings to match the actual use we
	// will make of the codec. So initialize it with the same values
	pConfiguration->bRTPHeader = TRUE;
	pConfiguration->unPacketSize = 512;
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

	DEBUGMSG(ZONE_INIT, ("%s: Encoder Configuration Options: bRTPHeader=%d, unPacketSize=%d, bEncoderResiliency=%d, bDisallowPosVerMVs=%d\r\n", _fx_, (int)pConfiguration->bRTPHeader, (int)pConfiguration->unPacketSize, (int)pConfiguration->bEncoderResiliency, (int)pConfiguration->bDisallowPosVerMVs));
	DEBUGMSG(ZONE_INIT, ("%s: Encoder Configuration Options: bDisallowAllVerMVs=%d, unPercentForcedUpdate=%d, unDefaultIntraQuant=%d, unDefaultInterQuant=%d\r\n", _fx_, (int)pConfiguration->bDisallowAllVerMVs, (int)pConfiguration->unPercentForcedUpdate, (int)pConfiguration->unDefaultIntraQuant, (int)pConfiguration->unDefaultInterQuant));
	
   /*
   	* Initialize encoder catalog.
   	*/
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
	// In H.263+, we encode and decode the padded frames (padded to the right
	// and bottom to multiples of 16). The actual frame dimensions are used
	// for display purposes only.
	EC->FrameHeight = (lpCompInst->yres + 0xf) & ~0xf;
	EC->FrameWidth = (lpCompInst->xres + 0xf) & ~0xf;
	EC->uActualFrameHeight = lpCompInst->yres;
	EC->uActualFrameWidth = lpCompInst->xres;

	ASSERT(sizeof(T_H263EncoderCatalog) == sizeof_T_H263EncoderCatalog);
	{
		int found_cc = TRUE;
		if (BI_RGB == lpCompInst->InputCompression) {
#ifdef USE_BILINEAR_MSH26X
			if (24 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB24toYUV12;
#else
			if (32 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB32toYUV12;
			} else if (24 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB24toYUV12;
#endif
			} else if (16 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = RGB16555toYUV12;
			} else if (8 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = CLUT8toYUV12;
			} else if (4 == lpCompInst->InputBitWidth) {
				EC->ColorConvertor = CLUT4toYUV12;
			} else {
				found_cc = FALSE;
				ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
			}
		} else if (FOURCC_YVU9 == lpCompInst->InputCompression) {
			EC->ColorConvertor = YVU9toYUV12;
		} else if (FOURCC_YUY2 == lpCompInst->InputCompression) {
			EC->ColorConvertor = YUY2toYUV12;
		} else if (FOURCC_UYVY == lpCompInst->InputCompression) {
			EC->ColorConvertor = UYVYtoYUV12;
		} else if ((FOURCC_YUV12 == lpCompInst->InputCompression) || (FOURCC_IYUV == lpCompInst->InputCompression)) {
			EC->ColorConvertor = YUV12toEncYUV12;
		} else {
			found_cc = FALSE;
			ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
		}
		if (found_cc) {
			colorCnvtInitialize(lpbiInput, EC->ColorConvertor);
		}
	}
#else
  	EC->FrameHeight = lpCompInst->yres;
  	EC->FrameWidth  = lpCompInst->xres;
#endif
  	EC->FrameSz		= lpCompInst->FrameSz;
  	EC->NumMBRows	= EC->FrameHeight >> 4;
  	EC->NumMBPerRow	= EC->FrameWidth  >> 4;
  	EC->NumMBs		= EC->NumMBRows * EC->NumMBPerRow;

	// This should default to zero. If RTP is used, it will be changed later
	EC->uNumberForcedIntraMBs = 0;
#ifdef H263P
	EC->uNextIntraMB = 0;
#else
	if(pConfiguration->bEncoderResiliency &&
	   pConfiguration->unPercentForcedUpdate &&
	   pConfiguration->unPacketLoss) 
	{//Chad Intra GOB
	//	EC->uNumberForcedIntraMBs = ((EC->NumMBs * pConfiguration->unPercentForcedUpdate) + 50) / 100;
		EC->uNextIntraMB = 0;
	}
#endif

  	// Store pointers to current frame in the catalog.
  	EC->pU8_CurrFrm        = P32Inst->u8CurrentPlane;
  	EC->pU8_CurrFrm_YPlane = EC->pU8_CurrFrm + 16;
  	EC->pU8_CurrFrm_UPlane = EC->pU8_CurrFrm_YPlane + YU_OFFSET;
  	EC->pU8_CurrFrm_VPlane = EC->pU8_CurrFrm_UPlane + UV_OFFSET;

  	// Store pointers to the previous frame in the catalog.
  	EC->pU8_PrevFrm        = P32Inst->u8PreviousPlane;
  	EC->pU8_PrevFrm_YPlane = EC->pU8_PrevFrm + 16*PITCH + 16;
  	EC->pU8_PrevFrm_UPlane = EC->pU8_PrevFrm_YPlane + YU_OFFSET;
  	EC->pU8_PrevFrm_VPlane = EC->pU8_PrevFrm_UPlane + UV_OFFSET;

  	// Store pointers to the future frame in the catalog.
  	EC->pU8_FutrFrm        = P32Inst->u8FuturePlane;
  	EC->pU8_FutrFrm_YPlane = EC->pU8_FutrFrm + 16*PITCH + 16;
  	EC->pU8_FutrFrm_UPlane = EC->pU8_FutrFrm_YPlane + YU_OFFSET;
  	EC->pU8_FutrFrm_VPlane = EC->pU8_FutrFrm_UPlane + UV_OFFSET;

  	// Store pointers to the B frame in the catalog.
  	EC->pU8_BidiFrm     = P32Inst->u8BPlane;
  	EC->pU8_BFrm_YPlane = EC->pU8_BidiFrm + 16;
  	EC->pU8_BFrm_UPlane = EC->pU8_BFrm_YPlane + YU_OFFSET;
  	EC->pU8_BFrm_VPlane = EC->pU8_BFrm_UPlane + UV_OFFSET;

  	// Store pointers to the signature frame in the catalog.
  	EC->pU8_Signature        = P32Inst->u8Signature;
  	EC->pU8_Signature_YPlane = EC->pU8_Signature + 16*PITCH + 16;

  	// Store pointer to the macroblock action stream in the catalog.
  	EC->pU8_MBlockActionStream = P32Inst->MBActionStream;

  	// Store pointer to the GOB DCT coefficient buffer in the catalog.
  	EC->pU8_DCTCoefBuf = P32Inst->piGOB_DCTCoefs;

	// Store pointer to area in which to pre-compute OBMC predictions.
	EC->pU8_PredictionScratchArea = P32Inst->u8PredictionScratchArea;

  	// Store pointer to the bit stream buffer in the catalog.
  	EC->pU8_BitStream = P32Inst->u8BitStream;
  	EC->pU8_BitStrCopy = P32Inst->u8BitStrCopy;

	// Store pointer to the RunValSign triplets for Luma and Chroma
	EC->pI8_MBRVS_Luma   = P32Inst->i8MBRVS_Luma;
	EC->pI8_MBRVS_Chroma = P32Inst->i8MBRVS_Chroma;

	// Reserve virtual memory
	EC->pI8_MBRVS_BLuma   = (I8 *) VirtualAlloc(
		NULL,			          // anywhere
		18*(65*3*22*4),	          // number of bytes
		MEM_RESERVE,              // reserve
		PAGE_READWRITE);		  // access

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz2, "E3ENC: (VM) %7ld Ln %5ld\0", 18*(65*3*22*4), __LINE__);
	AddName((unsigned int)EC->pI8_MBRVS_BLuma, gsz2);
#endif

	EC->pI8_MBRVS_BChroma =  (I8 *) VirtualAlloc(
		NULL,			          // anywhere
		18*(65*3*22*2),	          // number of bytes
		MEM_RESERVE,              // reserve
		PAGE_READWRITE);		  // access

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz3, "E3ENC: (VM) %7ld Ln %5ld\0", 18*(65*3*22*2), __LINE__);
	AddName((unsigned int)EC->pI8_MBRVS_BChroma, gsz3);
#endif

	if (EC->pI8_MBRVS_BLuma == NULL	|| EC->pI8_MBRVS_BChroma == NULL)
	{
    	ret = ICERR_MEMORY;
    	goto  done;
  	}



  	// Store pointer to private copy of decoder instance info.
  	EC->pDecInstanceInfo = &(P32Inst->DecInstanceInfo);

	/*
	 * Check to see if there is an H263test.ini file. If the UseINI key
	 * is not 1, or the INI file is not found, then we allow option
	 * signalling in the ICCOMPRESS structure. If set, the INI
	 * options override the ICCOMPRESS options.
	 */
	GetEncoderOptions(EC);

    EC->u8SavedBFrame = FALSE;

  	// Fill the picture header structure.
  	EC->PictureHeader.TR = 0;
  	EC->PictureHeader.Split = OFF;
  	EC->PictureHeader.DocCamera = OFF;
  	EC->PictureHeader.PicFreeze = OFF;
  	EC->PictureHeader.PB = OFF;		// Leave this off here. It is turned on after the P frame
									// has been encoded, when the PB frame is written.
    EC->prevAP  = 255;
	EC->prevUMV = 255;
#ifdef H263P
	EC->prevDF = 255;
#endif

  	EC->PictureHeader.CPM = 0;
  	EC->PictureHeader.TRB = 0;
  	EC->PictureHeader.DBQUANT = 1;  
  	EC->PictureHeader.PLCI = 0;
  	EC->PictureHeader.PEI = 0;
  	
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	EC->pEncTimingInfo = P32Inst->EncTimingInfo;
#endif // } LOG_ENCODE_TIMINGS_ON

	/*
	 * This flag is used by the encoder to signal that the 
	 * next frame should be encoded as an INTRA regardless of what
	 * the client asks for. This may be either because an error was
	 * detected in compressing the current delta, or to ensure that 
	 * the first frame is encoded INTRA.
	 */
  	EC->bMakeNextFrameKey = TRUE;	// Ensure that we always start with a key frame.

  /*
   * Initialize table with Bit Usage Profile
   */
	for (i = 0; i <= EC->NumMBRows ; i++)
		EC->uBitUsageProfile[i] = i;   // assume linear distribution at first

   /*
  	* Check assumptions about structure sizes and boundary
  	* alignment.
  	*/
  	ASSERT( sizeof(T_Blk) == sizeof_T_Blk )
  	ASSERT( sizeof(T_MBlockActionStream) == sizeof_T_MBlockActionStream )
  	ASSERT( ((sizeof_T_MBlockActionStream-1) & sizeof_T_MBlockActionStream) == 0);  // Size is power of two
  	ASSERT( sizeof(T_H263EncoderCatalog) == sizeof_T_H263EncoderCatalog )

  	// Encoder instance memory should start on a 32 byte boundary.
  	ASSERT( ( (unsigned int)P32Inst & 0x1f) == 0)

  	// MB Action Stream should be on boundary equal to size of a descriptor.
  	ASSERT((((int)EC->pU8_MBlockActionStream) & (sizeof_T_MBlockActionStream-1)) == 0);  // Allocated at right boundary.

  	// Block structure array should be on a 16 byte boundary.
  	ASSERT( ( (unsigned int) &(EC->pU8_MBlockActionStream->BlkY1) & 0xf) == 0)

  	// DCT coefficient array should be on a 32 byte boundary.
  	ASSERT( ( (unsigned int)EC->pU8_DCTCoefBuf & 0x1f) == 0)

  	// Current Frame Buffers should be on 32 byte boundaries.
  	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_YPlane & 0x1f) == 0)
  	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_UPlane & 0x1f) == 0)
  	ASSERT( ( (unsigned int)EC->pU8_CurrFrm_VPlane & 0x1f) == 0)
  	ASSERT( ( (unsigned int)EC->pU8_BFrm_YPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_BFrm_UPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_BFrm_VPlane & 0x1f) == 0x10)

  	// Previous Frame Buffers should be on 32 byte boundaries.
  	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_YPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_UPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_PrevFrm_VPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_FutrFrm_YPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_FutrFrm_UPlane & 0x1f) == 0x10)
  	ASSERT( ( (unsigned int)EC->pU8_FutrFrm_VPlane & 0x1f) == 0x10)
  
  	// Decoder instance structure should be on a DWORD boundary.
  	ASSERT( ( (unsigned int)EC->pDecInstanceInfo & 0x3 ) == 0 )


	/*
 	* Initialize MBActionStream
 	*/
  	int YBlockOffset, UBlockOffset;

  	YBlockOffset	= 0;
  	UBlockOffset = EC->pU8_CurrFrm_UPlane - EC->pU8_CurrFrm_YPlane;

  	for(i = 0; i < EC->NumMBs; i++)
  	{
    	// Clear the counter of the number of consecutive times a
    	// macroblock has been inter coded.
    	(EC->pU8_MBlockActionStream[i]).InterCodeCnt = (i & 0xf);

		// Store offsets to each block in the MB from the beginning of
		// the Y plane.
		(EC->pU8_MBlockActionStream[i]).BlkY1.BlkOffset = YBlockOffset;
		(EC->pU8_MBlockActionStream[i]).BlkY2.BlkOffset = YBlockOffset+8;
		(EC->pU8_MBlockActionStream[i]).BlkY3.BlkOffset = YBlockOffset+PITCH*8;
		(EC->pU8_MBlockActionStream[i]).BlkY4.BlkOffset = YBlockOffset+PITCH*8+8;
		(EC->pU8_MBlockActionStream[i]).BlkU.BlkOffset = UBlockOffset;
		(EC->pU8_MBlockActionStream[i]).BlkV.BlkOffset = UBlockOffset+UV_OFFSET;

		YBlockOffset += 16;
		UBlockOffset += 8;

		(EC->pU8_MBlockActionStream[i]).MBEdgeType = 0xF;
		if ((i % EC->NumMBPerRow) == 0)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &= MBEdgeTypeIsLeftEdge;
		}
		if (((i+1) % EC->NumMBPerRow) == 0)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &=
                            MBEdgeTypeIsRightEdge;
	  		// Set bit six of CodedBlocks to indicate this is the last
	  		// MB of the row.
	  		(EC->pU8_MBlockActionStream[i]).CodedBlocks  |= 0x40;
	  		YBlockOffset += PITCH*16 - EC->NumMBPerRow*16;
	  		UBlockOffset += PITCH*8  - EC->NumMBPerRow*8;
		}
		if (i < EC->NumMBPerRow)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &= MBEdgeTypeIsTopEdge;
		}
		if ((i + EC->NumMBPerRow) >= EC->NumMBs)
		{
			(EC->pU8_MBlockActionStream[i]).MBEdgeType &= MBEdgeTypeIsBottomEdge;
		}

	}	// end of for loop.

  /*
   * Initialize previous frame pointers. For now we can do this from here.
   */
/*
  YBlockAddress	= EC->pU8_PrevFrm_YPlane;
  UBlockAddress = EC->pU8_PrevFrm_UPlane;

  for(i = 0; i < EC->NumMBs; i++)
  {
	(EC->pU8_MBlockActionStream[i]).Blk[0].PastRef = YBlockAddress;
	(EC->pU8_MBlockActionStream[i]).Blk[1].PastRef = YBlockAddress+8;
	(EC->pU8_MBlockActionStream[i]).Blk[2].PastRef = YBlockAddress+PITCH*8;
	(EC->pU8_MBlockActionStream[i]).Blk[3].PastRef = YBlockAddress+PITCH*8+8;
	(EC->pU8_MBlockActionStream[i]).Blk[4].PastRef = UBlockAddress;
	(EC->pU8_MBlockActionStream[i]).Blk[5].PastRef = UBlockAddress+UV_OFFSET;

	// Zero all motion vectors.
	(EC->pU8_MBlockActionStream[i]).Blk[0].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[0].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[1].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[1].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[2].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[2].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[3].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[3].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[4].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[4].PastVMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[5].PastHMV = 0;
	(EC->pU8_MBlockActionStream[i]).Blk[5].PastVMV = 0;

	YBlockAddress += 16;
	UBlockAddress += 8;

	if( (i != 0) && (( (i+1) % EC->NumMBPerRow ) == 0) )
	{
	  YBlockAddress += PITCH*16 - EC->NumMBPerRow*16;
	  UBlockAddress += PITCH*8  - EC->NumMBPerRow*8;
	}

  }	// end of for loop.
*/

   /*
 	* Initialize bit rate controller.
 	*/
	if(pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
	{
		uIntraQP = pConfiguration->unDefaultIntraQuant;
		uInterQP = pConfiguration->unDefaultInterQuant;
	}
	else
	{
		uIntraQP = def263INTRA_QP;
		uInterQP = def263INTER_QP;
	}
	InitBRC(&(EC->BRCState), uIntraQP, uInterQP, EC->NumMBs);

	if (pConfiguration->bRTPHeader)
		H263RTP_InitBsInfoStream(lpCompInst,EC);

   /*
 	* Create a decoder instance and initialize it. DecoderInstInfo must be in first 64K.
 	*/
  	EC->pDecInstanceInfo->xres = lpCompInst->xres;
  	EC->pDecInstanceInfo->yres = lpCompInst->yres;

  	ret = H263InitDecoderInstance(EC->pDecInstanceInfo, H263_CODEC);
  	if (ret != ICERR_OK)
  		goto done1;
  	ret = H263InitColorConvertor(EC->pDecInstanceInfo, YUV12ForEnc);
  	if (ret != ICERR_OK)
  		goto done1;

   /*
  	* Clear initialized memory.
	*/
	// to be added.

   lpCompInst->Initialized = TRUE;
  	ret = ICERR_OK;

#if defined(H263P)
	// Set the pseudo stack space pointer (to be used for motion estimation and
	// whatever else needs extra stack space).
	EC->pPseudoStackSpace =
		((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->u8PseudoStackSpace +
			(SIZEOF_PSEUDOSTACKSPACE - sizeof(DWORD));
#endif

done1:

  	//GlobalUnlock(lpCompInst->hEncoderInst);

done:

  	return ret;

}


/*******************************************************************************
 *
 * H263Compress 
 *   This function drives the compression of one frame
 * Note:
 *   The timing statistics code produces incorrect no. after PB-frame changes 
 *   were made.
 *******************************************************************************/

LRESULT H263Compress(
#ifdef USE_BILINEAR_MSH26X
    LPINST     pi,
#else
    LPCODINST   lpCompInst,		// ptr to compressor instance info.
#endif
    ICCOMPRESS *lpicComp	    // ptr to ICCOMPRESS structure.
)
{
	FX_ENTRY("H263Compress");

#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpCompInst = (LPCODINST)pi->CompPtr;		// ptr to compressor instance info.
#endif
	//	Start PB-frame data
#if !defined(H263P)
	T_FutrPMBData FutrPMBData[GOBs_IN_CIF*MBs_PER_GOB_CIF + 1];
	I8	WeightForwMotion[128];	//	values based on TRb and TRd
	I8	WeightBackMotion[128];	//	values based on TRb and TRd
#endif
	U8	FutrFrmGQUANT[GOBs_IN_CIF];
	//	End PB-frame

	LRESULT ret;
	UN	GOB, SizeBitStream;
	UN	SizeBSnEBS;

#ifdef DEBUG
	UN i;
#endif

    U8	*pCurBitStream;	// pointer to the current location in the bitstream.
    U8	u8bitoffset;	// bit offset in the current byte of the bitstream.

	U32 uCumFrmSize = 0, GOBHeaderMask;
	U32 uAdjCumFrmSize = 0;

	T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    T_MBlockActionStream 		*MBlockActionPtr;

	BOOL  bGOBoverflowWarning = FALSE;	 //RH
	U32   u32tempBuf;					 //RH
	U32   u32sizeBitBuffer; 			 //RH
	U32   u32sizeBSnEBS;

    LPVOID         EncoderInst;
    ICDECOMPRESSEX ICDecExSt;
    ICDECOMPRESSEX DefaultICDecExSt = {
        0,
        NULL, NULL,
        NULL, NULL,
        0, 0, 0, 0,
        0, 0, 0, 0
    };

    unsigned int   gquant, gquant_prev;
    U32			   QP_cumulative;
    U32            IntraSWDTotal, IntraSWDBlocks, InterSWDTotal, InterSWDBlocks;
    int            StartingMB;
    EnumOnOff      bBitRateControl;

    T_CONFIGURATION * pConfiguration = &(lpCompInst->Configuration);

#ifdef ENCODE_STATS
    U32 uBitStreamBytes;
#endif /* ENCODE_STATS */

	U32 iSumSWD = 0, iSumBSWD = 0;
	U32 iSWD = 0, iBSWD = 0;
    U8 u8QPMin;
	// PB-frame variables
    I32 TRb;         
    I32 TRd;         
    I32 j;
    U8 *pP_BitStreamStart;
    U8 *pPB_BitStream;
    U8  u8PB_BitOffset;
    U8 *temp;
	BOOL bEncodePBFrame;
	BOOL bPBFailed;
	U32 u32BFrmZeroThreshold;

    //Chad, intra gob
	int uUsedByIntra=0;
	DWORD dwRTPSize=0;

#if ELAPSED_ENCODER_TIME
    SetStatAdd (STATADDRESS);
    InitStat ();
    ConfigElapsed ();
    ConfigSample ();
    StartElapsed ();
#endif

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	U32 uStartLow;
	U32 uStartHigh;
	U32 uElapsed;
	U32 uBefore;
	U32	uEncodeTime = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	U32 uInputCC = 0;
	U32 uMotionEstimation = 0;
	U32 uFDCT = 0;
	U32 uQRLE = 0;
	U32 uDecodeFrame = 0;
	U32 uZeroingBuffer = 0;
#endif // } DETAILED_ENCODE_TIMINGS_ON
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
#endif // } LOG_ENCODE_TIMINGS_ON

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_START(bTimingThisFrame,uStartLow,uStartHigh);
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#ifdef REUSE_DECODE
    CompandedFrame.Address = NULL;
    CompandedFrame.PDecoderInstInfo = NULL;
    CompandedFrame.FrameNumber = 0xFFFF;
#endif

    ret = ICERR_OK;
    
	// check instance pointer
	if (!lpCompInst)
		return ICERR_ERROR;

    /*
     * Lock the instance data private to the encoder.
     */
    // EncoderInst = (LPVOID)GlobalLock(lpCompInst->hEncoderInst);
    EncoderInst = lpCompInst->hEncoderInst;
    if (EncoderInst == NULL)
    {
		ERRORMESSAGE(("%s: ICERR_MEMORY\r\n", _fx_));
        ret = ICERR_MEMORY;
        goto  done;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));

    // Get pointer to encoder catalog.
    EC = &(P32Inst->EC);

	// Check pointer to encoder catalog
	if (!EC)
		return ICERR_ERROR;

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (EC->uStatFrameCount < ENC_TIMING_INFO_FRAME_COUNT)
	{
		EC->uStartLow = uStartLow;
		EC->uStartHigh = uStartHigh;
	}
	EC->bTimingThisFrame = bTimingThisFrame;
#endif // } LOG_ENCODE_TIMINGS_ON

#ifdef FORCE_ADVANCED_OPTIONS_ON // { FORCE_ADVANCED_OPTIONS_ON
	// Force PB-Frame for testing
	lpicComp->dwFlags |= CODEC_CUSTOM_PB;

	// Force UMV for testing
	lpicComp->dwFlags |= CODEC_CUSTOM_UMV;

	// Force AP for testing
	lpicComp->dwFlags |= CODEC_CUSTOM_AP;

	// Force SAC for testing
	EC->PictureHeader.SAC = ON;

	if (!(lpicComp->dwFlags & ICCOMPRESS_KEYFRAME))
	{
		lpicComp->lFrameNum *= 5;
	}
#endif // } FORCE_ADVANCED_OPTIONS_ON

    /***************************************************************************
     *  Do per-frame initialization.
     **************************************************************************/
	if ((lpicComp->dwFlags & ICCOMPRESS_KEYFRAME) ||
		(*(lpicComp->lpdwFlags) & AVIIF_KEYFRAME) ||
		(EC->bMakeNextFrameKey == TRUE))
    {
		DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Coding an Intra Frame\r\n", _fx_));
        EC->PictureHeader.PicCodType = INTRAPIC;
        EC->bMakeNextFrameKey = FALSE;
        EC->u8SavedBFrame = FALSE;
    }
    else
        EC->PictureHeader.PicCodType = INTERPIC;

   /*
    * Check for H.263 options. This is the location that
	* you can manually enable the options if you want.
	*/
	
    if (!EC->bUseINISettings)
	{
        // Check to see if PB frames is requested.
        // For our particular implementation, unrestricted motion vectors
        // are used when PB is on.
        //
        if (lpicComp->dwFlags & CODEC_CUSTOM_PB)
            EC->u8EncodePBFrame = TRUE;
		else
		{
			EC->u8EncodePBFrame = FALSE;
		}

		// Check to see if advanced prediction is requested. 
        if (lpicComp->dwFlags & CODEC_CUSTOM_AP)
			EC->PictureHeader.AP = ON;
		else
			EC->PictureHeader.AP = OFF;

		// Check to see if advanced prediction is requested. 
        if (lpicComp->dwFlags & CODEC_CUSTOM_UMV)
			EC->PictureHeader.UMV = ON;
		else
			EC->PictureHeader.UMV = OFF;

#ifdef H263P
		if (pConfiguration->bH263PlusState)
		{
			// Check to see if in-the-loop deblocking filter is requested.
			if (pConfiguration->bDeblockingFilterState)
				EC->PictureHeader.DeblockingFilter = ON;
			else
				EC->PictureHeader.DeblockingFilter = OFF;

			// Check to see if improved PB-frame mode requested.
			if (pConfiguration->bImprovedPBState)
			{
				EC->PictureHeader.ImprovedPB = ON;
				EC->u8EncodePBFrame = TRUE;
			}
			else
				EC->PictureHeader.ImprovedPB = OFF;
		}
#endif

    	// Turn off AP mode if the QP_mean is lower than a certain level. This should increase
    	// sharpness for low motion (low QP => no AP), and reduce blockiness at high motion 
    	// (higher QP => with AP)
#ifdef USE_MMX // { USE_MMX
		if (ToggleAP == ON && MMX_Enabled == FALSE) 
#else // }{ USE_MMX
		if (ToggleAP == ON) 
#endif // } USE_MMX
		{
			if (EC->PictureHeader.AP == ON && 
			    EC->BRCState.QP_mean < AP_MODE_QP_LEVEL  &&
			    EC->u8EncodePBFrame == FALSE)
				EC->PictureHeader.AP = OFF;
		}
	}

	// If we are not going to encode as a PB-frame, reset the saved flag
	if (EC->u8EncodePBFrame == FALSE)
		EC->u8SavedBFrame = FALSE;

	// verify that flags are set correctly
	if (EC->PictureHeader.UMV == ON)
	{
#ifdef USE_MMX // { USE_MMX
		if (MMX_Enabled == FALSE)
#endif // } USE_MMX
		{
			// can't do this		
#ifdef USE_MMX // { USE_MMX
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: turning UMV off MMX_Enabled is FALSE\r\n", _fx_));
#else // }{ USE_MMX
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: turning UMV off MMX_Enabled is FALSE\r\n", _fx_));
#endif // } USE_MMX
			EC->PictureHeader.UMV = OFF;
		}
	}

#ifdef H263P
	if (EC->PictureHeader.ImprovedPB == ON)
	{
#ifdef USE_MMX // { USE_MMX
		if (MMX_Enabled == FALSE)
#endif // } USE_MMX
		{
			// can't do this
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: turning improved PB off MMX_Enabled is FALSE\r\n", _fx_));
			EC->PictureHeader.ImprovedPB = OFF;
		}
	}
#endif // H263P

#ifdef COUNT_BITS
	// Clear bit counters.
	InitBits(EC);
#endif

#ifdef USE_MMX // { USE_MMX
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: AP: %d, PB: %d, UMV: %d, MMX: %d, Target fr.size: %d\r\n", _fx_, EC->PictureHeader.AP, EC->u8EncodePBFrame, EC->PictureHeader.UMV, MMX_Enabled, lpicComp->dwFrameSize));
#else // }{ USE_MMX
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: AP: %d, PB: %d, UMV: %d, Target fr.size: %d\r\n", _fx_, EC->PictureHeader.AP, EC->u8EncodePBFrame, EC->PictureHeader.UMV, lpicComp->dwFrameSize));
#endif // } USE_MMX

#if H263P
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: H.263+ options: IPB: %d, DF: %d\r\n", _fx_, EC->PictureHeader.ImprovedPB, EC->PictureHeader.DeblockingFilter));
#endif

   /*
    * Check to see if this is an inter-frame and if a B frame has not been
	* saved yet. If so, we do nothing but save the frame to the B frame 
	* buffer and exit.
	* 
	*/
	U32	TRB;

	/*
	 * Turn PB frame option back on if it was just
	 * temporariy turned off for last frame.
	 */

	if( EC->u8EncodePBFrame == TEMPORARILY_FALSE )
		EC->u8EncodePBFrame = TRUE;


	// If this is to be saved as a B frame.
    if (EC->u8EncodePBFrame == TRUE &&
        EC->PictureHeader.PicCodType == INTERPIC &&
        EC->u8SavedBFrame == FALSE)
    {
		/*
		 * Set temporal reference for B frame.
		 * It is the number of non-transmitted pictures (at 29.97 Hz)
		 * since the last P or I frame plus 1. TRB has a maximum value
		 * of 7, and can never be zero.
		 * TODO: At the beginning of a sequence, the key frame is compressed,
		 * and then the first frame is copied over to the B frame store, so that
		 * temporal reference for B is zero, which is not allowed. This may cause
		 * problems in some decoders.
		 */	
		 				 
		TRB = (lpicComp->lFrameNum % 256);	// Take the modulo in order to compare it with TR.
		if ( TRB < EC->PictureHeader.TR )
			TRB += 256;						// It should always be greater than TR.

		TRB = TRB - EC->PictureHeader.TR;	// Calculate the TRB value for the bitstream.

		if (TRB > 7)
		{	
			/*
			 * We don't want to encode this as a PB-frame because TRB > 7, or
			 * the adaptive switch has turned PB-frames off for a while.
			 */

			EC->PictureHeader.TR = (lpicComp->lFrameNum % 256);
			EC->u8EncodePBFrame = TEMPORARILY_FALSE;	// Turn off PBframe for this frame.
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: TRB too big (%d), making P frame, TR = %d\r\n", _fx_, TRB, EC->PictureHeader.TR));
		}
		else
		{
			EC->PictureHeader.TRB = (U8) TRB;

			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Saving B Frame, TRB = %d\r\n", _fx_, EC->PictureHeader.TRB));

        	//  Copy with color conversion and return
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
			colorCnvtFrame(EC->ColorConvertor, lpCompInst, lpicComp, EC->pU8_BFrm_YPlane,
					   EC->pU8_BFrm_UPlane, EC->pU8_BFrm_VPlane);
#else

			colorCnvtFrame(EC, lpCompInst, lpicComp, EC->pU8_BFrm_YPlane,
					   EC->pU8_BFrm_UPlane, EC->pU8_BFrm_VPlane);



#endif

        	EC->u8SavedBFrame = TRUE;		// indicate that we saved a B frame.
        	lpCompInst->CompressedSize = 8; //  Internal Encoder/decoder agreement
#ifdef ENCODE_STATS
			StatsFrameSize(lpCompInst->CompressedSize, lpCompInst->CompressedSize);
#endif /* ENCODE_STATS */

        	goto done;  //  <<<<<<<<<<<<<<<<<<<<
		}
    }
	else	// This is a P or I frame.
	{
		// Save temporal reference modulo 256.
		EC->PictureHeader.TR = (lpicComp->lFrameNum % 256);

#ifdef _DEBUG
		if (EC->u8EncodePBFrame == TRUE)
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: PB Frame, TR = %d\r\n", _fx_, EC->PictureHeader.TR));
		else if (EC->PictureHeader.PicCodType == INTRAPIC)
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: I Frame, TR = %d\r\n", _fx_, EC->PictureHeader.TR));
		else
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: P Frame, TR = %d\r\n", _fx_, EC->PictureHeader.TR));
#endif
	}
	// Initialize Motion Estimation state
	InitMEState(EC, lpicComp, pConfiguration);

    // Get pointer to macrobock action stream.
    MBlockActionPtr = EC->pU8_MBlockActionStream;

    /******************************************************************
     * RGB to YVU 12 Conversion
     ******************************************************************/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
	colorCnvtFrame(EC->ColorConvertor, lpCompInst, lpicComp,
				   EC->pU8_CurrFrm_YPlane,
				   EC->pU8_CurrFrm_UPlane,
				   EC->pU8_CurrFrm_VPlane);
#else


	colorCnvtFrame(EC, lpCompInst, lpicComp,
				   EC->pU8_CurrFrm_YPlane,
				   EC->pU8_CurrFrm_UPlane,
			   EC->pU8_CurrFrm_VPlane);


#endif

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uInputCC)
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if SAMPLE_RGBCONV_TIME && ELAPSED_ENCODER_TIME
    StopSample ();
#endif

   /******************************************************
    * Set picture level quantizer.
	******************************************************/

	// clear the still quantizer counter if this is not a still frame or
	// it is the key frame for a still frame sequence. R.H.
  	if ( 
  	     ((lpicComp->dwFlags & CODEC_CUSTOM_STILL) == 0 )  ||
		 ((lpicComp->dwFlags & CODEC_CUSTOM_STILL) && 
		  (EC->PictureHeader.PicCodType == INTRAPIC))
	   )
		EC->BRCState.u8StillQnt = 0;

	// If the Encoder Bit Rate section of the configuration has been
	// set ON then, we override quality only or any frame size normally
	// sent in and use frame rate and data rate to determine frame
	// size.
    if (EC->PictureHeader.PicCodType == INTERPIC &&
        lpCompInst->Configuration.bBitRateState == TRUE &&
        lpCompInst->FrameRate != 0.0f &&
		lpicComp->dwFrameSize == 0UL)
	{
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Changing dwFrameSize from %ld to %ld bits\r\n", _fx_, lpicComp->dwFrameSize << 3, (DWORD)((float)lpCompInst->DataRate / lpCompInst->FrameRate) << 3));
		
        lpicComp->dwFrameSize = (U32)((float)lpCompInst->DataRate / lpCompInst->FrameRate);
	}

	// Use a different quantizer selection scheme if this is a
	// progressive still transmission.	
  	if (lpicComp->dwFlags & CODEC_CUSTOM_STILL)
	{
        bBitRateControl = OFF;

#ifdef USE_MMX // { USE_MMX
		if (MMX_Enabled == TRUE)
        	EC->PictureHeader.PQUANT = StillImageQnt_MMX[ EC->BRCState.u8StillQnt ];
		else
			EC->PictureHeader.PQUANT = StillImageQnt[ EC->BRCState.u8StillQnt ];
#else // }{ USE_MMX
		EC->PictureHeader.PQUANT = StillImageQnt[ EC->BRCState.u8StillQnt ];
#endif // } USE_MMX

		DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Setting still frames QP : %d\r\n", _fx_, EC->PictureHeader.PQUANT));
	}
    //  If requested frame size is 0, then we simply set the quantizer
    //  according to the value in dwQuality.
    else
    if (lpicComp->dwFrameSize == 0)
    {
        bBitRateControl = OFF;
        EC->PictureHeader.PQUANT = clampQP((10000 - lpicComp->dwQuality)*32/10000);

		// In case a fixed quality setting is chosen (for example from VidEdit),
		// we have to limit the lower QP value, in order not to blow the quite
		// small bitstream buffer size. This size is set to be compliant with
		// the H.263 spec. If the "chance of buffer overflow" code had not been
		// added (search for "bGOBoverflowWarning", these limits would have had 
		// to be even higher. 
		if (EC->PictureHeader.PicCodType == INTERPIC)
		{
			if (EC->PictureHeader.PQUANT < 3)
				EC->PictureHeader.PQUANT = 3;
		}
		else
		{
			if (EC->PictureHeader.PQUANT < 8)
				EC->PictureHeader.PQUANT = 8;
		}

		DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller disabled (no target frame size), setting EC->PictureHeader.PQUANT = %ld\r\n", _fx_, EC->PictureHeader.PQUANT));

		// Limit the picture header QP to 2. Because of the calculation of u8QPMin
		// below, this will effectively limit the QP at 2 for all macroblocks.
		// The reason we need this is that the encoder generates an illegal
		// bitstream when encoding a synthetic image for QP=1
		if (EC->PictureHeader.PQUANT == 1)
			EC->PictureHeader.PQUANT = 2;       

		// Calculate the lower level for GQuant in this picture
		u8QPMin = EC->PictureHeader.PQUANT -  EC->PictureHeader.PQUANT/3;

    }
    else
    {
		// Calculate PQUANT based on bits used in last picture

		// Get Target Frame Rate that was passed from CompressFrames structure.
		if (lpCompInst->FrameRate != 0)
			EC->BRCState.TargetFrameRate = lpCompInst->FrameRate;

		bBitRateControl = ON;

		// If this is to be compressed as a PB frame, then we modify
		// the target framesize for the P frame to be a percentage
		// of twice the target frame size.
		if ((EC->u8EncodePBFrame == TRUE) && (EC->PictureHeader.PicCodType == INTERPIC) && (EC->u8SavedBFrame == TRUE))
			EC->BRCState.uTargetFrmSize = (80 * 2 * lpicComp->dwFrameSize)/100;
		else
			EC->BRCState.uTargetFrmSize = lpicComp->dwFrameSize;

		DEBUGMSG(ZONE_BITRATE_CONTROL, ("\r\n%s: Bitrate controller enabled with\r\n", _fx_));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Target frame rate = %ld.%ld fps\r\n  Target quality = %ld\r\n  Target frame size = %ld bits\r\n  Target bitrate = %ld bps\r\n", (DWORD)EC->BRCState.TargetFrameRate, (DWORD)(EC->BRCState.TargetFrameRate - (float)(DWORD)EC->BRCState.TargetFrameRate) * 10UL, (DWORD)lpicComp->dwQuality, (DWORD)lpicComp->dwFrameSize << 3, (DWORD)(EC->BRCState.TargetFrameRate * EC->BRCState.uTargetFrmSize) * 8UL));
		DEBUGMSG(ZONE_BITRATE_CONTROL, ("  Minimum quantizer = %ld\r\n  Maximum quantizer = 31\r\n", clampQP((10000 - lpicComp->dwQuality)*15/10000)));

		// Get the new quantizer value
		EC->PictureHeader.PQUANT = CalcPQUANT( &(EC->BRCState), EC->PictureHeader.PicCodType);

		// Calculate the min and max value for GQuant in this picture
		u8QPMax = 31;
        u8QPMin = clampQP((10000 - lpicComp->dwQuality)*15/10000);

    }

	gquant_prev = EC->PictureHeader.PQUANT;
	QP_cumulative = 0;

	// Check for AP, UMV or deblocking-filter modes. Each of these allows
	// motion vectors to point outside of the reference picture.
	// Need to verify this in final H.263+ spec for the deblocking filter.
	if (EC->PictureHeader.AP == ON || EC->PictureHeader.UMV
#ifdef H263P
		|| EC->PictureHeader.DeblockingFilter == ON
#endif
	   )
	{
		ExpandPlane((U32)EC->pU8_PrevFrm_YPlane,
			(U32)EC->FrameWidth,
			(U32)EC->FrameHeight,
			16);
		ExpandPlane((U32)EC->pU8_PrevFrm_UPlane,
			(U32)EC->FrameWidth>>1,
			(U32)EC->FrameHeight>>1,
			8);
		ExpandPlane((U32)EC->pU8_PrevFrm_VPlane,
			(U32)EC->FrameWidth>>1,
			(U32)EC->FrameHeight>>1,
			8);
	}

	// If PB-frames are used and AP or UMV is not used at the same time, we can't search
	// for a PB-delta vector (this is a limitation in the motion estimation routine,
	// not the standard)
	// If we allowed searching for B-frame vectors without AP, UMV or DF, we would need
	// to worry about searching outside of the frame
	if (EC->u8EncodePBFrame == TRUE && EC->PictureHeader.AP == OFF &&
		EC->PictureHeader.UMV == OFF
#ifdef H263P
		&& EC->PictureHeader.DeblockingFilter == OFF
#endif
		)
		u32BFrmZeroThreshold = 999999;	 // do not search for other vectors than zero vector
	else
#ifdef USE_MMX // { USE_MMX
		u32BFrmZeroThreshold = (MMX_Enabled == FALSE ? 384 : 500);
#else // }{ USE_MMX
		u32BFrmZeroThreshold = 384;
#endif // } USE_MMX

	// Variables which will not change during the frame
	// Gim 4/16/97 - added u32sizeBSnEBS
	// u32sizeBitBuffer : max. allowable frame size w/o RTP stuff
	// u32sizeBSnEBS	: max. allowable size w/ RTP stuff (EBS & trailer)
#if defined(H263P)
	u32sizeBSnEBS = CompressGetSize(lpCompInst, lpicComp->lpbiInput,
												lpicComp->lpbiOutput);
#elif defined(USE_BILINEAR_MSH26X)
	u32sizeBSnEBS = CompressGetSize(pi, lpicComp->lpbiInput,
												lpicComp->lpbiOutput);
#else
	u32sizeBSnEBS = CompressGetSize(lpCompInst, lpicComp->lpbiInput, 0);
#endif

	if (pConfiguration->bRTPHeader)
		u32sizeBitBuffer = u32sizeBSnEBS - getRTPBsInfoSize(lpCompInst);
	else
		u32sizeBitBuffer = u32sizeBSnEBS;

	u32tempBuf = (3 * u32sizeBitBuffer / EC->NumMBRows) >> 2;

    /*
     * Check to see if we told VfW to create a buffer smaller
     * than the maximum allowable.
     */
    ASSERT(u32sizeBitBuffer <= sizeof_bitstreambuf)

	// Check to see if we are to encode a PB frame
    bEncodePBFrame = (EC->u8EncodePBFrame && EC->u8SavedBFrame);
    bPBFailed = FALSE;

#if defined(H263P)
	EC->pFutrPMBData = ((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->FutrPMBData;
	EC->pWeightForwMotion = ((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->WeightForwMotion;  //  values based on TRb and TRd
	EC->pWeightBackMotion = ((T_H263EncoderInstanceMemory *)(lpCompInst->EncoderInst))->WeightBackMotion;  //  values based on TRb and TRd
#endif

	if (bEncodePBFrame)
	{
		TRb = EC->PictureHeader.TRB;

		TRd = (I32) EC->PictureHeader.TR - (I32) EC->PictureHeader.TRPrev;

		if (TRd == 0) {
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: TR == TRPrev. Setting TRd = 256\r\n", _fx_));
		}
		else if (TRd < 0) TRd += 256;

		for (j = 0; j < 128; j ++)
		{
#if defined(H263P)
			EC->pWeightForwMotion[j] = (I8) ((TRb * (j-64)) / TRd);
			EC->pWeightBackMotion[j] = (I8) (((TRb-TRd) * (j-64)) / TRd);
#else
			WeightForwMotion[j] = (I8) ((TRb * (j-64)) / TRd);
			WeightBackMotion[j] = (I8) (((TRb-TRd) * (j-64)) / TRd);
#endif
		}
	}
    
	/***************************************************************
     * Initialization before encoding all GOBs.
     * Store frame header code into bitstream buffer.
	 ***************************************************************/

    if (pConfiguration->bRTPHeader)
        H263RTP_ResetBsInfoStream(EC);

    // zero bit stream buffer
    pCurBitStream = EC->pU8_BitStream;
    u8bitoffset = 0;

    GOBHeaderMask = 1;
	EC->GOBHeaderPresent = 0;	// Clear GOB Header Present flag.
  
    encodeFrameHeader(EC, &pCurBitStream, &u8bitoffset, FALSE);

#ifdef USE_MMX // { USE_MMX
    if (MMX_Enabled == FALSE)
	{
        for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	    {
            StartingMB = GOB * EC->NumMBPerRow;
		
			gquant = FindNewQuant(EC,gquant_prev,uAdjCumFrmSize,GOB,u8QPMax,u8QPMin,
								  bBitRateControl,bGOBoverflowWarning);

            //  Save gquant for PB-frames
	        FutrFrmGQUANT[GOB] = gquant;
	        QP_cumulative += gquant;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			MOTIONESTIMATION(
				&(EC->pU8_MBlockActionStream[StartingMB]),
				EC->pU8_CurrFrm_YPlane,
				EC->pU8_PrevFrm_YPlane,
				0,			 // Not used for H.263.
				1,			 // Do Radius 15 search.
				1,			 // Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
				(EC->PictureHeader.AP == ON ||	EC->PictureHeader.DeblockingFilter) ? 1 : 0,   // Block MVs flag
				 EC->pPseudoStackSpace,
#else
				(EC->PictureHeader.AP == ON) ? 1 : 0,	// Block MVs flag
#endif
				0,			 // No Spatial Filtering
				150,//384,	 // Zero Vector Threshold. If less than this threshold
							 // don't search for NZ MV's. Set to 99999 to not search.
				128,		 // NonZeroMVDifferential. Once the best NZ MV is found,
							 // it must be better than the 0 MV SWD by at least this
							 // amount. Set to 99999 to never choose NZ MV.
				512,		 // BlockMVDifferential. The sum of the four block SWD
							 // must be better than the MB SWD by at least this
							 // amount to choose block MV's.
				20,//96,	 // Empty Threshold. Set to 0 to not force empty blocks.
				550,///1152, // Inter Coding Threshold. If the inter SWD is less than
							 // this amount then don't bother calc. the intra SWD.
				500,		 // Intra Coding Differential. Bias against choosing INTRA
							 // blocks.
				0,			 // Spatial Filtering Threshold.
				0,			 // Spatial Filtering Differential.
				&IntraSWDTotal,
				&IntraSWDBlocks,
				&InterSWDTotal,
				&InterSWDBlocks
			);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimation)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// Sum up SWD 
			iSumSWD += IntraSWDTotal + InterSWDTotal;

	       /*
	        * If it's an inter frame then calculate chroma vectors.
			* Also check the inter coded count for each macro block
			* and force to intra if it exceeds 132.
			*/
			if (EC->PictureHeader.PicCodType == INTERPIC)
			{
				calcGOBChromaVectors(EC, StartingMB, pConfiguration);
				// for IA this is called after motion estimation
				Check_InterCodeCnt(EC, StartingMB);
            }

	        //  Save the starting offset of the GOB as the start
	        //  bit offset of the first MB.
			if (bEncodePBFrame) {
#if defined(H263P)
				EC->pFutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
				FutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif
			}

            if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
	        {
				unsigned int GFID;

				// Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
				EC->GOBHeaderPresent |= GOBHeaderMask;

	            // Write GOB start code.
                PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, &pCurBitStream, &u8bitoffset);

	            // Write GOB number.
                PutBits(GOB, FIELDLEN_GN, &pCurBitStream, &u8bitoffset);

	            // Write GOB frame ID.
				// According to section 5.2.5 of the H.263 specification:
				// "GFID shall have the same value in every GOB header of a given
				// picture. Moreover, if PTYPE as indicated in a picture header is
				// the same as for the previous transmitted picture, GFID shall have
				// the same value as in that previous picture. However, if PTYPE in
				// a certain picture header differs from the PTYPE in the previous
				// transmitted picture header, the value for GFID in that picture
				// shall differ from the value in the previous picture."
				// In our usage of H.263, we usually send either I of P frames with
				// all options turned of, or always the same options turned on. This
				// simplifies the fix in allowing us to compute a GFID based only on
				// the picture type and the presence of at least on option.
				GFID = (EC->PictureHeader.PB || EC->PictureHeader.AP || EC->PictureHeader.SAC || EC->PictureHeader.UMV) ? 2 : 0;
				if (EC->PictureHeader.PicCodType == INTRAPIC)
					GFID++;
                PutBits(GFID, FIELDLEN_GFID, &pCurBitStream, &u8bitoffset);

	            // Write GQUANT.
                PutBits(gquant, FIELDLEN_GQUANT, &pCurBitStream, &u8bitoffset);

	            gquant_prev = gquant;

				#ifdef COUNT_BITS
				EC->Bits.GOBHeader += FIELDLEN_GBSC + FIELDLEN_GN + FIELDLEN_GFID + FIELDLEN_GQUANT;
				#endif
	        }

	        /*
	         * Input is the macroblock action stream with pointers to
	         * current and previous blocks. Output is a set of 32 DWORDs
	         * containing pairs of coefficients for each block. There are
	         * from 0 to 12 blocks depending on if PB frames are used and
	         * what the CBP field states.
	         */
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			FORWARDDCT(&(EC->pU8_MBlockActionStream[StartingMB]),
				EC->pU8_CurrFrm_YPlane,
				EC->pU8_PrevFrm_YPlane,
				0,
				EC->pU8_DCTCoefBuf,
				0,							// 0 = not a B-frame
				EC->PictureHeader.AP == ON, // Advanced prediction (OBMC)
				bEncodePBFrame, 			// Is P of PB pair?
				EC->pU8_PredictionScratchArea,
				EC->NumMBPerRow
			);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCT)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			/*
			* Input is the string of coefficient pairs output from the
			* DCT routine.
			*/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			GOB_Q_RLE_VLC_WriteBS(
				EC,
				EC->pU8_DCTCoefBuf,
				&pCurBitStream,
				&u8bitoffset,
#if defined(H263P)
				EC->pFutrPMBData,
#else
				FutrPMBData,
#endif
				GOB,
				gquant,
				pConfiguration->bRTPHeader,
				StartingMB);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLE)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		    //Chad	 INTRA GOB
			if (pConfiguration->bRTPHeader && IsIntraCoded(EC, GOB)) 
				uUsedByIntra += pCurBitStream - EC->pU8_BitStream + 1 - uCumFrmSize;

            // Accumulate number of bytes used in frame so far.
	        uCumFrmSize = pCurBitStream - EC->pU8_BitStream + 1; 

			// Here we will check to see if we have blown the buffer. If we have,
			// then we will set the next frame up to be a key frame and return an
			// ICERR_ERROR. We hope that with an INTRA quantizer of 16, we will not
			// overflow the buffer for the next frame.

            if (uCumFrmSize > u32sizeBitBuffer)
			{
				ERRORMESSAGE(("%s: Buffer overflow, uCumFrmSize %d > %d\r\n", _fx_, uCumFrmSize, u32sizeBitBuffer));
                // Now clear the buffer for the next frame and set up for a key frame
				memset(EC->pU8_BitStream, 0, uCumFrmSize);
				EC->bMakeNextFrameKey = TRUE;	// Could be a problem in still mode if
                ret = ICERR_ERROR;              // we blow the buffer on the first key frame: RH
				goto done;
			}
			else 
			{ 
                if ((bEncodePBFrame?3*uCumFrmSize>>1:uCumFrmSize) > ((GOB + 1) * u32tempBuf))
				{
					// set the next GOB quantizer to be higher to minimize overflowing the
					// buffer at the end of GOB processing.
					bGOBoverflowWarning = TRUE;

					DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Anticipating overflow: uCumFrmSize = %ld bits > (GOB + 1) * u32tempBuf = (#%ld + 1) * %ld\r\n", _fx_, uCumFrmSize << 3, GOB, u32tempBuf << 3));
				}
				else 
					bGOBoverflowWarning = FALSE;  
			}

			// Gim 4/16/97 - moved this adjustment from before to after the
			// buffer check above
			// if the current GOB is intra coded, adjust the cumulated sum
			if (pConfiguration->bRTPHeader)
			{
				if (!GOB)
					uAdjCumFrmSize = uCumFrmSize - uUsedByIntra / 4;
				else
					uAdjCumFrmSize = uCumFrmSize - uUsedByIntra;
			}
			else
				uAdjCumFrmSize = uCumFrmSize;

	    } // for GOB

        //Chad  INTRA GOB restore after use
        uUsedByIntra = 0;

		// Store the number of bits spent so far
		EC->uBitUsageProfile[GOB] = uAdjCumFrmSize;

    }
    else // MMX_Enabled == TRUE
	{
        MMxMESignaturePrep(EC->pU8_PrevFrm_YPlane,
                           EC->pU8_Signature_YPlane,
                           EC->FrameWidth,
                           EC->FrameHeight);

        for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	    {
            StartingMB = GOB * EC->NumMBPerRow;
			
			// Check inter code count for all macroblocks on this row
			// Need special version for MMX since it is called before motion estiamtion
			// When the intra coding flag is set, Brian still does motion estimation
			// for this MB in MMXEDTQ if the PB coding flag is set
			Check_InterCodeCnt_MMX(EC, StartingMB);

			gquant = FindNewQuant(EC,gquant_prev,uCumFrmSize,GOB,u8QPMax,u8QPMin,
			                      bBitRateControl,bGOBoverflowWarning);

	        //  Save gquant for PB-frames
	        FutrFrmGQUANT[GOB] = gquant;
	        QP_cumulative += gquant;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// This does the pass over the Luma blocks...
			__try
			{
				MMxEDTQ (
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_CurrFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_BFrm_YPlane,
					EC->pU8_Signature_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion,
					EC->pWeightBackMotion,
#else
					WeightForwMotion,
					WeightBackMotion,
#endif
					EC->FrameWidth,
					1,							// Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
					// H.263+, deblocking filter automatically turns on
					// block level MVs, but not OBMC
					(EC->PictureHeader.AP == ON) || (EC->PictureHeader.DeblockingFilter == ON), // Block MVs flag
					EC->pPseudoStackSpace,
#else
					EC->PictureHeader.AP == ON, // Block MVs flag
#endif
					0,							// No Spatial Filtering
					EC->PictureHeader.AP == ON, // Advanced Prediction (OBMC) and MVs outside of picture flag
					bEncodePBFrame, 			// Is PB pair?
#ifdef H263P
					EC->PictureHeader.DeblockingFilter == ON,  // Use deblocking filter (8x8 and unrestricted MV's)
					EC->PictureHeader.ImprovedPB == ON,  // Use improved PB-frame method
#endif
					1,							// Do Luma blocks this Pass
					EC->PictureHeader.UMV,		// MVs outside of picture and within [-31.5, 31.5]
#ifdef H263P
					(GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev)),
												// GOB header present. Used to generate MV predictor and search range in UMV
#endif
					gquant,
					min((6*gquant)>>2, 31), 	// TODO: to match DBQUANT in picture header
					u32BFrmZeroThreshold,		// BFrmZeroVectorThreshold
					0,							// SpatialFiltThreshold
					0,							// SpatialFiltDifferential
					&iSWD,
					&iBSWD,
					EC->pI8_MBRVS_Luma,
					EC->pI8_MBRVS_BLuma+GOB*(65*3*22*4)
				);
			}
			__except(ExceptionFilterForMMxEDTQ(GetExceptionInformation(),EC->pI8_MBRVS_BLuma,1))
			{
				// no exception handler
			}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimation)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// Sum up SWDs
			iSumSWD += iSWD;
			iSumBSWD += iBSWD;

	       /*
	        * If it's an inter frame then calculate chroma vectors.
			* Also check the inter coded count for each macro block
			* and force to intra if it exceeds 132.
			*/
	        if (EC->PictureHeader.PicCodType == INTERPIC)
	        {
				calcGOBChromaVectors(EC, StartingMB, pConfiguration);

				if (bEncodePBFrame) 
                    // Calculate chroma vectors.
					calcBGOBChromaVectors(EC, StartingMB);
            }

            // Save the starting offset of the GOB as the start
            // bit offset of the first MB.
			if (bEncodePBFrame) {
#if defined(H263P)
				EC->pFutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
				FutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif
			}

            if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
	        {
				unsigned int GFID;

				// Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
				EC->GOBHeaderPresent |= GOBHeaderMask;

	            // Write GOB start code.
                PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, &pCurBitStream, &u8bitoffset);

	            // Write GOB number.
                PutBits(GOB, FIELDLEN_GN, &pCurBitStream, &u8bitoffset);

	            // Write GOB frame ID.
				// According to section 5.2.5 of the H.263 specification:
				// "GFID shall have the same value in every GOB header of a given
				// picture. Moreover, if PTYPE as indicated in a picture header is
				// the same as for the previous transmitted picture, GFID shall have
				// the same value as in that previous picture. However, if PTYPE in
				// a certain picture header differs from the PTYPE in the previous
				// transmitted picture header, the value for GFID in that picture
				// shall differ from the value in the previous picture."
				// In our usage of H.263, we usually send either I of P frames with
				// all options turned of, or always the same options turned on. This
				// simplifies the fix in allowing us to compute a GFID based only on
				// the picture type and the presence of at least on option.
				GFID = (EC->PictureHeader.PB || EC->PictureHeader.AP || EC->PictureHeader.SAC || EC->PictureHeader.UMV) ? 2 : 0;
				if (EC->PictureHeader.PicCodType == INTRAPIC)
					GFID++;
                PutBits(GFID, FIELDLEN_GFID, &pCurBitStream, &u8bitoffset);

	            // Write GQUANT.
                PutBits(gquant, FIELDLEN_GQUANT, &pCurBitStream, &u8bitoffset);

	            gquant_prev = gquant;

				#ifdef COUNT_BITS
				EC->Bits.GOBHeader += FIELDLEN_GBSC + FIELDLEN_GN + FIELDLEN_GFID + FIELDLEN_GQUANT;
				#endif
	        }

	        /*
	         * Input is the macroblock action stream with pointers to
	         * current and previous blocks. Output is a set of 32 DWORDs
	         * containing pairs of coefficients for each block. There are
	         * from 0 to 12 blocks depending on if PB frames are used and
	         * what the CBP field states.
	         */
	           // This does the pass over the Chroma blocks....
	           //
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			__try
			{
				MMxEDTQ (
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_CurrFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_BFrm_YPlane,
					EC->pU8_Signature_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion,
					EC->pWeightBackMotion,
#else
					WeightForwMotion,
					WeightBackMotion,
#endif
					EC->FrameWidth,
					1,							// Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
					// H.263+, deblocking filter automatically turns on
					// block level MVs, but not OBMC
					(EC->PictureHeader.AP == ON) || (EC->PictureHeader.DeblockingFilter == ON), // Block MVs flag
					EC->pPseudoStackSpace,
#else
					EC->PictureHeader.AP == ON, // Block MVs flag
#endif
					0,							// No Spatial Filtering
					EC->PictureHeader.AP == ON, // Advanced Prediction (OBMC)
					bEncodePBFrame, 			// Is PB pair?
#ifdef H263P
					EC->PictureHeader.DeblockingFilter == ON,  // Use deblocking filter (8x8 and unrestricted MV's)
					EC->PictureHeader.ImprovedPB == ON,  // Use improved PB-frame method
					0,							// If not H.263+, must be 0
					0,							// If not H.263+, must be 0
#endif
					0,							// Do Chroma blocks this Pass
					0,							// 1 for extended motion vectors
#ifdef H263P
					0,							// GOB header present. Used in UMV to generate MV predictor.
#endif
					gquant,
					min((6*gquant) >> 2, 31),
					500,						// BFrmZeroVectorThreshold
					0,							// SpatialFiltThreshold
					0,							// SpatialFiltDifferential
					&iSWD,
					&iBSWD,
					EC->pI8_MBRVS_Chroma,
					EC->pI8_MBRVS_BChroma+GOB*(65*3*22*2)
				);
			}
			__except(ExceptionFilterForMMxEDTQ(GetExceptionInformation(),EC->pI8_MBRVS_BChroma,0))
			{
				// no exception handler
			}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCT)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			/*
			* Input is the string of coefficient pairs output from the
			* DCT routine.
			*/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			GOB_VLC_WriteBS(
				EC,
				EC->pI8_MBRVS_Luma,
				EC->pI8_MBRVS_Chroma,
				&pCurBitStream,
				&u8bitoffset,
#if defined(H263P)
				EC->pFutrPMBData,
#else
				FutrPMBData,
#endif
				GOB,
				gquant,
				pConfiguration->bRTPHeader,
				StartingMB);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLE)
#endif // } DETAILED_ENCODE_TIMINGS_ON

			// Accumulate number of bytes used in frame so far.
			uCumFrmSize = pCurBitStream - EC->pU8_BitStream + 1;

			// Here we will check to see if we have blown the buffer. If we have,
			// then we will set the next frame up to be a key frame and return an
			// ICERR_ERROR. We hope that with an INTRA quantizer of 16, we will not
			// overflow the buffer for the next frame.

			if (uCumFrmSize > u32sizeBitBuffer) 
			{
				ERRORMESSAGE(("%s: Buffer overflow, uCumFrmSize %d > %d\r\n", _fx_, uCumFrmSize, u32sizeBitBuffer));
				memset(EC->pU8_BitStream, 0, uCumFrmSize);
				EC->bMakeNextFrameKey = TRUE;	// Could be a problem in still mode if
				ret = ICERR_ERROR;				// we blow the buffer on the first key frame: RH 
				goto done;
            }
			else 
			{ 
                if ((bEncodePBFrame?3*uCumFrmSize>>1:uCumFrmSize) > ((GOB + 1) * u32tempBuf))
					// set the next GOB quantizer to be higher to minimize overflowing the
					// buffer at the end of GOB processing.
					bGOBoverflowWarning = TRUE;
				else 
					bGOBoverflowWarning = FALSE;  
			}
	    } // for GOB

	    // Store the number of bits spent so far
	    EC->uBitUsageProfile[GOB] = uCumFrmSize;

		// This is the new MMX PB-frames switch
		// Simple check to see if B-frame will look bad
		// This could be possibly be improved by looking at the
		// actual number of coefficients, or the number of bits
		// in the bitstream.
#ifdef H263P
		// Always use the B frame if improved PB-frame mode and AP or UMV mode requested
		if (TogglePB == TRUE && iSumBSWD >= iSumSWD &&
			!(EC->PictureHeader.ImprovedPB == ON &&
			 (EC->PictureHeader.AP == ON || EC->PictureHeader.UMV == ON ||
			  EC->PictureHeader.DeblockingFilter == ON)))
#else
		if (TogglePB == TRUE && iSumBSWD >= iSumSWD)
#endif
        {
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Giving up PB, SumBSWD = %d, SumSWD = %d\r\n", _fx_, iSumBSWD, iSumSWD));
            bEncodePBFrame = FALSE;
            EC->u8SavedBFrame = FALSE;
		}
    }
#else // }{ USE_MMX
    for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	{
        StartingMB = GOB * EC->NumMBPerRow;
	
			gquant = FindNewQuant(EC,gquant_prev,uAdjCumFrmSize,GOB,u8QPMax,u8QPMin,
								  bBitRateControl,bGOBoverflowWarning);

        //  Save gquant for PB-frames
	    FutrFrmGQUANT[GOB] = gquant;
	    QP_cumulative += gquant;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

			MOTIONESTIMATION(
				&(EC->pU8_MBlockActionStream[StartingMB]),
				EC->pU8_CurrFrm_YPlane,
				EC->pU8_PrevFrm_YPlane,
				0,			 // Not used for H.263.
				1,			 // Do Radius 15 search.
				1,			 // Half Pel Motion Estimation flag (0-off, 1-on)
#ifdef H263P
				(EC->PictureHeader.AP == ON ||	EC->PictureHeader.DeblockingFilter) ? 1 : 0,   // Block MVs flag
				 EC->pPseudoStackSpace,
#else
				(EC->PictureHeader.AP == ON) ? 1 : 0,	// Block MVs flag
#endif
				0,			 // No Spatial Filtering
				150,//384,	 // Zero Vector Threshold. If less than this threshold
							 // don't search for NZ MV's. Set to 99999 to not search.
				128,		 // NonZeroMVDifferential. Once the best NZ MV is found,
							 // it must be better than the 0 MV SWD by at least this
							 // amount. Set to 99999 to never choose NZ MV.
				512,		 // BlockMVDifferential. The sum of the four block SWD
							 // must be better than the MB SWD by at least this
							 // amount to choose block MV's.
				20,//96,	 // Empty Threshold. Set to 0 to not force empty blocks.
				550,///1152, // Inter Coding Threshold. If the inter SWD is less than
							 // this amount then don't bother calc. the intra SWD.
				500,		 // Intra Coding Differential. Bias against choosing INTRA
							 // blocks.
				0,			 // Spatial Filtering Threshold.
				0,			 // Spatial Filtering Differential.
				&IntraSWDTotal,
				&IntraSWDBlocks,
				&InterSWDTotal,
				&InterSWDBlocks
			);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uMotionEstimation)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Sum up SWD 
		iSumSWD += IntraSWDTotal + InterSWDTotal;

	   /*
	    * If it's an inter frame then calculate chroma vectors.
		* Also check the inter coded count for each macro block
		* and force to intra if it exceeds 132.
		*/
		if (EC->PictureHeader.PicCodType == INTERPIC)
		{
			calcGOBChromaVectors(EC, StartingMB, pConfiguration);
			// for IA this is called after motion estimation
			Check_InterCodeCnt(EC, StartingMB);
        }

	    //  Save the starting offset of the GOB as the start
	    //  bit offset of the first MB.
			if (bEncodePBFrame) {
#if defined(H263P)
				EC->pFutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
				FutrPMBData[StartingMB].MBStartBitOff =
				  (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif
			}

        if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
	    {
			unsigned int GFID;

			// Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
			EC->GOBHeaderPresent |= GOBHeaderMask;

	        // Write GOB start code.
            PutBits(FIELDVAL_GBSC, FIELDLEN_GBSC, &pCurBitStream, &u8bitoffset);

	        // Write GOB number.
            PutBits(GOB, FIELDLEN_GN, &pCurBitStream, &u8bitoffset);

	        // Write GOB frame ID.
			// According to section 5.2.5 of the H.263 specification:
			// "GFID shall have the same value in every GOB header of a given
			// picture. Moreover, if PTYPE as indicated in a picture header is
			// the same as for the previous transmitted picture, GFID shall have
			// the same value as in that previous picture. However, if PTYPE in
			// a certain picture header differs from the PTYPE in the previous
			// transmitted picture header, the value for GFID in that picture
			// shall differ from the value in the previous picture."
			// In our usage of H.263, we usually send either I of P frames with
			// all options turned of, or always the same options turned on. This
			// simplifies the fix in allowing us to compute a GFID based only on
			// the picture type and the presence of at least on option.
			GFID = (EC->PictureHeader.PB || EC->PictureHeader.AP || EC->PictureHeader.SAC || EC->PictureHeader.UMV) ? 2 : 0;
			if (EC->PictureHeader.PicCodType == INTRAPIC)
				GFID++;
            PutBits(GFID, FIELDLEN_GFID, &pCurBitStream, &u8bitoffset);

	        // Write GQUANT.
            PutBits(gquant, FIELDLEN_GQUANT, &pCurBitStream, &u8bitoffset);

	        gquant_prev = gquant;

			#ifdef COUNT_BITS
			EC->Bits.GOBHeader += FIELDLEN_GBSC + FIELDLEN_GN + FIELDLEN_GFID + FIELDLEN_GQUANT;
			#endif
	    }

	    /*
	     * Input is the macroblock action stream with pointers to
	     * current and previous blocks. Output is a set of 32 DWORDs
	     * containing pairs of coefficients for each block. There are
	     * from 0 to 12 blocks depending on if PB frames are used and
	     * what the CBP field states.
	     */
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		FORWARDDCT(&(EC->pU8_MBlockActionStream[StartingMB]),
			EC->pU8_CurrFrm_YPlane,
			EC->pU8_PrevFrm_YPlane,
			0,
			EC->pU8_DCTCoefBuf,
			0,							// 0 = not a B-frame
			EC->PictureHeader.AP == ON, // Advanced prediction (OBMC)
			bEncodePBFrame, 			// Is P of PB pair?
			EC->pU8_PredictionScratchArea,
			EC->NumMBPerRow
		);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uFDCT)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/*
		* Input is the string of coefficient pairs output from the
		* DCT routine.
		*/
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		GOB_Q_RLE_VLC_WriteBS(
			EC,
			EC->pU8_DCTCoefBuf,
			&pCurBitStream,
			&u8bitoffset,
#if defined(H263P)
			EC->pFutrPMBData,
#else
			FutrPMBData,
#endif
			GOB,
			gquant,
			pConfiguration->bRTPHeader,
			StartingMB);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uQRLE)
#endif // } DETAILED_ENCODE_TIMINGS_ON

		//Chad	 INTRA GOB
		if (pConfiguration->bRTPHeader && IsIntraCoded(EC, GOB)) 
			uUsedByIntra += pCurBitStream - EC->pU8_BitStream + 1 - uCumFrmSize;

        // Accumulate number of bytes used in frame so far.
	    uCumFrmSize = pCurBitStream - EC->pU8_BitStream + 1; 

		// Here we will check to see if we have blown the buffer. If we have,
		// then we will set the next frame up to be a key frame and return an
		// ICERR_ERROR. We hope that with an INTRA quantizer of 16, we will not
		// overflow the buffer for the next frame.

        if (uCumFrmSize > u32sizeBitBuffer)
		{
			ERRORMESSAGE(("%s: Buffer overflow, uCumFrmSize %d > %d\r\n", _fx_, uCumFrmSize, u32sizeBitBuffer));
            // Now clear the buffer for the next frame and set up for a key frame
			memset(EC->pU8_BitStream, 0, uCumFrmSize);
			EC->bMakeNextFrameKey = TRUE;	// Could be a problem in still mode if
            ret = ICERR_ERROR;              // we blow the buffer on the first key frame: RH
			goto done;
		}
		else 
		{ 
            if ((bEncodePBFrame?3*uCumFrmSize>>1:uCumFrmSize) > ((GOB + 1) * u32tempBuf))
				// set the next GOB quantizer to be higher to minimize overflowing the
				// buffer at the end of GOB processing.
				bGOBoverflowWarning = TRUE;
			else 
				bGOBoverflowWarning = FALSE;  
		}

		// Gim 4/16/97 - moved this adjustment from before to after the
		// buffer check above
		// if the current GOB is intra coded, adjust the cumulated sum
		if (pConfiguration->bRTPHeader)
		{
			if (!GOB)
				uAdjCumFrmSize = uCumFrmSize - uUsedByIntra / 4;
			else
				uAdjCumFrmSize = uCumFrmSize - uUsedByIntra;
		}
		else
			uAdjCumFrmSize = uCumFrmSize;

	} // for GOB

    //Chad  INTRA GOB restore after use
    uUsedByIntra = 0;

	// Store the number of bits spent so far
	EC->uBitUsageProfile[GOB] = uAdjCumFrmSize;
#endif // } USE_MMX

    #ifdef COUNT_BITS
    WriteCountBitFile( &(EC->Bits) );
    #endif

    // ------------------------------------------------------------------------
    //  Write the MBStartBitOff in the sentinel macroblock
    // ------------------------------------------------------------------------

	if (bEncodePBFrame)
	{	// Encoding future P frame
#if defined(H263P)
		EC->pFutrPMBData[EC->NumMBs].MBStartBitOff
			= (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#else
		FutrPMBData[EC->NumMBs].MBStartBitOff
			= (U32) (((pCurBitStream - EC->pU8_BitStream) << 3) + u8bitoffset);
#endif

		#ifdef DEBUG
		for (i = 0; i < EC->NumMBs; i++)
		{
#if defined(H263P)
			ASSERT(EC->pFutrPMBData[i].MBStartBitOff < EC->pFutrPMBData[i + 1].MBStartBitOff)
			ASSERT(EC->pFutrPMBData[i].CBPYBitOff <= EC->pFutrPMBData[i].MVDBitOff)
			ASSERT(EC->pFutrPMBData[i].MVDBitOff <= EC->pFutrPMBData[i].BlkDataBitOff)
			ASSERT(EC->pFutrPMBData[i].BlkDataBitOff <= (EC->pFutrPMBData[i + 1].MBStartBitOff - EC->pFutrPMBData[i].MBStartBitOff))
#else
			ASSERT(FutrPMBData[i].MBStartBitOff < FutrPMBData[i + 1].MBStartBitOff)
			ASSERT(FutrPMBData[i].CBPYBitOff <= FutrPMBData[i].MVDBitOff)
			ASSERT(FutrPMBData[i].MVDBitOff <= FutrPMBData[i].BlkDataBitOff)
			ASSERT(FutrPMBData[i].BlkDataBitOff <= (FutrPMBData[i + 1].MBStartBitOff - FutrPMBData[i].MBStartBitOff))
#endif
		}
		#endif
	}

    // ------------------------------------------------------------------------
    // Copy the compressed image to the output area.
    // ------------------------------------------------------------------------

    SizeBitStream = pCurBitStream - EC->pU8_BitStream + 1;

    /* make sure we don't write 8 empty bits */
    if (!u8bitoffset) SizeBitStream --;

    // Gim 4/21/97 - added check for overall buffer overflow before attaching
	// RTP info and trailer to the end of a P or I frame bitstream
    if (pConfiguration->bRTPHeader)
    {
        SizeBSnEBS = SizeBitStream + H263RTP_GetMaxBsInfoStreamSize(EC);

        if (SizeBSnEBS > u32sizeBSnEBS)
        {
			ERRORMESSAGE(("%s: BS+EBS buffer overflow, SizeBSnEBS %d > %d\r\n", _fx_, SizeBSnEBS, u32sizeBSnEBS));
			memset(EC->pU8_BitStream, 0, SizeBitStream);
            EC->bMakeNextFrameKey = TRUE;
            ret = ICERR_ERROR;
            goto done;
        }
    }

    #ifdef ENCODE_STATS
    uBitStreamBytes = SizeBitStream;
    #endif

    memcpy(lpicComp->lpOutput, EC->pU8_BitStream, SizeBitStream);
    memset(EC->pU8_BitStream, 0, SizeBitStream);

    if (pConfiguration->bRTPHeader)
        SizeBitStream += (WORD) H263RTP_AttachBsInfoStream(EC,
                         (U8 *) lpicComp->lpOutput, SizeBitStream);

    lpCompInst->CompressedSize = SizeBitStream;

    // ------------------------------------------------------------------------
    //  Run the decoder on this frame, to get next basis for prediction.
    // ------------------------------------------------------------------------

    ICDecExSt = DefaultICDecExSt;
    ICDecExSt.lpSrc = lpicComp->lpOutput;
    ICDecExSt.lpbiSrc = lpicComp->lpbiOutput;
    ICDecExSt.lpbiSrc->biSizeImage = SizeBitStream;

    // Decode it in future frame if doing PB-frame
    ICDecExSt.lpDst   = bEncodePBFrame ? EC->pU8_FutrFrm : EC->pU8_PrevFrm;

    ICDecExSt.lpbiDst = NULL;

    if (EC->PictureHeader.PicCodType == INTERPIC)
        ICDecExSt.dwFlags = ICDECOMPRESS_NOTKEYFRAME;

    // Call the decompressor
	// Call the decompressor 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,uStartLow,uStartHigh,uBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263Decompress (EC->pDecInstanceInfo, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE, FALSE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263Decompress (EC->pDecInstanceInfo, (ICDECOMPRESSEX FAR *)&ICDecExSt, FALSE);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,uStartLow,uStartHigh,uBefore,uElapsed,uDecodeFrame)
#endif // } DETAILED_ENCODE_TIMINGS_ON

    if (ret != ICERR_OK)
    {
        // Check to see if an error occurred in the decoder.  If it did
        // we don't have a valid "previous frame" hence force the next
        // frame to be a key frame.
		ERRORMESSAGE(("%s: Decoder failed in encoder\r\n", _fx_));
        EC->bMakeNextFrameKey = TRUE;
        ret = ICERR_ERROR;
        goto done;
    }

    // ------------------------------------------------------------------------
    //  Start processing the saved B frame.
    // ------------------------------------------------------------------------

    if (bEncodePBFrame)
    {
        #ifdef COUNT_BITS
        InitBits(EC);
        #endif

        // zero PB-frame bit stream buffer.
        pPB_BitStream     = EC->pU8_BitStrCopy;
        pP_BitStreamStart = (U8 *) lpicComp->lpOutput;
        u8PB_BitOffset    = 0;

        // Encode the frame header
        EC->PictureHeader.PB = ON;

        // Clear GOB Header Present flag.
        EC->GOBHeaderPresent = 0;
        GOBHeaderMask = 1;

        gquant_prev = EC->PictureHeader.PQUANT;

        if (pConfiguration->bRTPHeader)
            H263RTP_ResetBsInfoStream(EC);

        encodeFrameHeader(EC, &pPB_BitStream, &u8PB_BitOffset, TRUE);

#ifdef USE_MMX // { USE_MMX
        if (MMX_Enabled == FALSE)
        {
            /*****************************************
	         *  . copy edge pels in the previous frame
	         *  . initialize arrays used in motion estimation
	         *  . foreach(GOB)
	         *      . BFRAMEMOTIONESTIMATION
	         *      . Compute Chroma motion vectors
	         *      . Write GOB header
	         *      . FORWARDDCT
	         *      . PB_GOB_Q_RLE_VLC_WriteBS
	         *****************************************/

            for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	        {
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: BFRAME GOB #%d\r\n", _fx_, GOB));

                gquant = FutrFrmGQUANT[GOB];

                if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
                {
                    // Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
                    EC->GOBHeaderPresent |= GOBHeaderMask;

                    gquant_prev = gquant;
                }

                StartingMB = GOB * EC->NumMBPerRow;

				BFRAMEMOTIONESTIMATION(
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_BFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_FutrFrm_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion+32,
					EC->pWeightBackMotion+32,
#else
					WeightForwMotion+32,
					WeightBackMotion+32,
#endif
					u32BFrmZeroThreshold, // Zero Vector Threshold. If less than this threshold don't search for
#if defined(H263P)
					EC->pPseudoStackSpace,
#endif
							// NZ MV's. Set to 99999 to not search.
					128,	// NonZeroMVDifferential. Once the best NZ MV is found, it must be better
							// than the 0 MV SWD by at least this amount.
							// Set to 99999 to never choose NZ MV.
					96, 	// Empty Threshold. Set to 0 to not force empty blocks.
					&InterSWDTotal,
					&InterSWDBlocks
				);

				iSumBSWD += InterSWDTotal;
                if (TogglePB && iSumBSWD >= (3 * iSumSWD) >> 1)
                {
					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Giving up PB, SumBSWD = %d, SumSWD = %d\r\n", _fx_, iSumBSWD, iSumSWD));
                    memset(EC->pU8_BitStrCopy, 0, pPB_BitStream - EC->pU8_BitStrCopy + 1);
                    bPBFailed = TRUE;
                    break;
                }

                // Calculate chroma vectors.
	            calcBGOBChromaVectors(EC, StartingMB);

                FORWARDDCT( 
                    &(EC->pU8_MBlockActionStream[StartingMB]),
                    EC->pU8_BFrm_YPlane,
                    EC->pU8_PrevFrm_YPlane,
                    EC->pU8_FutrFrm_YPlane,
                    EC->pU8_DCTCoefBuf,
                    1,               //  1 = BFrame
                    0,               //  Advanced prediction irrelevant for B frame.
                    0,               //  Is not P of PB pair.
                    0,               //  PredictionScratchArea unneeded.
                    EC->NumMBPerRow
                );

                // GOB header is copied to PB stream when the data for the first
                // macroblock in the GOB is copied

				PB_GOB_Q_RLE_VLC_WriteBS(
					EC,
					EC->pU8_DCTCoefBuf,
					pP_BitStreamStart,
					&pPB_BitStream,
					&u8PB_BitOffset,
#if defined(H263P)
					EC->pFutrPMBData,
#else
					FutrPMBData,
#endif
					GOB,
					min((6*FutrFrmGQUANT[GOB])>>2, 31), // TODO: to match DBQUANT in picture header
					pConfiguration->bRTPHeader
				);
            }
        }
        else // MMX_Enabled == TRUE
	    {
            for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	        {
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: BFRAME GOB #%d\r\n", _fx_, GOB));

                gquant = FutrFrmGQUANT[GOB];

                if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
                {
                    // Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
                    EC->GOBHeaderPresent |= GOBHeaderMask;

                    gquant_prev = gquant;
                }

                // GOB header is copied to PB stream when the data for the first
                // macroblock in the GOB is copied

				PB_GOB_VLC_WriteBS(
					EC,
					EC->pI8_MBRVS_BLuma+GOB*(65*3*22*4),
					EC->pI8_MBRVS_BChroma+GOB*(65*3*22*2),
					pP_BitStreamStart,
					&pPB_BitStream,
					&u8PB_BitOffset,
#if defined(H263P)
					EC->pFutrPMBData,
#else
					FutrPMBData,
#endif
					GOB,
					min((6 * gquant) >> 2, 31),
					pConfiguration->bRTPHeader);
            }
        }
#else // }{ USE_MMX
        /*****************************************
	     *  . copy edge pels in the previous frame
	     *  . initialize arrays used in motion estimation
	     *  . foreach(GOB)
	     *      . BFRAMEMOTIONESTIMATION
	     *      . Compute Chroma motion vectors
	     *      . Write GOB header
	     *      . FORWARDDCT
	     *      . PB_GOB_Q_RLE_VLC_WriteBS
	     *****************************************/

        for (GOB = 0; GOB < EC->NumMBRows; GOB ++, GOBHeaderMask <<= 1)
	    {
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: BFRAME GOB #%d\r\n", _fx_, GOB));
            gquant = FutrFrmGQUANT[GOB];

            if (GOB && (pConfiguration->bRTPHeader || gquant != gquant_prev))
            {
                // Set a bit if header is present. (bit0=GOB0, bit1=GOB1, ...)
                EC->GOBHeaderPresent |= GOBHeaderMask;

                gquant_prev = gquant;
            }

            StartingMB = GOB * EC->NumMBPerRow;

				BFRAMEMOTIONESTIMATION(
					&(EC->pU8_MBlockActionStream[StartingMB]),
					EC->pU8_BFrm_YPlane,
					EC->pU8_PrevFrm_YPlane,
					EC->pU8_FutrFrm_YPlane,
#if defined(H263P)
					EC->pWeightForwMotion+32,
					EC->pWeightBackMotion+32,
#else
					WeightForwMotion+32,
					WeightBackMotion+32,
#endif
					u32BFrmZeroThreshold, // Zero Vector Threshold. If less than this threshold don't search for
#if defined(H263P)
					EC->pPseudoStackSpace,
#endif
							// NZ MV's. Set to 99999 to not search.
					128,	// NonZeroMVDifferential. Once the best NZ MV is found, it must be better
							// than the 0 MV SWD by at least this amount.
							// Set to 99999 to never choose NZ MV.
					96, 	// Empty Threshold. Set to 0 to not force empty blocks.
					&InterSWDTotal,
					&InterSWDBlocks
				);

			iSumBSWD += InterSWDTotal;
            if (TogglePB && iSumBSWD >= (3 * iSumSWD) >> 1)
            {
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Giving up PB, SumBSWD = %d, SumSWD = %d\r\n", _fx_, iSumBSWD, iSumSWD));
                memset(EC->pU8_BitStrCopy, 0, pPB_BitStream - EC->pU8_BitStrCopy + 1);
                bPBFailed = TRUE;
                break;
            }

            // Calculate chroma vectors.
	        calcBGOBChromaVectors(EC, StartingMB);

            FORWARDDCT( 
                &(EC->pU8_MBlockActionStream[StartingMB]),
                EC->pU8_BFrm_YPlane,
                EC->pU8_PrevFrm_YPlane,
                EC->pU8_FutrFrm_YPlane,
                EC->pU8_DCTCoefBuf,
                1,               //  1 = BFrame
                0,               //  Advanced prediction irrelevant for B frame.
                0,               //  Is not P of PB pair.
                0,               //  PredictionScratchArea unneeded.
                EC->NumMBPerRow
            );

            // GOB header is copied to PB stream when the data for the first
            // macroblock in the GOB is copied

				PB_GOB_Q_RLE_VLC_WriteBS(
					EC,
					EC->pU8_DCTCoefBuf,
					pP_BitStreamStart,
					&pPB_BitStream,
					&u8PB_BitOffset,
#if defined(H263P)
					EC->pFutrPMBData,
#else
					FutrPMBData,
#endif
					GOB,
					min((6*FutrFrmGQUANT[GOB])>>2, 31), // TODO: to match DBQUANT in picture header
					pConfiguration->bRTPHeader
				);
        }
#endif // } USE_MMX

        if (bPBFailed == FALSE)
		{
			// Copy the compressed image to the output area.
			SizeBitStream = pPB_BitStream - EC->pU8_BitStrCopy + 1;

			// make sure we don't write 8 empty bits
			if (u8PB_BitOffset == 0) SizeBitStream --;

            // Gim 4/21/97 - check to see if the PB buffer overflows the spec
            // size. If it does, zero out the PB buffer and continue.  The P
            // frame encoded will be returned.
			if (SizeBitStream > u32sizeBitBuffer)
			{
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: PB buffer overflow, SizeBitStream %d > %d\r\n", _fx_, SizeBitStream, u32sizeBitBuffer));
                bPBFailed = TRUE;
			}
            else
            if (pConfiguration->bRTPHeader)
            {
                SizeBSnEBS = SizeBitStream + H263RTP_GetMaxBsInfoStreamSize(EC);

                if (SizeBSnEBS > u32sizeBSnEBS)
                {
					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: PB BS+EBS buffer overflow, SizeBSnEBS %d > %d\r\n", _fx_, SizeBSnEBS, u32sizeBSnEBS));
                    bPBFailed = TRUE;
                }
            }

            if (bPBFailed == TRUE)
			{
                // if buffer overflow has been detected, we will drop the PB
                // and return the encoded P
                memset(EC->pU8_BitStrCopy, 0, SizeBitStream);
                EC->u8SavedBFrame = FALSE;
			}
			else
            {
                #ifdef ENCODE_STATS
				uBitStreamBytes = SizeBitStream;
				#endif

				memcpy(lpicComp->lpOutput, EC->pU8_BitStrCopy, SizeBitStream);
				memset(EC->pU8_BitStrCopy, 0, SizeBitStream);

                if (pConfiguration->bRTPHeader)
                    SizeBitStream += (WORD) H263RTP_AttachBsInfoStream(EC,
                                     (U8 *) lpicComp->lpOutput, SizeBitStream);

				lpCompInst->CompressedSize = SizeBitStream;
			}
        }

        // For the next PB-frame, frame pointers are swapped; i.e. for the next
        // frame future ...

        temp = EC->pU8_PrevFrm;
        EC->pU8_PrevFrm = EC->pU8_FutrFrm;
        EC->pU8_FutrFrm = temp;

        temp = EC->pU8_PrevFrm_YPlane;
        EC->pU8_PrevFrm_YPlane = EC->pU8_FutrFrm_YPlane;
        EC->pU8_FutrFrm_YPlane = temp;

        temp = EC->pU8_PrevFrm_UPlane;
        EC->pU8_PrevFrm_UPlane = EC->pU8_FutrFrm_UPlane;
        EC->pU8_FutrFrm_UPlane = temp;

        temp = EC->pU8_PrevFrm_VPlane;
        EC->pU8_PrevFrm_VPlane = EC->pU8_FutrFrm_VPlane;
        EC->pU8_FutrFrm_VPlane = temp;

        EC->u8SavedBFrame = FALSE;
        EC->PictureHeader.PB = OFF;   // RH: why is this here ?
    } // if (bEncodePBFrame)

	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Frame size: %d\r\n", _fx_, lpCompInst->CompressedSize));

    #ifdef ENCODE_STATS
    StatsFrameSize(uBitStreamBytes, lpCompInst->CompressedSize);
    #endif

    // ------------------------------------------------------------------------
    //  update states for next frame, etc.
    // ------------------------------------------------------------------------

	// This is a still image sequence and there is still more quantizers
	// in the sequence, then increment the quantizer.
    if ((lpicComp->dwFlags & CODEC_CUSTOM_STILL) &&
        (EC->BRCState.u8StillQnt < (numStillImageQnts-1)))
        EC->BRCState.u8StillQnt ++;

    // Calculate average quantizer to be used for next frame.
    if (EC->PictureHeader.PicCodType == INTERPIC)
    	EC->BRCState.QP_mean = (QP_cumulative + (EC->NumMBRows >> 1)) / EC->NumMBRows;
	else
		// If this is an INTRA frame, then we don't want to
		// use the QP for the next delta frame, hence we just
		// reset the QP_mean to the default.
    	EC->BRCState.QP_mean = def263INTER_QP;

    // Record frame size for bit rate controller on next frame.

	// IP + UDP + RTP + payload mode C header - worst case
	#define TRANSPORT_HEADER_SIZE (20 + 8 + 12 + 12)
	DWORD dwTransportOverhead;

	// Estimate the transport overhead
	if (pConfiguration->bRTPHeader)
		dwTransportOverhead = (lpCompInst->CompressedSize / pConfiguration->unPacketSize + 1) * TRANSPORT_HEADER_SIZE;
	else
		dwTransportOverhead = 0UL;

#ifdef USE_MMX // { USE_MMX
	if (EC->PictureHeader.PicCodType == INTRAPIC)
		EC->BRCState.uLastINTRAFrmSz = dwTransportOverhead + ((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize);
	else
		EC->BRCState.uLastINTERFrmSz = dwTransportOverhead + ((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize);

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Total cumulated frame size = %ld bits (data: %ld, transport overhead: %ld)\r\n", _fx_, (((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize) << 3) + (dwTransportOverhead << 3), ((MMX_Enabled == FALSE) ? uAdjCumFrmSize : uCumFrmSize) << 3, dwTransportOverhead << 3));
#else // }{ USE_MMX
    if (EC->PictureHeader.PicCodType == INTRAPIC)
        EC->BRCState.uLastINTRAFrmSz = dwTransportOverhead + uAdjCumFrmSize;
    else
		EC->BRCState.uLastINTERFrmSz = dwTransportOverhead + uAdjCumFrmSize;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Total cumulated frame size = %ld bits (data: %ld, transport overhead: %ld)\r\n", _fx_, (uAdjCumFrmSize << 3) + (dwTransportOverhead << 3), uAdjCumFrmSize << 3, dwTransportOverhead << 3));
#endif // } USE_MMX

	// Save temporal reference for next frame.
	EC->PictureHeader.TRPrev = EC->PictureHeader.TR;

	// Save AP, UMV and DF modes in case InitMEState needs to re-initialize some data
	if (EC->PictureHeader.PicCodType == INTERPIC)
	{
		EC->prevAP = EC->PictureHeader.AP;
		EC->prevUMV = EC->PictureHeader.UMV;
#ifdef H263P
		EC->prevDF = EC->PictureHeader.DeblockingFilter;
#endif
	}

	// send mean quantizer to real-time app. Not necessary, info. only
	*(lpicComp->lpdwFlags) |= (EC->BRCState.QP_mean << 16);

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_STOP(bTimingThisFrame,uStartLow,uStartHigh,uEncodeTime);

	if (bTimingThisFrame)
	{
		// Update the decompression timings counter
		#pragma message ("Current encode timing computations assume P5/90Mhz")
		UPDATE_COUNTER(g_pctrCompressionTimePerFrame, (uEncodeTime + 45000UL) / 90000UL);

		DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Compression time: %ld\r\n", _fx_, (uEncodeTime + 45000UL) / 90000UL));
	}
#endif // } ENCODE_TIMINGS_ON

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (bTimingThisFrame)
	{
		pEncTimingInfo = EC->pEncTimingInfo + EC->uStatFrameCount;
		pEncTimingInfo->uEncodeFrame      = uEncodeTime;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		pEncTimingInfo->uInputCC          = uInputCC;
		pEncTimingInfo->uMotionEstimation = uMotionEstimation;
		pEncTimingInfo->uFDCT             = uFDCT;
		pEncTimingInfo->uQRLE             = uQRLE;
		pEncTimingInfo->uDecodeFrame      = uDecodeFrame;
		pEncTimingInfo->uZeroingBuffer    = uZeroingBuffer;
#endif // } DETAILED_ENCODE_TIMINGS_ON
		EC->uStatFrameCount++;
	}
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

/*
#ifdef REUSE_DECODE
    CompandedFrame.Address = (unsigned char*) lpicComp->lpOutput;
    CompandedFrame.PDecoderInstInfo = PDecoderInstInfo;
    CompandedFrame.FrameNumber = PFrmHdr->FrameNumber;
#endif
*/

#if ELAPSED_ENCODER_TIME
    StopElapsed ();
    Elapsed = ReadElapsed () / 4L;
    Sample = ReadSample () / 4L;
#if 01
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: "%ld,%ld us\r\n", _fx_, Elapsed, Sample));
#else
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Elapsed time to encode frame: %ld us\r\n", _fx_, Elapsed));
#if SAMPLE_RGBCONV_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to convert RGB24 to YUV9: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_MOTION_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to do motion estimation: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_ENCBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to encode block layer: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_ENCMBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to encode macroblock layer: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_ENCVLC_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to encode VLC: %ld us\r\n", _fx_, Sample));
#endif
#if SAMPLE_COMPAND_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Time to decode companded image: %ld us\r\n", _fx_, Sample));
#endif
#endif
    TotalElapsed += Elapsed;
    TotalSample  += Sample;
    TimedIterations++;
#endif

done:
//    GlobalUnlock(lpCompInst->hEncoderInst);

#ifdef FORCE_ADVANCED_OPTIONS_ON // { FORCE_ADVANCED_OPTIONS_ON
	// Force advanced options for testing
	if (!(lpicComp->dwFlags & ICCOMPRESS_KEYFRAME))
		lpicComp->lFrameNum /= 5;
#endif // } FORCE_ADVANCED_OPTIONS_ON

#ifdef USE_MMX // { USE_MMX
	if (MMX_Enabled)
	{
		__asm {
			_emit 0x0f
			_emit 0x77	//	emms
		}
	}
#endif // } USE_MMX

    return ret;
}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func UN | FindNewQuant | This function computes the GQUANT value to
 *   use for a GOB.
 *
 * @parm T_H263EncoderCatalog * | EC | Specifies a pointer to the encoder
 *   catalog (global encoder state).
 *
 * @parm UN | gquant_prev | Specifies the GQUANT value of the previous GOB.
 *
 * @parm UN | uCumFrmSize | Specifies the cumulated size of the previous GOBs.
 *
 * @parm UN | GOB | Specifies the number of the GOB to find a new quantizer
 *   for.
 *
 * @parm U8 | u8QPMax | Specifies the maximum GQUANT value for the GOB. It
 *   is always set to 31.
 *
 * @parm U8 | u8QPMin | Specifies the minimum GQUANT value for the GOB. It
 *   is typically 1 when compressing at high quality, or 15 at low quality.
 *
 * @parm BOOL | bBitRateControl | If set to TRUE, the new value for GQUANT
 *   is computed to achieve a target bitrate.
 *
 * @parm BOOL | bGOBoverflowWarning | If set to TRUE, the previous GQUANT was
 *   tool low and could potentially generate a buffer overflow.
 *
 * @rdesc The GQUANT value.
 *
 * @xref <f CalcMBQUANT>
 ***************************************************************************/
UN FindNewQuant(
	T_H263EncoderCatalog *EC, 
	UN gquant_prev,
	UN uCumFrmSize,
	UN GOB,
	U8 u8QPMax,
	U8 u8QPMin,
	BOOL bBitRateControl,
	BOOL bGOBoverflowWarning
	)
{
	FX_ENTRY("FindNewQuant");

	I32 gquant_delta;
	I32 gquant;

	if (bBitRateControl == ON)
	{
		// Check out if some GOBs have been arbitrary forced to be Intra coded. This always
		// returns TRUE for an I-frame, and FALSE for all other frame types since this can only
		// return TRUE for predicted frames when the error resiliency mode is ON, and we never
		// use this mode.
		if (IsIntraCoded(EC,GOB) && GOB)
			gquant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[GOB], EC->uBitUsageProfile[EC->NumMBRows], uCumFrmSize,INTRAPIC);
		else
			gquant = CalcMBQUANT(&(EC->BRCState), EC->uBitUsageProfile[GOB], EC->uBitUsageProfile[EC->NumMBRows], uCumFrmSize, EC->PictureHeader.PicCodType);

		EC->uBitUsageProfile[GOB] = uCumFrmSize;

		// Make sure we don't exceed the maximum quantizer value
		if (gquant > u8QPMax)
			gquant = u8QPMax;

		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Bitrate controller enabled for GOB #%ld (uCumFrmSize = %ld bits and gquant_prev = %ld), setting gquant = %ld (min and max were %ld and %ld)\r\n", _fx_, GOB, uCumFrmSize << 3, gquant_prev, gquant, u8QPMin, u8QPMax));
    }
    else
    {
		// No bitrate control. Use the picture quantizer value for this GOB
        gquant = EC->PictureHeader.PQUANT;

		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("%s: Bitrate controller disabled for GOB #%ld (uCumFrmSize = %ld bits and gquant_prev = %ld), setting gquant = %ld (min and max were %ld and %ld)\r\n", _fx_, GOB, uCumFrmSize << 3, gquant_prev, gquant, u8QPMin, u8QPMax));
    }
    
	// Make sure we're not below the minimum quantizer value
    if (gquant < u8QPMin)
		gquant = u8QPMin;

    // Limit the amount that GQUANT can change from frame to frame
    gquant_delta = gquant - gquant_prev;

	// Increase the QP value if there is danger of buffer overflow
	if (!bGOBoverflowWarning)
	{
		// There's no overflow warning, but we don't want the quantizer value to
		// fluctuate too much from GOB to GOB
		if (gquant_delta > 4L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("  %s: Limiting amount of increase for GOB #%ld to 4, changing gquant from %ld to %ld\r\n", _fx_, GOB, gquant, clampQP(gquant_prev + 4L)));

			gquant = gquant_prev + 4L;
		}
		else if (gquant_delta < -2L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("  %s: Limiting amount of decrease for GOB #%ld to -2, changing gquant from %ld to %ld\r\n", _fx_, GOB, gquant, clampQP(gquant_prev - 2L)));

			gquant = gquant_prev - 2L;
		}
	} 
	else 
	{
		// There's a risk of overflow - arbitrarily raise the value of the quantizer if necessary
		if (gquant_delta < 4L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, ("  %s: Danger of overflow for GOB #%ld, changing gquant from %ld to %ld\r\n", _fx_, GOB, gquant, clampQP(gquant_prev + 4L)));

			gquant = gquant_prev + 4L;
		}
	}

	return clampQP(gquant);
}


/*******************************************************************************

H263TermEncoderInstance -- This function frees the space allocated for an
                          instance of the H263 encoder.

*******************************************************************************/
LRESULT H263TermEncoderInstance(LPCODINST lpInst)
{
	LRESULT ret;
	U8 BIGG * P32Inst;
	T_H263EncoderCatalog FAR * EC;

	FX_ENTRY("H263TermEncoderInstance")

	#if DUMPFILE
	_lclose (dmpfil);
	#endif

	#if ELAPSED_ENCODER_TIME
	if (TimedIterations == 0) TimedIterations = 10000000;
	TotalElapsed /= TimedIterations;
	TotalSample  /= TimedIterations;
	#if 01
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: "%ld,%ld us\r\n", _fx_, TotalElapsed, TotalSample));
	#else
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average elapsed time to encode frame: %ld us\r\n", _fx_, TotalElapsed));
	#if SAMPLE_RGBCONV_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to convert RGB24 to YUV9: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_MOTION_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to do motion estimation: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_ENCBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to encode block layer: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_ENCMBLK_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to encode macroblock layer: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_ENCVLC_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to encode VLC: %ld us\r\n", _fx_, TotalSample));
	#endif
	#if SAMPLE_COMPAND_TIME
	DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Average time to decode companded image: %ld us\r\n", _fx_, TotalSample));
	#endif
	#endif
	#endif

	// Check instance pointer
	if (!lpInst)
		return ICERR_ERROR;

	if(lpInst->Initialized == FALSE)
	{
		ERRORMESSAGE(("%s: Uninitialized instance\r\n", _fx_));
		ret = ICERR_OK;
		goto done;
	}
	lpInst->Initialized = FALSE;

	//  lpInst->EncoderInst = (LPVOID)GlobalLock(lpInst->hEncoderInst);
	lpInst->EncoderInst = lpInst->hEncoderInst;

	P32Inst = (U8 *)
		    ((((U32) lpInst->EncoderInst) + 
		              (sizeof(T_MBlockActionStream) - 1)) &
		             ~(sizeof(T_MBlockActionStream) - 1));
	EC = ((T_H263EncoderCatalog  *) P32Inst);

	// Check encoder catalog pointer
	if (!EC)
		return ICERR_ERROR;

	if (lpInst->Configuration.bRTPHeader)
		H263RTP_TermBsInfoStream(EC);

	#ifdef ENCODE_STATS
	OutputQuantStats("encstats.txt");
	OutputPSNRStats("encstats.txt");
	OutputFrameSizeStats("encstats.txt");
	#endif /* ENCODE_STATS */

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (EC->pEncTimingInfo)
		OutputEncodeTimingStatistics("c:\\encode.txt", EC->pEncTimingInfo);
#endif // } LOG_ENCODE_TIMINGS_ON

	ret = H263TermColorConvertor(EC->pDecInstanceInfo);
	if (ret != ICERR_OK) goto done;

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263TermDecoderInstance(EC->pDecInstanceInfo, FALSE);
#else // }{ #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	ret = H263TermDecoderInstance(EC->pDecInstanceInfo);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	if (ret != ICERR_OK) goto done;

	// Free virtual memory
	VirtualFree(EC->pI8_MBRVS_BLuma,0,MEM_RELEASE);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)EC->pI8_MBRVS_BLuma);
#endif
	VirtualFree(EC->pI8_MBRVS_BChroma,0,MEM_RELEASE);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)EC->pI8_MBRVS_BChroma);
#endif
	// No matter how many sparse pages we committed during encoding,
	// the whole memory block is released with these calls.
	// Documentation on VirtualFree() says the individual pages must
	// first be decommitted, but this is not correct, according
	// to Jeffrey R. Richter

	//  GlobalUnlock(lpInst->hEncoderInst);
	//  GlobalFree(lpInst->hEncoderInst);

	VirtualFree(lpInst->hEncoderInst,0,MEM_RELEASE);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)lpInst->hEncoderInst);
#endif

	ret = ICERR_OK;

	done:

	return ret;
}

/************************************************************************
 *
 *  GetEncoderOptions
 *
 *  Get the options, saving them in the catalog
 *************************************************************************/
static void GetEncoderOptions(T_H263EncoderCatalog * EC)
{
	/* Default Options
	 */
#ifdef FORCE_ADVANCED_OPTIONS_ON // { FORCE_ADVANCED_OPTIONS_ON
	// Force PB-Frames for testing
	EC->u8EncodePBFrame = OFF;
	// Force UMV for testing
	EC->PictureHeader.UMV = ON;
	// Force SAC for testing
	EC->PictureHeader.SAC = ON;
	// Force AP for testing
	EC->PictureHeader.AP = ON;
#else // }{ FORCE_ADVANCED_OPTIONS_ON
	EC->u8EncodePBFrame = FALSE;
	EC->PictureHeader.UMV = OFF;
	EC->PictureHeader.SAC = OFF;
	EC->PictureHeader.AP = OFF;
#endif // } FORCE_ADVANCED_OPTIONS_ON
#ifdef USE_MMX // { USE_MMX
	MMX_Enabled = MMxVersion;
#endif // } USE_MMX
#ifdef H263P
	EC->bH263Plus = FALSE;
	EC->PictureHeader.DeblockingFilter = OFF;
	EC->PictureHeader.ImprovedPB = OFF;
#endif
	EC->bUseINISettings = 0;	// Clear option override.
	return;

} /* end GetEncoderOptions() */

/*************************************************************
 *  Name:         encodeFrameHeader
 *  Description:  Write out the PB-frame header to the bit stream.
 ************************************************************/
static void encodeFrameHeader(
    T_H263EncoderCatalog *  EC,
    U8                   ** ppCurBitStream,
    U8                   *  pBitOffset,
    BOOL                    PBframe
)
{
	U8 temp=0;
#ifdef H263P
	BOOL bUseH263PlusOptions = FALSE;
#endif

    //  Picture start code
    PutBits(FIELDVAL_PSC, FIELDLEN_PSC, ppCurBitStream, pBitOffset);
    //  TR : Temporal reference
    PutBits(EC->PictureHeader.TR, FIELDLEN_TR,  ppCurBitStream, pBitOffset);
    //  PTYPE : bits 1-2
    PutBits(0x2, FIELDLEN_PTYPE_CONST, ppCurBitStream, pBitOffset);
    //  PTYPE : bit 3 split screen indicator
    PutBits(EC->PictureHeader.Split, FIELDLEN_PTYPE_SPLIT,  ppCurBitStream,
            pBitOffset);
    //  PTYPE : bit 4 document camera indicator
    PutBits(EC->PictureHeader.DocCamera, FIELDLEN_PTYPE_DOC, ppCurBitStream,
            pBitOffset);
    //  PTYPE : bit 5 freeze picture release
    PutBits(EC->PictureHeader.PicFreeze, FIELDLEN_PTYPE_RELEASE,
            ppCurBitStream, pBitOffset);

#ifdef H263P
	if ((EC->FrameSz == CUSTOM) ||
		(EC->PictureHeader.DeblockingFilter == ON) ||
		(EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON)
		// other supported H.263+ options
		)
	{
		// PTYPE : bits 6-8 extended PTYPE flag
		enum FrameSize tmpFrameSz = EPTYPE;

		bUseH263PlusOptions = TRUE; 		// at least one H.263+ optional mode requested
		PutBits(tmpFrameSz, FIELDLEN_PTYPE_SRCFORMAT, ppCurBitStream, pBitOffset);
	}
	else
	{
		//	PTYPE : bits 6-8 source format
		PutBits(EC->FrameSz, FIELDLEN_PTYPE_SRCFORMAT,	ppCurBitStream, pBitOffset);
	}
#else
	//  PTYPE : bits 6-8 source format
	PutBits(EC->FrameSz, FIELDLEN_PTYPE_SRCFORMAT,  ppCurBitStream, pBitOffset);
#endif

    //  PTYPE : bit 9 picture coding type
    PutBits(EC->PictureHeader.PicCodType, FIELDLEN_PTYPE_CODINGTYPE,
             ppCurBitStream, pBitOffset);
    //  PTYPE : bit 10 UMV
    PutBits(EC->PictureHeader.UMV, FIELDLEN_PTYPE_UMV,
             ppCurBitStream, pBitOffset);
    //  PTYPE : bit 11 SAC
    PutBits(EC->PictureHeader.SAC, FIELDLEN_PTYPE_SAC,
            ppCurBitStream, pBitOffset);
    //  PTYPE : bit 12 advanced prediction mode
    PutBits(EC->PictureHeader.AP, FIELDLEN_PTYPE_AP,
            ppCurBitStream, pBitOffset);
    //  PTYPE : bit 13 PB-frames mode
    PutBits(EC->PictureHeader.PB, FIELDLEN_PTYPE_PB,
            ppCurBitStream, pBitOffset);

#ifdef H263P

	// EPTYPE : 18 bits
	if (bUseH263PlusOptions) {
		//	EPTYPE : bits 1-3 source format
		PutBits(EC->FrameSz, FIELDLEN_EPTYPE_SRCFORMAT,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 4 custom PCF
		PutBits(EC->PictureHeader.CustomPCF, FIELDLEN_EPTYPE_CPCF,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 5 advanced intra coding mode
		PutBits(EC->PictureHeader.AdvancedIntra, FIELDLEN_EPTYPE_AI,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 6 deblocking filter mode
		PutBits(EC->PictureHeader.DeblockingFilter, FIELDLEN_EPTYPE_DF,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 7 slice structured mode
		PutBits(EC->PictureHeader.SliceStructured, FIELDLEN_EPTYPE_SS,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 8 improved PB-frame mode
		PutBits((EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB),
				FIELDLEN_EPTYPE_IPB,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 9 back-channel operation mode
		PutBits(EC->PictureHeader.BackChannel, FIELDLEN_EPTYPE_BCO,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 10 SNR and spatial scalability mode
		PutBits(EC->PictureHeader.Scalability, FIELDLEN_EPTYPE_SCALE,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 11 true B-frame mode
		PutBits(EC->PictureHeader.TrueBFrame, FIELDLEN_EPTYPE_TB,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 12 reference-picture resampling mode
		PutBits(EC->PictureHeader.RefPicResampling, FIELDLEN_EPTYPE_RPR,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 13 reduced-resolution update mode
		PutBits(EC->PictureHeader.RedResUpdate, FIELDLEN_EPTYPE_RRU,
				ppCurBitStream, pBitOffset);
		//	EPTYPE : bit 14-18 reserved
		PutBits(0x1, FIELDLEN_EPTYPE_CONST, ppCurBitStream, pBitOffset);
	}

	if (EC->FrameSz == CUSTOM) {
		// CSFMT : bit 1-4 pixel aspect ratio code
		// TODO. For now, force to CIF
		PutBits(0x2, FIELDLEN_CSFMT_PARC,
				ppCurBitStream, pBitOffset);
		// CSFMT : bits 5-13 frame width indication
		PutBits((EC->uActualFrameWidth >> 2) - 1, FIELDLEN_CSFMT_FWI,
				ppCurBitStream, pBitOffset);
		// CSFMT : bit 14 "1" to avoid start code emulation
		PutBits(0x1, FIELDLEN_CSFMT_CONST, ppCurBitStream, pBitOffset);
		// CSFMT : bits 15-23 frame height indication
		PutBits((EC->uActualFrameHeight >> 2) - 1, FIELDLEN_CSFMT_FHI,
				ppCurBitStream, pBitOffset);
	}
#endif

    //  PQUANT
    PutBits(EC->PictureHeader.PQUANT, FIELDLEN_PQUANT,
            ppCurBitStream, pBitOffset);
    //  CPM
    PutBits(EC->PictureHeader.CPM, FIELDLEN_CPM,
            ppCurBitStream, pBitOffset);
    if (PBframe == TRUE)
    {
        
        //  AG:TODO
        //  TRB
        PutBits(EC->PictureHeader.TRB, FIELDLEN_TRB,
                ppCurBitStream, pBitOffset);
        //  AG:TODO
        //  DBQUANT
        PutBits(EC->PictureHeader.DBQUANT, FIELDLEN_DBQUANT,
                ppCurBitStream, pBitOffset);

		#ifdef COUNT_BITS
		EC->Bits.PictureHeader += FIELDLEN_TRB + FIELDLEN_DBQUANT;
		#endif
    }
    
    //  PEI
    PutBits(EC->PictureHeader.PEI, FIELDLEN_PEI,
            ppCurBitStream, pBitOffset);

	#ifdef COUNT_BITS
	EC->Bits.PictureHeader    += FIELDLEN_PSC + FIELDLEN_TR
	+ FIELDLEN_PTYPE_CONST     + FIELDLEN_PTYPE_SPLIT
	+ FIELDLEN_PTYPE_DOC       + FIELDLEN_PTYPE_RELEASE
	+ FIELDLEN_PTYPE_SRCFORMAT + FIELDLEN_PTYPE_CODINGTYPE
	+ FIELDLEN_PTYPE_UMV       + FIELDLEN_PTYPE_SAC
	+ FIELDLEN_PTYPE_AP        + FIELDLEN_PTYPE_PB
	+ FIELDLEN_PQUANT          + FIELDLEN_CPM
	+ FIELDLEN_PEI;
	#endif
}


/*************************************************************
 *  Name:         InitMEState
 *  Description:  Initialize the MB action stream for the ME 
 *                state engine. 
 ************************************************************/
 void InitMEState(T_H263EncoderCatalog *EC, ICCOMPRESS *lpicComp, T_CONFIGURATION *pConfiguration)
 {
 	register unsigned int i;
	U8 u8FirstMEState;

	FX_ENTRY("InitMEState")

	// TODO: The FirstMEState initialization can be avoided
	// for each compress by either adding a parameter to the
	// motion estimator signalling key frame, or by not calling
	// motion estimation on intra frames, and resetting MBType,
	// CodedBlocks ourselves.
    if (EC->PictureHeader.PicCodType == INTRAPIC)
    {
        for(i=0; i < EC->NumMBs; i++)
        {
            // Clear the intercode count.
            (EC->pU8_MBlockActionStream[i]).InterCodeCnt = (i & 0xf);
            // For the motion estimator, this field must be set to force
            // intra blocks for intra frames.
            (EC->pU8_MBlockActionStream[i]).FirstMEState = ForceIntra;
        }

        *(lpicComp->lpdwFlags) |=  AVIIF_KEYFRAME;
        lpicComp->dwFlags |= ICCOMPRESS_KEYFRAME;

		// Store that this frame was intra coded. Used during the initialization
		// of the ME state for the next frame.
		EC->bPrevFrameIntra = TRUE;

    }
    else  //  Picture Coding type is INTERPIC
    {
		/*
		 * The FirstMEState element in each MB structure must be set
		 * to indicate its position in the frame. This is used by the
		 * motion estimator.
		 */

	   /*
		* Check for AP or UMV modes. When these mode is signalled, motion vectors are
		* allowed to point outside the picture.
		*/

	    /* We also need to perform the initialization if the previous frame
		   was an intra frame! (JM) 
		 */
		if (EC->bPrevFrameIntra ||
			EC->PictureHeader.AP != EC->prevAP ||
			EC->PictureHeader.UMV != EC->prevUMV
#ifdef H263P
			|| EC->PictureHeader.DeblockingFilter != EC->prevDF
#endif
			) {

			if( (EC->PictureHeader.UMV == ON) || (EC->PictureHeader.AP == ON)
#ifdef H263P
				|| (EC->PictureHeader.DeblockingFilter == ON)
#endif
			  )
			{
				// Set ME state central blocks.
				for(i=0; i < EC->NumMBs; i++)
					(EC->pU8_MBlockActionStream[i]).FirstMEState = CentralBlock;
			}
			else	// No AP or UMV option.
			{
        		// Set upper left corner
        		(EC->pU8_MBlockActionStream[0]).FirstMEState = UpperLeft;

        		// Set ME state for top edge.
        		for(i=1; i < EC->NumMBPerRow; i++)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = UpperEdge;

        		// Set upper right corner.
        		(EC->pU8_MBlockActionStream[ EC->NumMBPerRow - 1 ]).FirstMEState = UpperRight;

        		// Set ME state for central blocks.
        		for(i=EC->NumMBPerRow; i < EC->NumMBs; i++)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = CentralBlock;

        		// Set ME state for bottom edge.
        		for(i= (EC->NumMBs - EC->NumMBPerRow); i < EC->NumMBs; i++)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = LowerEdge;

        		// Set ME state for left edge
        		for(i= EC->NumMBPerRow ; i < EC->NumMBs; i += EC->NumMBPerRow)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = LeftEdge;

        		// Set ME state for right edge.
        		for(i= 2 * EC->NumMBPerRow - 1 ; i < EC->NumMBs; i += EC->NumMBPerRow)
		    		(EC->pU8_MBlockActionStream[i]).FirstMEState = RightEdge;

        		// Bottom left corner.
        		(EC->pU8_MBlockActionStream[EC->NumMBs - EC->NumMBPerRow]).FirstMEState = LowerLeft;

        		// Bottom right corner.
        		(EC->pU8_MBlockActionStream[EC->NumMBs - 1]).FirstMEState = LowerRight;

			} // end of else (not UMV)

		} // end of if (bPrevFrameIntra || prevAP != AP || prevUMV != UMV || prevDF != DF)

      	// Clear key frame flag.
       	*(lpicComp->lpdwFlags) &= ~AVIIF_KEYFRAME;
		lpicComp->dwFlags &= ~ICCOMPRESS_KEYFRAME;

		// Store that this frame was not intra coded. Used during the initialization
		// of the ME state for the next frame.
		EC->bPrevFrameIntra = FALSE;

    }

	// RTP stuff which needs to be done for every frame (?)
	if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
	{	//Chad	intra GOB
		
		// Of course unPacketLoss is non-zero. Why are we checking it here
		if (pConfiguration->unPacketLoss > 0)
		{	//Chad INTRA GOB
			EC->uNumberForcedIntraMBs = ((EC->NumMBs * pConfiguration->unPacketLoss) + 50) / 100;
			EC->uNumberForcedIntraMBs = (EC->uNumberForcedIntraMBs+EC->NumMBPerRow-1) / EC->NumMBPerRow * EC->NumMBPerRow;
		}

		if (EC->uNumberForcedIntraMBs > 0)
		{
			/* Force all the MBs in a GOB to intra.
			 */
			for ( i = 0 ; i < EC->uNumberForcedIntraMBs ; i++, EC->uNextIntraMB++)
			{ // Reset it to the first row when we reach the end.

				if (EC->uNextIntraMB >= EC->NumMBs)
				{
					EC->uNextIntraMB = 0;
				}
				 (EC->pU8_MBlockActionStream[EC->uNextIntraMB]).FirstMEState = ForceIntra;

			}

		}

		if (pConfiguration->bDisallowAllVerMVs)
	 	{
	 		/* Walk thru all the FirstMEStateME settings turning off Vertical.
	 		 */
	      	for(i=0; i < EC->NumMBs; i++)
	 		{
	 			u8FirstMEState = (EC->pU8_MBlockActionStream[i]).FirstMEState;
	 			switch (u8FirstMEState)
	 			{
	 				case ForceIntra:
	 					break;
	 				case UpperLeft:
	 				case LeftEdge:
	 				case LowerLeft:
	 					u8FirstMEState = NoVertLeftEdge;
	 				    break;
	 				case UpperEdge:
	 				case CentralBlock:
	 				case LowerEdge:
	 				    u8FirstMEState = NoVertCentralBlock;
	 				    break;
	 				case UpperRight:
	 				case RightEdge:
	 				case LowerRight:
	 				    u8FirstMEState = NoVertRightEdge;
	 				    break;
	 				case NoVertLeftEdge:
	 				case NoVertCentralBlock:
	 				case NoVertRightEdge:
	 					ASSERT(0);  /* It should work, but why was this already on */
	 					break;
	 				default:
						DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: Unexpected FirstMEState\r\n", _fx_));
	 					break;
	 			}
	 			(EC->pU8_MBlockActionStream[i]).FirstMEState = u8FirstMEState;
	 		}
	 	} 
	 	else if (pConfiguration->bDisallowPosVerMVs)
	 	{	/* Walk thru all the FirstMEState settings turning off Positive Vertical
	 	     */
	      	for(i=0; i < EC->NumMBs; i++)
	 		{
	 			u8FirstMEState = (EC->pU8_MBlockActionStream[i]).FirstMEState;
	 			switch (u8FirstMEState)
	 			{
	 				case ForceIntra:
	 				case LowerLeft:
	 				case LowerEdge:
	 				case LowerRight:
	 					break;
	 				case UpperLeft:
	 					u8FirstMEState = NoVertLeftEdge;
	 					break;
	 				case LeftEdge:
	 					u8FirstMEState = LowerLeft;
	 				    break;
	 				case UpperEdge:
	 				    u8FirstMEState = NoVertCentralBlock;
	 				    break;
	 				case CentralBlock:
	 				    u8FirstMEState = LowerEdge;
	 				    break;
	 				case UpperRight:
	 				    u8FirstMEState = NoVertRightEdge;
	 				    break;
	 				case RightEdge:
	 				    u8FirstMEState = LowerRight;
	 				    break;
	 				case NoVertLeftEdge:
	 				case NoVertCentralBlock:
	 				case NoVertRightEdge:
	 					ASSERT(0);  /* It should work, but why was this already on */
	 					break;
	 				default:
						DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: Warning: Unexpected FirstMEState\r\n", _fx_));
	 					break;
	 			}
	 			(EC->pU8_MBlockActionStream[i]).FirstMEState = u8FirstMEState;
	 		} /* for */
	 	} /* else if... */
	 } /* if (pConfiguration->bEncoderResiliency) */

} // end of InitMEState()


#ifdef USE_MMX // { USE_MMX
/*************************************************************
 *  Name: Check_InterCodeCnt_MMX
 *  Description:  Track inter code count for macro blocks
 *				  for forced update. Called before Motion 
 *                Estimation.
 ************************************************************/
static void Check_InterCodeCnt_MMX(T_H263EncoderCatalog *EC, U32 StartingMB)
{
	register T_MBlockActionStream *pCurrMB;
	T_MBlockActionStream *pLastMBPlus1;

	pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]);
    
	for(; pCurrMB < pLastMBPlus1; pCurrMB++, StartingMB++) 
	{
		// Check to see if it's time to refresh this block.
		if(pCurrMB->InterCodeCnt > 132) 
		{
			pCurrMB->CodedBlocks |= 0x80;
			// InterCodeCnt is reset in GOB_VLC_WriteBS() in e3mbenc.cpp */
		}

	}
}
#endif // } USE_MMX


/*************************************************************
 *  Name: Check_InterCodeCnt
 *  Description:  Track inter code count for macro blocks
 *				  for forced update. Called after Motion 
 *                Estimation.
 ************************************************************/
static void Check_InterCodeCnt(T_H263EncoderCatalog *EC, U32 StartingMB)
{
	register T_MBlockActionStream *pCurrMB;
	T_MBlockActionStream *pLastMBPlus1;

	pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]);
    
	for(; pCurrMB < pLastMBPlus1; pCurrMB++, StartingMB++) 
	{
		// Check to see if it's time to refresh this block.
		if(pCurrMB->InterCodeCnt > 132) 
		{

			if (pCurrMB->BlockType == INTER4MV)
			{
				pCurrMB->BlkY1.PHMV = pCurrMB->BlkY2.PHMV = pCurrMB->BlkY3.PHMV = pCurrMB->BlkY4.PHMV = 
					(pCurrMB->BlkY1.PHMV+pCurrMB->BlkY2.PHMV+pCurrMB->BlkY3.PHMV+pCurrMB->BlkY4.PHMV+2) >> 2;
				pCurrMB->BlkY1.PVMV = pCurrMB->BlkY2.PVMV = pCurrMB->BlkY3.PVMV = pCurrMB->BlkY4.PVMV = 
					(pCurrMB->BlkY1.PVMV+pCurrMB->BlkY2.PVMV+pCurrMB->BlkY3.PVMV+pCurrMB->BlkY4.PVMV+2) >> 2;
			}
			pCurrMB->BlockType = INTRABLOCK;
			pCurrMB->CodedBlocks |= 0x3f;
			// InterCodeCnt is reset in GOB_Q_VLC_WriteBS() in e3mbenc.cpp */
		}

	}
}

/*************************************************************
 *  Name: calcGOBChromaVectors
 *  Description:  Compute chroma motion vectors 
 ************************************************************/
static void calcGOBChromaVectors(
     T_H263EncoderCatalog *EC,
     U32             StartingMB,
     T_CONFIGURATION *pConfiguration
)
{

	register T_MBlockActionStream *pCurrMB;
    T_MBlockActionStream *pLastMBPlus1;
    char	       HMV, VMV;

	pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
	pLastMBPlus1 = &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]);
            
    for( ; pCurrMB < pLastMBPlus1; pCurrMB++, StartingMB++)
    {

		// The ME should generate MV indices in the range
		// of [-32,31].
 //     ASSERT( (pCurrMB->BlkY1.PHMV >= -32) &&
 //                     (pCurrMB->BlkY1.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY1.PVMV >= -32) &&
 //                     (pCurrMB->BlkY1.PVMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY2.PHMV >= -32) &&
 //                     (pCurrMB->BlkY2.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY2.PVMV >= -32) &&
 //                     (pCurrMB->BlkY2.PVMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY3.PHMV >= -32) &&
 //                     (pCurrMB->BlkY3.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY3.PVMV >= -32) &&
 //                     (pCurrMB->BlkY3.PVMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY4.PHMV >= -32) &&
 //                     (pCurrMB->BlkY4.PHMV <= 31) )
 //     ASSERT( (pCurrMB->BlkY4.PVMV >= -32) &&
 //                     (pCurrMB->BlkY4.PVMV <= 31) )

#ifdef _DEBUG
		if (pConfiguration->bEncoderResiliency && pConfiguration->unPacketLoss)
		{
			if (pConfiguration->bDisallowAllVerMVs)
			{
				ASSERT(pCurrMB->BlkY1.PVMV == 0);
				ASSERT(pCurrMB->BlkY2.PVMV == 0);
				ASSERT(pCurrMB->BlkY3.PVMV == 0);
				ASSERT(pCurrMB->BlkY4.PVMV == 0);
			}
			else if (pConfiguration->bDisallowPosVerMVs)
			{
				ASSERT(pCurrMB->BlkY1.PVMV <= 0);
				ASSERT(pCurrMB->BlkY2.PVMV <= 0);
				ASSERT(pCurrMB->BlkY3.PVMV <= 0);
				ASSERT(pCurrMB->BlkY4.PVMV <= 0);
			}
		}
#endif /* _DEBUG */

		// TODO: Don't calculate chroma vectors if this is not a P-frame
		// inside a PB frame and it's an INTRA MB or inter code count
		// exceeded 132.
		if(pCurrMB->BlockType != INTER4MV)
		{
        	HMV = QtrPelToHalfPel[pCurrMB->BlkY1.PHMV+64];
            VMV = QtrPelToHalfPel[pCurrMB->BlkY1.PVMV+64];
		}
		else	// 4 MV's per block.
		{
			HMV = SixteenthPelToHalfPel[
						pCurrMB->BlkY1.PHMV + pCurrMB->BlkY2.PHMV +
						pCurrMB->BlkY3.PHMV + pCurrMB->BlkY4.PHMV + 256 ];
			VMV = SixteenthPelToHalfPel[
						pCurrMB->BlkY1.PVMV + pCurrMB->BlkY2.PVMV +
						pCurrMB->BlkY3.PVMV + pCurrMB->BlkY4.PVMV + 256 ];
		}

        pCurrMB->BlkU.PHMV = HMV;
        pCurrMB->BlkU.PVMV = VMV;
        pCurrMB->BlkV.PHMV = HMV;
        pCurrMB->BlkV.PVMV = VMV;
                
        pCurrMB->BlkU.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + pCurrMB->BlkU.BlkOffset 
                    					+ (VMV>>1)*PITCH + (HMV>>1);
        pCurrMB->BlkV.B4_7.PastRef = EC->pU8_PrevFrm_YPlane + pCurrMB->BlkV.BlkOffset 
                                        + (VMV>>1)*PITCH + (HMV>>1);


		// The increment of pCurrMB->InterCodeCnt is now done 
		// in void GOB_VLC_WriteBS and void GOB_Q_RLE_VLC_WriteBS
		// When it was incremented here, it was always incremented,
		// no matter whether coefficients were coded or not.

    }  //  end of for loop

} // end of 



/*************************************************************
 *  Name: calcBGOBChromaVectors
 *  Description:  Compute forward and backward chroma motion vectors for the 
 *                B-frame GOB starting at MB number "StartingMB".  Luma motion 
 *                vectors are biased by 0x60.  Chroma motion vectors are also 
 *                biased by 0x60.
 ************************************************************/
static void calcBGOBChromaVectors(
     T_H263EncoderCatalog *EC,
     const U32             StartingMB
)
{
    register T_MBlockActionStream *pCurrMB;
    register I8                    HMVf, HMVb, VMVf, VMVb;

    for(pCurrMB = &(EC->pU8_MBlockActionStream[StartingMB]);
        pCurrMB < &(EC->pU8_MBlockActionStream[StartingMB + EC->NumMBPerRow]); 
        pCurrMB++)
    {
        //  Luma block motion vectors
        HMVf = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.HMVf-0x60+64]+0x60;
        HMVb = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.HMVb-0x60+64]+0x60;
        VMVf = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.VMVf-0x60+64]+0x60;
        VMVb = QtrPelToHalfPel[pCurrMB->BlkY1.BestMV.VMVb-0x60+64]+0x60;
        
        pCurrMB->BlkU.BestMV.HMVf = HMVf;
        pCurrMB->BlkU.BestMV.HMVb = HMVb;
        pCurrMB->BlkU.BestMV.VMVf = VMVf;
        pCurrMB->BlkU.BestMV.VMVb = VMVb;
        pCurrMB->BlkV.BestMV.HMVf = HMVf;
        pCurrMB->BlkV.BestMV.HMVb = HMVb;
        pCurrMB->BlkV.BestMV.VMVf = VMVf;
        pCurrMB->BlkV.BestMV.VMVb = VMVb;
   }
}

/*************************************************************
 *  Name: InitBits
 ************************************************************/
#ifdef COUNT_BITS
static void InitBits(T_H263EncoderCatalog * EC)
{

	EC->Bits.PictureHeader = 0;
	EC->Bits.GOBHeader = 0;
	EC->Bits.MBHeader = 0;
	EC->Bits.DQUANT = 0;
	EC->Bits.MV = 0;
	EC->Bits.Coefs = 0;
	EC->Bits.Coefs_Y = 0;
	EC->Bits.IntraDC_Y = 0;
	EC->Bits.Coefs_C = 0;
	EC->Bits.IntraDC_C = 0;
	EC->Bits.CBPY = 0;
	EC->Bits.MCBPC = 0;
	EC->Bits.Coded = 0;
	EC->Bits.num_intra = 0;
	EC->Bits.num_inter = 0;
	EC->Bits.num_inter4v = 0;

}
#endif

#ifdef COUNT_BITS

void InitCountBitFile()
{
  FILE *fp;

  fp = fopen("bits.txt", "w");

  ASSERT(fp != NULL);
  fclose(fp);
}

void WriteCountBitFile(T_BitCounts *Bits)
{
  FILE *fp;

  fp = fopen("bits.txt", "a");
  ASSERT(fp != NULL);

  fprintf(fp, "%8d %8d %8d %8d %8d %8d %8d\n",
  	Bits->PictureHeader,
  	Bits->GOBHeader,
  	Bits->MBHeader,
  	Bits->MV,
  	Bits->Coefs,
  	Bits->CBPY,
  	Bits->MCBPC
  	);

  fclose(fp);
}
#endif

#ifdef DEBUG_ENC

void trace(char *str)
{
  FILE *fp;

  fp = fopen("trace.txt", "a");

  fprintf(fp, "%s\n", str);

  fclose(fp);
}

#endif

#ifdef DEBUG_DCT
void cnvt_fdct_output(unsigned short *DCTcoeff, int DCTarray[64], int BlockType)
{
    register int i;
    static int coefforder[64] = {
     // 0  1  2  3  4  5  6  7
        6,38, 4,36,70,100,68,102, // 0
       10,46, 8,44,74,104,72,106, // 1
       18,50,16,48,82,112,80,114, // 2
       14,42,12,40,78,108,76,110, // 3
       22,54,20,52,86,116,84,118, // 4
        2,34, 0,32,66, 96,64, 98, // 5
       26,58,24,56,90,120,88,122, // 6
       30,62,28,60,94,124,92,126  // 7
    };
	static int zigzag[64] = {
	0, 1, 5, 6, 14, 15, 27, 28,
	2, 4, 7, 13, 16, 26, 29, 42,
	3, 8, 12, 17, 25, 30, 41, 43,
	9, 11, 18, 24, 31, 40, 44, 53,
	10, 19, 23, 32, 39, 45, 52, 54,
	20, 22, 33, 38, 46, 51, 55, 60,
	21, 34, 37, 47, 50, 56, 59, 61,
	35, 36, 48, 49, 57, 58, 62, 63
	};

	unsigned int index;

    for (i = 0; i < 64; i++) {

      index = (coefforder[i])>>1;

  	  if( (i ==0) && ((BlockType & 1) == 1)   )
        DCTarray[zigzag[i]] = ((int)(DCTcoeff[index])) >> 4 ;
	  else
        DCTarray[zigzag[i]] = ((int)(DCTcoeff[index] - 0x8000)) >> 4;
    }

}
#endif

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo)
{
    FILE * pFile;
	ENC_TIMING_INFO * pTempEncTimingInfo;
	ENC_TIMING_INFO etiTemp;
	int i;
	int iCount;

	FX_ENTRY("OutputEncodeTimingStatistics")

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	{
		ERRORMESSAGE(("%s: Error opening encode stat file\r\n", _fx_));
	    goto done;
	}

	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < ENC_TIMING_INFO_FRAME_COUNT ; i++, pTempEncTimingInfo++ )
	{
		fprintf(pFile, "Frame %d Detail Timing Information\n", i);
		OutputEncTimingDetail(pFile, pTempEncTimingInfo);
	}

	/* Compute the total information
	*/
	memset(&etiTemp, 0, sizeof(ENC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < ENC_TIMING_INFO_FRAME_COUNT ; i++, pTempEncTimingInfo++ )
	{
		iCount++;
		etiTemp.uEncodeFrame      += pTempEncTimingInfo->uEncodeFrame;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.uInputCC	      += pTempEncTimingInfo->uInputCC;
		etiTemp.uMotionEstimation += pTempEncTimingInfo->uMotionEstimation;
		etiTemp.uFDCT             += pTempEncTimingInfo->uFDCT;
		etiTemp.uQRLE             += pTempEncTimingInfo->uQRLE;
		etiTemp.uDecodeFrame      += pTempEncTimingInfo->uDecodeFrame;
		etiTemp.uZeroingBuffer    += pTempEncTimingInfo->uZeroingBuffer;
#endif // } DETAILED_ENCODE_TIMINGS_ON
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);

		/* Compute the average
		*/
		etiTemp.uEncodeFrame = (etiTemp.uEncodeFrame + (iCount / 2)) / iCount;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.uInputCC	      = (etiTemp.uInputCC + (iCount / 2)) / iCount;
		etiTemp.uMotionEstimation = (etiTemp.uMotionEstimation + (iCount / 2)) / iCount;
		etiTemp.uFDCT             = (etiTemp.uFDCT + (iCount / 2)) / iCount;
		etiTemp.uQRLE             = (etiTemp.uQRLE + (iCount / 2)) / iCount;
		etiTemp.uDecodeFrame      = (etiTemp.uDecodeFrame + (iCount / 2)) / iCount;
		etiTemp.uZeroingBuffer    = (etiTemp.uZeroingBuffer + (iCount / 2)) / iCount;
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo)
{
	U32 uOther;
	U32 uRoundUp;
	U32 uDivisor;

	fprintf(pFile, "\tEncode Frame =     %10d (%d milliseconds at 90Mhz)\n", pEncTimingInfo->uEncodeFrame,
			(pEncTimingInfo->uEncodeFrame + 45000) / 90000);
	uOther = pEncTimingInfo->uEncodeFrame;
	
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	/* This is needed because of the integer truncation.
	 */
	uDivisor = pEncTimingInfo->uEncodeFrame / 100; // to yield a percent
	uRoundUp = uDivisor / 2;
	
	fprintf(pFile, "\tInputCC =          %10d (%2d%%)\n", pEncTimingInfo->uInputCC, 
			(pEncTimingInfo->uInputCC + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uInputCC;
								   
	fprintf(pFile, "\tMotionEstimation = %10d (%2d%%)\n", pEncTimingInfo->uMotionEstimation, 
			(pEncTimingInfo->uMotionEstimation + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uMotionEstimation;
								   
	fprintf(pFile, "\tFDCT =             %10d (%2d%%)\n", pEncTimingInfo->uFDCT, 
			(pEncTimingInfo->uFDCT + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uFDCT;

	fprintf(pFile, "\tQRLE =             %10d (%2d%%)\n", pEncTimingInfo->uQRLE, 
			(pEncTimingInfo->uQRLE + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uQRLE;
								   
	fprintf(pFile, "\tDecodeFrame =      %10d (%2d%%)\n", pEncTimingInfo->uDecodeFrame, 
			(pEncTimingInfo->uDecodeFrame + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uDecodeFrame;
								   
	fprintf(pFile, "\tZeroingBuffer =    %10d (%2d%%)\n", pEncTimingInfo->uZeroingBuffer, 
			(pEncTimingInfo->uZeroingBuffer + uRoundUp) / uDivisor);
	uOther -= pEncTimingInfo->uZeroingBuffer;
								   
	fprintf(pFile, "\tOther =            %10d (%2d%%)\n", uOther, 
			(uOther + uRoundUp) / uDivisor);
#endif // } DETAILED_ENCODE_TIMINGS_ON

}
#endif // { LOG_ENCODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3mbenc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
/*****************************************************************************
 * e3enc.cpp
 *
 * DESCRIPTION:
 *		Specific encoder compression functions.
 *
 * Routines:					Prototypes in:
 *  H263InitEncoderInstance			
 * 	H263Compress
 *  H263TermEncoderInstance
 *  
 *
 *  
 *  $Author:   JMCVEIGH  $
 *  $Date:   05 Feb 1997 12:19:24  $
 *  $Archive:   S:\h26x\src\enc\e3mbenc.cpv  $
 *  $Header:   S:\h26x\src\enc\e3mbenc.cpv   1.54   05 Feb 1997 12:19:24   JMCVEIGH  $
 *  $Log:   S:\h26x\src\enc\e3mbenc.cpv  $
// 
//    Rev 1.54   05 Feb 1997 12:19:24   JMCVEIGH
// Support for separate improved PB-frame flag.
// 
//    Rev 1.53   19 Dec 1996 16:02:04   JMCVEIGH
// 
// And'ed CodedBlocksB with 0x3f to surpress high bit that indicates
// if only forward prediction is to be used in improved PB-frame mode.
// This is done in the VLC generation of CBPB and the block coeffs.
// 
//    Rev 1.52   16 Dec 1996 17:50:38   JMCVEIGH
// Encoding of MODB for improved PB-frame mode.
// 
//    Rev 1.51   05 Dec 1996 17:02:32   GMLIM
// 
// Changed the way RTP packetization was done to guarantee proper packet
// size.  Calls to update bitstream info buffer were modified.
// 
//    Rev 1.50   06 Nov 1996 16:30:32   gmlim
// Removed H263ModeC.
// 
//    Rev 1.49   05 Nov 1996 13:33:48   GMLIM
// Added mode c support for mmx case.
// 
//    Rev 1.48   03 Nov 1996 18:47:02   gmlim
// Modified to generate 
// rtp bs ext. for mode c.
// 
//    Rev 1.47   28 Oct 1996 12:03:16   KLILLEVO
// fixed an EMV bug in the writing of motion vectors for the PB-frame
// 
//    Rev 1.46   24 Oct 1996 16:27:40   KLILLEVO
// 
// changed from DBOUT to DbgLog
// 
//    Rev 1.45   22 Oct 1996 17:09:04   KLILLEVO
// reversed the condition on whether or not to skip a macroblock.
// Fall-through is now coded.
// Set the pCurMB->COD member properly and use that in the coded/
// not-coded test in the PB-frame encoding instead of repeating
// the same test as in the P-frame case.
// 
//    Rev 1.44   14 Oct 1996 11:58:42   KLILLEVO
// EMV bug fixed
// 
//    Rev 1.43   04 Oct 1996 08:43:16   KLILLEVO
// initial support for extended motion vectors
// 
//    Rev 1.42   13 Sep 1996 12:48:04   KLILLEVO
// cleaned up intra update code to make it more understandable
// 
//    Rev 1.41   10 Sep 1996 17:51:42   KLILLEVO
// moved reset of InterCodeCnt to e3enc.cpp CalcGobChroma..._InterCodeCnt
// 
//    Rev 1.40   09 Sep 1996 17:05:50   KLILLEVO
// changed small type in intercodecnt increment
// 
//    Rev 1.39   06 Sep 1996 16:12:24   KLILLEVO
// fixed the logical problem that the inter code count was always
// incremented no matter whether coefficients were transmitted or not
// 
//    Rev 1.38   03 May 1996 10:53:56   KLILLEVO
// 
// cleaned up and fixed indentation in two routines which might
// need to be rewritten for MMX PB-frames
// 
//    Rev 1.37   28 Apr 1996 20:19:30   BECHOLS
// 
// Merged RTP code into Main Base.
// 
//    Rev 1.36   15 Mar 1996 15:58:56   BECHOLS
// 
// added support for monolithic MMx code with separate passes over
// luma and chroma.
// 
//    Rev 1.35   22 Feb 1996 18:52:44   BECHOLS
// 
// Added boolean to switch between MMX and P5 quantization function.
// 
//    Rev 1.34   26 Jan 1996 16:25:42   TRGARDOS
// Added conditional compilation code to count bits.
// 
//    Rev 1.33   12 Jan 1996 16:34:30   BNICKERS
// 
// Fix numerous macroblock layer bugs w.r.t. PB encoding.
// 
//    Rev 1.32   22 Dec 1995 11:12:46   TRGARDOS
// Fixed bug in MV prediction calculation for blocks 2-4 of
// AP. Was not zeroing outside motion vectors when their
// block was INTRA coded.
// 
//    Rev 1.31   18 Dec 1995 12:40:18   RMCKENZX
// added copyright notice
// 
//    Rev 1.30   13 Dec 1995 22:00:58   TRGARDOS
// Changed MV predictor to not use ME state variable.
// 
//    Rev 1.29   13 Dec 1995 12:18:38   RMCKENZX
// Restored version 1.27
// 
//    Rev 1.27   11 Dec 1995 10:00:30   TRGARDOS
// Fixed debug messages for motion vectors.
// 
//    Rev 1.26   06 Dec 1995 12:06:26   TRGARDOS
// Finished 4MV support in MV delta and VLC/bit stream writing.
// 
//    Rev 1.25   05 Dec 1995 10:20:30   TRGARDOS
// Fixed MV predictors in GOBs with headers.
// 
//    Rev 1.24   09 Nov 1995 14:11:24   AGUPTA2
// PB-frame+performance+structure enhancements.
// 
//    Rev 1.23   19 Oct 1995 11:35:14   BNICKERS
// Made some changes to MacroBlockActionDescriptor structure to support B-Fram
// Motion Estimation and Frame Differencing.  Added some arguments to ME and F
// 
//    Rev 1.22   12 Oct 1995 17:39:34   TRGARDOS
// Fixed bug in MV prediction.
// 
//    Rev 1.21   03 Oct 1995 18:34:26   BECHOLS
// Changed the table sizes to reduce the memory requirements for the
// data to about half.  This also required a change to the initialization
// routine that sets up TCOEF_ and TCOEF_LAST_ tables.
// 
//    Rev 1.20   03 Oct 1995 09:21:34   TRGARDOS
// Fixed bug VLC encoding regarding MV prediction.
// 
//    Rev 1.19   29 Sep 1995 17:14:06   TRGARDOS
// Fixed offset value for cur to prev frame
// 
//    Rev 1.18   27 Sep 1995 19:10:02   TRGARDOS
// 
// Fixed bug in writing MB headers.
// 
//    Rev 1.17   27 Sep 1995 11:26:30   TRGARDOS
// Integrated motion estimation.
// 
//    Rev 1.16   18 Sep 1995 17:08:54   TRGARDOS
// Debugged delta frames.
// 
//    Rev 1.15   15 Sep 1995 16:37:32   TRGARDOS
// 
// 
//    Rev 1.14   13 Sep 1995 10:26:44   AGUPTA2
// Added blockType flag to QUANTRLE and changed the name to all upper-case.
// 
//    Rev 1.13   11 Sep 1995 14:10:42   BECHOLS
// 
// Changed this module to call the VLC routine in E35VLC.ASM.  I also
// renamed a couple of tables for clarity, and moved tables that I needed
// to the ASM module.
// 
//    Rev 1.12   08 Sep 1995 17:39:30   TRGARDOS
// Added more decoder code to encoder.
// 
//    Rev 1.11   07 Sep 1995 17:46:30   TRGARDOS
// Started adding delta frame support.
// 
//    Rev 1.10   05 Sep 1995 15:50:20   TRGARDOS
// 
//    Rev 1.9   05 Sep 1995 11:36:26   TRGARDOS
// 
//    Rev 1.8   01 Sep 1995 17:51:10   TRGARDOS
// Added DCT print routine.
// 
//    Rev 1.7   01 Sep 1995 10:13:32   TRGARDOS
// Debugging bit stream errors.
// 
//    Rev 1.6   31 Aug 1995 11:00:44   TRGARDOS
// Cut out MB VLC code.
// 
//    Rev 1.5   30 Aug 1995 12:42:22   TRGARDOS
// Fixed bugs in intra AC coef VLC coding.
// 
//    Rev 1.4   29 Aug 1995 17:19:16   TRGARDOS
// 
// 
//    Rev 1.3   25 Aug 1995 10:36:20   TRGARDOS
// 
// Fixed bugs in integration.
// 
//    Rev 1.2   22 Aug 1995 17:20:14   TRGARDOS
// Finished integrating asm quant & rle.
// 
//    Rev 1.1   22 Aug 1995 10:26:32   TRGARDOS
// Removed compile errors for adding quantization asm code.
// 
//    Rev 1.0   21 Aug 1995 16:30:04   TRGARDOS
// Initial revision.
// 
// Add quantization hooks and call RTP MB packetization only if 
// the bRTPHeader boolean is true
// 
*/

#include "precomp.h"

/*
 * VLC table for MCBPC for INTRA pictures.
 * Table is stored as {number of bits, code}.
 * The index to the table is built as:
 * 	bit 2 = 1 if DQUANT is present, 0 else.
 * 	bit 1 = 1 if V block is coded, 0 if not coded
 * 	bit 0 = 1 if U block is coded, 0 if not coded. 
 */
//  TODO : why int, why not const
int VLC_MCBPC_INTRA[9][2] =
	{ { 1, 1},	// 0
	  { 3, 2},	// 1
	  { 3, 1},	// 2
	  { 3, 3},	// 3
	  { 4, 1},	// 4
	  { 6, 2},	// 5
	  { 6, 1},	// 6
	  { 6, 3},	// 7
	  { 9, 1} };// 8  stuffing

/*
 * VLC table for MCBPC for INTER pictures.
 * Table is stored as {number of bits, code}.
 * The index to the table is built as:
 * bits 3,2 = MB type <0,1,2,3>
 * bit 1 = 1 if V block is coded, 0 if not coded.
 * bit 0 = 1 if U block is coded, 0 if not coded.
 * 
 * For INTER pictures, MB types are defined as:
 * 0: INTER
 * 1: INTER+Q
 * 2: INTER4V
 * 3: INTRA
 * 4: INTRA+Q
 */
//  TODO : why int, why not const
const int VLC_MCBPC_INTER[20][2] =
	{ { 1, 1},	// 0
	  { 4, 2},	// 1
	  { 4, 3},	// 2
	  { 6, 5},	// 3
	  { 3, 3},	// 4
	  { 7, 6},	// 5
	  { 7, 7},	// 6
	  { 9, 5},	// 7
	  { 3, 2},	// 8
	  { 7, 4},	// 9
	  { 7, 5},	// 10
	  { 8, 5},	// 11
	  { 5, 3},	// 12
	  { 8, 3},	// 13
	  { 8, 4},	// 14
	  { 7, 3},	// 15
	  { 6, 4},	// 16
	  { 9, 3}, 	// 17
	  { 9, 4},	// 18
	  { 9, 2} };// 19

/*
 * VLC's for motion vector delta's
 */
//  TODO : why int, why not const
int vlc_mvd[] = {
     // Index: Vector Differences
    13,5,	//  0: -16	16
    13,7,
    12,5,
    12,7,
    12,9,
    12,11,
    12,13,
    12,15,
    11,9,
    11,11,
    11,13,
    11,15,
    11,17,
    11,19,
    11,21,
    11,23,
    11,25,
    11,27,
    11,29,
    11,31,
    11,33,
    11,35,
    10,19,
    10,21,
    10,23,
    8,7,
    8,9,
    8,11,
    7,7,
    5,3,
    4,3,
    3,3,
    1,1,	// 32: 0
    3,2,
    4,2,
    5,2,
    7,6,
    8,10,
    8,8,
    8,6,
    10,22,
    10,20,
    10,18,
    11,34,
    11,32,
    11,30,
    11,28,
    11,26,
    11,24,
    11,22,
    11,20,
    11,18,
    11,16,
    11,14,
    11,12,
    11,10,
    11,8,
    12,14,
    12,12,
    12,10,
    12,8,
    12,6,
    12,4,
    13,6,
};


/*
 * VLC table for CBPY
 * Table is stores as {number of bits, code}
 * Index into the table for INTRA macroblocks is the
 * coded block pattern for the blocks in the order
 * bit 3 = block 4
 * bit 2 = block 3
 * bit 1 = block 2
 * bit 0 = block 1
 *
 * For INTER macroblocks, a CBP is built as above and
 * then is subtracted from 15 to get the index into the 
 * array: index = 15 - interCBP.
 */
//  TODO : why int, why not const
int VLC_CBPY[16][2] = 
	{ { 4, 3},	// 0
	  { 5, 2},	// 1
	  { 5, 3}, 	// 2
	  { 4, 4},	// 3
	  { 5, 4}, 	// 4
	  { 4, 5}, 	// 5
	  { 6, 2},	// 6
	  { 4, 6}, 	// 7
	  { 5, 5}, 	// 8
	  { 6, 3}, 	// 9
	  { 4, 7}, 	// 10
	  { 4, 8},	// 11
	  { 4, 9}, 	// 12
	  { 4, 10}, // 13
	  { 4, 11}, // 14
	  { 2, 3}  // 15
	};

/*
 * TODO : VLC tables for MODB and CBPB
 */
const U8 VLC_MODB[4][2] = 
{ 
    {1, 0},  //  0
    {1, 0},  //  should not happen
    {2, 2},  //  2
    {2, 3}   //  3
};

#ifdef H263P
/*
 * VLC table for MODB when improved PB-frame mode selected
 */
const U8 VLC_IMPROVED_PB_MODB[4][2] = 
{
	{1, 0},		// Bidirectional prediction with all empty blocks		(CBPB=0, MVDB=0)
	{2, 2},		// Forward prediction with all empty blocks				(CBPB=0, MVDB=1)
	{3, 6},		// Forward prediction with some non-empty blocks		(CBPB=1, MVDB=1)
	{3, 7}		// Bidirectional prediction with some non-empty blocks	(CBPB=1, MVDB=0)
};
#endif

/*
 * TODO : VLC tables for CBPB; indexed using CodedBlocksB
 *        
 */
const U8 VLC_CBPB[64] = 
{
    0,   //  000000
    32,  //  000001
    16,  //  000010
    48,  //  000011
    8,   //  000100
    40,  //  000101
    24,  //  000110
    56,  //  000111
    4,   //  001000
    36,  //  001001
    20,  //  001010
    52,  //  001011
    12,  //  001100
    44,  //  001101
    28,  //  001110
    60,  //  001111
    2,   //  010000
    34,  //  010001
    18,  //  010010
    50,  //  010011
    10,  //  010100
    42,  //  010101
    26,  //  010110
    58,  //  010111
    6,   //  011000
    38,  //  011001
    22,  //  011010
    54,  //  011011
    14,  //  011100
    46,  //  011101
    30,  //  011110
    62,  //  011111
    1,   //  100000
    33,  //  100001
    17,  //  100010
    49,  //  100011
    9,   //  100100
    41,  //  100101
    25,  //  100110
    57,  //  100111
    5,   //  101000
    37,  //  101001
    21,  //  101010
    53,  //  101011
    13,  //  101100
    45,  //  101101
    29,  //  101110
    61,  //  101111
    3,   //  110000
    35,  //  110001
    19,  //  110010
    51,  //  110011
    11,  //  110100
    43,  //  110101
    27,  //  110110
    59,  //  110111
    7,   //  111000
    39,  //  111001
    23,  //  111010
    55,  //  111011
    15,  //  111100
    47,  //  111101
    31,  //  111110
    63   //  111111
};

/*
 * VLC table for TCOEFs
 * Table entries are size, code.
 * Stored as (size, value)
 * BSE -- The "+ 1" and "<< 1" makes room for the sign bit.  This permits
 *   us to do a single write to the stream, versus two writes.
 */
//  TODO : why int, why not const
int VLC_TCOEF[102*2] = {
	 2 + 1,  2 << 1,	/* 0, runs of 0  ***  table for nonlast coefficient */
	 4 + 1, 15 << 1,
	 6 + 1, 21 << 1,
	 7 + 1, 23 << 1,
	 8 + 1, 31 << 1,
	 9 + 1, 37 << 1,
	 9 + 1, 36 << 1,
	10 + 1, 33 << 1,
	10 + 1, 32 << 1,
	11 + 1,  7 << 1,
	11 + 1,  6 << 1,
	11 + 1, 32 << 1,
	 3 + 1,  6 << 1,	/* 24, runs of 1 */
	 6 + 1, 20 << 1,
	 8 + 1, 30 << 1,
	10 + 1, 15 << 1,
	11 + 1, 33 << 1,
	12 + 1, 80 << 1,
	 4 + 1, 14 << 1,	/* 36, runs of 2 */
	 8 + 1, 29 << 1,
	10 + 1, 14 << 1,
	12 + 1, 81 << 1,
	 5 + 1, 13 << 1,	/* 44, runs of 3 */
	 9 + 1, 35 << 1,
	10 + 1, 13 << 1,
	 5 + 1, 12 << 1,	/* 50, runs of 4 */
	 9 + 1, 34 << 1,
	12 + 1, 82 << 1,
	 5 + 1, 11 << 1,	/* 56, runs of 5 */
	10 + 1, 12 << 1,
	12 + 1, 83 << 1,
	 6 + 1, 19 << 1,	/* 62, runs of 6 */
	10 + 1, 11 << 1,
	12 + 1, 84 << 1,
	 6 + 1, 18 << 1,	/* 68, runs of 7 */
	10 + 1, 10 << 1,
	 6 + 1, 17 << 1,	/* 72, runs of 8 */
	10 + 1,  9 << 1,
	 6 + 1, 16 << 1,	/* 76, runs of 9 */
	10 + 1,  8 << 1,
	 7 + 1, 22 << 1,	/* 80, runs of 10 */
	12 + 1, 85 << 1, 
	 7 + 1, 21 << 1, /* 84, runs of 11 */
	 7 + 1, 20 << 1, /* 86, runs of 12 */
	 8 + 1, 28 << 1, /* 88, runs of 13 */
	 8 + 1, 27 << 1, /* 90, runs of 14 */
	 9 + 1, 33 << 1,
	 9 + 1, 32 << 1,
	 9 + 1, 31 << 1,
	 9 + 1, 30 << 1,
	 9 + 1, 29 << 1,
	 9 + 1, 28 << 1,
	 9 + 1, 27 << 1,
	 9 + 1, 26 << 1,
	11 + 1, 34 << 1,
	11 + 1, 35 << 1,
	12 + 1, 86 << 1,
	12 + 1, 87 << 1,
	 4 + 1,  7 << 1,  /* Table for last coeff */
	 9 + 1, 25 << 1,
	11 + 1,  5 << 1,
	 6 + 1, 15 << 1,
 	11 + 1,  4 << 1,
	 6 + 1, 14 << 1,
	 6 + 1, 13 << 1,
	 6 + 1, 12 << 1,
	 7 + 1, 19 << 1,
	 7 + 1, 18 << 1,
	 7 + 1, 17 << 1,
	 7 + 1, 16 << 1,
	 8 + 1, 26 << 1,
	 8 + 1, 25 << 1,
	 8 + 1, 24 << 1,
	 8 + 1, 23 << 1,
	 8 + 1, 22 << 1,
	 8 + 1, 21 << 1,
	 8 + 1, 20 << 1,
	 8 + 1, 19 << 1,
	 9 + 1, 24 << 1,
	 9 + 1, 23 << 1,
	 9 + 1, 22 << 1,
	 9 + 1, 21 << 1,
	 9 + 1, 20 << 1,
	 9 + 1, 19 << 1,
	 9 + 1, 18 << 1,
	 9 + 1, 17 << 1,
	10 + 1,  7 << 1,
	10 + 1,  6 << 1,
	10 + 1,  5 << 1,
	10 + 1,  4 << 1,
	11 + 1, 36 << 1,
	11 + 1, 37 << 1,
	11 + 1, 38 << 1,
	11 + 1, 39 << 1,
	12 + 1, 88 << 1,
	12 + 1, 89 << 1,
	12 + 1, 90 << 1,
	12 + 1, 91 << 1,
	12 + 1, 92 << 1,
	12 + 1, 93 << 1,
	12 + 1, 94 << 1,
	12 + 1, 95 << 1
  };

/*
 * This table lists the maximum level represented in the
 * VLC table for a given run. If the level exceeds the
 * max, then escape codes must be used to encode the
 * run & level.
 * The table entries are of the form {maxlevel, ptr to table for this run}.
 */

T_MAXLEVEL_PTABLE TCOEF_RUN_MAXLEVEL[65] = {
	{12, &VLC_TCOEF[0]},	// run of 0
	{ 6, &VLC_TCOEF[24]},	// run of 1
	{ 4, &VLC_TCOEF[36]}, 	// run of 2
	{ 3, &VLC_TCOEF[44]},	// run of 3
	{ 3, &VLC_TCOEF[50]},	// run of 4
	{ 3, &VLC_TCOEF[56]},	// run of 5
	{ 3, &VLC_TCOEF[62]},	// run of 6
	{ 2, &VLC_TCOEF[68]}, 	// run of 7
	{ 2, &VLC_TCOEF[72]},  	// run of 8
	{ 2, &VLC_TCOEF[76]},  	// run of 9
	{ 2, &VLC_TCOEF[80]},  	// run of 10
	{ 1, &VLC_TCOEF[84]},	// run of 11
	{ 1, &VLC_TCOEF[86]},	// run of 12
	{ 1, &VLC_TCOEF[88]},	// run of 13
	{ 1, &VLC_TCOEF[90]},	// run of 14
	{ 1, &VLC_TCOEF[92]},	// run of 15
	{ 1, &VLC_TCOEF[94]},	// run of 16
	{ 1, &VLC_TCOEF[96]},	// run of 17
	{ 1, &VLC_TCOEF[98]},	// run of 18
	{ 1, &VLC_TCOEF[100]},	// run of 19
	{ 1, &VLC_TCOEF[102]},	// run of 20
	{ 1, &VLC_TCOEF[104]},	// run of 21
	{ 1, &VLC_TCOEF[106]},	// run of 22
	{ 1, &VLC_TCOEF[108]},	// run of 23
	{ 1, &VLC_TCOEF[110]},	// run of 24
	{ 1, &VLC_TCOEF[112]},	// run of 25
	{ 1, &VLC_TCOEF[114]},	// run of 26
	{ 0, 0},	// run of 27 not in VLC table
	{ 0, 0},	// run of 28 not in VLC table
	{ 0, 0},	// run of 29 not in VLC table
	{ 0, 0},	// run of 30 not in VLC table
	{ 0, 0},	// run of 31 not in VLC table
	{ 0, 0},	// run of 32 not in VLC table
	{ 0, 0},	// run of 33 not in VLC table
	{ 0, 0},	// run of 34 not in VLC table
	{ 0, 0},	// run of 35 not in VLC table
	{ 0, 0},	// run of 36 not in VLC table
	{ 0, 0},	// run of 37 not in VLC table
	{ 0, 0},	// run of 38 not in VLC table
	{ 0, 0},	// run of 39 not in VLC table
	{ 0, 0},	// run of 40 not in VLC table
	{ 0, 0},	// run of 41 not in VLC table
	{ 0, 0},	// run of 42 not in VLC table
	{ 0, 0},	// run of 43 not in VLC table
	{ 0, 0},	// run of 44 not in VLC table
	{ 0, 0},	// run of 45 not in VLC table
	{ 0, 0},	// run of 46 not in VLC table
	{ 0, 0},	// run of 47 not in VLC table
	{ 0, 0},	// run of 48 not in VLC table
	{ 0, 0},	// run of 49 not in VLC table
	{ 0, 0},	// run of 50 not in VLC table
	{ 0, 0},	// run of 51 not in VLC table
	{ 0, 0},	// run of 52 not in VLC table
	{ 0, 0},	// run of 53 not in VLC table
	{ 0, 0},	// run of 54 not in VLC table
	{ 0, 0},	// run of 55 not in VLC table
	{ 0, 0},	// run of 56 not in VLC table
	{ 0, 0},	// run of 57 not in VLC table
	{ 0, 0},	// run of 58 not in VLC table
	{ 0, 0},	// run of 59 not in VLC table
	{ 0, 0},	// run of 60 not in VLC table
	{ 0, 0},	// run of 61 not in VLC table
	{ 0, 0},	// run of 62 not in VLC table
	{ 0, 0},	// run of 63 not in VLC table
	{ 0, 0}		// run of 64 not in VLC table
	 };

static char __fastcall median(char v1, char v2, char v3);

static I8 * MB_Quantize_RLE(
    I32 **DCTCoefs,
    I8   *MBRunValPairs,
	U8   *CodedBlocks,
	U8    BlockType,
	I32   QP
);

/*************************************************************
 *  Name:  writePB_MVD
 *  Description: Writes out the VLC for horizontal and vertical motion vector
 *    to the bit-stream addressed by (pPB_BitStream, pPB_BitOffset) in a 
 *    PB-frame (in a PB-frame, a predictor is NOT set to 0 for INTRABLOCKS).
 *    In its current incarnation, it cannot be used to write MV for non-PB 
 *    frames.
 *  Parameters:
 *    curMB            Write MV for the MB no. "curMB" in the frame.  MBs are 
 *                     numbererd from 0 in a frame.
 *    pCurMB           Pointer to the current MB action descriptor
 *    NumMBPerRow      No. of MBs in a row; e.g. 11 in QCIF.
 *    pPB_BitStream    Current byte being written
 *    pPB_BitOffset    Offset at which VLC code is written
 *  Side-effects:
 *    Modifies pPB_BitStream and pPB_BitOffset.
 *************************************************************/
static void writePB_MVD(
    const U32               curMB, 
    T_MBlockActionStream  * const pCurMB,
    const U32               NumMBPerRow,
    const U32               NumMBs,
    U8                   ** pPB_BitStream,
    U8                    * pPB_BitOffset,
	U32						GOBHeaderFlag,
	const T_H263EncoderCatalog *EC
);

/*************************************************************
 *  Name:  writeP_MVD
 *  Description: Writes out the VLC for horizontal and vertical motion vector
 *    to the bit-stream addressed by (pP_BitStream, pP_BitOffset) in a 
 *    P-frame.
 *  Parameters:
 *    curMB            Write MV for the MB no. "curMB" in the frame.  MBs are 
 *                     numbererd from 0 in a frame.
 *    pCurMB           Pointer to current MB action descriptor
 *    NumMBPerRow      No. of MBs in a row; e.g. 11 in QCIF.
 *    pP_BitStream     Current byte being written
 *    pP_BitOffset     Offset at which VLC code is written
 *	  GOBHeaderPresent IF true, then GOB header is present for this GOB.
 *  Side-effects:
 *    Modifies pP_BitStream and pP_BitOffset.
 *************************************************************/
static void writeP_MVD(
    const U32                     curMB, 
    T_MBlockActionStream  * const pCurMB,
    const U32                     NumMBPerRow,
	const U32					  NumMBs,
    U8                         ** pP_BitStream,
    U8                          * pP_BitOffset,
	U32							  GOBHeaderPresent,
	T_H263EncoderCatalog         *EC
);

/**********************************************************************
 *  Quantize and RLE each macroblock, then VLC and write to stream.
 *  This function is only used for P or I frames, not B.
 *
 *  Parameters:
 *    FutrPMBData   
 **********************************************************************/
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I32                  *DCTCoefs,
	U8                  **pBitStream,
	U8                   *pBitOffset,
    T_FutrPMBData        *FutrPMBData,  //  Start of GOB
	U32                   GOB,
	U32                   QP,
	BOOL                  bRTPHeader,
	U32                   StartingMB
)
{
  	U32   MB, curMB, index;
  	I8    MBRunValSign[65*3*6], * EndAddress, *rvs;
  	U8	  bUseDQUANT = 0;	// Indicates if DQUANT is present.
	U8 	  MBType;
    U8   *pFrmStart = EC->pU8_BitStream;  //  TODO : should be a param.
	U32	  GOBHeaderMask, GOBHeaderFlag;

	#ifdef COUNT_BITS
	U32   savebyteptr, savebitptr;
	#endif

    register T_MBlockActionStream *pCurMB;

	FX_ENTRY("GOB_Q_RLE_VLC_WriteBS")

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

    // Loop through each macroblock of the GOB.
  	for(MB = 0, curMB = GOB*EC->NumMBPerRow, 
  			pCurMB = EC->pU8_MBlockActionStream + curMB; 
        	MB < EC->NumMBPerRow; 
        	MB++, curMB++, pCurMB++)
  	{
		DEBUGMSG(ZONE_ENCODE_MB, ("%s: MB #%d: QP=%d\r\n", _fx_, MB, QP));

	   /*
	 	* Quantize and RLE each block in the macroblock,
	 	* skipping empty blocks as denoted by CodedBlocks.
	 	* If any more blocks are empty after quantization
	 	* then the appropriate CodedBlocks bit is cleared.
	 	*/
    	EndAddress = MB_Quantize_RLE(
    		&DCTCoefs,
    		(I8 *)MBRunValSign,
    		&(pCurMB->CodedBlocks),
    		pCurMB->BlockType,
			QP
    		);

		// default COD is coded (= 0). Will be set to 1 only if skipped
		pCurMB->COD = 0;

#ifdef ENCODE_STATS
		StatsUsedQuant(QP);
#endif /* ENCODE_STATS */

		if(EC->PictureHeader.PicCodType == INTRAPIC)
		{
			pCurMB->MBType = INTRA;
			MBType = INTRA;
		}
		else	// inter picture code type
		{
    		if(pCurMB->BlockType == INTERBLOCK)
			{
				pCurMB->MBType = INTER;
				MBType = INTER;
			}
			else if(pCurMB->BlockType == INTER4MV)
			{
				pCurMB->MBType = INTER4V;
				MBType = INTER4V;
			}
			else if(pCurMB->BlockType == INTRABLOCK)
			{
				pCurMB->MBType = INTRA;
				MBType = INTRA;
			}
			else
			{
				ERRORMESSAGE(("%s: Unexpected MacroBlock Type found\r\n", _fx_));
			}
		}
        
        //  Save starting bit offset of the macroblock data from start of 
        //  of the frame data.  The offset for the first macroblock is saved
        //  in e3enc.cpp before this routine is called.
        if (EC->u8EncodePBFrame == TRUE
            && MB != 0)
        {
            FutrPMBData[curMB].MBStartBitOff 
            = (U32) (((*pBitStream - pFrmStart)<<3) + *pBitOffset);
        }        

        /*
	 	 * Write macroblock header to bit stream.
	 	 */
    	if( (MBType == INTER) || (MBType == INTER4V) )
		{
	  		// Check if entire macroblock is empty, including zero MV's.
			// If there is only one MV for the block, all block MVs in the
			// structure are still set but are equal.
	  		if( ((pCurMB->CodedBlocks & 0x3f) != 0) 
                 || (pCurMB->BlkY1.PHMV != 0) 
                 || (pCurMB->BlkY1.PVMV != 0)
                 || (pCurMB->BlkY2.PHMV != 0) 
                 || (pCurMB->BlkY2.PVMV != 0)
                 || (pCurMB->BlkY3.PHMV != 0) 
                 || (pCurMB->BlkY3.PVMV != 0)
                 || (pCurMB->BlkY4.PHMV != 0) 
                 || (pCurMB->BlkY4.PVMV != 0)
                 )
	  		{
				PutBits(0, 1, pBitStream, pBitOffset);	// COD = 0, nonempty MB

#ifdef COUNT_BITS
    			if(MBType == INTER)
    				EC->Bits.num_inter++;
    			else if (MBType == INTER4V)
					EC->Bits.num_inter4v++;
				EC->Bits.MBHeader += 1;
				EC->Bits.Coded++;
#endif

				// Increment the InterCoded block count if the block
				// is intercoded (not B frame) and is not empty.
				if (((pCurMB->CodedBlocks & 0x3f) != 0) &&
					((pCurMB->BlockType == INTERBLOCK) || (pCurMB->BlockType == INTER4MV)))
				{
					// Macroblock is coded. Need to increment inter code count if
					// there are no coefficients: see section 4.4 of the H.263
					// recommendation
					pCurMB->InterCodeCnt++;
				}

				// 	pCurMB->InterCodeCnt is reset in calcGOBChromaVecs_InterCodeCnt

  	   		   /*******************************************
	    		* Write macroblock header to bit stream.
	    		*******************************************/	  
	    	    // Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
	    		index = (pCurMB->CodedBlocks >> 4) & 0x3;

				// Add the MB type to next two bits to the left.
				index |= (MBType << 2);

				// Write code to bitstream.
	    		PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
                        pBitStream, pBitOffset);

#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
				EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
#endif
                
                //  Save bit offset of CBPY data from start of macroblock data
				//  if PB frame is on since we will reuse this later.
                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].CBPYBitOff
                    = (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                            - FutrPMBData[curMB].MBStartBitOff);
                }

	    		// Write CBPY to bitstream.
	    		index = pCurMB->CodedBlocks & 0xf;
				index = (~index) & 0xf;
	    		PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], 
                        pBitStream, pBitOffset);

#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_CBPY[index][0];
				EC->Bits.CBPY += VLC_CBPY[index][0];
#endif

	    		//if( bUseDQUANT )
	    		//{
	      			// TODO: write DQUANT to bit stream here. We can only do
					// this if MBtype is not INTER4V since that type doesn't 
					// allow quantizer as well.
	    		//}	

                //  Save bit offset of CBPY data from start of macroblock data
                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].MVDBitOff
                    = (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                            - FutrPMBData[curMB].MBStartBitOff);
                }

                // Write motion vectors to bit stream.
				if( (EC->GOBHeaderPresent & GOBHeaderMask) != 0 )
				{
					GOBHeaderFlag = TRUE;
				}
				else
				{
					GOBHeaderFlag = FALSE;
				}
                writeP_MVD(
                	curMB,		// Current MB number.
                	pCurMB,		// pointer to current MB action desc. struct.
                	EC->NumMBPerRow,
					EC->NumMBs,
                	pBitStream, 
                    pBitOffset,
                    GOBHeaderFlag,
					EC
                    );

                //  Save bit offset of block data from start of MB data
                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].BlkDataBitOff
                    = (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                             - FutrPMBData[curMB].MBStartBitOff);
                }

	   			/*
	    		 * Encode intra DC and all run/val pairs.
				 */
#ifdef COUNT_BITS
				savebyteptr = (U32) *pBitStream;
				savebitptr  = (U32) *pBitOffset;
#endif

            	rvs = MBRunValSign;
				MBEncodeVLC(&rvs,NULL, pCurMB->CodedBlocks, 
                            pBitStream, pBitOffset, 0, 0);

#ifdef COUNT_BITS
				EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
#endif
	  		}
	  		else	// Macroblock is empty.
	  		{
	    		PutBits(1, 1, pBitStream, pBitOffset);		// COD = 1, empty MB

				// Instead of repeating the above test in the PB-frame encoding
				// pCurMB->COD can now be tested instead.
				pCurMB->COD = 1;

                if (EC->u8EncodePBFrame == TRUE)
                {
                    FutrPMBData[curMB].CBPYBitOff = 1;
                    FutrPMBData[curMB].MVDBitOff  = 1;
                    FutrPMBData[curMB].BlkDataBitOff = 1;
                }
				
				#ifdef COUNT_BITS
				EC->Bits.MBHeader += 1;
				#endif

	  		}	// end of else
		} // end of if macroblock
		else if( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTERPIC)) 
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

  	 		/*******************************************
	  		* Write macroblock header to bit stream.
	  		*******************************************/	  
    		PutBits(0, 1, pBitStream, pBitOffset);		// COD = 0, nonempty MB

 			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += 1;
			EC->Bits.Coded++;
			#endif

	  		// Write MCBPC to bitstream.
	  		index = (pCurMB->CodedBlocks >> 4) & 0x3;
	  		index |= (MBType << 2);
	  		PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
                    pBitStream, pBitOffset);

 			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
			#endif

            //  Save bit offset of CBPY data from start of macroblock data
            if (EC->u8EncodePBFrame == TRUE)
            {
                FutrPMBData[curMB].CBPYBitOff
                = (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                         - FutrPMBData[curMB].MBStartBitOff);
            }

	  		// Write CBPY to bitstream.
	  		index = pCurMB->CodedBlocks & 0xf;
	  		//index = pMBActionStream[curMB].CBPY;
	  		PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, 
                    pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

	  		//if( bUseDQUANT )
	  		//{
	    		// write DQUANT to bit stream here.
	  		//}

            //  Save bit offset of block data from start of macroblock data
            if (EC->u8EncodePBFrame == TRUE)
            {
                FutrPMBData[curMB].BlkDataBitOff = FutrPMBData[curMB].MVDBitOff
                = (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
                         - FutrPMBData[curMB].MBStartBitOff);
            }

			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif
            
            //  Encode run/val pairs
         	rvs = MBRunValSign;
  	  		MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocks, pBitStream,
                        pBitOffset, 1, 0);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		} // end of else
		else if ( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTRAPIC))
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

            //  An INTRA frame should not be the P-frame in a PB-frame
            ASSERT(EC->u8SavedBFrame == FALSE)
  	 		/*******************************************
	  		* Write macroblock header to bit stream.
	  		*******************************************/	  
	  		// Write MCBPC to bitstream.
	  		index = (pCurMB->CodedBlocks >> 4) & 0x3;
	  		//index = pMBActionStream[curMB].CBPC;
	  		//index |= bUseDQUANT << 2;
	  		PutBits(VLC_MCBPC_INTRA[index][1], VLC_MCBPC_INTRA[index][0], 
                    pBitStream, pBitOffset);

 			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += VLC_MCBPC_INTRA[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTRA[index][0];
			#endif

	  		// Write CBPY to bitstream.
	  		index = pCurMB->CodedBlocks & 0xf;
	  		//index = pMBActionStream[curMB].CBPY;
	  		PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], 
                    pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

	  		//if( bUseDQUANT )
	  		//{
	    		// write DQUANT to bit stream here.
	  		//}

 			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif

         rvs = MBRunValSign;
 	  		MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocks, 
                        pBitStream, pBitOffset, 1, 0);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		} // end of else
		else
			ERRORMESSAGE(("%s: Unexpected case in writing MB header VLC\r\n", _fx_));

		// Calculate DQUANT based on bits used in previous MBs.
		// CalcDQUANT();

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pBitStream,
                                                    (U32) *pBitOffset);
  	} // for MB
} // end of GOB_Q_RLE_VLC_WriteBS()


void GOB_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I8              *pMBRVS_Luma,
	I8              *pMBRVS_Chroma,
	U8             **pBitStream,
	U8              *pBitOffset,
	T_FutrPMBData   *FutrPMBData,  //  Start of GOB
	U32              GOB,
	U32              QP,
	BOOL             bRTPHeader,
	U32              StartingMB)
{
	U32   MB, curMB, index;
	U8	  bUseDQUANT = 0;	// Indicates if DQUANT is present.
	U8 	  MBType;
	U8   *pFrmStart = EC->pU8_BitStream;  //  TODO : should be a param.
	U32	  GOBHeaderMask, GOBHeaderFlag;

	#ifdef COUNT_BITS
	U32   savebyteptr, savebitptr;
	#endif

	register T_MBlockActionStream *pCurMB;

	FX_ENTRY("GOB_VLC_WriteBS")

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

	// Loop through each macroblock of the GOB.
	for(MB = 0, curMB = GOB*EC->NumMBPerRow, pCurMB = EC->pU8_MBlockActionStream + curMB; 
	    MB < EC->NumMBPerRow; MB++, curMB++, pCurMB++)
	{
		DEBUGMSG(ZONE_ENCODE_MB, ("%s: MB #%d\r\n", _fx_, MB));

		// default COD is coded (= 0). Will be set to 1 only if skipped
		pCurMB->COD = 0;

		if(EC->PictureHeader.PicCodType == INTRAPIC) 
		{
			pCurMB->MBType = INTRA;
			MBType = INTRA;
		} 
		else 
		{	// inter picture code type
			if(pCurMB->BlockType == INTERBLOCK) 
			{
				pCurMB->MBType = INTER;
				MBType = INTER;
			} 
			else if(pCurMB->BlockType == INTER4MV) 
			{
				pCurMB->MBType = INTER4V;
				MBType = INTER4V;
			} 
			else if(pCurMB->BlockType == INTRABLOCK) 
			{
				pCurMB->MBType = INTRA;
				MBType = INTRA;
			} 
			else 
			{
				ERRORMESSAGE(("%s: Unexpected MacroBlock Type found\r\n", _fx_));
			}
		}
		//  Save starting bit offset of the macroblock data from start of 
		//  of the frame data.  The offset for the first macroblock is saved
		//  in e3enc.cpp before this routine is called.
		if(EC->u8EncodePBFrame == TRUE && MB != 0) 
		{
			FutrPMBData[curMB].MBStartBitOff 
			= (U32) (((*pBitStream - pFrmStart)<<3) + *pBitOffset);
		}        
		/*
		* Write macroblock header to bit stream.
		*/
		if((MBType == INTER) || (MBType == INTER4V)) 
		{
			// Check if entire macroblock is empty, including zero MV's.
			// If there is only one MV for the block, all block MVs in the
			// structure are still set but are equal.
			if(((pCurMB->CodedBlocks & 0x3f) != 0) 
			 || (pCurMB->BlkY1.PHMV != 0) 
			 || (pCurMB->BlkY1.PVMV != 0)
			 || (pCurMB->BlkY2.PHMV != 0) 
			 || (pCurMB->BlkY2.PVMV != 0)
			 || (pCurMB->BlkY3.PHMV != 0) 
			 || (pCurMB->BlkY3.PVMV != 0)
			 || (pCurMB->BlkY4.PHMV != 0) 
			 || (pCurMB->BlkY4.PVMV != 0)) 
			{
				PutBits(0, 1, pBitStream, pBitOffset);	// COD = 0, nonempty MB
				
				#ifdef COUNT_BITS
				if(MBType == INTER)
					EC->Bits.num_inter++;
				else if (MBType == INTER4V)
					EC->Bits.num_inter4v++;
				EC->Bits.MBHeader += 1;
				EC->Bits.Coded++;
				#endif

				// Increment the InterCoded block count if the block
				// is intercoded (not B frame) and is not empty.
				if (((pCurMB->CodedBlocks & 0x3f) != 0) &&
					((pCurMB->BlockType == INTERBLOCK) || (pCurMB->BlockType == INTER4MV)))
				{
					// Macroblock is coded. Need to increment inter code count if
					// there are no coefficients: see section 4.4 of the H.263
					// recommendation
					pCurMB->InterCodeCnt++;
				}

				// 	pCurMB->InterCodeCnt is reset in calcGOBChromaVecs_InterCodeCnt

				/*******************************************
				* Write macroblock header to bit stream.
				*******************************************/	  
				// Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
				index = (pCurMB->CodedBlocks >> 4) & 0x3;
				// Add the MB type to next two bits to the left.
				index |= (MBType << 2);
				// Write code to bitstream.
				PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
				pBitStream, pBitOffset);

				#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
				EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
				#endif

				//  Save bit offset of CBPY data from start of macroblock data
				//  if PB frame is on since we will reuse this later.
				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].CBPYBitOff
					= (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
					- FutrPMBData[curMB].MBStartBitOff);
				}
				// Write CBPY to bitstream.
				index = pCurMB->CodedBlocks & 0xf;
				index = (~index) & 0xf;
				PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, pBitOffset);

				#ifdef COUNT_BITS
				EC->Bits.MBHeader += VLC_CBPY[index][0];
				EC->Bits.CBPY += VLC_CBPY[index][0];
				#endif

				//if(bUseDQUANT) 
				//{
					// TODO: write DQUANT to bit stream here. We can only do
					// this if MBtype is not INTER4V since that type doesn't 
					// allow quantizer as well.
				//}
					
				//  Save bit offset of CBPY data from start of macroblock data
				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].MVDBitOff
					= (U8)( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
					- FutrPMBData[curMB].MBStartBitOff);
				}
				// Write motion vectors to bit stream.
				if((EC->GOBHeaderPresent & GOBHeaderMask) != 0) 
				{
					GOBHeaderFlag = TRUE;
				} 
				else 
				{
					GOBHeaderFlag = FALSE;
				}

				writeP_MVD(
					curMB,		// Current MB number.
					pCurMB,		// pointer to current MB action desc. struct.
					EC->NumMBPerRow,
					EC->NumMBs,
					pBitStream, 
					pBitOffset,
					GOBHeaderFlag,
					EC);

				//  Save bit offset of block data from start of MB data
				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].BlkDataBitOff
					= (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
					- FutrPMBData[curMB].MBStartBitOff);
				}
				/*
				* Encode intra DC and all run/val pairs.
				*/

				#ifdef COUNT_BITS
				savebyteptr = (U32) *pBitStream;
				savebitptr  = (U32) *pBitOffset;
				#endif

				MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocks, 
				            pBitStream, pBitOffset, 0, 1);

				#ifdef COUNT_BITS
				EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
				#endif

			} 
			else 
			{	// Macroblock is empty.
				PutBits(1, 1, pBitStream, pBitOffset);		// COD = 1, empty MB

				// Instead of repeating the above test in the PB-frame encoding
				// pCurMB->COD can now be tested instead.
				pCurMB->COD = 1;

				if(EC->u8EncodePBFrame == TRUE) 
				{
					FutrPMBData[curMB].CBPYBitOff = 1;
					FutrPMBData[curMB].MVDBitOff  = 1;
					FutrPMBData[curMB].BlkDataBitOff = 1;
				}
				#ifdef COUNT_BITS
				EC->Bits.MBHeader += 1;
				#endif
			}	// end of else
		} 
		else if( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTERPIC)) 
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

			/*******************************************
			* Write macroblock header to bit stream.
			*******************************************/	  
			PutBits(0, 1, pBitStream, pBitOffset);		// COD = 0, nonempty MB

			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += 1;
			EC->Bits.Coded++;
			#endif

			// Write MCBPC to bitstream.
			index = (pCurMB->CodedBlocks >> 4) & 0x3;
			index |= (MBType << 2);
			PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_MCBPC_INTER[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTER[index][0];
			#endif

			//  Save bit offset of CBPY data from start of macroblock data
			if(EC->u8EncodePBFrame == TRUE) 
			{
				FutrPMBData[curMB].CBPYBitOff
				= (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
				- FutrPMBData[curMB].MBStartBitOff);
			}
			// Write CBPY to bitstream.
			index = pCurMB->CodedBlocks & 0xf;
			//index = pMBActionStream[curMB].CBPY;
			PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

			//if( bUseDQUANT ) 
			//{
				// write DQUANT to bit stream here.
			//}

			//  Save bit offset of block data from start of macroblock data
			if(EC->u8EncodePBFrame == TRUE) 
			{
				FutrPMBData[curMB].BlkDataBitOff = FutrPMBData[curMB].MVDBitOff
				= (U8) ( ((*pBitStream - pFrmStart)<<3) + *pBitOffset
				- FutrPMBData[curMB].MBStartBitOff);
			}

			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif

			//  Encode run/val pairs
			MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocks, 
			            pBitStream, pBitOffset, 1, 1);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		} 
		else if ( (MBType == INTRA) && (EC->PictureHeader.PicCodType == INTRAPIC)) 
		{
			// Stagger inter code count.
			pCurMB->InterCodeCnt = (unsigned char) (StartingMB & 0xf);	

			//  An INTRA frame should not be the P-frame in a PB-frame
			ASSERT(EC->u8SavedBFrame == FALSE)

			/*******************************************
			* Write macroblock header to bit stream.
			*******************************************/	  
			// Write MCBPC to bitstream.
			index = (pCurMB->CodedBlocks >> 4) & 0x3;
			//index = pMBActionStream[curMB].CBPC;
			//index |= bUseDQUANT << 2;
			PutBits(VLC_MCBPC_INTRA[index][1], VLC_MCBPC_INTRA[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.num_intra++;
			EC->Bits.MBHeader += VLC_MCBPC_INTRA[index][0];
			EC->Bits.MCBPC += VLC_MCBPC_INTRA[index][0];
			#endif

			// Write CBPY to bitstream.
			index = pCurMB->CodedBlocks & 0xf;
			//index = pMBActionStream[curMB].CBPY;
			PutBits(VLC_CBPY[index][1], VLC_CBPY[index][0], pBitStream, pBitOffset);

			#ifdef COUNT_BITS
			EC->Bits.MBHeader += VLC_CBPY[index][0];
			EC->Bits.CBPY += VLC_CBPY[index][0];
			#endif

			//if( bUseDQUANT ) 
			//{
				// write DQUANT to bit stream here.
			//}

			#ifdef COUNT_BITS
			savebyteptr = (U32) *pBitStream;
			savebitptr  = (U32) *pBitOffset;
			#endif

			MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocks, 
			            pBitStream, pBitOffset, 1, 1);

			#ifdef COUNT_BITS
			EC->Bits.Coefs += ((U32) *pBitStream - savebyteptr)*8 - savebitptr + *pBitOffset;
			#endif

		}
		else
			ERRORMESSAGE(("%s: Unexpected case in writing MB header VLC\r\n", _fx_));

		// Calculate DQUANT based on bits used in previous MBs.
		// CalcDQUANT();

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pBitStream,
                                                    (U32) *pBitOffset);
	} // for MB
} // end of GOB_VLC_WriteBS()

/*************************************************************
 *  Name: PB_GOB_Q_RLE_VLC_WriteBS 
 *  Description:  Write out GOB layer bits for GOB number "GOB".
 *  Parameters:
 *    EC                 Encoder catalog
 *    DCTCoefs           Pointer to DCT coefficients for the GOB
 *    pP_BitStreamStart  Pointer to start of bit stream for the future
 *                       P-frame.  Some data from future P frame is copied over
 *                       to PB-frame.
 *    pPB_BitStream      Current PB-frame byte pointer
 *    pPB_BitOffset      Bit offset in the current byte pointed by pPB_BitStream
 *    FutrPMBData        Bit stream info on future P-frame.  This info. is 
 *                       initialized in GOB_Q_RLE_VLC_WriteBS()
 *    GOB                GOBs are numbered from 0 in a frame.
 *    QP                 Quantization value for B-block coefficients.
 *  Side-effects:
 *    pPB_BitStream and pPB_BitOffset are modified as a result of writing bits 
 *    to the stream.
 *************************************************************/
void PB_GOB_Q_RLE_VLC_WriteBS(
    T_H263EncoderCatalog       * EC,
	I32                        * DCTCoefs,
    U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
    const T_FutrPMBData  * const FutrPMBData,
	const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
)
{
    UN   MB;
  	U32  curMB, index;
    U32  GOBHeaderMask, GOBHeaderFlag;
  	I8 	 MBRunValSign[65*3*6], *EndAddress, *rvs;
  	U8	 bUseDQUANT = 0;	// Indicates if DQUANT is present.
    U8   emitCBPB, emitMVDB;

    register T_MBlockActionStream *pCurMB;

	FX_ENTRY("PB_GOB_Q_RLE_VLC_WriteBS")

#ifdef H263P
	// The H.263+ options are currently only available in MMX enabled
	// encoders. If the improved PB-frame mode is desired in non-MMX
	// implementations, the H263P-defined code in PB_GOB_VLC_WriteBS
	// should be mimiced here.
#endif

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

    for (MB = 0, curMB = GOB*EC->NumMBPerRow,
            pCurMB = EC->pU8_MBlockActionStream + curMB;
         MB < EC->NumMBPerRow;
         MB++, curMB++, pCurMB++)
    {
	   /*
	 	* Quantize and RLE each block in the macroblock,
	 	* skipping empty blocks as denoted by CodedBlocks.
	 	* If any more blocks are empty after quantization
	 	* then the appropriate CodedBlocks bit is cleared.
	 	*/
    	EndAddress = (I8 *)MB_Quantize_RLE(
    		&DCTCoefs,
    		(I8 *)MBRunValSign,
    		&(pCurMB->CodedBlocksB),
            INTERBLOCK,                           //  B coeffs are INTER-coded
			QP
    	);

#ifdef ENCODE_STATS
		StatsUsedQuant(QP);
#endif /* ENCODE_STATS */

        //  Write MBlock data
        // Check if entire macroblock is empty, including zero MV's.
        if( ((pCurMB->MBType == INTER)
             || (pCurMB->MBType == INTER4V))
            && (pCurMB->COD == 1) )
		{
            if( ((pCurMB->CodedBlocksB & 0x3f) == 0)
                 && (pCurMB->BlkY1.BHMV == 0)
                && (pCurMB->BlkY1.BVMV == 0))
            {
                //  P-mblock not coded, and neither is PB-mblock.
                //  COD = 1, empty MB.
                //  If it is the first MB in the GOb, then GOB header 
                //  is also copied
                CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,// src
                         FutrPMBData[curMB+1].MBStartBitOff                  // len
                         - FutrPMBData[curMB].MBStartBitOff);
            }
            else	// Macro block is not empty.
            {
                //  Copy COD and MCBPC
                //  If it is the first MB in the GOB, then GOB header 
                //  is also copied.
                if (FutrPMBData[curMB+1].MBStartBitOff - FutrPMBData[curMB].MBStartBitOff != 1)
                {
                    CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                             pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,// src
                             FutrPMBData[curMB+1].MBStartBitOff                  // len
                             - FutrPMBData[curMB].MBStartBitOff - 1);
				}
	    		PutBits(0, 1, pPB_BitStream, pPB_BitOffset);	// COD = 0, nonempty MB

  	   		   /*******************************************
	    		* Write macroblock header to bit stream.
	    		*******************************************/	  
	    	    // Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
	    		index = (pCurMB->CodedBlocks >> 4) & 0x3;

				// Add the MB type to next two bits to the left.
				index |= (pCurMB->MBType << 2);

				// Write code to bitstream.
	    		PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], 
                        pPB_BitStream, pPB_BitOffset);

                //  Write MODB
                if ((pCurMB->CodedBlocksB & 0x3f) == 0)
                {
                    emitCBPB = 0;
                }
                else
                {
                    emitCBPB = 1;
                }
            
                if (((pCurMB->BlkY1.BHMV != 0)
                     || (pCurMB->BlkY1.BVMV != 0))
                   || emitCBPB == 1)
                {
                    emitMVDB = 1;
                }
                else
                {
                    emitMVDB = 0;
                }

                index = (emitMVDB<<1) | emitCBPB;
                PutBits(VLC_MODB[index][1], VLC_MODB[index][0], 
                        pPB_BitStream, pPB_BitOffset);
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));

                //  Write CBPB
                if (emitCBPB)
                {
                    PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 
                            6, pPB_BitStream, pPB_BitOffset);
					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
                }

				// The P blocks are all empty
	    		PutBits(3, 2, pPB_BitStream, pPB_BitOffset);	// CBPY = 11, no coded P blocks

	  		    //if( bUseDQUANT )
	  		    //{
	    		    // write DQUANT to bit stream here.
	  		    //}

                //  Write MVD{2-4}
                //    Note:  MVD cannot be copied from future frame because 
                //           predictors are different for PB-frame (G.2)
			    if( (EC->GOBHeaderPresent & GOBHeaderMask) != 0 )
			    {
				    GOBHeaderFlag = TRUE;
			    }
			    else
			    {
				    GOBHeaderFlag = FALSE;
			    }
                writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
                        pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);
                //  Write MVDB
                if (emitMVDB)
                {
                    ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
                    ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
                    //  Write horizontal motion vector
                    index = (pCurMB->BlkY1.BHMV + 32)*2;
                    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                             pPB_BitStream, pPB_BitOffset);
                    //  Write vertical motion vector
                    index = (pCurMB->BlkY1.BVMV + 32)*2;
                    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                             pPB_BitStream, pPB_BitOffset);
                }
                //  There is no P-mblock blk data
                //  B-frame block data is always INTER-coded (last param is 0)
                if (emitCBPB)
                {
                    rvs = MBRunValSign;
#ifdef H263P
                    MBEncodeVLC(&rvs, NULL, (pCurMB->CodedBlocksB & 0x3f), 
                                pPB_BitStream, pPB_BitOffset, 0, 0);
#else
                    MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocksB, 
                                pPB_BitStream, pPB_BitOffset, 0, 0);
#endif
                }
            }	// end of else
		}
		else
		{
            //  Copy COD and MCBPC
            //  If it is the first MB in the GOB, then GOB header 
            //  is also copied.
            CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                     pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,// src
                     FutrPMBData[curMB].CBPYBitOff);                     // len
            //  Write MODB
            if ((pCurMB->CodedBlocksB & 0x3f) == 0)
            {
                emitCBPB = 0;
            }
            else
            {
                emitCBPB = 1;
            }
            
            if (((pCurMB->BlkY1.BHMV != 0)
                 || (pCurMB->BlkY1.BVMV != 0))
               || emitCBPB == 1)
            {
                emitMVDB = 1;
            }
            else
            {
                emitMVDB = 0;
            }

            index = (emitMVDB<<1) | emitCBPB;
            PutBits(VLC_MODB[index][1], VLC_MODB[index][0], 
                    pPB_BitStream, pPB_BitOffset);
			DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));

            //  Write CBPB
            if (emitCBPB)
            {
                PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 
                        6, pPB_BitStream, pPB_BitOffset);
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
            }
            //  Copy CBPY, {DQUANT}
            CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                     pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff // src
                                        + FutrPMBData[curMB].CBPYBitOff,
                     FutrPMBData[curMB].MVDBitOff                        // len
                     - FutrPMBData[curMB].CBPYBitOff);
            //  Write MVD{2-4}
            //    Note:  MVD cannot be copied from future frame because 
            //           predictors are different for PB-frame (G.2)
			if( (EC->GOBHeaderPresent & GOBHeaderMask) != 0 )
			{
				GOBHeaderFlag = TRUE;
			}
			else
			{
				GOBHeaderFlag = FALSE;
			}
            writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
                    pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);
            //  Write MVDB
            if (emitMVDB)
            {
                ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
                ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
                //  Write horizontal motion vector
                index = (pCurMB->BlkY1.BHMV + 32)*2;
                PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                         pPB_BitStream, pPB_BitOffset);
                //  Write vertical motion vector
                index = (pCurMB->BlkY1.BVMV + 32)*2;
                PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), 
                         pPB_BitStream, pPB_BitOffset);
            }
            //  Copy P-mblock blk data
            CopyBits(pPB_BitStream, pPB_BitOffset,                       // dest
                     pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff // src
                                        + FutrPMBData[curMB].BlkDataBitOff,
                     FutrPMBData[curMB+1].MBStartBitOff                  // len
                     - FutrPMBData[curMB].MBStartBitOff
                     - FutrPMBData[curMB].BlkDataBitOff);
            //  B-frame block data is always INTER-coded (last param is 0)
            if (emitCBPB)
            {
                rvs = MBRunValSign;
#ifdef H263P
                MBEncodeVLC(&rvs, NULL, (pCurMB->CodedBlocksB & 0x3f), 
                            pPB_BitStream, pPB_BitOffset, 0, 0);
#else
                MBEncodeVLC(&rvs, NULL, pCurMB->CodedBlocksB, 
                            pPB_BitStream, pPB_BitOffset, 0, 0);
#endif
            }
        }	// end of else

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pPB_BitStream,
                                                    (U32) *pPB_BitOffset);
	} // for MB

} // end of PB_GOB_Q_RLE_VLC_WriteBS()


/*************************************************************
 *  Name: PB_GOB_VLC_WriteBS 
 *  Description:  Write out GOB layer bits for GOB number "GOB".
 *  Parameters:
 *    EC                 Encoder catalog
 *    pMBRVS_Luma        Quantized DCT coeffs. of B-block luma
 *    pMBRVS_Chroma      Quantized DCT coeffs. of B-block chroma
 *    pP_BitStreamStart  Pointer to start of bit stream for the future
 *                       P-frame.  Some data from future P frame is copied over
 *                       to PB-frame.
 *    pPB_BitStream      Current PB-frame byte pointer
 *    pPB_BitOffset      Bit offset in the current byte pointed by pPB_BitStream
 *    FutrPMBData        Bit stream info on future P-frame.  This info. is 
 *                       initialized in GOB_Q_RLE_VLC_WriteBS()
 *    GOB                GOBs are numbered from 0 in a frame.
 *    QP                 Quantization value for B-block coefficients.
 *  Side-effects:
 *    pPB_BitStream and pPB_BitOffset are modified as a result of writing bits 
 *    to the stream.
 *  Notes:
 *    The improved PB-frame mode of H.263+ is currently only available in
 *    MMX enabled versions of the encoder. This routine is the MMX equivalent
 *    of PB_GOB_Q_RLE_VLC_WriteBS(), which does not contain the H.263+
 *    modifications.
 *************************************************************/
void PB_GOB_VLC_WriteBS(
	T_H263EncoderCatalog       * EC,
	I8                         * pMBRVS_Luma,
	I8                         * pMBRVS_Chroma,
	U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
	const T_FutrPMBData  * const FutrPMBData,
    const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
)
{
    UN  MB;
    U32 curMB, index;
    U32 GOBHeaderMask, GOBHeaderFlag;
    U8  bUseDQUANT = 0;   // Indicates if DQUANT is present.
    U8  emitCBPB, emitMVDB;
	register T_MBlockActionStream *pCurMB;

	FX_ENTRY("PB_GOB_VLC_WriteBS")

	// Create GOB header mask to be used further down.
	GOBHeaderMask = 1 << GOB;

    for (MB = 0, curMB = GOB*EC->NumMBPerRow,
            pCurMB = EC->pU8_MBlockActionStream + curMB;
         MB < EC->NumMBPerRow;
         MB++, curMB++, pCurMB++)
	{
		/*
		* Quantize and RLE each block in the macroblock,
		* skipping empty blocks as denoted by CodedBlocks.
		* If any more blocks are empty after quantization
		* then the appropriate CodedBlocks bit is cleared.
		*/
		//  Write MBlock data
		// Check if entire macroblock is empty, including zero MV's.
		if(((pCurMB->MBType == INTER)
		 || (pCurMB->MBType == INTER4V))
	 	 && (pCurMB->COD == 1) ) 
		{
#ifdef H263P
			// If forward prediction selected for B block, macroblock is not empty
            if( ((pCurMB->CodedBlocksB & 0x3f) == 0)
                 && (pCurMB->BlkY1.BHMV == 0)
                && (pCurMB->BlkY1.BVMV == 0)
				&& ((pCurMB->CodedBlocksB & 0x80) == 0))	// forward pred. not selected
#else
            if( ((pCurMB->CodedBlocksB & 0x3f) == 0)
                 && (pCurMB->BlkY1.BHMV == 0)
                && (pCurMB->BlkY1.BVMV == 0))
#endif
			{
				//  P-mblock not coded, and neither is PB-mblock.
				//  COD = 1, empty MB.
				//  If it is the first MB in the GOb, then GOB header 
				//  is also copied
				CopyBits(pPB_BitStream, pPB_BitOffset,                         // dest
				         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,  // src
				         FutrPMBData[curMB+1].MBStartBitOff                    // len
				         - FutrPMBData[curMB].MBStartBitOff);
			} 
			else 
			{ // Macro block is not empty.
				//  Copy COD and MCBPC
				//  If it is the first MB in the GOB, then GOB header 
				//  is also copied.
				if(FutrPMBData[curMB+1].MBStartBitOff - FutrPMBData[curMB].MBStartBitOff != 1) 
				{
					CopyBits(pPB_BitStream, pPB_BitOffset,                      // dest
					         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,     // src
					         FutrPMBData[curMB+1].MBStartBitOff                       // len
					         - FutrPMBData[curMB].MBStartBitOff - 1);
				}
				PutBits(0, 1, pPB_BitStream, pPB_BitOffset);	// COD = 0, nonempty MB
				/*******************************************
				* Write macroblock header to bit stream.
				*******************************************/	  
				// Write MCBPC to bitstream.
				// The rightmost two bits are the CBPC (65).
				// Note that this is the reverse of the order in the
				// VLC table in the H.263 spec.
				index = (pCurMB->CodedBlocks >> 4) & 0x3;
				// Add the MB type to next two bits to the left.
				index |= (pCurMB->MBType << 2);
				// Write code to bitstream.
				PutBits(VLC_MCBPC_INTER[index][1], VLC_MCBPC_INTER[index][0], pPB_BitStream, pPB_BitOffset);
				//  Write MODB
				if((pCurMB->CodedBlocksB & 0x3f) == 0) 
				{
					emitCBPB = 0;
				} 
				else 
				{
					emitCBPB = 1;
				}

#ifdef H263P
				if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON)
				{
					// include MVDB only if forward prediction selected
					// for bidirectional prediction, MVd = [0, 0]
					if (pCurMB->CodedBlocksB & 0x80)
					{
						emitMVDB = 1;
					}
					else
					{
						emitMVDB = 0;
					}
				}
				else
#endif // H263P
				{
					if(((pCurMB->BlkY1.BHMV != 0) || (pCurMB->BlkY1.BVMV != 0)) || emitCBPB == 1) 
					{
						emitMVDB = 1;
					} 
					else {
						emitMVDB = 0;
					}
				}

#ifdef H263P
				if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON) 
				{
					if (!emitCBPB) {
						if (!emitMVDB)
							// Bidirectional prediction with all empty blocks
							index = 0;
						else
							// Forward prediction with all empty blocks
							index = 1;
					} else {
						if (emitMVDB)
							// Forward prediction with non-empty blocks
							index = 2;
						else
							// Bidirectional prediction with non-empty blocks
							index = 3;
					}

					PutBits(VLC_IMPROVED_PB_MODB[index][1], VLC_IMPROVED_PB_MODB[index][0], 
							pPB_BitStream, pPB_BitOffset);
					DbgLog((LOG_TRACE,6,TEXT("MB=%d emitCBPB=%d emitMVDB=%d MODB=%d"),
							 curMB, (int)emitCBPB, (int)emitMVDB, 
							 (int)VLC_IMPROVED_PB_MODB[index][1]));
				}
				else // not using improved PB-frame mode
#endif // H263P
				{
					index = (emitMVDB<<1) | emitCBPB;
					PutBits(VLC_MODB[index][1], VLC_MODB[index][0], pPB_BitStream, pPB_BitOffset);

					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));
				}

				//  Write CBPB
				if(emitCBPB) {
					PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 6, pPB_BitStream, pPB_BitOffset);

					DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
				}
				PutBits(3, 2, pPB_BitStream, pPB_BitOffset);	// CBPY = 11, no coded P blocks
				//if( bUseDQUANT ) 
				//{
					// write DQUANT to bit stream here.
				//}
				//  Write MVD{2-4}
				//    Note:  MVD cannot be copied from future frame because 
				//           predictors are different for PB-frame (G.2)
				if((EC->GOBHeaderPresent & GOBHeaderMask) != 0) 
				{
					GOBHeaderFlag = TRUE;
				} 
				else 
				{
					GOBHeaderFlag = FALSE;
				}
				writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
				pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);
				//  Write MVDB
				if (emitMVDB) 
				{
					ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
					ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
					//  Write horizontal motion vector
					index = (pCurMB->BlkY1.BHMV + 32)*2;
					PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
					//  Write vertical motion vector
					index = (pCurMB->BlkY1.BVMV + 32)*2;
					PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
				}
				//  There is no P-mblock blk data
				//  B-frame block data is always INTER-coded (last param is 0)
				if (emitCBPB) 
				{
#ifdef H263P
					MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, (pCurMB->CodedBlocksB & 0x3f), 
					pPB_BitStream, pPB_BitOffset, 0, 1);
#else
					MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, pCurMB->CodedBlocksB, 
					pPB_BitStream, pPB_BitOffset, 0, 1);
#endif
				}
			}	// end of else
		} 
		else 
		{
			//  Copy COD and MCBPC
			//  If it is the first MB in the GOB, then GOB header 
			//  is also copied.
			CopyBits(pPB_BitStream, pPB_BitOffset,                      // dest
			         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff,     // src
			         FutrPMBData[curMB].CBPYBitOff);                          // len
			//  Write MODB
			if((pCurMB->CodedBlocksB & 0x3f) == 0) 
			{
				emitCBPB = 0;
			} 
			else 
			{
				emitCBPB = 1;
			}

#ifdef H263P
			if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON)
			{
				// include MVDB only if forward prediction selected
				// for bidirectional prediction, MVd = [0, 0]
				if (pCurMB->CodedBlocksB & 0x80)
				{
					emitMVDB = 1;
				}
				else
				{
					emitMVDB = 0;
				}
			}
			else
#endif // H263P
			{
				if(((pCurMB->BlkY1.BHMV != 0) || (pCurMB->BlkY1.BVMV != 0)) || emitCBPB == 1) 
				{
					emitMVDB = 1;
				} 
				else {
					emitMVDB = 0;
				}
			}


#ifdef H263P
			if (EC->PictureHeader.PB == ON && EC->PictureHeader.ImprovedPB == ON) 
			{
				if (!emitCBPB) {
					if (!emitMVDB)
						// Bidirectional prediction with all empty blocks
						index = 0;
					else
						// Forward prediction with all empty blocks
						index = 1;
				} else {
					if (emitMVDB)
						// Forward prediction with non-empty blocks
						index = 2;
					else
						// Bidirectional prediction with non-empty blocks
						index = 3;
				}

				PutBits(VLC_IMPROVED_PB_MODB[index][1], VLC_IMPROVED_PB_MODB[index][0], 
						pPB_BitStream, pPB_BitOffset);

				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_IMPROVED_PB_MODB[index][1]));
			}
			else // not using improved PB-frame mode
#endif // H263P
			{
				index = (emitMVDB<<1) | emitCBPB;
				PutBits(VLC_MODB[index][1], VLC_MODB[index][0], pPB_BitStream, pPB_BitOffset);
			
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: MB=%d emitCBPB=%d emitMVDB=%d MODB=%d\r\n", _fx_, curMB, (int)emitCBPB, (int)emitMVDB, (int)VLC_MODB[index][1]));
			}
			
			//  Write CBPB
			if (emitCBPB) {
				PutBits(VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)], 6, pPB_BitStream, pPB_BitOffset);
			
				DEBUGMSG(ZONE_ENCODE_DETAILS, ("%s: CBPB=0x%x\r\n", _fx_, VLC_CBPB[(pCurMB->CodedBlocksB & 0x3f)]));
			}
			//  Copy CBPY, {DQUANT}
			CopyBits(pPB_BitStream, pPB_BitOffset,                               // dest
			         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff               // src
			         + FutrPMBData[curMB].CBPYBitOff, FutrPMBData[curMB].MVDBitOff     // len
			         - FutrPMBData[curMB].CBPYBitOff);

			//  Write MVD{2-4}
			//    Note:  MVD cannot be copied from future frame because 
			//           predictors are different for PB-frame (G.2)
			if((EC->GOBHeaderPresent & GOBHeaderMask) != 0) 
			{
				GOBHeaderFlag = TRUE;
			} 
			else 
			{
				GOBHeaderFlag = FALSE;
			}
			writePB_MVD(curMB, pCurMB, EC->NumMBPerRow, EC->NumMBs,
			pPB_BitStream, pPB_BitOffset, GOBHeaderFlag, EC);

			//  Write MVDB
			if (emitMVDB) 
			{
				ASSERT(pCurMB->BlkY1.BHMV >= -32 && pCurMB->BlkY1.BHMV <= 31)
				ASSERT(pCurMB->BlkY1.BVMV >= -32 && pCurMB->BlkY1.BVMV <= 31)
				//  Write horizontal motion vector
				index = (pCurMB->BlkY1.BHMV + 32)*2;
				PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
				//  Write vertical motion vector
				index = (pCurMB->BlkY1.BVMV + 32)*2;
				PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
			}
			//  Copy P-mblock blk data
			CopyBits(pPB_BitStream, pPB_BitOffset,                               // dest
			         pP_BitStreamStart, FutrPMBData[curMB].MBStartBitOff               // src
			         + FutrPMBData[curMB].BlkDataBitOff, 
			         FutrPMBData[curMB+1].MBStartBitOff                                // len
			         - FutrPMBData[curMB].MBStartBitOff
			         - FutrPMBData[curMB].BlkDataBitOff);
			//  B-frame block data is always INTER-coded (last param is 0)
			if(emitCBPB) 
			{
#ifdef H263P
				MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, 
					        (pCurMB->CodedBlocksB & 0x3f), 
							pPB_BitStream, pPB_BitOffset, 0, 1);
#else
				MBEncodeVLC(&pMBRVS_Luma, &pMBRVS_Chroma, 
					        pCurMB->CodedBlocksB, 
							pPB_BitStream, pPB_BitOffset, 0, 1);
#endif
			}
		}	// end of else

        if (bRTPHeader)
            H263RTP_UpdateBsInfo(EC, pCurMB, QP, MB, GOB, *pPB_BitStream,
                                                    (U32) *pPB_BitOffset);
	} // for MB

} // end of PB_GOB_VLC_WriteBS()

/***************************************************************
 *  MB_Quantize_RLE
 *    Takes the list of coefficient pairs from the DCT routine
 *    and returns a list of Run/Level/Sign triples (each 1 byte)
 *    The end of the run/level/sign triples for a block
 *    is signalled by an illegal combination (TBD).
 ****************************************************************/
static I8 * MB_Quantize_RLE(
    I32 **DCTCoefs,
    I8   *MBRunValPairs,
	U8   *CodedBlocks,
	U8    BlockType,
	I32   QP
)
{
    int   b;
    U8    bitmask = 1;
    I8  * EndAddress;

    #ifdef DEBUG_DCT
    int  DCTarray[64];
    #endif

	FX_ENTRY("MB_Quantize_RLE")

    /*
     * Loop through all 6 blocks of macroblock.
     */
    for(b = 0; b < 6; b++, bitmask <<= 1)
    {
        
		DEBUGMSG(ZONE_ENCODE_MB, ("%s: Block #%d\r\n", _fx_, b));

        // Skip this block if not coded.
        if( (*CodedBlocks & bitmask) == 0)
            continue;
        
        #ifdef DEBUG_DCT
	    cnvt_fdct_output((unsigned short *) *DCTCoefs, DCTarray, (int) BlockType);
	    #endif
	
        /*
         * Quantize and run-length encode a block.
         */  
       EndAddress = QUANTRLE(*DCTCoefs, MBRunValPairs, QP, (int)BlockType);
       #ifdef DEBUG
	    char *p;
	    for(p = (char *)MBRunValPairs; p < (char *)EndAddress; p+=3)
        {
			DEBUGMSG(ZONE_ENCODE_MB, ("%s: (%u, %u, %d)\r\n", _fx_, (unsigned char)*p, (unsigned char)*(p+1), (int)*(p+2)));
        }
	    #endif

        // Clear coded block bit for this block.
        if ( EndAddress == MBRunValPairs)
        {
            ASSERT(BlockType != INTRABLOCK)	// should have at least INTRADC in an INTRA blck
            *CodedBlocks &= ~bitmask;
        }
        else if ( (EndAddress == (MBRunValPairs+3)) && (BlockType == INTRABLOCK) )
        {
            *CodedBlocks &= ~bitmask;
            MBRunValPairs = EndAddress;
        }
        else
        {
            MBRunValPairs = EndAddress;
            *MBRunValPairs = -1;   // Assign an illegal run to signal end of block.
            MBRunValPairs += 3;	   // Increment to the next triple.
        }
        
        *DCTCoefs += 32;		// Increment DCT Coefficient pointer to next block.
    }

    return MBRunValPairs;
}


/*******************************************************************
 * Variable length code teh run/level/sign triples and write the 
 * codes to the bitstream.
 *******************************************************************/
/*
U8 *  MB_VLC_WriteBS()
{
  for(b = 0; b < 6; b++)
  {
      Block_VLC_WriteBS()
  }
}
*/

void InitVLC(void)
{
  int i, size, code;
  int run, level;

  /*
   * initialize INTRADC fixed length code table.
   */
  for(i = 1; i < 254; i++)
  {
    FLC_INTRADC[i] = i;
  }
  FLC_INTRADC[0] = 1;
  FLC_INTRADC[128] = 255;
  FLC_INTRADC[254] = 254;
  FLC_INTRADC[255] = 254;

 /*
  * Initialize tcoef tables.
  */

  for(i=0; i < 64*12; i++)
  {
    VLC_TCOEF_TBL[i] = 0x0000FFFF;
  }
  
  for(run=0; run < 64; run++)
  {
    for(level=1; level <= TCOEF_RUN_MAXLEVEL[run].maxlevel; level++)
	{
	  size = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1)*2);
	  size <<= 16;
	  code = *(TCOEF_RUN_MAXLEVEL[run].ptable + (level - 1)*2 +1);
      VLC_TCOEF_TBL[ (run) + (level-1)*64 ] = code;
      VLC_TCOEF_TBL[ (run) + (level-1)*64 ] |= size;
	} // end of for level
  } // end of for run


 /*
  * Initialize last tcoef tables.
  */
  
  for(i=0; i < 64*3; i++)
  {
    VLC_TCOEF_LAST_TBL[i] = 0x0000FFFF;
  }    

  run = 0;
  for(level=1; level <= 3; level++)
  {
    size = *(VLC_TCOEF + 58*2 + (level - 1)*2);
    size <<= 16;
    code = *(VLC_TCOEF + 58*2 + (level - 1)*2 +1);
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] = code;
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] |= size;
  } // end of for level

  run = 1;
  for(level=1; level <= 2; level++)
  {
    size = *(VLC_TCOEF + 61*2 + (level - 1)*2);
    size <<= 16;
    code = *(VLC_TCOEF + 61*2 + (level - 1)*2 +1);
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] = code;
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] |= size;
  } // end of for level

  level=1;
  for(run=2; run <= 40; run++)
  {
    size = *(VLC_TCOEF + 63*2+ (run - 2)*2);
    size <<= 16;
    code = *(VLC_TCOEF + 63*2 + (run - 2)*2 +1);
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] = code;
    VLC_TCOEF_LAST_TBL[ run + (level-1)*64 ] |= size;
  } // end of for run

} // InitVLC.



/******************************************************************
 *  Name: median
 *  
 *  Description: Take the median of three signed chars.  Implementation taken 
 *               from the decoder.
 *******************************************************************/
static char __fastcall median(char v1, char v2, char v3)
{
    char temp;
    
    if (v2 < v1) 
    {
        temp = v2; v2 = v1; v1 = temp;
    } 
    //  Invariant : v1 < v2
    if (v2 > v3) 
    { 
        v2 = (v1 < v3) ? v3 : v1;
    }
    return v2;
}

/*************************************************************
 *  Name:       writeP_MVD
 *  Algorithm:  See section 6.1.1
 *     This routine assumes that there are always four motion 
 *  vectors per macroblock defined. If there is actually one
 *  motion vector in the macroblock, then the four MV fields
 *  should be equivalent. In this way the MV predictor for 
 *  block 1 of the 4 MV case is calculated the same way as the
 *  MV predictor for the macroblock in the 1 MV case.
 ************************************************************/
static void writeP_MVD(
    const U32                     curMB, 
    T_MBlockActionStream  * const pCurMB,
    const U32                     NumMBPerRow,
	const U32					  NumMBs,
    U8                         ** pP_BitStream,
    U8                          * pP_BitOffset,
	U32							  GOBHeaderPresent,
	T_H263EncoderCatalog         *EC
)
{
    I8  HMV, VMV, BHMV, BVMV, CHMV, CVMV, DHMV, DVMV;
    I8  HMV1, HMV2, HMV3, VMV1, VMV2, VMV3;

	FX_ENTRY("writeP_MVD")

    //FirstMEState = pCurMB->FirstMEState;

	/*
	 * Top left corner of picture of GOB.
	 */
    if( (curMB == 0) || 
              ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) == 0)  ) )
    {
        HMV = 0;
        VMV = 0;

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = VMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Upper edge (not corner) or upper right corner of picture
	 * or GOB.
	 */
    else if( (curMB < NumMBPerRow) ||
             ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) > 0)  ) )
    {
        register T_MBlockActionStream *pMB1;

        pMB1 = pCurMB - 1; 
        HMV = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        VMV = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }	
	/*
	 * Central portion of the picture, not next to any edge.
	 */
    else if ( 	((curMB % NumMBPerRow) != 0) &&		// not left edge
				(curMB >= NumMBPerRow) &&			// not top row
				((curMB % NumMBPerRow) != (NumMBPerRow-1)) &&	// not right edge
				(curMB < (NumMBs - NumMBPerRow))    )	// not bottom row
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;

        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;

        HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        HMV = median(HMV1, HMV2, HMV3);
        
        VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        VMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        
        VMV = median(VMV1, VMV2, VMV3);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V


    }
	/*
	 * Left edge or lower left corner.
	 */
    else if( (curMB % NumMBPerRow) == 0 )
    {
        register T_MBlockActionStream *pMB2, *pMB3;

        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;

        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        HMV = median(0, HMV2, HMV3);
        
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        VMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        VMV = median(0, VMV2, VMV3);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = 0;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Right edge or lower right corner.
	 */
    else if( (curMB % NumMBPerRow) == (NumMBPerRow-1) )
    {
        register T_MBlockActionStream *pMB1, *pMB2;

        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 

        HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV = median(HMV1, HMV2, 0);
        
        VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        
        VMV = median(VMV1, VMV2, 0);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   0;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   0;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
    else
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;

        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;

        HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PHMV : 0);
        HMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PHMV : 0);
        HMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        HMV = median(HMV1, HMV2, HMV3);
        
        VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY2.PVMV : 0);
        VMV2 = (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY3.PVMV : 0);
        VMV3 = (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        
        VMV = median(VMV1, VMV2, VMV3);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PHMV : 0);
			HMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PHMV : 0);
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   (pMB2->BlockType != INTRABLOCK ? pMB2->BlkY4.PVMV : 0);
			VMV3 =   (pMB3->BlockType != INTRABLOCK ? pMB3->BlkY3.PVMV : 0);
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PHMV : 0);
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = (pMB1->BlockType != INTRABLOCK ? pMB1->BlkY4.PVMV : 0);
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }

    /******************************************************************
     *  Compute motion vector delta and write VLC out to the bitstream
     ******************************************************************/
    register I32 hdelta, vdelta;
    register U32 index;

    hdelta = pCurMB->BlkY1.PHMV - HMV;
    vdelta = pCurMB->BlkY1.PVMV - VMV;
    
#ifdef DEBUG
	if (EC->PictureHeader.UMV == OFF) {
		ASSERT((pCurMB->BlkY2.PHMV >= -32 && pCurMB->BlkY2.PHMV <= 31));
		ASSERT((pCurMB->BlkY2.PVMV >= -32 && pCurMB->BlkY2.PVMV <= 31));
	} else {
		if (HMV <= -32) {
			ASSERT((pCurMB->BlkY2.PHMV >= -63 && pCurMB->BlkY2.PHMV <= 0));
		} else if (HMV <= 32) {
			ASSERT((hdelta >= -32 && hdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY2.PHMV >= 0 && pCurMB->BlkY2.PHMV <= 63));
		}
		if (VMV <= -32) {
			ASSERT((pCurMB->BlkY2.PVMV >= -63 && pCurMB->BlkY2.PVMV <= 0));
		} else if (VMV <= 32) {
			ASSERT((vdelta >= -32 && vdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY2.PVMV >= 0 && pCurMB->BlkY2.PVMV <= 63));
		}
	}
#endif

	if (EC->PictureHeader.UMV == ON)
	{
		if (HMV < -31 && hdelta < -63) 
			hdelta += 64;
		else if (HMV > 32 && hdelta > 63) 
			hdelta -= 64;

		if (VMV < -31 && vdelta < -63) 
			vdelta += 64;
		else if (VMV > 32 && vdelta > 63) 
			vdelta -= 64;
	}
	// Adjust the deltas to be in the range of -32...+31
	if(hdelta > 31)
		hdelta -= 64;
	if(hdelta < -32)
		hdelta += 64;

	if(vdelta > 31)
		vdelta -= 64;
	if(vdelta < -32)
		vdelta += 64;
    
	DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 1) MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY1.PHMV, pCurMB->BlkY1.PVMV));
    
    // Write horizontal motion vector delta here.
    index = (hdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

	#ifdef COUNT_BITS
	EC->Bits.MBHeader += *(vlc_mvd+index);
	EC->Bits.MV += *(vlc_mvd+index);
	#endif
	    
    // Write horizontal motion vector delta here.
    index = (vdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

	#ifdef COUNT_BITS
	EC->Bits.MBHeader += *(vlc_mvd+index);
	EC->Bits.MV += *(vlc_mvd+index);
	#endif

	/*
	 * Deal with 4 MV case.
	 */
	if(pCurMB->MBType == INTER4V)
	{

		/*--------------
		 * Block 2.
		 *--------------*/
    	hdelta = pCurMB->BlkY2.PHMV - BHMV;
    	vdelta = pCurMB->BlkY2.PVMV - BVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY2.PHMV >= -32 && pCurMB->BlkY2.PHMV <= 31));
			ASSERT((pCurMB->BlkY2.PVMV >= -32 && pCurMB->BlkY2.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY2.PHMV >= -63 && pCurMB->BlkY2.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PHMV >= 0 && pCurMB->BlkY2.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY2.PVMV >= -63 && pCurMB->BlkY2.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PVMV >= 0 && pCurMB->BlkY2.PVMV <= 63));
			}
		}
#endif

		if (EC->PictureHeader.UMV == ON)
		{
			if (BHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (BHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (BVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (BVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}
		// Adjust the deltas to be in the range of -32...+31
		if(hdelta > 31)
			hdelta -= 64;
		if(hdelta < -32)
			hdelta += 64;

		if(vdelta > 31)
			vdelta -= 64;
		if(vdelta < -32)
			vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 2)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY2.PHMV, pCurMB->BlkY2.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif


		/*----------------
		 * Block 3
		 *---------------*/
    	hdelta = pCurMB->BlkY3.PHMV - CHMV;
    	vdelta = pCurMB->BlkY3.PVMV - CVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY3.PHMV >= -32 && pCurMB->BlkY3.PHMV <= 31));
			ASSERT((pCurMB->BlkY3.PVMV >= -32 && pCurMB->BlkY3.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY3.PHMV >= -63 && pCurMB->BlkY3.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PHMV >= 0 && pCurMB->BlkY3.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY3.PVMV >= -63 && pCurMB->BlkY3.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PVMV >= 0 && pCurMB->BlkY3.PVMV <= 63));
			}
		}
#endif

		if (EC->PictureHeader.UMV == ON)
		{
			if (CHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (CHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (CVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (CVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}
		// Adjust the deltas to be in the range of -32...+31
		if(hdelta > 31)
			hdelta -= 64;
		if(hdelta < -32)
			hdelta += 64;

		if(vdelta > 31)
			vdelta -= 64;
		if(vdelta < -32)
			vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 3)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY3.PHMV, pCurMB->BlkY3.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif


		/*-----------------
		 * Block 4
		 *-------------------*/
    	hdelta = pCurMB->BlkY4.PHMV - DHMV;
    	vdelta = pCurMB->BlkY4.PVMV - DVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY4.PHMV >= -32 && pCurMB->BlkY4.PHMV <= 31));
			ASSERT((pCurMB->BlkY4.PVMV >= -32 && pCurMB->BlkY4.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY4.PHMV >= -63 && pCurMB->BlkY4.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PHMV >= 0 && pCurMB->BlkY4.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY4.PVMV >= -63 && pCurMB->BlkY4.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PVMV >= 0 && pCurMB->BlkY4.PVMV <= 63));
			}
		}
#endif

		if (EC->PictureHeader.UMV == ON)
		{
			if (DHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (DHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (DVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (DVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}
		// Adjust the deltas to be in the range of -32...+31
		if(hdelta > 31)
			hdelta -= 64;
		if(hdelta < -32)
			hdelta += 64;

		if(vdelta > 31)
			vdelta -= 64;
		if(vdelta < -32)
			vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (P Block 4)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY4.PHMV, pCurMB->BlkY4.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pP_BitStream, pP_BitOffset);

		#ifdef COUNT_BITS
		EC->Bits.MBHeader += *(vlc_mvd+index);
		EC->Bits.MV += *(vlc_mvd+index);
		#endif

	} // end of if INTER4V

}

/*************************************************************
 *  Name:       writePB_MVD
 *  Algorithm:  See section 6.1.1 and annex G
 *     This routine assumes that there are always four motion 
 *  vectors per macroblock defined. If there is actually one
 *  motion vector in the macroblock, then the four MV fields
 *  should be equivalent. In this way the MV predictor for 
 *  block 1 of the 4 MV case is calculated the same way as the
 *  MV predictor for the macroblock in the 1 MV case.
 ************************************************************/
static void writePB_MVD(
    const U32              curMB, 
    T_MBlockActionStream * const pCurMB,
    const U32              NumMBPerRow,
	const U32			   NumMBs,
    U8                  ** pPB_BitStream,
    U8                   * pPB_BitOffset,
	U32					   GOBHeaderPresent,
	const T_H263EncoderCatalog  *EC
)
{
    U8  FirstMEState;
    I8  HMV, VMV, BHMV, BVMV, CHMV, CVMV, DHMV, DVMV;
    I8  HMV1, HMV2, HMV3, VMV1, VMV2, VMV3;
    
	FX_ENTRY("writePB_MVD")

    FirstMEState = pCurMB->FirstMEState;

	/*
	 * Top left corner of picture of GOB.
	 */
    if( (curMB == 0) || 
              ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) == 0)  ) )
    {
        HMV = 0;
        VMV = 0;

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = VMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Upper edge (not corner) or upper right corner of picture
	 * or GOB.
	 */
    else if( (curMB < NumMBPerRow) ||
             ( (GOBHeaderPresent == TRUE) && ((curMB % NumMBPerRow) > 0)  ) )
    {
        register T_MBlockActionStream *pMB1;
        
        pMB1 = pCurMB - 1; 
        HMV = pMB1->BlkY2.PHMV;
        VMV = pMB1->BlkY2.PVMV;


		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			BHMV = pCurMB->BlkY1.PHMV;
			BVMV = pCurMB->BlkY1.PVMV;

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }	
	/*
	 * Central portion of the picture, not next to any edge.
	 */
    else if ( 	((curMB % NumMBPerRow) != 0) &&		// not left edge
				(curMB >= NumMBPerRow) &&			// not top row
				((curMB % NumMBPerRow) != (NumMBPerRow-1)) &&	// not right edge
				(curMB < (NumMBs - NumMBPerRow))    )	// not bottom row
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;
        
        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;
        HMV = median(pMB1->BlkY2.PHMV, pMB2->BlkY3.PHMV, pMB3->BlkY3.PHMV);
        VMV = median(pMB1->BlkY2.PVMV, pMB2->BlkY3.PVMV, pMB3->BlkY3.PVMV);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   pMB3->BlkY3.PHMV;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   pMB3->BlkY3.PVMV;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Left edge or lower left corner.
	 */
    else if( (curMB % NumMBPerRow) == 0 )
    {
        register T_MBlockActionStream *pMB2, *pMB3;
        
        pMB2 = pCurMB - NumMBPerRow;
        pMB3 = pMB2 + 1;
        HMV = median(0, pMB2->BlkY3.PHMV, pMB3->BlkY3.PHMV);
        VMV = median(0, pMB2->BlkY3.PVMV, pMB3->BlkY3.PVMV);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   pMB3->BlkY3.PHMV;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   pMB3->BlkY3.PVMV;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = 0;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = 0;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
	/*
	 * Right edge or lower right corner.
	 */
    else if( (curMB % NumMBPerRow) == (NumMBPerRow-1) )
    {
        register T_MBlockActionStream *pMB1, *pMB2;
        
        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        HMV = median(pMB1->BlkY2.PHMV, pMB2->BlkY3.PHMV, 0);
        VMV = median(pMB1->BlkY2.PVMV, pMB2->BlkY3.PVMV, 0);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   0;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   0;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }
    else
    {
        register T_MBlockActionStream *pMB1, *pMB2, *pMB3;
        
        pMB1 = pCurMB - 1; 
        pMB2 = pCurMB - NumMBPerRow; 
        pMB3 = pMB2 + 1;
        HMV = median(pMB1->BlkY2.PHMV, pMB2->BlkY3.PHMV, pMB3->BlkY3.PHMV);
        VMV = median(pMB1->BlkY2.PVMV, pMB2->BlkY3.PVMV, pMB3->BlkY3.PVMV);

		if(pCurMB->MBType == INTER4V)
		{
			// Predictor for Block 2.
			HMV1 = pCurMB->BlkY1.PHMV;
			HMV2 =   pMB2->BlkY4.PHMV;
			HMV3 =   pMB3->BlkY3.PHMV;
        	BHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY1.PVMV;
			VMV2 =   pMB2->BlkY4.PVMV;
			VMV3 =   pMB3->BlkY3.PVMV;
        	BVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 3.
			HMV1 = pMB1->BlkY4.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	CHMV = median(HMV1, HMV2, HMV3);
			
			VMV1 = pMB1->BlkY4.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	CVMV = median(VMV1, VMV2, VMV3);

			// Predictor for Block 4
			HMV1 = pCurMB->BlkY3.PHMV;
			HMV2 = pCurMB->BlkY1.PHMV;
			HMV3 = pCurMB->BlkY2.PHMV;
        	DHMV = median(HMV1, HMV2, HMV3);

			VMV1 = pCurMB->BlkY3.PVMV;
			VMV2 = pCurMB->BlkY1.PVMV;
			VMV3 = pCurMB->BlkY2.PVMV;
        	DVMV = median(VMV1, VMV2, VMV3);

		}	// end of if INTER4V

    }

    /******************************************************************
     *  Compute motion vector delta and write VLC out to the bitstream
     ******************************************************************/
    register I32 hdelta, vdelta;
    register U32 index;

    hdelta = pCurMB->BlkY1.PHMV - HMV;
    vdelta = pCurMB->BlkY1.PVMV - VMV;
    
#ifdef DEBUG
	if (EC->PictureHeader.UMV == OFF) {
		ASSERT((pCurMB->BlkY1.PHMV >= -32 && pCurMB->BlkY1.PHMV <= 31));
		ASSERT((pCurMB->BlkY1.PVMV >= -32 && pCurMB->BlkY1.PVMV <= 31));
	} else {
		if (HMV <= -32) {
			ASSERT((pCurMB->BlkY1.PHMV >= -63 && pCurMB->BlkY1.PHMV <= 0));
		} else if (HMV <= 32) {
			ASSERT((hdelta >= -32 && hdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY1.PHMV >= 0 && pCurMB->BlkY1.PHMV <= 63));
		}
		if (VMV <= -32) {
			ASSERT((pCurMB->BlkY1.PVMV >= -63 && pCurMB->BlkY1.PVMV <= 0));
		} else if (VMV <= 32) {
			ASSERT((vdelta >= -32 && vdelta <= 31));
		} else {
			ASSERT((pCurMB->BlkY1.PVMV >= 0 && pCurMB->BlkY1.PVMV <= 63));
		}
	}
#endif

    // Adjust the deltas to be in the range of -32...+31
    
	if (EC->PictureHeader.UMV == ON)
	{
		if (HMV < -31 && hdelta < -63) 
			hdelta += 64;
		else if (HMV > 32 && hdelta > 63) 
			hdelta -= 64;

		if (VMV < -31 && vdelta < -63) 
			vdelta += 64;
		else if (VMV > 32 && vdelta > 63) 
			vdelta -= 64;
	}

	if(hdelta > 31)
        hdelta -= 64;
    if(hdelta < -32)
        hdelta += 64;
    
    if(vdelta > 31)
        vdelta -= 64;
    if(vdelta < -32)
        vdelta += 64;

	DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 1)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY1.PHMV, pCurMB->BlkY1.PVMV));
    
    // Write horizontal motion vector delta
    index = (hdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    // Write vertical motion vector delta
    index = (vdelta + 32)*2;
    PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);


	/*
	 * Deal with 4 MV case.
	 */
	if(pCurMB->MBType == INTER4V)
	{

		/*--------------
		 * Block 2.
		 *--------------*/
    	hdelta = pCurMB->BlkY2.PHMV - BHMV;
    	vdelta = pCurMB->BlkY2.PVMV - BVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY2.PHMV >= -32 && pCurMB->BlkY2.PHMV <= 31));
			ASSERT((pCurMB->BlkY2.PVMV >= -32 && pCurMB->BlkY2.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY2.PHMV >= -63 && pCurMB->BlkY2.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PHMV >= 0 && pCurMB->BlkY2.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY2.PVMV >= -63 && pCurMB->BlkY2.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY2.PVMV >= 0 && pCurMB->BlkY2.PVMV <= 63));
			}
		}
#endif
		
    	// Adjust the deltas to be in the range of -32...+31
		if (EC->PictureHeader.UMV == ON)
		{
			if (BHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (BHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (BVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (BVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}


    	if(hdelta > 31)
        	hdelta -= 64;
    	if(hdelta < -32)
	        hdelta += 64;
    
    	if(vdelta > 31)
        	vdelta -= 64;
    	if(vdelta < -32)
        	vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 2)MB#=%d - MV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY2.PHMV, pCurMB->BlkY2.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);


		/*----------------
		 * Block 3
		 *---------------*/
    	hdelta = pCurMB->BlkY3.PHMV - CHMV;
    	vdelta = pCurMB->BlkY3.PVMV - CVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY3.PHMV >= -32 && pCurMB->BlkY3.PHMV <= 31));
			ASSERT((pCurMB->BlkY3.PVMV >= -32 && pCurMB->BlkY3.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY3.PHMV >= -63 && pCurMB->BlkY3.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PHMV >= 0 && pCurMB->BlkY3.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY3.PVMV >= -63 && pCurMB->BlkY3.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY3.PVMV >= 0 && pCurMB->BlkY3.PVMV <= 63));
			}
		}
#endif
		
    	// Adjust the deltas to be in the range of -32...+31

		if (EC->PictureHeader.UMV == ON)
		{
			if (CHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (CHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (CVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (CVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}

    	if(hdelta > 31)
        	hdelta -= 64;
    	if(hdelta < -32)
        	hdelta += 64;
    
    	if(vdelta > 31)
        	vdelta -= 64;
    	if(vdelta < -32)
        	vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 3)MB#=%d\nMV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY3.PHMV, pCurMB->BlkY3.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);


		/*-----------------
		 * Block 4
		 *-------------------*/
    	hdelta = pCurMB->BlkY4.PHMV - DHMV;
    	vdelta = pCurMB->BlkY4.PVMV - DVMV;
    
#ifdef DEBUG
		if (EC->PictureHeader.UMV == OFF) {
			ASSERT((pCurMB->BlkY4.PHMV >= -32 && pCurMB->BlkY4.PHMV <= 31));
			ASSERT((pCurMB->BlkY4.PVMV >= -32 && pCurMB->BlkY4.PVMV <= 31));
		} else {
			if (HMV <= -32) {
				ASSERT((pCurMB->BlkY4.PHMV >= -63 && pCurMB->BlkY4.PHMV <= 0));
			} else if (HMV <= 32) {
				ASSERT((hdelta >= -32 && hdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PHMV >= 0 && pCurMB->BlkY4.PHMV <= 63));
			}
			if (VMV <= -32) {
				ASSERT((pCurMB->BlkY4.PVMV >= -63 && pCurMB->BlkY4.PVMV <= 0));
			} else if (VMV <= 32) {
				ASSERT((vdelta >= -32 && vdelta <= 31));
			} else {
				ASSERT((pCurMB->BlkY4.PVMV >= 0 && pCurMB->BlkY4.PVMV <= 63));
			}
		}
#endif
		
    	// Adjust the deltas to be in the range of -32...+31
		if (EC->PictureHeader.UMV == ON)
		{
			if (DHMV < -31 && hdelta < -63) 
				hdelta += 64;
			else if (DHMV > 32 && hdelta > 63) 
				hdelta -= 64;

			if (DVMV < -31 && vdelta < -63) 
				vdelta += 64;
			else if (DVMV > 32 && vdelta > 63) 
				vdelta -= 64;
		}

    	if(hdelta > 31)
        	hdelta -= 64;
    	if(hdelta < -32)
        	hdelta += 64;
    
    	if(vdelta > 31)
        	vdelta -= 64;
    	if(vdelta < -32)
        	vdelta += 64;
    
		DEBUGMSG(ZONE_ENCODE_MV, ("%s: (PB Block 4)MB#=%d\nMV Delta: (%d, %d) Motion Vectors: (%d, %d)\r\n", _fx_, curMB, hdelta, vdelta, pCurMB->BlkY4.PHMV, pCurMB->BlkY4.PVMV));
    
    	// Write horizontal motion vector delta here.
    	index = (hdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);
    
    	// Write horizontal motion vector delta here.
    	index = (vdelta + 32)*2;
    	PutBits( *(vlc_mvd+index+1), *(vlc_mvd+index), pPB_BitStream, pPB_BitOffset);

	} // end of if INTER4V


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3pcolor.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#ifndef _H263P_E3PCOLOR_H_
#define  _H263P_E3PCOLOR_H_ 

// Defines for the input color convertors
#ifdef USE_BILINEAR_MSH26X
#define RGB24toYUV12     1
#define RGB16555toYUV12  2
#define CLUT8toYUV12     3
#define CLUT4toYUV12     4
#define YVU9toYUV12      5
#define YUY2toYUV12      6
#define UYVYtoYUV12      7
#define YUV12toEncYUV12  8
#else
#define RGB32toYUV12     1
#define RGB24toYUV12     2
#define RGB16555toYUV12  3
#define CLUT8toYUV12     4
#define CLUT4toYUV12     5
#define YVU9toYUV12      6
#define YUY2toYUV12      7
#define UYVYtoYUV12      8
#define YUV12toEncYUV12  9
#endif

#define COEF_WIDTH   8
#define SHIFT_WIDTH  COEF_WIDTH

#define C_RGB_COLOR_CONVERT_INIT													\
	U32 *pnext;																		\
	U32 *pyprev, *pyspace, *pynext;													\
	U32 *puvprev, *puvspace;														\
	U8	t8u, t8v;																	\
	U32 tm;																			\
	int t;																			\
	int i, j, k;																	\
	int BackTwoLines;																\
	int widthx16;																	\
	int heightx16;																	\
	int width_diff = 0;																\
	int height_diff = 0;															\
	int width_adj = 0;																\
	int height_adj = 0;																\
	int stretch = 0;																\
	int aspect = 0;																	\
	int word_ypitch_adj = 0;														\
	int word_uvpitch_adj = 0;														\
	int LumaIters = 1;																\
	int mark = OutputHeight;														\
	int byte_ypitch_adj = pitch - OutputWidth;										\
	int byte_uvpitch_adj = pitch - (OutputWidth >> 1);								\
	if (lpbiInput->biHeight > OutputHeight) {										\
		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) {						\
			LumaIters += 4;															\
		}																			\
		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1;						\
		width_adj *= lpbiInput->biBitCount;											\
		width_adj >>= 3;															\
		aspect = LumaIters;															\
		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1;			\
		stretch = 1;																\
		mark = 11;																	\
	} else {																		\
		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF;								\
		width_diff = widthx16 - OutputWidth;										\
		byte_ypitch_adj -= width_diff;												\
		word_ypitch_adj = byte_ypitch_adj >> 2;										\
		byte_uvpitch_adj -= (width_diff >> 1);										\
		word_uvpitch_adj = byte_uvpitch_adj >> 2;									\
		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF;								\
		height_diff = heightx16 - OutputHeight;										\
	}																				\
	BackTwoLines = -((lpbiInput->biWidth + OutputWidth) >> 2);						\
	BackTwoLines *= lpbiInput->biBitCount;											\
	BackTwoLines >>= 3;																\
	pnext =	(U32 *)(lpInput +														\
				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3) *				\
					((OutputHeight - aspect - 1) + height_adj)) +					\
				width_adj);

#define C_WIDTH_FILL																\
	if (width_diff) {																\
		tm = (*(YPlane-1)) << 24;													\
		tm |= (tm>>8) | (tm>>16) | (tm>>24);										\
		*(U32 *)YPlane = tm;														\
		if ((width_diff-4) > 0) {													\
			*(U32 *)(YPlane + 4) = tm;												\
		}																			\
		if ((width_diff-8) > 0) {													\
			*(U32 *)(YPlane + 8) = tm;												\
		}																			\
		YPlane += width_diff;														\
		if (0 == (k&1)) {															\
			t8u = *(UPlane-1);														\
			t8v = *(VPlane-1);														\
			*UPlane++ = t8u;														\
			*UPlane++ = t8u;														\
			*VPlane++ = t8v;														\
			*VPlane++ = t8v;														\
			if ((width_diff-4) > 0) {												\
				*UPlane++ = t8u;													\
				*UPlane++ = t8u;													\
				*VPlane++ = t8v;													\
				*VPlane++ = t8v;													\
			}																		\
			if ((width_diff-8) > 0) {												\
				*UPlane++ = t8u;													\
				*UPlane++ = t8u;													\
				*VPlane++ = t8v;													\
				*VPlane++ = t8v;													\
			}																		\
		}																			\
	}

#define C_HEIGHT_FILL																\
	if (height_diff) {																\
		pyprev =  (U32 *)(YPlane - pitch);											\
		pyspace = (U32 *)YPlane;													\
		for (j = height_diff; j > 0; j--) {											\
			for (i = widthx16; i>0; i -=4) {										\
				*pyspace++ = *pyprev++;												\
			}																		\
			pyspace += word_ypitch_adj;												\
			pyprev  += word_ypitch_adj;												\
		}																			\
		puvprev =  (U32 *)(UPlane - pitch);											\
		puvspace = (U32 *)UPlane;													\
		for (j = height_diff; j > 0; j -= 2) {										\
			for (i = widthx16; i>0; i -= 8) {										\
				*puvspace++ = *puvprev++;											\
			}																		\
			puvspace += word_uvpitch_adj;											\
			puvprev  += word_uvpitch_adj;											\
		}																			\
		puvprev =  (U32 *)(VPlane - pitch);											\
		puvspace = (U32 *)VPlane;													\
		for (j = height_diff; j > 0; j -= 2) {										\
			for (i = widthx16; i>0; i -= 8) {										\
				*puvspace++ = *puvprev++;											\
			}																		\
			puvspace += word_uvpitch_adj;											\
			puvprev  += word_uvpitch_adj;											\
		}																			\
	}

struct YUV {
  int YU;
  int V;
};

struct YUVQUAD {
	U8 Yval;
	U8 dummy;
	union {
		struct {
			U8 Uval;
			U8 Vval;
		};
		U16 UVval;
	};
};

extern struct YUV RYUV[];
extern struct YUV GYUV[];
extern struct YUV BYUV[];
extern struct YUVQUAD YUVPalette[];

extern void Compute_YUVPalette(LPBITMAPINFOHEADER lpbiInput);

#ifndef USE_BILINEAR_MSH26X
extern void C_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);
#endif

extern void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

extern void P5_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);

#endif // !_H263P_E3PCOLOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3enc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   19 Mar 1997 14:58:04  $
// $Archive:   S:\h26x\src\enc\e3enc.h_v  $
// $Header:   S:\h26x\src\enc\e3enc.h_v   1.87   19 Mar 1997 14:58:04   MDUDA  $
// $Log:   S:\h26x\src\enc\e3enc.h_v  $
;// 
;//    Rev 1.87   19 Mar 1997 14:58:04   MDUDA
;// Increased motion estimation stack space from 16k to 64k bytes.
;// 
;//    Rev 1.86   17 Mar 1997 20:19:50   MDUDA
;// Moved local storage to encoder catalog and allocated pseudo stack
;// space needed to work around problem with 16-bit apps that allocated
;// insufficient stack space.
;// 
;//    Rev 1.85   10 Feb 1997 11:43:28   JMCVEIGH
;// 
;// Support for new interpretation of blocking filter -
;// allow for motion vectors outside of the reference picture.
;// 
;//    Rev 1.84   07 Feb 1997 10:58:14   CZHU
;// Added three entry in EC to remove static variable used in e3rtp.cpp
;// 
;//    Rev 1.83   05 Feb 1997 12:19:18   JMCVEIGH
;// Pass GOBHeaderPresent parameter to MMxEDTQ() for EMV bug fix
;// support latest H.263+ draft bitstream spec, and support for 
;// separate improved PB-frame flag.
;// 
;//    Rev 1.82   30 Dec 1996 19:55:48   MDUDA
;// Added color convertor initializer prototype.
;// 
;//    Rev 1.81   19 Dec 1996 16:33:38   MDUDA
;// Modified call to colorCnvtFrame to support H263 backward compatibility.
;// 
;//    Rev 1.80   16 Dec 1996 17:49:48   JMCVEIGH
;// H263Plus flag.
;// 
;//    Rev 1.79   16 Dec 1996 13:35:30   MDUDA
;// 
;// Added ColorConvertor field to Encoder Catalog.
;// 
;//    Rev 1.78   11 Dec 1996 15:03:58   JMCVEIGH
;// 
;// Changed size of padding of encoder catalog to handle H.263+
;// options.
;// 
;//    Rev 1.77   10 Dec 1996 09:07:48   JMCVEIGH
;// Fixed bug in padding of T_H263EncoderCatalog to 512 bytes when
;// H263P not defined.
;// 
;//    Rev 1.76   09 Dec 1996 17:59:28   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
;// Normally, application will pass identical (arbitrary) frame
;// sizes in lParam1 and lParam2 of CompressBegin(). If 
;// cropping/stretching desired to convert to standard frame sizes,
;// application should pass the desired output size in lParam2 and
;// the input size in lParam1.
;// 
;//    Rev 1.75   09 Dec 1996 09:49:44   MDUDA
;// Modified for H263P.
;// 
;//    Rev 1.74   11 Nov 1996 09:12:28   JMCVEIGH
;// Added bPrevIntra. This is used to re-initialize the ME states
;// when the previous frame was intra coded and the current frame
;// is to be inter coded.
;// 
;//    Rev 1.73   06 Nov 1996 16:32:12   gmlim
;// Removed H263ModeC preprocessor definitions.
;// 
;//    Rev 1.72   05 Nov 1996 13:25:08   GMLIM
;// Added mode c support for mmx case.
;// 
;//    Rev 1.71   03 Nov 1996 19:01:26   gmlim
;// Parameters changed in PB_GOB_Q_RLE_VLC_WriteBS() for mode c.
;// 
;//    Rev 1.70   22 Oct 1996 14:51:52   KLILLEVO
;// Blocktype initialization in InitMEState() is  now only called if
;// the AP mode has changed from the previous picture.
;// 
;//    Rev 1.69   10 Oct 1996 16:43:02   BNICKERS
;// Initial debugging of Extended Motion Vectors.
;// 
;//    Rev 1.68   04 Oct 1996 08:47:56   BNICKERS
;// Add EMV.
;// 
;//    Rev 1.67   12 Sep 1996 10:56:12   BNICKERS
;// Add arguments for thresholds and differentials.
;// 
;//    Rev 1.66   06 Sep 1996 16:12:28   KLILLEVO
;// fixed the logical problem that the inter code count was always
;// incremented no matter whether coefficients were transmitted or not
;// 
;//    Rev 1.65   22 Aug 1996 11:31:24   KLILLEVO
;// changed PB switch to work the same for IA as for MMX
;// 
;//    Rev 1.64   19 Aug 1996 13:49:04   BNICKERS
;// Provide threshold and differential variables for spatial filtering.
;// 
;//    Rev 1.63   25 Jun 1996 14:24:50   BNICKERS
;// Implement heuristic motion estimation for MMX, AP mode.
;// 
;//    Rev 1.62   30 May 1996 15:09:08   BNICKERS
;// Fixed minor error in recent IA ME speed improvements.
;// 
;//    Rev 1.61   29 May 1996 15:38:02   BNICKERS
;// Acceleration of IA version of ME.
;// 
;//    Rev 1.60   14 May 1996 12:18:44   BNICKERS
;// Initial debugging of MMx B-Frame ME.
;// 
;//    Rev 1.59   03 May 1996 14:59:32   KLILLEVO
;// added one parameter to MMXEDTQ() : pointer to B-frame stream of
;// run,lengt,sign triplets
;// 
;//    Rev 1.58   03 May 1996 10:55:00   KLILLEVO
;// 
;// started integrating Brian's MMX PB-frames
;// 
;//    Rev 1.57   02 May 1996 12:01:02   BNICKERS
;// Initial integration of B Frame ME, MMX version.
;// 
;//    Rev 1.56   28 Apr 1996 19:56:52   BECHOLS
;// Enabled RTP header stuff in calls.
;// 
;//    Rev 1.55   26 Apr 1996 11:06:36   BECHOLS
;// Added rtp stuff... but still need to get rid of ifdef's
;// 
;//    Rev 1.54   26 Mar 1996 12:00:16   BNICKERS
;// Did some tuning for MMx encode.
;// 
;//    Rev 1.53   15 Mar 1996 15:57:32   BECHOLS
;// 
;// Added support for monolithic MMx code.
;// 
;//    Rev 1.52   12 Mar 1996 13:26:52   KLILLEVO
;// new rate control with adaptive bit usage profile
;// 
;//    Rev 1.51   27 Feb 1996 14:12:56   KLILLEVO
;// 
;// PB switch
;// 
;//    Rev 1.50   22 Feb 1996 18:48:50   BECHOLS
;// 
;// Added declarations for MMX functions.
;// 
;//    Rev 1.49   24 Jan 1996 13:21:26   BNICKERS
;// Implement OBMC
;// 
;//    Rev 1.48   22 Jan 1996 17:13:22   BNICKERS
;// Add MBEdgeType to MacroBlock Action Descriptor.
;// 
;//    Rev 1.47   22 Jan 1996 16:29:20   TRGARDOS
;// Started adding bit counting structures and code.
;// 
;//    Rev 1.46   03 Jan 1996 12:19:02   TRGARDOS
;// Added bUseINISettings member to EC structure.
;// 
;//    Rev 1.45   02 Jan 1996 17:07:54   TRGARDOS
;// Moved colorCnvtFrame into excolcnv.cpp and made 
;// color convertor functions static.
;// 
;//    Rev 1.44   27 Dec 1995 15:32:56   RMCKENZX
;// Added copyright notice
;//
;// Added uBitUsageProfile for BRC.
;// added a control to activate the chaned BRC
;// Hookup init from Registry instead of ini
;// Add a parameter to QRLE entry point - bRTPHeader flag
;// Add a variable to the encoder catalog to store the netx intra MB 
;// Added comments
;// integrate with build 29
//
////////////////////////////////////////////////////////////////////////////

#ifndef __H263E_H__
#define __H263E_H__

/*
 * This file declares structs which catalog the locations of various
 * tables, structures, and arrays needed by the H263 encoder.
*/

const U8 def263INTRA_QP = 16;  //  default QP values
const U8 def263INTER_QP = 16;

/*
 * Block description structure. Must be 16-byte aligned.
 * See e3mbad.inc for more detail on each structure entry.
 */
typedef struct {
    U32     BlkOffset;	// [0-3]  Offset to 8*8 target block from start of Y plane.
    union {
	   /*
		* Adress of reference block for P frame motion estimation.
		*/
        U8 	*PastRef;	// [4-7]  Address of 8*8 reference block.
	   /*
		* MVf and MVb vectors for B-frame motion estimation as defined in
		* H.263 spec. The reference block addresses are generated for
		* frame differencing. The numbers are biased by 60H.
		*/
        struct {
            U8 HMVf;
            U8 VMVf;
            U8 HMVb;
            U8 VMVb;
        }	CandidateMV;
    } B4_7;
    struct {		// Scratch variables used by ME.
        U8 HMVf;
        U8 VMVf;
        U8 HMVb;
        U8 VMVb;
    } BestMV;
	char PHMV;		// [12]   Horizontal motion vector for P block..
	char PVMV;		// [13]   Vertical motion vector for P block..
	char BHMV;		// [14]   Horizontal motion vector (delta?) for B block..
	char BVMV;		// [15]   Vertical motion vector (delta?) for B block..
} T_Blk;
const int sizeof_T_Blk = 16;

/*
 * T_MBlockActionStream - Structure to keep side information for a MB
 * used by encoder. This structure must be 16-byte aligned when allocated.
 * CodedBlocks must be DWORD aligned. The entire structure must be a multiple 
 * of 16 bytes, and must match the size of the structure in e3mbad.inc.
 */

#define SIZEOF_PSEUDOSTACKSPACE   (1024 * 64)

typedef struct {
	U8	BlockType;		// 0   -- See block types below.
        U8      MBEdgeType;     // 1   -- 1 off if left edge | 2 right | 4 top | 8 bottom.
	U8	Unassigned1;   	// 2   --
	U8	FirstMEState;	// 3   -- First State Num for Motion Estimation engine.
	U8	CodedBlocks;	// 4   -- [6] End-of-Stream indicator
						//        [0] indicates Y1 non-empty
						//        [1...5] indicates Y2, Y3, Y4, U, V nonempty.
						//        Other bits zero.
	U8	CodedBlocksB;	// 5   -- [0...5] like CodedBlocks, but for B frame.
						//        Set to 0 for non bi-di prediction.
	U8	Unassigned2[2]; // 6...7
	U32	SWD;			// 8...11  Sum of weighted diffs, from motion estimation.
	U32	SWDB;			// 12...15 Sum of weighted diffs, from B frame motion estimation.
	T_Blk	BlkY1;		// 16...31
	T_Blk	BlkY2;		// 32...47
	T_Blk	BlkY3;		// 48...63
	T_Blk	BlkY4;		// 64...79
	T_Blk	BlkU;		// 80...95
	T_Blk	BlkV;		// 96...111

	U8	COD;			// 112 -- Coded macroblock indication. When set to "0"
	  					//        indicates that macroblock is coded. If set to
						//        "1", it indicates that the macroblock is not coded
						//         and the rest of the macroblock layer is empty.
	U8	MBType;			// 113 -- Macro block type, {INTER, INTER+Q, INTER4V, INTRA, INTRA+Q}
	U8	CBPC;			// 114 -- Coded block pattern for chrominance.
	U8	MODB;			// 115 -- Macroblock mode for B-blocks.
	U8	CBPB;			// 116 -- Coded block pattern for B blocks.
	U8	CBPY;			// 117 -- Coded block pattern for luminance.
	U8	DQUANT;			// 118 -- Quantizer information. A two bit pattern to define
	   					//        change in QUANT.
	U8	InterCodeCnt;	// 119 -- Count number of times current MB has been intercoded.
	U8	Unassigned4[8];// 120...127 -- Pad out to a power of two.
} T_MBlockActionStream;
const int sizeof_T_MBlockActionStream = 128;

/*
 * Block Types
 */
const U8 INTERBLOCK = 0;
const U8 INTRABLOCK = 1;
const U8 INTERBIDI  = 2;
const U8 INTRABIDI  = 3;
const U8 INTER4MV	= 4;

const U8 IsINTRA    = 1;		// Mask to check for INTRA or ITNRABIDI.
const U8 IsBIDI     = 2; 	// Mask to check for INTRABIDI or INTERBIDI.

/*
 * MB Types
 */
const U8 INTER	= 0;
const U8 INTERQ	= 1;
const U8 INTER4V= 2;
const U8 INTRA	= 3;
const U8 INTRAQ	= 4;

/*
 * MB Edge Types
 */

const U8 MBEdgeTypeIsLeftEdge   = 0xE;
const U8 MBEdgeTypeIsRightEdge  = 0xD;
const U8 MBEdgeTypeIsTopEdge    = 0xB;
const U8 MBEdgeTypeIsBottomEdge = 0x7;

/*
 * First ME state for ME engine
 */
const U8 ForceIntra	= 0;
const U8 UpperLeft	= 1;
const U8 UpperEdge	= 2;
const U8 UpperRight	= 3;
const U8 LeftEdge	= 4;
const U8 CentralBlock = 5;
const U8 RightEdge	= 6;
const U8 LowerLeft	= 7;
const U8 LowerEdge	= 8;
const U8 LowerRight	= 9;
const U8 NoVertLeftEdge	= 10;
const U8 NoVertCentralBlock = 11;
const U8 NoVertRightEdge = 12;

/*
 * Coded block bit masks.
 */
const U8 Y1BLOCK = 0x01;
const U8 Y2BLOCK = 0x02;
const U8 Y3BLOCK = 0x04;
const U8 Y4BLOCK = 0x08;
const U8 UBLOCK  = 0x10;
const U8 VBLOCK  = 0x20;

const I32 GOBs_IN_CIF = 18;
const I32 MBs_PER_GOB_CIF = 22;

typedef struct {
    U8 StateNumInc_SelectCentralPt;
    U8 MVIncIdx_SelectCentralPt;
    U8 StateNumInc_SelectRef1;
    U8 MVIncIdx_SelectRef1;
    U8 StateNumInc_SelectRef2;
    U8 MVIncIdx_SelectRef2;
    U16 pad;
} T_SADState;


/* 
 * Structure to store bit counts.
 */
typedef struct {
	U32	PictureHeader;	// 0	All of picture header.
	U32	GOBHeader;		// 4	All of GOB Header.
	U32	MBHeader;		// 8	All of MB header.
	U32	DQUANT;			// 12	Bits spent on DQUANT.
	U32	MV;				// 16	Bits spent on MV's.
	U32	Coefs;			// 20	Total bits spent on coefs.
	U32	Coefs_Y;		// 24	Total bits spent on Y coefs.
	U32	IntraDC_Y;		// 28	Bits spent on IntraDC coefs for Y.
	U32	Coefs_C;		// 32	Total bits spent on Chroma Coefs
	U32	IntraDC_C;		// 36	Bits spent on IntraDC coefs for C.
	U32	CBPY;			// 40	Bits spent on CBPY
	U32	MCBPC;			// 44	Bits spent on MCBPC
	U32	Coded;			// 48	Number of coded blocks.
	U32	num_intra;		// 52	Number of intra coded blocks.
	U32	num_inter;		// 56	Number of Inter coded blocks.
	U32	num_inter4v;	// 60	Number of Inter4V coded blocks.
} T_BitCounts;

typedef struct {
    U32  MBStartBitOff;             //  Start of MB Data
    U8   CBPYBitOff;                //  from start of MB data
    U8   MVDBitOff;
    U8   BlkDataBitOff;             //  from start of MB data
} T_FutrPMBData;

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
/* Encoder Timing Data - per frame
*/
typedef struct {
	U32 uEncodeFrame;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	U32 uInputCC;
	U32 uMotionEstimation;
	U32 uFDCT;
	U32 uQRLE;
	U32 uDecodeFrame;
	U32 uZeroingBuffer;
#endif // } DETAILED_ENCODE_TIMINGS_ON
} ENC_TIMING_INFO;
#define ENC_TIMING_INFO_FRAME_COUNT 105
#endif // } LOG_ENCODE_TIMINGS_ON

/*
 * T_H263EncoderCatalog - Catalog of information needed for an instance.
 * This structure must be multiple of 16.
 */
typedef struct {
    U8        *pU8_CurrFrm;             // 0
    U8        *pU8_CurrFrm_YPlane;	    // 4 Pointers to current frame buffers.
    U8        *pU8_CurrFrm_VPlane;	    // 8
    U8        *pU8_CurrFrm_UPlane;      // 12

    U8        *pU8_PrevFrm;             // 16
    U8        *pU8_PrevFrm_YPlane; 	    // 20 Pointers to previous frame buffers
    U8        *pU8_PrevFrm_VPlane;      // 24
    U8        *pU8_PrevFrm_UPlane;	    // 28

    U8        *pU8_FutrFrm;             // 32
    U8        *pU8_FutrFrm_YPlane; 	    // 36 Pointers to previous frame buffers
    U8        *pU8_FutrFrm_VPlane;      // 40
    U8        *pU8_FutrFrm_UPlane;	    // 44

    U8        *pU8_BidiFrm;             // 48
    U8        *pU8_BFrm_YPlane;		    // 52 Pointers to B frame buffers.
    U8        *pU8_BFrm_UPlane;		    // 56
    U8        *pU8_BFrm_VPlane;		    // 60

    T_MBlockActionStream *pU8_MBlockActionStream; // 64 Pointer to macro block action stream.

    I32       *pU8_DCTCoefBuf;		    // 68 Pointer to GOB DCT coefficient buffer.
    
    U8        *pU8_BitStream;		    // 72 Pointer to bitstream buffer.
    U8        *pU8_BitStrCopy;          // 76 Pointer to bitstream buffer
                                        //    for the PB-frame

    T_H263FrameHeaderStruct PictureHeader;// 80..127 (48 bytes)    // Picture layer header structure.

    UN        FrameHeight;	            // 128
    UN        FrameWidth;	            // 132
    FrameSize FrameSz;		            // 136 -- Define frame size: SQCIF, QCIF, CIF
    UN        NumMBRows;                // 140 -- Number of rows of MB's
    UN        NumMBPerRow;              // 144 -- Number of MB's in a row.
    UN        NumMBs;		            // 148 -- Total number of MBs.

    U8        *pU8_RGB24Image;	        // 152
    U8        *pU8_MBlockCodeBookStream;// 156
    U8        *pU8_BlockCodeBookStream; // 160
    U8        *pU8_BlockOfInterCoeffs;  // 164
    U8        *pU8_BlockOfIntraCoeffs;  // 168
    U32       AvgIntraSAD;              // 172 Average SAD for Intra macroblocks.
    LPDECINST pDecInstanceInfo;         // 176 Private decoder instance info.

    BRCStateStruct BRCState;            // 180 State variables for bitrate control (32 bytes)

    U8        u8EncodePBFrame;          // 212 Should encoder encode PB frames
    U8        u8SavedBFrame;            // 213 Do we have a B-Frame saved for
                                        //     encoding PB-frame
    U8        bMakeNextFrameKey;        // 214
    U8        bUseINISettings;			    // 215
    U32		  GOBHeaderPresent;	        // 216...220 Flag which GOB headers are present.
    U32       LastSWDBeforeForcedP;			// 220...224 The last SWD before B frames were turned off
    T_BitCounts Bits;					          // 224 .. 288
    U8        *pU8_PredictionScratchArea; // 288...292 Pointer to area for pre-computing predictions.
	U8        prevAP;                   // 292 AP mode for previous picture
	U8        prevUMV;                  // 293 UMV mode for previous picture (not used)
	U8        bPrevFrameIntra;          // 294 Flag whether previous frame was intra coded (used to set the ME states)
    U8        Unassigned0[1];           // 295...295  available 
    U32       uBitUsageProfile[19];     // 296...372 Table for storing bit usage profile
                                        // 19 is large enough for CIF
                                        // element 0...NumGOBs-1 stores cumulative bit usage
                                        // element NumGOBs stores the final frame size
    I8        *pI8_MBRVS_Luma;          // 372..376 Pointer to area for Luma Run Value Sign Triplets.
    I8        *pI8_MBRVS_Chroma;        // 376..380 Pointer to area for Chroma Run Value Sign Triplets.

    HANDLE    hBsInfoStream;            // 380..384 memory handle for blocks allocate for extended portion of bs
    void *    pBsInfoStream;            // 384..388 point to next BITSTREAM_INFO struct for next packet
    U32       uBase;                    // 388..392 byte offset of at the beginning of this packet from start
                                        // 392..396 of the whole bitstream;
    U32       uPacketSizeThreshold;     // 396..400 the packet size used by the codec
    void *    pBaseBsInfoStream;        // 400..404 start of bitstream extension
    U32       uNumOfPackets;            // 404..408
    U32       uNextIntraMB;             // 408..412 Used to implement rolling intra MBs
    U32       uNumberForcedIntraMBs;    // 412..416 Number of forced intras in each frame
    I8        *pI8_MBRVS_BLuma;         // 416..420 Pointer to area for Luma Run Value Sign Triplets for the B-frame (MMX)
    I8        *pI8_MBRVS_BChroma;       // 420..424 Pointer to area for Chroma Run Value Sign Triplets for the B-frame (MMX)

    U8        *pU8_Signature;           // 424
    U8        *pU8_Signature_YPlane;    // 428 Pointers to signature buffers

#ifdef USE_BILINEAR_MSH26X
	U32		  uActualFrameWidth;		// 460+40 Actual (non-padded) frame width
	U32		  uActualFrameHeight;		// 464+40 Actual (non-padded) frame height
	U32       ColorConvertor;           // 468+40 Input color convertor.
#endif

#ifdef H263P
	//NEWCHANGES
	U32       uBitOffset_currPacket;	// 432+40 bit offset for current packet
    U8        *pBitStream_currPacket;	// 436+40 pointer to current bitstream, last MB
    U8        *pBitStream_lastPacket;	// 440+40 pointer to bitstream at last packet
	U8        *pPseudoStackSpace;		// 444+40 pointer to buffer for motion estimation
	T_FutrPMBData *pFutrPMBData;		// 448+40 pointer to buffer previously on local stack in 
    I8        *pWeightForwMotion;		// 452+40 values based on TRb and TRd
    I8        *pWeightBackMotion;		// 456+40 values based on TRb and TRd
	U32		  uActualFrameWidth;		// 460+40 Actual (non-padded) frame width
	U32		  uActualFrameHeight;		// 464+40 Actual (non-padded) frame height
	U32       ColorConvertor;           // 468+40 Input color convertor.
	U8		  bH263Plus;				// 469+40 Flag for using H.263+
	U8        prevDF;                   // 470+40 Deblocking filter mode for previous picture
    
	// sizeof_T_H263FrameHeaderStruct = 88
    U8        Unassigned2[2];          // Pad size to 512 bytes.
#else
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO *pEncTimingInfo;	// 432
	U32 uStatFrameCount;				// 436
	int bTimingThisFrame;				// 440
	U32 uStartLow;						// 444
	U32 uStartHigh;						// 448
#ifdef USE_BILINEAR_MSH26X
    U8        Unassigned2[62];          // Pad size to 512 bytes.
#else
    U8        Unassigned2[64];          // Pad size to 512 bytes.
#endif
#else // }{ LOG_ENCODE_TIMINGS_ON
#ifdef USE_BILINEAR_MSH26X
    U8        Unassigned2[72];          // Pad size to 512 bytes.
#else
    U8        Unassigned2[84];          // Pad size to 512 bytes.
#endif
#endif // } LOG_ENCODE_TIMINGS_ON
#endif
    
} T_H263EncoderCatalog;
const int sizeof_T_H263EncoderCatalog = 512;

/*
 * T_H263EncoderInstanceMemory
 *     Memory layout for encoder instance. The memory is allocated 
 * dynamically and the beginning of this structure is aligned to a 
 * 32 byte boundary.
 * All arrays should be start on a DWORD boundary.
 * MBActionStream should start on a 16 byte boundary.
 */

// Define bit stream buffer size.
const unsigned int sizeof_bitstreambuf = 352*288*3/4;

// This structure is allocated on a N-byte boundary, where N is the size of
// a MacroBlock Action Descriptor, which must be a power of two.
typedef struct {
	T_H263EncoderCatalog EC;
        U8      UnAssigned0[2560]; // so that MMX ME (EMV case) can read outside
                                   // of legal address range of MBActionStream.
	T_MBlockActionStream MBActionStream[22*18+3];
	U8	UnAssigned1[16]; 
	U8	u8CurrentPlane [ (288+16+8+144)*384 + 8 ];
	U8	u8Pad1[ 72 ];
	U8	u8PreviousPlane[ (16+288+16+8+144+8)*384 + 64]; //  reconstructed past
    U8  u8FuturePlane  [ (16+288+16+8+144+8)*384 +  0]; //  reconstructed future
	U8	u8BPlane       [ (288+16+8+144)*384 + 8 ];      //  like current plane
	U8      u8Pad2[1928];
	U8      u8Signature[(16+288+16)*384 + 24];
	U8	u8Scratch1[4096];
	U8	u8BitStream [ sizeof_bitstreambuf ];
    U8  u8BitStrCopy[ sizeof_bitstreambuf ];
	/*
	 * Allocate space for DCT coefficients for an entire GOB.
	 * Each block of coefficients is stored in 32 DWORDS (2 coefs/DWORD)
	 * and there can be up to 6 blocks in a macroblock (P frame),
	 * and up to 22 macroblocks in a GOB (CIF size).
	 */
	U32         UnAssigned2[6];				// insert 6 DWORDS to put DCT on 32 byte boundary.
	I32	        piGOB_DCTCoefs[32*6*22];	// For best performance align to 32 byte boundary
   /*
    * Allocate scratch space for storage of prediction blocks.  We need
    * enough space for a whole GOB, luma only.  This is used for the
    * calculation of OBMC predictions only.
    */
	U8          u8PredictionScratchArea[16*384];
	// The following arrays are needed for MMX
	I8 i8MBRVS_Luma[65 * 3 * 22 * 4];
	I8 i8MBRVS_Chroma[65 * 3 * 22 * 2];
	DECINSTINFO	DecInstanceInfo;	        // Private decoder instance.

#if defined(H263P)
	U8 u8PseudoStackSpace[SIZEOF_PSEUDOSTACKSPACE];
    T_FutrPMBData FutrPMBData[GOBs_IN_CIF*MBs_PER_GOB_CIF + 1];
    I8  WeightForwMotion[128];  //  values based on TRb and TRd
    I8  WeightBackMotion[128];  //  values based on TRb and TRd
#endif

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO	EncTimingInfo[ENC_TIMING_INFO_FRAME_COUNT];
#endif // { LOG_ENCODE_TIMINGS_ON

}	T_H263EncoderInstanceMemory;

// Define offsets from Y to U planes, and U to V planes.
const int YU_OFFSET = (288+16+8)*384;
const int UV_OFFSET = 192;
const int CurPrev_OFFSET = 181328;	// Offset from current to previous frame buffer.

/****************************************************************
 * Function prototypes
 ****************************************************************/
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
void colorCnvtFrame (
    U32                  ColorConvertor,
    LPCODINST            lpCompInst,
    ICCOMPRESS           *lpicComp,
    U8                   *YPlane,
    U8                   *UPlane,
    U8                   *VPlane
);
void colorCnvtInitialize(LPBITMAPINFOHEADER	lpbiInput, int InputColorConvertor);
#else
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
);
#endif

void PutBits(
	unsigned int fieldval, // Value of field to write to stream.
	unsigned int fieldlen, // Length of field to be written
	unsigned char **pbs, 				// Pointer to current byte in bitstream
	unsigned char *bitoffset	// bit offset in current byte of bitstream.
);

extern "C" void FORWARDDCT (T_MBlockActionStream * MBlockActionStream,
    U8 *  TargetFrameBaseAddr,
    U8 *  PreviousFrameBaseAddr,
    U8 *  FutureFrameBaseAddr,
    I32 * CoeffStream,
    int   IsBFrame,
    int   IsAdvancedPrediction,
    int   IsPOfPBPair,
    U8 *  ScratchBlocks,
    int   NumberOfMBlksInGOB
);

extern "C" void MOTIONESTIMATION (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * FilteredFrameBaseAddr,
    int   DoRadius15Search,
    int   DoHalfPelEstimation,
    int   DoBlockLevelVectors,
#if defined(H263P)
	U8  * pPseudoStackSpace,
#endif
    int   DoSpatialFiltering,
    int   ZeroVectorThreshold,
    int   NonZeroMVDifferential,
    int   BlockMVDifferential,
    int   EmptyThreshold,
    int   InterCodingThreshold,
    int   IntraCodingDifferential,
    int   SpatialFilteringThreshold,
    int   SpatialFilteringDifferential,
    U32 * IntraSWDTotal,
    U32 * IntraSWDBlocks,
    U32 * InterSWDTotal,
    U32 * InterSWDBlocks
);

#ifdef USE_MMX // { USE_MMX
extern "C" void MMxMESignaturePrep (U8 * PreviousFrameBaseAddr,
    U8  * SignatureBaseAddr,
    int FrameWidth,
    int FrameHeight
);

extern "C" void MMxEDTQ (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * BTargetFrameBaseAddr,
    U8  * SignatureBaseAddr,
    I8  * WeightForWardMotion,
    I8  * WeightBackwardMotion,
    int   FrameWidth,
    int   DoHalfPelEstimation,
    int   DoBlockLevelVectors,
#if defined(H263P)
	U8  * pPseudoStackSpace,
#endif
    int   DoSpatialFiltering,
    int   DoAdvancedPrediction,
    int   DoBFrame,
#if defined(H263P)
	int   DoDeblockingFilter,				// Only H.263+ should use this
	int   DoImprovedPBFrames,				// Only H.263+ should use this
#endif
    int   DoLumaBlocksInThisPass,
    int   DoExtendedMotionVectors,
#if defined(H263P)
	int   GOBHeaderPresent,
#endif
    int   QuantizationLevel,
    int   BQuantizationLevel,
    int   BFrmZeroVectorThreshold,
    int   SpatialFiltThreshold,
    int   SpatialFiltDifferential,
    U32 * SWDTotal,
    U32 * BSWDTotal,
    I8  * CodeStreamCursor,
    I8  * CodeBStreamCursor
);
#endif // } USE_MMX

extern "C" void BFRAMEMOTIONESTIMATION (
    T_MBlockActionStream * MBlockActionStream,
    U8  * TargetFrameBaseAddr,
    U8  * PreviousFrameBaseAddr,
    U8  * FutureFrameBaseAddr,
    I8  * WeightForWardMotion,
    I8  * WeightBackwardMotion,
    U32   ZeroVectorThreshold,
#if defined(H263P)
	U8  * pPseudoStackSpace,
#endif
    U32   NonZeroMVDifferential,
    U32   EmptyBlockThreshold,
    U32  * InterSWDTotal,
    U32  * InterSWDBlocks
);
    
extern "C" I8 * QUANTRLE(
    I32  *CoeffStr, 
    I8   *CodeStr, 
    I32   QP, 
    I32   BlockType
);

extern "C" void MBEncodeVLC(
    I8 **,
    I8 **,
    U32 , 
    U8 **, 
    U8 *, 
    I32,
    I32
);

/*
 * Routine to quantize, rle, vlc and write to bitstream
 * for an entire GOB.
 */
void GOB_Q_RLE_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I32                  *DCTCoefs,
	U8                  **pBitStream,
	U8                   *pBitOffset,
   T_FutrPMBData        *FutrPMBData,
	U32                   GOB,
	U32                   QP,
	BOOL                  bRTPHeader,
	U32                   StartingMB
);

void GOB_VLC_WriteBS(
	T_H263EncoderCatalog *EC,
	I8                   *pMBRVS_Luma,
	I8                   *pMBRVS_Chroma,
	U8                  **pBitStream,
	U8                   *pBitOffset,
	T_FutrPMBData        *FutrPMBData,  //  Start of GOB
	U32                  GOB,
	U32                   QP,
	BOOL                  bRTPHeader,
	U32                  StartingMB
);

void PB_GOB_Q_RLE_VLC_WriteBS(
    T_H263EncoderCatalog       * EC,
	I32                        * DCTCoefs,
    U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
    const T_FutrPMBData  * const FutrPMBData,
	const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
);

void PB_GOB_VLC_WriteBS(
	T_H263EncoderCatalog       * EC,
    I8                         * pMBRVS_Luma,
    I8                         * pMBRVS_Chroma,
    U8                         * pP_BitStreamStart,
	U8                        ** pPB_BitStream,
	U8                         * pPB_BitOffset,
    const T_FutrPMBData  * const FutrPMBData,
    const U32                    GOB,
    const U32                    QP,
    BOOL                         bRTPHeader
);

void CopyBits(
    U8       **pDestBS,
    U8        *pDestBSOffset,
    const U8  *pSrcBS,
    const U32  uSrcBitOffset,
    const U32  uBits
);
    
void InitVLC(void);


#ifdef DEBUG_ENC
void trace(char *str);
#endif

#ifdef DEBUG_DCT
void cnvt_fdct_output(unsigned short *DCTcoeff, int DCTarray[64], int BlockType);
#endif

struct T_MAXLEVEL_PTABLE {
	int	maxlevel;
	int * ptable;
};

//extern "C" { UN FAR ASM_CALLTYPE H263EOffset_DecoderInstInfo(); }

#endif		// #ifndef _H263E_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3pcolor.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*

CCIR 601 Specifies a conversion from RGB to YCrCb. For
what we call U and V, they are equivalent as 
U = Cb, V = Cr.

From CCIR 601-2 Annex II, we can go from RGB with values
in the range of 0-255, to YUV values in the same range
by the equation:

Y = (    77*R + 150*G +  29*B ) >> 8;
V = (   131*R - 110*G -  21*B ) >> 8 + 128; 	// Cr
U = ( (-44)*R -  87*G + 131*B ) >> 8 + 128;		// Cb

Has now changed to the inverse of the YUV->RGB on the
output, since the old version produced way too many bits.
The new version is:

Y = (   16836*R +  33056*G +  6416*B ) >> 16 + 16;
V = (   28777*R -  24117*G -  4660*B ) >> 16 + 128; 	// Cr
U = ( (-9726)*R -  19064*G + 28790*B ) >> 16 + 128;		// Cb

*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // { H263P

//
// All of the RGB converters follow the template given below. The converters make
// some assumptions about the frame size. All output frame sizes are assumed to
// have a frame height that is a multiple of 48. Also, the output frame width
// is assumed to be a multiple of 8. If the input frame size is equal
// to the output frame size, no stretching or cropping is done. Otherwise, the
// image is cropped and stretched for an 11:12 aspect ratio.
//

#if 0 // { 0
void rgb_color_converter() {
	for (j = 0; j < LumaIters; j++) {
		for (k = 0; k < mark; k++) {
			for (i = lpbiOutput->biWidth; i > 0; i -= m, pnext += n) {
				compute m Y values using look-up tables
				if (0 == (k&1)) {
					compute m/2 U,V values using look-up tables
				}
			}
			if ((0 == k) && j) {
				for (i = lpbiOutput->biWidth; i > 0; i -= 8 {
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
				}
			}
			pnext += iBackTwoLines;
			py += ypitch_adj;
			if (0 == (k&1)) {
				pu += uvpitch_adj;
				pv += uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = py - pitch;
			pyspace = py;
			pynext = py + pitch;
		}
	}
	if (stretch) {
		for (i = lpbiOutput->biWidth; i > 0; i -= 4 {
			*pyspace++ = *pyprev++;
		}
	}
}
#endif // } 0

// These are the look-up tables for the RGB converters. They are 8 bytes/entry
// to allow addressing via the scale by 8 indexed addressing mode. A pseudo-SIMD
// arrangement is used in these tables. Since all R, G and B contributions to the
// Y value are positive and fit in 15 bits, these are stored in the lower 16-bits
// of the YU word. In some cases, the U contribution is negative so it is placed
// in the upper 16 bits of the YU word. When a Y value is calculated, the U value
// is calculated in parallel. The V contribution is negative in some cases, but it
// gets its own word.

#define YRCoef   16836
#define YGCoef   33056
#define YBCoef    6416
#define URCoef    9726
#define UGCoef   19064
#define UBCoef   28790
#define VRCoef   28777
#define VGCoef   24117
#define VBCoef    4660

struct YUV RYUV[128];
struct YUV GYUV[128];
struct YUV BYUV[128];
struct YUVQUAD YUVPalette[256];

void fill_YUV_tables(void) {
int i,j;

  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      RYUV[((i*4)+j)>>1].YU = ((YRCoef*((i*4)+j+1))>>9) | ((-(((URCoef*((i*4)+j+1)))>>9))<<16);
      RYUV[((i*4)+j)>>1].V  = ((VRCoef*((i*4)+j+1))>>9);
    }
  }

  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      GYUV[((i*4)+j)>>1].YU = ((YGCoef*((i*4)+j+1))>>9) | ((-(((UGCoef*((i*4)+j+1)))>>9))<<16);
      GYUV[((i*4)+j)>>1].V  = -((VGCoef*((i*4)+j+1))>>9);
    }
  }

  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      BYUV[((i*4)+j)>>1].YU = ((YBCoef*((i*4)+j+1))>>9) | (((UBCoef*((i*4)+j+1))>>9)<<16);
      BYUV[((i*4)+j)>>1].V  = -((VBCoef*((i*4)+j+1))>>9);
    }
  }
}

void Compute_YUVPalette(LPBITMAPINFOHEADER	lpbiInput) {
RGBQUAD *lpCEntry, *lpCTable = (RGBQUAD *)((U8 *)lpbiInput + sizeof(BITMAPINFOHEADER));
YUVQUAD *lpYUVEntry;
DWORD i;
int t;

	for (i = 0; i < lpbiInput->biClrUsed; i++) {
		lpCEntry = &lpCTable[i];
		lpYUVEntry = &YUVPalette[i];
		t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
			  GYUV[lpCEntry->rgbGreen>>1].YU +
			  RYUV[lpCEntry->rgbRed>>1].YU );
		lpYUVEntry->Yval = (U8)((t>>8)+8);
		lpYUVEntry->Uval = (U8)((t>>24)+64);
		t = ( RYUV[lpCEntry->rgbRed>>1].V +
			  GYUV[lpCEntry->rgbGreen>>1].V +
			  BYUV[lpCEntry->rgbBlue>>1].V );
		lpYUVEntry->Vval = (U8)((t>>8)+64);
	}
}

typedef struct {
  // Ptr to color conv initializer function.
  void ( * Initializer) (LPBITMAPINFOHEADER	lpbiInput);
  void ( * ColorConvertor[3]) (
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch);
// [0] P5 version
// [1] P6 version
// [2] MMX version
} T_H26XInputColorConvertorCatalog;

/*  The Connectix Quick Cam requires RGB to YUV12 conversion.
 *  The B/W camera generates palette versions (8 and 4 bit).
 *  The color camera generates RGB24 for million colors and
 *  RGB16555 for thousands colors.
 */

#ifndef USE_BILINEAR_MSH26X
static void BGR32_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}
#endif

static void BGR24_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

static void BGR16555_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

static void CLUT8_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

static void CLUT4_INIT(LPBITMAPINFOHEADER	lpbiInput) {
	fill_YUV_tables();
}

T_H26XInputColorConvertorCatalog InputColorConvertorCatalog[] = {
	{ NULL,			NULL,						NULL,					NULL					},
#ifndef USE_BILINEAR_MSH26X
	{ BGR32_INIT,	P5_H26X_BGR32toYUV12,		P5_H26X_BGR32toYUV12,	P5_H26X_BGR32toYUV12    },
#endif
	{ BGR24_INIT,	P5_H26X_BGR24toYUV12,		P5_H26X_BGR24toYUV12,	P5_H26X_BGR24toYUV12	},
	{ BGR16555_INIT,P5_H26X_BGR16555toYUV12,	P5_H26X_BGR16555toYUV12,P5_H26X_BGR16555toYUV12 },
	{ CLUT8_INIT,	P5_H26X_CLUT8toYUV12,		P5_H26X_CLUT8toYUV12,	P5_H26X_CLUT8toYUV12	},
	{ CLUT4_INIT,	P5_H26X_CLUT4toYUV12,		P5_H26X_CLUT4toYUV12,	P5_H26X_CLUT4toYUV12	},
	{ NULL,			C_H26X_YVU9toYUV12,			C_H26X_YVU9toYUV12,		C_H26X_YVU9toYUV12      },
	{ NULL,			P5_H26X_YUY2toYUV12,		P5_H26X_YUY2toYUV12,	P5_H26X_YUY2toYUV12     },
	{ NULL,			P5_H26X_UYVYtoYUV12,		P5_H26X_UYVYtoYUV12,	P5_H26X_UYVYtoYUV12     },
	{ NULL,			C_H26X_YUV12toEncYUV12,		C_H26X_YUV12toEncYUV12,	C_H26X_YUV12toEncYUV12  },
};

void colorCnvtInitialize(
	LPBITMAPINFOHEADER	lpbiInput,
	int InputColorConvertor) {

	if (InputColorConvertorCatalog[InputColorConvertor].Initializer) {
		InputColorConvertorCatalog[InputColorConvertor].Initializer(lpbiInput);
	}
}

#ifdef USE_MMX // { USE_MMX
extern BOOL MMX_Enabled;
#endif // } USE_MMX

/*************************************************************
 *  Name:         colorCnvtFrame
 *  Description:  Color convert and copy input frame.
 ************************************************************/
void colorCnvtFrame(
  	U32			ColorConvertor,
	LPCODINST	lpCompInst,
    ICCOMPRESS	*lpicComp,
    U8			*YPlane,
    U8			*UPlane,
    U8			*VPlane
)
{
	LPBITMAPINFOHEADER	lpbiInput = lpicComp->lpbiInput;
    U8 *lpInput = (U8 *) lpicComp->lpInput;

#ifdef USE_MMX // { USE_MMX
	InputColorConvertorCatalog[ColorConvertor].ColorConvertor[MMX_Enabled ? MMX_CC : PENTIUM_CC](lpbiInput,lpCompInst->xres,lpCompInst->yres,lpInput,YPlane,UPlane,VPlane,PITCH);
#else // }{ USE_MMX
	InputColorConvertorCatalog[ColorConvertor].ColorConvertor[PENTIUM_CC](lpbiInput,lpCompInst->xres,lpCompInst->yres,lpInput,YPlane,UPlane,VPlane,PITCH);
#endif // } USE_MMX
			

}

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\dxpal.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

;// $Author:   KMILLS  $
;// $Date:   22 Dec 1995 14:05:16  $
;// $Archive:   S:\h26x\src\dec\dxpal.cpv  $
;// $Header:   S:\h26x\src\dec\dxpal.cpv   1.2   22 Dec 1995 14:05:16   KMILLS  $
;// $Log:   S:\h26x\src\dec\dxpal.cpv  $
// 
//    Rev 1.2   22 Dec 1995 14:05:16   KMILLS
// 
// added new copyright notice
// 
//    Rev 1.1   03 Nov 1995 11:49:48   BNICKERS
// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
// 
//    Rev 1.0   31 Jul 1995 13:00:52   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:28   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:56   CZHU
// Initial revision.

#include "precomp.h"

#ifdef USE_WIN95_PAL // { USE_WIN95_PAL
unsigned char PalTable[236*4] = {
	   4,   4,   4, PC_NOCOLLAPSE,
	   8,   8,   8, PC_NOCOLLAPSE,
	  12,  12,  12, PC_NOCOLLAPSE,
	  17,  17,  17, PC_NOCOLLAPSE,
	  22,  22,  22, PC_NOCOLLAPSE,
	  28,  28,  28, PC_NOCOLLAPSE,
	  34,  34,  34, PC_NOCOLLAPSE,
	  41,  41,  41, PC_NOCOLLAPSE,
	  85,  85,  85, PC_NOCOLLAPSE,
	  77,  77,  77, PC_NOCOLLAPSE,
	  66,  66,  66, PC_NOCOLLAPSE,
	  57,  57,  57, PC_NOCOLLAPSE,
	 255, 124, 128, PC_NOCOLLAPSE,
	 255,  80,  80, PC_NOCOLLAPSE,
	 214,   0, 147, PC_NOCOLLAPSE,
	 204, 236, 255, PC_NOCOLLAPSE,
	 239, 214, 198, PC_NOCOLLAPSE,
	 231, 231, 214, PC_NOCOLLAPSE,
	 173, 169, 144, PC_NOCOLLAPSE,
	  51,   0,   0, PC_NOCOLLAPSE,
	 102,   0,   0, PC_NOCOLLAPSE,
	 153,   0,   0, PC_NOCOLLAPSE,
	 204,   0,   0, PC_NOCOLLAPSE,
	   0,  51,   0, PC_NOCOLLAPSE,
	  51,  51,   0, PC_NOCOLLAPSE,
	 102,  51,   0, PC_NOCOLLAPSE,
	 153,  51,   0, PC_NOCOLLAPSE,
	 204,  51,   0, PC_NOCOLLAPSE,
	 255,  51,   0, PC_NOCOLLAPSE,
	   0, 102,   0, PC_NOCOLLAPSE,
	  51, 102,   0, PC_NOCOLLAPSE,
	 102, 102,   0, PC_NOCOLLAPSE,
	 153, 102,   0, PC_NOCOLLAPSE,
	 204, 102,   0, PC_NOCOLLAPSE,
	 255, 102,   0, PC_NOCOLLAPSE,
	   0, 153,   0, PC_NOCOLLAPSE,
	  51, 153,   0, PC_NOCOLLAPSE,
	 102, 153,   0, PC_NOCOLLAPSE,
	 153, 153,   0, PC_NOCOLLAPSE,
	 204, 153,   0, PC_NOCOLLAPSE,
	 255, 153,   0, PC_NOCOLLAPSE,
	   0, 204,   0, PC_NOCOLLAPSE,
	  51, 204,   0, PC_NOCOLLAPSE,
	 102, 204,   0, PC_NOCOLLAPSE,
	 153, 204,   0, PC_NOCOLLAPSE,
	 204, 204,   0, PC_NOCOLLAPSE,
	 255, 204,   0, PC_NOCOLLAPSE,
	 102, 255,   0, PC_NOCOLLAPSE,
	 153, 255,   0, PC_NOCOLLAPSE,
	 204, 255,   0, PC_NOCOLLAPSE,
	   0,   0,  51, PC_NOCOLLAPSE,
	  51,   0,  51, PC_NOCOLLAPSE,
	 102,   0,  51, PC_NOCOLLAPSE,
	 153,   0,  51, PC_NOCOLLAPSE,
	 204,   0,  51, PC_NOCOLLAPSE,
	 255,   0,  51, PC_NOCOLLAPSE,
	   0,  51,  51, PC_NOCOLLAPSE,
	  51,  51,  51, PC_NOCOLLAPSE,
	 102,  51,  51, PC_NOCOLLAPSE,
	 153,  51,  51, PC_NOCOLLAPSE,
	 204,  51,  51, PC_NOCOLLAPSE,
	 255,  51,  51, PC_NOCOLLAPSE,
	   0, 102,  51, PC_NOCOLLAPSE,
	  51, 102,  51, PC_NOCOLLAPSE,
	 102, 102,  51, PC_NOCOLLAPSE,
	 153, 102,  51, PC_NOCOLLAPSE,
	 204, 102,  51, PC_NOCOLLAPSE,
	 255, 102,  51, PC_NOCOLLAPSE,
	   0, 153,  51, PC_NOCOLLAPSE,
	  51, 153,  51, PC_NOCOLLAPSE,
	 102, 153,  51, PC_NOCOLLAPSE,
	 153, 153,  51, PC_NOCOLLAPSE,
	 204, 153,  51, PC_NOCOLLAPSE,
	 255, 153,  51, PC_NOCOLLAPSE,
	   0, 204,  51, PC_NOCOLLAPSE,
	  51, 204,  51, PC_NOCOLLAPSE,
	 102, 204,  51, PC_NOCOLLAPSE,
	 153, 204,  51, PC_NOCOLLAPSE,
	 204, 204,  51, PC_NOCOLLAPSE,
	 255, 204,  51, PC_NOCOLLAPSE,
	  51, 255,  51, PC_NOCOLLAPSE,
	 102, 255,  51, PC_NOCOLLAPSE,
	 153, 255,  51, PC_NOCOLLAPSE,
	 204, 255,  51, PC_NOCOLLAPSE,
	 255, 255,  51, PC_NOCOLLAPSE,
	   0,   0, 102, PC_NOCOLLAPSE,
	  51,   0, 102, PC_NOCOLLAPSE,
	 102,   0, 102, PC_NOCOLLAPSE,
	 153,   0, 102, PC_NOCOLLAPSE,
	 204,   0, 102, PC_NOCOLLAPSE,
	 255,   0, 102, PC_NOCOLLAPSE,
	   0,  51, 102, PC_NOCOLLAPSE,
	  51,  51, 102, PC_NOCOLLAPSE,
	 102,  51, 102, PC_NOCOLLAPSE,
	 153,  51, 102, PC_NOCOLLAPSE,
	 204,  51, 102, PC_NOCOLLAPSE,
	 255,  51, 102, PC_NOCOLLAPSE,
	   0, 102, 102, PC_NOCOLLAPSE,
	  51, 102, 102, PC_NOCOLLAPSE,
	 102, 102, 102, PC_NOCOLLAPSE,
	 153, 102, 102, PC_NOCOLLAPSE,
	 204, 102, 102, PC_NOCOLLAPSE,
	   0, 153, 102, PC_NOCOLLAPSE,
	  51, 153, 102, PC_NOCOLLAPSE,
	 102, 153, 102, PC_NOCOLLAPSE,
	 153, 153, 102, PC_NOCOLLAPSE,
	 204, 153, 102, PC_NOCOLLAPSE,
	 255, 153, 102, PC_NOCOLLAPSE,
	   0, 204, 102, PC_NOCOLLAPSE,
	  51, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 102, PC_NOCOLLAPSE,
	 204, 204, 102, PC_NOCOLLAPSE,
	 255, 204, 102, PC_NOCOLLAPSE,
	   0, 255, 102, PC_NOCOLLAPSE,
	  51, 255, 102, PC_NOCOLLAPSE,
	 153, 255, 102, PC_NOCOLLAPSE,
	 204, 255, 102, PC_NOCOLLAPSE,
	 255,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 255, PC_NOCOLLAPSE,
	   0, 153, 153, PC_NOCOLLAPSE,
	 153,  51, 153, PC_NOCOLLAPSE,
	 153,   0, 153, PC_NOCOLLAPSE,
	 204,   0, 153, PC_NOCOLLAPSE,
	   0,   0, 153, PC_NOCOLLAPSE,
	  51,  51, 153, PC_NOCOLLAPSE,
	 102,   0, 153, PC_NOCOLLAPSE,
	 204,  51, 153, PC_NOCOLLAPSE,
	 255,   0, 153, PC_NOCOLLAPSE,
	   0, 102, 153, PC_NOCOLLAPSE,
	  51, 102, 153, PC_NOCOLLAPSE,
	 102,  51, 153, PC_NOCOLLAPSE,
	 153, 102, 153, PC_NOCOLLAPSE,
	 204, 102, 153, PC_NOCOLLAPSE,
	 255,  51, 153, PC_NOCOLLAPSE,
	  51, 153, 153, PC_NOCOLLAPSE,
	 102, 153, 153, PC_NOCOLLAPSE,
	 153, 153, 153, PC_NOCOLLAPSE,
	 204, 153, 153, PC_NOCOLLAPSE,
	 255, 153, 153, PC_NOCOLLAPSE,
	   0, 204, 153, PC_NOCOLLAPSE,
	  51, 204, 153, PC_NOCOLLAPSE,
	 102, 204, 102, PC_NOCOLLAPSE,
	 153, 204, 153, PC_NOCOLLAPSE,
	 204, 204, 153, PC_NOCOLLAPSE,
	 255, 204, 153, PC_NOCOLLAPSE,
	   0, 255, 153, PC_NOCOLLAPSE,
	  51, 255, 153, PC_NOCOLLAPSE,
	 102, 204, 153, PC_NOCOLLAPSE,
	 153, 255, 153, PC_NOCOLLAPSE,
	 204, 255, 153, PC_NOCOLLAPSE,
	 255, 255, 153, PC_NOCOLLAPSE,
	   0,   0, 204, PC_NOCOLLAPSE,
	  51,   0, 153, PC_NOCOLLAPSE,
	 102,   0, 204, PC_NOCOLLAPSE,
	 153,   0, 204, PC_NOCOLLAPSE,
	 204,   0, 204, PC_NOCOLLAPSE,
	   0,  51, 153, PC_NOCOLLAPSE,
	  51,  51, 204, PC_NOCOLLAPSE,
	 102,  51, 204, PC_NOCOLLAPSE,
	 153,  51, 204, PC_NOCOLLAPSE,
	 204,  51, 204, PC_NOCOLLAPSE,
	 255,  51, 204, PC_NOCOLLAPSE,
	   0, 102, 204, PC_NOCOLLAPSE,
	  51, 102, 204, PC_NOCOLLAPSE,
	 102, 102, 153, PC_NOCOLLAPSE,
	 153, 102, 204, PC_NOCOLLAPSE,
	 204, 102, 204, PC_NOCOLLAPSE,
	 255, 102, 153, PC_NOCOLLAPSE,
	   0, 153, 204, PC_NOCOLLAPSE,
	  51, 153, 204, PC_NOCOLLAPSE,
	 102, 153, 204, PC_NOCOLLAPSE,
	 153, 153, 204, PC_NOCOLLAPSE,
	 204, 153, 204, PC_NOCOLLAPSE,
	 255, 153, 204, PC_NOCOLLAPSE,
	   0, 204, 204, PC_NOCOLLAPSE,
	  51, 204, 204, PC_NOCOLLAPSE,
	 102, 204, 204, PC_NOCOLLAPSE,
	 153, 204, 204, PC_NOCOLLAPSE,
	 204, 204, 204, PC_NOCOLLAPSE,
	 255, 204, 204, PC_NOCOLLAPSE,
	   0, 255, 204, PC_NOCOLLAPSE,
	  51, 255, 204, PC_NOCOLLAPSE,
	 102, 255, 153, PC_NOCOLLAPSE,
	 153, 255, 204, PC_NOCOLLAPSE,
	 204, 255, 204, PC_NOCOLLAPSE,
	 255, 255, 204, PC_NOCOLLAPSE,
	  51,   0, 204, PC_NOCOLLAPSE,
	 102,   0, 255, PC_NOCOLLAPSE,
	 153,   0, 255, PC_NOCOLLAPSE,
	   0,  51, 204, PC_NOCOLLAPSE,
	  51,  51, 255, PC_NOCOLLAPSE,
	 102,  51, 255, PC_NOCOLLAPSE,
	 153,  51, 255, PC_NOCOLLAPSE,
	 204,  51, 255, PC_NOCOLLAPSE,
	 255,  51, 255, PC_NOCOLLAPSE,
	   0, 102, 255, PC_NOCOLLAPSE,
	  51, 102, 255, PC_NOCOLLAPSE,
	 102, 102, 204, PC_NOCOLLAPSE,
	 153, 102, 255, PC_NOCOLLAPSE,
	 204, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 204, PC_NOCOLLAPSE,
	   0, 153, 255, PC_NOCOLLAPSE,
	  51, 153, 255, PC_NOCOLLAPSE,
	 102, 153, 255, PC_NOCOLLAPSE,
	 153, 153, 255, PC_NOCOLLAPSE,
	 204, 153, 255, PC_NOCOLLAPSE,
	 255, 153, 255, PC_NOCOLLAPSE,
	   0, 204, 255, PC_NOCOLLAPSE,
	  51, 204, 255, PC_NOCOLLAPSE,
	 102, 204, 255, PC_NOCOLLAPSE,
	 153, 204, 255, PC_NOCOLLAPSE,
	 204, 204, 255, PC_NOCOLLAPSE,
	 255, 204, 255, PC_NOCOLLAPSE,
	  51, 255, 255, PC_NOCOLLAPSE,
	 102, 255, 204, PC_NOCOLLAPSE,
	 153, 255, 255, PC_NOCOLLAPSE,
	 204, 255, 255, PC_NOCOLLAPSE,
	 255, 102, 102, PC_NOCOLLAPSE,
	 102, 255, 102, PC_NOCOLLAPSE,
	 255, 255, 102, PC_NOCOLLAPSE,
	 102, 102, 255, PC_NOCOLLAPSE,
	 255, 102, 255, PC_NOCOLLAPSE,
	 102, 255, 255, PC_NOCOLLAPSE,
	 165,   0,  33, PC_NOCOLLAPSE,
	  95,  95,  95, PC_NOCOLLAPSE,
	 119, 119, 119, PC_NOCOLLAPSE,
	 134, 134, 134, PC_NOCOLLAPSE,
	 150, 150, 150, PC_NOCOLLAPSE,
	 203, 203, 203, PC_NOCOLLAPSE,
	 178, 178, 178, PC_NOCOLLAPSE,
	 215, 215, 215, PC_NOCOLLAPSE,
	 221, 221, 221, PC_NOCOLLAPSE,
	 227, 227, 227, PC_NOCOLLAPSE,
	 234, 234, 234, PC_NOCOLLAPSE,
	 241, 241, 241, PC_NOCOLLAPSE,
	 248, 248, 248, PC_NOCOLLAPSE
};
#else // }{ USE_WIN95_PAL
unsigned char PalTable[236*4] = {
                              0,  39+ 15,       0,  PC_NOCOLLAPSE,
                              0,  39+ 24,       0,  PC_NOCOLLAPSE,
                              0,  39+ 33,       0,  PC_NOCOLLAPSE,
                              0,  39+ 42,       0,  PC_NOCOLLAPSE,
                        -44+ 51,  39+ 51,       0,  PC_NOCOLLAPSE,
                        -44+ 60,  39+ 60, -55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  39+ 69, -55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  39+ 78, -55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  39+ 87, -55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  39+ 96, -55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  39+105, -55+105,  PC_NOCOLLAPSE,
                        -44+114,  39+114, -55+114,  PC_NOCOLLAPSE,
                        -44+123,  39+123, -55+123,  PC_NOCOLLAPSE,
                        -44+132,  39+132, -55+132,  PC_NOCOLLAPSE,
                        -44+141,  39+141, -55+141,  PC_NOCOLLAPSE,
                        -44+150,  39+150, -55+150,  PC_NOCOLLAPSE,
                        -44+159,  39+159, -55+159,  PC_NOCOLLAPSE,
                        -44+168,  39+168, -55+168,  PC_NOCOLLAPSE,
                        -44+177,  39+177, -55+177,  PC_NOCOLLAPSE,
                        -44+186,  39+186, -55+186,  PC_NOCOLLAPSE,
                        -44+195,  39+195, -55+195,  PC_NOCOLLAPSE,
                        -44+204,  39+204, -55+204,  PC_NOCOLLAPSE,
                        -44+213,  39+213, -55+213,  PC_NOCOLLAPSE,
                        -44+222,     255, -55+222,  PC_NOCOLLAPSE,
                        -44+231,     255, -55+231,  PC_NOCOLLAPSE,
                        -44+240,     255, -55+240,  PC_NOCOLLAPSE,

                              0,  26+ 15,   0+ 15,  PC_NOCOLLAPSE,
                              0,  26+ 24,   0+ 24,  PC_NOCOLLAPSE,
                              0,  26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                              0,  26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                        -44+105,  26+105,   0+105,  PC_NOCOLLAPSE,
                        -44+114,  26+114,   0+114,  PC_NOCOLLAPSE,
                        -44+123,  26+123,   0+123,  PC_NOCOLLAPSE,
                        -44+132,  26+132,   0+132,  PC_NOCOLLAPSE,
                        -44+141,  26+141,   0+141,  PC_NOCOLLAPSE,
                        -44+150,  26+150,   0+150,  PC_NOCOLLAPSE,
                        -44+159,  26+159,   0+159,  PC_NOCOLLAPSE,
                        -44+168,  26+168,   0+168,  PC_NOCOLLAPSE,
                        -44+177,  26+177,   0+177,  PC_NOCOLLAPSE,
                        -44+186,  26+186,   0+186,  PC_NOCOLLAPSE,
                        -44+195,  26+195,   0+195,  PC_NOCOLLAPSE,
                        -44+204,  26+204,   0+204,  PC_NOCOLLAPSE,
                        -44+213,  26+213,   0+213,  PC_NOCOLLAPSE,
                        -44+222,  26+222,   0+222,  PC_NOCOLLAPSE,
                        -44+231,     255,   0+231,  PC_NOCOLLAPSE,
                        -44+240,     255,   0+240,  PC_NOCOLLAPSE,

                              0,  14+ 15,  55+ 15,  PC_NOCOLLAPSE,
                              0,  14+ 24,  55+ 24,  PC_NOCOLLAPSE,
                              0,  14+ 33,  55+ 33,  PC_NOCOLLAPSE,
                              0,  14+ 42,  55+ 42,  PC_NOCOLLAPSE,
                        -44+ 51,  14+ 51,  55+ 51,  PC_NOCOLLAPSE,
                        -44+ 60,  14+ 60,  55+ 60,  PC_NOCOLLAPSE,
                        -44+ 69,  14+ 69,  55+ 69,  PC_NOCOLLAPSE,
                        -44+ 78,  14+ 78,  55+ 78,  PC_NOCOLLAPSE,
                        -44+ 87,  14+ 87,  55+ 87,  PC_NOCOLLAPSE,
                        -44+ 96,  14+ 96,  55+ 96,  PC_NOCOLLAPSE,
                        -44+105,  14+105,  55+105,  PC_NOCOLLAPSE,
                        -44+114,  14+114,  55+114,  PC_NOCOLLAPSE,
                        -44+123,  14+123,  55+123,  PC_NOCOLLAPSE,
                        -44+132,  14+132,  55+132,  PC_NOCOLLAPSE,

						// Replace this entry with a more ie-logo-friendly color 
						// -44+141,  14+141,  55+141,  PC_NOCOLLAPSE,
							 51,     153,     255,  PC_NOCOLLAPSE,

                        -44+150,  14+150,  55+150,  PC_NOCOLLAPSE,
                        -44+159,  14+159,  55+159,  PC_NOCOLLAPSE,
                        -44+168,  14+168,  55+168,  PC_NOCOLLAPSE,
                        -44+177,  14+177,  55+177,  PC_NOCOLLAPSE,
                        -44+186,  14+186,  55+186,  PC_NOCOLLAPSE,
                        -44+195,  14+195,  55+195,  PC_NOCOLLAPSE,
                        -44+204,  14+204,     255,  PC_NOCOLLAPSE,
                        -44+213,  14+213,     255,  PC_NOCOLLAPSE,
                        -44+222,     255,     255,  PC_NOCOLLAPSE,
                        -44+231,     255,     255,  PC_NOCOLLAPSE,
                        -44+240,     255,     255,  PC_NOCOLLAPSE,

                          0+ 15,  13+ 15,       0,  PC_NOCOLLAPSE,
                          0+ 24,  13+ 24,       0,  PC_NOCOLLAPSE,
                          0+ 33,  13+ 33,       0,  PC_NOCOLLAPSE,
                          0+ 42,  13+ 42,       0,  PC_NOCOLLAPSE,
                          0+ 51,  13+ 51,       0,  PC_NOCOLLAPSE,
                          0+ 60,  13+ 60, -55+ 60,  PC_NOCOLLAPSE,
                          0+ 69,  13+ 69, -55+ 69,  PC_NOCOLLAPSE,
                          0+ 78,  13+ 78, -55+ 78,  PC_NOCOLLAPSE,
                          0+ 87,  13+ 87, -55+ 87,  PC_NOCOLLAPSE,
                          0+ 96,  13+ 96, -55+ 96,  PC_NOCOLLAPSE,
                          0+105,  13+105, -55+105,  PC_NOCOLLAPSE,
                          0+114,  13+114, -55+114,  PC_NOCOLLAPSE,
                          0+123,  13+123, -55+123,  PC_NOCOLLAPSE,
                          0+132,  13+132, -55+132,  PC_NOCOLLAPSE,
                          0+141,  13+141, -55+141,  PC_NOCOLLAPSE,
                          0+150,  13+150, -55+150,  PC_NOCOLLAPSE,
                          0+159,  13+159, -55+159,  PC_NOCOLLAPSE,
                          0+168,  13+168, -55+168,  PC_NOCOLLAPSE,
                          0+177,  13+177, -55+177,  PC_NOCOLLAPSE,
                          0+186,  13+186, -55+186,  PC_NOCOLLAPSE,
                          0+195,  13+195, -55+195,  PC_NOCOLLAPSE,
                          0+204,  13+204, -55+204,  PC_NOCOLLAPSE,
                          0+213,  13+213, -55+213,  PC_NOCOLLAPSE,
                          0+222,  13+222, -55+222,  PC_NOCOLLAPSE,
                          0+231,  13+231, -55+231,  PC_NOCOLLAPSE,
                          0+240,  13+242, -55+240,  PC_NOCOLLAPSE,

                          0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
                          0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
                          0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
                          0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
                          0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
                          0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
                          0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
                          0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
                          0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
                          0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
                          0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
                          0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
                          0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
                          0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
                          0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
                          0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
                          0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
                          0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
                          0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
                          0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
                          0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
                          0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
                          0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
                          0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
                          0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
                          0+240,   0+240,   0+240,  PC_NOCOLLAPSE,

                          0+ 15, -13+ 15,  55+ 15,  PC_NOCOLLAPSE,
                          0+ 24, -13+ 24,  55+ 24,  PC_NOCOLLAPSE,
                          0+ 33, -13+ 33,  55+ 33,  PC_NOCOLLAPSE,
                          0+ 42, -13+ 42,  55+ 42,  PC_NOCOLLAPSE,
                          0+ 51, -13+ 51,  55+ 51,  PC_NOCOLLAPSE,
                          0+ 60, -13+ 60,  55+ 60,  PC_NOCOLLAPSE,
                          0+ 69, -13+ 69,  55+ 69,  PC_NOCOLLAPSE,
                          0+ 78, -13+ 78,  55+ 78,  PC_NOCOLLAPSE,
                          0+ 87, -13+ 87,  55+ 87,  PC_NOCOLLAPSE,
                          0+ 96, -13+ 96,  55+ 96,  PC_NOCOLLAPSE,
                          0+105, -13+105,  55+105,  PC_NOCOLLAPSE,
                          0+114, -13+114,  55+114,  PC_NOCOLLAPSE,
                          0+123, -13+123,  55+123,  PC_NOCOLLAPSE,
                          0+132, -13+132,  55+132,  PC_NOCOLLAPSE,
                          0+141, -13+141,  55+141,  PC_NOCOLLAPSE,
                          0+150, -13+150,  55+150,  PC_NOCOLLAPSE,
                          0+159, -13+159,  55+159,  PC_NOCOLLAPSE,
                          0+168, -13+168,  55+168,  PC_NOCOLLAPSE,
                          0+177, -13+177,  55+177,  PC_NOCOLLAPSE,
                          0+186, -13+186,  55+186,  PC_NOCOLLAPSE,
                          0+195, -13+195,  55+195,  PC_NOCOLLAPSE,
                          0+204, -13+204,     255,  PC_NOCOLLAPSE,
                          0+213, -13+213,     255,  PC_NOCOLLAPSE,
                          0+222, -13+222,     255,  PC_NOCOLLAPSE,
                          0+231, -13+231,     255,  PC_NOCOLLAPSE,
                          0+240, -13+240,     255,  PC_NOCOLLAPSE,

                         44+ 15, -14+ 15,       0,  PC_NOCOLLAPSE,
                         44+ 24, -14+ 24,       0,  PC_NOCOLLAPSE,
                         44+ 33, -14+ 33,       0,  PC_NOCOLLAPSE,
                         44+ 42, -14+ 42,       0,  PC_NOCOLLAPSE,
                         44+ 51, -14+ 51,       0,  PC_NOCOLLAPSE,
                         44+ 60, -14+ 60, -55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -14+ 69, -55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -14+ 78, -55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -14+ 87, -55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -14+ 96, -55+ 96,  PC_NOCOLLAPSE,
                         44+105, -14+105, -55+105,  PC_NOCOLLAPSE,
                         44+114, -14+114, -55+114,  PC_NOCOLLAPSE,
                         44+123, -14+123, -55+123,  PC_NOCOLLAPSE,
                         44+132, -14+132, -55+132,  PC_NOCOLLAPSE,
                         44+141, -14+141, -55+141,  PC_NOCOLLAPSE,
                         44+150, -14+150, -55+150,  PC_NOCOLLAPSE,
                         44+159, -14+159, -55+159,  PC_NOCOLLAPSE,
                         44+168, -14+168, -55+168,  PC_NOCOLLAPSE,
                         44+177, -14+177, -55+177,  PC_NOCOLLAPSE,
                         44+186, -14+186, -55+186,  PC_NOCOLLAPSE,
                         44+195, -14+195, -55+195,  PC_NOCOLLAPSE,
                         44+204, -14+204, -55+204,  PC_NOCOLLAPSE,
                            255, -14+213, -55+213,  PC_NOCOLLAPSE,
                            255, -14+222, -55+222,  PC_NOCOLLAPSE,
                            255, -14+231, -55+231,  PC_NOCOLLAPSE,
                            255, -14+242, -55+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,   0+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,   0+ 24,  PC_NOCOLLAPSE,
                         44+ 33, -26+ 33,   0+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -26+ 42,   0+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -26+ 51,   0+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -26+ 60,   0+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -26+ 69,   0+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -26+ 78,   0+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -26+ 87,   0+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -26+ 96,   0+ 96,  PC_NOCOLLAPSE,
                         44+105, -26+105,   0+105,  PC_NOCOLLAPSE,
                         44+114, -26+114,   0+114,  PC_NOCOLLAPSE,
                         44+123, -26+123,   0+123,  PC_NOCOLLAPSE,
                         44+132, -26+132,   0+132,  PC_NOCOLLAPSE,
                         44+141, -26+141,   0+141,  PC_NOCOLLAPSE,
                         44+150, -26+150,   0+150,  PC_NOCOLLAPSE,
                         44+159, -26+159,   0+159,  PC_NOCOLLAPSE,
                         44+168, -26+168,   0+168,  PC_NOCOLLAPSE,
                         44+177, -26+177,   0+177,  PC_NOCOLLAPSE,
                         44+186, -26+186,   0+186,  PC_NOCOLLAPSE,
                         44+195, -26+195,   0+195,  PC_NOCOLLAPSE,
                         44+204, -26+204,   0+204,  PC_NOCOLLAPSE,
                            255, -26+213,   0+213,  PC_NOCOLLAPSE,
                            255, -26+222,   0+222,  PC_NOCOLLAPSE,
                            255, -26+231,   0+231,  PC_NOCOLLAPSE,
                            255, -26+240,   0+240,  PC_NOCOLLAPSE,

                         44+ 15,       0,  55+ 15,  PC_NOCOLLAPSE,
                         44+ 24,       0,  55+ 24,  PC_NOCOLLAPSE,
                         44+ 33,       0,  55+ 33,  PC_NOCOLLAPSE,
                         44+ 42, -39+ 42,  55+ 42,  PC_NOCOLLAPSE,
                         44+ 51, -39+ 51,  55+ 51,  PC_NOCOLLAPSE,
                         44+ 60, -39+ 60,  55+ 60,  PC_NOCOLLAPSE,
                         44+ 69, -39+ 69,  55+ 69,  PC_NOCOLLAPSE,
                         44+ 78, -39+ 78,  55+ 78,  PC_NOCOLLAPSE,
                         44+ 87, -39+ 87,  55+ 87,  PC_NOCOLLAPSE,
                         44+ 96, -39+ 96,  55+ 96,  PC_NOCOLLAPSE,
                         44+105, -39+105,  55+105,  PC_NOCOLLAPSE,
                         44+114, -39+114,  55+114,  PC_NOCOLLAPSE,
                         44+123, -39+123,  55+123,  PC_NOCOLLAPSE,
                         44+132, -39+132,  55+132,  PC_NOCOLLAPSE,
                         44+141, -39+141,  55+141,  PC_NOCOLLAPSE,
                         44+150, -39+150,  55+150,  PC_NOCOLLAPSE,
                         44+159, -39+159,  55+159,  PC_NOCOLLAPSE,
                         44+168, -39+168,  55+168,  PC_NOCOLLAPSE,
                         44+177, -39+177,  55+177,  PC_NOCOLLAPSE,
                         44+186, -39+186,  55+186,  PC_NOCOLLAPSE,
                         44+195, -39+195,  55+195,  PC_NOCOLLAPSE,
                         44+204, -39+204,     255,  PC_NOCOLLAPSE,
                            255, -39+213,     255,  PC_NOCOLLAPSE,
                            255, -39+222,     255,  PC_NOCOLLAPSE,
                            255, -39+231,     255,  PC_NOCOLLAPSE,
                            255, -39+240,     255,  PC_NOCOLLAPSE,

			0x81, 0x81, 0x83, PC_NOCOLLAPSE, 
			0x81, 0x81, 0x84, PC_NOCOLLAPSE
};
#endif // } USE_WIN95_PAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb32.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#ifdef H263P // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR32toYUV12()
 * 	
 *  Convert from BGR32 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0 // { 0

void C_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	int tm1, tm2;
	int t1, t2, t3, t4;

	C_RGB_COLOR_CONVERT_INIT

	// This assignment statement is here simply to avoid a warning message.
	t = t;

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = OutputWidth; i > 0; i-=4, YPlane+=4) {
				tm1 = *pnext++;
				t1 = (BYUV[(tm1>>1)&0x7F].YU +
				     GYUV[(tm1>>9)&0x7F].YU +
				     RYUV[(tm1>>17)&0x7F].YU);
				tm = *pnext++;
				t2 = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				tm2 = *pnext++;
				t3 = (BYUV[(tm2>>1)&0x7F].YU +
				     GYUV[(tm2>>9)&0x7F].YU +
				     RYUV[(tm2>>17)&0x7F].YU);
				tm = *pnext++;
				t4 = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*(U32 *)YPlane =
					(((t1+0x800)>>8)&0xFF)      |
					((t2+0x800)&0xFF00)         |
					(((t3+0x800)<<8)&0xFF0000)  |
					(((t4+0x800)<<16)&0xFF000000);
				if (0 == (k&1)) {
					*(U16 *)UPlane =
						((t1+0x40000000)>>24)            |
						(((t2+0x40000000)>>16)&0xFF00);
					t1 = (BYUV[(tm1>>1)&0x7F].V +
						 GYUV[(tm1>>9)&0x7F].V +
						 RYUV[(tm1>>17)&0x7F].V);
					t2 = (BYUV[(tm2>>1)&0x7F].V +
						 GYUV[(tm2>>9)&0x7F].V +
						 RYUV[(tm2>>17)&0x7F].V);
					*(U16 *)VPlane =
						((t1+0x4000)>>8)              |
						((t2+0x4000)&0xFF00);
					UPlane += 2; VPlane += 2;
				}
			}
			// The next two cases are mutually exclusive.
			// If there is a width_diff there cannot be a stretch and
			// if there is a stretch, there cannot be a width_diff.
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	// The next two cases are mutually exclusive.
	// If there is a height_diff there cannot be a stretch and
	// if there is a stretch, there cannot be a height_diff.
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR32toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_BGR32toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 4, pnext += 16)
L5:
	mov		eax, [esp + OUTPUT_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  |    | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  |    | R2 | G2 | B2 | pnext[1]
//  ---------------------
//  |    | R3 | G3 | B3 | pnext[2]
//  ---------------------
//  |    | R4 | G4 | B4 | pnext[3]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[(t1>> 1)&0x7F].YU +
//       GYUV[(t1>> 9)&0x7F].YU +
//       RYUV[(t1>>17)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	ebx, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	eax, ecx
	mov 	edx, ecx
// 3
	shr 	eax, 1
	and 	ecx, 0xFE00
// 4
	shr 	ecx, 9
	and 	eax, 0x7F
// 5
	shr 	edx, 17
	nop
// 6
	mov 	eax, [BYUV+eax*8].YU
	and		edx, 0x7F
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
		shr 	ebx, 1
	add	eax,  0x800
// 10
	sar 	eax, 8
		and		ecx, 0xFE00
// 11
		shr 	ecx, 9
		and		ebx, 0x7F
// 12
		shr		edx, 17
	mov	 [edi + 1], al
// 13
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 15
		add		eax, [RYUV+edx*8].YU
		nop
// 16
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add		eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  |    | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  |    | R2 | G2 | B2 | pnext[1]
//  ---------------------
//  |    | R3 | G3 | B3 | pnext[2]
//  ---------------------
//  |    | R4 | G4 | B4 | pnext[3]
//  ---------------------

// t2 = pnext[2]
// t3 = pnext[3]
// t = ( BYUV[(t3>> 1)&0x7F].YU +
//       GYUV[(t3>> 9)&0x7F].YU +
//       RYUV[(t3>>17)&0x7F].YU )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t2>> 1)&0x7F].YU +
//       GYUV[(t2>> 9)&0x7F].YU +
//       RYUV[(t2>>17)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 27
	mov		ebx, [esi + 8]
	mov 	ecx, [esi + 12]
// 28
	mov 	eax, ecx
	mov 	edx, ecx
// 29
	shr 	eax, 1
	and 	ecx, 0xFE00
// 30
	shr 	ecx, 9
	and 	eax, 0x7F
// 31
	shr 	edx, 17
	nop
// 32
	mov 	eax, [BYUV+eax*8].YU
	and		edx, 0x7F
// 33
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx, ebx
// 34
	add 	eax, [RYUV+edx*8].YU
		mov		edx, ebx
// 35
		shr		ebx, 1
	add	eax,  0x800
// 36
	sar 	eax, 8
		and		ebx, 0x7F
// 37
		shr		ecx, 9
	mov	 [edi + 3], al
// 38
		shr 	edx, 17
		and		ecx, 0x7F
// 39
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 40
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 41
		add		eax, [RYUV+edx*8].YU
		nop
// 42
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 43
		add		eax, 8
		and		ebx, 1
// 44
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 45
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 46
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 47
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 48
	mov		[edx], al
	inc		edx
// 49
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 50
	sar 	ebx, 8
	inc		edx
// 51
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 52
	mov		[edx - 1], bl
	nop
L16:
// 53
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 16]
// 54
	sub		eax, 4
	lea		edi, [edi + 4]
// 55
	mov		[esp + LOOP_I], eax
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov		ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	mov		edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb4.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_CLUT4toYUV12()
 * 	
 *  Convert from CLUT4 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0 // { 0

void C_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	U8  *p8next;
	U8  tm1, tm2, tm3, tm4;

	C_RGB_COLOR_CONVERT_INIT

	// The following assignment is here simply to avoid a warning message.
	t = t;

	// The palette may change with a new frame. Since we don't know when the palette
	// changes, we have to be conservative and compute it for each frame. However, this
	// should still be quicker than computing Y, U, and V for each pixel.

	Compute_YUVPalette(lpbiInput);

	for (j = 0, p8next = (U8 *)pnext; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = OutputWidth; (i & ~0x7); i-=8, YPlane+=8, p8next+=4) {
				tm1 = *p8next;
				tm2 = *(p8next+1);
				*(U32 *)YPlane =
					YUVPalette[(tm1>>4)&0xF].Yval            |
					((YUVPalette[tm1&0xF].Yval) << 8)        |
					((YUVPalette[(tm2>>4)&0xF].Yval) << 16)  |
					((YUVPalette[tm2&0xF].Yval) << 24);
				tm3 = *(p8next+2);
				tm4 = *(p8next+3);
				*(U32 *)(YPlane+4) =
					YUVPalette[(tm3>>4)&0xF].Yval            |
					((YUVPalette[tm3&0xF].Yval) << 8)        |
					((YUVPalette[(tm4>>4)&0xF].Yval) << 16)  |
					((YUVPalette[tm4&0xF].Yval) << 24);
				if (0 == (k&1)) {
					*(U32 *)UPlane =
						YUVPalette[(tm1>>4)&0xF].Uval            |
						((YUVPalette[(tm2>>4)&0xF].Uval) << 8)  |
						((YUVPalette[(tm3>>4)&0xF].Uval) << 16) |
						((YUVPalette[(tm4>>4)&0xF].Uval) << 24);
					*(U32 *)VPlane =
						YUVPalette[(tm1>>4)&0xF].Vval            |
						((YUVPalette[(tm2>>4)&0xF].Vval) << 8)  |
						((YUVPalette[(tm3>>4)&0xF].Vval) << 16) |
						((YUVPalette[(tm4>>4)&0xF].Vval) << 24);
					UPlane +=4; VPlane += 4;
				}
			}
			if (i & 0x4) {
				tm1 = *p8next++;
				tm2 = *p8next++;
				*(U32 *)YPlane =
					YUVPalette[(tm1>>4)&0xF].Yval            |
					((YUVPalette[tm1&0xF].Yval) << 8)        |
					((YUVPalette[(tm2>>4)&0xF].Yval) << 16)  |
					((YUVPalette[tm2&0xF].Yval) << 24);
				YPlane += 4;
				if (0 == (k&1)) {
					*(U16 *)UPlane =
						YUVPalette[(tm1>>4)&0xF].Uval           |
						((YUVPalette[(tm2>>4)&0xF].Uval) << 8);
					*(U16 *)VPlane =
						YUVPalette[(tm1>>4)&0xF].Vval           |
						((YUVPalette[(tm2>>4)&0xF].Vval) << 8);
					UPlane += 2; VPlane += 2;
				}
			}
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			p8next += (BackTwoLines << 2);
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		}
		C_HEIGHT_FILL
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}

	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUT4toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// Compute_YUVPalette(lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	push	eax
	call	Compute_YUVPalette
	pop		eax

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		ebp, [esp + OUTPUT_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm1 = *p8next
// tm2 = *(p8next+1);
// *(U32 *)YPlane =
//  YUVPalette[(tm1>>4)&0xF].Yval            |
//  ((YUVPalette[tm1&0xF].Yval) << 8)        |
//  ((YUVPalette[(tm2>>4)&0xF].Yval) << 16)  |
//  ((YUVPalette[tm2&0xF].Yval) << 24)
	mov		ax, [esi]
	 nop
	mov		ebx, eax
	 mov	ecx, eax
	shr		ecx, 12
	 mov	edx, eax
	shr		eax, 4
	 and	ebx, 0xF
	shr		edx, 8
	 and	eax, 0xF
	and		ecx, 0xF
	 and	edx, 0xF
	mov		al, [YUVPalette+eax*4].Yval
	 mov	bl, [YUVPalette+ebx*4].Yval
	shl		ebx, 8
	 mov	cl, [YUVPalette+ecx*4].Yval
	shl		ecx, 16
	 mov	dl, [YUVPalette+edx*4].Yval
	shl		edx, 24
	 or		eax, ebx
	or		eax, ecx
	 mov	ebx, [esp + LOOP_K]
	or		eax, edx
	 and	ebx, 1
	mov		[edi], eax
	 jnz	Lno_luma
// tm1 = *p8next
// tm2 = *(p8next+1);
// *(U32 *)UPlane =
//  YUVPalette[(tm1>>4)&0xF].Uval            |
//  ((YUVPalette[(tm2>>4)&0xF].Uval) << 8)
// *(U32 *)VPlane =
//  YUVPalette[(tm1>>4)&0xF].Vval            |
//  ((YUVPalette[(tm2>>4)&0xF].Vval) << 8)
// UPlane += 2
// VPlane += 2
	mov		ax, [esi]
	 nop
	mov		ecx, eax
	 and	eax, 0xF0
	shr		eax, 4
	 mov	ebx, [esp + UPLANE]
	shr		ecx, 12
	 mov	ax, [YUVPalette+eax*4].UVval
	and		ecx, 0xF
	 mov	edx, [esp + VPLANE]
	add		ebx, 2
	 mov	cx, [YUVPalette+ecx*4].UVval
	add		edx, 2
	 mov	[ebx - 2], al
	mov		[esp + UPLANE], ebx
	 mov	[edx - 2], ah
	mov		[esp + VPLANE], edx
	 mov	[ebx - 1], cl
	mov		[edx - 1], ch
	 nop

Lno_luma:
// p8next += 2
// YPlane += 4
	lea		esi, [esi + 2]
	lea		edi, [edi + 4]
	sub		ebp, 4
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb16.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//
// Only the 555 version of RGB16 input color conversion is provided. To generate
// other versions, use the following table.
//
//   number             shift              mask
//                     B, G, R
//   ------          -----------       ----------------
//    555              2, 3, 8         0x7C, 0x7C, 0x7C
//    664              3, 3, 9         0x78, 0x7E, 0x7E
//    565              2, 4, 9         0x7C, 0x7E, 0x7C
//    655              2, 3, 9         0x7C, 0x7C, 0x7E
//
// Only 555 falls under BI_RGB. The others are specified using the
// BI_BITFIELDS compression specification. For BI_BITFIELDS, call
// Build16bitModeID to get the actual bitfield number. This routine requires the
// three array elements in the bmiColors field of a BITMAPINFO object.
//
/*****************************************************************************
 *
 *  H26X_BGR16555toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0 // { 0

void C_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	int t1, t2;
	int tm1, tm2;

	C_RGB_COLOR_CONVERT_INIT

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {
			for (i = OutputWidth; i > 0; i-=4, YPlane+=4) {
				tm1 = *pnext++;
				t1 = (BYUV[(tm1<<2)&0x7C].YU +
					 GYUV[(tm1>>3)&0x7C].YU +
					 RYUV[(tm1>>8)&0x7C].YU);
				*(YPlane) = (U8)((t1>>SHIFT_WIDTH)+8);
				t = (BYUV[(tm1>>14)&0x7C].YU +
					 GYUV[(tm1>>19)&0x7C].YU +
					 RYUV[(tm1>>24)&0x7C].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm2 = *pnext++;
				t2 = (BYUV[(tm2<<2)&0x7C].YU +
					 GYUV[(tm2>>3)&0x7C].YU +
					 RYUV[(tm2>>8)&0x7C].YU);
				*(YPlane+2) = (U8)((t2>>SHIFT_WIDTH)+8);
				t = (BYUV[(tm2>>14)&0x7C].YU +
					 GYUV[(tm2>>19)&0x7C].YU +
					 RYUV[(tm2>>24)&0x7C].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*(U16 *)UPlane = ((t1+0x40000000)>>24) |	(((t2+0x40000000)>>16)&0xFF00);
					t1 = (RYUV[(tm1>>8)&0x7C].V +
						 GYUV[(tm1>>3)&0x7C].V +
						 BYUV[(tm1<<2)&0x7C].V);
					t2 = (RYUV[(tm2>>8)&0x7C].V +
						 GYUV[(tm2>>3)&0x7C].V +
						 BYUV[(tm2<<2)&0x7C].V);
					*(U16 *)VPlane = ((t1+0x4000)>>8) | ((t2+0x4000)&0xFF00);
					UPlane += 2; VPlane += 2;
				}
			}
			// The next two cases are mutually exclusive.
			// If there is a width_diff there cannot be a stretch and
			// if there is a stretch, there cannot be a width_diff.
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	// The next two cases are mutually exclusive.
	// If there is a height_diff there cannot be a stretch and
	// if there is a stretch, there cannot be a height_diff.
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR55516toYUV12

#endif // } 0

__declspec(naked)
void P5_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		eax, [esp + OUTPUT_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm1 = pnext[0]
// t = ( BYUV[(tm1>>14)&0x7C].YU +
//       GYUV[(tm1>>19)&0x7C].YU +
//       RYUV[(tm1>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t1 = ( BYUV[(tm1<< 2)&0x7C].YU +
//       GYUV[(tm1>> 8)&0x7C].YU +
//       RYUV[(tm1>>13)&0x7C].YU )
// *YPlane = (U8)((t1>>8)+8)
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 1
	mov 	ebx, [esi]
	mov		[esp + LOOP_I], eax
// 2
	mov 	eax, ebx
	mov 	ecx, ebx
// 3
	shr 	eax, 14
	mov 	edx, ebx
// 4
	shr 	ecx, 19
	and 	eax, 0x7C
// 5
	shr 	edx, 24
	and 	ecx, 0x7C
// 6
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 9
	sar 	eax, 8
		and	ebx,  0x1F
// 10
		shl 	ebx, 2
	add 	eax, 8
// 11
		shr 	ecx, 3
	mov	 	[edi + 1], al
// 12
		shr 	edx, 8
		and 	ecx, 0x7C
// 13
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 15
		add	 	eax, [RYUV+edx*8].YU
		lea		edi, [edi + 4]
// 16
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add	 	eax, 8
		and		ebx, 1
// 18
		mov 	[edi - 4], al
		jnz 	L9a

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t1>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop

L9a:
// tm2 = pnext[1]
// t = ( BYUV[(tm2>>14)&0x7C].YU +
//       GYUV[(tm2>>19)&0x7C].YU +
//       RYUV[(tm2>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t2 = ( BYUV[(tm2<< 2)&0x7C].YU +
//       GYUV[(tm2>> 8)&0x7C].YU +
//       RYUV[(tm2>>13)&0x7C].YU )
// *YPlane = (U8)((t2>>8)+8)
// YPlane += 4
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 27
	mov 	eax, [esi + 4]
	lea		esi, [esi + 8]
// 28
	mov 	ebx, eax
	mov 	ecx, eax
// 29
	shr 	eax, 14
	mov 	edx, ebx
// 30
	shr 	ecx, 19
	and 	eax, 0x7C
// 31
	shr 	edx, 24
	and 	ecx, 0x7C
// 32
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 33
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 34
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 35
	sar 	eax, 8
		and	ebx,  0x1F
// 36
		shl 	ebx, 2
	add 	eax, 8
// 37
		shr 	ecx, 3
	mov	 	[edi - 1], al
// 38
		shr 	edx, 8
		and 	ecx, 0x7C
// 39
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 40
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 41
		add	 	eax, [RYUV+edx*8].YU
		nop
// 42
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 43
		add	 	eax, 8
		and		ebx, 1
// 44
		mov 	[edi - 2], al
		jnz 	L9

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t2>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 45
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 46
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 47
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 48
	mov		[edx], al
	inc		edx
// 49
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 50
	sar 	ebx, 8
	inc		edx
// 51
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 52
	mov		[edx - 1], bl
	nop

L9:
// 53
	mov		eax, [esp + LOOP_I]
	nop
// 54
	sub		eax, 4
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb24.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR24toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */

#if 0 // { 0

void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{

	C_RGB_COLOR_CONVERT_INIT

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {
			for (i = OutputWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>SHIFT_WIDTH)+8);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
			}
			// The next two cases are mutually exclusive.
			// If there is a width_diff there cannot be a stretch and
			// if there is a stretch, there cannot be a width_diff.
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	// The next two cases are mutually exclusive.
	// If there is a height_diff there cannot be a stretch and
	// if there is a stretch, there cannot be a height_diff.
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR24toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 4, pnext += 12)
L5:
	mov		eax, [esp + OUTPUT_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[t0>>25].YU +
//       GYUV[(t1>> 1)&0x7F].YU +
//       RYUV[(t1>> 9)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	eax, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	ebx, eax
	mov 	edx, ecx
// 3
	shr 	eax, 25
	and 	ecx, 0xFE
// 4
	shr 	ecx, 1
	and 	edx, 0xFE00
// 5
	shr 	edx, 9
		and		ebx, 0xFEFEFE
// 6
	mov 	eax, [BYUV+eax*8].YU
	nop
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
	sar 	eax, 8
		and 	ebx, 0xFE
// 10
		shr 	ebx, 1
	add	eax,  8
// 11
		shr 	ecx, 9
	mov	 [edi + 1], al
// 12
		shr		edx, 17
		and		ecx, 0x7F
// 13
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 15
		add		eax, [RYUV+edx*8].YU
		nop
// 16
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add		eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t1 = pnext[1]
// t2 = pnext[2]
// t = ( BYUV[(t2>> 9)&0x7F].YU +
//       GYUV[(t2>>17)&0x7F].YU +
//       RYUV[t2>>25].YR )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t1>>17)&0x7F].YU +
//       GYUV[t1>>25].YU +
//       RYUV[(t2>> 1)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 27
	mov		ebp, [esi + 4]
	mov 	ebx, [esi + 8]
// 28
	mov 	eax, ebx
	mov 	ecx, ebx
// 29
	shr		eax, 9
	mov		edx, ebx
// 30
	shr 	ecx, 17
	and 	eax, 0x7F
// 31
	shr 	edx, 25
	and		ecx, 0x7F
// 32
	mov 	eax, [BYUV+eax*8].YU
	nop
// 33
	add 	eax, [GYUV+ecx*8].YU
		and		ebx, 0xFE
// 34
	add 	eax, [RYUV+edx*8].YU
		mov		ecx, ebp
// 35
		shr		ebx, 1
	add	eax,  0x800
// 36
	sar 	eax, 8
		mov		edx, ebp
// 37
		shr		edx, 17
	mov	 [edi + 3], al
// 38
		shr 	ecx, 25
		and		edx, 0x7F
// 39
		mov		eax, [RYUV+ebx*8].YU
		mov		ebp, ebx
// 40
		add	 	eax, [GYUV+ecx*8].YU
		nop
// 41
		add		eax, [BYUV+edx*8].YU
		nop
// 42
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 43
		add		eax, 8
		and		ebx, 1
// 44
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 45
	mov 	ebx, [BYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 46
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 47
	add		eax, 64
	add 	ebx, [RYUV+ebp*8].V
// 48
	mov		[edx], al
	inc		edx
// 49
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 50
	sar 	ebx, 8
	inc		edx
// 51
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 52
	mov		[edx - 1], bl
	nop
L16:
// 53
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 12]
// 54
	sub		eax, 4
	lea		edi, [edi + 4]
// 55
	mov		[esp + LOOP_I], eax
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov		ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:
	
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	mov		edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rgb8.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

//
// For the P5 versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_CLUT8toYUV12()
 * 	
 *  Convert from CLUT8 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0 // { 0

void C_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
	U32 tm1, tm2;
	C_RGB_COLOR_CONVERT_INIT

	// The following assignment is here simply to avoid a warning.
	t = t;

	// The palette may change with a new frame. Since we don't know when the palette
	// changes, we have to be conservative and compute it for each frame. However, this
	// should still be quicker than computing Y, U, and V for each pixel.

	Compute_YUVPalette(lpbiInput);

	for (j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = OutputWidth; (i & ~0x7); i-=8, YPlane+=8, pnext+=2) {
				tm1 = *pnext;
				*(U32 *)YPlane =
					YUVPalette[tm1&0xFF].Yval                 |
					((YUVPalette[(tm1>>8)&0xFF].Yval) << 8)   |
					((YUVPalette[(tm1>>16)&0xFF].Yval) << 16) |
					((YUVPalette[(tm1>>24)].Yval) << 24);
				tm2 = *(pnext+1);
				*(U32 *)(YPlane+4) =
					YUVPalette[tm2&0xFF].Yval                 |
					((YUVPalette[(tm2>>8)&0xFF].Yval) << 8)   |
					((YUVPalette[(tm2>>16)&0xFF].Yval) << 16) |
					((YUVPalette[(tm2>>24)].Yval) << 24);
				if (0 == (k&1)) {
					*(U32 *)UPlane =
						YUVPalette[tm1&0xFF].Uval                 |
						((YUVPalette[(tm1>>16)&0xFF].Uval) << 8)  |
						((YUVPalette[tm2&0xFF].Uval) << 16)       |
						((YUVPalette[(tm2>>16)&0xFF].Uval) << 24);
					*(U32 *)VPlane =
						YUVPalette[tm1&0xFF].Vval                 |
						((YUVPalette[(tm1>>16)&0xFF].Vval) << 8)  |
						((YUVPalette[tm2&0xFF].Vval) << 16)       |
						((YUVPalette[(tm2>>16)&0xFF].Vval) << 24);
					UPlane +=4; VPlane += 4;
				}
			}
			if (i & 0x4) {
				tm = *pnext++;
				*(U32 *)YPlane =
					YUVPalette[tm&0xFF].Yval                 |
					((YUVPalette[(tm>>8)&0xFF].Yval) << 8)   |
					((YUVPalette[(tm>>16)&0xFF].Yval) << 16) |
					((YUVPalette[(tm>>24)].Yval) << 24);
				YPlane += 4;
				if (0 == (k&1)) {
					*(U16 *)UPlane =
						YUVPalette[tm&0xFF].Uval                 |
						((YUVPalette[(tm>>16)&0xFF].Uval) << 8);
					*(U16 *)VPlane =
						YUVPalette[tm&0xFF].Vval                 |
						((YUVPalette[(tm>>16)&0xFF].Vval) << 8);
					UPlane += 2; VPlane += 2;
				}
			}
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			YPlane += byte_ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUT8toYUV12()

#endif // } 0

__declspec(naked)
void P5_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	shr		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	shr		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	shr		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	shr		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// Compute_YUVPalette(lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	push	eax
	call	Compute_YUVPalette
	pop		eax

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = OutputWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		ebp, [esp + OUTPUT_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm = *pnext
// *(U32 *)YPlane =
//  YUVPalette[tm&0xFF].Yval                 |
//  ((YUVPalette[(tm>>8)&0xFF].Yval) << 8)   |
//  ((YUVPalette[(tm>>16)&0xFF].Yval) << 16) |
//  ((YUVPalette[(tm>>24)].Yval) << 24)
	mov		eax, [esi]
	 nop
	mov		ebx, eax
	 mov	ecx, eax
	shr		ebx, 8
	 mov	edx, eax
	shr		ecx, 16
	 and	eax, 0xFF
	shr		edx, 24
	 and	ebx, 0xFF
	and		ecx, 0xFF
	 and	edx, 0xFF
	mov		al, [YUVPalette+eax*4].Yval
	 mov	bl, [YUVPalette+ebx*4].Yval
	shl		ebx, 8
	 mov	cl, [YUVPalette+ecx*4].Yval
	shl		ecx, 16
	 mov	dl, [YUVPalette+edx*4].Yval
	shl		edx, 24
	 or		eax, ebx
	or		eax, ecx
	 mov	ebx, [esp + LOOP_K]
	or		eax, edx
	 and	ebx, 1
	mov		[edi], eax
	 jnz	Lno_luma
// tm = *pnext
// *(U32 *)UPlane =
//  YUVPalette[tm&0xFF].Uval                 |
//	((YUVPalette[(tm>>16)&0xFF].Uval) << 8)
// *(U32 *)VPlane =
//  YUVPalette[tm&0xFF].Vval                 |
//  ((YUVPalette[(tm>>16)&0xFF].Vval) << 8)
// UPlane +=2
// VPlane += 2
	mov		eax, [esi]
	 nop
	mov		ebx, eax
	 and	eax, 0xFF
	shr		ebx, 16
	 mov	ecx, [esp + UPLANE]
	mov		ax, [YUVPalette+eax*4].UVval
	 and	ebx, 0xFF
	mov		edx, [esp + VPLANE]
	 add	ecx, 2
	mov		bx, [YUVPalette+ebx*4].UVval
	 add	edx, 2
	mov		[ecx - 2], al
	 mov	[esp + UPLANE], ecx
	mov		[edx - 2], ah
	 mov	[esp + VPLANE], edx
	mov		[ecx - 1], bl
	 mov	[edx - 1], bh

Lno_luma:
// pnext++
// YPlane += 4
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebp, 4
	jnz		L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	shr		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   gmlim  $
// $Date:   17 Apr 1997 16:55:12  $
// $Archive:   S:\h26x\src\enc\e3rtp.h_v  $
// $Header:   S:\h26x\src\enc\e3rtp.h_v   1.4   17 Apr 1997 16:55:12   gmlim  $
// $Log:   S:\h26x\src\enc\e3rtp.h_v  $
;// 
;//    Rev 1.4   17 Apr 1997 16:55:12   gmlim
;// Added H263RTP_GetMaxBsInfoStreamSize().
;// 
;//    Rev 1.3   05 Dec 1996 17:03:44   GMLIM
;// 
;// Changed the way RTP packetization was done to guarantee proper packet
;// size.
;// 
;//    Rev 1.2   16 Sep 1996 16:50:26   CZHU
;// changed RTP BS Init for smaller packet size
;// 
;//    Rev 1.1   29 Aug 1996 09:30:38   CZHU
;// 
;// Added a function checking intra-GOB
;// 
;//    Rev 1.0   22 Apr 1996 17:09:46   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.4   01 Mar 1996 16:36:30   DBRUCKS
;// 
;// add unPacketSize parameter to H263RTP_InitBsInfoStream
;// 
;//    Rev 1.3   23 Feb 1996 16:18:46   CZHU
;// No change.
;// 
;//    Rev 1.2   15 Feb 1996 12:00:48   CZHU
;// ean up
;// Clean up
;// 
;//    Rev 1.1   14 Feb 1996 14:59:38   CZHU
;// Support both mode A and mode B payload modes.
;// 
;//    Rev 1.0   12 Feb 1996 17:04:46   CZHU
;// Initial revision.
;// 
;//    Rev 1.3   11 Dec 1995 14:53:24   CZHU
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H263_RTP_INC_
#define  _H263_RTP_INC_

extern  I32 H263RTP_InitBsInfoStream( LPCODINST,T_H263EncoderCatalog *);
extern void H263RTP_ResetBsInfoStream(T_H263EncoderCatalog *);
extern I32  H263RTP_UpdateBsInfo(T_H263EncoderCatalog *,T_MBlockActionStream *,U32,U32,U32,U8 *,U32);
extern  void H263RTP_TermBsInfoStream(T_H263EncoderCatalog * );
extern  U32 H263RTP_AttachBsInfoStream(T_H263EncoderCatalog * ,U8 *, U32);
extern  U32 H263RTPFindMVs (T_H263EncoderCatalog *, T_MBlockActionStream * , U32 ,U32, I8 [2]);

//Chad intra GOB
extern BOOL IsIntraCoded( T_H263EncoderCatalog *, U32);
extern U32 H263RTP_GetMaxBsInfoStreamSize(T_H263EncoderCatalog *EC);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\exbitsio.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbitsio.cpp
 *
 * Description:
 *		Routines to write fields to a bit stream buffer.
 *
 * Routines:						Prototypes in:
 *		BSWriteField					e3enc.h
 */

//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 15:32:50  $
// $Archive:   S:\h26x\src\enc\exbitsio.cpv  $
// $Header:   S:\h26x\src\enc\exbitsio.cpv   1.5   27 Dec 1995 15:32:50   RMCKENZX  $
// $Log:   S:\h26x\src\enc\exbitsio.cpv  $
// 
//    Rev 1.5   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
//    Rev 1.4   09 Nov 1995 14:11:22   AGUPTA2
// PB-frame+performance+structure enhancements.
// 
//    Rev 1.3   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.2   25 Aug 1995 11:54:06   TRGARDOS
// 
// Debugged PutBits routine.
// 
//    Rev 1.1   14 Aug 1995 11:35:18   TRGARDOS
// y
// Finished writing picture frame header
// 
//    Rev 1.0   11 Aug 1995 17:28:34   TRGARDOS
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

/*************************************************************************
 * BSWriteField
 *
 * Write a field value of a specified size of bits into the
 * bitstream at the specified byte and bit offset.
 *
 * It is assumed that the field value is right justified
 * in the parameter fieldval, and field len never exceeds
 * 25.
 *
 * Returns void
 */
void PutBits(
	unsigned int fieldval,
	unsigned int fieldlen,
	unsigned char **pbs,
	unsigned char *bitoffset
	)
{
  unsigned int wordval;

  // Shift field left so that the field starts at
  // the current bit offset in the dword.
  fieldval <<= (32 - fieldlen) - *bitoffset;

  // Read in next dword starting at current byte position.
  wordval = (**pbs << 24) + (*(*pbs+1) << 16) + (*(*pbs+2) << 8) + *(*pbs+3);

  // Bitwise or the two dwords.
  wordval |= fieldval;

  // Write word back into memory, big-endian.
  *(*pbs+3) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+2) = wordval & 0xff;
  wordval >>= 8;
  *(*pbs+1) = wordval & 0xff;
  wordval >>= 8;
  **pbs = wordval & 0xff;

  // update byte and bit counters.
  *pbs += (*bitoffset + fieldlen) >> 3;
  *bitoffset = (*bitoffset + fieldlen) % 8;

} // end of BSWriteField function.


/*************************************************************
 *  CopyBits
 *
 ************************************************************/
void CopyBits(
    U8        **pDestBS,
    U8         *pDestBSOffset,
    const U8   *pSrcBS,
    const U32   uSrcBitOffset,
    const U32   uBits
)
{
    U32       bitstocopy, bitsinbyte;
    const U8 *sptr;

    if (uBits == 0) goto done;

    bitstocopy = uBits;
    sptr = pSrcBS + (uSrcBitOffset >> 3);
    bitsinbyte = 8 - (uSrcBitOffset & 0x7);
    if (bitsinbyte <= bitstocopy)
    {
        PutBits((*sptr) & ((1 << bitsinbyte) - 1),
                bitsinbyte, pDestBS, pDestBSOffset);
        bitstocopy -= bitsinbyte;
        sptr++;
    }
    else
    {
        PutBits( (*sptr >> (8 - (uSrcBitOffset & 0x7) - bitstocopy))
                 & ((1 << bitstocopy) - 1),
                bitstocopy, pDestBS, pDestBSOffset);
        goto done;
    }
    while (bitstocopy >= 8)
    {
        PutBits(*sptr, 8, pDestBS, pDestBSOffset);
        bitstocopy -= 8;
        sptr++;
    }
    if (bitstocopy > 0)
    {
        PutBits((*sptr)>>(8-bitstocopy), bitstocopy, pDestBS, pDestBSOffset);
    }

done:
    return;
}  //  CopyBits function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
//
// e3rtp.cpp
//
// Description:
//      This file is for RTP payload generation.  See EPS for details.
//
// Routines:
//      getRTPPacketSizeThreshold
//      H263RTP_InitBsInfoStream
//      H263RTP_ResetBsInfoStream
//      H263RTPFindMVs
//      H263RTP_UpdateBsInfo
//      H263RTP_TermBsInfoStream
//      H263RTP_AttachBsInfoStream
//      IsIntraCoded
//      H263RTP_GetMaxBsInfoStreamSize()
//
// -------------------------------------------------------------------------
//
// $Author:   gmlim  $
// $Date:   17 Apr 1997 16:54:02  $
// $Archive:   S:\h26x\src\enc\e3rtp.cpv  $
// $Header:   S:\h26x\src\enc\e3rtp.cpv   1.14   17 Apr 1997 16:54:02   gmlim  $
// $Log:   S:\h26x\src\enc\e3rtp.cpv  $
// 
//    Rev 1.14   17 Apr 1997 16:54:02   gmlim
// Added H263RTP_GetMaxBsInfoStreamSize().
// 
//    Rev 1.13   06 Mar 1997 16:06:26   gmlim
// Changed RTP to generate mode A packet at the beginning of a GOB.
// 
//    Rev 1.12   18 Feb 1997 15:33:06   CZHU
// Changed UpdateBSInfo() not to force packet at GOB all the time.
// 
//    Rev 1.11   07 Feb 1997 10:57:28   CZHU
// Added three entry in EC to remove static variable used in e3rtp.cpp
// 
//    Rev 1.10   24 Jan 1997 13:33:36   CZHU
// 
// Stop generating more packets when internal buffer is to overflow.
// 
//    Rev 1.9   11 Dec 1996 10:38:24   gmlim
// Removed unused pBsInfoStream from H263RTP_AttachBsInfoStream().
// 
//    Rev 1.8   05 Dec 1996 17:01:08   GMLIM
// Changed the way RTP packetization was done to guarantee proper packet
// size.  Created H263RTP_ResetBsInfoStream() and replaced two previous
// bitstream info update fucntions with H263RTP_UpdateBsInfo().
// 
//    Rev 1.7   06 Nov 1996 16:31:06   gmlim
// Removed H263ModeC def.s and did some cleanup.
// 
//    Rev 1.6   03 Nov 1996 18:44:42   gmlim
// Added support for mode c.
// 
//    Rev 1.5   24 Oct 1996 16:27:50   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.4   25 Sep 1996 10:55:28   CZHU
// Added checking null pointers at allocation and before use.
// 
//    Rev 1.3   16 Sep 1996 16:50:48   CZHU
// changed RTP BS Init for smaller packet size
// 
//    Rev 1.2   29 Aug 1996 09:31:00   CZHU
// Added a function checking intra-GOB
// 
//    Rev 1.1   28 Apr 1996 20:09:04   BECHOLS
// 
// Removed RTP_HEADER IFDEFs.
// 
//    Rev 1.0   22 Apr 1996 17:46:10   BECHOLS
// Initial revision.
// 
//    Rev 1.7   10 Apr 1996 13:33:04   CZHU
// Moved packet loss sim to c3rtp.cpp
// 
//    Rev 1.6   29 Mar 1996 13:37:42   CZHU
// 
//    Rev 1.5   01 Mar 1996 16:37:08   DBRUCKS
// change to use 3/4ths of packet size as the threshold 
// change to make packet size a parameter
// 
//    Rev 1.4   23 Feb 1996 17:36:48   CZHU
// 
//    Rev 1.3   23 Feb 1996 16:18:28   CZHU
// integrate with build 29
// 
//    Rev 1.2   15 Feb 1996 12:00:42   CZHU
// Clean up
// 
//    Rev 1.1   14 Feb 1996 14:59:36   CZHU
// Support both mode A and mode B payload modes.
// 
//    Rev 1.0   12 Feb 1996 17:04:44   CZHU
// Initial revision.
// 
//    Rev 1.5   25 Jan 1996 16:14:34   CZHU
// name changes
// 
//    Rev 1.4   15 Dec 1995 13:06:46   CZHU
// 
//    Rev 1.3   11 Dec 1995 14:52:42   CZHU
// Added support for per MB packetization
// 
//    Rev 1.2   04 Dec 1995 16:50:26   CZHU
// 
//    Rev 1.1   01 Dec 1995 15:53:52   CZHU
// Included Init() and Term() functions.
// 
//    Rev 1.0   01 Dec 1995 15:31:02   CZHU
// Initial revision.
** *************************************************************************/

#include "precomp.h"

#ifdef TRACK_ALLOCATIONS
char gsz1[32];
#endif

static U32 uBitOffset_currPacket;
static U8 *pBitStream_currPacket;
static U8 *pBitStream_lastPacket;

// ---------------------------------------------------------------------------
// getRTPPacketSizeThreshold()
// Helper function to calculate the threshold of packet size
// for given maximum packet size and data rate
// ---------------------------------------------------------------------------
 
static U32 getRTPPacketSizeThreshold(U32 uRequested)
{
    U32 uSize;
    // uSize = uRequested * 90 / 100;
    uSize = uRequested;
    ASSERT(uSize);
    return uSize;
}

// ---------------------------------------------------------------------------
// H263RTP_InitBsInfoStream()
// ---------------------------------------------------------------------------

I32 H263RTP_InitBsInfoStream(LPCODINST lpInst, T_H263EncoderCatalog *EC)
{
    U32 uBsInfoSize = getRTPBsInfoSize(lpInst);

	FX_ENTRY("H263RTP_InitBsInfoStream")

    if (EC->hBsInfoStream != NULL)
	{
        HeapFree(GetProcessHeap(), NULL, EC->pBaseBsInfoStream);
#ifdef TRACK_ALLOCATIONS
		// Track memory allocation
		RemoveName((unsigned int)EC->pBaseBsInfoStream);
#endif
	}

    EC->pBaseBsInfoStream = HeapAlloc(GetProcessHeap(), NULL, uBsInfoSize);

    if (EC->pBaseBsInfoStream == NULL)
    {
        lpInst->Configuration.bRTPHeader = FALSE;
        return FALSE;
    }

#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	wsprintf(gsz1, "E3RTP: %7ld Ln %5ld\0", uBsInfoSize, __LINE__);
	AddName((unsigned int)EC->pBaseBsInfoStream, gsz1);
#endif

    EC->hBsInfoStream = (void *) uBsInfoSize;
    EC->uPacketSizeThreshold = getRTPPacketSizeThreshold(lpInst->Configuration.unPacketSize);

	DEBUGMSG(ZONE_INIT, ("%s: BsInfoStream  initialized\r\n", _fx_));
   return TRUE;
}

// ---------------------------------------------------------------------------
// H263RTP_ResetBsInfoStream()
// ---------------------------------------------------------------------------

void H263RTP_ResetBsInfoStream(T_H263EncoderCatalog *EC)
{
	FX_ENTRY("H263RTP_ResetBsInfoStream")

    EC->pBsInfoStream = EC->pBaseBsInfoStream;
    EC->uBase = 0;
    EC->uNumOfPackets = 0;

    uBitOffset_currPacket = 0;
    pBitStream_currPacket = EC->PictureHeader.PB ? EC->pU8_BitStrCopy :
                                                   EC->pU8_BitStream;
    pBitStream_lastPacket = pBitStream_currPacket;

	DEBUGMSG(ZONE_ENCODE_RTP, ("%s: BsInfoStream  reset\r\n", _fx_));
}

// ---------------------------------------------------------------------------
// H263RTPFindMVs()
// Find motion vector predictors for current MB and return in arraryMVs[]
// ---------------------------------------------------------------------------

U32 H263RTPFindMVs(
    T_H263EncoderCatalog * EC, 
    T_MBlockActionStream * pMBlockAction,
    U32 uMBA,
    U32 uGOBN,
    I8 arrayMVs[2]
)
{
    if (!uMBA)
    {
        arrayMVs[0] = 0;
        arrayMVs[1] = 0;
    }
    else // revisit for AP
    {
        arrayMVs[0] = pMBlockAction[-1].BlkY1.PHMV;
        arrayMVs[1] = pMBlockAction[-1].BlkY1.PVMV;
    }
    return TRUE;
 }

// ---------------------------------------------------------------------------
// H263RTP_UpdateBsInfo()
// This routine is called at the beginning of each MB to update the bitstream
// info buffer
// ---------------------------------------------------------------------------

I32 H263RTP_UpdateBsInfo(
    T_H263EncoderCatalog *EC,
    T_MBlockActionStream *pMBlockAction,
    U32 uQuant, 
    U32 uMBA,
	U32 uGOBN,
    U8 *pBitStream,
	U32 uBitOffset
)
{
    U32 uNewBytes;
    T_RTP_H263_BSINFO *pBsInfoStream;
    I8 arrayMVs[2];

	FX_ENTRY("H263RTP_UpdateBsInfo")

    if (EC->pBsInfoStream == NULL) return FALSE;

    if (uMBA)
    {
        if ((U32) (pBitStream - pBitStream_lastPacket) <
                                                    EC->uPacketSizeThreshold)
        {
            pBitStream_currPacket = pBitStream;
            uBitOffset_currPacket = uBitOffset;
            return TRUE;
        }

        pBsInfoStream           = (T_RTP_H263_BSINFO *) EC->pBsInfoStream;
        pBsInfoStream->u8Mode   = EC->PictureHeader.PB ? RTP_H263_MODE_C :
                                                         RTP_H263_MODE_B;
        pBsInfoStream->u8MBA    = (U8) uMBA;
        pBsInfoStream->u8Quant  = (U8) uQuant;
        pBsInfoStream->u8GOBN   = (U8) uGOBN;
        H263RTPFindMVs(EC, pMBlockAction, uMBA, uGOBN, arrayMVs);
        pBsInfoStream->i8HMV1   = arrayMVs[0];
        pBsInfoStream->i8VMV1   = arrayMVs[1];
    }
    else
    {
        pBsInfoStream           = (T_RTP_H263_BSINFO *) EC->pBsInfoStream;
        pBsInfoStream->u8Mode   = RTP_H263_MODE_A;
        pBsInfoStream->u8MBA    = 0;
        pBsInfoStream->u8Quant  = 0;
        pBsInfoStream->u8GOBN   = (U8) uGOBN;
        pBsInfoStream->i8HMV1   = 0;
        pBsInfoStream->i8VMV1   = 0;
    }

    uNewBytes = (U32) (pBitStream_currPacket - pBitStream_lastPacket);
    EC->uBase += uNewBytes;

    pBsInfoStream->uBitOffset   = uBitOffset_currPacket + (EC->uBase << 3);
    pBsInfoStream->i8HMV2       = 0;
    pBsInfoStream->i8VMV2       = 0;
    pBsInfoStream->uFlags       = 0;

	DEBUGMSG(ZONE_ENCODE_RTP, ("%s: Flag=%d,Mode=%d,GOB=%d,MB=%d,Quant=%d,BitOffset=%d,pBitStream=%lx,LastPacketSz=%d B\r\n", _fx_, pBsInfoStream->uFlags, pBsInfoStream->u8Mode, pBsInfoStream->u8GOBN, pBsInfoStream->u8MBA, pBsInfoStream->u8Quant, pBsInfoStream->uBitOffset, (U32) pBitStream_currPacket, uNewBytes));

    // update packet pointers
    pBitStream_lastPacket = pBitStream_currPacket;
    pBitStream_currPacket = pBitStream;
    uBitOffset_currPacket = uBitOffset;

    // create a new packet: update counter and pointer
    EC->uNumOfPackets ++;
    EC->pBsInfoStream = (void *) ++ pBsInfoStream;
    ASSERT((DWORD) EC->hBsInfoStream >
           (DWORD) EC->pBsInfoStream - (DWORD) EC->pBaseBsInfoStream);

    return TRUE;

} // H263RTP_UpdateBsInfo()

// ---------------------------------------------------------------------------
// H263RTP_TermBsInfoStream()
// ---------------------------------------------------------------------------

void H263RTP_TermBsInfoStream(T_H263EncoderCatalog * EC)
{
	FX_ENTRY("H263RTP_TermBsInfoStream")

	DEBUGMSG(ZONE_INIT, ("%s: BsInfoStream freed\r\n", _fx_));

	HeapFree(GetProcessHeap(), NULL, EC->pBaseBsInfoStream);
#ifdef TRACK_ALLOCATIONS
	// Track memory allocation
	RemoveName((unsigned int)EC->pBaseBsInfoStream);
#endif
	EC->hBsInfoStream= NULL;
	return;
}


// ---------------------------------------------------------------------------
// H263RTP_AttachBsInfoStream()
// ---------------------------------------------------------------------------

U32 H263RTP_AttachBsInfoStream(
    T_H263EncoderCatalog * EC,
    U8 *lpOutput,
    U32 uSize
)
{
    U32 uIncreasedSize;
    U8 *lpAligned;
    T_H263_RTP_BSINFO_TRAILER BsInfoTrailer;

    // build bsinfo for the last packets
    BsInfoTrailer.uVersion        = H263_RTP_PAYLOAD_VERSION;
    BsInfoTrailer.uFlags          = 0;
    BsInfoTrailer.uUniqueCode     = H263_RTP_BS_START_CODE;
    BsInfoTrailer.uCompressedSize = uSize;
    BsInfoTrailer.uNumOfPackets   = EC->uNumOfPackets;
    BsInfoTrailer.u8Src           = EC->FrameSz;
    BsInfoTrailer.u8TR            = EC->PictureHeader.TR;

    if (EC->PictureHeader.PicCodType == INTRAPIC)
        BsInfoTrailer.uFlags |= RTP_H26X_INTRA_CODED;

    if (EC->PictureHeader.PB == ON)
    {
        BsInfoTrailer.u8TRB   = EC->PictureHeader.TRB;
        BsInfoTrailer.u8DBQ   = EC->PictureHeader.DBQUANT;
        BsInfoTrailer.uFlags |= RTP_H263_PB;
    }
    else
    {
        BsInfoTrailer.u8TRB   = 0;
        BsInfoTrailer.u8DBQ   = 0;
    }

    if (EC->PictureHeader.AP == ON)
        BsInfoTrailer.uFlags |= RTP_H263_AP;

    if (EC->PictureHeader.SAC == ON)
        BsInfoTrailer.uFlags |= RTP_H263_SAC;

    // update size field for the last BsInfoTrailer
    uIncreasedSize = EC->uNumOfPackets * sizeof(T_RTP_H263_BSINFO);

    // copy extended BS info and trailer to the given output buffer
    lpAligned = (U8 *) ((U32) (lpOutput + uSize + 3) & 0xfffffffc);
    memcpy(lpAligned, EC->pBaseBsInfoStream, uIncreasedSize);
    memcpy(lpAligned + uIncreasedSize, &BsInfoTrailer,
                                       sizeof(T_H263_RTP_BSINFO_TRAILER));

    return(uIncreasedSize + sizeof(T_H263_RTP_BSINFO_TRAILER)
                          + (U32) (lpAligned - lpOutput - uSize));
}

// ---------------------------------------------------------------------------
// IsIntraCoded(EC, GOB)
// return TRUE if current GOB is intra coded.
// other wise FALSE;
// Chad for intra GOB
// ---------------------------------------------------------------------------

BOOL IsIntraCoded(T_H263EncoderCatalog * EC, U32 Gob)
{
    U32 uGobMax, uGobMin;

    if (EC->uNumberForcedIntraMBs)
    {
        // for those GOBs are forced intra
        uGobMax = EC->uNextIntraMB / EC->NumMBPerRow;
        uGobMin = uGobMax - EC->uNumberForcedIntraMBs / EC->NumMBPerRow;

        if (Gob >= uGobMin && Gob < uGobMax)
            return TRUE;
	}
	return FALSE;
}

// ---------------------------------------------------------------------------
//  H263RTP_GetMaxBsInfoStreamSize()
//  return max size of EBS with trailer + 3 allignment bytes - 4/16/97 Gim
// ---------------------------------------------------------------------------

U32 H263RTP_GetMaxBsInfoStreamSize(T_H263EncoderCatalog *EC)
{
    return (EC->uNumOfPackets * sizeof(T_RTP_H263_BSINFO) +
                                sizeof(T_H263_RTP_BSINFO_TRAILER) + 3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3stat.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
 ****************************************************************************
 * 
 *  e3stat.cpp
 *
 *  Description:
 *		This modules contains the encoder statistics routines
 *
 *	Routines:				    All routines declared in e3stat.h
 *		StatsFrameSize  	
 *		InitFrameSizeStats
 *		OutputFrameSizeStats
 *		
 *		StatsUsedQuant
 *		InitQuantStats
 *		OutputQuantStats
 *		
 *		InitPSNRStats
 *		OutputPSNRStats
 *		InitStats		
 *		IncrementPSNRCounter		
 *		ComputeYPSNR
 *		ComputeVPSNR
 *		ComputeUPSNR
 *
 *  Data:

// $Header:   R:\h26x\h26x\src\enc\e3stat.cpv   1.0   22 Apr 1996 17:46:22   BECHOLS  $
// $Log:   R:\h26x\h26x\src\enc\e3stat.cpv  $
// 
//    Rev 1.0   22 Apr 1996 17:46:22   BECHOLS
// Initial revision.
// 
//    Rev 1.1   08 Mar 1996 14:14:26   DBRUCKS
// add framesize stats and fixed PSNR to use energy instead of the signal
// 
//    Rev 1.0   01 Mar 1996 16:34:40   DBRUCKS
// Initial revision.
*/

#include "precomp.h"

#ifdef ENCODE_STATS


    #define MAX_FRAME_SIZE_INDEX	255
	static U32 uArrayFrameSize[MAX_FRAME_SIZE_INDEX+1];
	static U32 uArrayBitStreamSize[MAX_FRAME_SIZE_INDEX+1];
	static int iFrameSizeIndex = 0;

	static U32 uQuantCount[32];

	#define MAX_PSNR_INDEX	255
	static double dArrayYPSNR[MAX_PSNR_INDEX+1];
	static double dArrayVPSNR[MAX_PSNR_INDEX+1];
	static double dArrayUPSNR[MAX_PSNR_INDEX+1];
	static int iPSNRIndex = 0;

	static double ComputePSNR(U8 * pu8Input,
							  int iInputPitch,
							  U8 * pu8Output,
							  int iOutputPitch,
							  UN unWidth,
							  UN unHeight);

	 
	/************************************************************************
	 *
	 *  StatsFrameSize
	 *
	 *  Save the frame size information - with possbily different bitstream
	 *  and frame sizes.  
	 */
	extern void StatsFrameSize(U32 uBitStreamSize, U32 uFrameSize)
	{
		ASSERT(uFrameSize >= uBitStreamSize);

		if (iFrameSizeIndex <= MAX_FRAME_SIZE_INDEX)
		{
			uArrayBitStreamSize[iFrameSizeIndex] = uBitStreamSize;
			uArrayFrameSize[iFrameSizeIndex] = uFrameSize;
			iFrameSizeIndex++; /* can grow to one larger than MAX_FRAME_SIZE_INDEX */
		}
	} /* end StatsFrameSize() */

	/************************************************************************
	 *
	 *  InitFrameSizeStats
	 */
	extern void InitFrameSizeStats()
	{
		int i;

		for (i = 0; i <= MAX_FRAME_SIZE_INDEX ; i++)
		{
			uArrayFrameSize[i] = 0;
			uArrayBitStreamSize[i] = 0;
		}
		iFrameSizeIndex = 0;
	} /* end InitFrameSizeStats() */

	/************************************************************************
	 *
	 *  OutputFrameSizeStats
	 */
	extern void OutputFrameSizeStats(char * filename)
	{
		U32 uSumBitStream;
		U32 uSumFrame;
		FILE * fp;
		int i;

		FX_ENTRY("OutputFrameSizeStats")

		ASSERT(iFrameSizeIndex <= (MAX_FRAME_SIZE_INDEX+1));
		fp = fopen(filename, "a");
		if (fp == NULL)
		{
			ERRORMESSAGE(("%s: Error opening stats file\r\n", _fx_));
		}
		else
		{
			uSumBitStream = 0;
			uSumFrame = 0;
			for (i = 0; i < iFrameSizeIndex ; i++)
			{
				uSumFrame += uArrayFrameSize[i];
				uSumBitStream += uArrayBitStreamSize[i];
				if (uArrayFrameSize[i] != uArrayBitStreamSize[i])
				{
					fprintf(fp,	"Frame[%d] Sizes: Frame=%d BitStream=%d Other=%d\n",
						    i, (int) uArrayFrameSize[i], (int) uArrayBitStreamSize[i], 
						    (int) (uArrayFrameSize[i] - uArrayBitStreamSize[i]));
				}
				else
				{
					fprintf(fp,"Frame[%d] Size=%d\n", (int) i, (int) uArrayFrameSize[i]);
				}
			}
			if (iFrameSizeIndex > 0)
			{
				if (uSumFrame != uSumBitStream)
				{
					fprintf(fp,"Count = %ld Average Sizes: Frm=%f BS=%f Other=%f\n",
						    (long) iFrameSizeIndex, 
						    ((float)uSumFrame)/((float)iFrameSizeIndex), 
						    ((float)uSumBitStream)/((float)iFrameSizeIndex),
						    ((float)(uSumFrame - uSumBitStream))/((float)iFrameSizeIndex)); 
				}
				else
				{
					fprintf(fp,"Count = %ld Average Size=%f\n", (long) iFrameSizeIndex, 
						    ((float)uSumFrame)/((float)iFrameSizeIndex));
				}
			}
			else
			{
				fprintf(fp,"No frame size statistics available\n");
			}
			fclose(fp);
		}
	} /* end OutputFrameSizeStats() */

	/************************************************************************
	 *
	 *  InitQuantStats
	 */
	extern void InitQuantStats()
	{
		int i;
		for (i = 0 ; i < 32 ; i++)
		{
			uQuantCount[i] = 0;
		}
	} /* end InitQuantStats() */

	/************************************************************************
	 *
	 *  StatsUsedQuant
	 */
	extern void StatsUsedQuant(
		int iQuant)
	{
		ASSERT(iQuant >= 1 && iQuant <= 31);
	 	uQuantCount[iQuant]++;
	} /* end StatsUsedQuant() */

	/************************************************************************
	 *
	 *  OutputQuantStats
	 */
	extern void OutputQuantStats(char * filename)
	{
		U32 uCount;
		U32 uTotal;
		FILE * fp;
		int i;

		FX_ENTRY("OutputQuantStats")

		fp = fopen(filename, "a");
		if (fp == NULL)
		{
			ERRORMESSAGE(("%s: Error opening stats file\r\n", _fx_));
		}
		else
		{
			uCount = 0;
			uTotal = 0;
			for (i = 0; i < 32 ; i++)
			{
				if (uQuantCount[i] > 0)
				{
					uCount += uQuantCount[i];
					uTotal += (uQuantCount[i] * i);
					fprintf(fp,"Quant[%d] = %ld\n", 
						    (int)i, (long) uQuantCount[i]);
				}
			}
			if (uCount > 0)
			{
				fprintf(fp,"Count = %ld Average = %f\n",
				        (long) uCount, ((float)uTotal)/((float)uCount));
			}
			else
			{
				fprintf(fp,"No quantization statistics available\n");
			}
			fclose(fp);
		}
	} /* end OutputQuantStats() */

	/************************************************************************
	 *
	 *  InitPSNRStats - initialize the PSNR data structures
	 */
	extern void InitPSNRStats()
	{
		int i;
		for (i = 0; i <= MAX_PSNR_INDEX; i++)
		{
			dArrayYPSNR[i] = 0.0;
			dArrayVPSNR[i] = 0.0;
			dArrayUPSNR[i] = 0.0;
		}
		iPSNRIndex = 0;
	} /* end InitPSNRStats() */

	/************************************************************************
	 * 
	 *  OutputPSNRStats - output the PSNR data to the specified file
	 */
	extern void OutputPSNRStats(
	    char * filename)
	{
		int i;
		FILE * fp;
		double dYTotal;
		double dVTotal;
		double dUTotal;

		FX_ENTRY("OutputPSNRStats")

		ASSERT(iPSNRIndex <= (MAX_PSNR_INDEX+1));

		fp = fopen(filename, "a");
		if (fp == NULL)
		{
			ERRORMESSAGE(("%s: Unable to open PSNR output file\r\n", _fx_));
		}
		else
		{
			if (iPSNRIndex <= 0)
			{
				fprintf(fp,"No PSNR data available\n");
			}
			else
			{
				dYTotal = 0.0;
				dVTotal = 0.0;
				dUTotal = 0.0;
				for (i = 0; i < iPSNRIndex ; i++)
				{
					dYTotal += dArrayYPSNR[i];
					dVTotal += dArrayVPSNR[i];
					dUTotal += dArrayUPSNR[i];
					fprintf(fp, "YVU#%d = %f %f %f\n", (int)i,
							dArrayYPSNR[i],dArrayVPSNR[i],dArrayUPSNR[i]);
				}
				fprintf(fp, "Average = %f %f %f\n",
						dYTotal/((double)iPSNRIndex),
						dVTotal/((double)iPSNRIndex),
						dUTotal/((double)iPSNRIndex));
			}
			fclose(fp);
		}
	} /* end OutputPSNRStats */

	/********************************************************************
	 *
	 *  IncrementPSNRCounter()
	 */
	extern void IncrementPSNRCounter()
	{
	 	if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
	 		iPSNRIndex++;
		}
	} /* end IncrementPSNRCounter() */

	/************************************************************************
	 *
	 *  ComputeYPSNR - compute the Y PSNR Value
	 */
	extern void ComputeYPSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		double dPSNR;
		if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
			dPSNR = ComputePSNR(pu8Input,iInputPitch,
			                    pu8Output,iOutputPitch,
								unWidth,unHeight);
			dArrayYPSNR[iPSNRIndex] = dPSNR;
		}
	} /* end ComputeYPSNR() */

	/************************************************************************
	 *
	 *  ComputeVPSNR - compute the V PSNR Value
	 */
	extern void ComputeVPSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		double dPSNR;
		if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
			dPSNR = ComputePSNR(pu8Input,iInputPitch,
			                    pu8Output,iOutputPitch,
								unWidth,unHeight);
			dArrayVPSNR[iPSNRIndex] = dPSNR;
		}
	} /* end ComputeVPSNR() */

	/************************************************************************
	 *
	 *  ComputeUPSNR - compute the U PSNR Value
	 */
	extern void ComputeUPSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		double dPSNR;
		if (iPSNRIndex <= MAX_PSNR_INDEX)
		{
			dPSNR = ComputePSNR(pu8Input,iInputPitch,
			                    pu8Output,iOutputPitch,
								unWidth,unHeight);
			dArrayUPSNR[iPSNRIndex] = dPSNR;
		}
	} /* end ComputeUPSNR() */

	/***************************** STATIC ROUTINES *************************/

	/************************************************************************
	 *
	 *  ComputePSNR - compute Peek Signal to Noise Ratio over this plane
	 *
	 *						   255*255
	 *	PSNR = 10log   ----------------------------
	 *              10 SUM((I-O)(I-O))/Wdith*Height
	 */
	static double ComputePSNR(
		U8 * pu8Input,
		int iInputPitch,
		U8 * pu8Output,
		int iOutputPitch,
		UN unWidth,
		UN unHeight)
	{
		UN unW;
		UN unH;
		U32 uSum;
		double dMSE;
		double dPSNR;
		double dTemp;
		int iInput;
		int iOutput;
		int iDiff;
		int iSquareOfDiff;

		/* Obtain the sum of the square of the differences
		 */
		uSum = 0;
		for (unH = 0; unH < unHeight; unH++)
		{
			for (unW = 0; unW < unWidth; unW++)
			{
				iInput = (int)*pu8Input++;
				iOutput = (int)*pu8Output++;
				iDiff = iInput - iOutput;
				iSquareOfDiff = iDiff*iDiff;
				uSum += (U32) iSquareOfDiff;
			}
			pu8Input += (iInputPitch - (int)unWidth);
			pu8Output += (iOutputPitch - (int)unWidth);
		}

		/* Obtain the Mean Squared Error
		 */
		if (uSum == 0)
		{
			dMSE = 0.01; /* a non-zero value */
		}
		else
		{
			dMSE = ((double)uSum)/((double)(unWidth*unHeight));
		}

		/* Obtain PSNR
		 */
		dTemp = (255.0 * 255.0) / dMSE;
		dTemp = log10(dTemp);
		dPSNR = 10.0 * dTemp;

		return dPSNR;
	} /* end ComputePSNR() */

#endif /* ENCODE_STATS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3vlc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/***************************************************************************
 * $Header:   S:\h26x\src\enc\e3vlc.h_v   1.7   27 Dec 1995 15:32:58   RMCKENZX  $
 * $Log:   S:\h26x\src\enc\e3vlc.h_v  $
;// 
;//    Rev 1.7   27 Dec 1995 15:32:58   RMCKENZX
;// Added copyright notice
 ***************************************************************************/

#ifndef _E3VLC_H
#define _E3VLC_H

extern "C" U8 FLC_INTRADC[256];
extern "C" int VLC_TCOEF_TBL[64*12*2];
extern "C" int VLC_TCOEF_LAST_TBL[64*3*2];

/*
 * Define the TCOEF escape constant and field length.
 */
#define TCOEF_ESCAPE_FIELDLEN  7
#define TCOEF_ESCAPE_FIELDVAL  3

#define TCOEF_RUN_FIELDLEN  6
#define TCOEF_LEVEL_FIELDLEN  8

#endif _E3VLC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3stat.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  e3stat.h
 *
 *  Description:
 *		Interface to the encoder statistics functions
 *
 *		Activate with ENCODE_STATS
 */

/*
 * $Header:   R:\h26x\h26x\src\enc\e3stat.h_v   1.0   22 Apr 1996 17:10:10   BECHOLS  $
 * $Log:   R:\h26x\h26x\src\enc\e3stat.h_v  $
;// 
;//    Rev 1.0   22 Apr 1996 17:10:10   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.1   08 Mar 1996 14:13:36   DBRUCKS
;// add frame size stats for use with RTP headers
;// 
;//    Rev 1.0   01 Mar 1996 16:34:48   DBRUCKS
;// Initial revision.
 */

#ifndef __E3STAT_H__
#define __E3STAT_H__

	#ifdef ENCODE_STATS

		/* Frame Sizes
		 */
		extern void StatsFrameSize(U32 uBitStreamSize, U32 uFrameSize);
		extern void InitFrameSizeStats();
		extern void OutputFrameSizeStats(char * filename);

		/* Quantization
		 */
		extern void StatsUsedQuant(int iQuant);
		extern void InitQuantStats();
		extern void OutputQuantStats(char * filename);
 
 		/* PSNR
		 */
		extern void InitPSNRStats();
		extern void OutputPSNRStats(char * filename);
		extern void IncrementPSNRCounter();
		extern void ComputeYPSNR(U8 * pu8Input,
							  	 int iInputPitch,
							  	 U8 * pu8Output,
								 int iOutputPitch,
							     UN unWidth,
							     UN unHeight);
		extern void ComputeVPSNR(U8 * pu8Input,
							  	 int iInputPitch,
							  	 U8 * pu8Output,
								 int iOutputPitch,
							     UN unWidth,
							     UN unHeight);
		extern void ComputeUPSNR(U8 * pu8Input,
							  	 int iInputPitch,
							  	 U8 * pu8Output,
								 int iOutputPitch,
							     UN unWidth,
							     UN unHeight);
	
	#endif /* ENCODE_STATS */

#endif /* __E3STAT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\e3ycrcb.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {

/***************************************************
 * H26X_YVU9toYUV12()
 *  Convert from YVU9 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 * uv_plane_common()
 *  Helper function to convert V and U plane information.
 *  Since the process is similar for both planes, the
 *  conversion code was included in this subroutine.
 *
 ***************************************************/	

#define READ_DWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned int *)(src))), ((val) &= 0xFEFEFEFE), ((val) >>= 1))

#define WRITE_DWORD(dest,val) ((*(unsigned int *)(dest)) = (val))

#define AVERAGE_DWORDS(out,in1,in2)  ((out) = ((((in1) + (in2)) & 0xFEFEFEFE) >> 1))

#define DUP_LOWER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = (((val) & 0x000000FF) |	(((val) << 8) & 0x0000FF00) | \
							  	(((val) << 8) & 0x00FF0000) | (((val) << 16) & 0xFF000000)))

#define DUP_UPPER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = ((((val) >> 16) & 0x000000FF) |	(((val) >> 8) & 0x0000FF00) | \
							  	(((val) >> 8) & 0x00FF0000) | ((val) & 0xFF000000)))

static void C_uv_plane_common(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *psrc,
	U8 *Plane,
	const int pitch) {

U8	*pprev;
U8	*pnext = psrc + (lpbiInput->biWidth >> 2);
U8	*pdest_copy = Plane;
U8	*pdest_avg = Plane + pitch;
U8	t, tb1, tb2;
U32	t1, t2;
int i, j, k;
int dest_pitch_adj;
int widthx4 = ((OutputWidth >> 2) + 0x3) & ~0x3;
int heightx4 = 0;
int width_diff = 0;
int height_diff = 0;
int stretch = 0;
int flag = 0;
int NextSrcLine = 0;
int ChromaIters = 1;
int mark = (OutputHeight >> 2);
int byte_uvpitch_adj = 0;

	if (lpbiInput->biHeight > OutputHeight) {
		for (ChromaIters = 0, i = OutputHeight; i > 0; i -= 48) {
			ChromaIters += 2;
		}
		NextSrcLine = (lpbiInput->biWidth - OutputWidth) >> 2;
		stretch = (NextSrcLine ? 1 : 0);
		mark = 6 - stretch;
		flag = stretch;
	} else {
		width_diff = widthx4 - (OutputWidth >> 2);
		byte_uvpitch_adj -= width_diff;
		heightx4 = ((lpbiInput->biHeight >> 2) + 0x3) & ~0x3;
		height_diff = (heightx4 - (lpbiInput->biHeight >> 2)) << 1;
	}
	dest_pitch_adj = pitch - (widthx4 << 1);

	for (j = ChromaIters; j > 0; j--) {
		for (k = mark + (flag & 1); k > 0; k--) {
			if (!stretch && (1 == j) && (1 == k)) {
				pnext = psrc;
			}
			for (i = (OutputWidth >> 1); (i & ~0x7); i-=8, psrc+=4, pnext+=4,
												pdest_copy+=8, pdest_avg+=8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				DUP_LOWER_TWO_BYTES(pdest_copy,t1);
				DUP_UPPER_TWO_BYTES((pdest_copy+4),t1);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			if (i & 0x4) {
				t = *psrc++ >> 1;
				*(U16*)pdest_copy = t | (t<<8);
				t = (t + (*pnext++ >> 1)) >> 1;
				*(U16*)pdest_avg = t | (t<<8);
				t = *psrc++ >> 1;
				*(U16*)(pdest_copy+2) = t | (t<<8);
				t = (t + (*pnext++ >> 1)) >> 1;
				*(U16*)(pdest_avg+2) = t | (t<<8);
				pdest_copy += 4; pdest_avg += 4;
			}
			if (i & 0x2) {
				t = *psrc++ >> 1;
				*(U16*)pdest_copy = t | (t<<8);
				t = (t + (*pnext++ >> 1)) >> 1;
				*(U16*)pdest_avg = t | (t<<8);
				pdest_copy += 2; pdest_avg += 2;
			}
			if (width_diff) {
				tb1 = *(pdest_copy-1);
				tb2 = *(pdest_avg-1);
				*pdest_copy++ = tb1; *pdest_copy++ = tb1;
				*pdest_avg++ = tb2;  *pdest_avg++ = tb2;
				if ((width_diff-1) > 0) {
					*pdest_copy++ = tb1; *pdest_copy++ = tb1;
					*pdest_avg++ = tb2;  *pdest_avg++ = tb2;
				}
				if ((width_diff-2) > 0) {
					*pdest_copy++ = tb1; *pdest_copy++ = tb1;
					*pdest_avg++ = tb2;  *pdest_avg++ = tb2;
				}
			}
			psrc += NextSrcLine;
			pnext += NextSrcLine;
			pdest_copy = pdest_avg + dest_pitch_adj;
			pdest_avg = pdest_copy + pitch;
		}
		if (height_diff) {
			pprev =  pdest_copy - pitch;
			for (j = height_diff; j > 0; j--) {
				for (i = widthx4; i>0; i--) {
					*pdest_copy++ = *pprev++;
					*pdest_copy++ = *pprev++;
				}
				pprev += dest_pitch_adj;
				pdest_copy += dest_pitch_adj;
			}
		}
		if (stretch) {
			psrc -= (lpbiInput->biWidth >> 2);
			pnext -= (lpbiInput->biWidth >> 2);
			pdest_avg = pdest_copy;
			for (i = OutputWidth >> 1; i > 0; i -= 8, psrc += 4, pnext += 4,
                                                              pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += NextSrcLine;
			pnext += NextSrcLine;
			pdest_copy = pdest_avg + dest_pitch_adj;
			pdest_avg = pdest_copy + pitch;
			flag++;
		}
	}
}

void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch) {

U32	*pnext, *plast, *pbn;
U32 *pyprev, *pyspace;
U8  *pvsrc, *pusrc;
int t;
int i, j, k;
int NextLine;
int widthx16;
int heightx16;
int width_diff = 0;
int height_diff = 0;
int width_adj = 0;
int height_adj = 0;
int stretch = 0;
int aspect = 0;
int word_ypitch_adj = 0;
int LumaIters = 1;
int mark = OutputHeight;
int byte_ypitch_adj = pitch - OutputWidth;

	if (lpbiInput->biHeight > OutputHeight) {
		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) {
			LumaIters += 4;
		}
		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1;
		aspect = LumaIters;
		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1;
		stretch = 1;
		mark = 11;
	} else {
		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF;
		width_diff = widthx16 - OutputWidth;
		byte_ypitch_adj -= width_diff;
		word_ypitch_adj = byte_ypitch_adj >> 2;
		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF;
		height_diff = heightx16 - OutputHeight;
	}
	NextLine = width_adj >> 1;
	pnext = (U32 *)(lpInput + (lpbiInput->biWidth * height_adj) + width_adj);

	for (j = LumaIters; j > 0; j--) {
		for (k = mark; k > 0; k--) {
			for (i = OutputWidth; (i & ~0xF); i-=16, YPlane+=16) {
				*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+8) = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+12) = (*pnext++ >> 1) & 0x7F7F7F7F;
			}
			if (i & 0x8) {
				*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
				*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
				YPlane += 8;
			}
			if (i & 0x4) {
				*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
				YPlane += 4;
			}
			if (width_diff) {
				t = (*(YPlane-1)) << 24;
				t |= (t>>8) | (t>>16) | (t>>24);
				*(U32 *)YPlane = t;
				if ((width_diff-4) > 0) {
					*(U32 *)(YPlane + 4) = t;
				}
				if ((width_diff-8) > 0) {
					*(U32 *)(YPlane + 8) = t;
				}
				YPlane += width_diff;
			}
			pnext += NextLine;
			YPlane += byte_ypitch_adj;
		}
		if (height_diff) {
			pyprev =  (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			for (j = height_diff; j > 0; j--) {
				for (i = widthx16; i>0; i -=4) {
					*pyspace++ = *pyprev++;
				}
				pyspace += word_ypitch_adj;
				pyprev  += word_ypitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth >> 2);
			pbn = pnext;
			for (i = OutputWidth; i > 0; i -= 4, YPlane += 4, plast++, pbn++) {
				*(U32 *)YPlane =
					( ((*plast & 0xFCFCFCFC) >> 2) +
				      ((*pbn & 0xFCFCFCFC) >> 2) );
			}
			YPlane += byte_ypitch_adj;
		}
	}

	pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight);
	pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight>>2));
	t = ((lpbiInput->biWidth>>2) * (height_adj>>2)) + (width_adj>>2);
	pvsrc += t;
	pusrc += t;
	C_uv_plane_common(lpbiInput,OutputWidth,OutputHeight,pusrc,UPlane,pitch);
	C_uv_plane_common(lpbiInput,OutputWidth,OutputHeight,pvsrc,VPlane,pitch);
}

/***************************************************
 * H26X_YUY2toYUV12()
 *  Convert from YUY2 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 ***************************************************/

#if 0 // { 0

void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch) {

	U8	*pline;

	C_RGB_COLOR_CONVERT_INIT

	// Since YUY2 is so much like RGB (inverted image), the macro used to initialize
	// RGB conversion is also used here. However, there are some local variables
	// declared in C_RGB_COLOR_CONVERT_INIT that are not used here. The following
	// assignment is here simply to avoid warnings.
	t = t;

	pline = (U8 *)pnext;

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {
			for (i = OutputWidth; i > 0; i-=4, pline+=8, YPlane+=4) {
				*(U32 *)YPlane =             (*pline>>1) | ((*(pline+ 2)<<7)&0x7F00) |
					        ((*(pline+ 4)<<15)&0x7F0000) | ((*(pline+ 6)<<23)&0x7F000000);
				if (0 == (k & 1)) {
					*(U16 *)UPlane =        (*(pline+ 1)>>1) | ((*(pline+ 5)<<7)&0x7F00);
					*(U16 *)VPlane =        (*(pline+ 3)>>1) | ((*(pline+ 7)<<7)&0x7F00);
					UPlane += 2; VPlane += 2;
				}
			}
			pnext = (U32 *)pline;
			C_WIDTH_FILL
			if (stretch && (0 == k) && j) {
				for (i = OutputWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += BackTwoLines;
			pline = (U8 *)pnext;
			YPlane += byte_ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += byte_uvpitch_adj;
				VPlane += byte_uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}
	C_HEIGHT_FILL
	if (stretch) {
		for (i = OutputWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
}

#endif // } 0

__declspec(naked)
void P5_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch				|  +136
//	| VPlane			|  +132
//	| UPlane			|  +128
//	| YPlane			|  +124
//	| lpInput			|  +120
//	| OutputHeight		|  +116
//	| OutputWidth		|  +112
//	| lpbiInput			|  +108
//	----------------------------
//	| return addr		|  +104
//	| saved ebp			|  +100
//	| saved ebx			|  + 96
//	| saved esi			|  + 92 
//	| saved edi			|  + 88

//  | output_width		|  + 84
//  | pyprev			|  + 80
//  | pyspace			|  + 76
//  | pynext	        |  + 72
//  | puvprev			|  + 68
//  | puvspace			|  + 64
//	| i					|  + 60
//	| j					|  + 56
//	| k					|  + 52
//	| BackTwoLines		|  + 48
//	| widthx16			|  + 44
//	| heightx16			|  + 40
//	| width_diff		|  + 36
//	| height_diff		|  + 32
//	| width_adj			|  + 28
//	| height_adj		|  + 24
//	| stretch			|  + 20
//	| aspect			|  + 16
//	| LumaIters			|  + 12
//	| mark				|  +  8
//	| byte_ypitch_adj	|  +  4
//	| byte_uvpitch_adj	|  +  0

#define LOCALSIZE			 88

#define PITCH_PARM			136
#define VPLANE				132
#define UPLANE				128
#define YPLANE				124
#define LP_INPUT			120
#define OUTPUT_HEIGHT_WORD	116
#define OUTPUT_WIDTH_WORD	112
#define LPBI_INPUT			108

#define	OUTPUT_WIDTH		 84
#define	PYPREV				 80
#define	PYSPACE				 76
#define	PYNEXT				 72
#define	PUVPREV				 68
#define	PUVSPACE			 64
#define LOOP_I				 60
#define LOOP_J				 56	
#define LOOP_K				 52
#define BACK_TWO_LINES		 48
#define WIDTHX16			 44
#define HEIGHTX16			 40
#define WIDTH_DIFF			 36
#define HEIGHT_DIFF			 32
#define WIDTH_ADJ			 28
#define HEIGHT_ADJ			 24
#define STRETCH				 20
#define ASPECT				 16
#define LUMA_ITERS			 12
#define MARK				  8
#define BYTE_YPITCH_ADJ		  4
#define BYTE_UVPITCH_ADJ	  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

//	int width_diff = 0
//	int height_diff = 0
//	int width_adj = 0
//	int height_adj = 0
//	int stretch = 0
//	int aspect = 0

	xor		eax, eax
	mov		[esp + WIDTH_DIFF], eax
	mov		[esp + HEIGHT_DIFF], eax
	mov		[esp + WIDTH_ADJ], eax
	mov		[esp + HEIGHT_ADJ], eax
	mov		[esp + STRETCH], eax
	mov		[esp + ASPECT], eax

//	int LumaIters = 1

	inc		eax
	mov		[esp + LUMA_ITERS], eax

//	int mark = OutputHeight
//	int output_width = OutputWidth
//	int byte_ypitch_adj = pitch - OutputWidth
//	int byte_uvpitch_adj = pitch - (OutputWidth >> 1)

	xor		ebx, ebx
	mov		bx, [esp + OUTPUT_HEIGHT_WORD]
	mov		[esp + MARK], ebx
	mov		bx, [esp + OUTPUT_WIDTH_WORD]
	mov		[esp + OUTPUT_WIDTH], ebx
	mov		ecx, [esp + PITCH_PARM]
	mov		edx, ecx
	sub		ecx, ebx
	mov		[esp + BYTE_YPITCH_ADJ], ecx
	sar		ebx, 1
	sub		edx, ebx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//	if (lpbiInput->biHeight > OutputHeight)

	mov		ebx, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	cmp		ecx, edx
	jle		Lno_stretch

//		for (LumaIters = 0, i = OutputHeight; i > 0; i -= 48) LumaIters += 4

	xor		ecx, ecx
Lrepeat48:
	lea		ecx, [ecx + 4]
	sub		edx, 48
	jnz		Lrepeat48
	mov		[esp + LUMA_ITERS], ecx

//		aspect = LumaIters

	mov		[esp + ASPECT], ecx

//		width_adj = (lpbiInput->biWidth - OutputWidth) >> 1
//		width_adj *= lpbiInput->biBitCount
//		width_adj >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	sar		ecx, 1
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + WIDTH_ADJ], ecx
		
//		height_adj = (lpbiInput->biHeight - (OutputHeight - aspect)) >> 1

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	add		ecx, [esp + ASPECT]
	sar		ecx, 1
	mov		[esp + HEIGHT_ADJ], ecx

//		stretch = 1
//		mark = 11

	mov		ecx, 1
	mov		edx, 11
	mov		[esp + STRETCH], ecx
	mov		[esp + MARK], edx
	jmp		Lif_done

Lno_stretch:

//		widthx16 = (lpbiInput->biWidth + 0xF) & ~0xF
//		width_diff = widthx16 - OutputWidth

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + WIDTHX16], ecx
	mov		edx, [esp + OUTPUT_WIDTH]
	sub		ecx, edx
	mov		[esp + WIDTH_DIFF], ecx

//		byte_ypitch_adj -= width_diff

	mov		edx, [esp + BYTE_YPITCH_ADJ]
	sub		edx, ecx
	mov		[esp + BYTE_YPITCH_ADJ], edx

//		byte_uvpitch_adj -= (width_diff >> 1)

	mov		edx, [esp + BYTE_UVPITCH_ADJ]
	sar		ecx, 1
	sub		edx, ecx
	mov		[esp + BYTE_UVPITCH_ADJ], edx

//		heightx16 = (lpbiInput->biHeight + 0xF) & ~0xF
//		height_diff = heightx16 - OutputHeight

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	add		ecx, 00FH
	and		ecx, 0FFFFFFF0H
	mov		[esp + HEIGHTX16], ecx
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		ecx, edx
	mov		[esp + HEIGHT_DIFF], ecx

Lif_done:

//	BackTwoLines = -(lpbiInput->biWidth + OutputWidth);
//	BackTwoLines *= lpbiInput->biBitCount
//	BackTwoLines >>= 3

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		edx, [esp + OUTPUT_WIDTH]
	add		ecx, edx
	neg		ecx
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	mov		[esp + BACK_TWO_LINES], ecx

//	pnext =	(U32 *)(lpInput +
//				(((lpbiInput->biWidth * lpbiInput->biBitCount) >> 3)) *
//					((OutputHeight - aspect - 1) + height_adj)) +
//				width_adj)
// assign (esi, pnext)

	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biWidth
	xor		edx, edx
	mov		dx, (LPBITMAPINFOHEADER)[ebx].biBitCount
	imul	ecx, edx
	sar		ecx, 3
	xor		edx, edx
	mov		dx, [esp + OUTPUT_HEIGHT_WORD]
	sub		edx, [esp + ASPECT]
	dec		edx
	add		edx, [esp + HEIGHT_ADJ]
	imul	ecx, edx
	add		ecx, [esp + WIDTH_ADJ]
	add		ecx, [esp + LP_INPUT]
	mov		esi, ecx

// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for (i = FrameWidth; i > 0; i -= 4, pnext += 8, YPlane += 4)
	mov		ebp, [esp + OUTPUT_WIDTH]
// The following jump is used to make sure the start of the loop begin in the U pipe.
	jmp		L6
// *(U32 *)YPlane =             (*pline>>1) | ((*(pline+ 2)<<7)&0x7F00) |
//   	       ((*(pline+ 4)<<15)&0x7F0000) | ((*(pline+ 6)<<23)&0x7F000000)
// Register usage:
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
	mov		al, [esi]
	 mov	cl, [esi+4]
	shr		eax, 1
	 mov	bl, [esi+2]
	shl		ecx, 15
	 mov	dl, [esi+6]
	shl		ebx, 7
	 and	ecx, 0x7F0000
	shl		edx, 23
	 and	ebx, 0x7F00
	and		edx, 0x7F000000
	 or		ebx, eax
	or		ebx, ecx
	 lea	edi, [edi+4]
	or		ebx, edx
	 lea	esi, [esi+8]
	mov		[edi-4], ebx
	 mov	ebx, [esp + LOOP_K]
// if (0 == (k & 1))
//  *(U16 *)UPlane = (*(pline+ 1)>>1) | ((*(pline+ 5)<<7)&0x7F00)
//	*(U16 *)VPlane = (*(pline+ 3)>>1) | ((*(pline+ 7)<<7)&0x7F00)
	test	ebx, 1
	 jnz	L7

	mov		ecx, [esp + UPLANE]
	 mov	edx, [esp + VPLANE]
	mov		al, [esi-7]
	 mov	bl, [esi-3]
	shr		eax, 1
	 and	ebx, 0xFE
	shl		ebx, 7
	 lea	edx, [edx+2]
	or		ebx, eax
	 mov	al, [esi-5]
	shr		eax, 1
	 mov	[ecx], bx
	mov		bl, [esi-1]
	 lea	ecx, [ecx+2]
	and		ebx, 0xFE
	 mov	[esp + UPLANE], ecx
	shl		ebx, 7
	 mov	[esp + VPLANE], edx
	or		ebx, eax
	 nop
	mov		[edx-2], bx
	 nop
L7:
	sub		ebp, 4
	 jnz	L6

// Assembler version of C_WIDTH_DIFF
// if (width_diff)
	mov		eax, [esp + WIDTH_DIFF]
	mov		edx, eax
	test	eax, eax
	jz		Lno_width_diff
// tm = (*(YPlane-1)) << 24
// tm |= (tm>>8) | (tm>>16) | (tm>>24)
	mov		bl, [edi - 1]
	shl		ebx, 24
	mov		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
	shr		ebx, 8
	or		ecx, ebx
// *(U32 *)YPlane = tm
	mov		[edi], ecx
// if ((width_diff-4) > 0)
	sub		eax, 4
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 4) = tm
	mov		[edi + 4], ecx
	sub		eax, 4
// if ((width_diff-8) > 0)
	jz		Lupdate_YPlane
// *(U32 *)(YPlane + 8) = tm
	mov		[edi + 8], ecx
Lupdate_YPlane:
// YPlane += width_diff
	lea		edi, [edi + edx]
///if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		Lno_width_diff
// t8u = *(UPlane-1)
// t8v = *(VPlane-1)
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		ebp, edx
	mov		eax, [esp + UPLANE]
	mov		ebx, [esp + VPLANE]
	mov		cl, [eax - 1]
	mov		ch, [ebx - 1]
	mov		[eax], cl
	mov		[eax + 1], cl
	mov		[ebx], ch
	mov		[ebx + 1], ch
// if ((width_diff-4) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 2], cl
	mov		[eax + 3], cl
	mov		[ebx + 2], ch
	mov		[ebx + 3], ch
// if ((width_diff-8) > 0)
	sub		ebp, 4
	jz		Lupdate_UVPlane
// *UPlane++ = t8u
// *UPlane++ = t8u
// *VPlane++ = t8v
// *VPlane++ = t8v
	mov		[eax + 4], cl
	mov		[eax + 5], cl
	mov		[ebx + 4], ch
	mov		[ebx + 5], ch
Lupdate_UVPlane:
	sar		edx, 1
	lea		eax, [eax + edx]
	mov		[esp + UPLANE], eax
	lea		ebx, [ebx + edx]
	mov		[esp + VPLANE], ebx
Lno_width_diff:

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = OutputWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + OUTPUT_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += BackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += byte_ypitch_adj;
	add		edi, [esp + BYTE_YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += byte_uvpitch_adj;
// VPlane += byte_uvpitch_adj;
	mov		eax, [esp + BYTE_UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	xor		eax, eax
	mov		ebx, [esp + LOOP_K]
	cmp		ebx, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)

// ASM version of C_HEIGHT_FILL
// if (height_diff)
	mov		eax, [esp + HEIGHT_DIFF]
	test	eax, eax
	jz		Lno_height_diff

// pyspace = (U32 *)YPlane
	mov		esi, edi
// pyprev =  (U32 *)(YPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j--)
Lheight_yfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -=4)
Lheight_yfill_row:
// *pyspace++ = *pyprev++
	mov		ecx, [esi]
	lea		esi, [esi + 4]
	mov		[edi], ecx
	lea		edi, [edi + 4]
	sub		ebx, 4
	jnz		Lheight_yfill_row
// pyspace += word_ypitch_adj
// pyprev  += word_ypitch_adj
	add		esi, [esp + BYTE_YPITCH_ADJ]
	add		edi, [esp + BYTE_YPITCH_ADJ]
	dec		eax
	jnz		Lheight_yfill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + UPLANE]
// puvspace = (U32 *)UPlane
	mov		esi, edi
// puvprev =  (U32 *)(UPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_ufill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_ufill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_ufill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_ufill_loop

	mov		eax, [esp + HEIGHT_DIFF]
	mov		edi, [esp + VPLANE]
// puvspace = (U32 *)VPlane
	mov		esi, edi
// puvprev =  (U32 *)(VPlane - pitch)
	sub		esi, [esp + PITCH_PARM]
// for (j = height_diff; j > 0; j -= 2)
Lheight_vfill_loop:
	mov		ebx, [esp + WIDTHX16]
// for (i = widthx16; i>0; i -= 8)
Lheight_vfill_row:
// *puvspace++ = *puvprev++
	mov		ecx, [esi]
	mov		[edi], ecx
	lea		esi, [esi + 4]
	lea		edi, [edi + 4]
	sub		ebx, 8
	jnz		Lheight_vfill_row
// puvspace += word_uvpitch_adj
// puvprev  += word_uvpitch_adj
	add		esi, [esp + BYTE_UVPITCH_ADJ]
	add		edi, [esp + BYTE_UVPITCH_ADJ]
	sub		eax, 2
	jnz		Lheight_vfill_loop
Lno_height_diff:

// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = OutputWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + OUTPUT_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef	LOCALSIZE

#undef	PITCH_PARM
#undef	VPLANE
#undef	UPLANE
#undef	YPLANE
#undef	LP_INPUT
#undef	OUTPUT_HEIGHT_WORD
#undef	OUTPUT_WIDTH_WORD
#undef	LPBI_INPUT

#undef	OUTPUT_WIDTH
#undef	PYPREV
#undef	PYSPACE
#undef	PYNEXT
#undef	PUVPREV
#undef	PUVSPACE
#undef	LOOP_I	
#undef	LOOP_J	
#undef	LOOP_K
#undef	BACK_TWO_LINES
#undef	WIDTHX16
#undef	HEIGHTX16
#undef	WIDTH_DIFF
#undef	HEIGHT_DIFF
#undef	WIDTH_ADJ
#undef	HEIGHT_ADJ
#undef	STRETCH
#undef	ASPECT
#undef	LUMA_ITERS
#undef	MARK
#undef	BYTE_YPITCH_ADJ
#undef	BYTE_UVPITCH_ADJ

/***************************************************
 * H26X_YUV12toEncYUV12()
 *  Copy YUV12 data to encoder memory at the
 *  appropriate location. It is assumed that the input
 *  data is stored as rows of Y, followed by rows of U,
 *  then rows of V.
 *
 ***************************************************/

 void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER	lpbiInput,
	WORD OutputWidth,
	WORD OutputHeight,
    U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	const int pitch) {

	int i, j;
	U32 *pnext = (U32 *)lpInput;
	U32 *plast;
	U32 t;
	U16 t16;
	U8  *p8next;
	int byte_ypitch_adj;	
	int byte_uvpitch_adj;
	
	int yinput_height = lpbiInput->biHeight;
	int yinput_width = lpbiInput->biWidth;
	int yheight_diff = 0;
	int ywidth_diff = 0;
	int uvheight_diff = 0;
	int uvwidth_diff = 0;

	int uvinput_width = yinput_width >> 1;
	int uvinput_height = yinput_height >> 1;
	int uvoutput_width = OutputWidth >> 1;

	int widthx16 = (OutputWidth + 0xF) & ~0xF;
	int width_diff = widthx16 - OutputWidth;
	int heightx16  = (OutputHeight + 0xF) & ~0xF;
	int height_diff = heightx16 - OutputHeight;

	// This routine has to handle two cases:
	//  - arbitrary frame size (width and height may be any multiple of 4 up to CIF size).
	//  - backward compatibility with H263 (320x240 -> 352x288 still mode)
	// Note: Crop and stretch was not supported for YUV12 conversion in H263.
	if (width_diff) {
		byte_ypitch_adj = pitch - widthx16;
		byte_uvpitch_adj = pitch - (widthx16 >> 1);
	} else {
		byte_ypitch_adj = pitch - OutputWidth;	
		byte_uvpitch_adj = pitch - (OutputWidth >> 1);
		ywidth_diff = OutputWidth - yinput_width;
		yheight_diff = OutputHeight - yinput_height;
		uvwidth_diff = ywidth_diff >> 1;
		uvheight_diff = yheight_diff >> 1;
	}

	// Y Plane conversion.
	for (j = yinput_height; j > 0; j--, YPlane += byte_ypitch_adj) {
		for (i = yinput_width; (i & ~0xF); i-=16, YPlane+=16) {
			*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+8) = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+12) = (*pnext++ >> 1) & 0x7F7F7F7F;
		}
		if (i & 0x8) {
			*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
			*(U32 *)(YPlane+4) = (*pnext++ >> 1) & 0x7F7F7F7F;
			YPlane += 8;
		}
		if (i & 0x4) {
			*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F;
			YPlane += 4;
		}
		// The next two cases are mutually exclusive. If there is a width_diff,
		// then there is no ywidth_diff. If there is a ywidth_diff, then there
		// is no width_diff. Both width_diff and ywidth_diff may be zero.
		if (width_diff) {
			t = (*(YPlane-1)) << 24;
			t |= (t>>8) | (t>>16) | (t>>24);
			*(U32 *)YPlane = t;
			if ((width_diff-4) > 0) {
				*(U32 *)(YPlane + 4) = t;
			}
			if ((width_diff-8) > 0) {
				*(U32 *)(YPlane + 8) = t;
			}
			YPlane += width_diff;
		}
		for (i = ywidth_diff; i > 0; i -= 4) {
			*(U32 *)YPlane = 0; YPlane += 4;
		}
	}
	// The next two cases are mutually exclusive. If there is a height_diff,
	// then there is no yheight_diff. If there is a yheight_diff, then there
	// is no height_diff. Both height_diff and yheight_diff may be zero.
	if (height_diff) {
		for (j = height_diff; j > 0; j-- ) {
			plast = (U32 *)(YPlane - pitch);
			for (i = widthx16; i > 0; i -= 4, YPlane += 4) {
				*(U32 *)YPlane = *plast++;
			}
			YPlane += byte_ypitch_adj;
		}
	}
	for (j = yheight_diff; j > 0; j--, YPlane += byte_ypitch_adj) {
		for (i = widthx16; i > 0; i -= 4) {
			*(U32 *)YPlane = 0; YPlane += 4;
		}
	}

	// U Plane conversion.
	p8next = (U8 *)pnext;
	for (j = uvinput_height; j > 0; j--, UPlane += byte_uvpitch_adj) {
		for (i = uvinput_width; (i & ~0x7); i-=8, UPlane+=8, p8next+=8) {
			*(U32 *)UPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			*(U32 *)(UPlane+4) = (*(U32 *)(p8next+4) >> 1) & 0x7F7F7F7F;
		}
		if (i & 0x4) {
			*(U32 *)UPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			UPlane += 4, p8next += 4;
		}
		if (i & 0x2) {
			*(U16 *)UPlane = (*(U16 *)p8next >> 1) & 0x7F7F;
			UPlane += 2, p8next += 2;
		}
		// The next two cases are mutually exclusive. If there is a width_diff,
		// then there is no uvwidth_diff. If there is a uvwidth_diff, then there
		// is no width_diff. Both width_diff and uvwidth_diff may be zero.
		if (width_diff) {
			t16 = (*(UPlane-1)) << 8;
			t16 |= (t16>>8); 
			*(U16*)UPlane = t16; UPlane += 2;
			if ((width_diff-4) > 0) {
				*(U16*)UPlane = t16; UPlane += 2;
			}
			if ((width_diff-8) > 0) {
				*(U16*)UPlane = t16; UPlane += 2;
			}
		}
		for (i = uvwidth_diff; i > 0; i -= 4) {
			*(U32 *)UPlane = 0x40404040; UPlane += 4;
		}
	}
	// The next two cases are mutually exclusive. If there is a height_diff,
	// then there is no uvheight_diff. If there is a uvheight_diff, then there
	// is no height_diff. Both height_diff and uvheight_diff may be zero.
	if (height_diff) {
		for (j = (height_diff >> 1); j > 0; j--, UPlane += byte_uvpitch_adj ) {
			plast = (U32 *)(UPlane - pitch);
			for (i = (widthx16 >> 1); i > 0; i -= 4, UPlane += 4) {
				*(U32 *)UPlane = *plast++;
			}
		}
	}
	for (j = uvheight_diff; j > 0; j--, UPlane += byte_uvpitch_adj) {
		for (i = uvoutput_width; i > 0; i -= 4) {
			*(U32 *)UPlane = 0x40404040; UPlane += 4;
		}
	}

	// V Plane conversion.
	for (j = uvinput_height; j > 0; j--, VPlane += byte_uvpitch_adj) {
		for (i = uvinput_width; (i & ~0x7); i-=8, VPlane+=8, p8next+=8) {
			*(U32 *)VPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			*(U32 *)(VPlane+4) = (*(U32 *)(p8next+4) >> 1) & 0x7F7F7F7F;
		}
		if (i & 0x4) {
			*(U32 *)VPlane = (*(U32 *)p8next >> 1) & 0x7F7F7F7F;
			VPlane += 4, p8next += 4;
		}
		if (i & 0x2) {
			*(U16 *)VPlane = (*(U16 *)p8next >> 1) & 0x7F7F;
			VPlane += 2, p8next += 2;
		}
		// The next two cases are mutually exclusive. If there is a width_diff,
		// then there is no uvwidth_diff. If there is a uvwidth_diff, then there
		// is no width_diff. Both width_diff and uvwidth_diff may be zero.
		if (width_diff) {
			t16 = (*(VPlane-1)) << 8;
			t16 |= (t16>>8); 
			*(U16*)VPlane = t16; VPlane += 2;
			if ((width_diff-4) > 0) {
				*(U16*)VPlane = t16; VPlane += 2;
			}
			if ((width_diff-8) > 0) {
				*(U16*)VPlane = t16; VPlane += 2;
			}
		}
		for (i = uvwidth_diff; i > 0; i -= 4) {
			*(U32 *)VPlane = 0x40404040; VPlane += 4;
		}
	}
	// The next two cases are mutually exclusive. If there is a height_diff,
	// then there is no uvheight_diff. If there is a uvheight_diff, then there
	// is no height_diff. Both height_diff and uvheight_diff may be zero.
	if (height_diff) {
		for (j = (height_diff >> 1); j > 0; j--, VPlane += byte_uvpitch_adj ) {
			plast = (U32 *)(VPlane - pitch);
			for (i = (widthx16 >> 1); i > 0; i -= 4, VPlane += 4) {
				*(U32 *)VPlane = *plast++;
			}
		}
	}
	for (j = uvheight_diff; j > 0; j--, VPlane += byte_uvpitch_adj) {
		for (i = uvoutput_width; i > 0; i -= 4) {
			*(U32 *)VPlane = 0x40404040; VPlane += 4;
		}
	}
}

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\exbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
                                                                      //
////////////////////////////////////////////////////////////////////////////
//
// $Author:   mbodart  $
// $Date:   17 Mar 1997 08:22:08  $
// $Archive:   S:\h26x\src\enc\exbase.cpv  $
// $Header:   S:\h26x\src\enc\exbase.cpv   1.73   17 Mar 1997 08:22:08   mbodart  $
// $Log:   S:\h26x\src\enc\exbase.cpv  $
// 
//    Rev 1.73   17 Mar 1997 08:22:08   mbodart
// Minor fixes.
// 
//    Rev 1.72   11 Mar 1997 13:46:46   JMCVEIGH
// Allow input = 320x240 and output = 320x240 for YUV12. This is
// for snapshot mode.
// 
//    Rev 1.71   10 Mar 1997 17:34:34   MDUDA
// Put in a check for 9-bit YUV12 and adjusted the internal compress
// structure instead of the input bitmap header info.
// 
//    Rev 1.70   10 Mar 1997 10:41:20   MDUDA
// Treating inconsistent format/bitwidth as a debug warning. Changing
// bit count to match format.
// 
//    Rev 1.69   07 Mar 1997 16:00:32   JMCVEIGH
// Added checks for non-NULL lpInst before getting H263PlusState. 
// Two separate "suggestions" for image sizes if input size is not
// supported in GetFormat. 
// 
//    Rev 1.68   07 Mar 1997 11:55:44   JMCVEIGH
// Moved query in GetFormat to after we have filled out the output
// format. This is because some apps. will ask for the format and
// then use the returned data, regardless if there was an error.
// Silly apps!
// 
//    Rev 1.67   07 Mar 1997 09:53:08   mbodart
// Added a call to _clearfp() in the Compress exception handler, so that
// the exception will not reoccur in the caller's code.
// 
//    Rev 1.66   06 Mar 1997 15:39:26   KLILLEVO
// 
// CompressQuery now checks for input/output formats regardless
// of configuration status. Also put in trace support for lparam1 and lparam2.
// 
//    Rev 1.65   22 Jan 1997 12:17:14   MDUDA
// 
// Put in more checking for H263+ option in CompressQuery
// and CompressBegin.
// 
//    Rev 1.64   22 Jan 1997 08:11:22   JMCVEIGH
// Backward compatibility with crop/stretch for 160x120 and 240x180
// in CompressGetFormat(). Do old way unless we have received the
// H263Plus custom message.
// 
//    Rev 1.63   13 Jan 1997 10:52:14   JMCVEIGH
// 
// Added NULL pointer checks in all functions that interface with
// application.
// 
//    Rev 1.62   09 Jan 1997 13:50:50   MDUDA
// Removed some _CODEC_STATS stuff.
// 
//    Rev 1.61   06 Jan 1997 17:42:30   JMCVEIGH
// If H263Plus message is not sent, encoder only supports standard
// frame sizes (sub-QCIF, QCIF, or CIF along with special cases),
// as before.
// 
//    Rev 1.60   30 Dec 1996 19:57:04   MDUDA
// Making sure that input formats agree with the bit count field.
// 
//    Rev 1.59   20 Dec 1996 15:25:28   MDUDA
// Fixed problem where YUV12 was enabled for crop and stretch.
// This feature is only allowed for RGB, YVU9 and YUY2.
// 
//    Rev 1.58   16 Dec 1996 13:36:08   MDUDA
// 
// Modified Compress Instance info for input color convertors.
// 
//    Rev 1.57   11 Dec 1996 16:01:20   MBODART
// In Compress, catch any exceptions and return an error code.  This gives
// upstream active movie filters a chance to recover gracefully.
// 
//    Rev 1.56   09 Dec 1996 17:59:36   JMCVEIGH
// Added support for arbitrary frame size support.
// 4 <= width <= 352, 4 <= height <= 288, both multiples of 4.
// Normally, application will pass identical (arbitrary) frame
// sizes in lParam1 and lParam2 of CompressBegin(). If 
// cropping/stretching desired to convert to standard frame sizes,
// application should pass the desired output size in lParam2 and
// the input size in lParam1.
// 
//    Rev 1.55   09 Dec 1996 09:50:12   MDUDA
// 
// Allowing 240x180 and 160x120 (crop and stretch) for YUY2.
// Modified _CODEC_STATS stuff.
// 
//    Rev 1.54   07 Nov 1996 14:45:16   RHAZRA
// Added buffer size adjustment to H.261 CompressGetSize() function
// 
//    Rev 1.53   31 Oct 1996 22:33:32   BECHOLS
// Decided buffer arbitration must be done in cxq_main.cpp for RTP.
// 
//    Rev 1.52   31 Oct 1996 21:55:50   BECHOLS
// Added fudge factor for RTP waiting for Raj to decide what he wants to do.
// 
//    Rev 1.51   31 Oct 1996 10:05:46   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.50   18 Oct 1996 14:35:46   MDUDA
// 
// Separated CompressGetSize and CompressQuery for H261 and H263 cases.
// 
//    Rev 1.49   11 Oct 1996 16:05:16   MDUDA
// 
// Added initial _CODEC_STATS stuff.
// 
//    Rev 1.48   16 Sep 1996 16:50:52   CZHU
// Return larger size for GetCompressedSize when RTP is enabled.
// 
//    Rev 1.47   13 Aug 1996 10:36:46   MDUDA
// 
// Now allowing RGB4 input format.
// 
//    Rev 1.46   09 Aug 1996 09:43:30   MDUDA
// Now allowing RGB16 format on input. This is generated by the color Quick Ca
// 
//    Rev 1.45   02 Aug 1996 13:45:58   MDUDA
// 
// Went back to previous version that allows RGB8 and RGB24 in
// 240x180 and 160x120 frames.
// 
//    Rev 1.44   01 Aug 1996 11:54:58   BECHOLS
// Cut & Paste Error.
// 
//    Rev 1.43   01 Aug 1996 11:20:28   BECHOLS
// Fixed handling of RGB 24 bit stuff so that it doesn't allow sizes other
// than QCIF, SQCIF, or CIF.  I broke this earlier when I added the RGB 8
// bit support. ...
// 
//    Rev 1.42   22 Jul 1996 13:31:16   BECHOLS
// 
// Added code to allow a CLUT8 input providing that the input resolutions
// are either 240x180 or 160x120.
// 
//    Rev 1.41   11 Jul 1996 15:43:58   MDUDA
// Added support for YVU9 240 x 180 and 160 x 120 for H263 only.
// We now produce subQCIF for 160x120 and QCIF for 240x180.
// 
//    Rev 1.40   05 Jun 1996 10:57:54   AKASAI
// Added #ifndef H261 in CompressQuery to make sure that H.261 will
// only support FCIF and QCIF input image sizes.  All other input sizes
// should return ICERR_BADFORMAT.
// 
//    Rev 1.39   30 May 1996 17:02:34   RHAZRA
// Added SQCIF support for H.263 in CompressGetSize()
// 
//    Rev 1.38   06 May 1996 12:47:40   BECHOLS
// Changed the structure element to unBytesPerSecond.
// 
//    Rev 1.37   06 May 1996 00:09:44   BECHOLS
// Changed the handling of the CompressFramesInfo message to get DataRate
// from the configuration data if the configuration has the data, and
// we haven't received a CompressBegin message yet.
// 
//    Rev 1.36   23 Apr 1996 16:51:20   KLILLEVO
// moved paranthesis to fix format check in CompressQuery()
// 
//    Rev 1.35   18 Apr 1996 16:07:10   RHAZRA
// Fixed CompressQuery to keep compiler happy for the non-MICROSOFT version
// 
//    Rev 1.34   18 Apr 1996 15:57:46   BECHOLS
// RAJ- Changed the query logic to correctly filter the allowable resolutions
// for compression.
// 
//    Rev 1.33   12 Apr 1996 14:15:40   RHAZRA
// Added paranthesis in CompressGetSize() to make the ifdef case work
// 
//    Rev 1.32   12 Apr 1996 13:31:02   RHAZRA
// Added SQCIF support in CompressGetSize() with #ifdef SUPPORT_SQCIF;
// changed CompressGetSize() to return 0 if the input format is not
// supported.
// 
//    Rev 1.31   10 Apr 1996 16:53:08   RHAZRA
// Added a error return in CompressGetSize() to keep complier smiling...
// 
//    Rev 1.30   10 Apr 1996 16:39:56   RHAZRA
// Added a check for the 320x240 size in CompressGetSize() function;
// added a ifndef to disable certain sizes and compression formats.
// 
//    Rev 1.29   04 Apr 1996 13:35:00   RHAZRA
// Changed CompressGetSize() to return spec-compliant buffer sizes.
// 
//    Rev 1.28   03 Apr 1996 08:39:52   SCDAY
// Added H261 specific code to CompressGetSize to limit buffer size
// as defined in H261 spec
// 
//    Rev 1.27   21 Feb 1996 11:43:12   SCDAY
// cleaned up compiler build warning by changing conversion frlDataRate to (U3
// 
//    Rev 1.26   15 Feb 1996 16:03:36   RHAZRA
// 
// Added a check for NULL lpInst pointer in CompressGetFormat()
// 
//    Rev 1.25   02 Feb 1996 18:53:46   TRGARDOS
// Changed code to read frame rate from Compressor Instance
// instead of the hack from Quality field.
// 
//    Rev 1.24   26 Jan 1996 09:35:32   TRGARDOS
// Added #ifndef H261 for 160x120,320x240 support.
// 
//    Rev 1.23   04 Jan 1996 18:36:54   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.22   27 Dec 1995 15:32:50   RMCKENZX
// Added copyright notice
// 
///////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef  YUV9FROMFILE
PAVIFILE paviFile;
PAVISTREAM paviStream; 
U8 huge * glpTmp;
HGLOBAL hgMem;
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns a format that 
;//                 we can deliver back to the caller.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressGetFormat(LPINST pi, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#else
DWORD PASCAL CompressGetFormat(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#endif
{
    DWORD dwQuery;
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;
#endif

	FX_ENTRY("CompressGetFormat")

	// lpInst == NULL is OK
	// this is what you get on ICOpen(...,ICMODE_QUERY)
#if 0
    if (lpInst == NULL) {
		ERRORMESSAGE(("%s: got a NULL lpInst pointer\r\n", _fx_));
       return ((DWORD) ICERR_ERROR);
    }
#endif

#ifdef USE_BILINEAR_MSH26X
    if(dwQuery = CompressQuery(pi, lParam1, NULL)) {
#else
    if(dwQuery = CompressQuery(lpInst, lParam1, NULL)) {
#endif
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
        return(dwQuery);
    }
    if(lParam2 == NULL) {
        // he just want me to return the output buffer size. 
        return ((DWORD)sizeof(BITMAPINFOHEADER));
    }

	// Check pointer
	if (!lParam1)
		return ICERR_ERROR;

    // give him back what he passed with our stuff in it 
	#ifndef WIN32
    (void)_fmemcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#else
	 (void)memcpy(lParam2, lParam1,sizeof(BITMAPINFOHEADER));
	#endif

    lParam2->biBitCount = 24;
#ifdef USE_BILINEAR_MSH26X
    lParam2->biCompression = pi->fccHandler;
#else
    lParam2->biCompression = FOURCC_H263;
#endif

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState);

	if (!bH263PlusState) {
		// For backward compatibility, make sure the crop and stretch cases are covered.
		if ( (lParam1->biCompression == FOURCC_YVU9) ||
			 (lParam1->biCompression == FOURCC_YUY2) ||
			 (lParam1->biCompression == FOURCC_UYVY) ||
			 (lParam1->biCompression == FOURCC_YUV12) ||
			 (lParam1->biCompression == FOURCC_IYUV) ||
			 (lParam1->biCompression == BI_RGB) )
		{
			if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
			{
				lParam2->biWidth        = 176;
				lParam2->biHeight       = 144;
			}
			if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
			{
				lParam2->biWidth        = 128;
				lParam2->biHeight       = 96;
			}
		}
	}
#else
	if ( (lParam1->biCompression == FOURCC_YVU9) ||
		 (lParam1->biCompression == FOURCC_YUY2) ||
		 (lParam1->biCompression == FOURCC_UYVY) ||
		 (lParam1->biCompression == FOURCC_YUV12) ||
		 (lParam1->biCompression == FOURCC_IYUV) ||
		 (lParam1->biCompression == BI_RGB) )
	{
		if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
			lParam2->biWidth        = 176;
			lParam2->biHeight       = 144;
		}
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
			lParam2->biWidth        = 128;
			lParam2->biHeight       = 96;
		}
	}
	else
	{
    	lParam2->biWidth        = MOD4(lParam1->biWidth);
    	lParam2->biHeight       = MOD4(lParam1->biHeight);
	}
#endif

    lParam2->biClrUsed      = 0;
    lParam2->biClrImportant = 0;
    lParam2->biPlanes       = 1;        
#ifdef USE_BILINEAR_MSH26X
    lParam2->biSizeImage    = CompressGetSize(pi, lParam1, lParam2);
#else
    lParam2->biSizeImage    = CompressGetSize(lpInst, lParam1, lParam2);
#endif
    return(ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    Added header.  This function returns the maximum
;//                 size that a compressed buffer can be.  This size is
;//                 guaranteed in encoder design.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

	FX_ENTRY("CompressGetSize")

	if ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) {
		dwRet = 8192L;
	} else {
		if  ((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) {
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			ERRORMESSAGE(("%s: ICERR_BADIMAGESIZE\r\n", _fx_));
			dwRet = 0;
		}  
	}

#if 0
	// Adjust the buffer size for RTP. Note that this adjustment will be performed
	// only if the codec has been told previously to use RTP and the RTP-related
	// information has been initialized. Therefore, the current (11/7) AM interface
	// will not take advantage of this routine.

	if (dwRet && lpInst && lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += H261EstimateRTPOverhead(lpInst, lParam1);
	}
#endif

	return dwRet;
}
#else
/* H.263 case */
#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressGetSize(LPINST pi, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#else
DWORD PASCAL CompressGetSize(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#endif
{
// RH: For QCIF and CIF, the maximum buffer sizes for 261 & 263 are identical.
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;
#endif
	DWORD dwRet =  0;
	DWORD dwExtSize=0;

	FX_ENTRY("CompressGetSize")

    if (lParam1 == NULL) {
		// We will use a size of zero to indicate an error for CompressGetSize
		ERRORMESSAGE(("%s: got a NULL lParam1 pointer\r\n", _fx_));
 	    dwRet = 0;
        return dwRet;
    }

#ifndef H263P
#ifdef USE_BILINEAR_MSH26X
	if (pi->fccHandler == FOURCC_H26X)
	{
		// H.263+
		U32 unPaddedWidth;
		U32 unPaddedHeight;
		U32 unSourceFormatSize;

		// Base buffer size on frame dimensions padded to multiples of 16
		if (lParam2 == NULL) 
		{
			// In case an old application passed in a NULL pointer in lParam2,
			// we use the input frame dimensions to calculate the format size
			unPaddedWidth = (lParam1->biWidth + 0xf) & ~0xf;
			unPaddedHeight = (lParam1->biHeight + 0xf) & ~0xf;
		} 
		else 
		{
			unPaddedWidth = (lParam2->biWidth + 0xf) & ~0xf;
			unPaddedHeight = (lParam2->biHeight + 0xf) & ~0xf;
		}

		unSourceFormatSize = unPaddedWidth * unPaddedHeight;

		// See Table 1/H.263, document LBC-96-358
		if (unSourceFormatSize < 25348)
			dwRet = 8192L;
		else if (unSourceFormatSize < 101380)
			dwRet = 32768L;
		else if (unSourceFormatSize < 405508)
			dwRet = 65536L;
		else 
			dwRet = 131072L;
	}
	else
	{
#endif
		if (((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
#ifdef USE_BILINEAR_MSH26X
			((lParam1->biWidth == 80) && (lParam1->biHeight == 64)) ||
#endif
			((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
			((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ||
			((lParam1->biWidth == 160) && (lParam1->biHeight == 120)))
		{
			dwRet = 8192L;
		}
		else if (((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ||
				((lParam1->biWidth == 320) && (lParam1->biHeight == 240)))
		{
			dwRet = 32768L;
		}
		else	// unsupported frame size; should not happen
		{
			ERRORMESSAGE(("%s: ICERR_BADIMAGESIZE\r\n", _fx_));
			dwRet = 0;
		}
#ifdef USE_BILINEAR_MSH26X
	}
#endif
#else
	// H.263+
	U32 unPaddedWidth;
	U32 unPaddedHeight;
	U32 unSourceFormatSize;

	// Base buffer size on frame dimensions padded to multiples of 16
	if (lParam2 == NULL) 
	{
		// In case an old application passed in a NULL pointer in lParam2,
		// we use the input frame dimensions to calculate the format size
		unPaddedWidth = (lParam1->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam1->biHeight + 0xf) & ~0xf;
	} 
	else 
	{
		unPaddedWidth = (lParam2->biWidth + 0xf) & ~0xf;
		unPaddedHeight = (lParam2->biHeight + 0xf) & ~0xf;
	}

	unSourceFormatSize = unPaddedWidth * unPaddedHeight;

	// See Table 1/H.263, document LBC-96-358
	if (unSourceFormatSize < 25348)
		dwRet = 8192L;
	else if (unSourceFormatSize < 101380)
		dwRet = 32768L;
	else if (unSourceFormatSize < 405508)
		dwRet = 65536L;
	else 
		dwRet = 131072L;
#endif

#if 0
	//adjust if RTP is enabled, based on information in Configuration
   	//Size calculated using DataRate, FrameRate in lpInst, 
	//and lpInst->Configuration.unPacketSize;
	//Chad, 9/12/96
 	if (dwRet && lpInst &&
		lpInst->Configuration.bRTPHeader && lpInst->Configuration.bInitialized)
	{	
		dwRet += getRTPBsInfoSize(lpInst);
	}
#endif

	return dwRet;
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
#if defined(H261)
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
{
    // Check for good input format

	FX_ENTRY("CompressQuery")

    if(NULL == lParam1)                          
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
 		return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) )
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) && (lParam1->biBitCount != 24))
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if(!  ( ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  ))
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

    if( lParam1->biPlanes != 1 )
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
    }

    if(0 == lParam2)                            // Checking input only
		return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
    if( lParam2->biCompression != FOURCC_H263 )
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
        return ((DWORD)ICERR_BADFORMAT);
    }

    return(ICERR_OK);
}
#else
/* H.263 case */
#ifdef USE_BILINEAR_MSH26X
DWORD PASCAL CompressQuery(LPINST pi, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#else
DWORD PASCAL CompressQuery(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1, LPBITMAPINFOHEADER lParam2)
#endif
{
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;
#endif

	FX_ENTRY("CompressQuery")

#if defined(H263P)
	BOOL bH263PlusState = FALSE;

	if (lpInst)
		CustomGetH263PlusState(lpInst, (DWORD FAR *)&bH263PlusState); 
#endif

    // Check for good input format
    if(lParam1 == NULL)                          
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
	}

	if(	(lParam1->biCompression != BI_RGB) &&
		(lParam1->biCompression != FOURCC_YVU9) &&
		(lParam1->biCompression != FOURCC_YUV12) &&
		(lParam1->biCompression != FOURCC_IYUV) &&
		(lParam1->biCompression != FOURCC_UYVY) &&
		(lParam1->biCompression != FOURCC_YUY2) )
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
	}

    if( (lParam1->biCompression == BI_RGB) &&
		(	(lParam1->biBitCount != 24) &&
#ifdef H263P
			(lParam1->biBitCount != 32) &&
#endif
			(lParam1->biBitCount != 16) &&
			(lParam1->biBitCount != 8) &&
			(lParam1->biBitCount != 4) ) )
	{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
	}

#ifndef H263P
#ifdef USE_BILINEAR_MSH26X
	if (pi->fccHandler == FOURCC_H26X)
	{
		if ((lParam1->biWidth & 0x3) || (lParam1->biHeight & 0x3) ||
			(lParam1->biWidth < 4)   || (lParam1->biWidth > 352) ||
			(lParam1->biHeight < 4)  || (lParam1->biHeight > 288))
		{
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
	}
	else
	{
#endif
		if(!
		  ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
#ifdef USE_BILINEAR_MSH26X
    		((lParam1->biWidth == 80) && (lParam1->biHeight == 64)) ||
#endif
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  

#ifndef MICROSOFT
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) )
		  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) )
		  ||
		  ( ( (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV) )
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) )
#endif
		  ))
		{
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
#ifdef USE_BILINEAR_MSH26X
	}
#endif
#else
	if (((FOURCC_YVU9 == lParam1->biCompression) && (9 != lParam1->biBitCount)) ||
	    ((FOURCC_YUY2 == lParam1->biCompression) && (16 != lParam1->biBitCount)) ||
	    ((FOURCC_UYVY == lParam1->biCompression) && (16 != lParam1->biBitCount)) ||
		// The following check for 9-bit YUV12 is a hack to work around a VPhone 1.x bug.
	    ((FOURCC_YUV12 == lParam1->biCompression) &&
			!((12 == lParam1->biBitCount) || (9 == lParam1->biBitCount))) ||
	    ((FOURCC_IYUV == lParam1->biCompression) &&
			!((12 == lParam1->biBitCount) || (9 == lParam1->biBitCount)))) {
		ERRORMESSAGE(("%s: Incorrect bit width (ICERR_BADFORMAT)\r\n", _fx_));
		return((DWORD)ICERR_BADFORMAT);
	}

	// The H263+ message indicates whether arbitrary frame
	// sizes are to be supported. If arbitrary frames are needed,
	// the H263+ message must be sent before the first call to
	// CompressQuery.

	if (bH263PlusState) {
		if ((lParam1->biWidth & 0x3) || (lParam1->biHeight & 0x3) ||
			(lParam1->biWidth < 4)   || (lParam1->biWidth > 352) ||
			(lParam1->biHeight < 4)  || (lParam1->biHeight > 288)) {
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
		  ( ((lParam1->biWidth == 128) && (lParam1->biHeight == 96)) ||
    		((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
    		((lParam1->biWidth == 352) && (lParam1->biHeight == 288))  ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) ) ||
		  ( (	(lParam1->biCompression == FOURCC_YVU9) ||
				(lParam1->biCompression == FOURCC_YUY2) ||
				(lParam1->biCompression == FOURCC_UYVY) ||
				(lParam1->biCompression == FOURCC_YUV12) ||
				(lParam1->biCompression == FOURCC_IYUV) ||
				(lParam1->biCompression == BI_RGB) )
	  			&& ((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) ) ||
		  ( ( (lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV) )
	  			&& ((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) ) ))
		{
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

    if( lParam1->biPlanes != 1 )
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
      return((DWORD)ICERR_BADFORMAT);
    }

    if(lParam2 == 0)                            // Checking input only
        return(ICERR_OK);     

	// TODO: Do we want to check frame dimensions of output?
#ifdef USE_BILINEAR_MSH26X
    if( (lParam2->biCompression != FOURCC_H263) && (lParam2->biCompression != FOURCC_H26X) )
#else
    if( lParam2->biCompression != FOURCC_H263 )
#endif
    {
		ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
        return ((DWORD)ICERR_BADFORMAT);
    }

#if defined(H263P)
	if (bH263PlusState) {
		if ((lParam1->biWidth != lParam2->biWidth) ||
			(lParam1->biHeight != lParam2->biHeight)) {
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return ((DWORD)ICERR_BADFORMAT);
		}
	} else {
		if(!
			(( ( ((lParam1->biWidth == 128) && (lParam1->biHeight ==  96)) ||
			     ((lParam1->biWidth == 176) && (lParam1->biHeight == 144)) ||
			     ((lParam1->biWidth == 352) && (lParam1->biHeight == 288)) ) &&
			   (lParam1->biWidth == lParam2->biWidth) && (lParam1->biHeight == lParam2->biHeight) ) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == FOURCC_UYVY) ||
			   (lParam1->biCompression == FOURCC_YUV12) ||
			   (lParam1->biCompression == FOURCC_IYUV) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 160) && (lParam1->biHeight == 120)) &&
	  			((lParam2->biWidth == 128) && (lParam2->biHeight == 96)))) ||
			 (((lParam1->biCompression == FOURCC_YVU9) ||
			   (lParam1->biCompression == FOURCC_YUY2) ||
			   (lParam1->biCompression == FOURCC_UYVY) ||
			   (lParam1->biCompression == FOURCC_YUV12) ||
			   (lParam1->biCompression == FOURCC_IYUV) ||
			   (lParam1->biCompression == BI_RGB)) &&
			   (((lParam1->biWidth == 240) && (lParam1->biHeight == 180)) &&
	  			((lParam2->biWidth == 176) && (lParam2->biHeight == 144)))) ||
			 (((lParam1->biCompression == FOURCC_YUV12) || (lParam1->biCompression == FOURCC_IYUV)) &&
			   (((lParam1->biWidth == 320) && (lParam1->biHeight == 240)) &&
	  			((lParam2->biWidth == 320) && (lParam2->biHeight == 240)))) ) )
		{
			ERRORMESSAGE(("%s: ICERR_BADFORMAT\r\n", _fx_));
			return ((DWORD)ICERR_BADFORMAT);
		}
	}
#endif

    return(ICERR_OK);
}
#endif

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressFramesInfo(LPCODINST lpCompInst, ICCOMPRESSFRAMES *lParam1, int lParam2)
{
	FX_ENTRY("CompressFramesInfo");

	// Check to see if we are given a nonzero pointer.
	if (lpCompInst == NULL)
	{
		ERRORMESSAGE(("%s: CompressFramesInfo called with NULL parameter - returning ICERR_BADFORMAT", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	// lParam2 should be the size of the structure.
	if (lParam2 != sizeof(ICCOMPRESSFRAMES))
	{
		ERRORMESSAGE(("%s: wrong size of ICOMPRESSFRAMES structure", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	if (!lParam1 || (lParam1->dwScale == 0))
	{
		ERRORMESSAGE(("%s: dwScale is zero", _fx_));
		return ((DWORD)ICERR_BADFORMAT);
	}

	lpCompInst->FrameRate = (float)lParam1->dwRate / (float)lParam1->dwScale;

	lpCompInst->DataRate  = (U32)lParam1->lDataRate;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Setting frame rate at %ld.%ld fps and bitrate at %ld bps", _fx_, (DWORD)lpCompInst->FrameRate, (DWORD)((lpCompInst->FrameRate - (float)(DWORD)lpCompInst->FrameRate) * 100.0f), lpCompInst->DataRate * 8UL));

	return ((DWORD)ICERR_OK);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       BOOL bIsOkRes(LPCODINST);
;//
;// Description:    This function checks whether the desired height and
;//                 width are possible.
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
BOOL bIsOkRes(LPCODINST lpCompInst)
{
    BOOL    bRet;

	// Check for NULL pointer
	if (lpCompInst == NULL)
		return 0;

    bRet = lpCompInst->xres <= 352
        && lpCompInst->yres <= 288
        && lpCompInst->xres >= 4
        && lpCompInst->yres >= 4
        && (lpCompInst->xres & ~3) == lpCompInst->xres
        && (lpCompInst->yres & ~3) == lpCompInst->yres;

    return(bRet);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressBegin(
#ifdef USE_BILINEAR_MSH26X
		LPINST pi,
#else
		LPCODINST lpCompInst,
#endif
		LPBITMAPINFOHEADER lParam1,
		LPBITMAPINFOHEADER lParam2
	)
{
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpCompInst = (LPCODINST)pi->CompPtr;
#endif
    DWORD dwQuery;
	LRESULT retval;

#if defined(H263P)
	BOOL bH263PlusState = FALSE;
	if (lpCompInst)
		CustomGetH263PlusState(lpCompInst, (DWORD FAR *)&bH263PlusState);
#endif

	// Check input and output format.
#ifdef USE_BILINEAR_MSH26X
    if( (dwQuery = CompressQuery(pi, lParam1, lParam2)) != ICERR_OK)
#else
    if( (dwQuery = CompressQuery(lpCompInst, lParam1, lParam2)) != ICERR_OK)
#endif
        return(dwQuery);

	// Check instance pointer
	if (!lpCompInst || !lParam1)
		return ICERR_ERROR;

#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
	lpCompInst->InputCompression = lParam1->biCompression;
	lpCompInst->InputBitWidth = lParam1->biBitCount;
	if (((FOURCC_YUV12 == lParam1->biCompression) || (FOURCC_IYUV == lParam1->biCompression)) && (9 == lParam1->biBitCount)) {
		lpCompInst->InputBitWidth = 12;
	}
#endif

#if defined(H263P)
	if ( lParam2 && bH263PlusState)
	{
		// This is the "new" style for indicating if the input should 
		// be cropped/stretched to a standard frame size.
		// Old applications may pass in NULL or junk for lparam2.
		// New applications should pass a valid lParam2 that indicates
		// the desired output frame size. Also, the H263Plus flag must
		// be set in the configuration structure before calling CompressBegin()
	    lpCompInst->xres    = (WORD)lParam2->biWidth;
		lpCompInst->yres    = (WORD)lParam2->biHeight;

	} else	
#endif // H263P
	{
		lpCompInst->xres    = (WORD)lParam1->biWidth;
		lpCompInst->yres    = (WORD)lParam1->biHeight;

		lpCompInst->Is160x120 = FALSE;
		lpCompInst->Is240x180 = FALSE;
		lpCompInst->Is320x240 = FALSE;
		if ( (lParam1->biWidth == 160) && (lParam1->biHeight == 120) )
		{
		  lpCompInst->xres    = 128;
		  lpCompInst->yres    = 96;
		  lpCompInst->Is160x120 = TRUE;
		}
		else if ( (lParam1->biWidth == 240) && (lParam1->biHeight == 180) )
		{
		  lpCompInst->xres    = 176;
		  lpCompInst->yres    = 144;
		  lpCompInst->Is240x180 = TRUE;
		}
		else if ( (lParam1->biWidth == 320) && (lParam1->biHeight == 240) )
		{
		  lpCompInst->xres    = 352;
		  lpCompInst->yres    = 288;
		  lpCompInst->Is320x240 = TRUE;
		}
	}

    if(!bIsOkRes(lpCompInst))
        return((DWORD)ICERR_BADIMAGESIZE);

    // Set frame size.
    if (lpCompInst->xres == 128 && lpCompInst->yres == 96)
  	  lpCompInst->FrameSz = SQCIF;
    else if (lpCompInst->xres == 176 && lpCompInst->yres == 144)
      lpCompInst->FrameSz = QCIF;
    else if (lpCompInst->xres == 352 && lpCompInst->yres == 288)
      lpCompInst->FrameSz = CIF;
#ifdef USE_BILINEAR_MSH26X
    else if (pi->fccHandler == FOURCC_H26X)
      lpCompInst->FrameSz = fCIF;
#endif
#ifdef H263P
	else
	  lpCompInst->FrameSz = CUSTOM;
#else
    else	// unsupported frame size.
      return (DWORD)ICERR_BADIMAGESIZE;
#endif


    // Allocate and Initialize tables and memory that are specific to
    // this instance.
#if defined(H263P) || defined(USE_BILINEAR_MSH26X)
    retval = H263InitEncoderInstance(lParam1,lpCompInst);
#else
    retval = H263InitEncoderInstance(lpCompInst);
#endif

    return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL CompressEnd(LPCODINST);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL CompressEnd(LPCODINST lpInst)
{  
  LRESULT retval;

  retval = H263TermEncoderInstance(lpInst);
  
  return(retval);
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD);
;//
;// Description:    
;//
;// History:        05/11/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
DWORD PASCAL Compress(
#ifdef USE_BILINEAR_MSH26X
				LPINST pi,
#else
				LPCODINST lpInst,			// ptr to Compressor instance information.
#endif
				ICCOMPRESS FAR * lpCompInfo, // ptr to ICCOMPRESS structure.
				DWORD dOutbufSize			// size, in bytes, of the ICCOMPRESS structure.
			)
{
#ifdef USE_BILINEAR_MSH26X
	LPCODINST lpInst = (LPCODINST)pi->CompPtr;			// ptr to Compressor instance information.
#endif
    DWORD dwRet;

	FX_ENTRY("Compress")

	// Check to see if we are given a NULL pointer.
	if(lpInst == NULL || lpCompInfo == NULL)
	{
		ERRORMESSAGE(("%s: called with NULL parameter\r\n", _fx_));
		return( (DWORD) ICERR_ERROR );
	}

    try
	{
#ifdef USE_BILINEAR_MSH26X
        dwRet = H263Compress(pi, lpCompInfo);
#else
        dwRet = H263Compress(lpInst, lpCompInfo);
#endif
    }
    catch (...)
	{
        // For a DEBUG build, display a message and pass the exception up.
        // For a release build, stop the exception here and return an error
        // code.  This gives upstream code a chance to gracefully recover.
		// We also need to clear the floating point control word, otherwise
		// the upstream code may incur an exception the next time it tries
		// a floating point operation (presuming this exception was due
		// to a floating point problem).
#if defined(DEBUG) || defined(_DEBUG)
		ERRORMESSAGE(("%s: Exception occured!!!\r\n", _fx_));
        throw;
#else
		_clearfp();
        return (DWORD) ICERR_ERROR;
#endif
    }

    if(dwRet != ICERR_OK)
	{
		ERRORMESSAGE(("%s: Failed!!!\r\n", _fx_));
	}

    // now transfer the information.
    lpCompInfo->lpbiOutput->biSize =sizeof(BITMAPINFOHEADER);
#ifdef USE_BILINEAR_MSH26X
    lpCompInfo->lpbiOutput->biCompression  = pi->fccHandler;
#else
    lpCompInfo->lpbiOutput->biCompression  = FOURCC_H263;
#endif
    lpCompInfo->lpbiOutput->biPlanes       = 1;
    lpCompInfo->lpbiOutput->biBitCount     = 24;
    lpCompInfo->lpbiOutput->biWidth        = lpInst->xres;
    lpCompInfo->lpbiOutput->biHeight       = lpInst->yres;
    lpCompInfo->lpbiOutput->biSizeImage    = lpInst->CompressedSize;
    lpCompInfo->lpbiOutput->biClrUsed      = 0;
    lpCompInfo->lpbiOutput->biClrImportant = 0;

	// lpCompInfo->dwFlags is set inside the compressor.

	// set the chunk idea if requested
	if (lpCompInfo->lpckid)
	{
		*(lpCompInfo->lpckid) = TWOCC_H26X;
	}
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\exbrc.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * exbrc.cpp
 *
 * Description:
 *   Bit rate control routines for H.261 and H.263.  The bit rate is controlled
 *   by changing QUANT value at the GOB level (H.261) or picture and GOB level
 *   (H.26X).  InitBRC() must be called at the time encoder is instanced; it
 *   initializes some data values in BRCState structure. CalcPQUANT() computes the new
 *   quant. value at the picture level; it must always be called.
 *   CalcMBQUANT computes the new quant. value at the MB level; it need not be 
 *   called if quant. adjustment is done at the picture level.
 *   
 *
 * Routines:
 *   InitBRC
 *   CalcPQUANT
 *   CalcMBQUANT
 * Prototypes in:
 *   e3enc.h
 * Note
 *   Encoder must update BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, and
 *   BRCState->uTargetFrmSize.
 */

/*
 * $Header:   S:\h26x\src\enc\exbrc.cpv   1.15   31 Oct 1996 14:59:26   MBODART  $
 * $Log:   S:\h26x\src\enc\exbrc.cpv  $
// 
//    Rev 1.15   31 Oct 1996 14:59:26   MBODART
// Prevent recent changes from inadvertantly affecting H.261.
// 
//    Rev 1.14   31 Oct 1996 10:05:38   KLILLEVO
// changed from DBOUT to DbgLog
// 
// 
//    Rev 1.13   29 Aug 1996 09:31:54   CZHU
// Map intra-coded GOB to simpliar quality of inter-coded neighbours
// 
//    Rev 1.12   14 Aug 1996 16:46:22   CZHU
// Adjust QP for intra frames other than the first Key frames. 
// 
//    Rev 1.11   12 Mar 1996 13:26:54   KLILLEVO
// new rate control with adaptive bit usage profile
// 
//    Rev 1.10   05 Feb 1996 17:15:12   TRGARDOS
// Added code to do custom quantizer selection for
// still frames
// 
//    Rev 1.9   01 Dec 1995 15:27:06   DBRUCKS
// I removed the QP_mean affects to the global_adj value.
// This resulted in removing any affect of the target frame rate on 
// the global adj value.
// 
//    Rev 1.8   28 Nov 1995 15:01:04   TRGARDOS
// Initialized target frame rate in BRCinit.
// 
//    Rev 1.7   27 Nov 1995 19:26:00   TRGARDOS
// Cleaned up bit rate control functions to be generic h26x bit rate
// controller.  Based off of macro blocks instead of GOBS now.
// 
//    Rev 1.6   26 Oct 1995 19:50:54   TRGARDOS
// Fixed a small mistake in the global adjust calculation
// and changed frame rate to a parameter.
// 
//    Rev 1.5   25 Oct 1995 23:22:36   SINGX
// Changed BRC back to we just get frame rate from client
// and compute global adjust ourselves.
// 
//    Rev 1.4   25 Oct 1995 20:14:40   TRGARDOS
// Added code to use global adjustment passed from client.
// 
//    Rev 1.3   12 Oct 1995 12:04:42   TRGARDOS
// Added QP_mean initialization in initBRC and added clipping
// to all calculations of the new QP.
// 
//    Rev 1.2   11 Oct 1995 19:35:00   TRGARDOS
// Modified bit rate controller.
// 
//    Rev 1.1   09 Oct 1995 11:48:10   TRGARDOS
// Added float typecasting.
// 
//    Rev 1.0   06 Oct 1995 16:41:22   AGUPTA2
// Initial revision.
 */

// PhilF-: In the LAN case and QCIF mode, it looks like even with the smallest quantizer
// we may be way below the max allowed at 30fps. Therefore, with little motion,
// the bitrate looks constant at a low bitrate value. When high motion comes in,
// even with the same small quantizer we will remain below the max. So we will
// use that small quantizer, and the size of those compressed frames will get bigger
// because of the higher motion -> this explains why we don't have a straight
// line in the LAN case when looking at StatView...

#include "precomp.h"

U8 clampQP(int iUnclampedQP)
{
	return ((iUnclampedQP < 2) ? 2 : (iUnclampedQP > 31) ? 31 : iUnclampedQP);
}

/****************************************************************************
 * InitBRC
 * Parameter:
 *   BRCState: T_H263EncoderCatalog ptr
 *   Initializes some some variables in the encoder catalog.
 * Note
 *  Must be called when the encoder is instanced.
 */
void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int numMBs)
{
	FX_ENTRY("InitBRC");

	BRCState->NumMBs = numMBs;
	BRCState->u8INTRA_QP = DefIntraQP;
	BRCState->u8INTER_QP = DefInterQP;
	BRCState->uLastINTRAFrmSz = 0;
	BRCState->uLastINTERFrmSz = 0;
	BRCState->QP_mean = DefIntraQP;
	BRCState->TargetFrameRate = (float) 0.0;
	BRCState->u8StillQnt = 0;

	DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: Bitrate controller initial state:\r\n  numMBs = %ld macroblocks\r\n  u8INTRA_QP = %ld\r\n  u8INTER_QP = %ld\r\n", _fx_, BRCState->NumMBs, BRCState->u8INTRA_QP, BRCState->u8INTER_QP));
	DEBUGMSG(ZONE_BITRATE_CONTROL, ("  uLastINTRAFrmSz = %ld bytes\r\n  uLastINTERFrmSz = %ld bytes\r\n  QP_mean = %ld\r\n  TargetFrameRate = %ld.%ld fps\r\n", BRCState->uLastINTRAFrmSz, BRCState->uLastINTERFrmSz, BRCState->QP_mean, (DWORD)BRCState->TargetFrameRate, (DWORD)((BRCState->TargetFrameRate - (float)(DWORD)BRCState->TargetFrameRate) * 10.0f)));

}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcPQUANT | This function computes the PQUANT value to
 *   use for the current frame. This is done by using the target frame size
 *   and the results achieved with the previous frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The PQUANT value.
 *
 * @comm H.261 does not have PQUANT. So, H261 encoder can call this routine
 *   once and use the value returned as GQUANT for all GOBs.  Or, it can
 *   call CalcMBQUANT for all GOBs.
 *
 *   This routine MUST be called for every frame for which QUANT adjustment
 *   is required. CalcMBQUANT() might not be called.
 *
 * @xref <f FindNewQuant> <f CalcMBQUANT>
 ***************************************************************************/
U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcPQUANT");

    if (PicCodType == INTERPIC)
    {
        if (BRCState->uLastINTERFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last P-frame as the starting point
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTERFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / (float)BRCState->uTargetFrmSize;

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_, clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}
			else
			{
				BRCState->Global_Adj = ((float)((int)BRCState->uLastINTERFrmSz - (int)BRCState->uTargetFrmSize)) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTER_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, QP_mean = %ld)\r\n", _fx_,clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, (DWORD)BRCState->QP_mean));
			}

        	BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj) + (float)0.5));
        }
		else
		{
			// This the first P-frame - use default value
			BRCState->u8INTER_QP = clampQP((unsigned char) BRCState->QP_mean);
			BRCState->Global_Adj = (float)0.0;

			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTER_QP = %ld\r\n", _fx_, BRCState->u8INTER_QP));
		}

        return BRCState->u8INTER_QP;
    }
    else if (PicCodType == INTRAPIC)
    {
        if (BRCState->uLastINTRAFrmSz != 0)
        {
			// Calculate the global adjustment parameter
			// Use the average QP for the last I-frame as the starting point
			// Assume lighting & other conditions haven't changed too much since last I-frame
			// The quantizer increases faster than it decreases
			if (BRCState->uLastINTRAFrmSz > BRCState->uTargetFrmSize)
			{
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float)BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = +%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)BRCState->Global_Adj, (DWORD)((BRCState->Global_Adj - (float)(DWORD)BRCState->Global_Adj) * 100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}
			else
			{
				// This the first I-frame - use default value
				BRCState->Global_Adj = ((float) ((int)BRCState->uLastINTRAFrmSz - (int)BRCState->uTargetFrmSize) ) / ((float) 2.0 * BRCState->uTargetFrmSize);

				DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: New u8INTRA_QP = %ld, Global_Adj = -%ld.%ld (based on uLastINTRAFrmSz = %ld bits, uTargetFrmSize = %ld bits)\r\n", _fx_, clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5)), (DWORD)(BRCState->Global_Adj * -1.0f), (DWORD)((BRCState->Global_Adj - (float)(DWORD)(BRCState->Global_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTRAFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3));
			}

			BRCState->u8INTRA_QP = clampQP((int)(BRCState->u8INTRA_QP * (1 + BRCState->Global_Adj) + (float)0.5));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL, ("%s: First u8INTRA_QP = %ld\r\n", _fx_, clampQP(BRCState->u8INTRA_QP)));
		}

        return clampQP(BRCState->u8INTRA_QP);
    }
    else
    {
		ERRORMESSAGE(("%s: Unknown frame type\r\n", _fx_));
        return clampQP(BRCState->u8INTRA_QP);  //  return any valid value
    }
    
}


/****************************************************************************
 * @doc INTERNAL H263FUNC
 *
 * @func U8 | CalcMBQUANT | This function computes the GQUANT value to
 *   use for the current GOB. This is done by using the target frame size and
 *   the running average of the GQUANTs computed for the previous GOBs in
 *   the current frame.
 *
 * @parm BRCStateStruct * | BRCState | Specifies a pointer to the current
 *   state of the bitrate controller.
 *
 * @parm U32 | uCumPrevFrmSize | Specifies the cumulated size of the previous
 *   GOBs in the previous frame.
 *
 * @parm U32 | uPrevFrmSize | Specifies the total size of the previous
 *   frame.
 *
 * @parm U32 | uCumFrmSize | Specifies the cumulated size of the previous
 *   GOBs.
 *
 * @parm EnumPicCodType | PicCodType | Specifies the type of the current
 *   frame. If set to INTRAPIC, then the current frame is an I-frame. It
 *   set to INTERPIC, then it is a P-frame or a PB-frame.
 *
 * @rdesc The GQUANT value.
 *
 * @xref <f FindNewQuant> <f CalcPQUANT>
 ***************************************************************************/
U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uCumPrevFrmSize, U32 uPrevFrmSize, U32 uCumFrmSize, EnumPicCodType PicCodType)
{
	FX_ENTRY("CalcMBQUANT");

	float		Local_Adj;
	int			TargetCumSize;

	if (PicCodType == INTERPIC)
	{
		// Calculate the local adjustment parameter by looking at how well we've
		// been doing so far with the previous GOBs
		TargetCumSize = (int)uCumPrevFrmSize * BRCState->uTargetFrmSize / uPrevFrmSize;

		// If this is the first GOB there's no local adjustment to compute
		Local_Adj = TargetCumSize ? (float)((int)uCumFrmSize - TargetCumSize) / (float)TargetCumSize : 0.0f;

		BRCState->u8INTER_QP = clampQP((int)(BRCState->QP_mean * (1 + BRCState->Global_Adj + Local_Adj) + (float)0.5));

#ifdef _DEBUG
		if (Local_Adj >= 0L)
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = +%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)Local_Adj, (DWORD)((Local_Adj - (float)(DWORD)Local_Adj) * 100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
		else
		{
			DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTER_QP = %ld, Local_Adj = -%ld.%ld (based on uLastINTERFrmSz = %ld bits, uTargetFrmSize = %ld bits, uCumPrevFrmSize = %ld, uPrevFrmSize = %ld, QP_mean = %ld)\r\n", _fx_, BRCState->u8INTER_QP, (DWORD)(Local_Adj * -1.0f), (DWORD)((Local_Adj - (float)(DWORD)(Local_Adj * -1.0f)) * -100.0f), (DWORD)BRCState->uLastINTERFrmSz << 3, (DWORD)BRCState->uTargetFrmSize << 3, uCumPrevFrmSize, uPrevFrmSize, (DWORD)BRCState->QP_mean));
		}
#endif

		return BRCState->u8INTER_QP;
	}
	else if (PicCodType == INTRAPIC)
	{
		// The previous I-frame is so old that there isn't much point in doing local
		// adjustments - so only consider the global changes
		DEBUGMSG(ZONE_BITRATE_CONTROL_DETAILS, (" %s: New u8INTRA_QP = %ld\r\n", _fx_, BRCState->u8INTRA_QP));

		return BRCState->u8INTRA_QP;
	}
	else
	{
		ERRORMESSAGE(("%s: Unknown frame type\r\n", _fx_));
		return BRCState->u8INTRA_QP;  //  return some valid value
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\adjpels.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\adjpels.asv   1.2   22 Dec 1995 15:54:30   KMILLS  $
;//
;// $Log:   S:\h26x\src\dec\adjpels.asv  $
;// 
;//    Rev 1.2   22 Dec 1995 15:54:30   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.1   31 Oct 1995 10:50:56   BNICKERS
;// Save/restore ebx.
;// 
;//    Rev 1.0   01 Sep 1995 17:14:04   DBRUCKS
;// add adjustpels
;*  
;*     Rev 1.0   29 Mar 1995 12:17:14   BECHOLS
;*  Initial revision.
;// 
;//    Rev 1.2   07 Dec 1994 16:21:04   BNICKERS
;// Prepare entry sequence for flat model.
;// 
;//    Rev 1.1   05 Dec 1994 09:45:18   BNICKERS
;// Prepare for flat model.
;// 
;//    Rev 1.0   15 Jul 1994 11:10:20   BECHOLS
;// Initial revision.
;//
;////////////////////////////////////////////////////////////////////////////
;
;  adjpels -- This function adjusts pel values to track the user's tinkering
;             with brightness, contrast, and saturation knobs.  Each call
;             to this function adjusts one plane.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
;include decinst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <DataAdjustPels>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE AdjustPels (U8 FAR * InstanceBase,
;                                   X32 PlaneBase,
;                                   DWORD PlaneWidth,
;                                   DWORD PlanePitch,
;                                   DWORD PlaneHeight,
;                                   X32 AdjustmentTable);
;
;  In 16-bit Microsoft Windows (tm), InstanceBase provides the segment
;  descriptor for the plane and the adjustment table.
;
;  In 32-bit Microsoft Windows (tm), InstanceBase provides the base to apply
;  to the plane base and the adjustment table.

PUBLIC  AdjustPels

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        AdjustPels  proc DIST LANG AInstanceBase:      DWORD,
                                   APlaneBase:         DWORD,
                                   APlaneWidth:        DWORD,
                                   APlanePitch:        DWORD,
                                   APlaneHeight:       DWORD,
                                   AAdjustmentTable:   DWORD

IFDEF WIN32

LocalFrameSize = 0
RegisterStorageSize = 16

; Arguments:

InstanceBase             = LocalFrameSize + RegisterStorageSize +  4
PlaneBase                = LocalFrameSize + RegisterStorageSize +  8
PlaneWidth               = LocalFrameSize + RegisterStorageSize + 12
PlanePitch               = LocalFrameSize + RegisterStorageSize + 16
PlaneHeight              = LocalFrameSize + RegisterStorageSize + 20
AdjustmentTable          = LocalFrameSize + RegisterStorageSize + 24
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 28


; No Locals (on local stack frame)

LCL EQU <esp+>

ELSE

RegisterStorageSize = 20           ; Put local variables on stack.

; Arguments:

InstanceBase_zero        = RegisterStorageSize +  4
InstanceBase_SegNum      = RegisterStorageSize +  6
PlaneBase                = RegisterStorageSize +  8
PlaneWidth               = RegisterStorageSize + 12
PlanePitch               = RegisterStorageSize + 14
PlaneHeight              = RegisterStorageSize + 16
AdjustmentTable          = RegisterStorageSize + 18
EndOfArgList             = RegisterStorageSize + 20

LCL EQU <>

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   eax,PD InstanceBase[esp]
  mov   esi,PD AdjustmentTable[esp]
  mov   edi,PD PlaneBase[esp]
  add   esi,eax
  add   edi,eax
  mov   ecx,PD PlaneWidth[esp]
  mov   edx,PD PlaneHeight[esp]
  mov   ebp,PD PlanePitch[esp]
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  movzx esi,PW [ebp+AdjustmentTable]
  mov   edi,PD [ebp+PlaneBase]
  movzx ecx,PW [ebp+PlaneWidth]
  movzx edx,PW [ebp+PlaneHeight]
  movzx ebp,PW [ebp+PlanePitch]
ENDIF

  sub   ebp,ecx
   xor  ebx,ebx
  shl   ecx,5
   dec  edx
  shl   edx,16
   xor  eax,eax

; Register usage:
;  ebp -- skip distance, i.e. pitch minus width.
;  esi -- Adjustment table address.
;  edi -- Plane cursor.
;  edx[16:31] -- height.
;  dh  -- width counter.
;  ch  -- width.
;  dl  -- An adjusted pel.
;  cl  -- An adjusted pel.
;  bl  -- A raw pel.
;  al  -- A raw pel.
  
NextLine:
  mov   al,PB [edi  ]
   mov  bl,PB [edi+4]
  mov   dh,ch

Next8Pels:
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]  ; Table duplicated;  avoids many bank conflicts.
  mov   al,PB [edi+1]
   mov  bl,PB [edi+5]
  mov   PB [edi  ],cl
   mov  PB [edi+4],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+2]
   mov  bl,PB [edi+6]
  mov   PB [edi+1],cl
   mov  PB [edi+5],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+3]
   mov  bl,PB [edi+7]
  mov   PB [edi+2],cl
   mov  PB [edi+6],dl
  mov   cl,PB [esi+eax]
   mov  dl,PB [esi+ebx+256+16]
  mov   al,PB [edi+8]
   mov  bl,PB [edi+12]
  mov   PB [edi+3],cl
   mov  PB [edi+7],dl
  add   edi,8
   dec  dh
  jne   Next8Pels

  add   edi,ebp
   sub  edx,000010000H
  jge   NextLine

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

AdjustPels endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\ccinst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\ccinst.inv   1.7   05 Feb 1996 13:35:40   BNICKERS  $
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF _CCINST_INC_
ELSE
_CCINST_INC = 1

include memmodel.inc

; Instance data in the Color Convertor's segment.

IFDEF WIN32

_H26xColorConvertorTbl SEGMENT DWORD PUBLIC 'DATA'
EXTERNDEF H26xColorConvertorTables:BYTE
_H26xColorConvertorTbl ENDS

ELSE

H26xColorConvertorTables = 0
LocalStorageCC EQU H26xColorConvertorTables ; 512 bytes for function locals
H26xColorConvertorTables = 512    ; locals under 16-bit Microsoft windows (tm).

ENDIF


; For CLUT8 and CLUT8Zoom2:

; 64 Dwords of UV contrib to line 0, dithered 4 ways.  Line 1 rotated 2 bytes.
UVDitherLine01  EQU H26xColorConvertorTables + 0

; 64 Dwords of UV contrib to line 2, dithered 4 ways.  Line 3 rotated 2 bytes.
UVDitherLine23  EQU H26xColorConvertorTables + 256

; 262 bytes of Y's contrib to CLUT indices.
YDither         EQU H26xColorConvertorTables + 512

; 26 bytes of padding.

; 256 Dwords of Y's contrib to CLUT indices, dithered 4 ways.
YDitherZ2       EQU H26xColorConvertorTables + 800

IFDEF WIN32
ELSE
SizeOf_CLUT8FixedPart    = H26xColorConvertorTables + 1824
H26xColorConvertorTables = H26xColorConvertorTables - 1824
ENDIF

; For RGB16   (Lo/Hi differ by dither.)

; These are the tables for 555 format.
RValLo        EQU H26xColorConvertorTables + 1824 ; 304 bytes for clamped R val.
GValLo        EQU H26xColorConvertorTables + 2128 ; 262 bytes for clamped G val.
BValLo        EQU H26xColorConvertorTables + 2390 ; 350 bytes for clamped B val.
RValHi        EQU H26xColorConvertorTables + 2740 ; 304 bytes for clamped R val.
GValHi        EQU H26xColorConvertorTables + 3044 ; 262 bytes for clamped G val.
BValHi        EQU H26xColorConvertorTables + 3306 ; 350 bytes for clamped B val.
; 565 format is 2048 bytes after 555 format.
; 655 format is 2048 bytes after 565 format.
; 664 format is 2048 bytes after 655 format.
                                                  ; 24 bytes Padding

UContrib      EQU H26xColorConvertorTables + 9824 ; interleaved with V.
VContrib      EQU H26xColorConvertorTables + 9828 ; interleaved with U.
                                                  ; 512 longwords.

; For RGB16 Zoom By 2.

; These are the tables for 555 format.
RValZ2        EQU H26xColorConvertorTables + 11872 ; 304 Dwords for clamped R.
GValZ2        EQU H26xColorConvertorTables + 13088 ; 262 Dwords for clamped G.
BValZ2        EQU H26xColorConvertorTables + 14136 ; 350 Dwords for clamped B.
; 565 format is 4096 bytes after 555 format.
; 655 format is 4096 bytes after 565 format.
; 664 format is 4096 bytes after 655 format.
                                                   ; 16 bytes Padding
IFDEF WIN32
ELSE
SizeOf_RGB16FixedPart    = H26xColorConvertorTables + 27840
H26xColorConvertorTables = H26xColorConvertorTables - 26016
ENDIF                                 


; For RGB24

B24Value      EQU H26xColorConvertorTables + 27840 ; 701 bytes for clamped Bval.
                                                   ; 3 bytes Padding
R24Value      EQU B24Value + 47                    ; Clamped R value.
G24Value      EQU B24Value + 96                    ; Clamped G value.

U24Contrib    EQU H26xColorConvertorTables + 28544 ; interleaved with V.
V24Contrib    EQU H26xColorConvertorTables + 28548 ; interleaved with U.
                                                   ; 512 longwords.

IFDEF WIN32
ELSE
SizeOf_RGB24FixedPart    = H26xColorConvertorTables + 30592
H26xColorConvertorTables = H26xColorConvertorTables -  2752
ENDIF

ActivePaletteIdxTable EQU H26xColorConvertorTables + 30592 ; 2^16 bytes.
UContribToAPIdx       EQU H26xColorConvertorTables + 96128 ; 1024 bytes UDith.
VContribToAPIdx       EQU H26xColorConvertorTables + 97152 ; 1024 bytes clamp B.

IFDEF WIN32
ELSE
SizeOf_CLUT8APFixedPart  = H26xColorConvertorTables + 12160 ; Keep it same as
H26xColorConvertorTables = H26xColorConvertorTables - 67584 ; three lines above
ENDIF

ENDIF

CCTYPE_YUV12ForEnc         =  0
CCTYPE_CLUT8               =  1
CCTYPE_CLUT8DCI            =  2
CCTYPE_CLUT8ZoomBy2        =  3
CCTYPE_CLUT8ZoomBy2DCI     =  4
CCTYPE_RGB24               =  5
CCTYPE_RGB24DCI            =  6
CCTYPE_RGB24ZoomBy2        =  7
CCTYPE_RGB24ZoomBy2DCI     =  8
CCTYPE_RGB16555            =  9
CCTYPE_RGB16555DCI         = 10
CCTYPE_RGB16555ZoomBy2     = 11
CCTYPE_RGB16555ZoomBy2DCI  = 12  
CCTYPE_IF09                = 13
CCTYPE_RGB16664            = 14
CCTYPE_RGB16664DCI         = 15
CCTYPE_RGB16664ZoomBy2     = 16
CCTYPE_RGB16664ZoomBy2DCI  = 17 
CCTYPE_RGB16565            = 18
CCTYPE_RGB16565DCI         = 19
CCTYPE_RGB16565ZoomBy2     = 20
CCTYPE_RGB16565ZoomBy2DCI  = 21 
CCTYPE_RGB16655            = 22
CCTYPE_RGB16655DCI         = 23
CCTYPE_RGB16655ZoomBy2     = 24
CCTYPE_RGB16655ZoomBy2DCI  = 25 
CCTYPE_CLUT8APDCI          = 26
CCTYPE_CLUT8APZoomBy2DCI   = 27
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\exbrc.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Header:   S:\h26x\src\enc\exbrc.h_v   1.2   12 Mar 1996 13:26:58   KLILLEVO  $
// $Log:   S:\h26x\src\enc\exbrc.h_v  $
;// 
;//    Rev 1.2   12 Mar 1996 13:26:58   KLILLEVO
;// new rate control with adaptive bit usage profile
;// 
;//    Rev 1.1   05 Feb 1996 17:15:22   TRGARDOS
;// Converted an unused byte in the BRCState structure to
;// a variable to store the still quantizer number.
;// 
;//    Rev 1.0   27 Nov 1995 19:49:10   TRGARDOS
;// Initial revision.

#ifndef _EXBRC_H_
#define _EXBRC_H_

/*
 * Structure for bit rate controller state variables.
 * Size of structure is 32 Bytes.
 */
struct BRCStateStruct {
	U32		NumMBs;
	U32		uLastINTRAFrmSz;
	U32		uLastINTERFrmSz;
	int		QP_mean;
	U32		uTargetFrmSize;
	float 	Global_Adj;
	U8		u8INTRA_QP;
	U8		u8INTER_QP;
	U8		u8StillQnt;		// Keeps of tracker of Qnt used for still image compression.
	U8		Unassigned[1];	// pad to make a multiple of 16 bytes.
	float	TargetFrameRate;
	};

void InitBRC(BRCStateStruct *BRCState, U8 DefIntraQP, U8 DefInterQP, int NumMBs);

U8 CalcPQUANT(BRCStateStruct *BRCState, EnumPicCodType PicCodType);

U8 CalcMBQUANT(BRCStateStruct *BRCState, U32 uTargetPos, U32 uTargetSum, U32 uCumFrmSize, EnumPicCodType PicCodType);

U8 clampQP(int iUnclampedQP);

#endif // _EXBRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\flipuyvy.cpp ===
#include "precomp.h"
#include "flip.h"




bool FlipImage(LPCODINST lpCompInst, ICCOMPRESS *lpicComp)
{
	// at the moment, we only know how to flip UYVY
	if (FOURCC_UYVY != lpicComp->lpbiInput->biCompression)
	{
		return false;
	}

	if (lpCompInst->bFlip == FALSE)
	{
		return false;
	}

	return FlipUYVY(lpCompInst, lpicComp);
}


bool FlipUYVY(LPCODINST lpCompInst, ICCOMPRESS *lpicComp)
{
	int nRows, int nCols;
	int nIndex;

	int nPitch;  // row width in bytes;
	int nImageSize;
	BYTE *pSrc, *pDst; // first and last rows
	BYTE *pBuffer=NULL;

	LPBITMAPINFOHEADER pBitMapInfo = lpicComp->lpbiInput;

	nRows = pBitMapInfo->biHeight;
	nCols = pBitMapInfo->biWidth;
	nPitch = nCols * 2;
	nImageSize = nRows * nPitch;


	// allocate the flip buffer if it hasn't already been allcoated
	if ((lpCompInst->pFlipBuffer == NULL) || (lpCompInst->dwFlipBufferSize < nImageSize))
	{
		if (lpCompInst->pFlipBuffer)
		{
			delete [] lpCompInst->pFlipBuffer;
		}
		lpCompInst->pFlipBuffer = (void*) (new BYTE [nImageSize]);
		if (lpCompInst->pFlipBuffer)
		{
			lpCompInst->dwFlipBufferSize = nImageSize;
		}
		else
		{
			lpCompInst->dwFlipBufferSize = 0;
			return false; // out of memory!
		}
	}
	

	pSrc = (BYTE*)lpicComp->lpInput;
	pDst = (BYTE*)(lpCompInst->pFlipBuffer) + (nRows - 1)*nPitch; // bottom of scratch buffer

	for (nIndex = 0; nIndex < nRows; nIndex++)
	{
		CopyMemory(pDst, pSrc, nPitch);
		pSrc += nPitch;
		pDst = pDst - nPitch;
	}

	return true;

}


void ReleaseFlipMemory(LPCODINST lpCompInst)
{
	if (lpCompInst->pFlipBuffer != NULL)
	{
		delete [] lpCompInst->pFlipBuffer;
		lpCompInst->pFlipBuffer = 0;
		lpCompInst->dwFlipBufferSize = 0;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\memmon.h ===
/*
** memmon.h
**
** Structures, equates, and function prototypes to
** access the Memmon VxD.
*/

/*
** Information per VxD
*/
typedef struct {

        unsigned        vi_size;
        unsigned        vi_vhandle;             /* VxDLdr's handle */
        unsigned short  vi_flags;
        unsigned short  vi_cobj;                /* Number of objects */
        char            vi_name[8];             /* Not NULL-terminated */

} VxDInfo;

#define VXD_INITALIZED      0x0001
#define VXD_DYNAMIC         0x8000


/*
** Information per VxD object
*/
typedef struct {

        unsigned        voi_linearaddr;
        unsigned        voi_size;               /* In bytes */
        unsigned        voi_objtype;

} VxDObjInfo;

/*
** VxD Object Types, copied directly from VMM.H
*/
#define RCODE_OBJ       -1

#define LCODE_OBJ       0x01
#define LDATA_OBJ       0x02
#define PCODE_OBJ       0x03
#define PDATA_OBJ       0x04
#define SCODE_OBJ       0x05
#define SDATA_OBJ       0x06
#define CODE16_OBJ      0x07
#define LMSG_OBJ        0x08
#define PMSG_OBJ        0x09

#define DBOC_OBJ        0x0B
#define DBOD_OBJ        0x0C

#define ICODE_OBJ       0x11
#define IDATA_OBJ       0x12
#define ICODE16_OBJ     0x13
#define IMSG_OBJ        0x14


/*
** Load information for a VxD
*/
typedef struct {

        unsigned        vli_size;
        VxDObjInfo      vli_objinfo[1];

} VxDLoadInfo;


/*
** Information for each context
*/
typedef struct {

        unsigned        ciContext;              /* Context ID */
        unsigned        ciProcessID;            /* Win32 process ID */
        unsigned        ciBlockCount;
        unsigned        ciHandle;               /* Memmon's handle */
        unsigned short  ciFlags;
        unsigned short  ciNumContexts;

} ContextInfo;

#define CONTEXT_NEW     0x0001                  /* Never sampled before */
#define CONTEXT_CHANGE  0x0002                  /* context list has changed */


/*
** Information for each block in a context
*/
typedef struct {

        unsigned        brLinAddr;
        unsigned        brPages;
        unsigned        brFlags;                /* PageAllocate flags */
        unsigned        brEIP;                  /* Caller's EIP */

} BlockRecord;


/*
** Page lock information
*/
typedef struct {

        unsigned        liProcessID;
        unsigned        liAddr;
        unsigned char * liBuffer;

} LockInfo;

/*
** The following structure is used internally to for GetPageInfo and
** ClearAccessed.  See memmon.c for usage.
*/
typedef struct {

        unsigned        uAddr;
        unsigned        uNumPages;
        unsigned        uProcessID;
        unsigned        uCurrentProcessID;
        unsigned        uOperation;
        char *          pBuffer;

} PAGEINFO;

#define PAGES_CLEAR     0
#define PAGES_QUERY     1

/*
** Structure filled in by GetSysInfo
*/
typedef struct {

        unsigned        infoSize;
        unsigned        infoMinCacheSize;
        unsigned        infoMaxCacheSize;
        unsigned        infoCurCacheSize;

} SYSINFO, *PSYSINFO;

/*
** Structure used to describe block names
*/
typedef struct {

        char            bnName[32];
        unsigned        bnAddress;
        unsigned        bnNext;

} BLOCKNAME, *PBLOCKNAME;

/*
** DeviceIoCtrl functions.  See memmon.c / psapi.c for usage.
*/
#define MEMMON_DIOC_FindFirstVxD        0x80
#define MEMMON_DIOC_FindNextVxD         0x81
#define MEMMON_DIOC_GetVxDLoadInfo      0x82
#define MEMMON_DIOC_GetFirstContext     0x83
#define MEMMON_DIOC_GetNextContext      0x84
#define MEMMON_DIOC_GetContextInfo      0x85
#define MEMMON_DIOC_SetBuffer           0x86
#define MEMMON_DIOC_FreeBuffer          0x87
#define MEMMON_DIOC_PageInfo            0x88

#define MEMMON_DIOC_WatchProcess        0x89
#define MEMMON_DIOC_GetChanges          0x8A
#define MEMMON_DIOC_QueryWS             0x8B
#define MEMMON_DIOC_EmptyWS             0x8C

#define MEMMON_DIOC_GetHeapSize         0x8D
#define MEMMON_DIOC_GetHeapList         0x8E

#define MEMMON_DIOC_GetSysInfo          0x8F

#define MEMMON_DIOC_AddName             0x90
#define MEMMON_DIOC_RemoveName          0x91
#define MEMMON_DIOC_GetFirstName        0x92
#define MEMMON_DIOC_GetNextName         0x93

/*
** Flags returned in GetBlockInfo and PageInfo calls
*/
#define MEMMON_Present                  0x01
#define MEMMON_Committed                0x02
#define MEMMON_Accessed                 0x04
#define MEMMON_Writeable                0x08
#define MEMMON_Phys                     0x10
#define MEMMON_Lock                     0x20

/*
** Flags used for heap analysis
*/
#define MEMMON_HEAPLOCK                 0x00000000
#define MEMMON_HEAPSWAP                 0x00000200
#define MEMMON_HP_FREE                  0x00000001
#define MEMMON_HP_VALID                 0x00000002
#define MEMMON_HP_FLAGS                 0x00000003
#define MEMMON_HP_ADDRESS               0xFFFFFFFC


/*
** Function prototypes (memmon.c)
*/
int     OpenMemmon( void );
void    CloseMemmon( void );

int     FindFirstVxD( VxDInfo * info );
int     FindNextVxD( VxDInfo * info );
int     GetVxDLoadInfo( VxDLoadInfo * info, int handle, int size );

int     GetFirstContext( ContextInfo * context, BOOL bIgnoreStatus );
int     GetNextContext( ContextInfo * context, BOOL bIgnoreStatus );
int     GetContextInfo( int context, BlockRecord * info, int numblocks );
int     GetLockInfo( unsigned uAddr, unsigned uProcessID, char * pBuffer );

void *  SetBuffer( int pages );
int     FreeBuffer( void );

int     GetPageInfo( unsigned, unsigned, unsigned, char * );
int     ClearAccessed( unsigned, unsigned, unsigned );

void    GetHeapSizeEstimate( unsigned *, unsigned * );
int     GetHeapList( unsigned *, unsigned, unsigned );

int     GetSysInfo( PSYSINFO );

int AddName( unsigned uAddress, char * pszName );
int RemoveName( unsigned uAddress );
int GetFirstName( ContextInfo * pContext, PBLOCKNAME pBlock );
int GetNextName( PBLOCKNAME pBlock );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\precomp.h ===
#include <windows.h>
#include <windowsx.h>   /* for GlobalAllocPtr and GlobalFreePtr */
#include <math.h>
#include <memory.h>     // for _fmemcpy
#include <dos.h>        // for _FP_SEG, _FP_OFF
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>     // MAX_PATH
#include <float.h>
#include <mmreg.h>
#include <mmsystem.h>
#include <msviddrv.h>
#include <mmddk.h> // Equals both?
#include <compddk.h>
//#include <vfw.h>
#ifdef _DEBUG
#ifdef RING0
extern "C" {
#include <std.h>
#include <sys.h>
}
#endif
#endif
#include <confdbg.h>
#include <avutil.h>
#include "ctypedef.h"
#ifdef H261
#include "cxprf.h"
#endif
#include "cdrvdefs.h"
#include "cproto.h"
#include "cldebug.h"
#if 0
// They do test in one case. In the others they always bring d3dec.h
#ifdef H261
#include "d1dec.h"
#else
#include "d3dec.h"
#endif
#endif
#include "d3dec.h"
#include "c3rtp.h"
#include "dxgetbit.h"
#include "d3rtp.h"
#include "d3coltbl.h"
#include "cresourc.h"
#include "cdialogs.h"
#ifndef H261
// They do test in one case. In the others they always bring e3enc.h, e3rtp.h
#include "exbrc.h"
#include "e3enc.h"
#include "e3rtp.h"
#else
// This section never is included... so I guess we haven't defined H261 -> we build H263
// Look for the include files for H.261 and bring them into the build
#include "e1enc.h"
#include "e1rtp.h"
#endif
#include "ccustmsg.h"
#include "ccpuvsn.h"
#include "cdrvcom.h"
#include "d3tables.h"
#include "dxcolori.h"
#include "d3const.h"
#include "d3coltbl.h"
#include "ccodecid.h"
#include "dxap.h"
#include "d3pict.h"
#include "d3gob.h"
#include "d3mblk.h"
#include "d3mvdec.h"
#include "dxfm.h"
#include "d3idct.h"
#include "d3halfmc.h"
#include "d3bvriq.h"
#ifdef RING0
// RINGO ain't defined, so there is no encasst.h
#include "encasst.h"
#endif
#ifdef ENCODE_STATS
#include "e3stat.h"
#endif /* ENCODE_STATS */
#if defined(H263P) || defined(USE_BILINEAR_MSH26X) // {
#include "e3pcolor.h"
#endif
#include "e3vlc.h"
#include "counters.h"
#include "ctiming.h"
#include "MemMon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\memmon.cpp ===
/*
** memmon\api\memmon.c - Win32 functions to talk to Memmon
*/
#include "Precomp.h"

#ifdef TRACK_ALLOCATIONS // { TRACK_ALLOCATIONS

// #define LOG_ALLOCATIONS 1

static HANDLE   hMemmon = INVALID_HANDLE_VALUE;           /* VxD handle */
static unsigned uMyProcessId;

/*
** OpenMemmon - Must be called before any other calls.  Gets a handle to
**              Memmon.
*/
int OpenMemmon( void )
{

#ifdef LOG_ALLOCATIONS
	OutputDebugString("OpenMemmon()\r\n");
#endif

    uMyProcessId = GetCurrentProcessId();
    if( hMemmon != INVALID_HANDLE_VALUE )
        return TRUE;

    hMemmon = CreateFile( "\\\\.\\memmon", GENERIC_READ, 0,
                NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    if( hMemmon == INVALID_HANDLE_VALUE )
        return FALSE;
    else
        return TRUE;
}


/*
** CloseMemmon - Should be called when the program is finished with Memmon.
**               Closes handle.
*/
void CloseMemmon( void )
{

#ifdef LOG_ALLOCATIONS
	OutputDebugString("CloseMemmon()\r\n");
#endif

    /*
    ** If we have a valid handle to memmon, free any buffers and
    ** close it.
    */
    if( hMemmon != INVALID_HANDLE_VALUE ) {
        FreeBuffer();
        CloseHandle( hMemmon );
        hMemmon = INVALID_HANDLE_VALUE;
    }
}


/*
** FindFirstVxD - Get information on the first VxD in the system
**
** Returns 0 on failure, number of VxDs on success
*/
int FindFirstVxD( VxDInfo * info )
{
    int temp, num;

    temp = info->vi_size;
    DeviceIoControl( hMemmon, MEMMON_DIOC_FindFirstVxD,
            info, sizeof( VxDInfo ), NULL, 0, NULL, NULL );
    num = info->vi_size;
    info->vi_size = temp;

    return num;
}


/*
** FindNextVxD - Get information on the next VxD in the system.  Must
**      pass same pointer as used in FindFirstVxD.  Continue to call
**      until it returns FALSE to get all VxDs.
**
** Returns 0 on failure (no more VxDs), >0 on success, -1 for restart
*/
int FindNextVxD( VxDInfo * info )
{
    DeviceIoControl( hMemmon, MEMMON_DIOC_FindNextVxD,
            info, sizeof( VxDInfo ), NULL, 0, NULL, NULL );

    return info->vi_vhandle;
}


/*
** GetVxDLoadInfo - Get information about VxD objects, sizes, etc.
**      info must be large enough to hold all of them.  Use obj
**      count from VxDInfo to allocate appropriate memory.  handle
**      comes from VxDInfo as well.
**
** Returns 0 on failure, >0 on success
*/
int GetVxDLoadInfo( VxDLoadInfo * info, int handle, int size )
{
    info->vli_size = size;
    info->vli_objinfo[0].voi_linearaddr = handle;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetVxDLoadInfo,
                        info, size, NULL, 0, NULL, NULL );
}


/*
** GetFirstContext - Get information on first context in system.
**      ProcessIDs returned will match Toolhelp32 process ids.
**
** ciFlags field of ContextInfo contains 1 if this is the first time
** this context has been examined.
**
** bIgnoreStatus = FALSE - Causes ciFlags to be zero if this context
**              is examined again
** bIgnoreStatus = TRUE - ciFlags will be the same next time as it
**              is this time
**
** Returns 0 on failure, >0 on success
*/
int     GetFirstContext( ContextInfo * context, BOOL bIgnoreStatus )
{
    context->ciProcessID = uMyProcessId;
    if( bIgnoreStatus )
        context->ciFlags = 1;
    else
        context->ciFlags = 0;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetFirstContext,
                context, sizeof( ContextInfo ), NULL, 0, NULL, NULL );
}


/*
** GetNextContext - Pass same structure used in GetFirstContext
**
** ciFlags field of ContextInfo contains 1 if this is the first time
** this context has been examined.
**
** bIgnoreStatus = FALSE - Causes ciFlags to be zero if this context
**              is examined again
** bIgnoreStatus = TRUE - ciFlags will be the same next time as it
**              is this time
**
** Returns 0 on failure (no more contexts), >0 on success
**
** On failure, if the ciHandle field is -1, the list changed during
** the search, and needs to be read again.  (FindFirstContext again)
*/
int     GetNextContext( ContextInfo * context, BOOL bIgnoreStatus )
{
    if( bIgnoreStatus )
        context->ciFlags = 1;
    else
        context->ciFlags = 0;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetNextContext,
                context, sizeof( ContextInfo ), NULL, 0, NULL, NULL );
}


/*
** GetContextInfo - Get a list of block addresses and sizes for a context
**      Use ContextInfo to decide how many, and allocate enough space.
**
** Returns 0 on failure, >0 on success
*/
int     GetContextInfo( int handle, BlockRecord * info, int numblocks )
{
    info->brLinAddr = numblocks;
    info->brPages = handle;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetContextInfo,
                info, numblocks * sizeof( BlockRecord ), NULL,
                0, NULL, NULL );
}


/*
** SetBuffer - Allocate and lock some number of pages
**      - If called more than once, the previous buffer is freed.
**
** pages is the number of pages to allocate
**
** Returns NULL on failure, pointer to buffer on success
*/
void * SetBuffer( int pages )
{
    unsigned uAddr = (unsigned)pages;
    int iRes;

    iRes = DeviceIoControl( hMemmon, MEMMON_DIOC_SetBuffer,
        &uAddr, sizeof( uAddr ), NULL, 0, NULL, NULL );

    if( iRes )
        return (void *)uAddr;
    else
        return NULL;
}


/*
** FreeBuffer - Free the buffer allocated by SetBuffer
**
** Returns 0 on failure, >0 on success
*/
int FreeBuffer( void )
{
    return DeviceIoControl( hMemmon, MEMMON_DIOC_FreeBuffer,
                NULL, 0, NULL, 0, NULL, NULL );
}


/*
** GetPageInfo - Get present/committed/accessed information about a
**      range of pages in a specific process
**
** uAddr is the address to get the information
** uNumPages is the number of pages to get information on
** uProcessID is GetCurrentProcessID() or a process id from ToolHelp
**      It's ignored if the address is a global address
** pBuffer is a buffer uNumPages long where the info will be stored:
**      - one byte for each page, a combination of the following flags:
**              MEMMON_Present
**              MEMMON_Committed
**              MEMMON_Accessed
**              MEMMON_Writeable
**              MEMMON_Lock
**
** Returns 0 on failure, >0 on success
*/
int GetPageInfo( unsigned uAddr, unsigned uNumPages,
                unsigned uProcessID, char * pBuffer )
{
    PAGEINFO        pi;

    pi.uAddr = uAddr;
    pi.uNumPages = uNumPages;
    pi.uProcessID = uProcessID;
    pi.uCurrentProcessID = uMyProcessId;
    pi.uOperation = PAGES_QUERY;
    pi.pBuffer = pBuffer;

    return DeviceIoControl( hMemmon, MEMMON_DIOC_PageInfo,
                &pi, sizeof( PAGEINFO ), NULL, 0, NULL, NULL );
}


/*
** ClearAccessed - Clear accessed bits for a range of process pages
**
** uAddr is the address of the first page to clear
** uNumPages is the number of pages to reset
** uProcessID is GetCurrentProcessID() or a process id from ToolHelp
**              It's ignored if the block is a global block
**
** Returns 0 on failure, >0 on success
*/
int ClearAccessed( unsigned uAddr, unsigned uNumPages, unsigned uProcessID )
{
    PAGEINFO        pi;

    pi.uAddr = uAddr;
    pi.uNumPages = uNumPages;
    pi.uProcessID = uProcessID;
    pi.uCurrentProcessID = uMyProcessId;
    pi.uOperation = PAGES_CLEAR;
    pi.pBuffer = NULL;

    return DeviceIoControl( hMemmon, MEMMON_DIOC_PageInfo,
                &pi, sizeof( PAGEINFO ), NULL, 0, NULL, NULL );
}

/*
** GetHeapSize - return how many allocated blocks in kernel heaps
**
** uSwap    - Estimated number allocated blocks in swappable heap
** uFixed   - Estimated number allocated blocks in fixed heap
**
** This number is lower than the actual number of blocks in the heap.
** Some VMM functions call HeapAllocate directly rather than through
** the service and aren't included in this count.  Free blocks aren't
** included in this count.
**
*/
void GetHeapSizeEstimate( unsigned * uSwap, unsigned * uFixed )
{
    unsigned info[2];

    DeviceIoControl( hMemmon, MEMMON_DIOC_GetHeapSize,
            info, sizeof( info ), NULL, 0, NULL, NULL );

    *uSwap = info[0];
    *uFixed = info[1];
}

/*
** GetHeapList - Get list of busy and free blocks in one of the kernel
**      heaps
**
** pBuffer - buffer to store records
** uSize - size of buffer in bytes
** uFlags - MEMMON_HEAPSWAP or MEMMON_HEAPLOCK
**
** Each record is two dwords.  The first, contains an address and flags:
**
** MEMMON_HP_FREE  - This block heap is not in use
** MEMMON_HP_VALID - If set the size of the block can be calculated by
**                   subtracting this address from the next.  If this
**                   flag isn't set, this block is a sentinel block and
**                   it's size is 0.
**
** The second dword contains the EIP of the caller.  This value is 0
** for all free blocks.  If this value is 0 for a busy block,
** HeapAllocate was called directly (not through the service) and so
** this block was allocated somewhere in VMM.
**
** Returns number of heap blocks stored in buffer
*/
int GetHeapList( unsigned * pBuffer, unsigned uSize, unsigned uFlags )
{
    unsigned info[3];

    info[0] = (unsigned)pBuffer;
    info[1] = uSize;
    info[2] = uFlags;

    DeviceIoControl( hMemmon, MEMMON_DIOC_GetHeapList,
            info, sizeof( info ), NULL, 0, NULL, NULL );

    return info[0];
}

/*
** GetSysInfo - get system info from memmon
**
** pInfo - pointer to SYSINFO struct to fill in
**
** Returns: 0 on failure, non 0 on success
*/
int GetSysInfo( PSYSINFO pInfo )
{
    pInfo->infoSize = sizeof( SYSINFO );
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetSysInfo,
            pInfo, pInfo->infoSize, NULL, 0, NULL, NULL );
}

/*
** AddName - Add a name to Memmon's name list for this process
**
** uAddress     - Address of block to name
** pszName      - name of block
**
** Returns 0 on success, non-0 on failure
*/
int AddName( unsigned uAddress, char * pszName )
{
    unsigned info[3];
	int res;

#ifdef LOG_ALLOCATIONS
	char szDebug[96];

	wsprintf(szDebug, "ADD - 0x%08lX - %s\r\n", uAddress, pszName);
	OutputDebugString(szDebug);
#endif

    info[0] = uMyProcessId;
    info[1] = uAddress;
    info[2] = (unsigned)pszName;
    res = DeviceIoControl( hMemmon, MEMMON_DIOC_AddName,
            info, sizeof( info ), NULL, 0, NULL, NULL );

	if (res)
		OutputDebugString("SUCCESS\r\n");
	else
		OutputDebugString("FAILURE\r\n");

	return res;	
}

/*
** RemoveName - Remove a name from Memmon's name list for this process
**
** uAddress     - Address of block to remove name
**
** Returns 0 on success, non-0 on failure
*/
int RemoveName( unsigned uAddress )
{
    unsigned info[2];

#ifdef LOG_ALLOCATIONS
	char szDebug[96];

	wsprintf(szDebug, "RMV - 0x%08lX \r\n", uAddress);
	OutputDebugString(szDebug);
#endif

    info[0] = uMyProcessId;
    info[1] = uAddress;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_RemoveName,
            info, sizeof( info ), NULL, 0, NULL, NULL );
}

/*
** GetFirstName - Get first name in name list for a context
**
** pContext - Context to get first name in
** pName    - Buffer to use for name info
**
** Returns 0 on success, non-0 on failure
*/
int GetFirstName( ContextInfo * pContext, PBLOCKNAME pBlock )
{
    unsigned info[2];

    info[0] = (unsigned)pContext;
    info[1] = (unsigned)pBlock;
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetFirstName,
            info, sizeof( info ), NULL, 0, NULL, NULL );
}

/*
** GetNextName - Remove a name from Memmon's name list for this process
**
** pBlock   - Buffer to save info
**
** Returns 0 on success, non-0 on failure
*/
int GetNextName( PBLOCKNAME pBlock )
{
    return DeviceIoControl( hMemmon, MEMMON_DIOC_GetNextName,
            pBlock, sizeof( BLOCKNAME ), NULL, 0, NULL, NULL );
}


#endif // } TRACK_ALLOCATIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\clocals.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\common\clocals.inv   1.1   27 Dec 1995 14:12:04   RMCKENZX  $
;// $Log:   S:\h26x\src\common\clocals.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:12:04   RMCKENZX
;// 
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

include memmodel.inc
IFDEF WIN32
LDal    macro   address
        mov     al,BYTE PTR address[esp]
        endm

LDbl    macro   address
        mov     bl,BYTE PTR address[esp]
        endm

LDcl    macro   address
        mov     cl,BYTE PTR address[esp]
        endm

LDdl    macro   address
        mov     dl,BYTE PTR address[esp]
        endm

LDah    macro   address
        mov     ah,BYTE PTR address[esp]
        endm

LDbh    macro   address
        mov     bh,BYTE PTR address[esp]
        endm

LDch    macro   address
        mov     ch,BYTE PTR address[esp]
        endm

LDdh    macro   address
        mov     dh,BYTE PTR address[esp]
        endm

Leax    macro   address
        mov     eax,DWORD PTR address[esp]
        endm

Lebx    macro   address
        mov     ebx,DWORD PTR address[esp]
        endm

Lecx    macro   address
        mov     ecx,DWORD PTR address[esp]
        endm

Ledx    macro   address
        mov     edx,DWORD PTR address[esp]
        endm

Lesi    macro   address
        mov     esi,DWORD PTR address[esp]
        endm

Ledi    macro   address
        mov     edi,DWORD PTR address[esp]
        endm

Lebp    macro   address
        mov     ebp,DWORD PTR address[esp]
        endm

LZeax   macro   address
        movzx   eax,BYTE PTR address[esp]
        endm

LZebx   macro   address
        movzx   ebx,BYTE PTR address[esp]
        endm

LZecx   macro   address
        movzx   ecx,BYTE PTR address[esp]
        endm

LZedx   macro   address
        movzx   edx,BYTE PTR address[esp]
        endm

LZesi   macro   address
        movzx   esi,BYTE PTR address[esp]
        endm

LZedi   macro   address
        movzx   edi,BYTE PTR address[esp]
        endm

LZebp   macro   address
        movzx   ebp,BYTE PTR address[esp]
        endm

STal    macro   address
        mov     BYTE PTR address[esp],al
        endm

STbl    macro   address
        mov     BYTE PTR address[esp],bl
        endm

STcl    macro   address
        mov     BYTE PTR address[esp],cl
        endm

STdl    macro   address
        mov     BYTE PTR address[esp],dl
        endm

STah    macro   address
        mov     BYTE PTR address[esp],ah
        endm

STbh    macro   address
        mov     BYTE PTR address[esp],bh
        endm

STch    macro   address
        mov     BYTE PTR address[esp],ch
        endm

STdh    macro   address
        mov     BYTE PTR address[esp],dh
        endm

Seax    macro   address
        mov     DWORD PTR address[esp],eax
        endm

Sebx    macro   address
        mov     DWORD PTR address[esp],ebx
        endm

Secx    macro   address
        mov     DWORD PTR address[esp],ecx
        endm

Sedx    macro   address
        mov     DWORD PTR address[esp],edx
        endm

Sesi    macro   address
        mov     DWORD PTR address[esp],esi
        endm

Sedi    macro   address
        mov     DWORD PTR address[esp],edi
        endm

Sebp    macro   address
        mov     DWORD PTR address[esp],ebp
        endm

ADDeax  macro   address
        add     eax,DWORD PTR address[esp]
        endm

ADDebx  macro   address
        add     ebx,DWORD PTR address[esp]
        endm

ADDecx  macro   address
        add     ecx,DWORD PTR address[esp]
        endm

ADDedx  macro   address
        add     edx,DWORD PTR address[esp]
        endm

ADDesi  macro   address
        add     esi,DWORD PTR address[esp]
        endm

ADDedi  macro   address
        add     edi,DWORD PTR address[esp]
        endm

ADDebp  macro   address
        add     ebp,DWORD PTR address[esp]
        endm

SUBeax  macro   address
        sub     eax,DWORD PTR address[esp]
        endm

SUBebx  macro   address
        sub     ebx,DWORD PTR address[esp]
        endm

SUBecx  macro   address
        sub     ecx,DWORD PTR address[esp]
        endm

SUBedx  macro   address
        sub     edx,DWORD PTR address[esp]
        endm

SUBesi  macro   address
        sub     esi,DWORD PTR address[esp]
        endm

SUBedi  macro   address
        sub     edi,DWORD PTR address[esp]
        endm

SUBebp  macro   address
        sub     ebp,DWORD PTR address[esp]
        endm

CMPeax  macro   address
        cmp     eax,DWORD PTR address[esp]
        endm

CMPebx  macro   address
        cmp     ebx,DWORD PTR address[esp]
        endm

CMPecx  macro   address
        cmp     ecx,DWORD PTR address[esp]
        endm

CMPedx  macro   address
        cmp     edx,DWORD PTR address[esp]
        endm

CMPesi  macro   address
        cmp     esi,DWORD PTR address[esp]
        endm

CMPedi  macro   address
        cmp     edi,DWORD PTR address[esp]
        endm

CMPebp  macro   address
        cmp     ebp,DWORD PTR address[esp]
        endm

ADDC2M  macro   address,constant
        add     DWORD PTR address[esp],constant
        endm

ELSE
LDal    macro   address
        DB      0A0H            ; opcode: move memory to accumulator (al)
        DD      address         ; source
        endm

LDbl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      01DH            ; destination: bl
        DD      address         ; source
        endm

LDcl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      00DH            ; destination: cl
        DD      address         ; source
        endm

LDdl    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      015H            ; destination: dl
        DD      address         ; source
        endm

LDah    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      025H            ; destination: ah
        DD      address         ; source
        endm

LDbh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      03DH            ; destination: bh
        DD      address         ; source
        endm

LDch    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      02DH            ; destination: ch
        DD      address         ; source
        endm

LDdh    macro   address
        DB      08AH            ; opcode: move memory to register
        DB      035H            ; destination: dh
        DD      address         ; source
        endm

Leax    macro   address
        DB      0A1H            ; opcode: move memory to accumulator (eax)
        DD      address         ; source
        endm

Lebx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

Lecx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

Ledx    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

Lesi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

Ledi    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

Lebp    macro   address
        DB      08BH            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

LZeax   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

LZebx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

LZecx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

LZedx   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

LZesi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

LZedi   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

LZebp   macro   address
        DB      00FH            ; opcode prefix
        DB      0B6H            ; opcode: move memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

STal    macro   address
        DB      0A2H            ; opcode: move accumulator (al) to memory
        DD      address         ; destination
        endm

STbl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      01DH            ; source: bl
        DD      address         ; destination
        endm

STcl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      00DH            ; source: cl
        DD      address         ; destination
        endm

STdl    macro   address
        DB      088H            ; opcode: move register to memory
        DB      015H            ; source: dl
        DD      address         ; destination
        endm

STah    macro   address
        DB      088H            ; opcode: move register to memory
        DB      025H            ; source: ah
        DD      address         ; destination
        endm

STbh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      03DH            ; source: bh
        DD      address         ; destination
        endm

STch    macro   address
        DB      088H            ; opcode: move register to memory
        DB      02DH            ; source: ch
        DD      address         ; destination
        endm

STdh    macro   address
        DB      088H            ; opcode: move register to memory
        DB      035H            ; source: dh
        DD      address         ; destination
        endm

Seax    macro   address
        DB      0A3H            ; opcode: move accumulator (eax) to memory
        DD      address         ; destination
        endm

Sebx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      01DH            ; source: ebx
        DD      address         ; destination
        endm

Secx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      00DH            ; source: ecx
        DD      address         ; destination
        endm

Sedx    macro   address
        DB      089H            ; opcode: move register to memory
        DB      015H            ; source: edx
        DD      address         ; destination
        endm

Sesi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      035H            ; source: esi
        DD      address         ; destination
        endm

Sedi    macro   address
        DB      089H            ; opcode: move register to memory
        DB      03DH            ; source: edi
        DD      address         ; destination
        endm

Sebp    macro   address
        DB      089H            ; opcode: move register to memory
        DB      02DH            ; source: ebp
        DD      address         ; destination
        endm

ADDeax  macro   address
        DB      003H            ; opcode: add memory to register
        DB      005H            ; destination: eax
        DD      address         ; source
        endm

ADDebx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

ADDecx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

ADDedx  macro   address
        DB      003H            ; opcode: add memory to register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

ADDesi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

ADDedi  macro   address
        DB      003H            ; opcode: add memory to register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

ADDebp  macro   address
        DB      003H            ; opcode: add memory to register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

SUBeax  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      005H            ; source: eax
        DD      address         ; destination
        endm

SUBebx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      01DH            ; destination: ebx
        DD      address         ; source
        endm

SUBecx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      00DH            ; destination: ecx
        DD      address         ; source
        endm

SUBedx  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      015H            ; destination: edx
        DD      address         ; source
        endm

SUBesi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      035H            ; destination: esi
        DD      address         ; source
        endm

SUBedi  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      03DH            ; destination: edi
        DD      address         ; source
        endm

SUBebp  macro   address
        DB      02BH            ; opcode: subtract memory from register
        DB      02DH            ; destination: ebp
        DD      address         ; source
        endm

CMPeax  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      005H            ; source: eax
        DD      address         ; source
        endm

CMPebx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      01DH            ; source: ebx
        DD      address         ; source
        endm

CMPecx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      00DH            ; source: ecx
        DD      address         ; source
        endm

CMPedx  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      015H            ; source: edx
        DD      address         ; source
        endm

CMPesi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      035H            ; source: esi
        DD      address         ; source
        endm

CMPedi  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      03DH            ; source: edi
        DD      address         ; source
        endm

CMPebp  macro   address
        DB      03BH            ; opcode: compare register with memory
        DB      02DH            ; source: ebp
        DD      address         ; source
        endm

ADDC2M  macro   address,constant
        add     ds:DWORD PTR address,constant
        endm

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512162.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512162.asv
;//
;// $Log:   S:\h26x\src\dec\cx512162.asv  $
;// 
;//    Rev 1.8   22 Mar 1996 16:41:06   BNICKERS
;// Fix bug wherein UV contrib was being taken from one pel to the right.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:00   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 10:02:00   BNICKERS
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   16 Feb 1996 15:12:42   BNICKERS
;// Correct color shift.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:22   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:38:54   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:54   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:16   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:18   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by two.
; ||||||||
; cx512162 -- This function performs zoom-by-2 YUV12-to-RGB16 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  for H26x.  It handles any format in which there
;             are three fields, the low order field being B and fully contained
;             in the low order byte, the second field being G and being
;             somewhere in bits 4 through 11, and the high order field being
;             R and fully contained in the high order byte.  Present support
;             for 555, 565, 655, and 644 formats only.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD, AUPlane: DWORD, AFrameWidth: DWORD, AFrameHeight: DWORD,
AYPitch: DWORD, AVPitch: DWORD, AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD, ADCIOffset: DWORD, ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD, ACCType: DWORD

LocalFrameSize = 64+768*6+24
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
LineParity               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
StashOddLinePel0         EQU  [esp+72]
StashOddLinePel1         EQU  [esp+76]
StashOddLinePel2         EQU  [esp+80]
StashOddLinePel3         EQU  [esp+84]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0/2
  cmp   ebx,CCTYPE_RGB16555ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16555ZoomBy2DCI
  je    @f
  mov   ecx,4096/2
  cmp   ebx,CCTYPE_RGB16565ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16565ZoomBy2DCI
  je    @f
  mov   ecx,8192/2
  cmp   ebx,CCTYPE_RGB16655ZoomBy2
  je    @f
  cmp   ebx,CCTYPE_RGB16655ZoomBy2DCI
  je    @f
  mov   ecx,12288/2
  cmp   ebx,CCTYPE_RGB16664ZoomBy2DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664ZoomBy2
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
   mov  StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  shl   ebx,2
   add  edx,esi
  sub   eax,ebx
   mov  YSkipDistance,ecx
  shr   ebx,3
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  YLimit,edx
  mov   esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,24
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-20],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  mov   esi,YCursor
   xor  ecx,ecx
  mov   [edi],ecx                    ; Store EOL indicator.
   mov  edx,CCType
  mov   dl,[esi]                     ; Fetch Y00.
   xor  ebx,ebx
  mov   bl,ChromaContribution        ; Get U contribution to B value.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3,edx         ; Stash offset to RGB table to use.
   mov  edi,CCOCursor
  mov   al,ChromaContribution+2      ; Get V contribution to R value.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+1      ; Get UV contribution to G value.
   mov  LineParity,ch
  and   eax,0FFH
   sub  esp,4608

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- Construction of a pel (twice) of RGB16.
;  edx -- Y value (i.e. Y contribution to R, G, and B) times 4, plus offset
;         to select appropriate table.
;  cl  -- UV contribution to G field of RGB value.
;  bl  -- U contribution to B field of RGB value.
;  al  -- V contribution to R field of RGB value.

DoLine1:
DoNext4YPelsOfLine0:

   mov  ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel00.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel00.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel00.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi],ebp                 ; Store Pel00 to color converted output.
   mov  dl,[esi+1]                   ; Fetch Y01.
  rol   ebp,16                       ; Swap Pel00 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel0+4608,ebp    ; Stash Pel00 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  add   edi,16                       ; Advance output cursor.
   add  esi,4                        ; Advance luma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel01.
   mov  bl,ChromaContribution+4+4608 ; Load U contribution to B val for pels2&3.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel01.
   mov  al,ChromaContribution+6+4608 ; Load V contribution to R val for pels2&3.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel01.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+4-16],ebp            ; Store Pel01 to color converted output.
   mov  dl,[esi+2-4]                 ; Fetch Y02.
  rol   ebp,16                       ; Swap Pel01 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel1+4608,ebp    ; Stash Pel01 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  mov   cl,ChromaContribution+5+4608 ; Load UV contrib to G val for pels2&3.
   add  esp,24                       ; Advance chroma cursor.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel02.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel02.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel02.
   mov  edx,StashOddLinePel3+4608-24 ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+8-16],ebp            ; Store Pel02 to color converted output.
   mov  dl,[esi+3-4]                 ; Fetch Y03.
  rol   ebp,16                       ; Swap Pel02 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y02 to 7 bits.
  mov   StashOddLinePel3+4608,edx    ; Stash offset to RGB table to use.
   add  edx,edx                      ; Get four times luma.
  mov   StashOddLinePel2+4608-24,ebp ; Stash Pel02 for later xfer to 2nd line.
   mov  esi,esi                      ; Keep pairing happy.
  mov   ebp,PD BValZ2[edx+ebx*4]     ; Get clamped B value for Pel03.
   mov  bl,ChromaContribution+0+4608 ; Load U contribution to B val for pels0&1.
  or    ebp,PD RValZ2[edx+eax*4]     ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+2+4608 ; Load V contribution to R val for pels0&1.
  or    ebp,PD GValZ2[edx+ecx*4]     ; Get clamped G value for Pel03.
   mov  edx,StashOddLinePel3+4608    ; edx[8:31] == Offset to RGB tbl, div by 2.
  mov   Ze [edi+12-16],ebp           ; Store Pel03 to color converted output.
   mov  dl,[esi]                     ; Fetch Y00.
  rol   ebp,16                       ; Swap Pel03 copies, for better dither.
   and  edx,0FFFFFFFEH               ; Reduce to Y00 to 7 bits.
  mov   StashOddLinePel3+4608-24,ebp ; Stash Pel03 for later xfer to 2nd line.
   add  edx,edx                      ; Get four times luma.
  test  eax,eax
   mov  cl,ChromaContribution+1+4608 ; Load UV contrib to G val for pels2&3.
  jne   DoNext4YPelsOfLine0
   
  and   esp,0FFFFE000H
  add   esp,02000H
  mov   edx,YSkipDistance
   mov  ebp,CCOSkipDistance
  add   esi,edx
   mov  ebx,AspectCount
  add   edi,ebp
   sub  ebx,2                    ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   lea  ecx,StashOddLinePel0
  mov   edx,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   eax,[ecx]
   mov  ebx,[ecx+4]
  mov   Ze [edi],eax
   mov  eax,[ecx+8]
  mov   Ze [edi+4],ebx
   mov  ebx,[ecx+12]
  mov   Ze [edi+8],eax
   add  ecx,24
  mov   Ze [edi+12],ebx
   add  edi,16
  sub   edx,4
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebp

Skip2ndLineOfLine0:

   mov  al,LineParity
  xor   al,1
   je   Line1Done

  mov   LineParity,al
   mov  edx,CCType
  mov   dl,[esi]
   xor  ebx,ebx
  mov   bl,ChromaContribution
   and  edx,0FFFFFFFEH
  mov   StashOddLinePel3,edx
   xor  ecx,ecx
  add   edx,edx
   mov  al,ChromaContribution+2
  mov   cl,ChromaContribution+1
   sub  esp,4608
  and   eax,0FFH
   jmp  DoLine1

Line1Done:

  mov   YCursor,esi
   mov  eax,esi
  mov   CCOCursor,edi
   mov  ecx,ChromaPitch
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cmemmod.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\common\cmemmod.inv   1.1   27 Dec 1995 14:12:08   RMCKENZX  $
;// $Log:   S:\h26x\src\common\cmemmod.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:12:08   RMCKENZX
;// 
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

IFDEF memmodel_inc
ELSE

IFDEF WIN32
.486
.MODEL FLAT, STDCALL
Zd EQU <>
Ze EQU <>
Zf EQU <>
Zg EQU <>
Zs EQU <>
Zc EQU <>
BPTR equ ebp
SPTR equ esp
NAT_WORD TEXTEQU <DWORD>

ELSE

.MODEL MEDIUM
.486
Zd EQU <ds:>
Ze EQU <es:>
Zf EQU <fs:>
Zg EQU <gs:>
Zs EQU <ss:>
Zc EQU <cs:>
BPTR equ bp
SPTR equ sp
NAT_WORD TEXTEQU <WORD>

ENDIF

PD EQU <DWORD PTR>
PW EQU <WORD PTR>
PB EQU <BYTE PTR>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; this provides a normal return when under WIN32 and
;; a 16 bit mode instruction override when under not WIN32
;;
;; This is needed as the segment this code runs in is
;; in 32 bit mode but the caller is in 16 bit mode.
;;
;; under WIN32, we must relieve the stack of passed
;; args, and with proper setup of the PROC directive,
;; the assembler will calculate the correct value
;; to relieve every time it sees the ret.
;;
;; this also sets the language to 'C' when not under WIN32 and
;; stdcall when under WIN32
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifdef WIN32
LANG    TEXTEQU <stdcall>
DIST    TEXTEQU <>
rturn   MACRO
	ret
ENDM
else
LANG    TEXTEQU <C>
DIST    TEXTEQU <FAR>
rturn   MACRO
	db      66h
	retf
ENDM
endif

memmodel_inc=1

; this is intended to emulate a disabled epilouge with the single
; exception of relieving the stack of passed parameters if
; the calling type is STDCALL.
;
; only stdcall and c calling conventions are directly supported.
; VARARGS is not supported.
; NONE of the standard prologue or epilogue switches
; are used.
; Like the standard epilogue, the use of retf, retn or ret n
; where n is the number of bytes to relieve, this macro
; is effectively disabled.
ReturnAndRelieveEpilogueMacro MACRO procname, \
                                    flag,     \
                                    parmbytes, \
                                    localbytes, \
                                    reglist, \
                                    macroargs
LOCAL RET_DIST
if (flag AND 020h)
; We are in a FAR procedure
	RET_DIST TEXTEQU <retf>
else
; We are in a local procedure
	RET_DIST TEXTEQU <ret>
endif

if (flag AND 010h)
; user restoring the stack: ret n, retf or retn was used
	RET_DIST
else
; user expects us to restore the stack: ret was used
if (flag AND 007h) EQ 3
; stdcall calling convention
if parmbytes EQ 0
	RET_DIST
else
	RET_DIST		parmbytes
endif
else
; assume 'C' calling convention
	RET_DIST
endif

endif
ENDM

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512241.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512241.asv
;//
;// $Log:   S:\h26x\src\dec\cx512241.asv  $
;// 
;//    Rev 1.7   27 Mar 1996 18:39:26   RMCKENZX
;// Corrected bug in line parity which manifests on odd aspects.
;// 
;//    Rev 1.6   27 Mar 1996 14:41:46   RMCKENZX
;// Changed YSkipDistance to use register ebp, not eax.  When
;// pitch-width was more than 255, the first 4 pels of odd lines
;// would get erroneous values for blue, due to the presence of
;// non-zero values in the high order bits of eax.  Also cleaned a
;// few comments.
;// 
;//    Rev 1.5   18 Mar 1996 09:58:46   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.4   05 Feb 1996 13:35:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   22 Dec 1995 15:40:52   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   30 Oct 1995 17:15:30   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:47:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:30   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512241 -- This function performs YUV12-to-RGB24 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB24    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]
G2B2R1G1                 EQU  [esp+68]
R3G3B3R2                 EQU  [esp+72]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF000H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebx
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   mov  CCOSkipDistance,eax
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   YLimit,edx
   mov  YCursor,esi
  mov   esi,VCursor
   xor  eax,eax
  mov   LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[ 9:15] -- Zero (pad).
  ;                                 ; ebx[ 0: 8] -- Zero (red).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,16
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-12],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   xor  ebx,ebx
  mov   [edi+4],ecx                 ; Store EOL indicator.
   mov  edx,AspectCount
  mov   edi,CCOCursor
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   esi,YCursor
   mov  AspectCount,edx
  jne   KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of one and a third pels of RGB24.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl,al  -- UV contrib to G field of RGB val,  U contrib to B field of RGB val.

  mov   cl,[esi+3]                     ; Get Y03.
   mov  bl,ChromaContribution+6        ; Get UV contribution to G value.
  mov   ebp,ChromaContribution+4       ; Get V contribution to R value.
   sub  esp,3072
  and   ebp,01FFH                      ; Extract V contribution to R value.
   mov  dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.

DoNext4YPelsOfLine0:

  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel03.
   mov  al,ChromaContribution+3072+7   ; Get U contribution to B value.
  shl   edx,16                         ; Position R and G value for Pel03.
   mov  bl,[esi+2]                     ; Get Y02.
  mov   dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel03.
   mov  cl,ChromaContribution+3072+6   ; Reload UV contribution to G value.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel02.
   mov  ebp,ChromaContribution+3072    ; Get V contribution to R value.
  mov   R3G3B3R2+3072,edx              ; Stash 1.33 pels.
   mov  dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel02.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel02.
   mov  cl,[esi+1]                     ; Get Y01.
  mov   bl,ChromaContribution+3072+2   ; Get UV contribution to G value.
   and  ebp,01FFH                      ; Extract V contribution to R value.
  shl   edx,16                         ; Position G and B values for Pel02.
   mov  al,ChromaContribution+3072+3   ; Get U contribution to B value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   mov  bl,[esi]                       ; Get Y00.
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   add  esi,4                          ; Advance source stream cursor.
  mov   G2B2R1G1+3072,edx              ; Stash 1.33 pels.
   mov  dh,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
  mov   cl,ChromaContribution+3072+2   ; Reload UV contribution to G value.
   add  edi,12                         ; Advance color converted output cursor.
  mov   dl,PB R24Value[ebx+ebp*1]      ; Get clamped R value for Pel00.
   mov  ebp,ChromaContribution+3072+20 ; Get next V contribution to R value.
  shl   edx,16                         ; Position R for Pel00 and B for Pel01.
   and  ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
  mov   dl,PB B24Value[ebx+eax*2]      ; Get clamped B value for Pel00.
   mov  eax,G2B2R1G1+3072              ; Reload 2nd 1.33 pels.
  mov   dh,PB G24Value[ebx+ecx]        ; Get clamped G value for Pel00.
   mov  cl,[esi+3]                     ; Get next Y03.
  mov   Ze [edi-12],edx                ; Write the first 1.33 pels out.
   mov  bl,ChromaContribution+3072+22  ; Get UV contribution to G value.
  mov   Ze [edi-8],eax                 ; Write the second 1.33 pels out.
   mov  edx,R3G3B3R2+3072
  mov   Ze [edi-4],edx                 ; Write the third 1.33 pels out.
   mov  eax,ebx                        ; Zero out upper bytes of eax.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel03.
   lea  esp,[esp+16]
  jne   DoNext4YPelsOfLine0

  and   esp,0FFFFF000H
  add   esp,1000H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx1209.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;// 
;// $Header:   S:\h26x\src\dec\cx51209.asv
;// 
;// $Log:   S:\h26x\src\dec\cx51209.asv
;// 
;////////////////////////////////////////////////////////////////////////////
; cx1209  -- This function performs YUV12 to IF09 color conversion for H26x.
;            IF09 consists of Y, V, U in 8-bit, planar format, plus a plane of
;            4-bit flags, each in 8 bits of storage, with each bit indicative
;            of which dwords of Y are unchanged from the previous frame.
;            IF09 is only applicable using DCI.
;
;            This version is tuned for maximum performance on both the Pentium
;            (r) microcprocessor and the Pentium Pro (tm) microprocessor.
;
;            Indentation of instructions indicates expected U/V pipe execution
;            on Pentium (r) microprocessor;  indented instructions are
;            expected to execute in V-pipe, outdented instructions in U-pipe.
;            Inside loops, blank lines delineate groups of 1, 2, or 3
;            instructions that are expected to be decoded simultaneously
;            on the Pentium Pro (tm) microprocessor.
;
; cx1209
; ^^^^^^
; ||||++----- Convert to IF09.
; ||++------- Convert from YUV12.
; |+--------- For both H261 and H263.
; +---------- Color convertor.
;-------------------------------------------------------------------------------
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx1209>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

PUBLIC  YUV12ToIF09
YUV12ToIF09    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AUVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

; void * YUV12ToIF09 (
;       U8 * YPlane,
;       U8 * VPlane,
;       U8 * UPlane,
;       UN  FrameWidth,
;       UN  FrameHeight,
;       UN  YPitch,
;       UN  UVPitch,
;       UN  AspectAdjustmentCount,
;       U8 * ColorConvertedFrame,
;       U32 DCIOffset,
;       U32 CCOffsetToLine0,
;       IN  CCOPitch,
;       IN  CCType)
;
;  YPlane and VPlane are offsets relative to InstanceBase.  In 16-bit Microsoft
;  Windows (tm), space in this segment is used for local variables and tables.
;  In 32-bit variants of Microsoft Windows (tm), the local variables are on
;  the stack, while the tables are in the one and only data segment.
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;
IFDEF WIN32

LocalFrameSize = 32
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
FrameWidth               = LocalFrameSize + RegisterStorageSize + 12
FrameHeight              = LocalFrameSize + RegisterStorageSize + 16
YPitch                   = LocalFrameSize + RegisterStorageSize + 20
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 24
DCIOffset                = LocalFrameSize + RegisterStorageSize + 28
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 32
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 36
CCType                   = LocalFrameSize + RegisterStorageSize + 40
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 44

; Locals (on local stack frame)

CCOCursor                  =   0
YLimit                     =   4
CCOVCursor                 =   8
CCOUCursor                 =  12
CCOSkipCursor              =  16
VLimit                     =  20
YLine1Limit                =  24
CCOUVPitch                 =  28

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
FrameWidth_arg             = RegisterStorageSize + 16
FrameHeight_arg            = RegisterStorageSize + 18
YPitch_arg                 = RegisterStorageSize + 20
ColorConvertedFrame        = RegisterStorageSize + 22
ColorConvertedFrame_SegNum = RegisterStorageSize + 24
DCIOffset                  = RegisterStorageSize + 26
CCOffsetToLine0            = RegisterStorageSize + 30
CCOPitch_arg               = RegisterStorageSize + 34
EndOfArgList               = RegisterStorageSize + 36

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
YLimit                     = LocalStorageCC +   4
CCOVCursor                 = LocalStorageCC +   8
CCOUCursor                 = LocalStorageCC +  12
CCOSkipCursor              = LocalStorageCC +  16
VLimit                     = LocalStorageCC +  20
YLine1Limit                = LocalStorageCC +  24
CCOUVPitch                 = LocalStorageCC +  28
YPlane                     = LocalStorageCC +  32
VPlane                     = LocalStorageCC +  36
FrameWidth                 = LocalStorageCC +  40
FrameHeight                = LocalStorageCC +  44
YPitch                     = LocalStorageCC +  48
CCOPitch                   = LocalStorageCC +  52

LCL EQU <>

ENDIF

  push    esi
  push    edi
  push    ebp
  push    ebx
IFDEF WIN32
  sub     esp,LocalFrameSize
  mov     eax,PD [esp+ColorConvertedFrame]
  add     eax,PD [esp+DCIOffset]
  add     eax,PD [esp+CCOffsetToLine0]
  mov     PD [esp+CCOCursor],eax
ELSE
  xor     eax,eax
  mov     eax,ds
  push    eax
  mov     ebp,esp
  and     ebp,00000FFFFH
  mov     ds, PW [ebp+InstanceBase_SegNum]
  mov     es, PW [ebp+ColorConvertedFrame_SegNum]

  mov     ebx,PD [ebp+YPlane_arg]           ; Make YPlane accessible
  mov     ds:PD YPlane,ebx
  mov     ebx,PD [ebp+VPlane_arg]           ; Make VPlane accessible.
  mov     ds:PD VPlane,ebx
  mov     ax,PW [ebp+FrameWidth_arg]        ; Make FrameWidth accessible
  mov     ds:PD FrameWidth,eax
  mov     ax,PW [ebp+FrameHeight_arg]       ; Make FrameHeight accessible
  mov     ds:PD FrameHeight,eax
  mov     ax,PW [ebp+YPitch_arg]            ; Make YPitch accessible
  mov     ds:PD YPitch,eax
  mov     ax,PW [ebp+ColorConvertedFrame]   ; Init CCOCursor
  add     eax,PD [ebp+DCIOffset]
  mov     ds:PD CCOCursor,eax
  movsx   ebx,PW [ebp+CCOPitch_arg]         ; Make CCOPitch accessible
  mov     ds:PD CCOPitch,ebx
ENDIF
  Ledx    FrameHeight
   Lebx   CCOPitch
  shr     ebx,2                    ; UV pitch for the output
   Lecx   YPitch
  add     ebx,3                    ; Pitch is always a multiple of 4.
   Lebp   CCOPitch
  and     ebx,0FFFFFFFCH
   Lesi   YPlane                   ; Fetch cursor over luma plane.
  Sebx    CCOUVPitch
   Leax   CCOCursor
  imul    ecx,edx                  ; ecx: size of Y input.
  imul    ebp,edx                  ; ebp: was CCOPitch, now size of Y output.
  imul    ebx,edx                  ; ebp: size of U/V output (times 4).
  add     ecx,esi                  ; ecx: Ylimit
   add    eax,ebp                  ; eax was CCOCursor, now CCOVCursor
  Secx    YLimit
   Seax   CCOVCursor
  sar     ebx,2                    ; ebx: UVsize of output
   Lecx   FrameWidth               ; ecx: Y frame width
  add     esi,ecx                  ; esi: end of first input Y
   add    eax,ebx                  ; eax: now CCOUCursor
  shr     ecx,2
   Seax   CCOUCursor
  Lebp    VPlane                   ; ebp Vplane input
   Ledx   YPitch
  lea     esi,[edx+esi]            ; End of Y line 1
   add    ebp,ecx                  ; end of Vline
  Sesi    YLine1Limit
   add    eax,ebx                  ; CCO Skip Blocks
  Sebp    VLimit                   ; UV width for input
   Seax   CCOSkipCursor

; Prepare the UV contribution to decide the skip blocks, and copy chroma
; planes at the same time.
;
; Register usage:
;
; esi: V plane input pointer
; edi; V output pointer
; ebp: U output pointer
; edx: Y plane input pointer
; ecx: V limit
; ebx: Work area for U
; eax: Work area for V

ChromaPrep:

  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Ledx    YPlane
   Leax   YPitch
  Lesi    VPlane
   Lecx   VLimit
  sub     edi,esi            ; make edi offset to esi.
   sub    ebp,esi            ; make ebp offset to esi to save inc in the loop.
  lea     edx,[eax+edx-1296] ; make edx point at place for chroma prep.
   mov    eax,PD [esi]           ; fetch four V
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

ChromaLoop:

  mov     Ze PD[esi+edi*1],eax   ; Store four V.
   mov    ebx,PD [esi+UOFFSET]   ; fetch four U
  add     esi,4

   mov    PD [edx],eax           ; Store four V to chroma-prep line in Y frame.
  add     edx,16                 ; Advance chroma-prep cursor.
   add    ebx,ebx                ; Change to 8-bit.  (Low bit undef, usually 0).

  mov     Ze PD[esi+ebp*1-4],ebx ; Store four U.
   mov    eax,PD [esi]           ; fetch next four V.
  add     eax,eax                ; Change to 8-bit.  (Low bit undef, usually 0).

   mov    PD [edx-12],ebx        ; Store four U to chroma-prep line in Y frame.
  mov     bl,Ze PB [esi+edi*1]   ; Pre-load output cache line
   cmp    esi,ecx

  mov     bl,Ze PB [esi+ebp*1]   ; Pre-load output cache line
   jb     ChromaLoop

; update chroma pointers.

  add     ecx,VPITCH
   Lebx   CCOUVPitch
  Ledi    CCOVCursor
   Lebp   CCOUCursor
  Secx    VLimit
   add    edi,ebx              ; update V output ptr to the next line
  Leax    VPlane
   add    ebp,ebx              ; update U output ptr to the next line
  Sedi    CCOVCursor
   add    eax,VPITCH
  Sebp    CCOUCursor
   Seax   VPlane

; now do Luma a row of 4x4 blocks
;
; register usage:
;
; esi: Y cursor
; edi: CCOCursor
; ebp: counts down 4 lines of luma.
; ecx: counts down frame width.
; ebx: Y Pitch.
; eax: Work area.

; copy a row of 4x4 luma

  Lesi    YPlane
   Lecx   FrameWidth
  Ledi    CCOCursor
   add    esi,ecx
  neg     ecx
   Lebx   YPitch

  sub     edi,ecx
   mov    eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
   mov    ebp,4

YLoop:

  mov     Ze PD[edi+ecx],eax   ; Store them to IF09 output, Y plane.
   mov    eax,PD[esi+ecx+4]    ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.

   add    ecx,4                ; Advance induction variable.
  jl      YLoop

YLoopDone:

  Lecx    FrameWidth
   add    esi,ebx
  add     edi,ecx
   neg    ecx
  mov     eax,PD[esi+ecx]      ; Fetch 4 Y pels.
  add     eax,eax              ; Make them 8-bit.  Low bit undef, but usually 0.
  dec     ebp
   jne    YLoop

  add     edi,ecx
  Sedi    CCOCursor           ; save the output ptr for next four lines

; Build the skip block mask
;
; Register usage:
;
; esi: Y ptr
; edi: Mask Ptr
; ebp: Y Pitch
; edx: mask
; ecx: Archive value
; ebx: UV contribution
; eax: Dword of Y pels
;
; Y starts with Line 1 of 4x4 blocks, since UV pattern has been saved
; relative to line 1.

  Lesi    YPlane
   Lebp   YPitch
  Ledi    CCOSkipCursor
   add    esi,ebp                          ; esi point at line 1 of luma

BuildSkipDescrLoop:

  mov     ebx,PD [esi-1296]         ; Fetch 4 U's;  byte0 corresponds to this Y.
   mov    eax,PD [esi-1292]         ; Fetch 4 V's;  byte0 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,0000000FCH            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1300]         ; Fetch 4 U's;  byte1 corresponds to this Y.
   mov    eax,PD [esi-1296]         ; Fetch 4 V's;  byte1 corresponds to this Y.
  shl     ebx,11                    ; Position U.

   and    eax,00000FC00H            ; Extract 6 bits of V.
  and     ebx,007E00000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1304]         ; Fetch 4 U's;  byte2 corresponds to this Y.
   mov    eax,PD [esi-1300]         ; Fetch 4 V's;  byte2 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   and    eax,000FC0000H            ; Extract 6 bits of V.
  and     ebx,00007E000H            ; Extract 6 bits of U.
   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   je     BuildSkipDescrLoopDone


  mov     ebx,PD [esi-1308]         ; Fetch 4 U's;  byte3 corresponds to this Y.
   mov    eax,PD [esi-1304]         ; Fetch 4 V's;  byte3 corresponds to this Y.
  shr     ebx,5                     ; Position U.

   mov    edx,PD [esi+ebp*2]        ; Line 3 of luma first.
  shr     eax,26                    ; Extract 6 bits of V.
   and    ebx,007E00000H            ; Extract 6 bits of U.

  and     edx,07E7E7E7EH            ; Use 6 bits of Y to save more xfer cycles.
   mov    ecx,PD[esi+ebp*2+YARCHIVEOFFSET] ; Fetch archive for previous frame
  lea     ebx,[ebx+eax*8]                  ; Build UV.

   mov    eax,PD[esi+ebp*1]                ; line 2 of luma.
  add     edx,ebx                          ; combine Y with UV pattern
   and    eax,07E7E7E7EH

  mov     PD[esi+ebp*2+YARCHIVEOFFSET],edx ; save the current in the archive
   sub    ecx,edx                          ; compare with the previous archive
  add     ecx,-1                           ; CF == 1 iff curr differs from prev

   lea    eax,[eax+ebx]
  sbb     edx,edx                          ; edx == -1 iff different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]

  mov     PD[esi+ebp*1+YARCHIVEOFFSET],eax
   sub    ecx,eax
  mov     eax,PD[esi]

   sub    esi,ebp                         ; Gain acces to line 0.
  and     eax,07E7E7E7EH
   add    ecx,-1

  adc     edx,edx                         ; edx[0] == 1 if different, else 0.
   mov    ecx,PD[esi+ebp*1+YARCHIVEOFFSET]
  add     eax,ebx

   lea    edi,[edi+1]
  sub     ecx,eax

   mov    PD[esi+ebp*1+YARCHIVEOFFSET],eax
  mov     eax,PD[esi]
   add    ecx,-1

  adc     edx,edx
   and    eax,07E7E7E7EH
  mov     ecx,PD[esi+YARCHIVEOFFSET]

   add    eax,ebx
  sub     ecx,eax
   Lebx   YLine1Limit

  mov     PD[esi+YARCHIVEOFFSET],eax
   add    ecx,-1
  lea     esi,[esi+ebp+4]     ; jump to line 1 of next 4x4 block

   adc    edx,edx
  xor     edx,0FFFFFFFFH      ; edx[4:31] = 0.  edx[0,1,2,3] == 1 if skip dword.
   cmp    esi,ebx             ; check the end of line 1 of Y

  mov     Ze PB[edi-1],dl     ; write to the skip block buffer
   jne    BuildSkipDescrLoop

BuildSkipDescrLoopDone:


  add     edi,3               ; Round to next dword.
   lea    ebx,[ebx+ebp*4]     ; update YLine1Limit for next row of blocks
  and     edi,0FFFFFFFCH
   Lesi   YPlane
  Sedi    CCOSkipCursor
   Sebx   YLine1Limit
  lea     esi,[esi+ebp*4]
   Leax   YLimit
  Sesi    YPlane
   cmp    esi,eax
  jl      ChromaPrep

IFDEF WIN32
  add     esp,LocalFrameSize
ELSE
  pop     ebx
  mov     ds,ebx
ENDIF
  pop     ebx
  pop     ebp
  pop     edi
  pop     esi
  rturn

YUV12ToIF09 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512161.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;//
;// $Header:   S:\h26x\src\dec\cx512161.asv
;//
;// $Log:   S:\h26x\src\dec\cx512161.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:44   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Mar 1996 15:51:18   BNICKERS
;// Made this function non-destructive on input.  Only works on flat model now.
;// 
;//    Rev 1.4   05 Feb 1996 13:34:34   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.3   27 Dec 1995 14:35:40   RMCKENZX
;// Added copyright notice
;// 
;//    Rev 1.2   27 Oct 1995 17:30:50   BNICKERS
;// Fix RGB16 color convertors.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:20   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:26   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For H263 or H261.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512161 -- This function performs YUV12-to-RGB16 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles any format in which there are three fields, the low
;             order field being B and fully contained in the low order byte, the
;             second field being G and being somewhere in bits 4 through 11, 
;             and the high order field being R and fully contained in the high
;             order byte.  Formats presently supported:  555, 565, 655, and 664.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN   FrameWidth,
;                                     UN   FrameHeight,
;                                     UN   YPitch,
;                                     UN   VPitch,
;                                     UN   AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32  DCIOffset,
;                                     U32  CCOffsetToLine0,
;                                     IN   CCOPitch,
;                                     IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB16

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB16    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
CCType                   EQU  [esp+40]
FrameWidth               EQU  [esp+44]
ChromaPitch              EQU  [esp+48]
AspectAdjustmentCount    EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   ebx,[edi+CCType_arg]

  mov   ecx,0
  cmp   ebx,CCTYPE_RGB16555
  je    @f
  cmp   ebx,CCTYPE_RGB16555DCI
  je    @f
  mov   ecx,2048
  cmp   ebx,CCTYPE_RGB16565
  je    @f
  cmp   ebx,CCTYPE_RGB16565DCI
  je    @f
  mov   ecx,4096
  cmp   ebx,CCTYPE_RGB16655
  je    @f
  cmp   ebx,CCTYPE_RGB16655DCI
  je    @f
  mov   ecx,6144
  cmp   ebx,CCTYPE_RGB16664DCI
  je    @f
  cmp   ebx,CCTYPE_RGB16664
  je    @f
  mov   ecx,0DEADBEEFH
@@:
  mov   CCType,ecx
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   eax,ebx
   sub  ecx,ebx
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,1
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  ChromaLineLen,ebx
  mov   CCOSkipDistance,eax
   mov  YLimit,edx
  mov   YCursor,esi
   mov  esi,VCursor

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD VContrib[eax*8]      ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD UContrib[ecx*8]      ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD UContrib[ecx*8]      ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD UContrib[ecx*8]      ; See above.
  mov   ebp,PD VContrib[eax*8]      ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   ecx,ecx
   mov  ebx,AspectCount
  mov   [edi],ecx                   ; Store EOL indicator.
   mov  eax,CCType
  xor   edx,edx
   mov  edi,CCOCursor
  dec   ebx                         ; If count is non-zero, we keep the line.
   mov  esi,YCursor
  mov   AspectCount,ebx
   jne  KeepLine0

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine0

KeepLine0:

;  Register Usage:
;
;  esp -- Cursor over the Chroma contribution.
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- U contribution to B field of RGB value.
;  edx -- V contribution to R field of RGB value.
;         Clamped, positioned G value.
;  ecx -- UV contribution to G field of RGB value.
;         Clamped, positioned G value.
;  ebx -- Construction of two pels of RGB16.
;  al -- Y value (i.e. Y contribution to R, G, and B);

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine0:

  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel01.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel01.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel01.
  or    ebx,edx                        ; Combine RGB16 value for Pel01.
   mov  al,[esi]                       ; Fetch Y00.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel01.
   mov  dl,ChromaContribution+1536+2   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel00.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel00.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]             ; Get clamped R value for Pel00.
  or    ebx,ecx                        ; Combine RGB16 value for Pel00.
   mov  al,[esi+3]                     ; Fetch Y03. 
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4  ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+5   ; Get UV contribution to G value.
  mov   dl,ChromaContribution+1536+6   ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  mov   Ze [edi],ebx                   ; Write the 2 pels to output.
   add  esi,4                          ; Advance Y line cursor
  mov   bh,PB RValLo[eax+edx]          ; Get clamped R value for Pel03.
   mov  dl,PB GValHi[eax+ecx]          ; Get clamped G value for Pel03.
  shl   edx,4                          ; Position G value.
   mov  bl,PB BValLo[eax+ebp*1]        ; Get clamped B value for Pel03.
  or    ebx,edx                        ; Combine RGB16 value for Pel03.
   mov  al,[esi+2-4]                   ; Fetch Y02.
  shr   al,1                           ; Reduce to 7 bits.
   xor  edx,edx
  shl   ebx,16                         ; Position RGB16 value for Pel03.
   mov  dl,ChromaContribution+1536+6   ; Reload V contribution to R value.
  mov   bl,PB BValHi[eax+ebp*1]        ; Get clamped R value for Pel02.
   mov  cl,PB GValLo[eax+ecx]          ; Get clamped G value for Pel02.
  shl   ecx,4                          ; Position G value.
   mov  bh,PB RValHi[eax+edx]          ; Get clamped R value for Pel02.
  or    ebx,ecx                        ; Combine RGB16 value for Pel02.
   mov  al,[esi+5-4]                   ; Fetch Y05.
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8  ; Get next pel's U contrib to B value.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1536+9   ; Get next pel's UV contrib to G value.
  mov   Ze [edi+4],ebx                 ; Write the 2 pels to output.
   add  edi,8                          ; Advance color converted output cursor.
  mov   dl,ChromaContribution+1536+10  ; Get next pel's V contrib to R value.
   and  ebp,0FFH                       ; Extract U contribution to G value.
  lea   esp,[esp+8]                    ; Advance Chroma contribution cursor.
   jne  DoNext4YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   ebp,YSkipDistance
   mov  ebx,AspectCount
  add   esi,ebp
   dec  ebx                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  ebx,AspectAdjustmentCount
  mov   AspectCount,ebx
   jmp  SkipLine1

KeepLine1:

  mov   al,[esi+1]                     ; Get Y01.
   mov  ebp,ChromaContribution         ; Get U contribution to B, plus garbage.
  shr   al,1                           ; Reduce to 7 bits.
   mov  cl,ChromaContribution+1        ; Get UV contribution to G value.
  mov   dl,ChromaContribution+2        ; Get V contribution to R value.
   and  ebp,0FFH                       ; Extract U contribution to B.
  sub   esp,1536
   xor  ebx,ebx

DoNext4YPelsOfLine1:

  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+2
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+3]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+4
  shr   al,1
   mov  cl,ChromaContribution+1536+5
  mov   dl,ChromaContribution+1536+6
   and  ebp,0FFH
  mov   Ze [edi],ebx
   add  esi,4
  mov   bh,PB RValHi[eax+edx]
   mov  dl,PB GValLo[eax+ecx]
  shl   edx,4
   mov  bl,PB BValHi[eax+ebp*1]
  or    ebx,edx
   mov  al,[esi+2-4]
  shr   al,1
   xor  edx,edx
  shl   ebx,16
   mov  dl,ChromaContribution+1536+6
  mov   bl,PB BValLo[eax+ebp*1]
   mov  cl,PB GValHi[eax+ecx]
  shl   ecx,4
   mov  bh,PB RValLo[eax+edx]
  or    ebx,ecx
   mov  al,[esi+5-4]
  xor   ecx,ecx
   mov  ebp,ChromaContribution+1536+8
  shr   al,1
   mov  cl,ChromaContribution+1536+9
  mov   Ze [edi+4],ebx
   add  edi,8
  mov   dl,ChromaContribution+1536+10
   and  ebp,0FFH
  lea   esp,[esp+8]
   jne  DoNext4YPelsOfLine1

  and   esp,0FFFFF800H
  add   esp,0800H
  add   edi,CCOSkipDistance
 
SkipLine1:

   mov  eax,YSkipDistance           ; Inc LumaCursor to next line.
  add   eax,esi
   mov  ecx,ChromaPitch
  mov   CCOCursor,edi
   mov  YCursor,eax
  mov   esi,VCursor                 ; Inc VPlane cursor to next line.
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ecx
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB16 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512242.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512242.asv
;//
;// $Log:   S:\h26x\src\dec\cx512242.asv  $
;// 
;//    Rev 1.8   20 Mar 1996 10:57:22   bnickers
;// Fix numerous bugs.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:22   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 09:58:36   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:36   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   22 Dec 1995 15:42:18   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.3   30 Oct 1995 17:15:32   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 17:49:36   CZHU
;// Fix a whole bunch of bugs.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:28   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cx512242 -- This function performs YUV12-to-RGB24 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

IFDEF USE_BILINEAR_MSH26X

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
BaR0G0B0                 EQU  [esp+72]
G1B1RaGa                 EQU  [esp+76]
RbGbBbR1                 EQU  [esp+80]
BcR2G2B2                 EQU  [esp+84]
G3B3RcGc                 EQU  [esp+88]
RdGdBdR3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax
                                     ;                                           EAX                 EBX                ECX              EDX              EBP
   mov  edx,FrameWidth               ;                                           ?? ?? ?? ??         ?? ?? ?? ??        ?? ?? ?? ??     >-- -- -- --      ?? ?? ?? ??
   add  edx,YSkipDistance            ;                                           ?? ?? ?? ??         ?? ?? ?? ??        ?? ?? ?? ??     >-- -- delta      ?? ?? ?? ??

DoLine1:
  xor   ebx,ebx                      ;                                           ?? ?? ?? ??        >-- -- -- --        ?? ?? ?? ??      -- -- delta      ?? ?? ?? ??
   xor  ecx,ecx                      ;                                           ?? ?? ?? ??         -- -- -- --       >-- -- -- --      -- -- delta      ?? ?? ?? ??
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.       ?? ?? ?? ??         -- -- -- --        -- -- -- --      -- -- delta     >AA AA AA AA
  mov   cl,[esi]                     ; Fetch Y0.                                 ?? ?? ?? ??         -- -- -- --      m>-- -- -- y0      -- -- delta      AA AA AA AA
   mov  bl,ChromaContribution+2      ; Fetch UV contrib to G value.              ?? ?? ?? ??       m>-- -- -- uvG01     -- -- -- y0      -- -- delta      AA AA AA AA
   and  ebp,0000001FFH               ; Extract V contrib to R.                   ?? ?? ?? ??         -- -- -- uvG01     -- -- -- y0      -- -- delta     >-- -- -1 AA
  mov   edi,CCOCursor                ;                                           ?? ?? ?? ??         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 AA
   sub  esp,6144                     ;                                           ?? ?? ?? ??         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 AA

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  xor   eax,eax                        ;                                        >-- -- -- --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 AA
   mov   al,[esi+1]                    ; Fetch Y1.                             m>-- -- -- y1         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  add    eax,ecx                       ; Add Y0 to Y1.                          >-- -- -- y1+y0      -- -- -- uvG01    <-- -- -- y0      -- -- delta      -- -- -1 vR01
  shl    eax,23                        ; Low bit will be nuked by R0.           >ya -- -- --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pel0 G.                         m>ya -- G0 --        <-- -- -- uvG01    <-- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   bl,ChromaContribution+6144+3  ; Fetch U contrib to B value.             ya -- G0 --       m>-- -- -- uB01      -- -- -- y0      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B.                         m>ya -- G0 B0        <-- -- -- uB01     <-- -- -- y0      -- -- delta      -- -- -1 vR01
  rol    eax,16                        ;                                        >G0 B0 ya --         -- -- -- uB01      -- -- -- y0      -- -- delta      -- -- -1 vR01
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.                         m>G0 B0 ya R0         -- -- -- uB01     <-- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   cl,ah                         ;                                        <G0 B0 ya R0         -- -- -- uB01     >-- -- -- ya      -- -- delta      -- -- -1 vR01
   mov   ah,PB B24Value[ecx+ebx*2]     ; Fetch Pela B.                         m>G0 B0 Ba R0        <-- -- -- uB01     <-- -- -- ya      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;                                        >Ba R0 G0 B0         -- -- -- uB01      -- -- -- ya      -- -- delta      -- -- -1 vR01
  mov    Ze [edi],eax                  ; First output.                         m<Ba R0 G0 B0         -- -- -- uB01      -- -- -- ya      -- -- delta      -- -- -1 vR01

  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Ba R0 G0 B0       m>-- -- -- uvG01     -- -- -- ya      -- -- delta      -- -- -1 vR01
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pela G.                         m>Ba R0 G0 Ga        <-- -- -- uvG01    <-- -- -- ya      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pela R.                         m>Ba R0 Ra Ga         -- -- -- uvG01    <-- -- -- ya      -- -- delta      -- -- -1 vR01
   mov   cl,[esi+1]                    ; Fetch Y1.                               Ba R0 Ra Ga         -- -- -- uvG01   m>-- -- -- y1      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Ra Ga -- --         -- -- -- uvG01     -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pel1 G.                         m>Ra Ga G1 --        <-- -- -- uvG01    <-- -- -- y1      -- -- delta      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+3  ; Fetch U contrib to B value.              Ra Ga G1 --       m>-- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel1 B.                         m>Ra Ga G1 B1        <-- -- -- uB01     <-- -- -- y1      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;										>G1 B1 Ra Ga         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov    Ze [edi+4],eax                ; Second output.					       m<G1 B1 Ra Ga         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   al,[esi+2]                    ; Fetch Y2.                             m>-- -- -- y2         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
   add   eax, ecx                      ; Add Y1 to Y2							>-- -- -- y2+y1      -- -- -- uB01     <-- -- -- y1      -- -- delta      -- -- -1 vR01
   shl   eax, 7                        ; Low bit will be nuked by R1.           >-- -- yb --         -- -- -- uB01      -- -- -- y1      -- -- delta      -- -- -1 vR01
  mov   al,PB R24Value[ecx+ebp*1]      ; Fetch Pel1 R.                         m>-- -- yb R1         -- -- -- uB01     <-- -- -- y1      -- -- delta      -- -- -1 vR01
  mov   cl,ah                          ;                                        <-- -- yb R1         -- -- -- uB01     >-- -- -- yb      -- -- delta      -- -- -1 vR01
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelb B.                         m>-- -- Bb R1        <-- -- -- uB01     <-- -- -- yb      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Bb R1 -- --         -- -- -- uB01      -- -- -- yb      -- -- delta      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Bb R1 -- --       m>-- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01
   mov   al,PB G24Value[ecx+ebx]       ; Fetch Pelb G.                         m>Bb R1 -- Gb        <-- -- -- uvG01    <-- -- -- yb      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelb R.                         m>Bb R1 Rb Gb         -- -- -- uvG01    <-- -- -- yb      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;										>Rb Gb Bb R1         -- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01
  mov    Ze [edi+8],eax                ; Third output.					       m<Rb Gb Bb R1         -- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01

  xor   eax,eax                        ;                                        >-- -- -- --         -- -- -- uvG01     -- -- -- yb      -- -- delta      -- -- -1 vR01
   mov   cl,[esi]                      ; ReFetch Y0.                             -- -- -- --         -- -- -- uvG01   m>-- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   al,[esi+edx+1]                ; Fetch Y128.                           m>-- -- -- y128       -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  add   eax,ecx                        ; Add Y0 to Y128.                       m>-- -- -- y128+y0    -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
   shl   eax, 16                       ;                                        >-- ++ -- --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
   mov   al,[esi+edx]                  ; Fetch Y127.                           m>-- ++ -- y127       -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  add    eax,ecx                       ; Add Y0 to Y127                         >-- ++ -- y127+y0    -- -- -- uvG01    <-- -- -- y0      -- -- delta      -- -- -1 vR01
   shl   eax,7                         ; Normalize Y0 + Y127, and Y0 + Y128     >yt -- ys --         -- -- -- uvG01     -- -- -- y0      -- -- delta      -- -- -1 vR01
  mov    cl,ah                         ;                                        <yt -- ys --         -- -- -- uvG01    >-- -- -- ys      -- -- delta      -- -- -1 vR01
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pels G.                         m>yt -- Gs Bs        <-- -- -- uvG01    <-- -- -- ys      -- -- delta      -- -- -1 vR01
  mov    bl,ChromaContribution+6144+3  ; Fetch U contrib to B value.             yt -- Gs Bs       m>-- -- -- uB01      -- -- -- ys      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pels B.                         m>yt -- -- Bs        <-- -- -- uB01     <-- -- -- ys      -- -- delta      -- -- -1 vR01
  rol    eax,16                        ;                                        >Gs Bs yt --         -- -- -- uB01      -- -- -- ys      -- -- delta      -- -- -1 vR01
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pels R.                         m>Gs Bs yt Rs         -- -- -- uB01     <-- -- -- ys      -- -- delta      -- -- -1 vR01
   mov   cl,ah                         ;                                        <Gs Bs yt Rs         -- -- -- uB01     >-- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelt B.                         m>Gs Bs Bt Rs        <-- -- -- uB01     <-- -- -- yt      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;                                        >Bt Rs Gs Bs         -- -- -- uB01      -- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   BaR0G0B0+6144,eax             ; Stash for saving to second line.      s<Bt Rs Gs Bs         -- -- -- uB01      -- -- -- yt      -- -- delta      -- -- -1 vR01

  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Bt Rs Gs Bs       m>-- -- -- uvG01     -- -- -- yt      -- -- delta      -- -- -1 vR01
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pelt G.                         m>Bt Rs Gs Gt        <-- -- -- uvG01    <-- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelt R.                         m>Bt Rs Rt Gt         -- -- -- uvG01    <-- -- -- yt      -- -- delta      -- -- -1 vR01
   mov   cl,[esi+1]                    ; Fetch Y1.                               Bt Rs Rt Gt         -- -- -- uvG01   m>-- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   bl,[esi+edx+2]                ; Fetch Y129.                             Bt Rs Rt Gt       m>-- -- -- y129      -- -- -- y1      -- -- delta      -- -- -1 vR01
  add   ebx,ecx                        ; Add Y1 to Y129.                         Bt Rs Rt Gt        >-- -- -- y129+y1  <-- -- -- y1      -- -- delta      -- -- -1 vR01
   shl   ebx, 16                       ;                                         Bt Rs Rt Gt        >-- ++ -- --        -- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   bl,[esi+edx+1]                ; Fetch Y128.                             Bt Rs Rt Gt       m>-- ++ -- y128      -- -- -- y1      -- -- delta      -- -- -1 vR01
  add    ebx,ecx                       ; Add Y1 to Y128                          Bt Rs Rt Gt        >-- ++ -- y128+y1  <-- -- -- y1      -- -- delta      -- -- -1 vR01
   shl   ebx,7                         ; Normalize Y1 + Y128, and Y1 + Y129      Bt Rs Rt Gt        >yv -- yu --        -- -- -- y1      -- -- delta      -- -- -1 vR01
   mov   cl,bh                         ;                                         Bt Rs Rt Gt        <yv -- yu --       >-- -- -- yu      -- -- delta      -- -- -1 vR01
   shr   ebx,24                        ;                                         Bt Rs Rt Gt        >-- -- -- yv        -- -- -- yu      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Rt Gt -- --         -- -- -- yv        -- -- -- yu      -- -- delta      -- -- -1 vR01
  mov    ah,bl                         ;                                        >Rt Gt yv --        <-- -- -- yv        -- -- -- yu      -- -- delta      -- -- -1 vR01
  mov  bl,ChromaContribution+6144+3    ; Fetch U contrib to B value.             Rt Gt yv --       m>-- -- -- uB01      -- -- -- yu      -- -- delta      -- -- -1 vR01
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pelu B.                         m>Rt Gt yv Bu        <-- -- -- uB01     <-- -- -- yu      -- -- delta      -- -- -1 vR01
  shl    edx, 16                       ; Make room to save yv                    Rt Gt yv Bu         -- -- -- uB01      -- -- -- yu     <delta -- --      -- -- -1 vR01
  mov    dl,ah                         ;                                         Rt Gt yv Bu         -- -- -- uB01      -- -- -- yu     >delta -- yv      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Rt Gt yv Bu       m>-- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pelu G.                         m>Rt Gt Gu Bu        <-- -- -- uvG01    <-- -- -- yu      delta -- yv      -- -- -1 vR01
  ror    eax,16                        ;										>Gu Bu Rt Gt         -- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01
   mov   G1B1RaGa+6144,eax             ; Stash for saving to second line.      s<Gu Bu Rt Gt         -- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uvG01     -- -- -- yu      delta -- yv      -- -- -1 vR01
  mov   al,PB R24Value[ecx+ebp*1]      ; Fetch Pelu R.                         m>-- -- -- Ru         -- -- -- uvG01    <-- -- -- yu      delta -- yv     <-- -- -1 vR01
  mov   cl,dl                          ;                                         -- -- -- Ru         -- -- -- uvG01    >-- -- -- yv      delta -- yv      -- -- -1 vR01
  shr   edx,16                         ; Restore delta                           -- -- -- Ru         -- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01
  mov  bl,ChromaContribution+6144+3    ; Fetch U contrib to B value.             -- -- -- Ru       m>-- -- -- uB01      -- -- -- yv      -- -- delta      -- -- -1 vR01
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelv B.                         m>-- -- Bv Ru        <-- -- -- uB01     <-- -- -- yv      -- -- delta      -- -- -1 vR01
  shl    eax,16                        ;                                        >Bv Ru -- --         -- -- -- uB01      -- -- -- yv      -- -- delta      -- -- -1 vR01
  mov   bl,ChromaContribution+6144+2   ; Fetch UV contrib to G value.            Bv Ru -- --       m>-- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   al,PB G24Value[ecx+ebx]       ; Fetch Pelv G.                         m>Bv Ru -- Gv        <-- -- -- uvG01    <-- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelv R.                         m>Bv Ru Rv Gv         -- -- -- uvG01    <-- -- -- yv      -- -- delta      -- -- -1 vR01
  ror    eax,16                        ;										>Rv Gv Bv Ru         -- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   RbGbBbR1+6144,eax             ; Stash for saving to second line.      s<Rv Gv Bv Ru         -- -- -- uvG01     -- -- -- yv      -- -- delta      -- -- -1 vR01

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uB01      -- -- -- yv      -- -- delta      -- -- -1 vR01
   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.     -- -- -- --         -- -- -- uB01      -- -- -- yv      -- -- delta    m>BB BB BB BB
   mov   cl,[esi+2]                    ; Fetch Y2.                               -- -- -- --         -- -- -- uB01    m>-- -- -- y2      -- -- delta      BB BB BB BB
   and   ebp,0000001FFH                ; Extract V contrib to R.                 -- -- -- --         -- -- -- uB01      -- -- -- y2      -- -- delta     >-- -- -1 vR23
   mov   al,[esi+3]                    ; Fetch Y3.                             m>-- -- -- y3         -- -- -- uB01      -- -- -- y2      -- -- delta      BB BB BB BB
   add   eax, ecx                      ; Add Y2 to Y3							>-- -- -- y3+y2      -- -- -- uB01     <-- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             -- -- -- --       m>-- -- -- uB23      -- -- -- y2      -- -- delta      -- -- -1 vR23
  shl    eax,23                        ; Low bit will be nuked by R2.           >yc -- -- --         -- -- -- uB23      -- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel2 B.                         m>yc -- -- B2        <-- -- -- uB23     <-- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            yc -- -- B2       m>-- -- -- uvG23    <-- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pel2 G.                         m>yc -- G2 B2        <-- -- -- uvG23    <-- -- -- y2      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;                                        >G2 B2 yc --         -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
   mov   al,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.                         m>G2 B2 yc R2         -- -- -- uvG23    <-- -- -- y2      -- -- delta     <-- -- -1 vR23
  mov    cl, ah                        ;                                        <G2 B2 yc R2         -- -- -- uvG23    >-- -- -- yc      -- -- delta     <-- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             G2 B2 yc R2       m>-- -- -- uB23     >-- -- -- yc      -- -- delta     <-- -- -1 vR23
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelc B.                         m>G2 B2 Bc R2        <-- -- -- uB23     <-- -- -- yc      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;										>Bc R2 G2 B2         -- -- -- uB23      -- -- -- yc      -- -- delta      -- -- -1 vR23
  mov    Ze [edi+12],eax               ; Fourth output.                        m<Bc R2 G2 B2         -- -- -- uB23      -- -- -- yc      -- -- delta      -- -- -1 vR23

   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelc R.                         m>Bc R2 Rc B2         -- -- -- uB23     <-- -- -- yc      -- -- delta     <-- -- -1 vR23
  mov    bl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            Bc R2 Rc B2       m>-- -- -- uvG23     -- -- -- yc      -- -- delta      -- -- -1 vR23
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pelc G.                         m>Bc R2 Rc Gc        <-- -- -- uvG23    <-- -- -- yc      -- -- delta      -- -- -1 vR23
   mov   cl,[esi+3]                    ; Fetch Y3.                               Bc R2 Rc Gc         -- -- -- uvG23   m>-- -- -- y3      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;                                        >Rc Gc -- --         -- -- -- uvG23     -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pel3 G.                         m>Rc Gc G3 --         -- -- -- uvG23    <-- -- -- y3      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             Rc Gc G3 --       m>-- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   al,PB B24Value[ecx+ebx*2]     ; Fetch Pel3 B.                         m>Rc Gc G3 B3        <-- -- -- uB23     <-- -- -- y3      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;										>G3 B3 Rc Gc         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
  mov    Ze [edi+16],eax               ; Fifth output.                         m<G3 B3 Rc Gc         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   al,[esi+4]                    ; Fetch Y4.                             m>-- -- -- y4         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   add   eax,ecx                       ; Add Y3 to Y4.                          >-- -- -- y4+y3      -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   shl   eax,7                         ; Low bit will be nuked by R3.           >-- -- yd --         -- -- -- uB23      -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.                         m>-- -- yd R3         -- -- -- uB23     <-- -- -- y3      -- -- delta     <-- -- -1 vR23
   mov   cl,ah                         ;                                        <-- -- yd R3         -- -- -- uB23     >-- -- -- yd      -- -- delta     <-- -- -1 vR23
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Peld B.                         m>-- -- Bd R3        <-- -- -- uB23     <-- -- -- yd      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;										>Bd R3 -- --         -- -- -- uB23      -- -- -- yd      -- -- delta      -- -- -1 vR23
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Peld R.                         m>Bd R3 Rd --         -- -- -- uB23     <-- -- -- yd      -- -- delta     <-- -- -1 vR23
  mov    bl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            Bd R3 Rd --       m>-- -- -- uvG23    <-- -- -- yd      -- -- delta     <-- -- -1 vR23
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Peld G.                         m>Bd R3 Rd Gd        <-- -- -- uvG23    <-- -- -- yd      -- -- delta      -- -- -1 vR23
  rol    eax,16                        ;                                        >Rd Gd Bd R3         -- -- -- uvG23     -- -- -- yd      -- -- delta      -- -- -1 vR23
  mov    Ze [edi+20],eax               ; Sixth output.                         m<Rd Gd Bd R3         -- -- -- uvG23     -- -- -- yd      -- -- delta      -- -- -1 vR23

  xor   eax,eax                        ;                                        >-- -- -- --         -- -- -- uvG23     -- -- -- yd      -- -- delta      -- -- -1 vR23
   mov   cl,[esi+2]                    ; ReFetch Y2.                             -- -- -- --         -- -- -- uvG23   m>-- -- -- y2      -- -- delta      -- -- -1 vR23
   mov   al,[esi+edx+3]                ; Fetch Y130.                           m>-- -- -- y130       -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
  add   eax,ecx                        ; Add Y2 to Y130.                       m>-- -- -- y130+y2    -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
   shl   eax, 16                       ;                                        >-- ++ -- --         -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
   mov   al,[esi+edx+2]                ; Fetch Y129.                           m>-- ++ -- y129       -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
  add    eax,ecx                       ; Add Y2 to Y129                         >-- ++ -- y129+y2    -- -- -- uvG23    <-- -- -- y2      -- -- delta      -- -- -1 vR23
   shl   eax,7                         ; Normalize Y2 + Y129, and Y2 + Y130     >yx -- yw --         -- -- -- uvG23     -- -- -- y2      -- -- delta      -- -- -1 vR23
  mov    cl,ah                         ;                                        <yx -- yw --         -- -- -- uvG23    >-- -- -- yw      -- -- delta      -- -- -1 vR23
   mov   ah,PB G24Value[ecx+ebx]       ; Fetch Pelw G.                         m>yx -- Gw Bw        <-- -- -- uvG23    <-- -- -- yw      -- -- delta      -- -- -1 vR23
  mov    bl,ChromaContribution+6144+7  ; Fetch U contrib to B value.             yx -- Gw Bw       m>-- -- -- uB23      -- -- -- yw      -- -- delta      -- -- -1 vR23
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pelw B.                         m>yx -- -- Bw        <-- -- -- uB23     <-- -- -- yw      -- -- delta      -- -- -1 vR23
  rol    eax,16                        ;                                        >Gw Bw yx --         -- -- -- uB23      -- -- -- yw      -- -- delta      -- -- -1 vR23
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pelw R.                         m>Gw Bw yx Rw         -- -- -- uB23     <-- -- -- yw      -- -- delta      -- -- -1 vR23
   mov   cl,ah                         ;                                        <Gw Bw yx Rw         -- -- -- uB23     >-- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelx B.                         m>Gw Bw Bx Rw        <-- -- -- uB23     <-- -- -- yx      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;                                        >Bx Rw Gw Bw         -- -- -- uB23      -- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   BcR2G2B2+6144,eax             ; Stash for saving to second line.      s<Bx Rw Gw Bw         -- -- -- uB23      -- -- -- yx      -- -- delta      -- -- -1 vR23

  mov   bl,ChromaContribution+6144+6   ; Fetch UV contrib to G value.            Bx Rw Gw Bw       m>-- -- -- uvG23     -- -- -- yx      -- -- delta      -- -- -1 vR23
  mov    al,PB G24Value[ecx+ebx]       ; Fetch Pelx G.                         m>Bx Rw Gw Gx        <-- -- -- uvG23    <-- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelx R.                         m>Bx Rw Rx Gx         -- -- -- uvG23    <-- -- -- yx      -- -- delta      -- -- -1 vR23
   mov   cl,[esi+3]                    ; Fetch Y3.                               Bx Rw Rx Gx         -- -- -- uvG23   m>-- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   bl,[esi+edx+4]                ; Fetch Y131.                             Bx Rw Rx Gx       m>-- -- -- y131      -- -- -- y3      -- -- delta      -- -- -1 vR23
  add   ebx,ecx                        ; Add Y3 to Y131.                         Bx Rw Rx Gx        >-- -- -- y131+y3  <-- -- -- y3      -- -- delta      -- -- -1 vR23
   shl   ebx, 16                       ;                                         Bx Rw Rx Gx        >-- ++ -- --        -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   bl,[esi+edx+3]                ; Fetch Y130.                             Bx Rw Rx Gx       m>-- ++ -- y130      -- -- -- y3      -- -- delta      -- -- -1 vR23
  add    ebx,ecx                       ; Add Y3 to Y130                          Bx Rw Rx Gx        >-- ++ -- y130+y3  <-- -- -- y3      -- -- delta      -- -- -1 vR23
   shl   ebx,7                         ; Normalize Y3 + Y130, and Y3 + Y131      Bx Rw Rx Gx        >yz -- yy --        -- -- -- y3      -- -- delta      -- -- -1 vR23
   mov   cl,bh                         ;                                         Bx Rw Rx Gx        <yz -- yy --       >-- -- -- yy      -- -- delta      -- -- -1 vR23
   shr   ebx,24                        ;                                         Bx Rw Rx Gx        >-- -- -- yz        -- -- -- yy      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;                                        >Rx Gx -- --         -- -- -- yz        -- -- -- yy      -- -- delta      -- -- -1 vR23
  mov    ah,bl                         ;                                        >Rx Gx yz --        <-- -- -- yz        -- -- -- yy      -- -- delta      -- -- -1 vR23
  mov  bl,ChromaContribution+6144+7    ; Fetch U contrib to B value.             Rx Gx yz --       m>-- -- -- uB23      -- -- -- yy      -- -- delta      -- -- -1 vR23
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pely B.                         m>Rx Gx yz By        <-- -- -- uB23     <-- -- -- yy      -- -- delta      -- -- -1 vR23
  shl    edx, 16                       ; Make room to save yz                    Rx Gx yz By         -- -- -- uB23      -- -- -- yy     <delta -- --      -- -- -1 vR23
  mov    dl,ah                         ;                                         Rx Gx yz By         -- -- -- uB23      -- -- -- yy     >delta -- yz      -- -- -1 vR23
  mov   bl,ChromaContribution+6144+6   ; Fetch UV contrib to G value.            Rx Gx yz By       m>-- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23
  mov    ah,PB G24Value[ecx+ebx]       ; Fetch Pely G.                         m>Rx Gx Gy By        <-- -- -- uvG23    <-- -- -- yy      delta -- yz      -- -- -1 vR23
  ror    eax,16                        ;										>Gy By Rx Gx         -- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23
   mov   G3B3RcGc+6144,eax             ; Stash for saving xo second line.      s<Gy By Rx Gx         -- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23

   xor   eax,eax                       ;                                        >-- -- -- --         -- -- -- uvG23     -- -- -- yy      delta -- yz      -- -- -1 vR23
  mov   al,PB R24Value[ecx+ebp*1]      ; Fetch Pely R.                         m>-- -- -- Ry         -- -- -- uvG23    <-- -- -- yy      delta -- yz     <-- -- -1 vR23
  mov   cl,dl                          ;                                         -- -- -- Ry         -- -- -- uvG23    >-- -- -- yz      delta -- yz      -- -- -1 vR23
  shr   edx,16                         ; Restore delta                           -- -- -- Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23
  mov  bl,ChromaContribution+6144+7    ; Fetch U contrib to B value.             -- -- -- Ry       m>-- -- -- uB23      -- -- -- yz      -- -- delta      -- -- -1 vR23
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pelz B.                         m>-- -- Bz Ry        <-- -- -- uB23     <-- -- -- yz      -- -- delta      -- -- -1 vR23
  shl    eax,16                        ;                                        >Bz Ry -- --         -- -- -- uB23      -- -- -- yz      -- -- delta      -- -- -1 vR23
  mov   bl,ChromaContribution+6144+6   ; Fetch UV contrib to G value.            Bz Ry -- --       m>-- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23
   mov   al,PB G24Value[ecx+ebx]       ; Fetch Pelz G.                         m>Bz Ry -- Gz        <-- -- -- uvG23    <-- -- -- yz      -- -- delta      -- -- -1 vR23
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pelz R.                         m>Bz Ry Rz Gz         -- -- -- uvG23    <-- -- -- yz      -- -- delta      -- -- -1 vR23
  ror    eax,16                        ;										>Rz Gz Bz Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23
   mov   RdGdBdR3+6144,eax             ; Stash for saving to second line.      s<Rz Gz Bz Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta      -- -- -1 vR23

   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.     Rz Gz Bz Ry         -- -- -- uvG23     -- -- -- yz      -- -- delta    m>CC CC CC CC
  mov    bl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.            Rz Gz Bz Ry       m>-- -- -- uvG45     -- -- -- yz      -- -- delta      CC CC CC CC
   and   ebp,0000001FFH                ; Extract U contrib to B.                 Rz Gz Bz Ry         -- -- -- uvG45     -- -- -- yz      -- -- delta     >-- -- -1 vR45
  mov    cl,[esi+4]                    ; Fetch Y4.                               Rz Gz Bz Ry         -- -- -- uvG45   m>-- -- -- y4      -- -- delta      -- -- -1 vR45
   lea   esi,[esi+4]                   ; Advance input cursor.  
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,BaR0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

ELSE

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
B0R0G0B0                 EQU  [esp+72]
G1B1R0G0                 EQU  [esp+76]
R1G1B1R1                 EQU  [esp+80]
B2R2G2B2                 EQU  [esp+84]
G3B3R2G2                 EQU  [esp+88]
R3G3B3R3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax

DoLine1:
                                     ;                                           EAX                 EBX                ECX              EDX              EBP
  xor   ebx,ebx                      ;                                           ?? ?? ?? ??        >-- -- -- --        ?? ?? ?? ??      ?? ?? ?? ??     ?? ?? ?? ??
   xor  ecx,ecx                      ;                                           ?? ?? ?? ??         -- -- -- --       >-- -- -- --      ?? ?? ?? ??     ?? ?? ?? ??
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.       ?? ?? ?? ??         -- -- -- --        -- -- -- --      ?? ?? ?? ??    >AA AA AA AA
   xor  edx,edx                      ;                                           ?? ?? ?? ??         -- -- -- --        -- -- -- --     >-- -- -- --     AA AA AA AA
  mov   cl,[esi]                     ; Fetch Y0.                                 ?? ?? ?? ??         -- -- -- --      m>-- -- -- y0      -- -- -- --     AA AA AA AA
   mov  bl,ChromaContribution+3      ; Fetch U contrib to B value.               ?? ?? ?? ??       m>-- -- -- uB01      -- -- -- y0      -- -- -- --     AA AA AA AA
  mov   dl,ChromaContribution+2      ; Fetch UV contrib to G value.              ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0    m>-- -- -- uvG01  AA AA AA AA
   and  ebp,0000001FFH               ; Extract V contrib to R.                   ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01 >-- -- -1 AA
  mov   edi,CCOCursor                ;                                           ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
   sub  esp,6144                     ;                                           ?? ?? ?? ??         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
  xor   eax,eax                      ;                                          >-- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov    ah,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B.                         m>-- -- B0 --        <-- -- -- uB01     <-- -- -- y0      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.                           -- -- B0 --       m>-- -- R0 uB01     <-- -- -- y0      -- -- -- uvG01  <-- -- -1 AA
  mov    bl,PB G24Value[ecx+edx]       ; Fetch Pel0 G.   -- -- R0 G0             -- -- B0 --       m>-- -- R0 G0       <-- -- -- y0     <-- -- -- uvG01   -- -- -1 AA
   mov   cl,[esi+1]                    ; Fetch Y1.                               -- -- B0 --         -- -- R0 G0      m>-- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  shl    ebx,16                        ;                 R0 G0 -- --             -- -- B0 --        >R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   al,ah                         ; Copy Pel0 B.    -- -- B0 B0            >-- -- B0 B0         R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  or     eax,ebx                       ;                 R0 G0 B0 B0            >R0 G0 B0 B0        <R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R0 G0 G1 --             R0 G0 B0 B0       m>R0 G0 G1 --       <-- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  ror    eax,8                         ; First output:   B0 R0 G0 B0            >B0 R0 G0 B0         R0 G0 G1 --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.           B0 R0 G0 B0         R0 G0 G1 --        -- -- -- y1    m>-- -- -- uB01    -- -- -1 AA
  mov    Ze [edi],eax                  ; Save B0R0G0B0.                        m<B0 R0 G0 B0         R0 G0 G1 --        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.   R0 G0 G1 B1             B0 R0 G0 B0       m>R0 G0 G1 B1       <-- -- -- y1     <-- -- -- uB01    -- -- -1 AA
  rol    ebx,16                        ; Second output:  G1 B1 R0 G0             B0 R0 G0 B0        >G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   B0R0G0B0+6144,eax             ; Stash for saving to second line.      s<B0 R0 G0 B0        >G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
  mov    Ze [edi+4],ebx                ; Save G1B1R0G0.					         B0 R0 G0 B0       m<G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   G1B1R0G0+6144,ebx             ; Stash for saving to second line.        B0 R0 G0 B0       s<G1 B1 R0 G0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
  mov    bl,PB R24Value[ecx+ebp*1]     ; Fetch Pel1 R.   G1 B1 -- R1             B0 R0 G0 B0       m>G1 B1 R0 R1       <-- -- -- y1      -- -- -- uB01   <-- -- -1 AA
   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.     B0 R0 G0 B0         G1 B1 R0 R1        -- -- -- y1      -- -- -- uB01  m>BB BB BB BB
  mov    bh,bl                         ; Copy Pel1 R.    G1 B1 R1 R1             B0 R0 G0 B0        >G1 B1 R1 R1        -- -- -- y1      -- -- -- uB01    BB BB BB BB

   mov   cl,[esi+2]                    ; Fetch Y2.                               B0 R0 G0 B0         G1 B1 R1 R1      m>-- -- -- y2      -- -- -- uB01    BB BB BB BB
  ror    ebx,8                         ; Third output:   R1 G1 B1 R1             B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01    BB BB BB BB
   and   ebp,0000001FFH                ; Extract V contrib to R.                 B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01   >-- -- -1 BB
  mov    dl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2    m>-- -- -- uvG23   -- -- -1 BB
   xor   eax,eax                       ;                                         -- -- -- --         R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    al,ChromaContribution+6144+7  ; Fetch U contrib to B value.           m>-- -- -- uB23       R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   R1G1B1R1+6144,ebx             ; Stash for saving to second line.        -- -- -- uB23     s<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    Ze [edi+8],ebx                ; Save R1G1B1R1.                          -- -- -- uB23     m<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   xor   ebx,ebx                       ;                                         -- -- -- uB23      >-- -- -- --        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    bh,PB B24Value[ecx+eax*2]     ; Fetch Pel2 B.                          <-- -- -- uB23     m>-- -- B2 --       <-- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.                         m>-- -- R2 uB23       -- -- B2 --       <-- -- -- y2      -- -- -- uvG23  <-- -- -1 BB
  mov    al,PB G24Value[ecx+edx]       ; Fetch Pel2 G.   -- -- R2 G2           m>-- -- R2 G2         -- -- B2 --       <-- -- -- y2     <-- -- -- uvG23   -- -- -1 BB
   mov   cl,[esi+3]                    ; Fetch Y3.                               -- -- R2 G2         -- -- B2 --      m>-- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  shl    eax,16                        ;                 R2 G2 -- --            >R2 G2 -- --         -- -- B2 --        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   bl,bh                         ; Copy Pel2 B.    -- -- B2 B2             R2 G2 -- --        >-- -- B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  or     ebx,eax                       ;                 R2 G2 B2 B2            <R2 G2 -- --        >R2 G2 B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R2 G2 G3 --           m>R2 G2 G3 --         R2 G2 B2 B2       <-- -- -- y3     <-- -- -- uvG23   -- -- -1 BB
  ror    ebx,8                         ; Fourth output:  B2 R2 G2 B2             R2 G2 G3 --        >B2 R2 G2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   dl,ChromaContribution+6144+7  ; Refetch U contrib to B value.           R2 G2 G3 --         B2 R2 G2 B2        -- -- -- y3    m>-- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+12],ebx               ; Save B2R2G2B2.                          R2 G2 G3 --       m<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   al,PB B24Value[ecx+edx*2]     ; Fetch Pel3 B.   R2 G2 G3 B3           m>R2 G2 G3 B3         B2 R2 G2 B2       <-- -- -- y3     <-- -- -- uB23    -- -- -1 BB
  rol    eax,16                        ; Fifth output:   G3 B3 R2 G2            >G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   B2R2G2B2+6144,ebx             ; Stash for saving to second line.        G3 B3 R2 G2       s<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+16],eax               ; Save G3B3R2G2.                        m<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   G3B3R2G2+6144,eax             ; Stash for saving to second line.      s<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.   G3 B3 -- R3	       m>G3 B3 R2 R3         B2 R2 G2 B2       <-- -- -- y3      -- -- -- uB23   <-- -- -1 BB
   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.     G3 B3 R2 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23  m<CC CC CC CC
  mov    ah,al                         ; Copy Pel3 R.    G3 B3 R3 R3            >G3 B3 R3 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    CC CC CC CC
   mov   cl,[esi+4]                    ; Fetch Y4.					             G3 B3 R3 R3         B2 R2 G2 B2      m>-- -- -- y4      -- -- -- uB23    CC CC CC CC
  ror    eax,8                         ; Sixth output:   R3 G3 B3 R3            >R3 G3 B3 R3         B2 R2 G2 B2        -- -- -- y4      -- -- -- uB23    CC CC CC CC
   xor   ebx,ebx                       ;                                         R3 G3 B3 R3        >-- -- -- --        -- -- -- y4      -- -- -- uB23    CC CC CC CC
  mov    dl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.            R3 G3 B3 R3         -- -- -- --        -- -- -- y4    m>-- -- -- uvG45   CC CC CC CC
   and   ebp,0000001FFH                ; Extract U contrib to B.                 R3 G3 B3 R3         -- -- -- --        -- -- -- y4      -- -- -- uvG45  >-- -- -1 CC
  mov    bl,ChromaContribution+6144+35 ; Fetch U contrib to B value.             R3 G3 B3 R3       m>-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   lea   esi,[esi+4]                   ; Advance input cursor.  
  mov    Ze [edi+20],eax               ; Save R3G3B3R3.                        m<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   mov   R3G3B3R3+6144,eax             ; Stash for saving to second line.      s<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
  mov    eax,ebx                       ;                                        >-- -- -- uB45      <-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,B0R0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx51224z.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512242.asv
;//
;// $Log:   S:\h26x\src\dec\cx512242.asv  $
;// 
;//    Rev 1.8   20 Mar 1996 10:57:22   bnickers
;// Fix numerous bugs.
;// 
;//    Rev 1.7   19 Mar 1996 11:50:22   bnickers
;// Fix error regarding commitment of pages to stack.
;// 
;//    Rev 1.6   18 Mar 1996 09:58:36   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:36   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   22 Dec 1995 15:42:18   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.3   30 Oct 1995 17:15:32   BNICKERS
;// Fix color shift in RGB24 color convertors.
;// 
;//    Rev 1.2   26 Oct 1995 17:49:36   CZHU
;// Fix a whole bunch of bugs.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:22   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:28   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cx512242 -- This function performs YUV12-to-RGB24 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB24ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB24ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]
B0R0G0B0                 EQU  [esp+72]
G1B1R0G0                 EQU  [esp+76]
R1G1B1R1                 EQU  [esp+80]
B2R2G2B2                 EQU  [esp+84]
G3B3R2G2                 EQU  [esp+88]
R3G3B3R3                 EQU  [esp+92]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,4096
  mov   eax,[esp]
  sub   esp,LocalFrameSize-4096
  and   esp,0FFFFF000H
  mov   eax,[esp]
  and   esp,0FFFFE000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  sub   esp,1000H
  mov   eax,[esp]
  add   esp,2000H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  sub   ecx,ebx
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  lea   ebp,[ebx+ebx*4]
   add  edx,esi
  add   ebp,ebx
   mov  YSkipDistance,ecx
  sub   eax,ebp
   mov  YLimit,edx
  shr   ebx,1
   mov  CCOSkipDistance,eax
  mov   ChromaLineLen,ebx
   mov  ecx,AspectAdjustmentCount
  mov   esi,VCursor
   mov  AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[ 0: 7] -- Zero
  ;                                 ; ebp[ 8:15] -- V contrib to G.
  ;                                 ; ebp[16:23] -- V contrib to R.
  ;                                 ; ebp[24:31] -- Zero.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[ 0: 7] -- U contrib to B.
  ;                                 ; ebx[ 8:15] -- U contrib to G.
  ;                                 ; ebx[16:23] -- Zero.
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,32
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-28],ebp                ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi+4],eax                  ; Store EOL indicator.
   mov  LineParity,eax

DoLine1:
                                     ;                                           EAX                 EBX                ECX              EDX              EBP
  xor   ebx,ebx                      ;                                           -- -- -- --        >-- -- -- --        ?? ?? ?? ??      ?? ?? ?? ??     ?? ?? ?? ??
   xor  ecx,ecx                      ;                                           -- -- -- --         -- -- -- --       >-- -- -- --      ?? ?? ?? ??     ?? ?? ?? ??
  mov   ebp,ChromaContribution       ; Fetch preprocessed chroma contribs.       -- -- -- --         -- -- -- --        -- -- -- --      ?? ?? ?? ??     AA AA AA AA
   xor  edx,edx                      ;                                           -- -- -- --         -- -- -- --        -- -- -- --     >-- -- -- --     AA AA AA AA
  mov   cl,[esi]                     ; Fetch Y0.                                 -- -- -- --         -- -- -- --      m>-- -- -- y0      -- -- -- --     AA AA AA AA
   mov  bl,ChromaContribution+3      ; Fetch U contrib to B value.               -- -- -- --       m>-- -- -- uB01      -- -- -- y0      -- -- -- --     AA AA AA AA
  mov   dl,ChromaContribution+2      ; Fetch UV contrib to G value.              -- -- -- --         -- -- -- uB01      -- -- -- y0    m>-- -- -- uvG01  AA AA AA AA
   and  ebp,0000001FFH               ; Extract V contrib to R.                   -- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01 >-- -- -1 AA
  mov   edi,CCOCursor                ;                                           -- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
   sub  esp,6144                     ;                                           -- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA
  xor   eax,eax                      ;                                          >-- -- -- --         -- -- -- uB01      -- -- -- y0      -- -- -- uvG01  -- -- -1 AA

;  Register Usage:
;
;  esi -- Cursor over a line of the Y Plane.
;  edi -- Cursor over the color conv output.
;  ebp -- V contribution to R field of RGB value.
;  edx -- UV contrib to G field;  U contrib to B field of RGB value.
;  ecx -- Y value (i.e. Y contribution to R, G, and B);
;  ebx -- Construction of one and a third pels of RGB24.
;  eax -- Construction of one and a third pels of RGB24.



Next4YPelsLine0:
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov    al,PB B24Value[ecx+ebx*2]     ; Fetch Pel0 B                          m>-- -- -- B0        <-- -- -- uB01     <-- -- -- y0      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB R24Value[ecx+ebp*1]     ; Fetch Pel0 R.	                         -- -- -- B0       m>-- -- R0 uB01     <-- -- -- y0      -- -- -- uvG01  <-- -- -1 AA
  mov    bl,PB G24Value[ecx+edx]       ; Fetch Pel0 G.                           -- -- -- B0       m>-- -- R0 G0       <-- -- -- y0     <-- -- -- uvG01   -- -- -1 AA
   mov   cl,[esi+1]                    ; Fetch Y1.                               -- -- -- B0         -- -- R0 G0      m>-- -- -- y1      -- -- -- uvG01   -- -- -1 AA
  shl    ebx,8                         ;                                         -- -- -- B0        >-- R0 G0 --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA

  shl    ebx,8                         ;                                         -- -- -- B0        >R0 G0 -- --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.							 -- -- -- B0       m>R0 G0 G1 --       <-- -- -- y1     <-- -- -- uvG01   -- -- -1 AA
  mov    dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.           -- -- -- B0         R0 G0 G1 --        -- -- -- y1    m>-- -- -- uB01    -- -- -1 AA
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.                           -- -- -- B0       m>R0 G0 G1 B1       <-- -- -- y1     <-- -- -- uB01    -- -- -1 AA
  add    al,bl                         ; Fetch Pel1 B.                         r>-- -- -- B0+B1      R0 G0 G1 B1        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   shr   al,1                          ; Fetch Pel1 B.                          >-- -- -- B01        R0 G0 G1 B1        -- -- -- y1      -- -- -- uB01    -- -- -1 AA


  or     eax,ebx                       ;									   r>-- R0 G0 B0        <-- R0 G0 --        -- -- -- y1      -- -- -- uvG01   -- -- -1 AA
   mov   bh,PB G24Value[ecx+edx]       ; Fetch Pel1 G.							 -- R0 G0 B0       m>-- R0 G1 --       <-- -- -- y1     <-- -- -- uvG01   -- -- -1 AA
  mov    dl,ChromaContribution+6144+3  ; Refetch U contrib to B value.           -- R0 G0 B0         -- R0 G1 --        -- -- -- y1    m>-- -- -- uB01    -- -- -1 AA
   mov   bl,PB B24Value[ecx+edx*2]     ; Fetch Pel1 B.                           -- R0 G0 B0       m>-- R0 G1 B1       <-- -- -- y1     <-- -- -- uB01    -- -- -1 AA
  rol    ebx,16                        ; Make room for R1                        -- R0 G0 B0        >G1 B1 -- R0        -- -- -- y1      -- -- -- uB01    -- -- -1 AA
   mov   dl,bl                         ; Save R0.                                -- R0 G0 B0         G1 B1 -- R0        -- -- -- y1     >-- -- -- R0      -- -- -1 AA
  mov    bl,PB R24Value[ecx+ebp*1]     ; Fetch Pel1 R1.                          -- R0 G0 B0        >G1 B1 -- R1       <-- -- -- y1      -- -- -- R0     <-- -- -1 AA
   add   dl,bl                         ; Add R1 to R0.                           -- R0 G0 B0         G1 B1 -- R1        -- -- -- y1     >-- -- -- R0+R1   -- -- -1 AA
  shr    edx,1                         ; Compute (R1+R0)/2.                      -- R0 G0 B0         G1 B1 -- R1        -- -- -- y1     >-- -- -- R01     -- -- -1 AA
   mov   bh,dl                         ; Save R01.                               -- R0 G0 B0        >G1 B1 R01R1        -- -- -- y1     <-- -- -- R01     -- -- -1 AA
  rol    ebx,16                        ; Reorder components.                     -- R0 G0 B0        >R01R1 G1 B1        -- -- -- y1      -- -- -- R01     -- -- -1 AA
   mov   dl,al                         ; Copy B0.                               <-- R0 G0 B0         R01R1 G1 B1        -- -- -- y1    r>-- -- -- B0      -- -- -1 AA
  mov    cl,bh                         ; Copy G1.                                -- R0 G0 B0        <R01R1 G1 B1      r>-- -- -- G1      -- -- -- B0      -- -- -1 AA
   add   dl,bl                         ; Add B1 to B0.                           -- R0 G0 B0        <R01R1 G1 B1        -- -- -- G1    r>-- -- -- B0+B1   -- -- -1 AA
  add    cl,ah                         ; Add G0 to G1.                          <-- R0 G0 B0         R01R1 G1 B1      r>-- -- -- G1+G0   -- -- -- B0+B1   -- -- -1 AA
   shr   edx,1                         ; Compute (B1+B0)/2.                      -- R0 G0 B0         R01R1 G1 B1        -- -- -- G1+G0  >-- -- -- B01     -- -- -1 AA
  shr    ecx,1                         ; Compute (G1+G0)/2.                      -- R0 G0 B0         R01R1 G1 B1       >-- -- -- G01     -- -- -- B01     -- -- -1 AA
   shl   ecx,24                        ; Reorder nibbles.                        -- R0 G0 B0         R01R1 G1 B1        -- -- -- G01    >B01-- -- --      -- -- -1 AA
  or     eax,edx                       ; Reorder nibbles.                      r>B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01    <B01-- -- --      -- -- -1 AA
   mov   Ze [edi],eax                  ; Save B01R0G0B0.                       m<B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01     B01-- -- --      -- -- -1 AA
  mov    edx,ebx                       ;                                         B01R0 G0 B0        <R01R1 G1 B1        -- -- -- G01    >R01R1 G1 B1      -- -- -1 AA
   rol   edx,16                        ;                                         B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01    >G1 B1 R01R1      -- -- -1 AA
  mov    dl,cl                         ;                                         B01R0 G0 B0         R01R1 G1 B1       <-- -- -- G01    >R1 B1 R01G01     -- -- -1 AA
   mov   Ze [edi+4],edx                ; Save R1B1R01G01.                        B01R0 G0 B0         R01R1 G1 B1        -- -- -- G01   m<R1 B1 R01G01     -- -- -1 AA

   mov   ebp,ChromaContribution+6144+4 ; Fetch preprocessed chroma contribs.     B0 R0 G0 B0         G1 B1 R0 R1        -- -- -- y1      -- -- -- uB01    BB BB BB BB
  mov    bh,bl                         ; Copy Pel1 R.                            B0 R0 G0 B0        >G1 B1 R1 R1        -- -- -- y1      -- -- -- uB01    BB BB BB BB
   mov   cl,[esi+2]                    ; Fetch Y2.                               B0 R0 G0 B0         G1 B1 R1 R1      m>-- -- -- y2      -- -- -- uB01    BB BB BB BB
  ror    ebx,8                         ; Third output:                           B0 R0 G0 B0        >R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01    BB BB BB BB
   and   ebp,0000001FFH                ; Extract V contrib to R.                 B0 R0 G0 B0        >R1 G1 B1 R1        -- -- -- y2      -- -- -- uB01    -- -- -1 BB
  mov    dl,ChromaContribution+6144+6  ; Fetch UV contrib to G value.            B0 R0 G0 B0         R1 G1 B1 R1        -- -- -- y2     >-- -- -- uvG23   -- -- -1 BB
   xor   eax,eax                       ;                                        >-- -- -- --         R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    al,ChromaContribution+6144+7  ; Fetch U contrib to B value.            >-- -- -- uB23       R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   R1G1B1R1+6144,ebx             ; Stash for saving to second line.        -- -- -- uB23     m<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    Ze [edi+8],ebx                ; Save R1G1B1R1.                          -- -- -- uB23     m<R1 G1 B1 R1        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   xor   ebx,ebx                       ;                                         -- -- -- uB23      >-- -- -- --        -- -- -- y2      -- -- -- uvG23   -- -- -1 BB
  mov    bh,PB B24Value[ecx+eax*2]     ; Fetch Pel2 B.                          <-- -- -- uB23      >-- -- B2 --       <-- -- -- y2      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB R24Value[ecx+ebp*1]     ; Fetch Pel2 R.                          >-- -- R2 uB23       -- -- B2 --       <-- -- -- y2      -- -- -- uvG23  <-- -- -1 BB
  mov    al,PB G24Value[ecx+edx]       ; Fetch Pel2 G.                          >-- -- R2 G2         -- -- B2 --       <-- -- -- y2     <-- -- -- uvG23   -- -- -1 BB
   mov   cl,[esi+3]                    ; Fetch Y3.                               -- -- R2 G2         -- -- B2 --       >-- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  shl    eax,16                        ;                 R2 G2 -- --            >R2 G2 -- --         -- -- B2 --        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   bl,bh                         ; Copy Pel2 B.    -- -- B2 B2             R2 G2 -- --        >-- -- B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
  or     ebx,eax                       ;                 R2 G2 B2 B2             R2 G2 -- --        >R2 G2 B2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   ah,PB G24Value[ecx+edx]       ; Fetch Pel1 G.   R2 G2 G3 --            >R2 G2 G3 --         R2 G2 B2 B2       <-- -- -- y3     <-- -- -- uvG23   -- -- -1 BB
  ror    ebx,8                         ; Fourth output:  B2 R2 G2 B2             R2 G2 G3 --        >B2 R2 G2 B2        -- -- -- y3      -- -- -- uvG23   -- -- -1 BB
   mov   dl,ChromaContribution+6144+7  ; Refetch U contrib to B value.           R2 G2 G3 --         B2 R2 G2 B2        -- -- -- y3     >-- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+12],ebx               ; Save B2R2G2B2.                          R2 G2 G3 --       m<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   al,PB B24Value[ecx+edx*2]     ; Fetch Pel3 B.   R2 G2 G3 B3           m>R2 G2 G3 B3         B2 R2 G2 B2       <-- -- -- y3     <-- -- -- uB23    -- -- -1 BB
  rol    eax,16                        ; Fifth output:   G3 B3 R2 G2            >G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   B2R2G2B2+6144,ebx             ; Stash for saving to second line.        G3 B3 R2 G2       m<B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    Ze [edi+16],eax               ; Save G3B3R2G2.                        m<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
   mov   G3B3R2G2+6144,eax             ; Stash for saving to second line.      m<G3 B3 R2 G2         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    -- -- -1 BB
  mov    al,PB R24Value[ecx+ebp*1]     ; Fetch Pel3 R.   G3 B3 -- R3           m>G3 B3 R2 R3         B2 R2 G2 B2       <-- -- -- y3      -- -- -- uB23   <-- -- -1 BB
   mov   ebp,ChromaContribution+6144+32; Fetch preprocessed chroma contribs.     G3 B3 R2 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23  m>CC CC CC CC
  mov    ah,al                         ; Copy Pel3 R.    G3 B3 R3 R3            >G3 B3 R3 R3         B2 R2 G2 B2        -- -- -- y3      -- -- -- uB23    CC CC CC CC
   mov   cl,[esi+4]                    ; Fetch Y4.                               G3 B3 R3 R3         B2 R2 G2 B2       >-- -- -- y4      -- -- -- uB23    CC CC CC CC
  ror    eax,8                         ; Sixth output:   R3 G3 B3 R3            >R3 G3 B3 R3         B2 R2 G2 B2        -- -- -- y4      -- -- -- uB23    CC CC CC CC
   xor   ebx,ebx                       ;                                         R3 G3 B3 R3        >-- -- -- --        -- -- -- y4      -- -- -- uB23    CC CC CC CC
  mov    dl,ChromaContribution+6144+34 ; Fetch UV contrib to G value.            R3 G3 B3 R3         -- -- -- --        -- -- -- y4    m>-- -- -- uvG45   CC CC CC CC
   and   ebp,0000001FFH                ; Extract U contrib to B.                 R3 G3 B3 R3         -- -- -- --        -- -- -- y4      -- -- -- uvG45  >-- -- -1 CC
  mov    bl,ChromaContribution+6144+35 ; Fetch U contrib to B value.             R3 G3 B3 R3        >-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   lea   esi,[esi+4]                   ; Advance input cursor.                   R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
  mov    Ze [edi+20],eax               ; Save R3G3B3R3.                        m<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
   mov   R3G3B3R3+6144,eax             ; Stash for saving to second line.      m<R3 G3 B3 R3         -- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 CC
  mov    eax,ebx                       ;                                       r>-- -- -- uB45      <-- -- -- uB45      -- -- -- y4      -- -- -- uvG45   -- -- -1 C
   lea   esp,[esp+32]
  lea    edi,[edi+24]                  ; Advance output cursor.
   jne   Next4YPelsLine0

  and   esp,0FFFFE000H
  add   esp,02000H
  
  mov   ebx,CCOSkipDistance
   mov  ebp,AspectCount
  add   edi,ebx
   sub  ebp,2                      ; If count is non-zero, we keep the line.
  mov   AspectCount,ebp
   lea  ecx,B0R0G0B0
  mov   eax,FrameWidth
   jg   Keep2ndLineOfLine0

  add   ebp,AspectAdjustmentCount
  mov   AspectCount,ebp
   jmp  Skip2ndLineOfLine0

Keep2ndLineOfLine0:
Keep2ndLineOfLine0_Loop:

  mov   ebp,[ecx]
   sub  eax,4
  mov   Ze PD [edi],ebp
   mov  ebp,[ecx+4]
  mov   Ze PD [edi+4],ebp
   mov  ebp,[ecx+8]
  mov   Ze PD [edi+8],ebp
   mov  ebp,[ecx+12]
  mov   Ze PD [edi+12],ebp
   mov  ebp,[ecx+16]
  mov   Ze PD [edi+16],ebp
   mov  ebp,[ecx+20]
  mov   Ze PD [edi+20],ebp
   lea  ecx,[ecx+32]
  lea   edi,[edi+24]
   jne  Keep2ndLineOfLine0_Loop

  add   edi,ebx

Skip2ndLineOfLine0:

   mov  bl,LineParity
  add   esi,YSkipDistance
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB24ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512322.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512322.asv
;//
;// $Log:   S:\h26x\src\dec\cx512322.asv  $
;// 
;//    Rev 1.2   12 Apr 1996 11:26:26   RMCKENZX
;// Corrected bug in fetching first V contribution to Red.
;// 
;//    Rev 1.1   10 Apr 1996 11:12:54   RMCKENZX
;// Fixed bug in aspect ratio correction -- clearing sign bit of bl.
;// 
;//    Rev 1.0   01 Apr 1996 10:25:48   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by two.
; ||||||||
; cx512322 -- This function performs YUV12-to-RGB32 zoom-by-two color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It handles the format in which the low order
;             byte is B, the second byte is G, the third byte is R, and the
;             high order byte is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 FAR * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32ZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToRGB32ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*8+32
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]

YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
ChromaPitch              EQU  [esp+40]
AspectAdjustmentCount    EQU  [esp+44]
LineParity               EQU  [esp+48]
LumaPitch                EQU  [esp+52]
FrameWidth               EQU  [esp+56]
StashESP                 EQU  [esp+60]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+YPitch_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+FrameWidth_arg]
  mov   LumaPitch,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   FrameWidth,edx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  shl   ebx,3
   mov  esi,YCursor              ; Fetch cursor over luma plane.
  add   edx,esi
   sub  eax,ebx
  shr   ebx,4
   mov  YLimit,edx
  mov   ChromaLineLen,ebx
   mov  CCOSkipDistance,eax
  mov   esi,VCursor
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ecx

;  Register Usage:
;
;  edi -- Y Line cursor.  Chroma contribs go in lines above current Y line.
;  esi -- Chroma Line cursor.
;  ebp -- Y Pitch
;  edx -- Distance from V pel to U pel.
;  ecx -- V contribution to RGB; sum of U and V contributions.
;  ebx -- U contribution to RGB.
;  eax -- Alternately a U and a V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  esi,YCursor
  mov   [edi],eax                   ; Store EOL indicator.
   mov  LineParity,eax
  mov   edi,CCOCursor

Keep2ndLineOfOutput:
DoLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

   xor  edx,edx
  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  eax,eax

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
  mov   Ze [edi+4],edx                 ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+16]                   ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-8],edx                 ; Write RGB32 for Pel01.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  mov   eax,CCOSkipDistance
   mov  bl,LineParity
  add   edi,eax
   xor  bl,080H
  mov   esi,YCursor
   jns  SecondOutputLineDone
   
  mov   LineParity,bl
   mov  ebp,AspectCount
  sub   ebp,2                          ; If count is non-zero, we keep the line.
   mov  ecx,AspectAdjustmentCount
  mov   AspectCount,ebp
   jg   Keep2ndLineOfOutput

  add   ebp,ecx
   and  bl, 7fh                     ; clear LineParity SecondOutputLineDone bit
  mov   AspectCount,ebp

SecondOutputLineDone:

  add   esi,LumaPitch
   xor  bl,1
  mov   CCOCursor,edi
   mov  YCursor,esi
  mov   LineParity,bl
   jne  DoLine1

  mov   eax,esi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebp,ChromaPitch
   mov  ebx,YLimit                  ; Done with last line?
  add   esi,ebp
   cmp  eax,ebx
  mov   VCursor,esi
   jb   PrepareChromaLine

Done:

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512321.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512321.asv
;//
;// $Log:   S:\h26x\src\dec\cx512321.asv  $
;// 
;//    Rev 1.0   01 Apr 1996 10:25:46   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium(r) Microprocessor.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cx512321 -- This function performs YUV12-to-RGB32 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It handles the format in which the low order byte is B, the
;             second byte is G, the third byte is R, and the high order byte
;             is zero.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToRGB32

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack,
; or, rather, how to mangle the entry name.

YUV12ToRGB32    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 60+768*4+16
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch                    = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch                  = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
CCOSkipDistance          EQU  [esp+ 4]
ChromaLineLen            EQU  [esp+ 8]
YSkipDistance            EQU  [esp+12]
YLimit                   EQU  [esp+16]
YCursor                  EQU  [esp+20]
VCursor                  EQU  [esp+24]
DistanceFromVToU         EQU  [esp+28]
EndOfChromaLine          EQU  [esp+32]
AspectCount              EQU  [esp+36]
FrameWidth               EQU  [esp+40]
ChromaPitch              EQU  [esp+44]
AspectAdjustmentCount    EQU  [esp+48]
LineParity               EQU  [esp+52]
StashESP                 EQU  [esp+56]

ChromaContribution       EQU  [esp+60]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,[edi+YPitch]
  mov   ebx,FrameWidth
   mov  eax,[edi+CCOPitch]
  imul  edx,ecx
  sub   ecx,ebx
   lea  ebx,[ebx*4]
  sub   eax,ebx
   mov  YSkipDistance,ecx
  sar   ebx,3
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  add   edx,esi
   mov  CCOSkipDistance,eax
  mov   YLimit,edx
   mov  ChromaLineLen,ebx
  mov   YCursor,esi
   xor  eax,eax
  mov   esi,VCursor
   mov  LineParity,eax

;  Register Usage:
;
;  edi -- Chroma contribution Line cursor.
;  esi -- Chroma Line cursor.
;  ebp -- V contribution to RGB;  sum of U and V contributions.
;  edx -- Distance from V pel to U pel.
;  ecx -- A U pel.
;  ebx -- U contribution to RGB.
;  eax -- A V pel.

PrepareChromaLine:

  mov   edi,ChromaLineLen
   xor  eax,eax
  mov   edx,DistanceFromVToU
   mov  al,[esi]                    ; Fetch V.
  add   edi,esi                     ; Compute EOL address.
   xor  ecx,ecx
  mov   ebp,PD V24Contrib[eax*8]    ; ebp[24:31] -- Zero (blue).
  ;                                 ; ebp[16:24] -- V contrib to G.
  ;                                 ; ebp[ 9:15] -- Zero (pad).
  ;                                 ; ebp[ 0: 8] -- V contrib to R.
   mov  cl,[esi+edx]                ; Fetch U.
  mov   EndOfChromaLine,edi
   xor  ebx,ebx                     ; Keep pairing happy.
  mov   ebx,PD U24Contrib[ecx*8]    ; ebx[24:31] -- U contrib to B.
  ;                                 ; ebx[16:24] -- U contrib to G.
  ;                                 ; ebx[11:15] -- Zero (pad).
  ;                                 ; ebx[ 2:10] -- Zero (red).
  ;                                 ; ebx[ 0: 1] -- Zero (pad).
   mov  cl,[esi+edx+1]              ; Fetch next U.
  lea   edi,ChromaContribution
   add  ebp,ebx                     ; Chroma contributions to RGB.

NextChromaPel:

  mov   ebx,PD U24Contrib[ecx*8]    ; See above.
   mov  al,[esi+1]                  ; Fetch V.
  mov   [edi],ebp                   ; Store contribs to use for even chroma pel.
   mov  cl,[esi+edx+2]              ; Fetch next U.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   add  edi,8
  add   ebp,ebx                     ; Chroma contributions to RGB.
   mov  al,[esi+2]                  ; Fetch V.
  mov   [edi-4],ebp                 ; Store contribs to use for odd chroma pel.
   mov  ebx,PD U24Contrib[ecx*8]    ; See above.
  mov   ebp,PD V24Contrib[eax*8]    ; See above.
   mov  cl,[esi+edx+3]              ; Fetch next U.
  add   ebp,ebx                     ; Chroma contributions to RGB.
   add  esi,2                       ; Inc Chroma cursor.
  cmp   esi,EndOfChromaLine
   jne  NextChromaPel

  xor   eax,eax
   mov  edx,AspectCount
  mov   [edi],eax                   ; Store EOL indicator.
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   mov  edi,CCOCursor
  mov   esi,YCursor
   jne  KeepLine0

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:
KeepLine1:

;  Register Usage:
;
;  edi -- Cursor over the color converted output image.
;  esi -- Cursor over a line of the Y Plane.
;  ebp -- V contribution to R field of RGB value.
;  edx -- Construction of a pel of RGB32.
;  cl  -- Y value (i.e. Y contribution to R, G, and B);
;  bl  -- UV contribution to G field of RGB value.
;  al  -- U contribution to B field of RGB val.

  mov   ebp,ChromaContribution         ; Get V contribution to R value.
   xor  ecx,ecx
  sub   esp,1536
   mov  cl,[esi]                       ; Get Y00.
  xor   ebx,ebx
   and  ebp,01FFH                      ; Extract V contribution to R value.
  mov   bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
   xor  edx,edx

DoNext2YPelsOfLine0:

  mov   dl,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel00.
   add  esi,2                          ; Advance luma cursor.
  shl   edx,16                         ; Position R and high order 0-byte.
   mov  al,ChromaContribution+1536+3   ; Get U contribution to B value.
  mov   dh,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel00.
   add  esp,4                          ; Advance chroma contribution cursor.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel00.
   mov  cl,[esi-1]                     ; Get Y01.
  mov   Ze [edi],edx                   ; Write RGB32 for Pel00.
   xor  edx,edx
  mov   dh,PB R24Value[ecx+ebp*1]      ; Get clamped R value for Pel01.
   mov  ebp,ChromaContribution+1536    ; Get V contribution to R value.
  mov   dl,PB G24Value[ecx+ebx]        ; Get clamped G value for Pel01.
   lea  edi,[edi+8]                    ; Advance output cursor.
  shl   edx,8                          ; Position R, G, and high order 0-byte.
   mov  bl,ChromaContribution+1536+2   ; Get UV contribution to G value.
  mov   dl,PB B24Value[ecx+eax*2]      ; Get clamped B value for Pel01.
   mov  cl,[esi]                       ; Get Y02.
  mov   Ze [edi-4],edx                 ; Write RGB32 for Pel01.
   xor  edx,edx
  and   ebp,01FFH                      ; Extract V contrib to R val.  0 --> EOL.
   jne  DoNext2YPelsOfLine0

  and   esp,0FFFFF800H
  add   esp,800H
  add   edi,CCOSkipDistance
 
SkipLine0:

  mov   bl,LineParity
   mov  ebp,YSkipDistance           ; *** change to use ebp *** rgm 3/27/96
  xor   bl,1
   je   Line1Done

  mov   LineParity,bl
   mov  edx,AspectCount
  add   esi,ebp                     ; *** change to use ebp *** rgm 3/27/96
   dec  edx                         ; If count is non-zero, we keep the line.
  mov   AspectCount,edx
   jne  KeepLine1

  add   esi,FrameWidth
   mov  edx,AspectAdjustmentCount
  mov   AspectCount,edx
   xor  ebx, ebx                    ; *** change to advance parity *** rgm

Line1Done:

  mov   LineParity,bl
   add  ebp,esi                     ; *** change to use ebp *** rgm 3/27/96
  mov   CCOCursor,edi
   mov  esi,VCursor                 ; Inc VPlane cursor to next line.
  mov   ebx,ChromaPitch
   mov  YCursor,ebp                 ; *** change to use ebp *** rgm 3/27/96
  add   esi,ebx     
   mov  ebx,YLimit                  ; Done with last line?
  mov   VCursor,esi
   cmp  ebp,ebx                     ; *** change to use ebp *** rgm 3/27/96
  jb    PrepareChromaLine

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToRGB32 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\excolcnv.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   21 Nov 1996 17:33:56  $
// $Archive:   S:\h26x\src\enc\excolcnv.cpv  $
// $Header:   S:\h26x\src\enc\excolcnv.cpv   1.45   21 Nov 1996 17:33:56   MDUDA  $
// $Log:   S:\h26x\src\enc\excolcnv.cpv  $
// 
//    Rev 1.45   21 Nov 1996 17:33:56   MDUDA
// Added more non-compressed YUV12 support (RGB16 and RGB24).
// Also rewrote IA_YUV12toEncYUV12 to be more readable.
// 
//    Rev 1.44   31 Oct 1996 10:05:48   KLILLEVO
// changed from DBOUT to DbgLog
// 
//    Rev 1.43   22 Oct 1996 16:44:22   MDUDA
// Added IA support for YUY2 input color conversion and cleaned up C version.
// Now using IA version.
// 
//    Rev 1.42   18 Oct 1996 14:31:32   MDUDA
// 
// Added a C-version of YUY2 input color conversion.
// 
//    Rev 1.41   11 Oct 1996 16:04:50   MDUDA
// Using new RGB to YUV lookup tables.
// 
//    Rev 1.40   03 Oct 1996 10:43:58   AGUPTA2
// Got rid of segment directives; made tables read-only.
// 
//    Rev 1.39   13 Sep 1996 13:34:04   MDUDA
// Fixed YVU9 bug where input = output frame size was not colored
// (U and V planes) properly.
// 
//    Rev 1.38   11 Sep 1996 15:45:06   MDUDA
// Modified RGB look-up tables and added C_H26X_YUV12toEncYUV12 and
// IA_H26X_YUV12toEncYUV12.
// 
//    Rev 1.37   03 Sep 1996 14:54:46   MDUDA
// Fixed problem causing VC++ 4.1 internal compiler error. Replaced
// inline assembler constructs such as [ebx.biWidth] with
// (LPBITMAPINFOHEADER)[ebx].biWidth.
// 
//    Rev 1.36   29 Aug 1996 16:31:14   MDUDA
// Added Pentium assembler versions for all RGB conversion routines.
// Also, rewrote YVU9 support to allow input frame sizes other
// than 160x120 and 240x180.
// 
//    Rev 1.35   16 Aug 1996 12:17:48   MDUDA
// Fixed bug where U and V values in the BGR converters were treated as unsign
// values. Also did some general cleanup of BGR converters in preparation for
// doing Pentium assembler version.
// 
//    Rev 1.34   13 Aug 1996 10:35:38   MDUDA
// Added support for RGB4. Generalized RGB LUT support for 4-bit and
// and 8-bit pixels into a single routine.
// 
//    Rev 1.33   09 Aug 1996 09:45:02   MDUDA
// Added support for RGB16 format on input. This is for the color
// Quick Cam. Also, generalized RGB16 for other bit combinations.
// However, these can only be specified under BI_BITFIELDS format.
// 
//    Rev 1.32   02 Aug 1996 13:44:48   MDUDA
// modified H26X_BGR24toYUV12 to crop and stretch 240x180 and 160x120
// frames
// 
//    Rev 1.31   01 Aug 1996 14:03:50   MDUDA
// 
// Optimized H26X_YVU9toYUV12 by rewriting function in assembler code. Used in
// _asm. Also re-arranged functions so that colorCnvtFrame is at the end of
// the file.
// 
//    Rev 1.30   22 Jul 1996 13:28:22   BECHOLS
// Added a CLUT8 to YUV12 color convertor (CC). This CC crops and stretches
// either the 240x180 or the 160x120 image size to produce QCIF and SubQCIF
// image sizes respectively.
// 
//    Rev 1.29   11 Jul 1996 15:47:02   MDUDA
// 
// Modified H263_YVU9toYUV12 to create subQCIF and QCIF from
// 160x120 and 240x180 images, respectively. To fit the new
// formats, the original images are cropped and stretched using a
// dither pattern for the color planes.
// 
//    Rev 1.28   14 May 1996 12:04:08   KLILLEVO
// changed RGB->YUV color conversion to use the inverse
// if the output YUV->RGB conversion instead of the conversion
// "recommended by the CCIR". Compression performance for RGB
// input was significantly improved (33% less bits for same
// fixed QP)
// 
//    Rev 1.27   04 May 1996 21:55:20   BECHOLS
// For RGB24 to YVU12 conversion, I unrolled the inner loop by 8 and changed
// the writes to DWORD vs. BYTE writes.  This resulted in a 30% reduction in
// the execution time.
// 
//    Rev 1.26   10 Apr 1996 16:44:14   RHAZRA
// Fixed a bug in 320x240 mode for the H26X_YUV12toEncYUV12() function.
// DWORD should be and-ed with 0x7f7f7f7f and not 0x7f7f7f.
// 
//    Rev 1.25   27 Mar 1996 15:10:08   SCDAY
// Optimized H26X_YUV12toEncYUV12 'C' code to read/write DWORDs
// 
//    Rev 1.24   08 Jan 1996 17:46:14   unknown
// 
// Correct logic on bIs320x240 check
// 
//    Rev 1.23   05 Jan 1996 17:34:38   RMCKENZX
// corrected chroma pad value to 0x40 to achieve black padding
// 
//    Rev 1.22   05 Jan 1996 17:29:46   RMCKENZX
// Added code to pad out 320x240 stills to 352x288 
// full CIF images.
// 
//    Rev 1.21   04 Jan 1996 18:37:20   TRGARDOS
// Added code to permit 320x240 input and then set a boolean
// bIs320x240.
// 
//    Rev 1.20   02 Jan 1996 17:09:04   TRGARDOS
// Moved colorCnvFrame into this file and made the
// color convertor functions static.
// 
//    Rev 1.19   27 Dec 1995 15:32:56   RMCKENZX
// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:35:42   TRGARDOS
// Added Brian's fix to the input color convertor to avoid
// overflow of the chars.
// 
//    Rev 1.17   27 Nov 1995 16:09:04   TRGARDOS
// Removed two unused variables to get rid of compiler warnings.
// 
//    Rev 1.16   30 Oct 1995 14:34:12   TRGARDOS
// Fixed 240x180 to center clip.
// 
//    Rev 1.15   30 Oct 1995 12:03:16   TRGARDOS
// Added color convertor support for YUV9 240x180.
// 
//    Rev 1.14   28 Oct 1995 15:39:28   TRGARDOS
// Fixed color conversion problem from YVU9 to YVU12.
// 
//    Rev 1.13   12 Oct 1995 17:40:12   TRGARDOS
// Fixed YUV12 input color convertor.
// 
//    Rev 1.12   12 Oct 1995 12:04:16   TRGARDOS
// Changed some variable names in YUV12 convertor.
// 
//    Rev 1.11   10 Oct 1995 16:34:12   TRGARDOS
// Added YUV12 input support.
// 
//    Rev 1.10   28 Sep 1995 17:02:36   DBRUCKS
// fix colorIn to not swap left to right
// 
//    Rev 1.9   15 Sep 1995 16:37:38   TRGARDOS
// 
// 
//    Rev 1.8   13 Sep 1995 17:09:22   TRGARDOS
// 
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.7   11 Sep 1995 11:14:06   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.6   07 Sep 1995 09:27:54   TRGARDOS
// Added YVU9 to YVU12 color convertor.
// 
//    Rev 1.5   05 Sep 1995 15:50:46   TRGARDOS
// Added color back in to convertors.
// 
//    Rev 1.4   01 Sep 1995 17:51:42   TRGARDOS
// Fixed bugs in color converter.
// 
//    Rev 1.3   01 Sep 1995 10:13:42   TRGARDOS
// Debugging bit stream errors.
// 
//    Rev 1.2   30 Aug 1995 12:42:26   TRGARDOS
// Fixed bugs in intra AC coef VLC coding.
// 
//    Rev 1.1   02 Aug 1995 17:28:06   TRGARDOS
// 
// Cleaned up stuff to get stub working under new
// version control system.
// 
//    Rev 1.0   31 Jul 1995 13:07:10   DBRUCKS
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:46:16   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:22   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

/*

CCIR 601 Specifies a conversion from RGB to YCrCb. For
what we call U and V, they are equivalent as 
U = Cb, V = Cr.

From CCIR 601-2 Annex II, we can go from RGB with values
in the range of 0-255, to YUV values in the same range
by the equation:

Y = (    77*R + 150*G +  29*B ) >> 8;
V = (   131*R - 110*G -  21*B ) >> 8 + 128; 	// Cr
U = ( (-44)*R -  87*G + 131*B ) >> 8 + 128;		// Cb

Has now changed to the inverse of the YUV->RGB on the
output, since the old version produced way too many bits.
The new version is:

Y = (   16836*R +  33056*G +  6416*B ) >> 16 + 16;
V = (   28777*R -  24117*G -  4660*B ) >> 16 + 128; 	// Cr
U = ( (-9726)*R -  19064*G + 28790*B ) >> 16 + 128;		// Cb

*/

#include "precomp.h"

#if !defined(H263P) && !defined(USE_BILINEAR_MSH26X) // { H263P

#if defined(_CODEC_STATS)

static const double RDTSC_SHIFT_32 = 4294967296.0;

static double PENTIUM_TIMER()
{
	unsigned long int a, b;
	double temp1, temp2, result;

	__asm
	{
		_emit   0x0f
		_emit   0x31
		mov     a, eax
		mov     b, edx
	}

	temp1 = (double) a;
	temp2 = (double) (b & 0xFFFF);
	if (RDTSC_CLOCK_FREQ) {
		result = (temp1 + temp2 * RDTSC_SHIFT_32) / RDTSC_CLOCK_FREQ;
	} else {
		result = 0.0;
	}
	return( result * 1000.0 );
}

#endif

// Set all local functions to "static", and then set it accordingly if
// VTune statistics are to be collected. VTune doesn't recognize static functions
// so we need some way to turn off the static attribute if VTune is to be run
// on the executable. For now, simply use a define of _VTUNE to build the driver.
#if defined(_VTUNE)
#define _STATIC
#else
#define _STATIC static
#endif

// These are the look-up tables for the RGB converters. They are 8 bytes/entry
// to allow addressing via the scale by 8 indexed addressing mode. A pseudo-SIMD
// arrangement is used in these tables. Since all R, G and B contributions to the
// Y value are positive and fit in 15 bits, these are stored in the lower 16-bits
// of the YU word. In some cases, the U contribution is negative so it is placed
// in the upper 16 bits of the YU word. When a Y value is calculated, the U value
// is calculated in parallel. The V contribution is negative in some cases, but it
// gets its own word.

// This is the code that was used to generate the tables.
#if 0
#define YRCoef   16836
#define YGCoef   33056
#define YBCoef    6416
#define URCoef    9726
#define UGCoef   19064
#define UBCoef   28790
#define VRCoef   28777
#define VGCoef   24117
#define VBCoef    4660

#include <stdio.h>

void main() {
int i,j;

  printf("struct YUV {\n");
  printf("  int YU;\n");
  printf("  int V;\n");
  printf("};\n\n");

  printf("struct YUV  RYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YRCoef*((i*4)+j+1))>>9) |
         ((-(((URCoef*((i*4)+j+1)))>>9))<<16),
        ((VRCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  GYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YGCoef*((i*4)+j+1))>>9) |
         ((-(((UGCoef*((i*4)+j+1)))>>9))<<16),
         -((VGCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");

  printf("struct YUV  BYUV[] = {\n");
  for (i = 0; i < 64; i++) {
    for (j = 0; j < 4; j += 2) {
      printf("{0x%.8x, 0x%.8x}, ",
        ((YBCoef*((i*4)+j+1))>>9) |
         (((UBCoef*((i*4)+j+1))>>9)<<16),
        -((VBCoef*((i*4)+j+1))>>9));
    }
    printf("\n");
  }
  printf("};\n");
}
#endif
 
struct YUV {
  int YU;
  int V;
};

const struct YUV  RYUV[] = {
{0xffee0020, 0x00000038}, {0xffc80062, 0x000000a8}, 
{0xffa200a4, 0x00000119}, {0xff7c00e6, 0x00000189}, 
{0xff560127, 0x000001f9}, {0xff300169, 0x0000026a}, 
{0xff0a01ab, 0x000002da}, {0xfee401ed, 0x0000034b}, 
{0xfebe022f, 0x000003bb}, {0xfe980270, 0x0000042b}, 
{0xfe7202b2, 0x0000049c}, {0xfe4c02f4, 0x0000050c}, 
{0xfe260336, 0x0000057d}, {0xfe000377, 0x000005ed}, 
{0xfdda03b9, 0x0000065d}, {0xfdb403fb, 0x000006ce}, 
{0xfd8e043d, 0x0000073e}, {0xfd68047e, 0x000007af}, 
{0xfd4204c0, 0x0000081f}, {0xfd1c0502, 0x0000088f}, 
{0xfcf60544, 0x00000900}, {0xfcd00585, 0x00000970}, 
{0xfcaa05c7, 0x000009e1}, {0xfc840609, 0x00000a51}, 
{0xfc5e064b, 0x00000ac2}, {0xfc38068d, 0x00000b32}, 
{0xfc1206ce, 0x00000ba2}, {0xfbec0710, 0x00000c13}, 
{0xfbc60752, 0x00000c83}, {0xfba00794, 0x00000cf4}, 
{0xfb7a07d5, 0x00000d64}, {0xfb540817, 0x00000dd4}, 
{0xfb2e0859, 0x00000e45}, {0xfb08089b, 0x00000eb5}, 
{0xfae208dc, 0x00000f26}, {0xfabc091e, 0x00000f96}, 
{0xfa960960, 0x00001006}, {0xfa7009a2, 0x00001077}, 
{0xfa4a09e3, 0x000010e7}, {0xfa240a25, 0x00001158}, 
{0xf9fe0a67, 0x000011c8}, {0xf9d80aa9, 0x00001239}, 
{0xf9b20aeb, 0x000012a9}, {0xf98c0b2c, 0x00001319}, 
{0xf9660b6e, 0x0000138a}, {0xf9400bb0, 0x000013fa}, 
{0xf91a0bf2, 0x0000146b}, {0xf8f40c33, 0x000014db}, 
{0xf8ce0c75, 0x0000154b}, {0xf8a80cb7, 0x000015bc}, 
{0xf8820cf9, 0x0000162c}, {0xf85c0d3a, 0x0000169d}, 
{0xf8360d7c, 0x0000170d}, {0xf8100dbe, 0x0000177d}, 
{0xf7ea0e00, 0x000017ee}, {0xf7c40e41, 0x0000185e}, 
{0xf79e0e83, 0x000018cf}, {0xf7780ec5, 0x0000193f}, 
{0xf7520f07, 0x000019af}, {0xf72c0f49, 0x00001a20}, 
{0xf7060f8a, 0x00001a90}, {0xf6e00fcc, 0x00001b01}, 
{0xf6ba100e, 0x00001b71}, {0xf6941050, 0x00001be2}, 
{0xf66e1091, 0x00001c52}, {0xf64810d3, 0x00001cc2}, 
{0xf6221115, 0x00001d33}, {0xf5fc1157, 0x00001da3}, 
{0xf5d61198, 0x00001e14}, {0xf5b011da, 0x00001e84}, 
{0xf58a121c, 0x00001ef4}, {0xf564125e, 0x00001f65}, 
{0xf53e12a0, 0x00001fd5}, {0xf51812e1, 0x00002046}, 
{0xf4f21323, 0x000020b6}, {0xf4cc1365, 0x00002126}, 
{0xf4a613a7, 0x00002197}, {0xf48013e8, 0x00002207}, 
{0xf45a142a, 0x00002278}, {0xf434146c, 0x000022e8}, 
{0xf40e14ae, 0x00002359}, {0xf3e814ef, 0x000023c9}, 
{0xf3c21531, 0x00002439}, {0xf39c1573, 0x000024aa}, 
{0xf37615b5, 0x0000251a}, {0xf35015f6, 0x0000258b}, 
{0xf32a1638, 0x000025fb}, {0xf304167a, 0x0000266b}, 
{0xf2de16bc, 0x000026dc}, {0xf2b816fe, 0x0000274c}, 
{0xf292173f, 0x000027bd}, {0xf26c1781, 0x0000282d}, 
{0xf24617c3, 0x0000289d}, {0xf2201805, 0x0000290e}, 
{0xf1fa1846, 0x0000297e}, {0xf1d41888, 0x000029ef}, 
{0xf1ae18ca, 0x00002a5f}, {0xf188190c, 0x00002acf}, 
{0xf162194d, 0x00002b40}, {0xf13c198f, 0x00002bb0}, 
{0xf11619d1, 0x00002c21}, {0xf0f01a13, 0x00002c91}, 
{0xf0ca1a54, 0x00002d02}, {0xf0a41a96, 0x00002d72}, 
{0xf07e1ad8, 0x00002de2}, {0xf0581b1a, 0x00002e53}, 
{0xf0321b5c, 0x00002ec3}, {0xf00c1b9d, 0x00002f34}, 
{0xefe61bdf, 0x00002fa4}, {0xefc01c21, 0x00003014}, 
{0xef9a1c63, 0x00003085}, {0xef741ca4, 0x000030f5}, 
{0xef4e1ce6, 0x00003166}, {0xef281d28, 0x000031d6}, 
{0xef021d6a, 0x00003246}, {0xeedc1dab, 0x000032b7}, 
{0xeeb61ded, 0x00003327}, {0xee901e2f, 0x00003398}, 
{0xee6a1e71, 0x00003408}, {0xee441eb2, 0x00003479}, 
{0xee1e1ef4, 0x000034e9}, {0xedf81f36, 0x00003559}, 
{0xedd21f78, 0x000035ca}, {0xedac1fba, 0x0000363a}, 
{0xed861ffb, 0x000036ab}, {0xed60203d, 0x0000371b}, 
{0xed3a207f, 0x0000378b}, {0xed1420c1, 0x000037fc}, 
};
const struct YUV  GYUV[] = {
{0xffdb0040, 0xffffffd1}, {0xff9100c1, 0xffffff73}, 
{0xff460142, 0xffffff15}, {0xfefc01c3, 0xfffffeb7}, 
{0xfeb10245, 0xfffffe59}, {0xfe6702c6, 0xfffffdfa}, 
{0xfe1c0347, 0xfffffd9c}, {0xfdd203c8, 0xfffffd3e}, 
{0xfd880449, 0xfffffce0}, {0xfd3d04ca, 0xfffffc82}, 
{0xfcf3054b, 0xfffffc23}, {0xfca805cc, 0xfffffbc5}, 
{0xfc5e064e, 0xfffffb67}, {0xfc1306cf, 0xfffffb09}, 
{0xfbc90750, 0xfffffaaa}, {0xfb7e07d1, 0xfffffa4c}, 
{0xfb340852, 0xfffff9ee}, {0xfae908d3, 0xfffff990}, 
{0xfa9f0954, 0xfffff932}, {0xfa5409d5, 0xfffff8d3}, 
{0xfa0a0a57, 0xfffff875}, {0xf9bf0ad8, 0xfffff817}, 
{0xf9750b59, 0xfffff7b9}, {0xf92a0bda, 0xfffff75b}, 
{0xf8e00c5b, 0xfffff6fc}, {0xf8960cdc, 0xfffff69e}, 
{0xf84b0d5d, 0xfffff640}, {0xf8010dde, 0xfffff5e2}, 
{0xf7b60e60, 0xfffff584}, {0xf76c0ee1, 0xfffff525}, 
{0xf7210f62, 0xfffff4c7}, {0xf6d70fe3, 0xfffff469}, 
{0xf68c1064, 0xfffff40b}, {0xf64210e5, 0xfffff3ad}, 
{0xf5f71166, 0xfffff34e}, {0xf5ad11e7, 0xfffff2f0}, 
{0xf5621269, 0xfffff292}, {0xf51812ea, 0xfffff234}, 
{0xf4cd136b, 0xfffff1d6}, {0xf48313ec, 0xfffff177}, 
{0xf439146d, 0xfffff119}, {0xf3ee14ee, 0xfffff0bb}, 
{0xf3a4156f, 0xfffff05d}, {0xf35915f0, 0xffffeffe}, 
{0xf30f1672, 0xffffefa0}, {0xf2c416f3, 0xffffef42}, 
{0xf27a1774, 0xffffeee4}, {0xf22f17f5, 0xffffee86}, 
{0xf1e51876, 0xffffee27}, {0xf19a18f7, 0xffffedc9}, 
{0xf1501978, 0xffffed6b}, {0xf10519f9, 0xffffed0d}, 
{0xf0bb1a7b, 0xffffecaf}, {0xf0701afc, 0xffffec50}, 
{0xf0261b7d, 0xffffebf2}, {0xefdb1bfe, 0xffffeb94}, 
{0xef911c7f, 0xffffeb36}, {0xef471d00, 0xffffead8}, 
{0xeefc1d81, 0xffffea79}, {0xeeb21e02, 0xffffea1b}, 
{0xee671e84, 0xffffe9bd}, {0xee1d1f05, 0xffffe95f}, 
{0xedd21f86, 0xffffe901}, {0xed882007, 0xffffe8a2}, 
{0xed3d2088, 0xffffe844}, {0xecf32109, 0xffffe7e6}, 
{0xeca8218a, 0xffffe788}, {0xec5e220b, 0xffffe72a}, 
{0xec13228d, 0xffffe6cb}, {0xebc9230e, 0xffffe66d}, 
{0xeb7e238f, 0xffffe60f}, {0xeb342410, 0xffffe5b1}, 
{0xeaea2491, 0xffffe552}, {0xea9f2512, 0xffffe4f4}, 
{0xea552593, 0xffffe496}, {0xea0a2614, 0xffffe438}, 
{0xe9c02696, 0xffffe3da}, {0xe9752717, 0xffffe37b}, 
{0xe92b2798, 0xffffe31d}, {0xe8e02819, 0xffffe2bf}, 
{0xe896289a, 0xffffe261}, {0xe84b291b, 0xffffe203}, 
{0xe801299c, 0xffffe1a4}, {0xe7b62a1d, 0xffffe146}, 
{0xe76c2a9f, 0xffffe0e8}, {0xe7212b20, 0xffffe08a}, 
{0xe6d72ba1, 0xffffe02c}, {0xe68c2c22, 0xffffdfcd}, 
{0xe6422ca3, 0xffffdf6f}, {0xe5f82d24, 0xffffdf11}, 
{0xe5ad2da5, 0xffffdeb3}, {0xe5632e26, 0xffffde55}, 
{0xe5182ea8, 0xffffddf6}, {0xe4ce2f29, 0xffffdd98}, 
{0xe4832faa, 0xffffdd3a}, {0xe439302b, 0xffffdcdc}, 
{0xe3ee30ac, 0xffffdc7e}, {0xe3a4312d, 0xffffdc1f}, 
{0xe35931ae, 0xffffdbc1}, {0xe30f322f, 0xffffdb63}, 
{0xe2c432b1, 0xffffdb05}, {0xe27a3332, 0xffffdaa6}, 
{0xe22f33b3, 0xffffda48}, {0xe1e53434, 0xffffd9ea}, 
{0xe19b34b5, 0xffffd98c}, {0xe1503536, 0xffffd92e}, 
{0xe10635b7, 0xffffd8cf}, {0xe0bb3638, 0xffffd871}, 
{0xe07136ba, 0xffffd813}, {0xe026373b, 0xffffd7b5}, 
{0xdfdc37bc, 0xffffd757}, {0xdf91383d, 0xffffd6f8}, 
{0xdf4738be, 0xffffd69a}, {0xdefc393f, 0xffffd63c}, 
{0xdeb239c0, 0xffffd5de}, {0xde673a41, 0xffffd580}, 
{0xde1d3ac3, 0xffffd521}, {0xddd23b44, 0xffffd4c3}, 
{0xdd883bc5, 0xffffd465}, {0xdd3d3c46, 0xffffd407}, 
{0xdcf33cc7, 0xffffd3a9}, {0xdca93d48, 0xffffd34a}, 
{0xdc5e3dc9, 0xffffd2ec}, {0xdc143e4a, 0xffffd28e}, 
{0xdbc93ecc, 0xffffd230}, {0xdb7f3f4d, 0xffffd1d2}, 
{0xdb343fce, 0xffffd173}, {0xdaea404f, 0xffffd115}, 
};
const struct YUV  BYUV[] = {
{0x0038000c, 0xfffffff7}, {0x00a80025, 0xffffffe5}, 
{0x0119003e, 0xffffffd3}, {0x01890057, 0xffffffc1}, 
{0x01fa0070, 0xffffffaf}, {0x026a0089, 0xffffff9c}, 
{0x02da00a2, 0xffffff8a}, {0x034b00bb, 0xffffff78}, 
{0x03bb00d5, 0xffffff66}, {0x042c00ee, 0xffffff54}, 
{0x049c0107, 0xffffff41}, {0x050d0120, 0xffffff2f}, 
{0x057d0139, 0xffffff1d}, {0x05ee0152, 0xffffff0b}, 
{0x065e016b, 0xfffffef9}, {0x06cf0184, 0xfffffee6}, 
{0x073f019d, 0xfffffed4}, {0x07b001b6, 0xfffffec2}, 
{0x082001cf, 0xfffffeb0}, {0x089001e8, 0xfffffe9e}, 
{0x09010201, 0xfffffe8b}, {0x0971021a, 0xfffffe79}, 
{0x09e20233, 0xfffffe67}, {0x0a52024c, 0xfffffe55}, 
{0x0ac30266, 0xfffffe43}, {0x0b33027f, 0xfffffe30}, 
{0x0ba40298, 0xfffffe1e}, {0x0c1402b1, 0xfffffe0c}, 
{0x0c8502ca, 0xfffffdfa}, {0x0cf502e3, 0xfffffde8}, 
{0x0d6602fc, 0xfffffdd5}, {0x0dd60315, 0xfffffdc3}, 
{0x0e46032e, 0xfffffdb1}, {0x0eb70347, 0xfffffd9f}, 
{0x0f270360, 0xfffffd8c}, {0x0f980379, 0xfffffd7a}, 
{0x10080392, 0xfffffd68}, {0x107903ab, 0xfffffd56}, 
{0x10e903c4, 0xfffffd44}, {0x115a03dd, 0xfffffd31}, 
{0x11ca03f7, 0xfffffd1f}, {0x123b0410, 0xfffffd0d}, 
{0x12ab0429, 0xfffffcfb}, {0x131c0442, 0xfffffce9}, 
{0x138c045b, 0xfffffcd6}, {0x13fc0474, 0xfffffcc4}, 
{0x146d048d, 0xfffffcb2}, {0x14dd04a6, 0xfffffca0}, 
{0x154e04bf, 0xfffffc8e}, {0x15be04d8, 0xfffffc7b}, 
{0x162f04f1, 0xfffffc69}, {0x169f050a, 0xfffffc57}, 
{0x17100523, 0xfffffc45}, {0x1780053c, 0xfffffc33}, 
{0x17f10555, 0xfffffc20}, {0x1861056e, 0xfffffc0e}, 
{0x18d20588, 0xfffffbfc}, {0x194205a1, 0xfffffbea}, 
{0x19b205ba, 0xfffffbd8}, {0x1a2305d3, 0xfffffbc5}, 
{0x1a9305ec, 0xfffffbb3}, {0x1b040605, 0xfffffba1}, 
{0x1b74061e, 0xfffffb8f}, {0x1be50637, 0xfffffb7d}, 
{0x1c550650, 0xfffffb6a}, {0x1cc60669, 0xfffffb58}, 
{0x1d360682, 0xfffffb46}, {0x1da7069b, 0xfffffb34}, 
{0x1e1706b4, 0xfffffb22}, {0x1e8806cd, 0xfffffb0f}, 
{0x1ef806e6, 0xfffffafd}, {0x1f6806ff, 0xfffffaeb}, 
{0x1fd90719, 0xfffffad9}, {0x20490732, 0xfffffac7}, 
{0x20ba074b, 0xfffffab4}, {0x212a0764, 0xfffffaa2}, 
{0x219b077d, 0xfffffa90}, {0x220b0796, 0xfffffa7e}, 
{0x227c07af, 0xfffffa6c}, {0x22ec07c8, 0xfffffa59}, 
{0x235d07e1, 0xfffffa47}, {0x23cd07fa, 0xfffffa35}, 
{0x243e0813, 0xfffffa23}, {0x24ae082c, 0xfffffa11}, 
{0x251e0845, 0xfffff9fe}, {0x258f085e, 0xfffff9ec}, 
{0x25ff0877, 0xfffff9da}, {0x26700890, 0xfffff9c8}, 
{0x26e008aa, 0xfffff9b6}, {0x275108c3, 0xfffff9a3}, 
{0x27c108dc, 0xfffff991}, {0x283208f5, 0xfffff97f}, 
{0x28a2090e, 0xfffff96d}, {0x29130927, 0xfffff95b}, 
{0x29830940, 0xfffff948}, {0x29f40959, 0xfffff936}, 
{0x2a640972, 0xfffff924}, {0x2ad4098b, 0xfffff912}, 
{0x2b4509a4, 0xfffff8ff}, {0x2bb509bd, 0xfffff8ed}, 
{0x2c2609d6, 0xfffff8db}, {0x2c9609ef, 0xfffff8c9}, 
{0x2d070a08, 0xfffff8b7}, {0x2d770a21, 0xfffff8a4}, 
{0x2de80a3b, 0xfffff892}, {0x2e580a54, 0xfffff880}, 
{0x2ec90a6d, 0xfffff86e}, {0x2f390a86, 0xfffff85c}, 
{0x2faa0a9f, 0xfffff849}, {0x301a0ab8, 0xfffff837}, 
{0x308a0ad1, 0xfffff825}, {0x30fb0aea, 0xfffff813}, 
{0x316b0b03, 0xfffff801}, {0x31dc0b1c, 0xfffff7ee}, 
{0x324c0b35, 0xfffff7dc}, {0x32bd0b4e, 0xfffff7ca}, 
{0x332d0b67, 0xfffff7b8}, {0x339e0b80, 0xfffff7a6}, 
{0x340e0b99, 0xfffff793}, {0x347f0bb2, 0xfffff781}, 
{0x34ef0bcc, 0xfffff76f}, {0x35600be5, 0xfffff75d}, 
{0x35d00bfe, 0xfffff74b}, {0x36400c17, 0xfffff738}, 
{0x36b10c30, 0xfffff726}, {0x37210c49, 0xfffff714}, 
{0x37920c62, 0xfffff702}, {0x38020c7b, 0xfffff6f0}, 
};

#define COEF_WIDTH   8
#define SHIFT_WIDTH  COEF_WIDTH

//
// All of the RGB converters follow the template given below. The converters make
// some assumptions about the frame size. All output frame sizes are assumed to
// have a frame height that is a multiple of 48. Also, the output frame width
// is assumed to be a multiple of 8. If the input frame size is equal
// to the output frame size, no stretching or cropping is done. Otherwise, the
// image is cropped and stretched for an 11:12 aspect ratio.
//

#if 0
void rgb_color_converter() {
	for (j = 0; j < LumaIters; j++) {
		for (k = 0; k < mark; k++) {
			for (i = FrameWidth; i > 0; i -= m, pnext += n) {
				compute m Y values using look-up tables
				if (0 == (k&1)) {
					compute m/2 U,V values using look-up tables
				}
			}
			if ((0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8 {
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
					t = *pyprev++ & 0xFEFEFEFE;
					t += *pynext++ & 0xFEFEFEFE;
					*pyspace++ = t;
				}
			}
			pnext += iBackTwoLines;
			py += ypitch_adj;
			if (0 == (k&1)) {
				pu += uvpitch_adj;
				pv += uvpitch_adj;
			}
		}
		if (stretch) {
			pyprev = py - pitch;
			pyspace = py;
			pynext = py + pitch;
		}
	}
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4 {
			*pyspace++ = *pyprev++;
		}
	}
}
#endif

//
// For the IA versions, the strategy is to compute the Y value for an odd RGB value
// followed by computing the Y value for the corresponding even RGB value. The registers
// are then set with the proper values to compute U and V values for the even RGB
// value. This avoids repeating the shifting and masking needed to extract the Red,
// Green and Blue components.
//

/*****************************************************************************
 *
 *  H26X_BGR24toYUV12()
 * 	
 *  Convert from BGR24 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH. The input data is stored in 
 *  the order B,G,R,B,G,R...
 *
 */
#if defined(_CODEC_STATS)
#define NOC_SHIFT_WIDTH 7
void NOC_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int height_adj, width_adj;
	int LumaIters = 0;
	int ypitch_adj = 0;
	int uvpitch_adj = 0;

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	width_adj += (width_adj << 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 2);
	iBackTwoLines += (iBackTwoLines << 1);

	// Point to the beginning of the last line.
	pnext =	(U32 *)
				(lpInput +
				((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
					((FrameHeight - aspect - 1) + height_adj)) +
				width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>23)+128);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>NOC_SHIFT_WIDTH)+128);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>23)+128);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>NOC_SHIFT_WIDTH)+128);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of NOC_H26X_BGR24toYUV12()
#endif

#if 0
_STATIC void C_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int height_adj, width_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	width_adj += (width_adj << 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 2);
	iBackTwoLines += (iBackTwoLines << 1);

	// Point to the beginning of the last line.
	pnext =	(U32 *)
				(lpInput +
				((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
					((FrameHeight - aspect - 1) + height_adj)) +
				width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 4, pnext += 3) {
				tm = pnext[0];
				t = BYUV[tm>>25].YU;
				tm = pnext[1];
				t += (GYUV[(tm>>1)&0x7F].YU +
				      RYUV[(tm>>9)&0x7F].YU);
				*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[0];
				t = (BYUV[(tm>>1)&0x7F].YU +
				     GYUV[(tm>>9)&0x7F].YU +
				     RYUV[(tm>>17)&0x7F].YU);
				*YPlane = (U8)((t>>SHIFT_WIDTH)+8);
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = (RYUV[(tm>>17)&0x7F].V +
					     GYUV[(tm>>9)&0x7F].V +
					     BYUV[(tm>>1)&0x7F].V);
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
				tm = pnext[2];
				t = (BYUV[(tm>>9)&0x7F].YU +
				     GYUV[(tm>>17)&0x7F].YU +
				     RYUV[tm>>25].YU);
				*(YPlane+3) = (U8)((t>>SHIFT_WIDTH)+8);
				tm = pnext[1];
				t = BYUV[(tm>>17)&0x7F].YU + GYUV[tm>>25].YU;
				tm = pnext[2];
				t += RYUV[(tm>>1)&0x7F].YU;
				*(YPlane+2) = (U8)((t>>SHIFT_WIDTH)+8);
				YPlane += 4;
				if (0 == (k&1)) {
					*UPlane++ = (U8)((t>>24)+64);
					t = RYUV[(tm>>1)&0x7F].V;
					tm = pnext[1];
					t += GYUV[tm>>25].V + BYUV[(tm>>17)&0x7F].V;
					*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR24toYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR24toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// width_adj += width_adj << 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	mov		eax, esi
	shr		eax, 1
	add		esi, eax
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -(lpbiInput->biWidth + FrameWidth)
// iBackTwoLines += (iBackTwoLines << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	neg		ebp
	mov		eax, ebp
	shl		eax, 1
	add		ebp, eax
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth + (lpbiInput->biWidth << 1)) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	add		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, pnext += 12)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts in the U pipe
	jmp		L6
L6:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t0 = pnext[0]
// t1 = pnext[1]
// t = ( BYUV[t0>>25].YU +
//       GYUV[(t1>> 1)&0x7F].YU +
//       RYUV[(t1>> 9)&0x7F].YU )
// *(YPlane+1) = ((t>>8)+8)
// t = ( BYUV[(t0>> 1)&0x7F].YU +
//       GYUV[(t0>> 9)&0x7F].YU +
//       RYUV[(t0>>17)&0x7F].YU )
// *YPlane = ((t>>8)+8)
// assign(eax: B2,Y1,Y2,U)
// assign(ebx: B1,V)
// assign(ecx: G2,G1)
// assign(edx: R2,R1)
// assign(ebp: B1)

// 1
	mov 	eax, [esi]
	mov		ecx, [esi + 4]
// 2
	mov 	ebx, eax
	mov 	edx, ecx
// 3
	shr 	eax, 25
	and 	ecx, 0xFE
// 4
	shr 	ecx, 1
	and 	edx, 0xFE00
// 5
	shr 	edx, 9
		and		ebx, 0xFEFEFE
// 6
	mov 	eax, [BYUV+eax*8].YU
	nop
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov		ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov		edx,  ebx
// 9
		and 	ebx, 0xFE
	add	eax,  0x800
// 10
	sar 	eax, 8
	nop
// 11
		shr 	ebx, 1
		nop
// 12
		shr 	ecx, 9
	mov	 [edi + 1], al
// 13
		shr		edx, 17
		and		ecx, 0x7F
// 14
		mov		eax, [BYUV+ebx*8].YU
		and		edx, 0x7F
// 15
		add	 	eax, [GYUV+ecx*8].YU
		mov		ebp, ebx
// 16
		add		eax, [RYUV+edx*8].YU
		nop
// 17
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 18
		add		eax, 8
		and		ebx, 1
// 19
		mov 	[edi], al
		jnz		L9

// At this point, ebp: B1, ecx: G1, edx: R1
// t0 = pnext[0]
// *UPlane++   = ((t>>24)+64)
// t   = ( RYUV[(t0>>17)&0x7F].V +
//         GYUV[(t0>> 9)&0x7F].V +
//         BYUV[(t0>> 1)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 20
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 21
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 22
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 23
	mov		[edx], al
	inc		edx
// 24
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 25
	sar 	ebx, 8
	inc		edx
// 26
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 27
	mov		[edx - 1], bl
	nop

L9:
//  ---------------------
//  | B2 | R1 | G1 | B1 | pnext[0]
//  ---------------------
//  | G3 | B3 | R2 | G2 | pnext[1]
//  ---------------------
//  | R4 | G4 | B4 | R3 | pnext[2]
//  ---------------------

// t1 = pnext[1]
// t2 = pnext[2]
// t = ( BYUV[(t2>> 9)&0x7F].YU +
//       GYUV[(t2>>17)&0x7F].YU +
//       RYUV[t2>>25].YR )
// *(YPlane+3) = ((t>>8)+8)
// t = ( BYUV[(t1>>17)&0x7F].YU +
//       GYUV[t1>>25].YU +
//       RYUV[(t2>> 1)&0x7F].YU )
// *(YPlane+2) = ((t>>8)+8)
// YPlane += 4
// assign(eax: B4,Y3,Y4,U)
// assign(ebx: R3,V)
// assign(ecx: G4,G3)
// assign(edx: R4/B3)
// assign(ebp: R3)

// 28
	mov		ebp, [esi + 4]
	mov 	ebx, [esi + 8]
// 29
	mov 	eax, ebx
	mov 	ecx, ebx
// 30
	shr		eax, 9
	mov		edx, ebx
// 31
	shr 	ecx, 17
	and 	eax, 0x7F
// 32
	shr 	edx, 25
	and		ecx, 0x7F
// 33
	mov 	eax, [BYUV+eax*8].YU
	nop
// 34
	add 	eax, [GYUV+ecx*8].YU
		and		ebx, 0xFE
// 35
	add 	eax, [RYUV+edx*8].YU
		mov		ecx, ebp
// 36
		shr		ebx, 1
	add	eax,  0x800
// 37
	sar 	eax, 8
		mov		edx, ebp
// 38
		shr		edx, 17
	mov	 [edi + 3], al
// 39
		shr 	ecx, 25
		and		edx, 0x7F
// 40
		mov		eax, [RYUV+ebx*8].YU
		mov		ebp, ebx
// 41
		add	 	eax, [GYUV+ecx*8].YU
		nop
// 42
		add		eax, [BYUV+edx*8].YU
		nop
// 43
		sar		eax, 8
		mov 	ebx, [esp + LOOP_K]
// 44
		add		eax, 8
		and		ebx, 1
// 45
		mov 	[edi + 2], al
		jnz		L16

// At this point, ebp: R3, ecx: G3, edx: B3
// t1 = pnext[1]
// t2 = pnext[2]
// *UPlane++   = ((t>>16)+64)
// t   = ( RYUV[(t2>> 1)&0x7F].V +
//         GYUV[t1>>25].V +
//         BYUV[(t1>>17)&0x7F].V )
// *VPlane++ = ((t>>8)+64)

// 46
	mov 	ebx, [BYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 47
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 48
	add		eax, 64
	add 	ebx, [RYUV+ebp*8].V
// 49
	mov		[edx], al
	inc		edx
// 50
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 51
	sar 	ebx, 8
	inc		edx
// 52
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 53
	mov		[edx - 1], bl
	nop
L16:
// 54
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 12]
// 55
	sub		eax, 4
	lea		edi, [edi + 4]
// 56
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L21
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L21
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L21

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L22:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L22
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L21:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L23
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L23:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L24
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L24:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L26

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L25:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L25
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L26:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

#if defined(_CODEC_STATS)
#define NOC_SHIFT_WIDTH  7
void NOC_H26X_BGR16toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int LumaIters = 0;
	int ypitch_adj = 0;
	int uvpitch_adj = 0;

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;

	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 1);

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj)) +
					 width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 2, pnext++) {

				tm = *pnext;
				//    555              2, 3, 8         0x7C, 0x7C, 0x7C
				t = (BYUV[(tm>>14)&0x7C].YU +
					 GYUV[(tm>>19)&0x7C].YU +
					 RYUV[(tm>>24)&0x7C].YU);
				*(YPlane+1) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				t = (BYUV[(tm<<2)&0x7C].YU +
					 GYUV[(tm>>3)&0x7C].YU +
					 RYUV[(tm>>8)&0x7C].YU);
				*(YPlane) = (U8)((t>>NOC_SHIFT_WIDTH)+16);
				YPlane += 2;
				if (0 == (k&1)) {
					//    555              2, 3, 8         0x7C, 0x7C, 0x7C
					*UPlane++ = (U8)((t>>23)+128);
					t = (RYUV[(tm>>8)&0x7C].V +
						 GYUV[(tm>>3)&0x7C].V +
						 BYUV[(tm<<2)&0x7C].V);
					*VPlane++ = (U8)((t>>NOC_SHIFT_WIDTH)+128);
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of NOC_H26X_BGR16toYUV12
#endif

#if 0
_STATIC void C_H26X_BGR16toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	UN  bitfield,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm;
	int t;
	int i, j, k;
	int iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int LumaIters = 0;
	int ypitch_adj = pitch - FrameWidth;
	int uvpitch_adj = pitch - (FrameWidth >> 1);

	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;

	// The input image is upside down - process the lines in reverse order.

	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) >> 1);

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj)) +
					 width_adj);

	for ( j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 2, pnext++) {

				tm = *pnext;
				switch (bitfield) {
					//    555              2, 3, 8         0x7C, 0x7C, 0x7C
					case 555:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>24)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>8)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#if 0
// Beware - untested code ahead				
					//    664              3, 3, 9         0x78, 0x7E, 0x7E
					case 664:
						t = (BYUV[(tm>>13)&0x78].YU +
						     GYUV[(tm>>19)&0x7E].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<3)&0x78].YU +
						     GYUV[(tm>>3)&0x7E].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    565              2, 4, 9         0x7C, 0x7E, 0x7C
					case 565:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>20)&0x7E].YU +
						     RYUV[(tm>>25)&0x7C].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>4)&0x7E].YU +
						     RYUV[(tm>>9)&0x7C].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
					//    655              2, 3, 9         0x7C, 0x7C, 0x7E
					case 655:
						t = (BYUV[(tm>>14)&0x7C].YU +
						     GYUV[(tm>>19)&0x7C].YU +
						     RYUV[(tm>>25)&0x7E].YU);
						*(YPlane+1) = (U8)((t>>SHIFT_WIDTH)+8);
						t = (BYUV[(tm<<2)&0x7C].YU +
						     GYUV[(tm>>3)&0x7C].YU +
						     RYUV[(tm>>9)&0x7E].YU);
						*(YPlane) = (U8)((t>>SHIFT_WIDTH)+8);
						YPlane += 2;
						break;
#endif
				}
				if (0 == (k&1)) {
					switch (bitfield) {
						//    555              2, 3, 8         0x7C, 0x7C, 0x7C
						case 555:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>8)&0x7C].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#if 0
// Beware - untested code ahead				
						//    664              3, 3, 9         0x78, 0x7E, 0x7E
						case 664:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7E].V +
							     BYUV[(tm<<3)&0x78].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    565              2, 4, 9         0x7C, 0x7E, 0x7C
						case 565:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7C].V +
							     GYUV[(tm>>4)&0x7E].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
						//    655              2, 3, 9         0x7C, 0x7C, 0x7E
						case 655:
							*UPlane++ = (U8)((t>>24)+64);
							t = (RYUV[(tm>>9)&0x7E].V +
							     GYUV[(tm>>3)&0x7C].V +
							     BYUV[(tm<<2)&0x7C].V);
							*VPlane++ = (U8)((t>>SHIFT_WIDTH)+64);
							break;
#endif
					}
				}
			}
			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		} // end of for k
		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	} // end of for j
	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of C_H26X_BGR16toYUV12
#endif

__declspec(naked)
_STATIC void IA_H26X_BGR16555toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| i				|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define LOOP_I				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 4)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// tm = pnext[0]
// t = ( BYUV[(tm>>14)&0x7C].YU +
//       GYUV[(tm>>19)&0x7C].YU +
//       RYUV[(tm>>24)&0x7C].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// t = ( BYUV[(tm<< 2)&0x7C].YU +
//       GYUV[(tm>> 8)&0x7C].YU +
//       RYUV[(tm>>13)&0x7C].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// assign(eax: B2/Y1/Y2/U)
// assign(ebx: B1/V)
// assign(ecx: G2/G1)
// assign(edx: R2/R1)
// assign(ebp: B1)
// 1
	mov 	eax, [esi]
	nop
// 2
	mov 	ebx, eax
	mov 	ecx, eax
// 3
	shr 	eax, 14
	mov 	edx, ebx
// 4
	shr 	ecx, 19
	and 	eax, 0x7C
// 5
	shr 	edx, 24
	and 	ecx, 0x7C
// 6
	mov 	eax, [BYUV+eax*8].YU
	and 	edx, 0x7C
// 7
	add 	eax, [GYUV+ecx*8].YU
		mov	ecx,  ebx
// 8
	add 	eax, [RYUV+edx*8].YU
		mov	edx,  ebx
// 9
	sar 	eax, 8
		and	ebx,  0x1F
// 10
		shl 	ebx, 2
	add 	eax, 8
// 11
		shr 	ecx, 3
	mov	 	[edi + 1], al
// 12
		shr 	edx, 8
		and 	ecx, 0x7C
// 13
		mov	 	eax, [BYUV+ebx*8].YU
		and	 	edx, 0x7C
// 14
		add	 	eax, [GYUV+ecx*8].YU
		mov	 	ebp, ebx
// 15
		add	 	eax, [RYUV+edx*8].YU
		nop
// 16
		sar	 	eax, 8
		mov 	ebx, [esp + LOOP_K]
// 17
		add	 	eax, 8
		and		ebx, 1
// 18
		mov 	[edi], al
		jnz 	L9

// At this point, ebp: B1, ecx: G1, edx: R1
// *UPlane++   = (U8)((t>>24)+64)
// t   = ( VBGR[(t>>13)&0x7C].VR +
//         VBGR[(t>> 8)&0x7C].VG +
//         VBGR[(t<< 2)&0x7C].VB )
// *VPlane++ = (U8)((t>>8)+64)
// 19
	mov 	ebx, [RYUV+edx*8].V
	mov 	edx, [esp + UPLANE]
// 20
	sar		eax, 16
	add 	ebx, [GYUV+ecx*8].V
// 21
	add		eax, 64
	add 	ebx, [BYUV+ebp*8].V
// 22
	mov		[edx], al
	inc		edx
// 23
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 24
	sar 	ebx, 8
	inc		edx
// 25
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 26
	mov		[edx - 1], bl
	nop
L9:
// 27
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 4]
// 28
	sub		eax, 2
	lea		edi, [edi + 2]
// 29
	mov		[esp + LOOP_I], eax
	jnz		L6

// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*****************************************************************************
 *
 *  H26X_CLUTtoYUV12()
 * 	
 *  Convert from CLUT8/CLUT4 to YUV12 (YCrCb 4:2:0) and copy to destination memory 
 *  with pitch defined by the constant PITCH.
 *
 *	This is needed to support the quickcam.
 */

#if 0
_STATIC void C_H26X_CLUTtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
    U8 * lpInput,
    U8 * YPlane,
    U8 * UPlane,
    U8 * VPlane,
    UN  FrameWidth,
    UN  FrameHeight,
	UN	pixel_bits,
	const int pitch)
{
	U32 *pnext, *pyprev, *pyspace, *pynext;
	U32 tm, tn;
	int t;
	int i, j, k, m, n;
	int iNextLine, iBackTwoLines;
	int stretch, mark, aspect;
	int width_adj, height_adj;
	int yshift, uvshift;
	int pixel_mask, loop_cnt, loop_limit;
	RGBQUAD *lpCEntry, *lpCTable = (RGBQUAD *)((U8 *)lpbiInput + sizeof(BITMAPINFOHEADER));
	int LumaIters = 0;
	int ypitch_adj = (pitch - FrameWidth);
	int uvpitch_adj = (pitch - (FrameWidth >> 1));

	ASSERT((8 == pixel_bits) || (4 == pixel_bits));
	// This loop is here simply to avoid a divide. LumaIters = (FrameHeight/12).
	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1);
	aspect = (width_adj ? LumaIters : 0);
	height_adj = ((lpbiInput->biHeight - (FrameHeight - aspect)) >> 1);
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = lpbiInput->biWidth;
	iBackTwoLines = -((iNextLine + (int)FrameWidth) >> 2);
	if (8 == pixel_bits) {
		yshift = 8;
		uvshift = 16;
		pixel_mask = 0xFF;
		loop_cnt = 2;
		loop_limit = 4;
	} else {
		yshift = 4;
		uvshift = 8;
		pixel_mask = 0xF;
		loop_cnt = 1;
		loop_limit = 8;
		width_adj >>= 1;
		iNextLine >>= 1;
		iBackTwoLines >>= 1;
	}

	// The input image is upside down - process the lines in reverse order.

	// Point to the beginning of the last line.
	pnext = (U32 *)(lpInput +
					(iNextLine * ((FrameHeight - aspect - 1) + height_adj)) + width_adj);

	for (j = 0; j < LumaIters; j++) {

		for (k = 0; k < mark; k++) {

			for (i = FrameWidth; i > 0; i -= 8) {

				for (n = 0; n < loop_cnt; n++) {
					tm = *pnext++;
					tm = ((4 == pixel_bits) ?
						( ((tm >> 4) & 0x0F0F0F0F) | ((tm << 4) & 0xF0F0F0F0) ) : tm);
					tn = tm;
					for (m = 0; m < loop_limit; m += 4) {
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
						lpCEntry = &lpCTable[tm&pixel_mask];
						t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
							  GYUV[lpCEntry->rgbGreen>>1].YU +
							  RYUV[lpCEntry->rgbRed>>1].YU );
						*YPlane++ = (U8)((t>>8)+8);
						tm >>= yshift;
					}
					if (0 == (k&1)) {
						for (m = 0; m < loop_limit; m += 2, tn >>= uvshift) {
							lpCEntry = &lpCTable[tn&pixel_mask];
							t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
								  RYUV[lpCEntry->rgbRed>>1].YU +
								  GYUV[lpCEntry->rgbGreen>>1].YU );
							*UPlane++ = (U8)((t>>24)+64);
							t = ( RYUV[lpCEntry->rgbRed>>1].V +
								  GYUV[lpCEntry->rgbGreen>>1].V +
								  BYUV[lpCEntry->rgbBlue>>1].V );
							*VPlane++ = (U8)((t>>8)+64);
						}
					}
				}
			}

			if (stretch && (0 == k) && j) {
				for (i = FrameWidth; i > 0; i -= 8) {
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
					tm = ((*pyprev++ & 0xFEFEFEFE) >> 1);
					tm += ((*pynext++ & 0xFEFEFEFE) >> 1);
					*pyspace++ = tm;
				}
			}

			pnext += iBackTwoLines;

			YPlane += ypitch_adj;
			// Increment after even lines.
			if(0 == (k&1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}

		if (stretch) {
			pyprev = (U32 *)(YPlane - pitch);
			pyspace = (U32 *)YPlane;
			pynext = (U32 *)(YPlane += pitch);
		}
	}

	if (stretch) {
		for (i = FrameWidth; i > 0; i -= 4) {
			*pyspace++ = *pyprev++;
		}
	}
} // end of H26X_CLUTtoYUV12()
#endif

__declspec(naked)
_STATIC void IA_H26X_CLUT8toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 1
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 1
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
// iBackTwoLines = -(iNextline + FrameWidth)
	mov		edi, [esp + FRAME_WIDTH]
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput +
//            (iNextLine*((FrameHeight-aspect-1) + height_adj)) +
//            width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext += 2)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*(pnext+1)]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[*pnext]
// t = (  BYUV[lpCEntry->rgbBlue>>1].YU +
//        GYUV[lpCEntry->rgbGreen>>1].YU +
//        RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>>24)+64)
// t = (  VBGR[lpCEntry->rgbRed>>1].V +
//        VBGR[lpCEntry->rgbGreen>>1].V +
//        VBGR[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	xor		eax, eax
	mov		ebp, [esp + LPCTABLE]
// 2
	mov		al, [esi + 1]
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
		xor		ebx, ebx
// 9
	add		eax, [RYUV+edx*4].YU
		mov		bl, [esi]
// 10
	sar		eax, 8
		lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
		mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
		mov		cl, (LPRGBQUAD)[ebp].rgbGreen
		and		bl, 0xFE
// 14
		mov		dl, (LPRGBQUAD)[ebp].rgbRed
		and		cl, 0xFE
// 15
		mov		eax, [BYUV+ebx*4].YU
		and		dl, 0xFE
// 16
		add		eax, [GYUV+ecx*4].YU
		mov		ebp, ebx
// 17
		add		eax, [RYUV+edx*4].YU
		nop
// 18
		sar		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
		add		eax, 8
	and		ebx, 1
// 20
		mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 29
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 2]
// 30
	sub		eax, 2
	lea		edi, [edi + 2]
// 31
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill (esi, pnext)
// kill (edi, YPlane)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
	 mov	edi, [esp + PYSPACE]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

__declspec(naked)
_STATIC void IA_H26X_CLUT4toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * lpInput,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  +100 
//	| FrameHeight	|  + 96
//	| FrameWidth	|  + 92
//	| VPlane		|  + 88
//	| UPlane		|  + 84 
//	| YPlane		|  + 80 
//	| lpInput		|  + 76 
//	| lpbiInput		|  + 72 
//	----------------------------
//	| return addr	|  + 68
//	| saved ebp		|  + 64
//	| saved ebx		|  + 60
//	| saved esi		|  + 56 
//	| saved edi		|  + 52

//	| pyprev		|  + 48
//	| pyspace		|  + 44
//	| pynext		|  + 40
//	| i				|  + 36
//	| j				|  + 32
//	| k				|  + 28
//	| iBackTwoLines	|  + 24
//	| stretch		|  + 20
//	| mark			|  + 16
//	| lpCEntry		|  + 12
//	| lpCTable		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 52

#define PITCH_PARM			100
#define FRAME_HEIGHT		 96
#define FRAME_WIDTH			 92
#define VPLANE				 88
#define UPLANE				 84
#define YPLANE				 80
#define LP_INPUT			 76
#define LPBI_INPUT			 72

#define PYPREV				 48
#define PYSPACE				 44
#define PYNEXT				 40
#define LOOP_I				 36	
#define LOOP_J				 32	
#define LOOP_K				 28
#define BACK_TWO_LINES		 24
#define STRETCH				 20
#define MARK				 16
#define LUMA_ITERS			 12
#define LPCTABLE			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push 	ebx
	push 	esi
	push 	edi
	sub 	esp, LOCALSIZE

// lpCTable = lpbiInput + sizeof(BITMAPINFOHEADER)
// assign (ebx, lpbiInput)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, eax
	add		eax, TYPE BITMAPINFOHEADER
	mov		[esp + LPCTABLE], eax
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (ecx, FrameWidth)
// kill (edx, pitch)
	shr		ecx, 1
	sub		edx, ecx
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (ecx, LumaIters)
	xor		ecx, ecx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		ecx, [ecx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = ((lpbiInput->biWidth - FrameWidth) >> 2
// assign (edx, width_adj)
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		edx, [esp + FRAME_WIDTH]
	shr		edx, 2
// aspect = (width_adj ? LumaIters : 0)
// assign (esi, aspect)
// kill (ecx, LumaIters)
	mov		[esp + LUMA_ITERS], ecx
	xor		esi, esi
	test	edx, edx
	jz		L2
	mov		esi, ecx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (ecx, height_adj)
L2:
	mov		ecx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		ecx, [esp + FRAME_HEIGHT]
	add		ecx, esi
	shr		ecx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	ecx, ecx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		edi, 12
	sub		edi, eax
	mov		[esp + MARK], edi
// iNextLine = lpbiInput->biWidth >> 1
// kill (ebx, lpbiInput)
// assign (ebx, iNextLine)
	mov		ebx, (LPBITMAPINFOHEADER)[ebx].biWidth
	shr		ebx, 1
// iBackTwoLines = -(iNextline + (FrameWidth >> 1))
	mov		edi, [esp + FRAME_WIDTH]
	shr		edi, 1
	add		edi, ebx
	neg		edi
	mov		[esp + BACK_TWO_LINES], edi
// pnext = lpInput+(iNextLine*((FrameHeight-aspect-1)+height_adj))+ width_adj
// kill (ebx, iNextLine)
// kill (ecx, height_adj)
// kill (edx, width_adj)
// kill (esi, aspect)
// assign (esi, pnext)
	mov		eax, [esp + FRAME_HEIGHT]
	sub		eax, esi
	dec		eax
	add		eax, ecx
	mov		esi, [esp + LP_INPUT]
	add		esi, edx
	imul	ebx
	add		esi, eax
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
// for (k = 0; k < mark; k++)
L4:
	xor		eax, eax
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 2, pnext++)
L5:
	mov		eax, [esp + FRAME_WIDTH]
	mov		[esp + LOOP_I], eax
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// lpCEntry = &lpCTable[*pnext&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *(YPlane+1) = (U8)((t>>8)+8)
// lpCEntry = &lpCTable[(*pnext>>4)&0xF]
// t = ( BYUV[lpCEntry->rgbBlue>>1].YU +
//       GYUV[lpCEntry->rgbGreen>>1].YU +
//       RYUV[lpCEntry->rgbRed>>1].YU )
// *YPlane = (U8)((t>>8)+8)
// YPlane += 2
// *UPlane++ = (U8)((t>24)+64)
// t = ( RYUV[lpCEntry->rgbRed>>1].V +
//       GYUV[lpCEntry->rgbGreen>>1].V +
//       BYUV[lpCEntry->rgbBlue>>1].V )
// *VPlane++ = (U8)((t>>8)+64)
// assign (ebp: lpCEntry,B1)
// assign (eax: P2,B2,Y2,Y1,U)
// assign (ebx: B1,V)
// assign (ecx: G2,G1)
// assign (edx: R2,R1)
// 1
	mov		al, [esi]
	mov		ebp, [esp + LPCTABLE]
// 2
	and		eax, 0xF
	xor		ecx, ecx
// 3
	lea		ebx, [ebp+eax*4]
	xor		edx, edx
// 4
	mov		al, (LPRGBQUAD)[ebx].rgbBlue
	nop
// 5
	mov		cl, (LPRGBQUAD)[ebx].rgbGreen
	and		al, 0xFE
// 6
	mov		dl, (LPRGBQUAD)[ebx].rgbRed
	and		cl, 0xFE
// 7
	mov		eax, [BYUV+eax*4].YU
	and		dl, 0xFE
// 8
	add		eax, [GYUV+ecx*4].YU
	mov		bl, [esi]
// 9
	add		eax, [RYUV+edx*4].YU
	and		ebx, 0xF0
//
	shr		ebx, 4
	nop
// 10
	shr		eax, 8
	lea		ebp, [ebp+ebx*4]
// 11
	add		eax, 8
	nop
// 12
	mov		[edi + 1], al
	mov		bl, (LPRGBQUAD)[ebp].rgbBlue
// 13
	mov		cl, (LPRGBQUAD)[ebp].rgbGreen
	and		bl, 0xFE
// 14
	mov		dl, (LPRGBQUAD)[ebp].rgbRed
	and		cl, 0xFE
// 15
	mov		eax, [BYUV+ebx*4].YU
	and		dl, 0xFE
// 16
	add		eax, [GYUV+ecx*4].YU
	mov		ebp, ebx
// 17
	add		eax, [RYUV+edx*4].YU
	nop
// 18
	shr		eax, 8
	mov		ebx, [esp + LOOP_K]
// 19
	add		eax, 8
	and		ebx, 1
// 20
	mov		[edi], al
	jnz		L9
// 21
	mov 	ebx, [RYUV+edx*4].V
	mov 	edx, [esp + UPLANE]
// 22
	sar		eax, 16
	add 	ebx, [GYUV+ecx*4].V
// 23
	add		eax, 64
	add 	ebx, [BYUV+ebp*4].V
// 24
	mov		[edx], al
	inc		edx
// 25
	mov 	[esp + UPLANE], edx
	mov 	edx, [esp + VPLANE]
// 26
	sar 	ebx, 8
	inc		edx
// 27
	add 	ebx, 64
	mov 	[esp + VPLANE], edx
// 28
	mov		[edx - 1], bl
	nop
L9:
// 32
	mov		eax, [esp + LOOP_I]
	lea		esi, [esi + 1]
// 33
	sub		eax, 2
	lea		edi, [edi + 2]
// 34
	mov		[esp + LOOP_I], eax
	jnz		L6

// only esi (pnext) is live at this point (after line loop)
// if (stretch && (0 == k) && j)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L14
	mov		eax, [esp + LOOP_K]
	test	eax, eax
	jnz		L14
	mov 	eax, [esp + LOOP_J]
	test	eax, eax
	jz		L14

// spill YPlane ptr
	mov		[esp + YPLANE], edi
	nop

// for (i = FrameWidth; i > 0; i -= 8)
// assign (ebx, pyprev)
// assign (ecx, t)
// assign (edx, pynext)
// assign (edi, pyspace)
// assign (ebp, i)

// make sure offsets are such that there are no bank conflicts here
	mov 	ebx, [esp + PYPREV]
	mov 	edi, [esp + PYSPACE]

	mov 	edx, [esp + PYNEXT]
	mov 	ebp, [esp + FRAME_WIDTH]

// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
// t = (*pyprev++ & 0xFEFEFEFE) >> 1
// t += (*pynext++ & 0xFEFEFEFE) >> 1
// *pyspace++ = t
L15:
// 1
	mov		eax, [ebx]
	lea		ebx, [ebx + 4]
// 2
	mov		ecx, [edx]
	lea		edx, [edx + 4]
// 3
	shr		ecx, 1
	and		eax, 0xFEFEFEFE
// 4
	shr		eax, 1
	and		ecx, 0x7F7F7F7F
// 5
	add		eax, ecx
	mov		ecx, [ebx]
// 6
	shr		ecx, 1
	mov		[edi], eax
// 7
	mov		eax, [edx]
	and		ecx, 0x7F7F7F7F
// 8
	shr		eax, 1
	lea		edi, [edi + 4]
// 9
	and		eax, 0x7F7F7F7F
	lea		ebx, [ebx + 4]
// 10
	lea		edx, [edx + 4]
	add		eax, ecx
// 11
	mov		[edi], eax
	lea		edi, [edi + 4]
// 12
	sub		ebp, 8
	jnz		L15
// kill (ebx, pyprev)
// kill (ecx, t)
// kill (edx, pynext)
// kill (edi, pyspace)
// kill (ebp, i)

// restore YPlane
	mov		edi, [esp + YPLANE]

// pnext += iBackTwoLines
L14:
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// if(0 == (k&1))
	mov		eax, [esp + LOOP_K]
	and		eax, 1
	jnz		L16
// UPlane += uvpitch_adj;
// VPlane += uvpitch_adj;
	mov		eax, [esp + UVPITCH_ADJ]
	add		[esp + UPLANE], eax
	add		[esp + VPLANE], eax

L16:
	inc		DWORD PTR [esp + LOOP_K]
	mov		eax, [esp + LOOP_K]
	cmp		eax, [esp + MARK]
	jl		L5

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	je	 	L17
// pyprev = YPlane - pitch
	mov		eax, edi
	sub		eax, [esp + PITCH_PARM]
	mov		[esp + PYPREV], eax
// pyspace = YPlane
	mov		[esp + PYSPACE], edi
// pynext = (YPlane += pitch)
	add		edi, [esp + PITCH_PARM]
	mov		[esp + PYNEXT], edi

L17:
	inc		DWORD PTR [esp + LOOP_J]
	mov		eax, [esp + LOOP_J]
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

// kill(esi, pnext)
// if (stretch)
	mov		esi, [esp + PYPREV]
	cmp		DWORD PTR [esp + STRETCH], 0
	je		L19

// for (i = FrameWidth; i > 0; i -= 4)
// assign (esi, pyprev)
// assign (edi, pyspace)
// assign (ebp, i)
	mov		edi, [esp + PYSPACE]
	 mov	ebp, [esp + FRAME_WIDTH]
L18:
	mov		ecx, [esi]
	 lea	esi, [esi + 4]
	mov		[edi], ecx
	 lea	edi, [edi + 4]
	sub		ebp, 4
	 jnz	L18
// kill (esi, pyprev)
// kill (edi, pyspace)
// kill (ebp, i)

L19:
	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef LOOP_I
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef LPCTABLE
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YVU9toYUV12()
 *  Convert from YVU9 to YUV12
 *  and copy to destination memory with pitch
 *  defined by the constant PITCH.
 *
 * uv_plane_common()
 *  Helper function to convert V and U plane information.
 *  Since the process is similar for both planes, the
 *  conversion code was included in this subroutine.
 *
 ***************************************************/	

#if 0
#define READ_DWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned int *)(src))), ((val) &= 0xFEFEFEFE), ((val) >>= 1))

#define READ_QWORD_AND_SHIFT(val,src) \
 (((val) = *((unsigned __int64 *)(src))), ((val) &= 0xFEFEFEFEFEFEFEFE), ((val) >>= 1))

#define WRITE_DWORD(dest,val) ((*(unsigned int *)(dest)) = (val))

#define WRITE_QWORD(dest,val) ((*(unsigned __int64 *)(dest)) = (val))

#define AVERAGE_DWORDS(out,in1,in2)  ((out) = ((((in1) + (in2)) & 0xFEFEFEFE) >> 1))

#define DUP_LOWER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = (((val) & 0x000000FF) |	(((val) << 8) & 0x0000FF00) | \
							  	(((val) << 8) & 0x00FF0000) | (((val) << 16) & 0xFF000000)))

#define DUP_UPPER_TWO_BYTES(dest,val) \
  (*((unsigned int *)(dest)) = ((((val) >> 16) & 0x000000FF) |	(((val) >> 8) & 0x0000FF00) | \
							  	(((val) >> 8) & 0x00FF0000) | ((val) & 0xFF000000)))


_STATIC void C_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj) {

U8* pnext = psrc + (OutputFrameWidth>>1) + spitch_adj;
U8* pdest_copy = Plane;
U8* pdest_avg = Plane + pitch;
int dpitch_adj = pitch - OutputFrameWidth;
int stretch = (spitch_adj ? 1 : 0);
int mark = 6 - stretch;
int flag = stretch;
int i, j, k;
UN t1,t2;

	for (j = ChromaIters; j > 0; j--) {
		for (k = mark + (flag & 1); k > 0; k--) {
			if (!stretch && (1 == j) && (1 == k)) {
				pnext = psrc;
			}
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_copy += 8,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				DUP_LOWER_TWO_BYTES(pdest_copy,t1);
				DUP_UPPER_TWO_BYTES((pdest_copy+4),t1);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
		}
		if (stretch) {
			psrc -= ((OutputFrameWidth>>1) + spitch_adj);
			pnext -= ((OutputFrameWidth>>1) + spitch_adj);
			pdest_avg = pdest_copy;
			for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4,
                                                      pnext += 4,
                                                      pdest_avg += 8) {
				READ_DWORD_AND_SHIFT(t1,psrc);
				READ_DWORD_AND_SHIFT(t2,pnext);
				AVERAGE_DWORDS(t1,t1,t2);
				AVERAGE_DWORDS(t1,t1,t2);
				DUP_LOWER_TWO_BYTES(pdest_avg,t1);
				DUP_UPPER_TWO_BYTES((pdest_avg+4),t1);
			}
			psrc += spitch_adj;
			pnext += spitch_adj;
			pdest_copy = pdest_avg + dpitch_adj;
			pdest_avg = pdest_copy + pitch;
			flag++;
		}
	}
}

_STATIC void C_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn;
U8  *pvsrc, *pusrc;
int width_adj, height_adj;
int stretch, mark, aspect;
int iNextLine;
int i, j, k, t;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);

	for (i = FrameHeight; i > 0; i -= 48) {
		LumaIters += 4;
	}
	width_adj = (lpbiInput->biWidth - FrameWidth) >> 1;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	iNextLine = width_adj << 1;
	pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj;
	for (j = LumaIters; j > 0; j--) {
		for (k = mark; k > 0; k--) {
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4) {
				*(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
			}
			pnext += iNextLine;
			YPlane += ypitch_adj;
		}
		if (stretch) {
			plast = pnext - lpbiInput->biWidth;
			pbn = pnext;
			for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, plast += 4, pbn += 4) {
				*(U32 *)YPlane =
					( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
				        ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}

	pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight);
	pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight>>2));
	t = ((lpbiInput->biWidth>>2) * (height_adj>>2)) + (width_adj>>2);
	pvsrc += t;
	pusrc += t;
	C_uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
	C_uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1);
}
#endif

__declspec(naked)
_STATIC void IA_uv_plane_common(
	U8 *psrc,
	U8 *Plane,
	UN pitch,
	UN OutputFrameWidth,
	UN ChromaIters,
	UN spitch_adj)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | spitch_adj      |  + 64
//    | ChromaIters     |  + 60
//    | OutputFrameWidth|  + 56
//    | pitch           |  + 52
//    | Plane           |  + 48
//    | psrc            |  + 44
//  -----------------------------
//    | return addr     |  + 40
//    | saved ebp       |  + 36
//    | saved ebx       |  + 32
//    | saved esi       |  + 28
//    | saved edi       |  + 24

//    | dpitch_adj      |  + 20
//    | stretch         |  + 16
//    | mark            |  + 12
//    | flag            |  +  8
//    | j               |  +  4
//    | k               |  +  0

#define LOCALSIZE           24

#define SPITCH_ADJ          64
#define CHROMA_ITERS        60
#define OUTPUT_FRAME_WIDTH  56
#define PITCH_PARM          52
#define PLANE               48
#define PSRC                44

#define DPITCH_ADJ          20
#define STRETCH             16
#define MARK                12
#define FLAG                 8
#define LOOP_J               4
#define LOOP_K               0

	_asm {

	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// pnext = psrc + (OuputFrameWidth>>1) + uvpitch_adj
// pdest_copy = Plane
// pdest_avg = Plane + pitch
// assign (esi, psrc)
// assign (ecx, pnext)
// assign (edi, pdest_copy)
// assign (edx, pdest_avg)
// assign (ebp, i)
	mov		esi, [esp + PSRC]
	mov		ecx, esi
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	add		ecx, eax
	mov		edi, [esp + PLANE]
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// dpitch_adj = pitch - OutputFrameWidth
	mov		eax, [esp + PITCH_PARM]
	sub		eax, [esp + OUTPUT_FRAME_WIDTH]
	mov		[esp + DPITCH_ADJ], eax
// stretch = (spitch_adj ? 1 : 0)
	xor		ebx, ebx
	mov		eax, [esp + SPITCH_ADJ]
	test	eax, eax
	jz		L1
	inc		ebx
L1:
	mov		[esp + STRETCH], ebx
// mark = 6 - stretch
	mov		eax, 6
	sub		eax, ebx
	mov		[esp + MARK], eax
// flag = stretch
	mov		DWORD PTR [esp + FLAG], ebx

// for (j = ChromaIters; j > 0; j--)
	mov		eax, [esp + CHROMA_ITERS]
	mov		[esp + LOOP_J], eax
L2:
// for (k = mark + (flag & 1); k > 0; k--)
	mov		eax, [esp + FLAG]
	and		eax, 1
	add		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
L3:
// if (!stretch && (0 == j) && (0 == k))
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jnz		L4
	mov		eax, [esp + LOOP_J]
	cmp		eax, 1
	jne		L4
	mov		eax, [esp + LOOP_K]
	cmp		eax, 1
	jne		L4
// pnext = psrc
	mov		ecx, esi
L4:
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4,
//                                           pdest_copy += 8, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L5:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_copy,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi], ebx
// DUP_UPPER_TWO_BYTES((pdest_copy+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edi+4], ebx
// READ_DWORD_AND_SHIFT(t2,pnext)
// AVERAGE_DWORDS(t1,t1,t2)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edi, [edi + 8]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L5

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + pitch_adj
// pdest_avg = pdest_copy + pitch
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
// end of k loop
	dec		DWORD PTR [esp + LOOP_K]
	jnz		L3

// if (stretch)
	cmp		DWORD PTR [esp + STRETCH], 0
	jz		L6

// psrc -= ((OutputFrameWidth>>1)+spitch_adj)
// pnext -= ((OutputFrameWidth>>1)+spitch_adj)
// pdest_avg = pdest_copy
	mov		eax, [esp + OUTPUT_FRAME_WIDTH]
	shr		eax, 1
	add		eax, [esp + SPITCH_ADJ]
	sub		esi, eax
	sub		ecx, eax
	mov		edx, edi
// for (i = OutputFrameWidth; i > 0; i -= 8, psrc += 4, pnext += 4, pdest_avg += 8)
	mov		ebp, [esp + OUTPUT_FRAME_WIDTH]
// Pentium pipeline scheduling has not been performed on the following loop code yet
L7:
// READ_DWORD_AND_SHIFT(t1,psrc)
	mov		eax, [esi]
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// READ_DWORD_AND_SHIFT(t2,pnext)
	mov		ebx, [ecx]
	and		ebx, 0xFEFEFEFE
	shr		ebx, 1
// AVERAGE_DWORDS(t1,t1,t2)
// AVERAGE_DWORDS(t1,t1,t2)
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
	add		eax, ebx
	and		eax, 0xFEFEFEFE
	shr		eax, 1
// DUP_LOWER_TWO_BYTES(pdest_avg,t1)
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx], ebx
// DUP_UPPER_TWO_BYTES((pdest_avg+4),t1)
	shr		eax, 16
	mov		bl, ah
	mov		bh, ah
	shl		ebx, 16
	mov		bl, al
	mov		bh, al
	mov		[edx+4], ebx
// end of i loop
	lea		esi, [esi + 4]
	lea		ecx, [ecx + 4]
	lea		edx, [edx + 8]
	sub		ebp, 8
	jnz		L7

// psrc += spitch_adj
// pnext += spitch_adj
// pdest_copy = pdest_avg + dpitch_adj
// pdest_avg = pdest_copy + pitch
// flag++
	add		esi, [esp + SPITCH_ADJ]
	add		ecx, [esp + SPITCH_ADJ]
	mov		eax, edx
	add		eax, [esp + DPITCH_ADJ]
	mov		edi, eax
	mov		edx, edi
	add		edx, [esp + PITCH_PARM]
	inc		DWORD PTR [esp + FLAG]

// end of j loop
L6:
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L2

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef SPITCH_ADJ
#undef CHROMA_ITERS
#undef OUTPUT_FRAME_WIDTH
#undef PITCH_PARM
#undef PLANE
#undef PSRC

#undef DPITCH_ADJ
#undef STRETCH
#undef MARK
#undef FLAG
#undef LOOP_J
#undef LOOP_K

__declspec(naked)
_STATIC void IA_H26X_YVU9toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)

{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 88
//    | FrameHeight     |  + 84
//    | FrameWidth      |  + 80
//    | VPlane          |  + 76
//    | UPlane          |  + 72
//    | YPlane          |  + 68
//    | lpInput         |  + 64
//    | lpbiInput       |  + 60
//  -----------------------------
//    | return addr     |  + 56
//    | saved ebp       |  + 52
//    | saved ebx       |  + 48
//    | saved esi       |  + 44
//    | saved edi       |  + 40

//    | width_adj       |  + 36
//    | height_adj      |  + 32
//    | stretch         |  + 28
//    | mark            |  + 24
//    | iNextLine       |  + 20
//    | j               |  + 16
//    | k               |  + 12
//    | LumaIters       |  +  8
//    | ypitch_adj      |  +  4
//    | uvpitch_adj     |  +  0

#define LOCALSIZE        40

#define PITCH_PARM       88
#define FRAME_HEIGHT     84
#define FRAME_WIDTH      80
#define VPLANE           76
#define UPLANE           72
#define YPLANE           68
#define LP_INPUT         64
#define LPBI_INPUT       60

#define WIDTH_ADJ        36
#define HEIGHT_ADJ       32
#define STRETCH          28
#define MARK             24
#define NEXT_LINE        20
#define LOOP_J           16
#define LOOP_K           12
#define LUMA_ITERS        8
#define YPITCH_ADJ        4
#define UVPITCH_ADJ       0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = (lpbiInput->biWidth - FrameWidth) >> 1
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
	shr		esi, 1
	mov		[esp + WIDTH_ADJ], esi
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
	mov		[esp + HEIGHT_ADJ], edx
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iNextLine = width_adj << 1
	mov		ebp, esi
	shl		ebp, 1
	mov		[esp + NEXT_LINE], ebp
// pnext = lpInput + (lpbiInput->biWidth * height_adj) + width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	mov		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
	mov		edi, [esp + YPLANE]
// for (j = LumaIters; j > 0; j--)
	mov		eax, [esp + LUMA_ITERS]
	mov		[esp + LOOP_J], eax
// for (k = mark; k > 0; k--)
L4:
	mov		eax, [esp + MARK]
	mov		[esp + LOOP_K], eax
// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
L5:
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here to make sure the following loop starts on the U pipe
	jmp		L6
L6:
// *(U32 *)YPlane = (*(U32 *)pnext & 0xFEFEFEFE) >> 1;
// 1
	mov		eax, [esi]
	lea		esi, [esi + 4]
// 2
	and		eax, 0xFEFEFEFE
	lea		edi, [edi + 4]
// 3
	shr		eax, 1
	sub		ebp, 4
// 4
	mov		[edi - 4], eax
	jnz		L6

// pnext += iNextLine
// YPlane += ypitch_adj
	add		esi, [esp + NEXT_LINE]
	add		edi, [esp + YPITCH_ADJ]

// end of k loop
	mov		eax, [esp + LOOP_K]
	sub		eax, 1
	mov		[esp + LOOP_K], eax
	jnz		L5

// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L7

// plast = pnext - lpbiInput->biWidth
// pn = pnext
// assign (ecx, plast)
// assign (edx, pn)
	mov		ecx, esi
	mov		eax, [esp + LPBI_INPUT]
	sub		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		edx, esi

// for (i = FrameWidth; i > 0; i -= 4, YPlane += 4, pnext += 4)
// assign (ebp, i)
	mov		ebp, [esp + FRAME_WIDTH]
// This jump is here just to make sure the loop code starts with the U pipe
	jmp		L8
L8:
// *(U32 *)YPlane =
//  ( ( ((*(U32 *)plast & 0xFEFEFEFE) >> 1) +
//      ((*(U32 *)pbn & 0xFEFEFEFE) >> 1) ) & 0xFEFEFEFE ) >> 1
// 1
	mov		eax, [ecx]
	lea		ecx, [ecx + 4]
// 2
	shr		eax, 1
// 3
	and		eax, 0x7F7F7F7F
	mov		ebx, [edx]
// 4
	shr		ebx, 1
	lea		edi, [edi + 4]
// 5
	and		ebx, 0x7F7F7F7F
// 6
	add		eax, ebx
// 7
	and		eax, 0xFEFEFEFE
// 8
	shr		eax, 1
// 9
	mov		[edi - 4], eax
	sub		ebp, 4
// 10
	lea		edx, [edx + 4]
	jnz		L8

// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]

L7:
// end of the LumaIters loop
	dec		DWORD PTR [esp + LOOP_J]
	jnz		L4

// pvsrc = lpInput + (lpbiInput->biWidth * lpbiInput->biHeight)
// assign (esi, pvsrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ebx, (LPBITMAPINFOHEADER)[eax].biWidth
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	imul	ebx
	add		eax, [esp + LP_INPUT]
	mov		esi, eax
// pusrc = pvsrc + ((lpbiInput->biWidth>>2) * (lpbiInput->biHeight)>>2)
// assign (edi, pusrc)
	mov		eax, [esp + LPBI_INPUT]
	mov		ecx, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		ecx, 2
	mov		eax, (LPBITMAPINFOHEADER)[eax].biHeight
	shr		eax, 2
	imul	ecx
	add		eax, esi
	mov		edi, eax
// t = ((lpbiInput->biWidth>>2) * (height>>2)) + (width_adj>>2)
// assign (eax, t)
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shr		eax, 2
	mov		ebx, [esp + HEIGHT_ADJ]
	shr		ebx, 2
	imul	ebx
	mov		ebx, [esp + WIDTH_ADJ]
	shr		ebx, 2
	add		eax, ebx
// pvsrc += t
// pusrc += t
	add		esi, eax
	add		edi, eax

// uv_plane_common(pusrc,UPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + UPLANE]
	push	edi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

// uv_plane_common(pvsrc,VPlane,pitch,FrameWidth>>1,LumaIters>>1,width_adj>>1)
	mov		ebp, esp
	mov		eax, [ebp + WIDTH_ADJ]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + LUMA_ITERS]
	shr		eax, 1
	push	eax
	mov		eax, [ebp + FRAME_WIDTH]
	shr		eax, 1
	push	eax
	push	DWORD PTR [ebp + PITCH_PARM]
	push	DWORD PTR [ebp + VPLANE]
	push	esi
	call	IA_uv_plane_common
	lea		esp, [esp + 24]

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef WIDTH_ADJ
#undef HEIGHT_ADJ
#undef STRETCH
#undef MARK
#undef NEXT_LINE
#undef LOOP_J
#undef LOOP_K
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/***************************************************
 * H26X_YUV12toEncYUV12()
 *  Copy YUV12 data to encoder memory at the
 *  appropriate location. It is assumed that the input
 *  data is stored as rows of Y, followed by rows of U,
 *  then rows of V.
 *
 ***************************************************/

#if 0
_STATIC void C_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

	int i, j;
	U32 *pnext = (U32 *)lpInput;

	int ypitch_adj = pitch - FrameWidth;
	int yinput_height = lpbiInput->biHeight;
	int yinput_width = lpbiInput->biWidth;
	int yheight_diff = FrameHeight - yinput_height;
	int ywidth_diff = FrameWidth - yinput_width;

	int uvpitch_adj = pitch - (FrameWidth >> 1);
	int uvoutput_width = FrameWidth >> 1;
	int uvinput_height = yinput_height >> 1;
	int uvinput_width = yinput_width >> 1;
	int uvheight_diff = yheight_diff >> 1;
	int uvwidth_diff = ywidth_diff >> 1;

	for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj) {
			for (i = yinput_width; i > 0; i -= 8) {
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
					*(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4;
				}
			for (i = ywidth_diff; i > 0; i -= 8) {
					*(U32 *)YPlane = 0; YPlane += 4;
					*(U32 *)YPlane = 0; YPlane += 4;
				}
	}
	for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj) {
			for (i = FrameWidth; i > 0; i -= 8) {
				*(U32 *)YPlane = 0; YPlane += 4;
				*(U32 *)YPlane = 0; YPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
					*(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
					*(U32 *)UPlane = 0x40404040; UPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
				*(U32 *)UPlane = 0x40404040; UPlane += 4;
			}
	}

	for (j = uvinput_height; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvinput_width; i > 0; i -= 8) {
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
					*(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4;
				}
			for (i = uvwidth_diff; i > 0; i -= 8) {
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
					*(U32 *)VPlane = 0x40404040; VPlane += 4;
				}
	}
	for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj) {
			for (i = uvoutput_width; i > 0; i -= 8) {
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
				*(U32 *)VPlane = 0x40404040; VPlane += 4;
			}
	}

}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUV12toEncYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//    | pitch           |  + 92
//    | FrameHeight     |  + 88
//    | FrameWidth      |  + 84
//    | VPlane          |  + 80
//    | UPlane          |  + 76
//    | YPlane          |  + 72
//    | lpInput         |  + 68
//    | lpbiInput       |  + 64
//  -----------------------------
//    | return addr     |  + 60
//    | saved ebp       |  + 56
//    | saved ebx       |  + 52
//    | saved esi       |  + 48
//    | saved edi       |  + 44

//    | ypitch_adj      |  + 40
//    | yinput_height   |  + 36
//    | yinput_width    |  + 32
//    | yheight_diff    |  + 28
//    | ywidth_diff     |  + 24
//    | uvpitch_adj     |  + 20
//    | uvoutput_width  |  + 16
//    | uvinput_height  |  + 12
//    | uvinput_width   |  +  8
//    | uvheight_diff   |  +  4
//    | uvwidth_diff    |  +  0

#define LOCALSIZE        44

#define PITCH_PARM       92
#define FRAME_HEIGHT     88
#define FRAME_WIDTH      84
#define VPLANE           80
#define UPLANE           76
#define YPLANE           72
#define LP_INPUT         68
#define LPBI_INPUT       64

#define YPITCH_ADJ       40
#define YINPUT_HEIGHT    36
#define YINPUT_WIDTH     32
#define YHEIGHT_DIFF     28
#define YWIDTH_DIFF      24
#define UVPITCH_ADJ      20
#define UVOUTPUT_WIDTH   16
#define UVINPUT_HEIGHT   12
#define UVINPUT_WIDTH     8
#define UVHEIGHT_DIFF     4
#define UVWIDTH_DIFF      0

	_asm {

		push	ebp
		push	ebx
		push	esi
		push	edi
		sub		esp, LOCALSIZE

		mov		ebx, [esp + FRAME_HEIGHT]
		mov		ecx, [esp + FRAME_WIDTH]
		mov		edx, [esp + PITCH_PARM]
// ypitch_adj = pitch - FrameWidth
		mov		eax, edx
		sub		eax, ecx
		mov		[esp + YPITCH_ADJ], eax
// uvoutput_width = FrameWidth >> 1
		mov		ebp, ecx
		shr		ebp, 1
		mov		[esp + UVOUTPUT_WIDTH], ebp
// uvpitch_adj = pitch - (FrameWidth >> 1)
		sub		edx, ebp
		mov		[esp + UVPITCH_ADJ], edx
// yinput_height = lpbiInput->biHeight
// uvinput_height = yinput_height >> 1
// yinput_width = lpbiInput->biWidth
// uvinput_width = yinput_width >> 1
		mov		ebx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biHeight
		mov		[esp + YINPUT_HEIGHT], eax
		shr		eax, 1
		mov		[esp + UVINPUT_HEIGHT], eax
		mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
// yheight_diff = FrameHeight - yinput_height
// uvheight_diff = yheight_diff >> 1;
		mov		eax, [esp + FRAME_HEIGHT]
		mov		ebx, eax
		sub		eax, [esp + YINPUT_HEIGHT]
		jns		NoCrop0
		xor		eax, eax
		mov		[esp + YINPUT_HEIGHT], ebx
		shr		ebx, 1
		mov		[esp + UVINPUT_HEIGHT], ebx
NoCrop0:
		mov		[esp + YHEIGHT_DIFF], eax
		shr		eax, 1
		mov		[esp + UVHEIGHT_DIFF], eax
// ywidth_diff = FrameWidth - yinput_width
// uvwidth_diff = ywidth_diff >> 1;
		mov		eax, [esp + FRAME_WIDTH]
		xor		ebx, ebx
		sub		eax, [esp + YINPUT_WIDTH]
		jns		NoCrop1
		mov		eax, [esp + FRAME_WIDTH]
		mov		ebx, [esp + YINPUT_WIDTH]
		sub		ebx, eax
		mov		[esp + YINPUT_WIDTH], eax
		shr		eax, 1
		mov		[esp + UVINPUT_WIDTH], eax
		xor		eax, eax
NoCrop1:
		mov		[esp + YWIDTH_DIFF], eax
		shr		eax, 1
		mov		[esp + UVWIDTH_DIFF], eax
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]

// assign (edi, YPlane)
		mov		edi, [esp + YPLANE]
// for (j = yinput_height; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YINPUT_HEIGHT]
L1:
// for (i = yinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + YINPUT_WIDTH]
L2:
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// *(U32 *)YPlane = (*pnext++ >> 1) & 0x7F7F7F7F; YPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L2
// for (i = ywidth_diff; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + YWIDTH_DIFF]
		test	ebp, ebp
		jz		L3
L4:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L4
// j--, YPlane += ypitch_adj
L3:
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L1

// for (j = yheight_diff; j > 0; j--, YPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + YHEIGHT_DIFF]
		test	ecx, ecx
		jz		L7
L5:
// for (i = FrameWidth; i > 0; i -= 8)
//    *(U32 *)YPlane = 0; YPlane += 4;
//    *(U32 *)YPlane = 0; YPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + FRAME_WIDTH]
L6:
// 1
		xor		eax, eax
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L6
// j--, YPlane += ypitch_adj
		mov		eax, [esp + YPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L5

L7:
// recompute start of input U plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
// assign (edi, UPlane)
		mov		edi, [esp + UPLANE]
		shr		ebx, 1
// for (j = uvinput_height; j > 0; j--, UPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L8:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L9:
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// *(U32 *)UPlane = (*pnext++ >> 1) & 0x7F7F7F7F; UPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L9
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L11
L10:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L10
// j--, UPlane += uvpitch_adj
L11:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L8

// for (j = uvheight_diff; j > 0; j--, UPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L14
L12:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
//    *(U32 *)UPlane = 0x40404040; UPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L13:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L13
// j--, UPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L12

L14:
// recompute start of input V plane
		mov		edx, [esp + LPBI_INPUT]
		mov		eax, (LPBITMAPINFOHEADER)[edx].biHeight
		mov		ecx, (LPBITMAPINFOHEADER)[edx].biWidth
		imul	eax, ecx
// assign (esi, lpInput)
		mov		esi, [esp + LP_INPUT]
		add		esi, eax
		shr		eax, 2
		add		esi, eax
// assign (edi, VPlane)
		mov		edi, [esp + VPLANE]
// for (j = uvinput_height; j > 0; j--, VPlane += ypitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVINPUT_HEIGHT]
L15:
// for (i = uvinput_width; i > 0; i -= 8)
// assign (ebp, i)
		mov		ebp, [esp + UVINPUT_WIDTH]
L16:
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// *(U32 *)VPlane = (*pnext++ >> 1) & 0x7F7F7F7F; VPlane += 4
// 1
		mov		eax, [esi]
		mov		edx, [esi + 4]
// 2
		shr		eax, 1
		and		edx, 0xFEFEFEFE
// 3
		shr		edx, 1
		and		eax, 0x7F7F7F7F
// 4
		lea		esi, [esi + 8]
		mov		[edi], eax
// 5
		sub		ebp, 8
		mov		[edi + 4], edx
// 6
		lea		edi, [edi + 8]
		jnz		L16
// for (i = uvwidth_diff; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVWIDTH_DIFF]
		test	ebp, ebp
		jz		L18
L17:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L17
// j--, VPlane += uvpitch_adj
L18:
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		add		esi, ebx
		dec		ecx
		jnz		L15

// for (j = uvheight_diff; j > 0; j--, VPlane += uvpitch_adj)
// assign (ecx, j)
		mov		ecx, [esp + UVHEIGHT_DIFF]
		test	ecx, ecx
		jz		L21
L19:
// for (i = uvoutput_width; i > 0; i -= 8)
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
//    *(U32 *)VPlane = 0x40404040; VPlane += 4;
// assign (ebp, i)
		mov		ebp, [esp + UVOUTPUT_WIDTH]
L20:
// 1
		mov		eax, 040404040H
		sub		ebp, 8
// 2
		mov		[edi], eax
		mov		[edi + 4], eax
// 3
		lea		edi, [edi + 8]
		jnz		L20
// j--, VPlane += uvpitch_adj
		mov		eax, [esp + UVPITCH_ADJ]
		add		edi, eax
		dec		ecx
		jnz		L19

L21:
		add		esp, LOCALSIZE
		pop		edi
		pop		esi
		pop		ebx
		pop		ebp
		ret
	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef YPITCH_ADJ
#undef YINPUT_HEIGHT
#undef YINPUT_WIDTH
#undef YHEIGHT_DIFF
#undef YWIDTH_DIFF
#undef UVPITCH_ADJ
#undef UVOUTPUT_WIDTH
#undef UVINPUT_HEIGHT
#undef UVINPUT_WIDTH
#undef UVHEIGHT_DIFF
#undef UVWIDTH_DIFF

#if defined(_CODEC_STATS)
void NOC_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn, *peol;
int width_adj, height_adj;
int stretch, mark, aspect;
int iBackTwoLines;
int j, k;
int LumaIters = 0;
int ypitch_adj = 0;
int uvpitch_adj = 0;
int nextline = -(lpbiInput->biWidth << 1);

	for (j = FrameHeight; j > 0; j -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) << 1);
	// Point to the beginning of the last line.
	pnext = lpInput + ((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj))
			        + width_adj;

	for (j = LumaIters; j > 0; j--) {
		for (k = 0; k < mark; k++) {
			for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8) {
				if (0 == (k & 1)) {
					*(YPlane+0) = *(pnext+ 0);	*(YPlane+1) = *(pnext+ 2);
					*(YPlane+2) = *(pnext+ 4);	*(YPlane+3) = *(pnext+ 6);
					*(YPlane+4) = *(pnext+ 8);	*(YPlane+5) = *(pnext+10);
					*(YPlane+6) = *(pnext+12);	*(YPlane+7) = *(pnext+14);
					*(UPlane+0) = ((*(pnext+ 1)>>1) + (*(pnext+ 1+nextline)>>1));
					*(UPlane+1) = ((*(pnext+ 5)>>1) + (*(pnext+ 5+nextline)>>1));
					*(UPlane+2) = ((*(pnext+ 9)>>1) + (*(pnext+ 9+nextline)>>1));
					*(UPlane+3) = ((*(pnext+13)>>1) + (*(pnext+13+nextline)>>1));
					*(VPlane+0) = ((*(pnext+ 3)>>1) + (*(pnext+ 3+nextline)>>1));
					*(VPlane+1) = ((*(pnext+ 7)>>1) + (*(pnext+ 7+nextline)>>1));
					*(VPlane+2) = ((*(pnext+11)>>1) + (*(pnext+11+nextline)>>1));
					*(VPlane+3) = ((*(pnext+15)>>1) + (*(pnext+15+nextline)>>1));
					UPlane += 4; VPlane += 4;
				} else {
					*(YPlane+0) = *(pnext+ 0);	*(YPlane+1) = *(pnext+ 2);
					*(YPlane+2) = *(pnext+ 4);	*(YPlane+3) = *(pnext+ 6);
					*(YPlane+4) = *(pnext+ 8);	*(YPlane+5) = *(pnext+10);
					*(YPlane+6) = *(pnext+12);	*(YPlane+7) = *(pnext+14);
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth << 1);
			pbn = pnext;
			for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4,
															  plast += 8,
															  pbn += 8) {
				*(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1));
				*(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1));
				*(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1));
				*(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1));
			}
			YPlane += ypitch_adj;
		}
	}
}
#endif

#if 0
void C_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 *lpInput,
	U8 *YPlane,
	U8 *UPlane,
	U8 *VPlane,
	UN FrameWidth,
	UN FrameHeight,
	const int pitch) {

U8  *pnext, *plast, *pbn, *peol;
int width_adj, height_adj;
int stretch, mark, aspect;
int iBackTwoLines;
int j, k;
int LumaIters = 0;
int ypitch_adj = pitch - FrameWidth;
int uvpitch_adj = pitch - (FrameWidth >> 1);
int nextline = -(lpbiInput->biWidth << 1);

	for (j = FrameHeight; j > 0; j -= 48) {
		LumaIters += 4;
	}
	width_adj = lpbiInput->biWidth - FrameWidth;
	aspect = (width_adj ? LumaIters : 0);
	height_adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1;
	stretch = (height_adj ? 1 : 0);
	mark = 12 - stretch;
	// Move from end of line N to beginning of line N-1
	iBackTwoLines = -((lpbiInput->biWidth + (int)FrameWidth) << 1);
	// Point to the beginning of the last line.
	pnext = lpInput + ((lpbiInput->biWidth << 1) * ((FrameHeight - aspect - 1) + height_adj))
			        + width_adj;

	for (j = LumaIters; j > 0; j--) {
		for (k = 0; k < mark; k++) {
			for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8) {
				if (0 == (k & 1)) {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
					*(UPlane+0) = ((*(pnext+ 1)>>1) + (*(pnext+ 1+nextline)>>1)) >> 1;
					*(UPlane+1) = ((*(pnext+ 5)>>1) + (*(pnext+ 5+nextline)>>1)) >> 1;
					*(UPlane+2) = ((*(pnext+ 9)>>1) + (*(pnext+ 9+nextline)>>1)) >> 1;
					*(UPlane+3) = ((*(pnext+13)>>1) + (*(pnext+13+nextline)>>1)) >> 1;
					*(VPlane+0) = ((*(pnext+ 3)>>1) + (*(pnext+ 3+nextline)>>1)) >> 1;
					*(VPlane+1) = ((*(pnext+ 7)>>1) + (*(pnext+ 7+nextline)>>1)) >> 1;
					*(VPlane+2) = ((*(pnext+11)>>1) + (*(pnext+11+nextline)>>1)) >> 1;
					*(VPlane+3) = ((*(pnext+15)>>1) + (*(pnext+15+nextline)>>1)) >> 1;
					UPlane += 4; VPlane += 4;
				} else {
					*(YPlane+0) = *(pnext+ 0) >> 1;	*(YPlane+1) = *(pnext+ 2) >> 1;
					*(YPlane+2) = *(pnext+ 4) >> 1;	*(YPlane+3) = *(pnext+ 6) >> 1;
					*(YPlane+4) = *(pnext+ 8) >> 1;	*(YPlane+5) = *(pnext+10) >> 1;
					*(YPlane+6) = *(pnext+12) >> 1;	*(YPlane+7) = *(pnext+14) >> 1;
				}
			}
			pnext += iBackTwoLines;
			YPlane += ypitch_adj;
			if (0 == (k & 1)) {
				UPlane += uvpitch_adj;
				VPlane += uvpitch_adj;
			}
		}
		if (stretch) {
			plast = pnext - (lpbiInput->biWidth << 1);
			pbn = pnext;
			for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4,
															  plast += 8,
															  pbn += 8) {
				*(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1;
				*(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1;
				*(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1;
				*(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1;
			}
			YPlane += ypitch_adj;
		}
	}
}
#endif

__declspec(naked)
_STATIC void IA_H26X_YUY2toYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

#define LOCALSIZE			 48

#define PITCH_PARM			 96
#define FRAME_HEIGHT		 92
#define FRAME_WIDTH			 88
#define VPLANE				 84
#define UPLANE				 80
#define YPLANE				 76
#define LP_INPUT			 72
#define LPBI_INPUT			 68

#define PYPREV				 44
#define PYSPACE				 40
#define PYNEXT				 36
#define PEOL				 32	
#define LOOP_J				 28	
#define LOOP_K				 24
#define BACK_TWO_LINES		 20
#define STRETCH				 16
#define MARK				 12
#define LUMA_ITERS			  8
#define YPITCH_ADJ			  4
#define UVPITCH_ADJ			  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * Y 0 * U 0 * Y 1 * V 0 * Y 2 * U 1 * Y 3 * V 1 * Y 4 * U 2 * Y 5 * V 2 * Y 6 * U 3 * Y 7 * V 3 *
//         *************************************************************************************************
// Y Offsets  0			  2			  4			  6			  8			  10		  12		  14
// U Offsets        1                       5                       9   					13
// Y Offsets                    3                       7                       11                      15
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+9]			; U2
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+13]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+11]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+15]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi]			; Y0
; 6
	mov		bh, [esi+5]			; U1
	mov		ah, [esi+2]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi+1]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+7]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+3]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+12]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+14]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+8]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+10]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+4]			; Y2
	mov		bl, [esi+12]		; Y6
; 2
	mov		ah, [esi+6]			; Y3
	mov		bh, [esi+14]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi]			; Y0
; 5
	mov		ah, [esi+2]			; Y1
	mov		bh, [esi+10]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+8]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+4]
	mov		bl, [ebp+4]
	mov		bh, [ebp+6]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+6]
	mov		bl, [ebp]
; 2
	shl		eax, 16
	mov		bh, [ebp+2]
; 3
	mov		al, [edx]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+2]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+4]
; 9
	shr		eax, 1
	mov		bh, [ebp+6]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+4]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

bool UYVY_to_YUV12_Flip(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * pImage,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
	DWORD dwFrameWidthHalf, dwFrameHeightHalf;
	BYTE *pRowStartY, *pRowStartSrc, *pRowStartU, *pRowStartV;
	int offset;

	int nRowsToSkip=0, nColsToSkip=0, nRowSkipDelta=0xffffff, nColSkipDelta=0xffffff;
	int nSrcRowIndex, nDstRowIndex, nSrcColIndex, nDstColIndex, COLUMNSTOSKIP=0, ROWSTOSKIP=0;


	if ((FrameWidth != (DWORD)(lpbiInput->biWidth)) || (FrameHeight != (DWORD)(lpbiInput->biHeight)))
	{
		nColsToSkip = COLUMNSTOSKIP = lpbiInput->biWidth - FrameWidth;
		nRowsToSkip = ROWSTOSKIP = lpbiInput->biHeight - FrameHeight;
		if ((nColsToSkip < 0) || (nRowsToSkip < 0))
		{
			return false;
		}

		// nXXXSkipDelta dictate how often we "skip" a row or col
		if (nRowsToSkip)
		{
			nRowSkipDelta = (lpbiInput->biHeight + (nRowsToSkip - 1)) / nRowsToSkip;
		}

		if (nColsToSkip)
		{
			nColSkipDelta = (lpbiInput->biWidth + (nColsToSkip - 1)) / nColsToSkip;
		}
	
	}

	// quick check to make sure we're processing CIF, QCIF, or SQCIF
	if ((FrameWidth % 4) || (FrameHeight % 4))
	{
		return false;
	}

	dwFrameWidthHalf = FrameWidth / 2;
	dwFrameHeightHalf = FrameHeight / 2;

	nSrcRowIndex = 0;
	nDstRowIndex = 0;

	// step 1, convert the Y values over
	while ((DWORD)nDstRowIndex < FrameHeight)
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		pRowStartY = YPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 1;

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		// Copy the Y values of the input row into the destination row		
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;

		while ((DWORD)nDstColIndex < FrameWidth)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nColsToSkip--;
				nSrcColIndex++;
				continue;
			}

			pRowStartY[nDstColIndex] = pRowStartSrc[nSrcColIndex * 2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}


	nSrcRowIndex = 0;
	nDstRowIndex = 0;
	nRowsToSkip = ROWSTOSKIP;

	// step 2, process U and V values
	while ((DWORD)nDstRowIndex < dwFrameHeightHalf)  // dest is only half as many rows as src
	{
		// ASSERT(nSrcRowIndex < lpbiInput->biHeight);

		// don't process odd numbered rows
		if (nSrcRowIndex % 2)
		{
			
			// if we were supposed to skip this src row anyway, make sure
			// we update our decrement
			if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
			{
				nRowsToSkip--;
			}

			nSrcRowIndex++;

			continue;
		}

		// do we need to skip this row ?
		if ((nRowsToSkip > 0) && ((nSrcRowIndex % nRowSkipDelta) == 0))
		{
			nRowsToSkip--;
			nSrcRowIndex++;
			continue;
		}

		pRowStartU = UPlane + (pitch * nDstRowIndex);
		pRowStartV = VPlane + (pitch * nDstRowIndex);
		pRowStartSrc = pImage + (lpbiInput->biWidth * nSrcRowIndex * 2) + 0;

		// Copy the U and V values of the input row into the destination row
		nSrcColIndex = 0;
		nDstColIndex = 0;

		nColsToSkip = COLUMNSTOSKIP;  // reset column skip count

		while ((DWORD)nDstColIndex < dwFrameWidthHalf)
		{
			// ASSERT(nSrcColIndex < lpbiInput->biWidth);

			// skip odd numbered columns
			if (nSrcColIndex % 2)
			{

				// if we were supposed to skip this src row anyway, make sure
				// we update our decrement

				if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
				{
					nColsToSkip--;
				}

				nSrcColIndex++;

				continue;
			}

			// do we need to skip this column ?
			if ((nColsToSkip > 0) && ((nSrcColIndex % nColSkipDelta) == 0))
			{
				nSrcColIndex++;
				nColsToSkip--;
				continue;
			}

			offset = nSrcColIndex * 2;
			pRowStartU[nDstColIndex] = pRowStartSrc[offset] >> 1;
			pRowStartV[nDstColIndex] = pRowStartSrc[offset+2] >> 1;

			nSrcColIndex++;
			nDstColIndex++;
		}

		nSrcRowIndex++;
		nDstRowIndex++;
	}



	// and we are done!
	return true;

}



__declspec(naked)
_STATIC void IA_H26X_UYVYtoYUV12(
	LPBITMAPINFOHEADER lpbiInput,
	U8 * BGR24Image,
	U8 * YPlane,
	U8 * UPlane,
	U8 * VPlane,
	UN  FrameWidth,
	UN  FrameHeight,
	const int pitch)
{
// Permanent (callee-save) registers - ebx, esi, edi, ebp
// Temporary (caller-save) registers - eax, ecx, edx
//
// Stack frame layout
//	| pitch			|  + 96 
//	| FrameHeight	|  + 92
//	| FrameWidth	|  + 88
//	| VPlane		|  + 84
//	| UPlane		|  + 80 
//	| YPlane		|  + 76 
//	| lpInput		|  + 72 
//	| lpbiInput		|  + 68 
//	----------------------------
//	| return addr	|  + 64
//	| saved ebp		|  + 60
//	| saved ebx		|  + 56
//	| saved esi		|  + 52 
//	| saved edi		|  + 48

//  | pyprev		|  + 44
//  | pyspace       |  + 40
//  | pynext        |  + 36
//	| peol			|  + 32
//	| j				|  + 28
//	| k				|  + 24
//	| iBackTwoLines	|  + 20
//	| stretch		|  + 16
//	| mark			|  + 12
//	| LumaIters		|  +  8
//	| ypitch_adj	|  +  4
//	| uvpitch_adj	|  +  0

	_asm {
	
	push	ebp
	push	ebx
	push	esi
	push	edi
	sub		esp, LOCALSIZE

// assign (ebx, lpbiInput)
	mov		ebx, [esp + LPBI_INPUT]
// ypitch_adj = pitch - FrameWidth
// assign (ecx, FrameWidth)
// assign (edx, pitch)
	mov		ecx, [esp + FRAME_WIDTH]
	mov		edx, [esp + PITCH_PARM]
	mov		eax, edx
	sub		eax, ecx
	mov		[esp + YPITCH_ADJ], eax
// uvpitch_adj = pitch - (FrameWidth >> 1)
// kill (edx, pitch)
	mov		ebp, ecx
	shr		ebp, 1
	sub		edx, ebp
	mov		[esp + UVPITCH_ADJ], edx
// for (i = FrameHeight; i > 0; i -= 48) LumaIters += 4
// assign (edx, LumaIters)
	xor		edx, edx
	mov		eax, [esp + FRAME_HEIGHT]
L1:
	lea		edx, [edx + 4]
	sub		eax, 48
	jnz		L1
// width_adj = lpbiInput->biWidth - FrameWidth;
// assign (esi, width_adj)
	mov		esi, (LPBITMAPINFOHEADER)[ebx].biWidth
	sub		esi, [esp + FRAME_WIDTH]
// aspect = (width_adj ? LumaIters : 0)
// assign (edi, aspect)
// kill (edx, LumaIters)
	mov		[esp + LUMA_ITERS], edx
	xor		edi, edi
	test	esi, esi
	jz		L2
	mov		edi, edx
// height _adj = (lpbiInput->biHeight - (FrameHeight - aspect)) >> 1
// assign (edx, height_adj)
L2:
	mov		edx, (LPBITMAPINFOHEADER)[ebx].biHeight
	sub		edx, [esp + FRAME_HEIGHT]
	add		edx, edi
	shr		edx, 1
// stretch = (height_adj ? 1 : 0)
	xor		eax, eax
	test	edx, edx
	jz		L3
	inc		eax
L3:
	mov		[esp + STRETCH], eax
// mark = 12 - stretch
	mov		ebp, 12
	sub		ebp, eax
	mov		[esp + MARK], ebp
// iBackTwoLines = -((lpbiInput->biWidth + FrameWidth) << 1)
	mov		ebp, (LPBITMAPINFOHEADER)[ebx].biWidth
	add		ebp, [esp + FRAME_WIDTH]
	shl		ebp, 1
	neg		ebp
	mov		[esp + BACK_TWO_LINES], ebp
// pnext = lpInput +
//            ((lpbiInput->biWidth << 1) *
//             ((FrameHeight - aspect - 1) + height_adj)) +
//            width_adj
// kill (ebx, lpbiInput)
// kill (ecx, FrameWidth)
// kill (edx, height_adj)
// kill (esi, width_adj)
// kill (edi, aspect)
// assign (esi, pnext)
	mov		eax, (LPBITMAPINFOHEADER)[ebx].biWidth
	shl		eax, 1
	mov		ebx, [esp + FRAME_HEIGHT]
	sub		ebx, edi
	dec		ebx
	add		ebx, edx
	imul	ebx
	add		esi, eax
	add		esi, [esp + LP_INPUT]
// assign (edi, YPlane)
// assign (edx, UPlane)
// assign (ebp, VPlane)
	mov		edi, [esp + YPLANE]
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
// for (j = 0; j < LumaIters; j++)
	xor		eax, eax
	mov		[esp + LOOP_J], eax
L4:
// for (k = 0; k < mark; k++)
	xor		eax, eax
	mov		[esp + LOOP_K], eax
L5:
// for ( peol = pnext + (FrameWidth << 1); pnext < peol; pnext += 16, YPlane += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, esi
	mov		[esp + PEOL], ecx
// if (0 == (k & 1)) {
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L6
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// *(UPlane+0) = *(pnext+ 1) >> 1; *(UPlane+1) = *(pnext+ 5) >> 1
// *(UPlane+2) = *(pnext+ 9) >> 1; *(UPlane+3) = *(pnext+13) >> 1
// *(VPlane+0) = *(pnext+ 3) >> 1; *(VPlane+1) = *(pnext+ 7) >> 1
// *(VPlane+2) = *(pnext+11) >> 1; *(VPlane+3) = *(pnext+15) >> 1
// or graphically
//         *************************************************************************************************
// Values  * U 0 * Y 0 * V 0 * Y 1 * U 1 * Y 2 * V 1 * Y 3 * U 2 * Y 4 * V 2 * Y 5 * U 3 * Y 6 * V 3 * Y 7 *
//         *************************************************************************************************
// Y Offsets        1           3           5           7           9           11          13          15
// U Offsets  0                       4                       8                       12       
// Y Offsets              2                       6                       10                      14      
// Register usage:
// eax - accumulate Y values
// ebx - accumulate U values
// ecx - accumulate V values
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
// edx - ptr for writing U values
// ebp - ptr for writing V values
L7:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+8]			; U2
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+12]		; U3
; 3
	shl		eax, 16
	mov		cl, [esi+10]		; V2
; 4
	shl		ebx, 16
	mov		ch, [esi+14]		; V3
; 5
	shl		ecx, 16
	mov		al, [esi+1]			; Y0
; 6
	mov		bh, [esi+4]			; U1
	mov		ah, [esi+3]			; Y1
; 7
	shr		eax, 1
	mov		bl, [esi]			; U0
; 8 
	shr		ebx, 1
	mov		ch, [esi+6]			; V1
; 9
	and		eax, 07F7F7F7FH
	mov		cl, [esi+2]			; V0
; 10
	shr		ecx, 1
	and		ebx, 07F7F7F7FH
; 11
	mov		[edi], eax
	and		ecx, 07F7F7F7FH
; 12
	mov		al, [esi+13]		; Y6
	mov		[edx], ebx
; 13
	mov		ah, [esi+15]		; Y7
	mov		[ebp], ecx
; 14
	shl		eax, 16
	mov		ecx, [esp + PEOL]
; 15
	mov		al, [esi+9]			; Y4
	lea		edi, [edi+8]
; 16
	mov		ah, [esi+11]		; Y5
	lea		edx, [edx+4]
; 17
	shr		eax, 1
	lea		ebp, [ebp+4]
; 18
	and		eax, 07F7F7F7FH
	lea		esi, [esi+16]
; 19
	mov		[edi-4], eax
	cmp		esi, ecx
; 20
	jl		L7

	jmp		L8
// } else {
// *(YPlane+0) = *(pnext+ 0) >> 1; *(YPlane+1) = *(pnext+ 2) >> 1
// *(YPlane+2) = *(pnext+ 4) >> 1; *(YPlane+3) = *(pnext+ 6) >> 1
// *(YPlane+4) = *(pnext+ 8) >> 1; *(YPlane+5) = *(pnext+10) >> 1
// *(YPlane+6) = *(pnext+12) >> 1; *(YPlane+7) = *(pnext+14) >> 1
// }
// Register usage:
// eax, ebx - accumulate Y values
// ecx - peol
// esi - ptr to interlaced (VYUY) input
// edi - ptr for writing Y values
L6:
; 1
	mov		al, [esi+5]			; Y2
	mov		bl, [esi+13]		; Y6
; 2
	mov		ah, [esi+7]			; Y3
	mov		bh, [esi+15]		; Y7
; 3
	shl		eax, 16
	lea		edi, [edi+8]
; 4
	shl		ebx, 16
	mov		al, [esi+1]			; Y0
; 5
	mov		ah, [esi+3]			; Y1
	mov		bh, [esi+11]		; Y5
; 6
	shr		eax, 1
	mov		bl, [esi+9]			; Y4
; 7
	shr		ebx, 1
	and		eax, 07F7F7F7FH
; 8
	mov		[edi-8], eax
	and		ebx, 07F7F7F7FH
; 9
	mov		[edi-8+4], ebx
	lea		esi, [esi+16]
; 10
	cmp		esi, ecx
	jl		L6
L8:
// pnext += iBackTwoLines
	add		esi, [esp + BACK_TWO_LINES]
// YPlane += ypitch_adj
	add		edi, [esp + YPITCH_ADJ]
// if (0 == (k&1))
	mov		eax, [esp + LOOP_K]
	test	eax, 1
	jnz		L9
// UPlane += uvpitch_adj
	add		edx, [esp + UVPITCH_ADJ]
// VPlane += uvpitch_adj
	add		ebp, [esp + UVPITCH_ADJ]
L9:
	mov		eax, [esp + LOOP_K]
	inc		eax
	mov		[esp + LOOP_K], eax
	cmp		eax, [esp + MARK]
	jl		L5
// if (stretch)
	mov		eax, [esp + STRETCH]
	test	eax, eax
	jz		L10
// Save ptrs to UPlane and VPlane, use edx and ebp to do the stretch average.
	mov		[esp + UPLANE], edx
	mov		[esp + VPLANE], ebp
// plast = pnext - (lpbiInput->biWidth << 1)
// assign (plast, edx)
	mov		edx, esi
	mov		eax, [esp + LPBI_INPUT]
	mov		eax, (LPBITMAPINFOHEADER)[eax].biWidth
	shl		eax, 1
	sub		edx, eax
// pbn = pnext
// assign (pbn, ebp)
	mov		ebp, esi
// for ( peol = pbn + (FrameWidth << 1); pbn < peol; YPlane += 4, plast += 8, pbn += 8)
	mov		ecx, [esp + FRAME_WIDTH]
	shl		ecx, 1
	add		ecx, ebp
//     *(YPlane+0) = ((*(plast+0) >> 1) + (*(pbn+0) >> 1)) >> 1
//     *(YPlane+1) = ((*(plast+2) >> 1) + (*(pbn+2) >> 1)) >> 1
//     *(YPlane+2) = ((*(plast+4) >> 1) + (*(pbn+4) >> 1)) >> 1
//     *(YPlane+3) = ((*(plast+6) >> 1) + (*(pbn+6) >> 1)) >> 1

	mov		al, [edx+5]
	mov		bl, [ebp+5]
	mov		bh, [ebp+7]
	shl		ebx, 16

L11:
; 1
	mov		ah, [edx+7]
	mov		bl, [ebp+1]
; 2
	shl		eax, 16
	mov		bh, [ebp+3]
; 3
	mov		al, [edx+1]
	lea		edi, [edi+4]
; 4
	mov		ah, [edx+3]
	lea		edx, [edx+8]
; 5
	and		eax, 0xFEFEFEFE
	lea		ebp, [ebp+8]
; 6
	shr		eax, 1
	and		ebx, 0xFEFEFEFE
; 7
	shr		ebx, 1
	nop
; 8
	add		eax, ebx
	mov		bl, [ebp+5]
; 9
	shr		eax, 1
	mov		bh, [ebp+7]
; 10
	shl		ebx, 16
	and		eax, 0x7F7F7F7F
; 11
	mov		[edi-4], eax
	mov		al, [edx+5]
; 12
	cmp		ebp, ecx
	jl		L11
//   YPlane += ypitch_adj;
	add		edi, [esp + YPITCH_ADJ]
// Recover pts to UPlane and VPlane
	mov		edx, [esp + UPLANE]
	mov		ebp, [esp + VPLANE]
L10:
	mov		eax, [esp + LOOP_J]
	inc		eax
	mov		[esp + LOOP_J], eax
	cmp		eax, [esp + LUMA_ITERS]
	jl		L4

	add		esp, LOCALSIZE
	pop		edi
	pop		esi
	pop		ebx
	pop		ebp
	ret

	}
}

#undef LOCALSIZE

#undef PITCH_PARM
#undef FRAME_HEIGHT
#undef FRAME_WIDTH
#undef VPLANE
#undef UPLANE
#undef YPLANE
#undef LP_INPUT
#undef LPBI_INPUT

#undef PYPREV
#undef PYSPACE
#undef PYNEXT
#undef PEOL
#undef LOOP_J
#undef LOOP_K
#undef BACK_TWO_LINES
#undef STRETCH
#undef MARK
#undef LUMA_ITERS
#undef YPITCH_ADJ
#undef UVPITCH_ADJ

/*************************************************************
 *  Name:         colorCnvtFrame
 *  Description:  Color convert and copy input frame.
 ************************************************************/
void colorCnvtFrame(
    T_H263EncoderCatalog * EC,
    LPCODINST              lpCompInst,
    ICCOMPRESS           * lpicComp,
    U8                   * YPlane,
    U8                   * UPlane,
    U8                   * VPlane
)
{
    U8 *RGBCursor = (U8 *) lpicComp->lpInput;
	LPBITMAPINFOHEADER	lpbiInput = lpicComp->lpbiInput;
	bool bRet;

	FX_ENTRY("colorCnvtFrame")

    /*  The Connectix Quick Cam requires RGB to YUV12 conversion.
     *  The B/W camera generates palette versions (8 and 4 bit).
     *  The color camera generates RGB24 for million colors and
     *  RGB16555 for thousands colors.
     */

    if (BI_RGB == lpicComp->lpbiInput->biCompression)
	{
        if (24 == lpicComp->lpbiInput->biBitCount) {
#if 0
		if ((128 == lpbiInput->biWidth) && (96 == lpbiInput->biHeight)) {
			U8 YTest[12288];
			U8 UTest[6144];
			U8 VTest[6144];
			int i, j, k;
			U8 R,G,B;
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YTest, UTest, VTest,
				EC->FrameWidth, EC->FrameHeight, 128);
			for (i = 0; i < 96; i++) {
				for (j = 0; j < 128; j++) {
					k = (i*128)+j;
					if (1 < abs(YPlane[(i*384)+j]-YTest[(i*128)+j])) {
						B = RGBCursor[(((95-i)*128)+j)*3];
						G = RGBCursor[(((95-i)*128)+j)*3+1];
						R = RGBCursor[(((95-i)*128)+j)*3+2];
					}
					if ((0 == (i%2)) && (0 == (j%2))) {
						k =	((i>>1)*128)+(j>>1);
						if (1 < abs(UPlane[((i>>1)*384)+(j>>1)]-UTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
						if (1 < abs(VPlane[((i>>1)*384)+(j>>1)] != VTest[((i>>1)*128)+(j>>1)])) {
							B = RGBCursor[(((95-i)*128)+j)*3];
							G = RGBCursor[(((95-i)*128)+j)*3+1];
							R = RGBCursor[(((95-i)*128)+j)*3+2];
						}
					}
				}
			}
		}
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#else
			IA_H26X_BGR24toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(16 == lpicComp->lpbiInput->biBitCount)
		{
		// To use a common routine for all possible combinations of RGB16,
		// a bitfield number is passed. This number identifies the proper bit shift
		// and masking values to extract the color information
		// from the 16-bit pixel words.
		//
		//   number             shift              mask
		//                     B, G, R
		//   ------          -----------       ----------------
		//    555              2, 3, 8         0x7C, 0x7C, 0x7C
		//    664              3, 3, 9         0x78, 0x7E, 0x7E
		//    565              2, 4, 9         0x7C, 0x7E, 0x7C
		//    655              2, 3, 9         0x7C, 0x7C, 0x7E
		//
		// Only 555 falls under BI_RGB. The others are specified using the
		// BI_BITFIELDS compression specification. For BI_BITFIELDS, call
		// Build16bitModeID to get the actual bitfield number. This routine requires the
		// three array elements in the bmiColors field of a BITMAPINFO object.
		//
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_BGR16toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 555, PITCH);
#else
			IA_H26X_BGR16555toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(8 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 8, PITCH);
#else
			IA_H26X_CLUT8toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else if(4 == lpicComp->lpbiInput->biBitCount)
		{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
			C_H26X_CLUTtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, 4, PITCH);
#else
			IA_H26X_CLUT4toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
				EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
		}
		else
		{
			ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
		}
    }
    else if (FOURCC_YVU9 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YVU9toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if ((FOURCC_YUV12 == lpicComp->lpbiInput->biCompression) || (FOURCC_IYUV == lpicComp->lpbiInput->biCompression))
	{
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUV12toEncYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
	}
    else if (FOURCC_YUY2 == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif
#if 0
        C_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#else
        IA_H26X_YUY2toYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
            EC->FrameWidth, EC->FrameHeight, PITCH);
#endif
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else if (FOURCC_UYVY == lpicComp->lpbiInput->biCompression)
    {
#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time = PENTIUM_TIMER();
			}
#endif



		// UYVY images are upside-down in relation to I420
		// call the "flipped" version of the UYVY-I420 translator.

	bRet = UYVY_to_YUV12_Flip(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
	                          EC->FrameWidth, EC->FrameHeight, PITCH);


//          IA_H26X_UYVYtoYUV12(lpbiInput, RGBCursor, YPlane, UPlane, VPlane,
//            EC->FrameWidth, EC->FrameHeight, PITCH);


#if defined(_CODEC_STATS)
			if (pEncoderStats) {
				pEncoderStats->color_convertor_time =
					PENTIUM_TIMER() - pEncoderStats->color_convertor_time;
			}
#endif
    }
    else
    {
		ERRORMESSAGE(("%s: Unexpected input format detected\r\n", _fx_));
    }
}

#endif // } H263P
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx5128a1.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a1.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a1.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:26   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:30   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:22:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:58:38   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:40   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:14   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by one, i.e. non-zoom.
; cx5128a1  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;              It converts the input to the clut8 index dyncamically computed
;              for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a1>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8AP (U8 * YPlane,
;                                       U8 * VPlane,
;                                       U8 * UPlane,
;                                       UN  FrameWidth,
;                                       UN  FrameHeight,
;                                       UN  YPitch,
;                                       UN  VPitch,
;                                       UN  AspectAdjustmentCount,
;                                       U8 FAR * ColorConvertedFrame,
;                                       U32 DCIOffset,
;                                       U32 CCOffsetToLine0,
;                                       IN  CCOPitch,
;                                       IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8AP

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8AP    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine0

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine0

KeepLine0:

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*2-8+0]        ; 03 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+2]                ; 02 -- Fetch luma for Pel02
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+3]                ; 03 -- Fetch luma for Pel03
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+2]        ; 01 -- Fetch UV contrib to Active Pal addr
    
Line0Loop:

  mov   bh,PB [esi-768*2-8+1]        ; 02 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01 -- Fetch luma for Pel01
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither03 -8] ; 03 -- Pel03 clut index
  mov   al,PB [esi+0]                ; 00 -- Fetch luma for Pel00
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither02 -8] ; 02 -- Pel02 clut index
  shl   edx,16                       ; 03 & 02 -- Position high order pels
   mov  ah,PB [esi-768*1-4+3]        ; 00 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+2+4]              ; 02 -- Fetch luma for next Pel02
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither01 -8] ; 01 -- Pel01 clut index
   mov  ch,PB [esi-768*1-4+2+4]      ; 01 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither00 -8] ; 00 -- Pel00 clut index
   mov  ah,PB [esi-768*2-8+0+4]      ; 03 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+3+4]              ; 03 -- Fetch luma for next Pel03
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line0Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine0:

  Lesi  YPlane                       ; Reload luma cursor.
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine1

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*2-8+2]        ; 13 -- Fetch UV contrib to Active Pal addr
   mov  bl,PB [esi+ebp*1+2]          ; 12 -- Fetch luma for Pel12
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   mov  al,PB [esi+ebp*1+3]          ; 13 -- Fetch luma for Pel13
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   mov  ch,PB [esi-768*1-4+0]        ; 11 -- Fetch UV contrib to Active Pal addr
    
Line1Loop:

  mov   bh,PB [esi-768*2-8+3]        ; 12 -- Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+ebp*1+1]          ; 11 -- Fetch luma for Pel11
  shr   cl,1                         ; 01 -- Reduce luma to 7 bits
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither13 -8] ; 13 -- Pel13 clut index
  mov   al,PB [esi+ebp*1+0]          ; 10 -- Fetch luma for Pel10
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither12 -8] ; 12 -- Pel12 clut index
  shl   edx,16                       ; 13 & 12 -- Position high order pels
   mov  ah,PB [esi-768*1-4+1]        ; 10 -- Fetch UV contrib to Active Pal addr
  shr   al,1                         ; 00 -- Reduce luma to 7 bits
   mov  bl,PB [esi+ebp*1+2+4]        ; 12 -- Fetch luma for next Pel12
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither11 -8] ; 11 -- Pel11 clut index
   mov  ch,PB [esi-768*1-4+0+4]      ; 11 -- Fetch next UV contrib
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither10 -8] ; 10 -- Pel10 clut index
   mov  ah,PB [esi-768*2-8+2+4]      ; 13 -- Fetch next UV contrib
  mov   PD es:[edi+esi],edx          ; Write 4 pels to display adapter.
   mov  al,PB [esi+ebp*1+3+4]        ; 13 -- Fetch luma for next Pel13
  shr   bl,1                         ; 02 -- Reduce luma to 7 bits
   Ledx EndOfLine
  shr   al,1                         ; 03 -- Reduce luma to 7 bits
   add  esi,4                        ; Advance to next 4 pels
  cmp   esi,edx
   jne  Line1Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine1:

  Lesi  YPlane                       ; Reload luma cursor.
   lea  edx,[ebp*2]
  add   esi,edx
   Ledi VPlane
  Sesi  YPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledx  AspectCount
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  sub   edi,esi
   dec  edx
  Sebp  EndOfLine
   Lebp YPitch
  Sedx  AspectCount
   jne  KeepLine2

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine2

KeepLine2:

  mov   ah,PB [esi-768*2-8+1]
   mov  bl,PB [esi+2]
  shr   bl,1
   mov  al,PB [esi+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+3]
    
Line2Loop:

  mov   bh,PB [esi-768*2-8+0]
   mov  cl,PB [esi+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither23 -8]
  mov   al,PB [esi+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither22 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+2]
  shr   al,1
   mov  bl,PB [esi+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither21 -8]
   mov  ch,PB [esi-768*1-4+3+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither20 -8]
   mov  ah,PB [esi-768*2-8+1+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line2Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine2:

  Lesi  YPlane
   Ledx AspectCount
  sub   edi,esi
   dec  edx
  Sedx  AspectCount
   jne  KeepLine3

  Ledx  AspectAdjustmentCount
   add  edi,esi
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*2-8+3]
   mov  bl,PB [esi+ebp*1+2]
  shr   bl,1
   mov  al,PB [esi+ebp*1+3]
  shr   al,1
   mov  ch,PB [esi-768*1-4+1]
    
Line3Loop:

  mov   bh,PB [esi-768*2-8+2]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  dh,PB ActivePaletteIdxTable[eax+Ydither33 -8]
  mov   al,PB [esi+ebp*1+0]
   mov  dl,PB ActivePaletteIdxTable[ebx+Ydither32 -8]
  shl   edx,16
   mov  ah,PB [esi-768*1-4+0]
  shr   al,1
   mov  bl,PB [esi+ebp*1+2+4]
  mov   dh,PB ActivePaletteIdxTable[ecx+Ydither31 -8]
   mov  ch,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[eax+Ydither30 -8]
   mov  ah,PB [esi-768*2-8+3+4]
  mov   PD es:[edi+esi],edx
   mov  al,PB [esi+ebp*1+3+4]
  shr   bl,1
   Ledx EndOfLine
  shr   al,1
   add  esi,4
  cmp   esi,edx
   jne  Line3Loop

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx
  Sedi  CCOCursor

SkipLine3:

  Lesi  YPlane
   lea  edx,[ebp*2]
  add   esi,edx
   Ledx YLimit
  Sesi  YPlane
   cmp  esi,edx
  jne   NextFourLines

IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8AP endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx51282.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51282.asv
;//
;// $Log:   S:\h26x\src\dec\cx51282.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:42   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:08   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:53:50   KMILLS
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 14:39:42   BNICKERS
;// Support YUV12 to CLUT8 zoom by 2.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:10   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by two.
; |||||||
; cx51282  -- This function performs YUV12 to CLUT8 zoom-by-2 color conversion
;             for H26x.  It is tuned for best performance on the Pentium(r)
;             Microprocessor.  It dithers among 9 chroma points and 26 luma
;             points, mapping the 8 bit luma pels into the 26 luma points by
;             clamping the ends and stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN  FrameWidth,
;                                            UN  FrameHeight,
;                                            UN  YPitch,
;                                            UN  VPitch,
;                                            UN  AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32 DCIOffset,
;                                            U32 CCOffsetToLine0,
;                                            IN  CCOPitch,
;                                            IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8ZoomBy2

IFDEF USE_BILINEAR_MSH26X

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   ChromaLineLen,ebx
   mov  YLimit,edx

NextTwoLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8 
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov   [esi],edx                   ; Stash EOL indication.
   mov  esi,YCursor                 ; Reload cursor over y line.
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+1]                  ; Fetch y1.                                  XX XX XX XX       m>-- -- -- y1        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      -- -- -- --
  mov   cl,[esi]                    ; Fetch y0.                                  XX XX XX XX         -- -- -- y1      m>-- -- -- y0      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      -- -- -- --
  mov   al,PB YDither[ecx+0]        ; Fetch Y0.                                m>XX XX XX Y0         -- -- -- y1       <-- -- -- y0      -- -- -- --
   add  ecx,ebx                     ; Add y1 to y0.                              XX XX XX Y0        <-- -- -- y1       >-- -- -- y0+y1   -- -- -- --
  shr   ecx,1                       ; ya = (y0 + y1) / 2.                        XX XX XX Y0         -- -- -- y1       >-- -- -- ya      -- -- -- --
   mov  ah,PB YDither[ecx+6]        ; Fetch YA.                                  XX XX YA Y0         -- -- -- y1       <-- -- -- ya      -- -- -- --
  mov   dl,PB YDither[ebx+2]        ; Fetch Y1.                                  XX XX YA Y0         -- -- -- y1       <-- -- -- ya    m>-- -- -- Y1
   mov  cl,[esi+2]                  ; Fetch y2.                                  XX XX YA Y0         -- -- -- y1      m>-- -- -- y2      -- -- -- Y1
  add   ebx,ecx                     ; Add y2 to y1.                              XX XX YA Y0        >-- -- -- y1+y2    <-- -- -- y2      -- -- -- Y1
   shr  ebx,1                       ; yb = (y1 + y2) / 2.                        XX XX YA Y0        >-- -- -- yb        -- -- -- y2      -- -- -- Y1
  mov   dh,PB YDither[ebx+4]        ; Fetch YB.                                  XX XX YA Y0        >-- -- -- yb        -- -- -- y2    m>-- -- YB Y1
   sub  edi,esi                     ; Get span from y cursor to CCO cursor.      XX XX YA Y0         -- -- -- yb        -- -- -- y2      -- -- YB Y1
  shl   edx,16                      ; Position YB Y1.                            XX XX YA Y0         -- -- -- yb        -- -- -- y2     >YB Y1 -- --
   sub  edi,esi                     ;                                            XX XX YA Y0         -- -- -- yb        -- -- -- y2      YB Y1 -- --
  and   eax,00000FFFFH              ; Extract YA Y0.                            >-- -- YA Y0         -- -- -- yb        -- -- -- y2      YB Y1 -- --
   mov  bl,[esi+3]                  ; Fetch y3.                                  -- -- YA Y0       m>-- -- -- y3        -- -- -- y2      YB Y1 -- --
  or    eax,edx                     ; < YB Y1 YA Y0>.                           >YB Y1 YA Y0         -- -- -- y3        -- -- -- y2     <YB Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               YB Y1 YA Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  sub   esp,1536

Line0Loop:

  add   eax,edx                       ; < PB P1 PA P0>.                         >PB P1 PA P0         -- -- -- y3        -- -- -- y2     <C1 C1 C0 C0
   mov  Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PB P1 PA P0         -- -- -- y3        -- -- -- y2      C1 C1 C0 C0
  mov   al,PB YDither[ecx+0]          ; Fetch Y2.                              m>PB P1 PA Y2         -- -- -- y3       <-- -- -- y2      C1 C1 C0 C0
   add  ecx,ebx                       ; Add y3 to y2.                            PB P1 PA Y2         -- -- -- y3       >-- -- -- y2+y3   C1 C1 C0 C0
  shr   ecx,1                         ; yc = (y2 + y3) / 2.                      PB P1 PA Y2         -- -- -- y3       >-- -- -- yc      C1 C1 C0 C0
   mov  ah,PB YDither[ecx+6]          ; Fetch YC.                                PB P1 YC Y2         -- -- -- y3       <-- -- -- yc      C1 C1 C0 C0
  and   eax,00000FFFFH                ; Extract YC Y2.                          >-- -- YC Y2         -- -- -- y3        -- -- -- y2      C1 C1 C0 C0
   mov  dl,PB YDither[ebx+2]          ; Fetch Y3.                                -- -- YC Y2         -- -- -- y3        -- -- -- y2      C1 C1 C0 Y3
  mov   cl,[esi+4]                    ; Fetch y4.                                -- -- YC Y2         -- -- -- y3      m>-- -- -- y4      C1 C1 C0 Y3
   add  ebx,ecx                       ; Add y4 to y3.                            -- -- YC Y2        >-- -- -- y3+y4     -- -- -- y4      C1 C1 C0 Y3
  shr   ebx,1                         ; yd = (y3 + y4) / 2.                      -- -- YC Y2        >-- -- -- yd        -- -- -- y4      C1 C1 C0 Y3
   mov  dh,PB YDither[ebx+4]          ; Fetch YD.                                -- -- YC Y2        <-- -- -- yd        -- -- -- y4    m>C1 C1 YD Y3
  add   esi,4                         ; Advance cursor.                          -- -- YC Y2         -- -- -- yd        -- -- -- y4      C1 C1 YD Y3
   shl  edx,16                        ; Extract YD Y3.                           -- -- YC Y2         -- -- -- yd        -- -- -- y4     >YD Y3 -- --
  mov   bl,[esi+1]                    ; Fetch y5.                                -- -- YC Y2       m>-- -- -- y5        -- -- -- y4      YD Y3 -- --
   or   eax,edx                       ; < YD Y3 Yc Y2>.                         >YD Y3 YC Y2         -- -- -- y5        -- -- -- y4     <YD Y3 -- --
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             YD Y3 YC Y2         -- -- -- y5        -- -- -- y4    s>C3 C3 C2 C2
   add  eax,edx                       ; < P03  P03  P02  P02>.                  >PD P3 PC P2         -- -- -- y5        -- -- -- y4     <C3 C3 C2 C2
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PD P3 PC P2         -- -- -- y5        -- -- -- y4      C3 C3 C2 C2
   mov  al,PB YDither[ecx+0]          ; Fetch Y4.                                PD P3 PC Y4         -- -- -- y5       <-- -- -- y4      C3 C3 C2 C2
  add   ecx,ebx                       ; Add y5 to y4.                            PD P3 PC Y4        >-- -- -- y5       >-- -- -- y4+y5   C3 C3 C2 C2
   shr  ecx,1                         ; ye = (y4 + y5) / 2.                      PD P3 PC Y4         -- -- -- y5       >-- -- -- ye      C3 C3 C2 C2
  mov   ah,PB YDither[ecx+6]          ; Fetch YE.                              m>PD P3 YE Y4         -- -- -- y5       <-- -- -- ye      C3 C3 C2 C2
   and  eax,00000FFFFH                ; Extract YE Y4.                          >-- -- YE Y4         -- -- -- y5        -- -- -- ye      C3 C3 C2 C2
  mov   dl,PB YDither[ebx+2]          ; Fetch Y5.                                -- -- YE Y4         -- -- -- y5        -- -- -- ye    m>C3 C3 C2 Y5
   mov  cl,[esi+2]                    ; Fetch y6.                                -- -- YE Y4         -- -- -- y5      m>-- -- -- y6      C3 C3 C2 Y5
  add   ebx,ecx                       ; Add y6 to y5.                            -- -- YE Y4        >-- -- -- y5+y6    <-- -- -- y6      C3 C3 C2 Y5
   shr  ebx,1                         ; yf = (y5 + y6) / 2.                      -- -- YE Y4        >-- -- -- yf        -- -- -- y6      C3 C3 C2 Y5
  mov   dh,PB YDither[ebx+4]          ; Fetch YF.                                -- -- YE Y4        <-- -- -- yf        -- -- -- y6      C3 C3 YF Y5
   shl  edx,16                        ; Extract YF Y5.                           -- -- YE Y4         -- -- -- yf        -- -- -- y6      YF Y5 -- --
  mov   bl,[esi+3]                    ; Fetch y7.                                -- -- YE Y4       m>-- -- -- y7        -- -- -- y6      YF Y5 -- --
   or   eax,edx                       ; < YF Y5 YE Y4>.                         >YF Y5 YE Y4         -- -- -- y7        -- -- -- y6     <YF Y5 -- --
  mov   edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.             YF Y5 YE Y4         -- -- -- y7        -- -- -- y6    s>C5 C5 C4 C4
   add  esp,8                         ;                                          YF Y5 YE Y4         -- -- -- y7        -- -- -- y6      C5 C5 C4 C4
  test  edx,edx
   jne  Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   edx,AspectCount
   mov  edi,CCOCursor               ; Fetch output cursor.
  sub   edx,2
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   AspectCount,edx
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   ebp,AspectAdjustmentCount
   jg   KeepLine1

  add   edx,ebp
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

   mov  ebp,LumaPitch
  mov   bl,[esi+ebp+2]              ; Fetch y130.                                XX XX XX XX       m>-- -- -- y130      -- -- -- --      XX XX XX XX
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y130      -- -- -- --      XX XX XX XX
  mov   cl,[esi+1]                  ; Fetch y1.                                  XX XX XX XX         -- -- -- y130    m>-- -- -- y1      XX XX XX XX
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y130      -- -- -- y1      XX XX XX XX
  add   ebx,ecx                     ; Add y1 to y130.                            XX XX XX XX        >-- -- -- y130+y1  <-- -- -- y1      XX XX XX XX
   shr  ebx,1                       ; yd = (y1 + y130) / 2.                      XX XX XX XX        >-- -- -- yd        -- -- -- y1      XX XX XX XX
  mov   dh,PB YDither[ebx+6]        ; Fetch YD.                                  XX XX XX XX        <-- -- -- yd        -- -- -- y1    m>XX XX YD XX
   mov  bl,[esi+ebp+1]              ; Fetch y129.                                XX XX XX XX       m>-- -- -- y129      -- -- -- y1      XX XX YD XX
  add   ecx,ebx                     ; Add y129 to y1.                            XX XX XX XX        <-- -- -- y129     >-- -- -- y1+y129 XX XX YD XX
   shr  ecx,1                       ; yc = (y1 + y129) / 2.                      XX XX XX XX         -- -- -- y129     >-- -- -- yc      XX XX YD XX
  mov   dl,PB YDither[ecx+0]        ; Fetch YC.                                  XX XX XX XX         -- -- -- y129     <-- -- -- yc    m>XX XX YD YC
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y129      -- -- -- yc      XX XX YD YC
  shl   edx,16                      ; Extract YD YC.                             XX XX XX XX         -- -- -- y129      -- -- -- yc     >YD YC -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y129      -- -- -- yc      YD YC -- --
  mov   cl,[esi]                    ; Fetch y0.                                  XX XX XX XX         -- -- -- y129    m>-- -- -- y0      YD YC -- --
   add  ebx,ecx                     ; Add y0 to y129.                            XX XX XX XX        >-- -- -- y129+y0  <-- -- -- y0      YD YC -- --
  shr   ebx,1                       ; yb = (y0 + y129) / 2.                      XX XX XX XX        >-- -- -- yb        -- -- -- y0      YD YC -- --
   mov  ah,PB YDither[ebx+4]        ; Fetch YB.                                m>XX XX YB XX        <-- -- -- yb        -- -- -- y0      YD YC -- --
  mov   bl,[esi+ebp]                ; Fetch y128.                                XX XX YB XX       m>-- -- -- y128      -- -- -- y0      YD YC -- --
   add  ecx,ebx                     ; Add y0 to y128.                            XX XX YB XX        <-- -- -- y128     >-- -- -- y0+y128 YD YC -- --
  shr   ecx,1                       ; ya = (y0 + y128) / 2.                      XX XX YB XX         -- -- -- y128     >-- -- -- ya      YD YC -- --
   mov  al,PB YDither[ecx+2]        ; Fetch YA.                                  XX XX YB YA         -- -- -- y128     <-- -- -- ya      YD YC -- --
  mov   bl,[esi+ebp+4]              ; Fetch y132.                                XX XX YB YA       m>-- -- -- y132      -- -- -- ya      YD YC -- --
   and  eax,00000FFFFH              ; Extract YB YA.                            >-- -- YB YA         -- -- -- y132      -- -- -- ya      YD YC -- --
  mov   cl,[esi+3]                  ; Fetch y3.                                  -- -- YB YA         -- -- -- y132    m>-- -- -- y3      YD YC -- --
   or   eax,edx                     ; < YD YC YB YA>.                           >YD YC YB YA         -- -- -- y132      -- -- -- y3     <YD YC -- --
  mov   edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               YD YC YB YA         -- -- -- y132      -- -- -- y3    m>C1 C1 C0 C0
   rol  edx,16                      ; Swap dither pattern.                       YD YC YB YA         -- -- -- y132      -- -- -- y3     >C0 C0 C1 C1
  sub   esp,1536

Line1Loop:

  add   eax,edx                       ; < PA PB PC PD>.                         >PD PC PB PA         -- -- -- y132      -- -- -- y3     <C0 C0 C1 C1
   add  ebx,ecx                       ; Add y3 to y132.                          PD PC PB PA        >-- -- -- y132+y3  <-- -- -- y3      C0 C0 C1 C1
  shr   ebx,1                         ; yh = (y3 + y132) / 2.                    PD PC PB PA        >-- -- -- yh        -- -- -- y3      C0 C0 C1 C1
   mov  dh,PB YDither[ebx+6]          ; Fetch YH.                                PD PC PB PA        <-- -- -- yh        -- -- -- y3    m>C0 C0 YH C1
  mov   bl,[esi+ebp+3]                ; Fetch y131.                              PD PC PB PA       m>-- -- -- y131      -- -- -- y3      C0 C0 YH C1
   add  ecx,ebx                       ; Add y131 to y3.                          PD PC PB PA        <-- -- -- y131     >-- -- -- y3+y131 C0 C0 YH C1
  shr   ecx,1                         ; yg = (y3 + y131) / 2.                    PD PC PB PA         -- -- -- y131     >-- -- -- yg      C0 C0 YH C1
   mov  dl,PB YDither[ecx+0]          ; Fetch YG.                                PD PC PB PA         -- -- -- y131     <-- -- -- yg    m>C0 C0 YH YG
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PD PC PB PA         -- -- -- y131      -- -- -- yg      C0 C0 YH YG
   shl  edx,16                        ; Extract YH YG.                           PD PC PB PA         -- -- -- y131      -- -- -- yg     >YH YG -- --
  mov   cl,[esi+2]                    ; Fetch y2.                                PD PC PB PA         -- -- -- y131    m>-- -- -- y2      YH YG -- --
   add  ebx,ecx                       ; Add y2 to y131.                          PD PC PB PA        >-- -- -- y131+y0  <-- -- -- y2      YH YG -- --
  shr   ebx,1                         ; yf = (y2 + y131) / 2.                    PD PC PB PA        >-- -- -- yf        -- -- -- y2      YH YG -- --
   mov  ah,PB YDither[ebx+4]          ; Fetch YF.                              m>PD PC YF PA        <-- -- -- yf        -- -- -- y2      YH YG -- --
  mov   bl,[esi+ebp+2]                ; Fetch y130.                              PD PC YF PA       m>-- -- -- y130      -- -- -- y2      YH YG -- --
   add  ecx,ebx                       ; Add y2 to y130.                          PD PC YF PA        <-- -- -- y130     >-- -- -- y2+y130 YH YG -- --
  shr   ecx,1                         ; ye = (y2 + y130) / 2.                    PD PC YF PA         -- -- -- y130     >-- -- -- ye      YH YG -- --
   mov  al,PB YDither[ecx+2]          ; Fetch YE.                                PD PC YF YE         -- -- -- y130     <-- -- -- ye      YH YG -- --
  add   esi,4                         ; Advance cursor.                          PD PC YF YE         -- -- -- y130      -- -- -- ye      YH YG -- --
   and  eax,00000FFFFH                ; Extract YF YE.                          >-- -- YF YE         -- -- -- y130      -- -- -- ye      YH YG -- --
  mov   bl,[esi+ebp+2]                ; Fetch y134.                              -- -- YF YE       m>-- -- -- y134      -- -- -- ye      YH YG -- --
   or   eax,edx                       ; < YH YG YF YE>.                         >YH YG YF YE         -- -- -- y134      -- -- -- ye     <YH YG -- --
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             YH YG YF YE         -- -- -- y134      -- -- -- ye    s>C3 C3 C2 C2
   rol  edx,16                        ; Swap dither pattern.                     YH YG YF YE         -- -- -- y134      -- -- -- ye     >C2 C2 C3 C3
  add   esp,8                         ;                                          YH YG YF YE         -- -- -- y134      -- -- -- ye      C2 C2 C3 C3
   add  eax,edx                       ; < PH PG PF PE>.                         >PH PG PF PE         -- -- -- y134      -- -- -- ye     <C2 C2 C3 C3
  mov   cl,[esi+1]                    ; Fetch y5.                                PH PG PF PE         -- -- -- y134    m>-- -- -- y5      C2 C2 C3 C3
   mov  Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PH PG PF PE         -- -- -- y134      -- -- -- y5      C2 C2 C3 C3
  add   ebx,ecx                       ; Add y5 to y134.                          PH PG PF PE        >-- -- -- y134+y5  <-- -- -- y5      C2 C2 C3 C3
   shr  ebx,1                         ; yl = (y5 + y134) / 2.                    PH PG PF PE        >-- -- -- yl        -- -- -- y5      C2 C2 C3 C3
  mov   dh,PB YDither[ebx+6]          ; Fetch YL.                                PH PG PF PE        <-- -- -- yl        -- -- -- y5    m>C2 C2 YL C3
   mov  bl,[esi+ebp+1]                ; Fetch y133.                              PH PG PF PE       m>-- -- -- y133      -- -- -- y5      C2 C2 YL C3
  add   ecx,ebx                       ; Add y133 to y5.                          PH PG PF PE        <-- -- -- y133     >-- -- -- y5+y133 C2 C2 YL C3
   shr  ecx,1                         ; yk = (y5 + y133) / 2.                    PH PG PF PE         -- -- -- y133     >-- -- -- yk      C2 C2 YL C3
  mov   dl,PB YDither[ecx+0]          ; Fetch YK.                                PH PG PF PE         -- -- -- y133     <-- -- -- yk    m>C2 C2 YL YK
   shl  edx,16                        ; Extract YL YK.                           PH PG PF PE         -- -- -- y133      -- -- -- yk     >YL YK -- --
  mov   cl,[esi]                      ; Fetch y4.                                PH PG PF PE         -- -- -- y133    m>-- -- -- y4      YL YK -- --
   add  ebx,ecx                       ; Add y4 to y133.                          PH PG PF PE        >-- -- -- y133+y4  <-- -- -- y4      YL YK -- --
  shr   ebx,1                         ; yj = (y4 + y133) / 2.                    PH PG PF PE        >-- -- -- yj        -- -- -- y4      YL YK -- --
   mov  ah,PB YDither[ebx+4]          ; Fetch YJ.                              m>PH PG YJ PE        <-- -- -- yj        -- -- -- y4      YL YK -- --
  mov   bl,[esi+ebp]                  ; Fetch y132.                              PH PG YJ PE       m>-- -- -- y132      -- -- -- y4      YL YK -- --
   add  ecx,ebx                       ; Add y4 to y132.                          PH PG YJ PE        <-- -- -- y132     >-- -- -- y4+y132 YL YK -- --
  shr   ecx,1                         ; yi = (y4 + y132) / 2.                    PH PG YJ PE         -- -- -- y132     >-- -- -- yi      YL YK -- --
   mov  al,PB YDither[ecx+2]          ; Fetch YI.                                PH PG YJ YI         -- -- -- y132     <-- -- -- yi      YL YK -- --
  and   eax,00000FFFFH                ; Extract YJ YI.                          >-- -- YJ YI         -- -- -- y132      -- -- -- yi      YL YK -- --
   mov  bl,[esi+ebp+4]                ; Fetch y136.                              -- -- YJ YI       m>-- -- -- y136      -- -- -- yi      YL Yk -- --
  or    eax,edx                       ; < YL YK YJ YI>.                         >YL YK YJ YI         -- -- -- y136      -- -- -- yi      YL YK -- --
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             YL YK YJ YI         -- -- -- y136      -- -- -- yi    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     YL YK YJ YI         -- -- -- y136      -- -- -- yi     >C4 C4 C5 C5
   mov  cl,[esi+3]                    ; Fetch y7.                                YL YK YJ YI         -- -- -- y136    m>-- -- -- y7      C4 C4 C5 C5
  test  edx,edx
   jne  Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

; Now color convert the second input line of luma.

  mov   esi,YCursor                 ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+ebp*1]              ; Fetch y0.                                  XX XX XX XX       m>-- -- -- y0        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y0        -- -- -- --      -- -- -- --
  mov   cl,[esi+ebp*1+1]            ; Fetch y1.                                  XX XX XX XX         -- -- -- y0      m>-- -- -- y1      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y0        -- -- -- y1      -- -- -- --
  mov   dh,PB YDither[ebx+6]        ; Fecth Y0.                                  XX XX XX XX         -- -- -- y0        -- -- -- y1      -- -- Y0 --
   add  ebx,ecx                     ; Add y1 to y0.                              XX XX XX XX        >-- -- -- y0+y1    <-- -- -- y1      -- -- Y0 --
  shr   ebx,1                       ; ya = (y0 + y1) / 2.                        XX XX XX XX        >-- -- -- ya        -- -- -- y1      -- -- Y0 --
   mov  dl,PB YDither[ebx+0]        ; Fetch YA.                                  XX XX XX XX        <-- -- -- ya        -- -- -- y1    m>-- -- Y0 YA
  sub   edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- ya        -- -- -- y1      -- -- Y0 YA
   shl  edx,16                      ; Extract Y0 YA                              XX XX XX XX         -- -- -- ya        -- -- -- y1     >Y0 YA -- --
  sub   edi,esi                     ;                                            XX XX XX XX         -- -- -- ya        -- -- -- y1      Y0 YA -- --
   mov  bl,[esi+ebp*1+2]            ; Fetch y2.                                  XX XX XX XX       m>-- -- -- y2        -- -- -- y1      Y0 YA -- --
  mov   ah,PB YDither[ecx+4]        ; Fetch Y1.                                m>XX XX Y1 XX         -- -- -- y2       <-- -- -- y1      Y0 YA -- --
   add  ecx,ebx                     ; Add y2 to y1.                              XX XX Y1 XX         -- -- -- y2       >-- -- -- y1+y2   Y0 YA -- --
  shr   ecx,1                       ; yb = (y1 + y2) / 2.                        XX XX Y1 XX         -- -- -- y2       >-- -- -- yb      Y0 YA -- --
   mov  al,PB YDither[ecx+2]        ; Fetch YB.                                m>XX XX Y1 YB         -- -- -- y2       <-- -- -- yb      Y0 YA -- --
  and   eax,00000FFFFH              ; Extract Y1 YB.                            >-- -- Y1 YB         -- -- -- y2        -- -- -- yb      Y0 YA -- --
   mov  cl,[esi+ebp*1+3]            ; Fetch y3.                                  -- -- Y1 YB         -- -- -- y2      m>-- -- -- y3      Y0 YA -- --
  or    eax,edx                     ; < Y0 YA Y1 YB>.                           >Y0 YA Y1 YB         -- -- -- y2        -- -- -- y3     <Y0 YA -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y0 YA Y1 YB         -- -- -- y2        -- -- -- y3    m>C1 C1 C0 C0
  rol   edx,16                      ; Swap dither pattern.                       Y0 YA Y1 YB         -- -- -- y2        -- -- -- y3     >C0 C0 C1 C1
   sub  esp,1536

Line2Loop:

  add   eax,edx                       ; < P0 PA P1 PB>.                         >P0 PA P1 PB         -- -- -- y2        -- -- -- y3      C0 C0 C1 C1
   mov  dh,PB YDither[ebx+6]          ; Fecth Y2.                                P0 PA P1 PB        <-- -- -- y2        -- -- -- y3    m>C0 C0 Y2 C1
  add   ebx,ecx                       ; Add y3 to y2.                            P0 PA P1 PB        >-- -- -- y2+y3    <-- -- -- y3      C0 C0 Y2 C1
   shr  ebx,1                         ; yc = (y2 + y3) / 2.                      P0 PA P1 PB        >-- -- -- yc        -- -- -- y3      C0 C0 Y2 C1
  mov   dl,PB YDither[ebx+0]          ; Fetch YC.                                P0 PA P1 PB        <-- -- -- yc        -- -- -- y3    m>C0 C0 Y2 YC
   bswap eax                          ; < PB P1 PA P0>.                         >PB P1 PA P0         -- -- -- yc        -- -- -- y3      C0 C0 Y2 YC
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PB P1 PA P0         -- -- -- yc        -- -- -- y3      C0 C0 Y2 YC
   add  esi,4                         ;                                          PB P1 PA P0         -- -- -- yc        -- -- -- y3      C0 C0 Y2 YC
  shl   edx,16                        ; Extract Y2 YC.                           PB P1 PA P0         -- -- -- yc        -- -- -- y3     >Y2 YC -- --
   mov  bl,[esi+ebp*1]                ; Fetch y4.                                PB P1 PA P0       m>-- -- -- y4        -- -- -- y3      Y2 YC -- --
  mov   ah,PB YDither[ecx+4]          ; Fetch Y3.                              m>PB P1 Y3 P0         -- -- -- y4       <-- -- -- y3      Y2 YC -- --
   add  ecx,ebx                       ; Add y4 to y3.                            PB P1 Y3 P0         -- -- -- y4       >-- -- -- y4+y4   Y2 YC -- --
  shr   ecx,1                         ; yd = (y3 + y4) / 2.                      PB P1 Y3 P0         -- -- -- y4       >-- -- -- yd      Y2 YC -- --
   mov  al,PB YDither[ecx+2]          ; Fetch YD.                              m>PB P1 Y3 YD         -- -- -- y4       <-- -- -- yd      Y2 YC -- --
  and   eax,00000FFFFH                ; Extract Y3 YD.                          >-- -- Y3 YD         -- -- -- y4        -- -- -- yd      Y2 YC -- --
   or   eax,edx                       ; < Y2 YC Y3 YD>.                         >Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd     <Y2 YC -- --
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd    s>C3 C3 C2 C2
   rol  edx,16                        ; Swap dither pattern.                     Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd    s>C2 C2 C3 C3
  add   esp,8                         ;                                          Y2 YC Y3 YD         -- -- -- y4        -- -- -- yd      C2 C2 C3 C3
   add  eax,edx                       ; < P2 PC P3 PD>.                         >P2 PC P3 PD         -- -- -- y4        -- -- -- yd     <C2 C2 C3 C3
  mov   cl,[esi+ebp*1+1]              ; Fetch next y5.                           P2 PC P3 PD         -- -- -- y4      m>-- -- -- y5      C2 C2 C3 C3
   bswap eax                          ; < PD P3 PC P2>.                         >PD P3 PC P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PD P3 PC P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
   mov  dh,PB YDither[ebx+6]          ; Fecth Y4.                                PD P3 PC P2        <-- -- -- y4        -- -- -- y5    m>C2 C2 Y4 C3
  add   ebx,ecx                       ; Add y5 to y4.                            PD P3 PC P2        >-- -- -- y4+y5    <-- -- -- y5      C2 C2 Y4 C3
   shr  ebx,1                         ; ye = (y4 + y5) / 2.                      PD P3 PC P2        >-- -- -- ye        -- -- -- y5      C2 C2 Y4 C3
  mov   dl,PB YDither[ebx+0]          ; Fetch YE.                                PD P3 PC P2        <-- -- -- ye        -- -- -- y5    m>C2 C2 Y4 YE
   shl  edx,16                        ; Extract Y4 YE.                           PD P3 PC P2         -- -- -- ye        -- -- -- y5     >Y4 YE -- --
  mov   bl,[esi+ebp*1+2]              ; Fetch y6.                                PD P3 PC P2       m>-- -- -- y6        -- -- -- y5      Y4 YE -- --
   mov  ah,PB YDither[ecx+4]          ; Fetch Y5.                              m>PD P3 Y5 P2         -- -- -- y6       <-- -- -- y5      Y4 YE -- --
  add   ecx,ebx                       ; Add y6 to y5.                            PD P3 Y5 P2         -- -- -- y6       >-- -- -- y5+y6   Y4 YE -- --
   shr  ecx,1                         ; yf = (y5 + y6) / 2.                      PD P3 Y5 P2         -- -- -- y6       >-- -- -- yf      Y4 YE -- --
  mov   al,PB YDither[ecx+2]          ; Fetch YF.                              m>PD P3 Y5 YF         -- -- -- y6       <-- -- -- yf      Y4 YE -- --
   and  eax,00000FFFFH                ; Extract Y5 YF.                          >-- -- Y5 YF         -- -- -- y6        -- -- -- yf      Y4 YE -- --
  or    eax,edx                       ; < Y4 YE Y5 YF>.                         >Y4 YE Y5 YF         -- -- -- y6        -- -- -- yf      Y4 YE -- --
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             Y4 YE Y5 YF         -- -- -- y6        -- -- -- yf    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     Y4 YE Y5 YF         -- -- -- y6        -- -- -- yf     >C4 C4 C5 C5
   mov  cl,[esi+ebp*1+3]              ; Fetch y7.                                Y4 YE Y5 YF         -- -- -- y6      m>-- -- -- y7      C4 C4 C5 C5
  test  edx,edx
   jne  Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   esi,YCursor
   mov  edx,AspectCount
  mov   edi,CCOCursor               ; Fetch output cursor.
   sub  edx,2
  lea   eax,[esi+ebp*2]             ; Compute start of next line.
   mov  AspectCount,edx
  mov   YCursor,eax
   jg   KeepLine3

  add   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

   mov  bl,[esi+ebp*2+2]            ; Fetch y130.                                XX XX XX XX       m>-- -- -- y130      -- -- -- --      XX XX XX XX
  mov   eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- y130      -- -- -- --      XX XX XX XX
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y130      -- -- -- --      XX XX XX XX
  mov   cl,[esi+ebp+1]              ; Fetch y1.                                  XX XX XX XX         -- -- -- y130    m>-- -- -- y1      XX XX XX XX
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y130      -- -- -- y1      XX XX XX XX
  add   ebx,ecx                     ; Add y1 to y130.                            XX XX XX XX        >-- -- -- y130+y1  <-- -- -- y1      XX XX XX XX
   shr  ebx,1                       ; yd = (y1 + y130) / 2.                      XX XX XX XX        >-- -- -- yd        -- -- -- y1      XX XX XX XX
  mov   al,PB YDither[ebx+0]        ; Fetch YD.                                m>XX XX XX YD        <-- -- -- yd        -- -- -- y1      XX XX XX XX
   mov  bl,[esi+ebp+1]              ; Fetch y129.                                XX XX XX YD       m>-- -- -- y129      -- -- -- y1      XX XX XX XX
  add   ecx,ebx                     ; Add y129 to y1.                            XX XX XX YD        <-- -- -- y129     >-- -- -- y1+y129 XX XX XX XX
   shr  ecx,1                       ; yc = (y1 + y129) / 2.                      XX XX XX YD         -- -- -- y129     >-- -- -- yc      XX XX XX XX
  mov   ah,PB YDither[ecx+6]        ; Fetch YC.                                m>XX XX YC YD         -- -- -- y129     <-- -- -- yc      XX XX XX XX
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX YC YD         -- -- -- y129      -- -- -- yc      XX XX XX XX
  and   eax,00000FFFFH              ; Extract YD YC.                            >-- -- YC YD         -- -- -- y129      -- -- -- yc      XX XX XX XX
   sub  edi,esi                     ;                                            -- -- YC YD         -- -- -- y129      -- -- -- yc      XX XX XX XX
  mov   cl,[esi+ebp]                ; Fetch y0.                                  -- -- YC YD         -- -- -- y129    m>-- -- -- y0      XX XX XX XX
   add  ebx,ecx                     ; Add y0 to y129.                            -- -- YC YD        >-- -- -- y129+y0  <-- -- -- y0      XX XX XX XX
  shr   ebx,1                       ; yb = (y0 + y129) / 2.                      -- -- YC YD        >-- -- -- yb        -- -- -- y0      XX XX XX XX
   mov  dl,PB YDither[ebx+2]        ; Fetch YB.                                  -- -- YC YD        <-- -- -- yb        -- -- -- y0    m>XX XX XX YB
  mov   bl,[esi+ebp*2]              ; Fetch y128.                                -- -- YC YD       m>-- -- -- y128      -- -- -- y0      XX XX XX YB
   add  ecx,ebx                     ; Add y0 to y128.                            -- -- YC YD        <-- -- -- y128     >-- -- -- y0+y128 XX XX XX YB
  shr   ecx,1                       ; ya = (y0 + y128) / 2.                      -- -- YC YD         -- -- -- y128     >-- -- -- ya      XX XX XX YB
   mov  dh,PB YDither[ecx+4]        ; Fetch YA.                                  -- -- YC YD         -- -- -- y128     <-- -- -- ya    m>XX XX YA YB
  mov   bl,[esi+ebp*2+4]            ; Fetch y132.                                -- -- YC YD       m>-- -- -- y132      -- -- -- ya      XX XX YA YB
   shl  edx,16                      ; Extract YB YA.                             -- -- YC YD         -- -- -- y132      -- -- -- ya     >YA YB -- --
  mov   cl,[esi+ebp+3]              ; Fetch y3.                                  -- -- YC YD         -- -- -- y132    m>-- -- -- y3      YA YB -- --
   or   eax,edx                     ; < YD YC YB YA>.                           >YA YB YC YD         -- -- -- y132      -- -- -- y3     <YA YB -- --
  mov   edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               YA YB YC YD         -- -- -- y132      -- -- -- y3    m>C1 C1 C0 C0
   sub  esp,1536

Line3Loop:

  add   eax,edx                       ; < PA PB PC PD>.                         >PA PB PC PD         -- -- -- y132      -- -- -- y3     <C1 C1 C0 C0
   add  ebx,ecx                       ; Add y3 to y132.                          PA PB PC PD        >-- -- -- y132+y3  <-- -- -- y3      C1 C1 C0 C0
  shr   ebx,1                         ; yh = (y3 + y132) / 2.                    PA PB PC PD        >-- -- -- yh        -- -- -- y3      C1 C1 C0 C0
   mov  dl,PB YDither[ebx+0]          ; Fetch YH.                                PA PB PC PD        <-- -- -- yh        -- -- -- y3    m>C1 C1 C0 YH
  bswap eax                           ;                                         >PD PC PB PA         -- -- -- yh        -- -- -- y3      C1 C1 C0 YH
  mov   bl,[esi+ebp*2+3]              ; Fetch y131.                              PD PC PB PA       m>-- -- -- y131      -- -- -- y3      C1 C1 C0 YH
   add  ecx,ebx                       ; Add y131 to y3.                          PD PC PB PA        <-- -- -- y131     >-- -- -- y3+y131 C1 C1 C0 YH
  shr   ecx,1                         ; yg = (y3 + y131) / 2.                    PD PC PB PA         -- -- -- y131     >-- -- -- yg      C1 C1 C0 YH
   mov  dh,PB YDither[ecx+6]          ; Fetch YG.                                PD PC PB PA         -- -- -- y131     <-- -- -- yg    m>C1 C1 YG YH
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<PD PC PB PA         -- -- -- y131      -- -- -- yg      C1 C1 YG YH
   and  edx,00000FFFFH                ; Extract YG YH.                           PD PC PB PA         -- -- -- y131      -- -- -- yg     >-- -- YG YH
  mov   cl,[esi+ebp+2]                ; Fetch y2.                                PD PC PB PA         -- -- -- y131    m>-- -- -- y2      -- -- YG YH
   add  ebx,ecx                       ; Add y2 to y131.                          PD PC PB PA        >-- -- -- y131+y0  <-- -- -- y2      -- -- YG YH
  shr   ebx,1                         ; yf = (y2 + y131) / 2.                    PD PC PB PA        >-- -- -- yf        -- -- -- y2      -- -- YG YH
   mov  al,PB YDither[ebx+2]          ; Fetch YF.                              m>PD PC PB YF        <-- -- -- yf        -- -- -- y2      -- -- YG YH
  mov   bl,[esi+ebp*2+2]              ; Fetch y130.                              PD PC PB YF       m>-- -- -- y130      -- -- -- y2      -- -- YG YH
   add  ecx,ebx                       ; Add y2 to y130.                          PD PC PB YF        <-- -- -- y130     >-- -- -- y2+y130 -- -- YG YH
  shr   ecx,1                         ; ye = (y2 + y130) / 2.                    PD PC PB YF         -- -- -- y130     >-- -- -- ye      -- -- YG YH
   mov  ah,PB YDither[ecx+4]          ; Fetch YE.                                PD PC YE YF         -- -- -- y130     <-- -- -- ye      -- -- YG YH
  add   esi,4                         ; Advance cursor.                          PD PC YE YF         -- -- -- y130      -- -- -- ye      -- -- YG YH
   shl  eax,16                        ; Extract YE YF.                          >YE YF -- --         -- -- -- y130      -- -- -- ye      -- -- YG YH
  mov   bl,[esi+ebp*2+2]              ; Fetch y134.                              YE YF -- --       m>-- -- -- y134      -- -- -- ye      -- -- YG YH
   or   eax,edx                       ; < YH YG YF YE>.                         >YE YF YG YH         -- -- -- y134      -- -- -- ye     <-- -- YG YH
  mov   edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             YE YF YG YH         -- -- -- y134      -- -- -- ye    s>C3 C3 C2 C2
  add   esp,8                         ;                                          YE YF YG YH         -- -- -- y134      -- -- -- ye      C3 C3 C2 C2
   add  eax,edx                       ; < PH PG PF PE>.                         >PE PF PG PH         -- -- -- y134      -- -- -- ye     <C3 C3 C2 C2
  mov   cl,[esi+ebp+1]                ; Fetch y5.                                PE PF PG PH         -- -- -- y134    m>-- -- -- y5      C3 C3 C2 C2
  bswap eax                           ;                                         >PH PG PF PE         -- -- -- y134      -- -- -- y5      C3 C3 C2 C2
   mov  Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<PH PG PF PE         -- -- -- y134      -- -- -- y5      C3 C3 C2 C2
  add   ebx,ecx                       ; Add y5 to y134.                          PH PG PF PE        >-- -- -- y134+y5  <-- -- -- y5      C3 C3 C2 C2
   shr  ebx,1                         ; yl = (y5 + y134) / 2.                    PH PG PF PE        >-- -- -- yl        -- -- -- y5      C3 C3 C2 C2
  mov   dl,PB YDither[ebx+0]          ; Fetch YL.                                PH PG PF PE        <-- -- -- yl        -- -- -- y5    m>C3 C3 C2 YL
   mov  bl,[esi+ebp*2+1]              ; Fetch y133.                              PH PG PF PE       m>-- -- -- y133      -- -- -- y5      C3 C3 C2 YL
  add   ecx,ebx                       ; Add y133 to y5.                          PH PG PF PE        <-- -- -- y133     >-- -- -- y5+y133 C3 C3 C2 YL
   shr  ecx,1                         ; yk = (y5 + y133) / 2.                    PH PG PF PE         -- -- -- y133     >-- -- -- yk      C3 C3 C2 YL
  mov   dh,PB YDither[ecx+6]          ; Fetch YK.                                PH PG PF PE         -- -- -- y133     <-- -- -- yk    m>C3 C3 YK YL
   and  edx,00000FFFFH                ; Extract YK YL.                           PH PG PF PE         -- -- -- y133      -- -- -- yk     >-- -- YK YL
  mov   cl,[esi+ebp]                  ; Fetch y4.                                PH PG PF PE         -- -- -- y133    m>-- -- -- y4      -- -- YK YL
   add  ebx,ecx                       ; Add y4 to y133.                          PH PG PF PE        >-- -- -- y133+y4  <-- -- -- y4      -- -- YK YL
  shr   ebx,1                         ; yj = (y4 + y133) / 2.                    PH PG PF PE        >-- -- -- yj        -- -- -- y4      -- -- YK YL
   mov  al,PB YDither[ebx+2]          ; Fetch YJ.                              m>PH PG PF YJ        <-- -- -- yj        -- -- -- y4      -- -- YK YL
  mov   bl,[esi+ebp*2]                ; Fetch y132.                              PH PG PF YJ       m>-- -- -- y132      -- -- -- y4      -- -- YK YL
   add  ecx,ebx                       ; Add y4 to y132.                          PH PG PF YJ        <-- -- -- y132     >-- -- -- y4+y132 -- -- YK YL
  shr   ecx,1                         ; yi = (y4 + y132) / 2.                    PH PG PF YJ         -- -- -- y132     >-- -- -- yi      -- -- YK YL
   mov  ah,PB YDither[ecx+4]          ; Fetch YI.                                PH PG YI YJ         -- -- -- y132     <-- -- -- yi      -- -- YK YL
  shl   eax,16                        ; Extract YI YJ.                          >YI YJ -- --         -- -- -- y132      -- -- -- yi      -- -- YK YL
   mov  bl,[esi+ebp*2+4]              ; Fetch y136.                              YI YJ -- --       m>-- -- -- y136      -- -- -- yi      -- -- YK YL
  or    eax,edx                       ; < YL YK YJ YI>.                         >YI YJ YK YL         -- -- -- y136      -- -- -- yi      -- -- YK YL
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             YI YJ YK YL         -- -- -- y136      -- -- -- yi    s>C5 C5 C4 C4
   mov  cl,[esi+ebp+3]                ; Fetch y7.                                YI YJ YK YL         -- -- -- y136    m>-- -- -- y7      C5 C5 C4 C4
  test  edx,edx
   jne  Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextTwoLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8ZoomBy2 endp

ELSE

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8ZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi
  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   ChromaLineLen,ebx
   mov  YLimit,edx

NextTwoLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8 
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.
                                       ;                                         EAX                 EBX                ECX              EDX              EBP
  mov   [esi],edx                   ; Stash EOL indication.
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+1]                  ; Fetch Y01.                                 XX XX XX XX       m>-- -- -- y1        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      -- -- -- --
  mov   cl,[esi]                    ; Fetch Y00.                                 XX XX XX XX         -- -- -- y1      m>-- -- -- y0      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      -- -- -- --
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.               XX XX XX XX        <-- -- -- y1        -- -- -- y0    m>Y1 Y1 Y1 Y1
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 Y1 Y1
  and   edx,0FFFF0000H              ; Extract < Y01  Y01  ___  ___>.             XX XX XX XX         -- -- -- y1        -- -- -- y0     >Y1 Y1 -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 -- --
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.             m>Y0 Y0 Y0 Y0         -- -- -- y1       <-- -- -- y0      Y1 Y1 -- --
   mov  bl,[esi+3]                  ; Fetch Y03.                                 Y0 Y0 Y0 Y0       m>-- -- -- y3        -- -- -- y0      Y1 Y1 -- --
  and   eax,00000FFFFH              ; Extract < ___  ___  Y00  Y00>.            >-- -- Y0 Y0         -- -- -- y3        -- -- -- y0      Y1 Y1 -- --
   mov  cl,[esi+2]                  ; Fetch Y02.                                 -- -- Y0 Y0         -- -- -- y3      m>-- -- -- y2      Y1 Y1 -- --
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     <Y1 Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  sub   esp,1536

Line0Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     <C1 C1 C0 C0
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P1 P1 P0 P0        <-- -- -- y3        -- -- -- y2    m>Y3 Y3 Y3 Y3
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
   add  esi,4                         ; Advance cursor.                          P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  and   edx,0FFFF0000H                ; Extract < Y03  Y03  ___  ___>.           P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     >Y3 Y3 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y2 Y2 Y2 Y2         -- -- -- y3       <-- -- -- y2      Y3 Y3 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y02  Y02>.          >-- -- Y2 Y2         -- -- -- y3        -- -- -- y2      Y3 Y3 -- --
   mov  bl,[esi+1]                    ; Fetch next Y01.                          -- -- Y2 Y2       m>-- -- -- y5        -- -- -- y2      Y3 Y3 -- --
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2     <Y3 Y3 -- --
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2    s>C3 C3 C2 C2
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P3 P3 P2 P2         -- -- -- y5        -- -- -- y2     <C3 C3 C2 C2
   mov  cl,[esi]                      ; Fetch next Y00.                          P3 P3 P2 P2         -- -- -- y5      m>-- -- -- y4      C3 C3 C2 C2
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P3 P3 P2 P2         -- -- -- y5        -- -- -- y4      C3 C3 C2 C2
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P3 P3 P2 P2        <-- -- -- y5        -- -- -- y4    m>Y5 Y5 Y5 Y5
  and   edx,0FFFF0000H                ; Extract < Y01  Y01  ___  ___>.           P3 P3 P2 P2         -- -- -- y5        -- -- -- y4     >Y5 Y5 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y4 Y4 Y4 Y4         -- -- -- y5       <-- -- -- y4      Y5 Y5 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y00  Y00>.          >-- -- Y4 Y4         -- -- -- y5        -- -- -- y4      Y5 Y5 -- --
   mov  bl,[esi+3]                    ; Fetch Y03.                               -- -- Y4 Y4       m>-- -- -- y7        -- -- -- y4      Y5 Y5 -- --
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4      Y5 Y5 -- --
   mov  edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.             Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4    s>C5 C5 C4 C4
  add   esp,8                         ;                                          Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4      C5 C5 C4 C4
   mov  cl,[esi+2]                    ; Fetch Y02.                               Y5 Y5 Y4 Y4         -- -- -- y7      m>-- -- -- y6      C5 C5 C4 C4
  test  edx,edx
   jne  Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   edx,AspectCount
   mov  edi,CCOCursor               ; Fetch output cursor.
  sub   edx,2
   mov  eax,CCOPitch                ; Compute start of next line.
  mov   AspectCount,edx
   mov  esi,YCursor                 ; Reload cursor over Y line.
  mov   ebp,AspectAdjustmentCount
   jg   KeepLine1

  add   edx,ebp
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  mov   bl,[esi+1]                  ; Fetch Y01.                                 XX XX XX XX       m>-- -- -- y1        -- -- -- --      XX XX XX XX
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      XX XX XX XX
  mov   cl,[esi]                    ; Fetch Y00.                                 XX XX XX XX         -- -- -- y1      m>-- -- -- y0      XX XX XX XX
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      XX XX XX XX
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.               XX XX XX XX        <-- -- -- y1        -- -- -- y0    m>Y1 Y1 Y1 Y1
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 Y1 Y1
  shl   edx,16                      ; Extract < Y01  Y01  ___  ___>.             XX XX XX XX         -- -- -- y1        -- -- -- y0     >Y1 Y1 -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 -- --
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.             m>Y0 Y0 Y0 Y0         -- -- -- y1       <-- -- -- y0      Y1 Y1 -- --
   mov  bl,[esi+3]                  ; Fetch Y03.                                 Y0 Y0 Y0 Y0       m>-- -- -- y3        -- -- -- y0      Y1 Y1 -- --
  shr   eax,16                      ; Extract < ___  ___  Y00  Y00>.            >-- -- Y0 Y0         -- -- -- y3        -- -- -- y0      Y1 Y1 -- --
   mov  cl,[esi+2]                  ; Fetch Y02.                                 -- -- Y0 Y0         -- -- -- y3      m>-- -- -- y2      Y1 Y1 -- --
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     <Y1 Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  rol   edx,16                      ; Swap dither pattern.                       Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     >C0 C0 C1 C1
   sub  esp,1536

Line1Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     <C0 C0 C1 C1
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P1 P1 P0 P0        <-- -- -- y3        -- -- -- y2    m>Y3 Y3 Y3 Y3
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
   add  esi,4                         ; Advance cursor.                          P1 P1 P0 P0         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  shl   edx,16                        ; Extract < Y03  Y03  ___  ___>.           P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     >-- -- Y3 Y3
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y2 Y2 Y2 Y2         -- -- -- y3       <-- -- -- y2      -- -- Y3 Y3
  shr   eax,16                        ; Extract < ___  ___  Y02  Y02>.          >Y2 Y2 -- --         -- -- -- y3        -- -- -- y2      -- -- Y3 Y3
   mov  bl,[esi+1]                    ; Fetch next Y01.                          Y2 Y2 -- --       m>-- -- -- y5        -- -- -- y2      -- -- Y3 Y3
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2     <-- -- Y3 Y3
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2    s>C3 C3 C2 C2
  rol   edx,16                        ; Swap dither pattern.                     Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2    s>C2 C2 C3 C3
   add  esp,8                         ;                                          Y2 Y2 Y3 Y3         -- -- -- y5        -- -- -- y2      C2 C2 C3 C3
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P2 P2 P3 P3         -- -- -- y5        -- -- -- y2     <C2 C2 C3 C3
   mov  cl,[esi]                      ; Fetch next Y00.                          P2 P2 P3 P3         -- -- -- y5      m>-- -- -- y4      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P2 P2 P3 P3         -- -- -- y5        -- -- -- y4      C2 C2 C3 C3
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P2 P2 P3 P3        <-- -- -- y5        -- -- -- y4    m>Y5 Y5 Y5 Y5
  shl   edx,16                        ; Extract < Y01  Y01  ___  ___>.           P2 P2 P3 P3         -- -- -- y5        -- -- -- y4     >-- -- Y5 Y5
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y4 Y4 Y4 Y4         -- -- -- y5       <-- -- -- y4      -- -- Y5 Y5
  shr   eax,16                        ; Extract < ___  ___  Y00  Y00>.          >Y4 Y4 -- --         -- -- -- y5        -- -- -- y4      -- -- Y5 Y5
   mov  bl,[esi+3]                    ; Fetch Y03.                               Y4 Y4 -- --       m>-- -- -- y7        -- -- -- y4      -- -- Y5 Y5
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y4 Y4 Y5 Y5         -- -- -- y7        -- -- -- y4      -- -- Y5 Y5
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             Y4 Y4 Y5 Y5         -- -- -- y7        -- -- -- y4    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     Y4 Y4 Y5 Y5         -- -- -- y7        -- -- -- y4     >C4 C4 C5 C5
   mov  cl,[esi+2]                    ; Fetch Y02.                               Y4 Y4 Y5 Y5         -- -- -- y7      m>-- -- -- y6      C4 C4 C5 C5
  test  edx,edx
   jne  Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

; Now color convert the second input line of luma.

  mov   esi,YCursor                 ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edi,CCOCursor               ; Fetch output cursor.
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- --        -- -- -- --      -- -- -- --
  mov   bl,[esi+ebp*1]              ; Fetch Y01.                                 XX XX XX XX       m>-- -- -- y1        -- -- -- --      -- -- -- --
   add  eax,edi                     ;                                           >XX XX XX XX         -- -- -- y1        -- -- -- --      -- -- -- --
  mov   cl,[esi+ebp*1+1]            ; Fetch Y00.                                 XX XX XX XX         -- -- -- y1      m>-- -- -- y0      -- -- -- --
   mov  CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y1        -- -- -- y0      -- -- -- --
  mov   edx,PD YDitherZ2[ebx*4]     ; Fetch < Y01  Y01  Y01  Y01>.               XX XX XX XX        <-- -- -- y1        -- -- -- y0    m>Y1 Y1 Y1 Y1
   sub  edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 Y1 Y1
  shl   edx,16                      ; Extract < Y01  Y01  ___  ___>.             XX XX XX XX         -- -- -- y1        -- -- -- y0     >Y1 Y1 -- --
   sub  edi,esi                     ;                                            XX XX XX XX         -- -- -- y1        -- -- -- y0      Y1 Y1 -- --
  mov   eax,PD YDitherZ2[ecx*4]     ; Fetch < Y00  Y00  Y00  Y00>.             m>Y0 Y0 Y0 Y0         -- -- -- y1       <-- -- -- y0      Y1 Y1 -- --
   mov  bl,[esi+ebp*1+2]            ; Fetch Y03.                                 Y0 Y0 Y0 Y0       m>-- -- -- y3        -- -- -- y0      Y1 Y1 -- --
  shr   eax,16                      ; Extract < ___  ___  Y00  Y00>.            >-- -- Y0 Y0         -- -- -- y3        -- -- -- y0      Y1 Y1 -- --
   mov  cl,[esi+ebp*1+3]            ; Fetch Y02.                                 -- -- Y0 Y0         -- -- -- y3      m>-- -- -- y2      Y1 Y1 -- --
  or    eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     <Y1 Y1 -- --
   mov  edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2    m>C1 C1 C0 C0
  rol   edx,16                      ; Swap dither pattern.                       Y1 Y1 Y0 Y0         -- -- -- y3        -- -- -- y2     >C0 C0 C1 C1
   sub  esp,1536

Line2Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P1 P1 P0 P0         -- -- -- y3        -- -- -- y2     <C0 C0 C1 C1
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P1 P1 P0 P0        <-- -- -- y3        -- -- -- y2    m>Y3 Y3 Y3 Y3
  bswap eax                           ;                                         >P0 P0 P1 P1         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P0 P0 P1 P1         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
   add  esi,4                         ;                                          P0 P0 P1 P1         -- -- -- y3        -- -- -- y2      Y3 Y3 Y3 Y3
  shl   edx,16                        ; Extract < Y03  Y03  ___  ___>.           P0 P0 P1 P1         -- -- -- y3        -- -- -- y2     >Y3 Y3 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y2 Y2 Y2 Y2         -- -- -- y3       <-- -- -- y2      Y3 Y3 -- --
  shr   eax,16                        ; Extract < ___  ___  Y02  Y02>.          >-- -- Y2 Y2         -- -- -- y3        -- -- -- y2      Y3 Y3 -- --
   mov  bl,[esi+ebp*1]                ; Fetch next Y01.                          -- -- Y2 Y2       m>-- -- -- y5        -- -- -- y2      Y3 Y3 -- --
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2     <Y3 Y3 -- --
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2    s>C3 C3 C2 C2
  rol   edx,16                        ; Swap dither pattern.                     Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2    s>C2 C2 C3 C3
   add  esp,8                         ; Swap dither pattern.                     Y3 Y3 Y2 Y2         -- -- -- y5        -- -- -- y2      C2 C2 C3 C3
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P3 P3 P2 P2         -- -- -- y5        -- -- -- y2     <C2 C2 C3 C3
   mov  cl,[esi+ebp*1+1]              ; Fetch next Y00.                          P3 P3 P2 P2         -- -- -- y5      m>-- -- -- y4      C2 C2 C3 C3
  bswap eax                           ;                                         >P2 P2 P3 P3         -- -- -- y5        -- -- -- y4      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P2 P2 P3 P3         -- -- -- y5        -- -- -- y4      C2 C2 C3 C3
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P2 P2 P3 P3        <-- -- -- y5        -- -- -- y4    m>Y5 Y5 Y5 Y5
  shl   edx,16                        ; Extract < Y01  Y01  ___  ___>.           P2 P2 P3 P3         -- -- -- y5        -- -- -- y4     >Y5 Y5 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y4 Y4 Y4 Y4         -- -- -- y5       <-- -- -- y4      Y5 Y5 -- --
  shr   eax,16                        ; Extract < ___  ___  Y00  Y00>.          >-- -- Y4 Y4         -- -- -- y5        -- -- -- y4      Y5 Y5 -- --
   mov  bl,[esi+ebp*1+2]              ; Fetch Y03.                               -- -- Y4 Y4       m>-- -- -- y7        -- -- -- y4      Y5 Y5 -- --
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4      Y5 Y5 -- --
   mov  edx,ChromaContribution+1536   ; Fetch <UV01 UV01 UV00 UV00>.             Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4    s>C5 C5 C4 C4
  rol   edx,16                        ; Swap dither pattern.                     Y5 Y5 Y4 Y4         -- -- -- y7        -- -- -- y4     >C4 C4 C5 C5
   mov  cl,[esi+ebp*1+3]              ; Fetch Y02.                               Y5 Y5 Y4 Y4         -- -- -- y7      m>-- -- -- y6      C4 C4 C5 C5
  test  edx,edx
   jne  Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

; Color convert same input line, dithering differently.

  mov   esi,YCursor
   mov  edx,AspectCount
  mov   edi,CCOCursor               ; Fetch output cursor.
   sub  edx,2
  lea   eax,[esi+ebp*2]             ; Compute start of next line.
   mov  AspectCount,edx
  mov   YCursor,eax
   jg   KeepLine3

  add   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  mov   bl,[esi+ebp*1]              ; Fetch Y00.                                 XX XX XX XX       m>-- -- -- y0        -- -- -- --      -- -- -- --
   mov  eax,CCOPitch                ; Compute start of next line.                XX XX XX XX         -- -- -- y0        -- -- -- --      -- -- -- --
  add   eax,edi                     ;                                           >XX XX XX XX         -- -- -- y0        -- -- -- --      -- -- -- --
   mov  cl,[esi+ebp*1+1]            ; Fetch Y01.                                 XX XX XX XX         -- -- -- y0      m>-- -- -- y1      -- -- -- --
  mov   CCOCursor,eax               ; Stash start of next line.                s<XX XX XX XX         -- -- -- y0        -- -- -- y1      -- -- -- --
   mov  edx,PD YDitherZ2[ebx*4]     ; Fetch < Y00  Y00  Y00  Y00>.               XX XX XX XX        <-- -- -- y0        -- -- -- y1    m>Y0 Y0 Y0 Y0
  sub   edi,esi                     ; Get span from Y cursor to CCO cursor.      XX XX XX XX         -- -- -- y0        -- -- -- y1      Y0 Y0 Y0 Y0
   mov  eax,PD YDitherZ2[ecx*4]     ; Fetch < Y01  Y01  Y01  Y01>.             m>Y1 Y1 Y1 Y1         -- -- -- y0       <-- -- -- y1      Y0 Y0 Y0 Y0
  and   edx,0FFFF0000H              ; Extract < ___  ___  Y00  Y00>.             Y1 Y1 Y1 Y1         -- -- -- y0        -- -- -- y1     >Y0 Y0 -- --
   sub  edi,esi                     ;                                            Y1 Y1 Y1 Y1         -- -- -- y0        -- -- -- y1      Y0 Y0 -- --
  mov   bl,[esi+ebp*1+2]            ; Fetch Y02.                                 Y1 Y1 Y1 Y1       m>-- -- -- y2        -- -- -- y1      Y0 Y0 -- --
   and  eax,00000FFFFH              ; Extract < ___  ___  Y01  Y01>.            >-- -- Y1 Y1         -- -- -- y2        -- -- -- y1      Y0 Y0 -- --
  mov   cl,[esi+ebp*1+3]            ; Fetch Y03.                                 -- -- Y1 Y1         -- -- -- y2      m>-- -- -- y3      Y0 Y0 -- --
   or   eax,edx                     ; < Y01  Y01  Y00  Y00>.                    >Y0 Y0 Y1 Y1         -- -- -- y2        -- -- -- y3     <Y0 Y0 -- --
  mov   edx,ChromaContribution      ; Fetch <UV01 UV01 UV00 UV00>.               Y0 Y0 Y1 Y1         -- -- -- y2        -- -- -- y3    m>C1 C1 C0 C0
   sub  esp,1536

Line3Loop:

  add   eax,edx                       ; < P01  P01  P00  P00>.                  >P0 P0 P1 P1         -- -- -- y2        -- -- -- y3     <C1 C1 C0 C0
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y03  Y03  Y03  Y03>.             P0 P0 P1 P1        <-- -- -- y2        -- -- -- y3    m>Y2 Y2 Y2 Y2
  bswap eax                           ;                                         >P1 P1 P0 P0         -- -- -- y2        -- -- -- y3      Y2 Y2 Y2 Y2
  mov   Ze [edi+esi*2],eax            ; Store four pels to color conv output.  m<P1 P1 P0 P0         -- -- -- y2        -- -- -- y3      Y2 Y2 Y2 Y2
   add  esi,4                         ;                                          P1 P1 P0 P0         -- -- -- y2        -- -- -- y3      Y2 Y2 Y2 Y2
  and   edx,0FFFF0000H                ; Extract < Y03  Y03  ___  ___>.           P1 P1 P0 P0         -- -- -- y2        -- -- -- y3     >Y2 Y2 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y02  Y02  Y02  Y02>.           m>Y3 Y3 Y3 Y3         -- -- -- y2       <-- -- -- y3      Y2 Y2 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y02  Y02>.          >-- -- Y3 Y3         -- -- -- y2        -- -- -- y3      Y2 Y2 -- --
   mov  bl,[esi+ebp*1]                ; Fetch next Y01.                          -- -- Y3 Y3       m>-- -- -- y4        -- -- -- y3      Y2 Y2 -- --
  or    eax,edx                       ; < Y03  Y03  Y02  Y02>.                  >Y2 Y2 Y3 Y3         -- -- -- y4        -- -- -- y3     <Y2 Y2 -- --
   mov  edx,ChromaContribution+1536+4 ; Fetch <UV03 UV03 UV02 UV02>.             Y2 Y2 Y3 Y3         -- -- -- y4        -- -- -- y3    s>C3 C3 C2 C2
  add   eax,edx                       ; < P03  P03  P02  P02>.                  >P2 P2 P3 P3         -- -- -- y4        -- -- -- y3     <C2 C2 C3 C3
   mov  cl,[esi+ebp*1+1]              ; Fetch next Y00.                          P2 P2 P3 P3         -- -- -- y4      m>-- -- -- y5      C2 C2 C3 C3
  bswap eax                           ;                                         >P3 P3 P2 P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
  mov   Ze [edi+esi*2+4-8],eax        ; Store four pels to color conv output.  m<P3 P3 P2 P2         -- -- -- y4        -- -- -- y5      C2 C2 C3 C3
   mov  edx,PD YDitherZ2[ebx*4]       ; Fetch < Y01  Y01  Y01  Y01>.             P3 P3 P2 P2        <-- -- -- y4        -- -- -- y5    m>Y4 Y4 Y4 Y4
  and   edx,0FFFF0000H                ; Extract < Y01  Y01  ___  ___>.           P3 P3 P2 P2         -- -- -- y4        -- -- -- y5     >Y4 Y4 -- --
   mov  eax,PD YDitherZ2[ecx*4]       ; Fetch < Y00  Y00  Y00  Y00>.           m>Y5 Y5 Y5 Y5         -- -- -- y4       <-- -- -- y5      Y4 Y4 -- --
  and   eax,00000FFFFH                ; Extract < ___  ___  Y00  Y00>.          >-- -- Y5 Y5         -- -- -- y4        -- -- -- y5      Y4 Y4 -- --
   mov  bl,[esi+ebp*1+2]              ; Fetch Y03.                               -- -- Y5 Y5       m>-- -- -- y6        -- -- -- y5      Y4 Y4 -- --
  or    eax,edx                       ; < Y01  Y01  Y00  Y00>.                  >Y4 Y4 Y5 Y5         -- -- -- y6        -- -- -- y5      Y4 Y4 -- --
   mov  edx,ChromaContribution+1536+8 ; Fetch <UV01 UV01 UV00 UV00>.             Y4 Y4 Y5 Y5         -- -- -- y6        -- -- -- y5    s>C5 C5 C4 C4
  add   esp,8                         ; Fetch <UV01 UV01 UV00 UV00>.             Y4 Y4 Y5 Y5         -- -- -- y6        -- -- -- y5      C5 C5 C4 C4 
   mov  cl,[esi+ebp*1+3]              ; Fetch Y02.                               Y4 Y4 Y5 Y5         -- -- -- y6      m>-- -- -- y7      C5 C5 C4 C4
  test  edx,edx
   jne  Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextTwoLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8ZoomBy2 endp

ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx51281.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx51281.asv
;//
;// $Log:   S:\h26x\src\dec\cx51281.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:58:40   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:38   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:06   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:43:28   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   03 Nov 1995 11:49:40   BNICKERS
;// Support YUV12 to CLUT8 zoom and non-zoom color conversions.
;// 
;//    Rev 1.1   26 Oct 1995 09:46:08   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:20   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for the Pentium Microprocessor.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by one, i.e. non-zoom.
; |||||||
; cx51281  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;             It is tuned for best performance on the Pentium(r) Microprocessor.
;             It dithers among 9 chroma points and 26 luma points, mapping the
;             8 bit luma pels into the 26 luma points by clamping the ends and
;             stepping the luma by 8.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToCLUT8 (U8 * YPlane,
;                                     U8 * VPlane,
;                                     U8 * UPlane,
;                                     UN  FrameWidth,
;                                     UN  FrameHeight,
;                                     UN  YPitch,
;                                     UN  VPitch,
;                                     UN  AspectAdjustmentCount,
;                                     U8 * ColorConvertedFrame,
;                                     U32 DCIOffset,
;                                     U32 CCOffsetToLine0,
;                                     IN  CCOPitch,
;                                     IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCnt: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

LocalFrameSize = 64+768*2+4
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType_arg                = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+ 0]
ChromaLineLen            EQU  [esp+ 4]
YLimit                   EQU  [esp+ 8]
YCursor                  EQU  [esp+12]
VCursor                  EQU  [esp+16]
DistanceFromVToU         EQU  [esp+20]
EndOfChromaLine          EQU  [esp+24]
AspectCount              EQU  [esp+28]
FrameWidth               EQU  [esp+32]
ChromaPitch              EQU  [esp+36]
AspectAdjustmentCount    EQU  [esp+40]
LumaPitch                EQU  [esp+44]
CCOPitch                 EQU  [esp+48]
StashESP                 EQU  [esp+52]

ChromaContribution       EQU  [esp+64]

  push  esi
  push  edi
  push  ebp
  push  ebx

  mov   edi,esp
  sub   esp,LocalFrameSize
  and   esp,0FFFFF800H
  mov   eax,[edi+FrameWidth_arg]
  mov   ebx,[edi+ChromaPitch_arg]
  mov   ecx,[edi+AspectAdjustmentCount_arg]
  mov   edx,[edi+YPitch_arg]
  mov   esi,[edi+CCOPitch_arg]
  mov   FrameWidth,eax
  mov   ChromaPitch,ebx
  mov   AspectAdjustmentCount,ecx
  mov   AspectCount,ecx
  mov   LumaPitch,edx
  mov   CCOPitch,esi
  mov   ebx,[edi+VPlane_arg]
  mov   ecx,[edi+UPlane_arg]
  mov   eax,[edi+YPlane_arg]
  sub   ecx,ebx
  mov   DistanceFromVToU,ecx
  mov   VCursor,ebx
  mov   YCursor,eax
  mov   eax,[edi+ColorConvertedFrame]
  add   eax,[edi+DCIOffset]
  add   eax,[edi+CCOffsetToLine0]
  mov   CCOCursor,eax
  mov   StashESP,edi

  mov   edx,[edi+FrameHeight]
   mov  ecx,LumaPitch
  imul  edx,ecx
  mov   ebx,FrameWidth
   mov  esi,YCursor                  ; Fetch cursor over luma plane.
  sar   ebx,1
   add  edx,esi
  mov   YLimit,edx
   mov  ChromaLineLen,ebx

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Cursor over storage to hold preprocessed UV.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    cl  -- V pel value
;    eax -- Scratch

  mov   edi,VCursor                 ; Fetch address of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU        ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                    ; Fetch first V pel.
   ;
  and   ebx,0FCH                    ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]              ; Fetch first U pel.
  and   ecx,0FCH                    ; Reduce to 6 bits.
   mov  VCursor,edx                 ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  bl,[edi+1]                  ; Fetch next V pel.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  cl,[edi+ebp*1+1]            ; Fetch next U pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   and  bl,0FCH                     ; Reduce to 6 bits.
  add   eax,edx                     ; Combine dither patterns for U and V.
   and  cl,0FCH                     ; Reduce to 6 bits.
  mov   edx,PD UVDitherLine01[ebx]  ; Fetch dither pattern for V point.
   mov  [esi],eax                   ; Stash UV corresponding to Y00,Y01,Y10,Y11.
  mov   eax,PD UVDitherLine23[ecx]  ; Fetch dither pattern for U point.
   mov  bl,[edi+2]                  ; Fetch next V pel.
  lea   edx,[edx+edx*2+00A0A0A0AH]  ; Weight V dither pattern.
   mov  cl,[edi+ebp*1+2]            ; Fetch next U pel.
  add   eax,edx                     ; Combine dither patterns for U and V.
   mov  edx,EndOfChromaLine         ; Fetch EOL address.
  mov   [esi+4],eax                 ; Stash UV corresponding to Y02,Y03,Y12,Y13.
   add  edi,2                       ; Advance U plane cursor.
  and   bl,0FCH                     ; Reduce to 6 bits.
   and  cl,0FCH                     ; Reduce to 6 bits.
  add   esi,8
   sub  edx,edi
  jne   @b

; Now color convert a line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Not used.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   [esi],edx                   ; Stash EOL indication.
   mov  edx,AspectCount
  mov   esi,YCursor                 ; Reload cursor over Y line.
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine0

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine0

KeepLine0:

  mov   edi,CCOCursor                 ; Fetch output cursor.
   mov  eax,CCOPitch                  ; Compute start of next line.
  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <UV03 UV02 xxxx xxxx>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+3]                    ; Fetch Y03.
   and  edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
  mov   eax,ChromaContribution        ; Fetch <xxxx xxxx UV01 UV00>.
   sub  esp,1536-8
  and   eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
   mov  cl,[esi+2]                    ; Fetch Y02.

Line0Loop:

  or    eax,edx                       ; <UV03 UV02 UV01 UV00>.
   mov  dh,PB YDither[ebx+4]          ; <xxxx xxxx  Y03 xxxx>.
  mov   dl,PB YDither[ecx+2]          ; <xxxx xxxx  Y03  Y02>.
   mov  bl,PB [esi+1]                 ; Fetch Y01.
  shl   edx,16                        ; < Y03  Y02 xxxx xxxx>.
   mov  cl,PB [esi]                   ; Fetch Y00.
  mov   dh,PB YDither[ebx+6]          ; < Y03  Y02  Y01 xxxx>.
   mov  bl,PB [esi+3+4]               ; Fetch next Y03.
  mov   dl,PB YDither[ecx+0]          ; < Y03  Y02  Y01  Y00>.
   mov  cl,PB [esi+2+4]               ; Fetch next Y02.
  add   eax,edx                       ; < P03  P02  P01  P00>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <UV03 UV02 xxxx xxxx>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <xxxx xxxx UV01 UV00>.
  and   edx,0FFFF0000H                ; <UV03 UV02 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  add   esp,8
   and  eax,00000FFFFH                ; <xxxx xxxx UV01 UV00>.
  jne   Line0Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine0:

; Color convert another line of luma.
;
;  Register Usage
;    edi -- Cursor over line of color converted output frame, minus esi.
;    esi -- Cursor over Y line.
;    ebp -- Y Pitch.
;    edx,eax -- Build output pels.
;    ecx,ebx -- Y pels.

  mov   esi,YCursor                   ; Reload cursor over Y line.
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor                 ; Fetch output cursor.
  lea   eax,[esi+ebp*2]               ; Compute address of next line of Y.
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch                  ; Compute start of next line.
  mov   AspectCount,edx
   jne  KeepLine1

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine1

KeepLine1:

  add   eax,edi
   mov  edx,ChromaContribution+4      ; Fetch <xxxx xxxx UV13 UV12>.
  mov   CCOCursor,eax                 ; Stash start of next line.
   sub  edi,esi                       ; Get span from Y cursor to CCO cursor.
  mov   bl,[esi+ebp*1+3]              ; Fetch Y13.
   mov  eax,ChromaContribution        ; Fetch <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   sub  esp,1536-8
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   mov  cl,[esi+ebp*1+2]              ; Fetch Y12.

Line1Loop:

  or    eax,edx                       ; <UV13 UV12 UV11 UV10>.
   mov  dh,PB YDither[ebx+6]          ; <xxxx xxxx  Y13 xxxx>.
  mov   dl,PB YDither[ecx+0]          ; <xxxx xxxx  Y13  Y12>.
   mov  bl,PB [esi+ebp*1+1]           ; Fetch Y11.
  shl   edx,16                        ; < Y13  Y12 xxxx xxxx>.
   mov  cl,PB [esi+ebp*1]             ; Fetch Y10.
  mov   dh,PB YDither[ebx+4]          ; < Y13  Y12  Y11 xxxx>.
   mov  bl,PB [esi+ebp*1+3+4]         ; Fetch next Y13.
  mov   dl,PB YDither[ecx+2]          ; < Y13  Y12  Y11  Y10>.
   mov  cl,PB [esi+ebp*1+2+4]         ; Fetch next Y12.
  add   eax,edx                       ; < P13  P12  P11  P10>.
   mov  edx,ChromaContribution+1536+4 ; Fetch next <xxxx xxxx UV13 UV12>.
  mov   Ze [edi+esi],eax              ; Store four pels to color conv output.
   mov  eax,ChromaContribution+1536   ; Fetch next <UV11 UV10 xxxx xxxx>.
  shl   edx,16                        ; <UV13 UV12 xxxx xxxx>.
   add  esi,4                         ; Advance input cursor.
  shr   eax,16                        ; <xxxx xxxx UV11 UV10>.
   lea  esp,[esp+8]
  jne   Line1Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine1:

  mov   edi,VCursor                   ; Fetch addr of pel 0 of next line of V.
   mov  ebp,DistanceFromVToU          ; Fetch span from V plane to U plane.
  lea   esi,ChromaContribution
   mov  eax,ChromaLineLen
  mov   edx,ChromaPitch
   add  eax,edi
  mov   EndOfChromaLine,eax
   add  edx,edi
  mov   bl,[edi]                      ; Fetch first V pel.
   ;
  and   ebx,0FCH                      ; Reduce to 6 bits.
   mov  cl,[edi+ebp*1]                ; Fetch first U pel.
  and   ecx,0FCH                      ; Reduce to 6 bits.
   mov  VCursor,edx                   ; Stash for next time around.

@@:

  mov   edx,PD UVDitherLine23[ebx]
   mov  bl,[edi+1]
  mov   eax,PD UVDitherLine01[ecx]
   mov  cl,[edi+ebp*1+1]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   and  bl,0FCH
  add   eax,edx
   and  cl,0FCH
  mov   edx,PD UVDitherLine23[ebx]
   mov  [esi],eax
  mov   eax,PD UVDitherLine01[ecx]
   mov  bl,[edi+2]
  lea   edx,[edx+edx*2+00A0A0A0AH]
   mov  cl,[edi+ebp*1+2]
  add   eax,edx
   mov  edx,EndOfChromaLine
  mov   [esi+4],eax
   add  edi,2
  and   bl,0FCH
   and  cl,0FCH
  add   esi,8
   sub  edx,edi
  jne   @b

  mov   [esi],edx
   mov  edx,AspectCount
  mov   esi,YCursor
   dec  edx
  mov   AspectCount,edx
   jne  KeepLine2

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine2

KeepLine2:

  mov   edi,CCOCursor
   mov  eax,CCOPitch
  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+3]
   and  edx,0FFFF0000H
  mov   eax,ChromaContribution
   sub  esp,1536-8
  and   eax,00000FFFFH
   mov  cl,[esi+2]

Line2Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+2]
  mov   dl,PB YDither[ecx+4]
   mov  bl,PB [esi+1]
  shl   edx,16
   mov  cl,PB [esi]
  mov   dh,PB YDither[ebx+0]
   mov  bl,PB [esi+3+4]
  mov   dl,PB YDither[ecx+6]
   mov  cl,PB [esi+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  and   edx,0FFFF0000H
   add  esi,4
  add   esp,8
   and  eax,00000FFFFH
  jne   Line2Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine2:

  mov   esi,YCursor
   mov  ebp,LumaPitch
  mov   edx,AspectCount
   mov  edi,CCOCursor
  lea   eax,[esi+ebp*2]
   dec  edx
  mov   YCursor,eax
   mov  eax,CCOPitch
  mov   AspectCount,edx
   jne  KeepLine3

  mov   edx,AspectAdjustmentCount
  mov   AspectCount,edx
   jmp  SkipLine3

KeepLine3:

  add   eax,edi
   mov  edx,ChromaContribution+4
  mov   CCOCursor,eax
   sub  edi,esi
  mov   bl,[esi+ebp*1+3]
   mov  eax,ChromaContribution
  shl   edx,16
   sub  esp,1536-8
  shr   eax,16
   mov  cl,[esi+ebp*1+2]

Line3Loop:

  or    eax,edx
   mov  dh,PB YDither[ebx+0]
  mov   dl,PB YDither[ecx+6]
   mov  bl,PB [esi+ebp*1+1]
  shl   edx,16
   mov  cl,PB [esi+ebp*1]
  mov   dh,PB YDither[ebx+2]
   mov  bl,PB [esi+ebp*1+3+4]
  mov   dl,PB YDither[ecx+4]
   mov  cl,PB [esi+ebp*1+2+4]
  add   eax,edx
   mov  edx,ChromaContribution+1536+4
  mov   Ze [edi+esi],eax
   mov  eax,ChromaContribution+1536
  shl   edx,16
   add  esi,4
  shr   eax,16
   lea  esp,[esp+8]
  jne   Line3Loop

  and   esp,0FFFFF800H
  add   esp,0800H

SkipLine3:

  mov   esi,YCursor
   mov  eax,YLimit
  cmp   eax,esi
   jne  NextFourLines

  mov   esp,StashESP
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512yuv.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx512yuv.asv   1.5   30 Dec 1996 20:02:08   MDUDA  $
;//
;// $Log:   S:\h26x\src\dec\cx512yuv.asv  $
;// 
;//    Rev 1.5   30 Dec 1996 20:02:08   MDUDA
;// Fixed problem where buffer boundaries were being over-written.
;// 
;//    Rev 1.4   11 Dec 1996 14:58:52   JMCVEIGH
;// 
;// Changed to support width the are multiples of 4.
;// 
;//    Rev 1.3   18 Jul 1996 12:52:58   KLILLEVO
;// changed cache heating to speed things up a bit 
;// 
;//    Rev 1.2   18 Jul 1996 09:39:34   KLILLEVO
;// 
;// added PVCS header and log

;; Very straightforward implementation of the YUV pitch changer
;; Does 16 pels at a time. If the width is not a multiple of 16
;; the remainder pels are handled as a special case. We assume
;; that the width is at least a multiple of 4

OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUV


YUV12ToYUV   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  12

RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

LineAdd          = 0          ; 1
LineWidth        = 4          ; 2

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_LineAdd                 EQU    [esp + LineAdd]
_LineWidth               EQU    [esp + LineWidth]
_uRemainderEdgePels		 EQU	[esp + uRemainderEdgePels]

; Save registers and start working

push    ebx
 push   esi
push    edi
 push   ebp

sub     esp, LocalFrameSize

 mov   	eax, _uCCOutputBuffer
add     eax, _uOffsetToLine0
 mov    ecx, _lOutput
add     eax, ecx        
 mov    ebx, _uYPitch
mov     ecx, _uWidth
 mov    esi, _uYPlane
mov     edi, eax

; luma
sub    ebx, ecx   ; ebx = pitch - width
 mov    edx, _uHeight
mov    eax, _uWidth
 mov    _LineAdd, ebx

L2:
test	ecx, 0FFFFFFF0H
 jz		LEdgePels			; Width may be less than 16

L1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 16
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 16], eax
 mov    DWORD PTR [edi - 12], ebx
mov     eax, DWORD PTR [esi + 8]
 mov    ebx, DWORD PTR [esi +12]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 16
 sub    ecx, 16

test	ecx, 0FFFFFFF0H
 jnz    L1

LEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 8 edge pels
test	ecx, 08H
 jz		Lchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 mov	ebx, DWORD PTR [esi + 4]			; Input pels 4-7
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 mov	DWORD PTR [edi + 4], ebx			; Output pels 4-7
add		esi, 8
 add	edi, 8

Lchk4:
; Check 4 edge pels
test	ecx, 04H
 jz		L2_cont
mov    eax, DWORD PTR [esi + 0]			; Input pels 0-3
add		esi, 4
mov    DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

L2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     L2

; chroma
mov     esi, _uUPlane
 mov    ecx, _uWidth
shr     ecx, 1
 mov    ebx, _uUVPitch
sub     ebx, ecx   ; ebx = pitch - width/2
 mov    edx, _uHeight
shr     edx, 1
 mov    _LineAdd, ebx
mov		_uWidth, ecx
 mov	_uHeight, edx

U2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

U1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    U1

UEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Uchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Uchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		U2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

U2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
 jnz     U2


; chroma
mov    esi, _uVPlane
 mov	ecx, _uWidth
mov    edx, _uHeight
 nop

V2:
test	ecx, 0FFFFFFF8H
 jz		UEdgePels			; Width may be less than 16

V1:
mov     ebx, DWORD PTR [edi]  ; heat cache
 add	edi, 8
mov     eax, DWORD PTR [esi + 0]
 mov    ebx, DWORD PTR [esi + 4]
mov     DWORD PTR [edi - 8], eax
 mov    DWORD PTR [edi - 4], ebx

add     esi, 8
 sub    ecx, 8

test	ecx, 0FFFFFFF8H
 jnz    V1

VEdgePels:
; Do edge pels is needed (if width a multiple of 4, but not 16)

; Check 4 edge pels
test	ecx, 04H
 jz		Vchk4
mov		eax, DWORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 4
mov		DWORD PTR [edi + 0], eax			; Output pels 0-3
 add	edi, 4

Vchk4:
; Check 2 edge pels
test	ecx, 02H
 jz		V2_cont
mov    ax, WORD PTR [esi + 0]			; Input pels 0-3
 add	esi, 2
mov    WORD PTR [edi + 0], ax			; Output pels 0-3
 add	edi, 2

V2_cont:
add     esi, _LineAdd
 mov     ecx, _uWidth
dec    edx
jnz     V2

add     esp, LocalFrameSize  ; restore esp to registers                               

pop	    ebp
 pop    edi
pop	    esi
 pop    ebx
ret     52                   ; 13*4 bytes of arguments

YUV12ToYUV ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12162.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cxm12162.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12162.asv  $
;// 
;//    Rev 1.10   01 Apr 1997 12:51:50   BNICKERS
;// Fix bugs # 153 and 156 -- wrong color when U is small;  right edge flickeri
;// 
;//    Rev 1.9   09 Dec 1996 15:20:40   BECHOLS
;// Brian fixed ARC bug #94.
;// 
;//    Rev 1.8   06 Sep 1996 16:07:58   BNICKERS
;// Re-written to filter new points.
;// 
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for Intel Microprocessors with MMX Technology
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by two.
; ||||||||
; cxm12162 -- This function performs zoom-by-2 YUV12-to-RGB16 color conversion
;             for H26x.  It is tuned for best performance on Intel
;             Microprocessors with MMX Technology.  It handles any format in
;             which there are three fields, the low order field being B and
;             starting in bit 0, the second field being G, and the high order
;             field being R.  Present support for 555, 565, 655, and 644
;             formats only.  This version adds new rows and columns by
;             averaging them with the originals to either side.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be QWORD aligned.  Pitch and Width must
;             be a multiple of eight.  Height may be any amount, but must be
;             a multiple of two.  The U and V planes may have a different
;             pitch than the Y plane, subject to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include ccinst.inc

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCCDATA SEGMENT PAGE
ALIGN 16

Luma0020004000200000 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW 0
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00100H
 DW (CNT*04A7FH)/00200H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 00000H
 DW 01FFFH
 DW 03FFFH
 DW 01FFFH
ENDM

UContribToBandG LABEL DWORD
DW -(-128*0C83H)/00040H
DW	08000H
DW -(-127*0C83H)/00040H
DW  08000H
CNT = -126
REPEAT 253
 DW -(CNT*00C83H)/00040H
 DW  (CNT*0408BH)/00040H
 CNT = CNT + 1
ENDM
DW  (127*0C83H)/00040H
DW  07FFFH

VContribToRandG LABEL DWORD
CNT = -128
REPEAT 256
 DW -(CNT*01A04H)/00040H
 DW  (CNT*03312H)/00040H
 CNT = CNT + 1
ENDM

MMXCCDATA ENDS

.CODE

ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB16ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

PUBLIC MMX_YUV12ToRGB16ZoomBy2

MMX_YUV12ToRGB16ZoomBy2 proc DIST LANG AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

MAXWIDTH = 768
LocalFrameSize = MAXWIDTH*20+128+64
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType                    = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

DitherB                  EQU  [esp+  0]
DitherG                  EQU  [esp+  8]
DitherR                  EQU  [esp+ 16]
SelectBBits              EQU  [esp+ 24]
SelectGBits              EQU  [esp+ 32]
SelectRBits              EQU  [esp+ 40]

ShiftCountForB           EQU  [esp+ 48]
ShiftCountForG           EQU  [esp+ 52]
ShiftCountForR           EQU  [esp+ 56]

CCOCursor                EQU  [esp+ 60]
CCOPitch                 EQU  [esp+MAXWIDTH*20+128+ 0]
YCursor                  EQU  [esp+MAXWIDTH*20+128+ 4]

YLimit                   EQU  [esp+MAXWIDTH*20+128+ 8]
YPitch                   EQU  [esp+MAXWIDTH*20+128+12]
UCursor                  EQU  [esp+MAXWIDTH*20+128+16]
DistanceFromUToV         EQU  [esp+MAXWIDTH*20+128+20]
ChromaPitch              EQU  [esp+MAXWIDTH*20+128+24]
AspectCount              EQU  [esp+MAXWIDTH*20+128+28]
AspectAdjustmentCount    EQU  [esp+MAXWIDTH*20+128+32]
StartIndexOfYLine        EQU  [esp+MAXWIDTH*20+128+36]
StashESP                 EQU  [esp+MAXWIDTH*20+128+40]

FiltLine0                EQU  [esp+ 64]  ; Must be 32 byte aligned.
FiltLine1                EQU  [esp+ 72]
FiltLine2                EQU  [esp+ 80]
FiltLine3                EQU  [esp+ 88]
HFiltLinePrev            EQU  [esp+ 96]

  push       esi
  push       edi
  push       ebp
  push       ebx

  mov        edi,esp
  and        esp,0FFFFF000H
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,LocalFrameSize-12288
  mov        eax,[esp]

  mov        eax,768
  sub        eax,[edi+FrameWidth_arg]
  imul       eax,20
  mov        StartIndexOfYLine,eax

  mov        eax,[edi+YPlane_arg]
  mov        YCursor,eax

  mov        ebx,[edi+YPitch_arg]
  mov        YPitch,ebx
  mov        ecx,[edi+FrameHeight]
  imul       ebx,ecx
  add        eax,ebx
  mov        YLimit,eax

  mov        eax,[edi+UPlane_arg]
  mov        ebx,[edi+VPlane_arg]
  mov        UCursor,eax
  sub        ebx,eax
  mov        DistanceFromUToV,ebx

  mov        eax,[edi+ColorConvertedFrame]
  add        eax,[edi+DCIOffset]
  add        eax,[edi+CCOffsetToLine0]
  mov        CCOCursor,eax

  mov        eax,[edi+ChromaPitch_arg]
  mov        ChromaPitch,eax

  mov        eax,[edi+CCOPitch_arg]
  mov        CCOPitch,eax

  mov        eax,[edi+AspectAdjustmentCount_arg]
  mov        AspectAdjustmentCount,eax
  mov        AspectCount,eax

  mov        StashESP,edi

  mov        eax,[edi+CCType]
  cmp        eax,CCTYPE_RGB16555ZoomBy2
  je         CCTypeIs555
  cmp        eax,CCTYPE_RGB16555ZoomBy2DCI
  je         CCTypeIs555
  cmp        eax,CCTYPE_RGB16565ZoomBy2
  je         CCTypeIs565
  cmp        eax,CCTYPE_RGB16565ZoomBy2DCI
  je         CCTypeIs565
  cmp        eax,CCTYPE_RGB16655ZoomBy2
  je         CCTypeIs655
  cmp        eax,CCTYPE_RGB16655ZoomBy2DCI
  je         CCTypeIs655
  cmp        eax,CCTYPE_RGB16664ZoomBy2DCI
  je         CCTypeIs664
  cmp        eax,CCTYPE_RGB16664ZoomBy2
  je         CCTypeIs664
  mov        eax,0DEADBEEFH
  mov        YCursor,eax

CCTypeIs555:

  mov        eax,000000200H   ; Dither pattern.
   mov       ebx,002000000H
  mov        DitherB,eax
   mov       DitherB+4,eax
  mov        DitherG,ebx
   mov       DitherG+4,ebx
  mov        DitherR,eax
   mov       DitherR+4,eax
  mov        eax,003E003E0H       ; Bits to extract for fields
   mov       ebx,07C007C00H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0001F001FH
   xor       ecx,ecx              ; Left shift count for R
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax
  mov        eax,10               ; Right shift count for B
   mov       ebx,5                ; Right shift count for G
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx
   jmp       CCTypeInitialized
   
CCTypeIs565:

  mov        eax,000000200H
   mov       ebx,004000000H
  mov        DitherB,eax
   mov       DitherB+4,eax
  mov        DitherG,ebx
   mov       DitherG+4,ebx
  mov        DitherR,eax
   mov       DitherR+4,eax
  mov        eax,007E007E0H
   mov       ebx,0F800F800H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0001F001FH
   mov       ecx,1
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax 
  mov        eax,10
   mov       ebx,4
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx
   jmp       CCTypeInitialized

CCTypeIs655:

  mov        eax,000000200H   ; Dither pattern.
   mov       ebx,004000000H
  mov        DitherB,eax
   mov       DitherB+4,eax
  mov        DitherG,eax
   mov       DitherG+4,eax
  mov        DitherR,ebx
   mov       DitherR+4,ebx
  mov        eax,003E003E0H       ; Bits to extract for fields
   mov       ebx,0FC00FC00H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0001F001FH
   mov       ecx,1                ; Left shift count for R
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax
  mov        eax,10               ; Right shift count for B
   mov       ebx,5                ; Right shift count for G
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx
   jmp       CCTypeInitialized

CCTypeIs664:

  mov        eax,000000400H   ; Dither pattern.
   mov       ebx,001000000H
  mov        DitherB,ebx
   mov       DitherB+4,ebx
  mov        DitherG,eax
   mov       DitherG+4,eax
  mov        DitherR,eax
   mov       DitherR+4,eax
  mov        eax,003F003F0H       ; Bits to extract for fields
   mov       ebx,0FC00FC00H
  mov        SelectGBits,eax
   mov       SelectGBits+4,eax
  mov        SelectRBits,ebx
   mov       SelectRBits+4,ebx
  mov        eax,0000F000FH
   mov       ecx,1                ; Left shift count for R
  mov        SelectBBits,eax
   mov       SelectBBits+4,eax
  mov        eax,11               ; Right shift count for B
   mov       ebx,5                ; Right shift count for G
  mov        ShiftCountForB,eax
   mov       ShiftCountForG,ebx
  mov        ShiftCountForR,ecx

CCTypeInitialized:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   xor       eax,eax
  lea        edx,[esi+ebp*2]
   xor       ebx,ebx
  mov        YCursor,edx
   mov       bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOfFirst2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  mov        al,[esi+1]                       ; Get B.
   add       edi,40                           ; Inc filtered luma temp stg idx.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >

  movq       HFiltLinePrev[edi-40],mm1        ; Save L1 as next iters LPrev.
   paddw     mm1,mm0                          ; L0+L1
  paddw      mm0,mm0                          ; 2L0
   add       esi,2                            ; Increment input index.
  movq       FiltLine3[edi-40],mm1            ; Save filtered line L0+L1.
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi-40],mm0            ; Save filtered line 2L0.
   movq      mm0,mm2                          ; Next iters A.
  mov        bl,[esi+ebp*1+2]                 ; Get c.
   cmp       edi,MAXWIDTH*20-40               ; Done yet.
  mov        al,[esi+2]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  mov        ebp,DistanceFromUToV
   lea       eax,FiltLine2
  mov        esi,UCursor
   mov       edx,StartIndexOfYLine
  jmp        DoOutputLine


Last2OutputLines:

  mov        ebp,DistanceFromUToV
   lea       esi,[edi+40]
  ja         Done

;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  mm0-mm6 -- Scratch.


  movq       mm0,HFiltLinePrev[edi]   ; Fetch horizontally filtered line LP.
  paddw      mm0,mm0                  ; 2LP

Next2PelsOfLast2LumaLines:

  movq       FiltLine3[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       FiltLine2[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       mm0,HFiltLinePrev[edi+40]; Fetch horizontally filtered line LP.
  add        edi,40
   paddw     mm0,mm0                  ; 2LP
  cmp        edi,MAXWIDTH*20          ; Done yet.
   jne       Next2PelsOfLast2LumaLines

  lea        eax,FiltLine2
   mov       edx,StartIndexOfYLine
  mov        esi,UCursor
   jmp       DoOutputLine


Next4OutputLines:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   mov       ecx,YLimit
  lea        edx,[esi+ebp*2]
   xor       eax,eax
  mov        YCursor,edx
   xor       ebx,ebx
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).
   cmp       esi,ecx
  mov        bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
   jae       Last2OutputLines

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOf2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  movq       mm4,HFiltLinePrev[edi]           ; LP
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   movq      mm5,mm4                          ; LP
  mov        al,[esi+1]                       ; Get B.
   add       esi,2                            ; Increment input index.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >
   paddw     mm5,mm5                          ; 2LP
  movq       HFiltLinePrev[edi],mm1           ; Save L1 as next iters LPrev.
   paddw     mm4,mm0                          ; LP+L0
  movq       FiltLine0[edi],mm5               ; Save 2LP
   paddw     mm1,mm0                          ; L0+L1
  movq       FiltLine1[edi],mm4               ; Save LP+L0
   paddw     mm0,mm0                          ; 2L0
  movq       FiltLine3[edi],mm1               ; Save L0+L1
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi],mm0               ; Save 2L0
   movq      mm0,mm2                          ; Next iters A.
  add        edi,40                           ; Inc filtered luma temp stg idx.
   mov       bl,[esi+ebp*1+2]                 ; Get c.
  cmp        edi,MAXWIDTH*20-40               ; Done yet.
   mov       al,[esi+2]                       ; Get C.
  jl         Next2PelsOf2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOf2LumaLines

  mov        ebp,DistanceFromUToV
   mov       esi,UCursor
  lea        eax,FiltLine0
   mov       edx,StartIndexOfYLine

DoOutputLine:

  mov        edi,CCOCursor
   mov       ecx,AspectCount
  dec        ecx                    ; If count is non-zero, we keep the line.
   mov       ebx,CCOPitch
  mov        AspectCount,ecx
   je        SkipOutputLine

  add        ebx,edi
   xor       ecx,ecx
  mov        cl,[esi]
   add       eax,MAXWIDTH*20
  movdt      mm3,ShiftCountForB
   pcmpeqw   mm6,mm6
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gu >
  mov        cl,[esi+ebp*1]
   sub       edx,MAXWIDTH*20
  movdt      mm4,ShiftCountForG
   psllw     mm6,15                        ; Four words of -32768
  movdt      mm5,ShiftCountForR
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >
  movq       mm7,SelectBBits
  mov        CCOCursor,ebx
   jmp       StartDoOutputLine

; ebp -- Distance from U to V
; esi -- Cursor over U
; edi -- Cursor over output
; edx -- Index over Y storage area
; eax -- Base address of Y line
; mm6 -- Four words of -32768, to clamp at floor.
; mm3, mm4, mm5 -- Shift counts to apply to R, G, and B.

DoNext4OutputPels:

  movq       [edi-8],mm2                   ; Save 4 output pels.
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >

StartDoOutputLine:

  movdt      mm2,VContribToRandG[ecx*4]    ; <  0    0   Rv   Gv  >
   punpcklwd mm2,mm2                       ; < Rv   Rv   Gv   Gv  >
  movq       mm1,mm0                       ; < junk junk Gu   Gu  >
   punpckhdq mm0,mm0                       ; < Bu   Bu   Bu   Bu  >
  paddsw     mm0,[eax+edx]                 ; < B B B B > with ceiling clamped.
   paddw     mm1,mm2                       ; < junk junk Guv  Guv >
  paddsw     mm0,DitherB                   ; B with dither added.
   punpckldq mm1,mm1                       ; < Guv  Guv  Guv  Guv >
  paddsw     mm1,[eax+edx]                 ; < G G G G > with ceiling clamped.
   punpckhdq mm2,mm2                       ; < Rv   Rv   Rv   Rv  >
  paddsw     mm1,DitherG                   ; G with dither added.
   paddsw    mm0,mm6                       ; B with floor clamped.
  paddsw     mm2,[eax+edx]                 ; < R R R R > with ceiling clamped.
   paddsw    mm1,mm6                       ; G with floor clamped.
  paddsw     mm2,DitherR                   ; R with dither added.
   psrlw     mm0,mm3                       ; Position B bits.
  paddsw     mm2,mm6                       ; R with floor clamped.
   psrlw     mm1,mm4                       ; Position G bits.
  pand       mm1,SelectGBits               ; Eliminate fractional bits.
   psllw     mm2,mm5                       ; Position R bits.
  inc        esi                           ; Advance input cursor
   xor       ecx,ecx
  pand       mm2,SelectRBits               ; Eliminate fractional bits.
   pand      mm0,mm7
  mov        cl,[esi]                      ; Fetch next U.
   add       edi,8                         ; Advance output cursor.
  por        mm2,mm0                       ; R and B combined.
   add       edx,40                        ; Increment Y index.
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gv  > next iter.
   por       mm2,mm1                       ; Completed RGB16 for 4 output pels.
  mov        cl,[esi+ebp*1]                ; Fetch next V.
   jne       DoNext4OutputPels

  movq       [edi-8],mm2                   ; Save 4 output pels.

  movq       mm0,DitherB                   ; Reverse dither patterns.
  movq       mm1,DitherG
   psrlq     mm0,16
  movq       mm2,DitherR
   psrlq     mm1,16
  psrlq      mm2,16
  punpckldq  mm0,mm0
  punpckldq  mm1,mm1
  movq       DitherB,mm0
   punpckldq mm2,mm2
  movq       DitherG,mm1
  movq       DitherR,mm2

PrepareForNextOutputLine:

  mov        edx,StartIndexOfYLine
   add       eax,8-MAXWIDTH*20            ; Advance to next filtered line of Y.
  mov        esi,UCursor
   test      al,8                         ; Jump if just did line 0 or 2.
  mov        ebx,ChromaPitch
   jne       DoOutputLine

  add        esi,ebx                      ; Advance to next chroma line.
   test      al,16                        ; Jump if about to do line 2.
  mov        UCursor,esi
   jne       DoOutputLine

  sub        esi,ebx                      ; Done with 4 lines.  Restore UCursor.
  mov        UCursor,esi
   jmp       Next4OutputLines

SkipOutputLine:
  mov        ecx,AspectAdjustmentCount
   add       eax,MAXWIDTH*20
  mov        AspectCount,ecx
   jmp       PrepareForNextOutputLine

Done:

  mov        esp,StashESP
  pop        ebx
  pop        ebp
  pop        edi
  pop        esi
  rturn

MMX_YUV12ToRGB16ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12242.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cxm12242.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12242.asv  $
;// 
;//    Rev 1.4   01 Apr 1997 12:53:18   BNICKERS
;// Fix bugs # 153 and 156 -- wrong color when U is small;  right edge flickeri
;// 
;//    Rev 1.3   11 Mar 1997 13:49:36   JMCVEIGH
;// Same ARC bug fix (#94) as was done in cxm12162.asm. Without
;// this, zoom by 2 and ARC causes black lines in output (every 12th).
;// 
;//    Rev 1.2   06 Sep 1996 16:08:14   BNICKERS
;// Re-written to filter new points.
;// 
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for Intel Microprocessors with MMX Technology
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by two.
; ||||||||
; cxm12242 -- This function performs zoom-by-2 YUV12-to-RGB24 color conversion
;             for H26x.  It is tuned for best performance on Intel
;             Microprocessors with MMX Technology.  It handles the format in
;             which B is the low order field, then G, then R.  This version
;             adds new rows and columns by averaging them with the originals
;             to either side.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be QWORD aligned.  Pitch and Width must
;             be a multiple of eight.  Height may be any amount, but must be
;             a multiple of two.  The U and V planes may have a different
;             pitch than the Y plane, subject to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCCDATA SEGMENT PAGE
ALIGN 16

Luma0040002000200000 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW 0
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00100H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 00000H
 DW 01FFFH
 DW 01FFFH
 DW 03FFFH
ENDM

Luma0020004000000020 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW (CNT*04A7FH)/00200H
 DW 0
 DW (CNT*04A7FH)/00100H
 DW (CNT*04A7FH)/00200H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 01FFFH
 DW 00000H
 DW 03FFFH
 DW 01FFFH
ENDM

UContribToBandG LABEL DWORD
DW -(-128*0C83H)/00040H
DW	08000H
DW -(-127*0C83H)/00040H
DW  08000H
CNT = -126
REPEAT 253
 DW -(CNT*00C83H)/00040H
 DW  (CNT*0408BH)/00040H
 CNT = CNT + 1
ENDM
DW  (127*0C83H)/00040H
DW  07FFFH

VContribToRandG LABEL DWORD
CNT = -128
REPEAT 256
 DW -(CNT*01A04H)/00040H
 DW  (CNT*03312H)/00040H
 CNT = CNT + 1
ENDM


C0001000001000001 DD  001000001H, 000010000H
C0200020002000200 DD  002000200H, 002000200H
C0000000001000000 DD  001000000H, 000000000H
C000000FF00000000 DD  000000000H, 0000000FFH
C0000010000010000 DD  000010000H, 000000100H

MMXCCDATA ENDS

.CODE

ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB24ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

PUBLIC MMX_YUV12ToRGB24ZoomBy2

MMX_YUV12ToRGB24ZoomBy2 proc DIST LANG AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

MAXWIDTH = 768
LocalFrameSize = MAXWIDTH*20+64
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType                    = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+  0]
CCOPitch                 EQU  [esp+  4]
YCursor                  EQU  [esp+  8]
YLimit                   EQU  [esp+ 12]
YPitch                   EQU  [esp+ 16]
UCursor                  EQU  [esp+ 20]
DistanceFromUToV         EQU  [esp+ 24]
ChromaPitch              EQU  [esp+ 28]
AspectCount              EQU  [esp+ 32]
AspectAdjustmentCount    EQU  [esp+ 36]
StartIndexOfYLine        EQU  [esp+ 40]
StashESP                 EQU  [esp+ 44]

FiltLine0                EQU  [esp+ 64]  ; Must be 32 byte aligned.
FiltLine1                EQU  [esp+ 72]
FiltLine2                EQU  [esp+ 80]
FiltLine3                EQU  [esp+ 88]
HFiltLinePrev            EQU  [esp+ 96]

  push       esi
  push       edi
  push       ebp
  push       ebx

  mov        edi,esp
  and        esp,0FFFFF000H
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,LocalFrameSize-12288
  mov        eax,[esp]

  mov        eax,768
  sub        eax,[edi+FrameWidth_arg]
  imul       eax,20
  mov        StartIndexOfYLine,eax

  mov        eax,[edi+YPlane_arg]
  mov        YCursor,eax

  mov        ebx,[edi+YPitch_arg]
  mov        YPitch,ebx
  mov        ecx,[edi+FrameHeight]
  imul       ebx,ecx
  add        eax,ebx
  mov        YLimit,eax

  mov        eax,[edi+UPlane_arg]
  mov        ebx,[edi+VPlane_arg]
  mov        UCursor,eax
  sub        ebx,eax
  mov        DistanceFromUToV,ebx

  mov        eax,[edi+ColorConvertedFrame]
  add        eax,[edi+DCIOffset]
  add        eax,[edi+CCOffsetToLine0]
  mov        CCOCursor,eax

  mov        eax,[edi+ChromaPitch_arg]
  mov        ChromaPitch,eax

  mov        eax,[edi+CCOPitch_arg]
  mov        CCOPitch,eax

  mov        eax,[edi+AspectAdjustmentCount_arg]
  mov        AspectAdjustmentCount,eax
  mov        AspectCount,eax

  mov        StashESP,edi

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   xor       eax,eax
  lea        edx,[esi+ebp*2]
   xor       ebx,ebx
  mov        YCursor,edx
   mov       bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).

  movq       mm1,Luma0020004000000020[ebx*8]  ; L1:< 32a 64a     0       32a >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000000020[eax*8]  ; L0:< 32A 64A     0       32A >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOfFirst2LumaLines:

  movq       mm3,Luma0020004000000020[ebx*8]  ; L1:< 32c 64c     0       32c >
   psrlq     mm1,32                           ; L1:< 0   0       32a     64a >
  movq       mm2,Luma0020004000000020[eax*8]  ; L0:< 32C 64C     0       32C >
   punpckldq mm1,mm3                          ; L1:< 0   32c     32a     64a >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   psrlq     mm0,32                           ; L0:< 0   0       32A     64A >
  mov        al,[esi+1]                       ; Get B.
   add       edi,40                           ; Inc filtered luma temp stg idx.
  paddw      mm1,Luma0040002000200000[ebx*8]  ; L1:< 64b 32b+32c 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 0   32C     32A     64A >
  paddw      mm0,Luma0040002000200000[eax*8]  ; L0:< 64B 32B+32C 32A+32B 64A >

  movq       HFiltLinePrev[edi-40],mm1        ; Save L1 as next iters LPrev.
   paddw     mm1,mm0                          ; L0+L1
  paddw      mm0,mm0                          ; 2L0
   add       esi,2                            ; Increment input index.
  movq       FiltLine3[edi-40],mm1            ; Save filtered line L0+L1.
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi-40],mm0            ; Save filtered line 2L0.
   movq      mm0,mm2                          ; Next iters A.
  mov        bl,[esi+ebp*1+2]                 ; Get c.
   cmp       edi,MAXWIDTH*20-40               ; Done yet.
  mov        al,[esi+2]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  mov        ebp,DistanceFromUToV
   lea       eax,FiltLine2
  mov        esi,UCursor
   mov       edx,StartIndexOfYLine
  jmp        DoOutputLine


Last2OutputLines:

  mov        ebp,DistanceFromUToV
   lea       esi,[edi+40]
  ja         Done

;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  mm0-mm6 -- Scratch.


  movq       mm0,HFiltLinePrev[edi]   ; Fetch horizontally filtered line LP.
  paddw      mm0,mm0                  ; 2LP

Next2PelsOfLast2LumaLines:

  movq       FiltLine3[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       FiltLine2[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       mm0,HFiltLinePrev[edi+40]; Fetch horizontally filtered line LP.
  add        edi,40
   paddw     mm0,mm0                  ; 2LP
  cmp        edi,MAXWIDTH*20          ; Done yet.
   jne       Next2PelsOfLast2LumaLines

  lea        eax,FiltLine2
   mov       edx,StartIndexOfYLine
  mov        esi,UCursor
   jmp       DoOutputLine


Next4OutputLines:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   mov       ecx,YLimit
  lea        edx,[esi+ebp*2]
   xor       eax,eax
  mov        YCursor,edx
   xor       ebx,ebx
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).
   cmp       esi,ecx
  mov        bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
   jae       Last2OutputLines

  movq       mm1,Luma0020004000000020[ebx*8]  ; L1:< 32a 64a     0       32a >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000000020[eax*8]  ; L0:< 32A 64A     0       32A >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOf2LumaLines:

  movq       mm3,Luma0020004000000020[ebx*8]  ; L1:< 32c 64c     0       32c >
   psrlq     mm1,32                           ; L1:< 0   0       32a     64a >
  movq       mm2,Luma0020004000000020[eax*8]  ; L0:< 32C 64C     0       32C >
   punpckldq mm1,mm3                          ; L1:< 0   32c     32a     64a >
  movq       mm4,HFiltLinePrev[edi]           ; LP
   psrlq     mm0,32                           ; L0:< 0   0       32A     64A >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   movq      mm5,mm4                          ; LP
  mov        al,[esi+1]                       ; Get B.
   add       esi,2                            ; Increment input index.
  paddw      mm1,Luma0040002000200000[ebx*8]  ; L1:< 64b 32b+32c 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 0   32C     32A     64A >
  paddw      mm0,Luma0040002000200000[eax*8]  ; L0:< 64B 32B+32C 32A+32B 64A >
   paddw     mm5,mm5                          ; 2LP
  movq       HFiltLinePrev[edi],mm1           ; Save L1 as next iters LPrev.
   paddw     mm4,mm0                          ; LP+L0
  movq       FiltLine0[edi],mm5               ; Save 2LP
   paddw     mm1,mm0                          ; L0+L1
  movq       FiltLine1[edi],mm4               ; Save LP+L0
   paddw     mm0,mm0                          ; 2L0
  movq       FiltLine3[edi],mm1               ; Save L0+L1
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi],mm0               ; Save 2L0
   movq      mm0,mm2                          ; Next iters A.
  add        edi,40                           ; Inc filtered luma temp stg idx.
   mov       bl,[esi+ebp*1+2]                 ; Get c.
  cmp        edi,MAXWIDTH*20-40               ; Done yet.
   mov       al,[esi+2]                       ; Get C.
  jl         Next2PelsOf2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOf2LumaLines

  mov        ebp,DistanceFromUToV
   mov       esi,UCursor
  lea        eax,FiltLine0
   mov       edx,StartIndexOfYLine

DoOutputLine:

  mov        edi,CCOCursor
   mov       ecx,AspectCount
  dec        ecx                    ; If count is non-zero, we keep the line.
   mov       ebx,CCOPitch
  mov        AspectCount,ecx
   je        SkipOutputLine

  add        ebx,edi
   xor       ecx,ecx
  mov        cl,[esi]
   add       eax,MAXWIDTH*20
  movq       mm7,C0001000001000001
   pcmpeqw   mm6,mm6
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gu >
   psllw     mm6,15                        ; Four words of -32768
  mov        cl,[esi+ebp*1]
   sub       edx,MAXWIDTH*20
  pxor       mm3,mm3
   movq      mm5,mm7
  mov        CCOCursor,ebx
   jmp       StartDoOutputLine

; ebp -- Distance from U to V
; esi -- Cursor over U
; edi -- Cursor over output
; edx -- Index over Y storage area
; eax -- Base address of Y line
; mm6 -- Four words of -32768, to clamp at floor.
; mm7 -- <0x0100 0x0000 0x0100 0x0001>

DoNext4OutputPels:

  movdf      [edi-4],mm4                   ; Store <R3 G3 B3 R2>
   movq      mm5,mm7                       ; < 0100 0000 0100 0001 >

StartDoOutputLine:

  movdt      mm2,VContribToRandG[ecx*4]    ; <  0    0   Rv   Gv  >
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >
  movq       mm1,mm0                       ; < junk junk Gu   Gu  >
   punpcklwd mm2,mm2                       ; < Rv   Rv   Gv   Gv  >
  paddw      mm1,mm2                       ; < junk junk Guv  Guv >
   punpckhdq mm0,mm0                       ; < Bu   Bu   Bu   Bu  >
  paddsw     mm0,[eax+edx]                 ; < B2 B3 B1 B0 > w/ ceiling clamped.
   punpckldq mm1,mm1                       ; < Guv  Guv  Guv  Guv >
  paddsw     mm1,[eax+edx]                 ; < G2 G3 G1 G0 > w/ ceiling clamped.
   punpckhdq mm2,mm2                       ; < Rv   Rv   Rv   Rv  >
  paddsw     mm2,[eax+edx]                 ; < R2 R3 R1 R0 > w/ ceiling clamped.
   paddsw    mm0,mm6                       ; B with floor clamped.
  psubsw     mm0,mm6                       ; B back in range.
   paddsw    mm1,mm6                       ; G with floor clamped.
  psubsw     mm1,mm6                       ; G back in range.
   paddsw    mm2,mm6                       ; R with floor clamped.
  psubsw     mm2,mm6                       ; R back in range.
   psrlw     mm0,7                         ; <  0 B2  0 B3  0 B1  0 B0 >
  pmulhw     mm1,C0200020002000200         ; <  0 G2  0 G3  0 G1  0 G0 >
   punpckhwd mm3,mm0                       ; < -- -- -- --  0 B3 -- -- >
  pmaddwd    mm3,C0000000001000000         ; < -- -- -- --  0  0 B3  0 >
   psrlw     mm2,7                         ; <  0 R2  0 R3  0 R1  0 R0 >
  pmullw     mm5,mm2                       ; < -- --  0  0 R1  0  0 R0 >
   punpckhdq mm2,mm2                       ; < -- --  0 R3  0 R2 -- -- >
  pmullw     mm0,mm7                       ; <  0 B2  0  0 B1  0  0 B0 >
   movq      mm4,mm1                       ; < -- -- -- G3 -- -- -- -- >
  pand       mm4,C000000FF00000000         ; < -- --  0 G3  0  0 -- -- >
   pmullw    mm1,mm7                       ; <  0 G2  0  0 G1  0  0 G0 >
  pmullw     mm2,C0000010000010000         ; < -- -- R3  0  0 R2 -- -- >
   psllq     mm5,16                        ; <  0  0 R1  0  0 R0  0  0 >
  xor        ecx,ecx
   por       mm5,mm0                       ; <  0 B2 R1  0 B1 R0  0 B0 >
  mov        cl,[esi+1]                    ; Fetch next U.
   psllq     mm1,8                         ; < G2  0  0 G1  0  0 G0  0 >
  por        mm4,mm2                       ; < -- -- R3 G3  0 R2 -- -- >
   por       mm5,mm1                       ; < G2 B2 R1 G1 B1 R0 G0 B0 >
  inc        esi                           ; Advance input cursor
   psrlq     mm4,16                        ; < -- -- -- -- R3 G3  0 R2 >
  movdf      [edi],mm5                     ; Store < B1 R0 G0 B0 >
   psrlq     mm5,32                        ; < -- -- -- -- G2 B2 R1 G1 >
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gv  > next iter.
   por       mm4,mm3                       ; < -- -- -- -- R3 G3 B3 R2 >
  movdf      [edi+4],mm5                   ; Store < G2 B2 R1 G1 >
   ;
  add        edi,12                        ; Advance output cursor.
   add       edx,40                        ; Increment Y index.
  mov        cl,[esi+ebp*1]                ; Fetch next V.
   jne       DoNext4OutputPels

  movdf      [edi-4],mm4                   ; Store <R3 G3 B3 R2>

PrepareForNextOutputLine:

  mov        edx,StartIndexOfYLine
   add       eax,8-MAXWIDTH*20            ; Advance to next filtered line of Y.
  mov        esi,UCursor
   test      al,8                         ; Jump if just did line 0 or 2.
  mov        ebx,ChromaPitch
   jne       DoOutputLine

  add        esi,ebx                      ; Advance to next chroma line.
   test      al,16                        ; Jump if about to do line 2.
  mov        UCursor,esi
   jne       DoOutputLine

  sub        esi,ebx                      ; Done with 4 lines.  Restore UCursor.
  mov        UCursor,esi
   jmp       Next4OutputLines

SkipOutputLine:
  mov        ecx,AspectAdjustmentCount
   add       eax,MAXWIDTH*20
  mov        AspectCount,ecx
   jmp       PrepareForNextOutputLine

Done:

  mov        esp,StashESP
  pop        ebx
  pop        ebp
  pop        edi
  pop        esi
  rturn

MMX_YUV12ToRGB24ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12161.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cx512161.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12161.asv  $
;// 
;//    Rev 1.9   24 May 1996 11:12:10   AGUPTA2
;// 
;// Modified version of final drop from IDC.  Fixed alignment, global var,
;// referencing beyond stack pointer problems.  Cosmetic changes to adhere
;// to a common coding convention in all MMX color convertor files.
;//
;//    Rev 1.8   17 Apr 1996 09:51:08   ISRAELH
;// Added AspectRatio adjustement, emms.
;//
;//    Rev 1.7   11 Apr 1996 09:51:08   RMCKENZX
;// Changed return to pop the stack.
;//
;//    Rev 1.6   09 Apr 1996 10:00:44   RMCKENZX
;//
;// Changed calling sequence to __stdcall.
;//
;//    Rev 1.5   05 Apr 1996 10:40:20   RMCKENZX
;// Hacked in Aspect Ratio correction.  This is accomplished
;// by simply overwriting the next even line after the aspect
;// count has been matched or exceeded.
;//
;//    Rev 1.4   29 Mar 1996 07:52:56   RMCKENZX
;// re-fixed bug in 655 setup.
;//
;//    Rev 1.3   28 Mar 1996 14:35:38   RMCKENZX
;// Cleaned up code, added comments, revised calling sequence,
;// moved global variables onto stack.
;//
;//    Rev 1.2   21 Mar 1996 08:10:06   RMCKENZX
;// Fixed 655 case -- initialized GLeftShift at 5.
;//
;//    Rev 1.1   20 Mar 1996 11:18:52   RMCKENZX
;// March 96 version.
;
;     Rev 1.3   19 Feb 1996 11:49:42   israelh
;  bug fix.
;  new algorithm for RGB16 bit pack.
;
;     Rev 1.3   18 Feb 1996 20:58:44   israelh
;  better algorithm and bug fix
;
;     Rev 1.2   29 Jan 1996 19:53:50   mikeh
;
;  added Ifdef timing
;
;     Rev 1.1   29 Jan 1996 16:29:16   mikeh
;  remvoed $LOG stuff
;
;     Rev 1.0   29 Jan 1996 11:49:44   israelh
;  Initial revision.
;//
;// MMX 1.3 14 Jan 1996 IsraelH
;// Implementing runtime RGB bit allocation according to BValLo[0]:
;// It contains the ColorConvertor value from d1color.cpp module.
;// Compiler flag RTIME16 for using runtime allocation.
;//
;// MMX 1.2 10 Jan 1996 IsraelH
;// Implementing RGB16x565 (5-R 5-G 5-B) as default
;// Compiler flag MODE555 for RGB16555 (5-R 5-G 5-B)
;//
;// MMX 1.1 09 Jan 1996 IsraelH
;// Implementing RGB16x555 (5-R 5-G 5-B)
;// Commenting out RGB16664 (6-R 6-G 4-B)
;// Adding performance measurements in runtime
;//
;// MMX 1.0 25 Dec 1995 IsraelH
;// Port to MMX(TM) without using tables
;
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB16.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cxm12161 -- This function performs YUV12-to-RGB16 color conversion for H26x.
;             It handles any format in which there are three fields, the low
;             order field being B and fully contained in the low order byte, the
;             second field being G and being somewhere in bits 4 through 11,
;             and the high order field being R and fully contained in the high
;             order byte.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of four.  For best
;             performance, Pitch should not be 4 more than a multiple of 32.
;             Height may be any amount, but must be a multiple of two.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
Minusg              DWORD   00800080h, 00800080h
Yadd                DWORD   10101010h, 10101010h
VtR                 DWORD   00660066h, 00660066h ;01990199h,01990199h
VtG                 DWORD   00340034h, 00340034h ;00d000d0h,00d000d0h
UtG                 DWORD   00190019h, 00190019h ;00640064h,00640064h
UtB                 DWORD   00810081h, 00810081h ;02050205h,02050205h
Ymul                DWORD   004a004ah, 004a004ah ;012a012ah,012a012ah
UVtG                DWORD   00340019h, 00340019h ;00d00064h,00d00064h
VtRUtB              DWORD   01990205h, 01990205h
fourbitu            DWORD  0f0f0f0f0h, 0f0f0f0f0h
fivebitu            DWORD  0e0e0e0e0h, 0e0e0e0e0h
sixbitu             DWORD  0c0c0c0c0h, 0c0c0c0c0h
MMXDATA1 ENDS

MMXCODE1 SEGMENT
MMX_YUV12ToRGB16 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

LocalFrameSize           = 256
RegisterStorageSize      = 16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU argument_base +  4
VPlane                   EQU argument_base +  8
UPlane                   EQU argument_base + 12
FrameWidth               EQU argument_base + 16
FrameHeight              EQU argument_base + 20
YPitch                   EQU argument_base + 24
ChromaPitch              EQU argument_base + 28
AspectAdjustmentCount    EQU argument_base + 32
ColorConvertedFrame      EQU argument_base + 36
DCIOffset                EQU argument_base + 40
CCOffsetToLine0          EQU argument_base + 44
CCOPitch                 EQU argument_base + 48
CCType                   EQU argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
localFrameWidth          EQU local_base + 0
localYPitch              EQU local_base + 4
localChromaPitch         EQU local_base + 8
localAspectAdjustmentCount EQU local_base + 12
localCCOPitch            EQU local_base + 16
CCOCursor                EQU local_base + 20
CCOSkipDistance          EQU local_base + 24
YLimit                   EQU local_base + 28
DistanceFromVToU         EQU local_base + 32
currAspectCount          EQU local_base + 36
YCursorEven              EQU local_base + 40
YCursorOdd               EQU local_base + 44
tmpCCOPitch              EQU local_base + 48
StashESP                 EQU local_base + 52
; space for two DWORD locals
temp_mmx                 EQU local_base + 64  ; note it is 64 bytes
RLeftShift               EQU local_base +128
GLeftShift               EQU local_base +136
RRightShift              EQU local_base +144
GRightShift              EQU local_base +152
BRightShift              EQU local_base +160
RUpperLimit              EQU local_base +168
GUpperLimit              EQU local_base +176
BUpperLimit              EQU local_base +184

; Switches used by RGB color convertors to determine the exact conversion type.
RGB16555 =  9
RGB16664 = 14
RGB16565 = 18
RGB16655 = 22

  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32
   mov       [StashESP], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Save some parameters on local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [FrameWidth]
   ;
  mov        [localFrameWidth], ebx
   mov       ebx, [YPitch]
  mov        [localYPitch], ebx
   mov       ebx, [ChromaPitch]
  mov        [localChromaPitch], ebx
   mov       ebx, [AspectAdjustmentCount]
  mov        [localAspectAdjustmentCount], ebx
   mov       ebx, [CCOPitch]
  mov        [localCCOPitch], ebx
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Set-up rest of the local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov       al, [CCType]
  cmp        al, RGB16555
   je        RGB555
  cmp        al, RGB16664
   je        RGB664
  cmp        al, RGB16565
   je        RGB565
  cmp        al, RGB16655
   je        RGB655
RGB555:
  xor        eax, eax
   mov       ebx, 2   ; 10-8 for byte shift
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 5
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 9
  mov        [RRightShift], ebx
   mov       [RRightShift+4], eax
  mov        [GRightShift], ebx
   mov       [GRightShift+4], eax
  mov        [BRightShift], ebx
   mov       [BRightShift+4], eax
  movq       mm0, fivebitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       [GUpperLimit], mm0
   ;
  movq       [BUpperLimit], mm0
   jmp       RGBEND

RGB664:
  xor        eax, eax
   mov       ebx, 2   ; 8-6
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 4
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 8
  mov        [RRightShift], ebx
   mov       [RRightShift+4], eax
  mov        [GRightShift], ebx
   mov       [GRightShift+4], eax
  mov        ebx, 10
   mov       [BRightShift+4], eax
  mov        [BRightShift], ebx
   ;
  movq       mm0, sixbitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       [GUpperLimit], mm0
   ;
  movq       mm0, fourbitu
   ;
  movq       [BUpperLimit], mm0
   jmp       RGBEND

RGB565:
  xor        eax, eax
   mov       ebx, 3   ; 8-5
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 5
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 9
  mov        [RRightShift+4], eax
   mov       [RRightShift], ebx
  mov        [BRightShift], ebx
   mov       [BRightShift+4], eax
  mov        ebx, 8
   mov       [GRightShift+4], eax
  mov        [GRightShift], ebx
   ;
  movq       mm0, fivebitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       [BUpperLimit], mm0
   ;
  movq       mm0, sixbitu
   ;
  movq       [GUpperLimit], mm0
   jmp       RGBEND

RGB655:
  xor        eax, eax
   mov       ebx, 2   ; 8-6
  mov        [RLeftShift], ebx
   mov       [RLeftShift+4], eax
  mov        ebx, 5
   mov       [GLeftShift+4], eax
  mov        [GLeftShift], ebx
   mov       ebx, 8
  mov        [RRightShift], ebx
   mov       [RRightShift+4], eax
  mov        ebx, 9
   mov       [GRightShift+4], eax
  mov        [GRightShift], ebx
   mov       [BRightShift], ebx
  mov        [BRightShift+4], eax
   ;
  movq       mm0, sixbitu
   ;
  movq       [RUpperLimit], mm0
   ;
  movq       mm0, fivebitu
   ;
  movq       [GUpperLimit], mm0
   ;
  movq       [BUpperLimit], mm0
   jmp       RGBEND

RGBEND:
  mov        ebx, [VPlane]
   mov       ecx, [UPlane]
  sub        ecx, ebx
   mov       eax, [ColorConvertedFrame]
  mov        [DistanceFromVToU], ecx
   mov       edx, [DCIOffset]
  add        eax, edx
   mov       edx, [CCOffsetToLine0]
  add        eax, edx
   mov       edx, [FrameHeight]
  mov        [CCOCursor], eax
   mov       ecx, [YPitch]
  imul       edx, ecx                        ; FrameHeight*YPitch
   ;
  mov        ebx, [FrameWidth]
   mov       eax, [CCOPitch]
  sub        eax, ebx                        ; CCOPitch-FrameWidth
   mov       esi, [YPlane]                   ; Fetch cursor over luma plane.
  sub        eax, ebx                        ; CCOPitch-2*FrameWidth
   mov       [CCOSkipDistance], eax          ; CCOPitch-2*FrameWidth
  add        edx, esi                        ; YPlane+Size_of_Y_array
   ;
  mov        [YLimit], edx
   mov       edx, [AspectAdjustmentCount]
  cmp        edx,1
   je        finish
  mov        esi, [VPlane]
   mov       [currAspectCount], edx
  mov        [localAspectAdjustmentCount], edx
   xor       eax, eax
  mov        edi, [CCOCursor]
   mov       edx, [DistanceFromVToU]
  mov        ebp, [YPlane]
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  cannot access parameters beyond this point
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov       ebx, [localFrameWidth]
  mov        eax, [localYPitch]
   add       ebp, ebx
  mov        [YCursorEven], ebp				 ; YPlane + FrameWidth
   add       ebp, eax						 
  sar        ebx, 1							 ; FrameWidth/2
   mov       [YCursorOdd], ebp				 ; YPlane + FrameWidth + YPitch
  add        esi, ebx						 ; VPlane + FrameWidth/2
   ;
  add        edx, esi						 ; UPlane + FrameWidth/2
   neg       ebx
  mov       [localFrameWidth], ebx           ; -FrameWidth/2

;  Register Usage:
;
;------------------------------------------------------------------------------
PrepareChromaLine:
  mov        ebp, [currAspectCount]
   mov       ebx, [localFrameWidth]
  sub        ebp, 2
   mov       eax, [localCCOPitch]
  mov        [tmpCCOPitch], eax
   ja        continue
  xor        eax, eax
   add       ebp, [localAspectAdjustmentCount]
  mov        [tmpCCOPitch], eax

continue:
  mov       [currAspectCount], ebp

do_next_8x2_block:
  mov        ebp, [YCursorEven]
; here is even line
  movdt      mm1, [edx+ebx]                  ; 4 u values
   pxor      mm0, mm0                        ; mm0=0
  movdt      mm2, [esi+ebx]                  ; 4 v values
   punpcklbw mm1, mm0                        ; get 4 unsign u
  psubw      mm1, Minusg                     ; get 4 unsign u-128
   punpcklbw mm2, mm0                        ; get unsign v
  psubw      mm2, Minusg                     ; get unsign v-128
   movq      mm3, mm1                        ; save the u-128 unsign
  movq       mm5, mm1                        ; save u-128 unsign
   punpcklwd mm1, mm2                        ; get 2 low u, v unsign pairs
  pmaddwd    mm1, UVtG
   punpckhwd mm3, mm2                        ; create high 2 unsign uv pairs
  pmaddwd    mm3, UVtG
   ;
  movq       [temp_mmx], mm2                 ; save v-128
   ;
  movq       mm6, [ebp+2*ebx]                ; mm6 has 8 y pixels
   ;
  psubusb    mm6, Yadd                       ; mm6 has 8 y-16 pixels
   packssdw  mm1, mm3                        ; packed the results to signed words
  movq       mm7, mm6                        ; save the 8 y-16 pixels
   punpcklbw mm6, mm0                        ; mm6 has 4 low y-16 unsign
  pmullw     mm6, Ymul
   punpckhbw mm7, mm0                        ; mm7 has 4 high y-16 unsign
  pmullw     mm7, Ymul
   movq      mm4, mm1
  movq       [temp_mmx+8], mm1               ; save 4 chroma G values
   punpcklwd mm1, mm1                        ; chroma G replicate low 2
  movq       mm0, mm6                        ; low  y
   punpckhwd mm4, mm4                        ; chroma G replicate high 2
  movq       mm3, mm7                        ; high y
   psubw     mm6, mm1                        ;  4 low G
  psraw      mm6, [GRightShift]
   psubw     mm7, mm4                        ; 4 high G values in signed 16 bit
  movq       mm2, mm5
   punpcklwd mm5, mm5                        ; replicate the 2 low u pixels
  pmullw     mm5, UtB
   punpckhwd mm2, mm2
  psraw      mm7, [GRightShift]
   pmullw    mm2, UtB
  packuswb   mm6, mm7                        ; mm6: G7 G6 G5 G4 G3 G2 G1 G0
   ;
  movq       [temp_mmx+16], mm5              ; low chroma B
   paddw     mm5, mm0                        ; 4 low B values in signed 16 bit
  movq       [temp_mmx+40], mm2              ; high chroma B
   paddw     mm2, mm3                        ; 4 high B values in signed 16 bit
  psraw      mm5, [BRightShift]              ; low B scaled down by 6+(8-5)
   ;
  psraw      mm2, [BRightShift]              ; high B scaled down by 6+(8-5)
   ;
  packuswb   mm5, mm2                        ; mm5: B7 B6 B5 B4 B3 B2 B1 B0
   ;
  movq       mm2, [temp_mmx]                 ; 4 v values
   movq      mm1, mm5                        ; save B
  movq       mm7, mm2
   punpcklwd mm2, mm2                        ; replicate the 2 low v pixels
  pmullw     mm2, VtR
   punpckhwd mm7, mm7
  pmullw     mm7, VtR
   ;
  paddusb    mm1, [BUpperLimit]              ; mm1: saturate B+0FF-15
   ;
  movq       [temp_mmx+24], mm2              ; low chroma R
   ;
  paddw      mm2, mm0                        ; 4 low R values in signed 16 bit
   ;
  psraw      mm2, [RRightShift]              ; low R scaled down by 6+(8-5)
   pxor      mm4, mm4                        ; mm4=0 for 8->16 conversion
  movq       [temp_mmx+32], mm7              ; high chroma R
   paddw     mm7, mm3                        ; 4 high R values in signed 16 bit
  psraw      mm7, [RRightShift]              ; high R scaled down by 6+(8-5)
   ;
  psubusb    mm1, [BUpperLimit]
   packuswb  mm2, mm7                        ; mm2: R7 R6 R5 R4 R3 R2 R1 R0
  paddusb    mm6, [GUpperLimit]              ; G fast patch ih
   ;
  psubusb    mm6, [GUpperLimit]              ; fast patch ih
   ;
  paddusb    mm2, [RUpperLimit]              ; R
   ;
  psubusb    mm2, [RUpperLimit]
   ;

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; here we are packing from RGB24 to RGB16
  ; input:
  ; mm6: G7 G6 G5 G4 G3 G2 G1 G0
  ; mm1: B7 B6 B5 B4 B3 B2 B1 B0
  ; mm2: R7 R6 R5 R4 R3 R2 R1 R0
  ; assuming 8 original pixels in 0-H representation on mm6, mm5, mm2
  ; when  H=2**xBITS-1 (x is for R G B)
  ; output:
  ;        mm1- result: 4 low RGB16
  ;        mm7- result: 4 high RGB16
  ; using: mm0- zero register
  ;        mm3- temporary results
  ; algorithm:
  ;   for (i=0; i<8; i++) {
  ;     RGB[i]=256*(R[i]<<(8-5))+(G[i]<<5)+B[i];
  ;   }
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  psllq      mm2, [RLeftShift]  ; position R in the most significant part of the byte
   movq      mm7, mm1                        ; mm1: Save B

  ; note: no need for shift to place B on the least significant part of the byte
  ;   R in left position, B in the right position so they can be combined

  punpcklbw  mm1, mm2                        ; mm1: 4 low 16 bit RB
   pxor      mm0, mm0                        ; mm0: 0
  punpckhbw  mm7, mm2                        ; mm5: 4 high 16 bit RB
   movq      mm3, mm6                        ; mm3: G
  punpcklbw  mm6, mm0                        ; mm6: low 4 G 16 bit
   ;
  psllw      mm6, [GLeftShift]               ; shift low G 5 positions
   ;
  punpckhbw  mm3, mm0                        ; mm3: high 4 G 16 bit
   por       mm1, mm6                        ; mm1: low RBG16
  psllw      mm3, [GLeftShift]               ; shift high G 5 positions
   ;
  por        mm7, mm3                        ; mm5: high RBG16
   ;
  mov        ebp, [YCursorOdd]               ; moved to here to save cycles before odd line
   ;
  movq       [edi], mm1                      ; !! aligned
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;- start odd line
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       mm1, [ebp+2*ebx]                ; mm1 has 8 y pixels
   pxor      mm2, mm2
  psubusb    mm1, Yadd                       ; mm1 has 8 pixels y-16
   ;
  movq       mm5, mm1
   punpcklbw mm1, mm2                        ; get 4 low y-16 unsign pixels word
  pmullw     mm1, Ymul                       ; low 4 luminance contribution
   punpckhbw mm5, mm2                        ; 4 high y-16
  pmullw     mm5, Ymul                       ; high 4 luminance contribution
   ;
  movq       [edi+8], mm7                    ; !! aligned
   movq      mm0, mm1
  paddw      mm0, [temp_mmx+24]              ; low 4 R
   movq      mm6, mm5
  psraw      mm0, [RRightShift]              ; low R scaled down by 6+(8-5)
   ;
  paddw      mm5, [temp_mmx+32]              ; high 4 R
   movq      mm2, mm1
  psraw      mm5, [RRightShift]              ; high R scaled down by 6+(8-5)
   ;
  paddw      mm2, [temp_mmx+16]              ; low 4 B
   packuswb  mm0, mm5                        ; mm0: R7 R6 R5 R4 R3 R2 R1 R0
  psraw      mm2, [BRightShift]              ; low B scaled down by 6+(8-5)
   movq      mm5, mm6
  paddw      mm6, [temp_mmx+40]              ; high 4 B
   ;
  psraw      mm6, [BRightShift]              ; high B scaled down by 6+(8-5)
   ;
  movq       mm3, [temp_mmx+8]               ; chroma G  low 4
   ;
  packuswb   mm2, mm6                        ; mm2: B7 B6 B5 B4 B3 B2 B1 B0
   movq      mm4, mm3
  punpcklwd  mm3, mm3                        ; replicate low 2
   ;
  punpckhwd  mm4, mm4                        ; replicate high 2
   psubw     mm1, mm3                        ;  4 low G
  psraw      mm1, [GRightShift]              ; low G scaled down by 6+(8-5)
   psubw     mm5, mm4                        ;  4 high G values in signed 16 bit
  psraw      mm5, [GRightShift]              ; high G scaled down by 6+(8-5)
   ;
  paddusb    mm2, [BUpperLimit]              ; mm1: saturate B+0FF-15
   packuswb  mm1, mm5                        ; mm1: G7 G6 G5 G4 G3 G2 G1 G0
  psubusb    mm2, [BUpperLimit]
   ;
  paddusb    mm1, [GUpperLimit]              ; G
   ;
  psubusb    mm1, [GUpperLimit]
   ;
  paddusb    mm0, [RUpperLimit]              ; R
   ;
  mov        eax, [tmpCCOPitch]
   ;
  psubusb    mm0, [RUpperLimit]
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; here we are packing from RGB24 to RGB16
  ; mm1: G7 G6 G5 G4 G3 G2 G1 G0
  ; mm2: B7 B6 B5 B4 B3 B2 B1 B0
  ; mm0: R7 R6 R5 R4 R3 R2 R1 R0
  ; output:
  ;        mm2- result: 4 low RGB16
  ;        mm7- result: 4 high RGB16
  ; using: mm4- zero register
  ;        mm3- temporary results
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  psllq      mm0, [RLeftShift]               ; position R in the most significant part of the byte
   movq      mm7, mm2                        ; mm7: Save B

  ; note: no need for shift to place B on the least significant part of the byte
  ;   R in left position, B in the right position so they can be combined

  punpcklbw  mm2, mm0                        ; mm1: 4 low 16 bit RB
   pxor      mm4, mm4                        ; mm4: 0
  movq       mm3, mm1                        ; mm3: G
   punpckhbw mm7, mm0                        ; mm7: 4 high 16 bit RB
  punpcklbw  mm1, mm4                        ; mm1: low 4 G 16 bit
   ;
  punpckhbw  mm3, mm4                        ; mm3: high 4 G 16 bit
   ;
  psllw      mm1, [GLeftShift]               ; shift low G 5 positions
   por       mm2, mm1                        ; mm2: low RBG16
  psllw      mm3, [GLeftShift]               ; shift high G 5 positions
   ;
  por        mm7, mm3                        ; mm7: high RBG16
   ;
  movq       [edi+eax], mm2
   ;
  movq       [edi+eax+8], mm7                ; aligned
   ;
  add        edi, 16                         ; ih take 16 bytes (8 pixels-16 bit)
   add       ebx, 4                          ; ? to take 4 pixels together instead of 2
  jl         do_next_8x2_block               ; ? update the loop for 8 y pixels at once
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Update:
  ;    edi: output RGB plane pointer for odd and even line
  ;    ebp: Y Plane address
  ;    esi: V Plane address
  ;    edx: U Plane address
  ;    YcursorEven: Even Y line address
  ;    YCursorOdd:  Odd Y line address
  ;  Note:  eax, ebx, ecx can be used as scratch registers
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ecx, [CCOSkipDistance]
   mov       eax, [localYPitch]
  add        edi, ecx                        ; go to begin of next even line
   mov       ecx, [tmpCCOPitch]
  add        edi, ecx                        ; skip odd line
   mov       ecx, [localChromaPitch]
  add        esi, ecx
   add       ebp, eax                        ; skip two lines
  mov        [YCursorEven], ebp              ; save even line address
   mov       ecx, [localChromaPitch]
  add        edx, ecx
   add       ebp, eax                        ; odd line address
  mov        [YCursorOdd], ebp               ; save odd line address
   mov       eax, [YLimit]                   ; Done with last line?
  cmp        ebp, eax
   jbe       PrepareChromaLine
;  ADDedi     CCOSkipDistance        ; go to begin of next line
;  ADDedi     tmpCCOPitch           ; skip odd line (if it is needed)
;  Leax       YPitch
;  Lebp       YCursorOdd
;  add        ebp, eax       ; skip one line
;  Sebp       YCursorEven
;
;  add        ebp, eax       ; skip one line
;  Sebp       tmpYCursorOdd
;  ADDesi     ChromaPitch
;  ADDedx     ChromaPitch
;  Leax       YLimit                  ; Done with last line?
;  cmp        ebp, eax
;  jbe        PrepareChromaLine

finish:
  mov        esp, [StashESP]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToRGB16 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12241.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;//
;// $Header:   S:\h26x\src\dec\cx512241.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12241.asv  $
;// 
;//    Rev 1.7   28 May 1996 17:57:10   AGUPTA2
;// Cosmetic changes to adhere to common coding convention in all MMX 
;// color convertors plus bug fixes.
;// 
;//
;//    Rev 1.2   26 Mar 1996 11:15:30   RMCKENZX
;//
;// Changed calling sequence to MMX_..., changed parameters to
;// new type (eliminated YUV base, etc.).  put data in MMXDATA1 segment
;// and code in MMXCODE1 segment.  cleaned and commented code.
;//
;//    Rev 1.1   20 Mar 1996 11:19:20   RMCKENZX
;// March 96 version.
;
;     Rev 1.3   18 Feb 1996 20:57:18   israelh
;  new mmx version
;
;     Rev 1.2   29 Jan 1996 19:53:52   mikeh
;
;  added Ifdef timing
;
;     Rev 1.1   29 Jan 1996 16:29:16   mikeh
;  remvoed $LOG stuff
;
;     Rev 1.0   29 Jan 1996 11:49:48   israelh
;  Initial revision.
;//
;//
;// MMX 1.2 26 Jan 1996 IsraelH
;// Optimized code.
;// Adding runtime performane measurments
;//
;// MMX 1.1 23 Dec 1995 IsraelH
;// Using direct calculations with 10.6 precission.
;// Using 8x2 loop to use the same U,V contibutions for both of the lines.
;//
;// MMX 1.0 16 Dec 1995 IsraelH
;// Port to MMX(TM) without using look up tables
;//
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB24.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cxm12241 -- This function performs YUV12-to-RGB24 color conversion for H26x.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the high order byte is R.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of 8.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
;constants for direct RGB calculation: 4x10.6 values
;PUBLIC Minusg, VtR, VtG, UtG, UtB, Ymul, Yadd, UVtG, lowrgb, lowrgbn, higp, 
;       highpn, highwn, mzero
Minusg              DWORD   00800080h,  00800080h
VtR                 DWORD   00660066h,  00660066h
VtG                 DWORD   00340034h,  00340034h
UtG                 DWORD   00190019h,  00190019h
UtB                 DWORD   00810081h,  00810081h
Ymul                DWORD   004a004ah,  004a004ah
Yadd                DWORD   10101010h,  10101010h
UVtG                DWORD   00340019h,  00340019h
lowrgb              DWORD   00ffffffh,  00000000h
lowrgbn             DWORD  0ff000000h, 0ffffffffh
highp               DWORD   00000000h, 0ff000000h
highpn              DWORD  0ffffffffh,  00ffffffh
highwn              DWORD  0ffffffffh,  0000ffffh
mzero               DWORD   00000000h,  00000000h
MMXDATA1 ENDS

MMXCODE1 SEGMENT

MMX_YUV12ToRGB24 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

LocalFrameSize           =   128
RegisterStorageSize      =   16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU   argument_base +  4
VPlane                   EQU   argument_base +  8
UPlane                   EQU   argument_base + 12
FrameWidth               EQU   argument_base + 16
FrameHeight              EQU   argument_base + 20
YPitch                   EQU   argument_base + 24
ChromaPitch              EQU   argument_base + 28
AspectAdjustmentCount    EQU   argument_base + 32
ColorConvertedFrame      EQU   argument_base + 36
DCIOffset                EQU   argument_base + 40
CCOffsetToLine0          EQU   argument_base + 44
CCOPitch                 EQU   argument_base + 48
CCType                   EQU   argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
localFrameWidth          EQU   local_base + 0
localYPitch              EQU   local_base + 4
localChromaPitch         EQU   local_base + 8
localAspectAdjustmentCount EQU local_base + 12
localCCOPitch            EQU   local_base + 16
CCOCursor                EQU   local_base + 20
CCOSkipDistance          EQU   local_base + 24
YLimit                   EQU   local_base + 28
DistanceFromVToU         EQU   local_base + 32
currAspectCount          EQU   local_base + 36
YCursorEven              EQU   local_base + 40
YCursorOdd               EQU   local_base + 44
tmpCCOPitch              EQU   local_base + 48
StashESP                 EQU   local_base + 52
; space for two DWORD locals
temp_mmx                 EQU   local_base + 64  ; note it is 64 bytes, align at QWORD

  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32                        ; align at cache line boundary
   mov       [StashESP], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Save some parameters on local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [FrameWidth]
   ;
  mov        [localFrameWidth], ebx
   mov       ebx, [YPitch]
  mov        [localYPitch], ebx
   mov       ebx, [ChromaPitch]
  mov        [localChromaPitch], ebx
   mov       ebx, [AspectAdjustmentCount]
  mov        [localAspectAdjustmentCount], ebx
   mov       ebx, [CCOPitch]
  mov        [localCCOPitch], ebx
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Set-up rest of the local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   mov       ebx, [VPlane]
  mov        ecx, [UPlane]
   mov       eax, [ColorConvertedFrame]
  sub        ecx, ebx
   mov       edx, [DCIOffset]
  mov        [DistanceFromVToU], ecx         ; UPlane - VPlane
   mov       ecx, [CCOffsetToLine0]
  add        eax, edx                        ; ColorConvertedFrame+DCIOffset
   mov       edx, [FrameHeight]
  add        eax, ecx                        ; ColorConvertedFrame+DCIOffset+CCOffsetToLine0
   mov       ecx, [localYPitch]
  mov        [CCOCursor],eax                 ; ColorConvertedFrame+DCIOffset+CCOffsetToLine0
   mov       ebx, [localFrameWidth]
  mov        eax, [CCOPitch]
   ;
  imul       edx, ecx                        ; FrameHeight*YPitch
   ;
  sub        eax, ebx                         ; CCOPitch-FrameWidth
   mov       esi, [YPlane]                   ; Fetch cursor over luma plane.
  sub        eax, ebx                         ; CCOPitch-2*FrameWidth
   add       edx, esi                         ; YPlane+Size_of_Y_array
  sub        eax, ebx                         ; CCOPitch-3*FrameWidth
   mov       [YLimit], edx                   ; YPlane+Size_of_Y_array
  mov        [CCOSkipDistance], eax          ; CCOPitch-3*FrameWidth
   mov       edx, [localAspectAdjustmentCount]
  mov       esi, [VPlane]
   cmp        edx,1
  je        finish
  mov        [currAspectCount], edx
   mov       eax, [localYPitch]
  mov        edi, [CCOCursor]
   mov       edx, [DistanceFromVToU]
  mov        ebp, [YPlane]                
   mov       ebx, [localFrameWidth]
  add        ebp,ebx
   ;
  mov        [YCursorEven], ebp
   add       ebp,eax
  mov        [YCursorOdd], ebp
   ;
  sar        ebx,1
   ;
  add        esi,ebx
   ;
  add        edx,esi
   neg       ebx
  mov        [localFrameWidth], ebx          ; -FrameWidth/2
   ;

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;
  ;  The following loops do two lines of Y (one line of UV).
  ;  The inner loop (do_next_8x2_block) does 8 pels on the even line and
  ;  the 8 pels immediately below them (sharing the same chroma) on the
  ;  odd line.
  ;
  ;  Core Register Usage:
  ;    eax    output pitch (for odd line writes)
  ;    ebx    cursor within the line.  Starts at -Width, runs up to 0
  ;    ecx        -- unused --
  ;    edx    U plane base address
  ;    ebp    Y plane base address
  ;    esi    V plane base address
  ;    edi    output RGB plane pointer
  ;
  ;  The YUV plane base addresses are previously biased by -Width and are
  ;  used in conjunction with ebx.
  ;
  ;  CAUTION:  Parameters should not be referenced beyond this point.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PrepareChromaLine:
  mov        ebp, [currAspectCount]
   mov       ebx, [localFrameWidth]
  sub        ebp, 2
   mov       eax, [localCCOPitch]
  mov        [tmpCCOPitch], eax
   ja        continue
  xor        eax, eax
   add       ebp, [localAspectAdjustmentCount]
  mov        [tmpCCOPitch], eax

continue:
  mov       [currAspectCount], ebp

do_next_8x2_block:
  mov        ebp, [YCursorEven]
   ;
  movdt      mm1, [edx+ebx]                  ; mm1 = xxxxxxxx U76 U54 U32 U10
   pxor      mm0, mm0                        ; mm0 = 0
  movdt      mm2, [esi+ebx]                  ; mm2 = xxxxxxxx V76 V54 V32 V10
   punpcklbw mm1, mm0                        ; mm1 = .U76 .U54 .U32 .U10
  psubw      mm1, Minusg                     ; unbias U (sub 128)
   punpcklbw mm2, mm0                        ; mm2 = .V76 .V54 .V32 .V10
  psubw      mm2, Minusg                     ; unbias V (sub 128)
   movq      mm3, mm1                        ; mm3 = .U76 .U54 .U32 .U10
                                             ; *** delay cycle for store ***
  movq       [temp_mmx+48], mm1               ; stash .U76 .U54 .U32 .U10
   punpcklwd mm1, mm2                        ; mm1 = .V32 .U32 .V10 .U10
  pmaddwd    mm1, UVtG                       ; mm1 = .....G32 .....G10 (from chroma)
   punpckhwd mm3, mm2                        ; mm3 = .V76 .U76 .V54 .U54
  pmaddwd    mm3, UVtG                       ; mm3 = .....G76 .....G54 (from chroma)
   ;
  movq       [temp_mmx], mm2                 ; stash .V76 .V54 .V32 .V10
   ;
  movq       mm6, [ebp+2*ebx]                ; mm6 = Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   ;
  psubusb    mm6, Yadd                       ; unbias Y (sub 16) & clip at 0
   packssdw  mm1, mm3                        ; mm1 = .G76 .G54 .G32 .G10 (from chroma)
  movq       mm7, mm6                        ; mm7 = Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   punpcklbw mm6, mm0                        ; mm6 = ..Y3 ..Y2 ..Y1 ..Y0
  pmullw     mm6, Ymul                       ; mm6 = ..G3 ..G2 ..G1 ..G0 (from luma)
   punpckhbw mm7, mm0                        ; mm7 = ..Y7 ..Y6 ..Y5 ..Y4
  pmullw     mm7, Ymul                       ; mm7 = ..G7 ..G6 ..G5 ..G4 (from luma)
   movq      mm4, mm1                        ; mm4 = .G76 .G54 .G32 .G10 (from chroma)
  movq       [temp_mmx+8], mm1               ; stash .G76 .G54 .G32 .G10 (from chroma)
   punpcklwd mm1, mm1                        ; mm1 = .G32 .G32 .G10 .G10 (from chroma)
  punpckhwd  mm4, mm4                        ; mm4 = .G76 .G76 .G54 .G54 (from chroma)
   movq      mm0, mm6                        ; mm0 = RGB3 RGB2 RGB1 RGB0 (from luma)
  movq       mm3, mm7                        ; mm3 = RGB7 RGB6 RGB5 RGB4 (from luma)
   psubw     mm6, mm1                        ; mm6 = ..G3 ..G2 ..G1 ..G0 (scaled total)
  movq       mm1, [temp_mmx+48]           ; mm1 = .U76 .U54 .U32 .U10
   psubw     mm7, mm4                        ; mm1 = ..G7 ..G6 ..G5 ..G4 (scaled total)
  psraw      mm6, 6                          ; mm6 = ..G3 ..G2 ..G1 ..G0 (total)
   movq      mm2, mm1                        ; mm2 = .U76 .U54 .U32 .U10
  punpcklwd  mm1, mm1                        ; mm1 = .U32 .U32 .U10 .U10
   ;
  pmullw     mm1, UtB                        ; mm1 = .B32 .B32 .B10 .B10 (from U)
   punpckhwd mm2, mm2                        ; mm2 = .U76 .U76 .U54 .U54
  pmullw     mm2, UtB                        ; mm2 = .B76 .B76 .B54 .B54 (from U)
   psraw     mm7, 6                          ; mm6 = ..G7 ..G6 ..G5 ..G4 (total)
  packuswb   mm6, mm7                        ; mm6: G7 G6 G5 G4 G3 G2 G1 G0
   ;                                         ; -------- green done --------
  movq       [temp_mmx+16], mm1           ; stash .B32 .B32 .B10 .B10 (from U)
   ;
  movq       [temp_mmx+40], mm2           ; stash .B76 .B76 .B54 .B54 (from U)
   paddw     mm1, mm0                        ; mm1 = ..B3 ..B2 ..B1 ..B0 (scaled total)
  paddw      mm2, mm3                        ; mm1 = ..B7 ..B6 ..B5 ..B4 (scaled total)
   psraw     mm1, 6                          ; mm1 = ..B3 ..B2 ..B1 ..B0 (total)
  psraw      mm2, 6                          ; mm1 = ..B7 ..B6 ..B5 ..B4 (total)
   ;
  packuswb   mm1, mm2                        ; mm1: B7 B6 B5 B4 B3 B2 B1 B0
   ;                                         ; -------- blue  done --------
  movq       mm2, [temp_mmx]                 ; mm2 = .V76 .V54 .V32 .V10
   ;
  movq       mm7, mm2                        ; mm7 = .V76 .V54 .V32 .V10
   punpcklwd mm2, mm2                        ; mm2 = .V32 .V32 .V10 .V10
  pmullw     mm2, VtR                        ; mm2 = .R32 .R32 .R10 .R10 (from V)
   punpckhwd mm7, mm7                        ; mm7 = .V76 .V76 .V54 .V54
  pmullw     mm7, VtR                        ; mm7 = .R76 .R76 .R54 .R54 (from V)
   ;
                                             ; *** delay for multiply ***
  movq       [temp_mmx+24], mm2           ; stash .R32 .R32 .R10 .R10 (from V)
   paddw     mm2, mm0                        ; mm2 = ..R3 ..R2 ..R1 ..R0 (total scaled)
  psraw      mm2, 6                          ; mm2 = ..R3 ..R2 ..R1 ..R0 (total)
   ;
  movq       [temp_mmx+32], mm7           ; stash .R76 .R76 .R54 .R54 (from V)
   paddw     mm7, mm3                        ; mm7 = ..R7 ..R6 ..R5 ..R4 (total scaled)
  psraw      mm7, 6                          ; mm7 = ..R7 ..R6 ..R5 ..R4 (total)
   movq      mm5, mm1                        ; mm5 = B7 B6 B5 B4 B3 B2 B1 B0
  packuswb   mm2, mm7                        ; mm2: R7 R6 R5 R4 R3 R2 R1 R0
   ;                                          ; --------  red done  --------
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; shuffle up the results:
  ;   red = mm2
  ; green = mm6
  ;  blue = mm1
  ; into red-green-blue order and store
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  punpcklbw  mm5, mm6                        ; mm5: G3 B3 G2 B2 G1 B1 G0 B0
   movq      mm4, mm2                        ; mm4 = R7 R6 R5 R4 R3 R2 R1 R0
  punpcklbw  mm4, mm4                        ; mm4: R3 R3 R2 R2 R1 R1 R0 R0
   movq      mm3, mm5                        ; mm3 = G3 B3 G2 B2 G1 B1 G0 B0
  punpcklwd  mm5, mm4                        ; mm5: R1 R1 G1 B1 R0 R0 G0 B0
   ;
  movq       mm0, mm5                        ; mm0 = R1 R1 G1 B1 R0 R0 G0 B0
   ;
  pand       mm5, lowrgb                     ; mm5: 0 0 0 0 0 R0 G0 B0
   ;
  pand       mm0, lowrgbn                    ; mm0: R1 R1 G1 B1 R0 0 0 0
   ;
  psrlq      mm0, 8                          ; mm0: 0 R1 R1 G1 B1 R0 0 0
   ;
  por        mm0, mm5                        ; mm0: x x  R1 G1 B1 R0 G0 B0
   ;
  pand       mm0, highwn                     ; mm3: 0 0 R1 G1 B1 R0 G0 B0
   movq      mm5, mm3                        ; mm5 = G3 B3 G2 B2 G1 B1 G0 B0
  punpckhwd  mm5, mm4                        ; mm5: R3 R3 G3 B3 R2 R2 G2 B2
   ;
  movq       mm4, mm5                        ; mm4 = R3 R3 G3 B3 R2 R2 G2 B2
   ;
  psllq      mm4, 48                         ; mm4: G2 B2 0 0 0 0 0 0
   ;
  por        mm0, mm4                        ; mm0: G2 B2 R1 G1 B1 R0 G0 B0
   psrlq     mm5, 24                         ; mm5: 0 0 0 R3 R3 G3 B3 R2

  punpckhbw  mm1, mm6                        ; mm1: G7 B7 G6 B6 G5 B5 G4 B4
   ;
  punpckhbw  mm2, mm2                        ; mm2: R7 R7 R6 R6 R5 R5 R4 R4
   ;
  movq       [edi], mm0                      ; !! aligned
   movq      mm7, mm1                        ; mm7: G7 B7 G6 B6 G5 B5 G4 B4
  punpcklwd  mm1, mm2                        ; mm1: R5 R5 G5 B5 R4 R4 G4 B4
   ;
  movq       mm6, mm1                        ; mm6: R5 R5 G5 B5 R4 R4 G4 B4
   punpckldq mm5, mm1                        ; mm5: R4 R4 G4 B4 R3 G3 B3 R2
  pand       mm5, highpn                     ; mm5: 0 R4 G4 B4 R3 G3 B3 R2
   psllq     mm6, 24                         ; mm6: B5 R4 R4 G4 B4 0 0 0
  pand       mm6, highp                      ; mm6: B5 0 0 0 0 0 0 0
   psrlq     mm1, 40                         ; mm1: 0 0 0 0 0 R5 R5 G5
  mov        ebp, [YCursorOdd]               ; moved to here to save cycles before odd line
   por       mm5, mm6                        ; mm5: B5 R4 G4 B4 R3 G3 B3 R2
  punpckhwd  mm7, mm2                        ; mm7: R7 R7 G7 B7 R6 R6 G6 B6
   ;
  punpcklwd  mm1, mm7                        ; mm1: x x x x G6 B6 R5 G5
   ;
  movq       [edi+8], mm5                    ; !! aligned
   ;
  movdf      [edi+16], mm1                   ; !!!!  aligned
   ;
  ;
  ; start odd line
  ;
  movq       mm1, [ebp+2*ebx]                ; mm1 has 8 y pixels
   psrlq     mm7, 24                         ; belong to even line - for cycles saving
  movdf      [edi+20], mm7                   ; !!!!  aligned
   ;
  psubusb    mm1, Yadd                       ; mm1 has 8 pixels y-16
   ;
  movq       mm5, mm1
   ;
  punpcklbw  mm1, mzero                      ; get 4 low y-16 unsign pixels word
   ;
  punpckhbw  mm5, mzero                      ; 4 high y-16
   ;
  pmullw     mm1, Ymul                       ; low 4 luminance contribution
   ;
  pmullw     mm5, Ymul                       ; high 4 luminance contribution
   movq      mm0, mm1
  paddw      mm0, [temp_mmx+24]           ; low 4 R
   movq      mm6, mm5
  paddw      mm5, [temp_mmx+32]           ; high 4 R
   psraw     mm0, 6
  psraw      mm5, 6
   ;
  movq       mm2, mm1
   packuswb  mm0, mm5                        ; mm0: R7 R6 R5 R4 R3 R2 R1 R0
                                             ; --------  red done  --------
  paddw      mm2, [temp_mmx+16]           ; low 4 B
   movq      mm5, mm6
  paddw      mm5, [temp_mmx+40]           ; high 4 B
   psraw     mm2, 6
  psraw      mm5, 6
   ;
  packuswb   mm2, mm5                        ; mm2: B7 B6 B5 B4 B3 B2 B1 B0
   ;                                         ; -------- blue  done --------

  movq       mm3, [temp_mmx+8]            ; chroma G  low 4
   ;
  movq       mm4, mm3
   punpcklwd mm3, mm3                        ; replicate low 2
  punpckhwd  mm4, mm4                        ; replicate high 2
   psubw     mm1, mm3                        ; 4 low G
  psubw      mm6, mm4                        ; 4 high G values in signed 16 bit
   psraw     mm1, 6                          ; low G
  psraw      mm6, 6                          ; high G
   ;
  packuswb   mm1, mm6                        ; mm1: G7 G6 G5 G4 G3 G2 G1 G0
   ;                                         ; -------- green done --------

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; shuffle up the results:
  ;   red = mm0
  ; green = mm1
  ;  blue = mm2
  ; into red-green-blue order and store
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       mm3, mm2                        ; B
   ;
  punpcklbw  mm3, mm1                        ; mm3: G3 B3 G2 B2 G1 B1 G0 B0
   movq      mm4, mm0                        ;  R
  punpcklbw  mm4, mm4                        ; mm4: R3 R3 R2 R2 R1 R1 R0 R0
   movq      mm5, mm3                        ;  BG
  mov        eax, [tmpCCOPitch]
   punpcklwd mm3, mm4                        ; mm3: R1 R1 G1 B1 R0 R0 G0 B0
  movq       mm6, mm3                        ; save mm3
   ;
  pand       mm6, lowrgb                     ; mm6: 0 0 0 0 0 R0 G0 B0
   ;
  pand       mm3, lowrgbn                    ; mm3: R1 R1 G1 B1 R0 0 0 0
   ;
  psrlq      mm3, 8                          ; mm3: 0 R1 R1 G1 B1 R0 0 0
   ;
  por        mm3, mm6                        ; mm3: x x R1 G1 B1 R0 G0 B0
   ;
  pand       mm3, highwn                     ; mm3: 0 0 R1 G1 B1 R0 G0 B0
   movq      mm6, mm5                        ; BG
  punpckhwd  mm6, mm4                        ; mm6: R3 R3 G3 B3 R2 R2 G2 B2
   ;
  movq       mm4, mm6
   ;
  psllq      mm4, 48                         ; mm4: G2 B2 0 0 0 0 0 0
   ;
  por        mm3, mm4                        ; mm3: G2 B2 R1 G1 B1 R0 G0 B0
   ;
  movq       [edi+eax],  mm3
  psrlq      mm6, 24                         ; mm6: 0 0 0 R3 R3 G3 B3 R2
   punpckhbw mm2, mm1                        ; mm2: G7 B7 G6 B6 G5 B5 G4 B4
  punpckhbw  mm0, mm0                        ; mm0: R7 R7 R6 R6 R5 R5 R4 R4
   movq      mm7, mm2                        ; mm7: G7 B7 G6 B6 G5 B5 G4 B4
  punpcklwd  mm7, mm0                        ; mm7: x  R5 G5 B5 x  R4 G4 B4
   ;
  punpckldq  mm6, mm7                        ; mm6: R4 R4 G4 B4 R3 G3 B3 R2
   movq      mm4, mm7
  psllq      mm4, 24                         ; mm4: B5 R4 R4 G4 B4 0 0 0
   ;
  pand       mm6, highpn                     ; mm6: 0 R4 G4 B4 R3 G3 B3 R2
   psrlq     mm7, 40                         ; mm7: 0 0 0 0 0 R5 R5 G5
  pand       mm4, highp                      ; mm4: B5 0 0 0 0 0 0 0 0
   punpckhwd mm2, mm0                        ; mm2: R7 R7 G7 B7 R6 R6 G6 B6
  por        mm6, mm4                        ; mm6: B5 R4 G4 B4 R3 G3 B3 R2
   punpcklwd mm7, mm2                        ; mm7  x x x x G6 B6 R5 G5
  psrlq      mm2, 24
   ;
  punpckldq  mm7, mm2
   ;
  movq       [edi+eax+8], mm6                ; aligned
   ;
  movq       [edi+eax+16], mm7
   add       edi, 24                         ; ih take 24 instead of 12 output
  add        ebx, 4                          ; ? to take 4 pixels together instead of 2
   jl        do_next_8x2_block               ; ? update the loop for 8 y pixels at once
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Update:
  ;    edi: output RGB plane pointer for odd and even line
  ;    ebp: Y Plane address
  ;    esi: V Plane address
  ;    edx: U Plane address
  ;    YcursorEven: Even Y line address
  ;    YCursorOdd:  Odd Y line address
  ;  Note:  eax, ebx, ecx can be used as scratch registers
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ecx, [CCOSkipDistance]
   mov       eax, [localYPitch]
  add        edi, ecx                        ; go to begin of next even line
   mov       ecx, [tmpCCOPitch]
  add        edi, ecx                        ; skip odd line
   mov       ecx, [localChromaPitch]
  add        esi, ecx
   add       ebp, eax                        ; skip two lines
  mov        [YCursorEven], ebp              ; save even line address
   mov       ecx, [localChromaPitch]
  add        edx, ecx
   add       ebp, eax                        ; odd line address
  mov        [YCursorOdd], ebp               ; save odd line address
   mov       eax, [YLimit]                   ; Done with last line?
  cmp        ebp, eax
   jbe       PrepareChromaLine
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do 2 lines loop
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

finish:
  mov        esp, [StashESP]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToRGB24 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12321.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

; $Header:   S:\h26x\src\dec\cxm12321.asv   1.4   24 May 1996 10:30:20   AGUPTA2  $
; $Log:   S:\h26x\src\dec\cxm12321.asv  $
;// 
;//    Rev 1.4   24 May 1996 10:30:20   AGUPTA2
;// Cosmetic changes to adhere to a common coding convention in all
;// MMX color convertor files.
;// 
;// 
;//    Rev 1.3   11 Apr 1996 09:51:14   RMCKENZX
;// Changed return to pop the stack.
;// 
;//    Rev 1.2   09 Apr 1996 17:15:30   RMCKENZX
;// Optimized.
;// 
;//    Rev 1.1   09 Apr 1996 09:50:32   RMCKENZX
;// Added aspect correction, fixed wrap-around, changed calling sequence.
;// 
;//    Rev 1.0   06 Apr 1996 17:06:06   RMCKENZX
;// Initial revision.
;
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by one, i.e. non-zoom.
; ||||||||
; cxm12321 -- This function performs YUV12-to-RGB32 color conversion for H26x.
;             It handles the format in which the low order byte is B, the
;             second byte is G, and the third byte is R, and the high order
;             byte is 0.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be DWORD aligned, and preferably QWORD
;             aligned.  Pitch and Width must be a multiple of 8.  The U
;             and V planes may have a different pitch than the Y plane, subject
;             to the same limitations.
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
;
; constants for direct RGB calculation:  4x10.6 values
; chroma constants are multiplied by 64 (6 fraction bits) and 255/224 (scale).
; luma constant is 64 * (255/219) = 74.55055, so it is dithered.
; 
PUBLIC C VtR, VtG, UtG, UtB, Ymul0, Ymul1, Ysub, UVsub
VtR                     DWORD       00660066h,  00660066h  ; 1.402   -> 102.14571
VtG                     DWORD      0ffccffcch, 0ffccffcch  ; -.71414 -> -52.03020
UtG                     DWORD      0ffe7ffe7h, 0ffe7ffe7h  ; -.34414 -> -25.07306
UtB                     DWORD       00810081h,  00810081h  ; 1.772   -> 129.10286
Ymul0                   DWORD       004a004bh,  004a004bh  ;             74.55055
Ymul1                   DWORD       004b004ah,  004b004ah  ;             74.55055
Ysub                    DWORD       00100010h,  00100010h  ; bias for y
UVsub                   DWORD       00800080h,  00800080h  ; bias for uv
MMXDATA1 ENDS

MMXCODE1 SEGMENT

MMX_YUV12ToRGB32 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

LocalSize                 =         20h                   ; for 7 local variables
RegisterSize              =         10h                   ; for the 4 push/pops
StashSize                 =         1200h                 ; 768 (max width) * 6 
LocalFrameSize            =         LocalSize + StashSize
FrameAdjustOne            =         800h
FrameAdjustTwo            =         LocalFrameSize - FrameAdjustOne
argument_base            EQU        ebp + RegisterSize            
local_base               EQU        esp
stash_base               EQU        esp	+ LocalSize

; Arguments:
YPlane                   EQU        argument_base + 04h
VPlane                   EQU        argument_base + 08h
UPlane                   EQU        argument_base + 0ch
FrameWidth               EQU        argument_base + 10h
FrameHeight              EQU        argument_base + 14h
LumaPitch                EQU        argument_base + 18h
ChromaPitch              EQU        argument_base + 1ch
AspectAdjustmentCount    EQU        argument_base + 20h
ColorConvertedFrame      EQU        argument_base + 24h
DCIOffset                EQU        argument_base + 28h
CCOffsetToLine0          EQU        argument_base + 2ch
CCOPitch                 EQU        argument_base + 30h


; Locals (on local stack frame)
localAspectCount         EQU        local_base + 00h
localAspectAdjustment    EQU        local_base + 04h
localWidth               EQU        local_base + 08h
localYPitch              EQU        local_base + 0ch
localUVPitch             EQU        local_base + 10h
localOutPitch            EQU        local_base + 14h
localStashEsp            EQU        local_base + 18h


; symbolic register names for shuffle segments
mmx_zero                 EQU    mm0            ; mmx_zero
											   
  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   and       esp, -32                        ; align to cache-line size
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Initialize: 'x'=live, '-'=dead, 'o'=live(ALU op)
  ;                                            esi eax ebx ecx edx edi ebp
  pxor       mmx_zero, mmx_zero              ;
   sub       esp, FrameAdjustOne             ;
  mov        edi, [CCOPitch]                 ;           			x
   mov       ecx, [ChromaPitch]              ;              x       |
  mov        ebx, [esp]                      ;      |   -   |       |
   sub       esp, FrameAdjustTwo             ;      |       |       |
  mov        eax, [LumaPitch]                ;      x       |       |
   nop
  mov        [localStashEsp], ebp            ;      |       |       |
   mov       [localOutPitch], edi            ;      | 		|	 	-
  mov        [localUVPitch], ecx             ;      |       -        
   mov       [localYPitch], eax              ;      -                
  mov        eax, [AspectAdjustmentCount]    ;	 	x
   mov       edi, [ColorConvertedFrame]      ;      |               x
  mov        [localAspectCount], eax         ;	                    |
   mov       esi, [FrameWidth]               ;  x   |        
  mov        ebx, [DCIOffset]                ;  |   |   x           |
   mov       edx, [CCOffsetToLine0]          ;  |   |   |       x   |
  add        edi, ebx                        ;  |   |   -       |   o
   add       edi, edx                        ;  |   |           -   o
  mov        [localAspectAdjustment], eax    ;	|   -               |
   mov       eax, [YPlane]                   ;  |   x               |
  lea        edi, [edi+4*esi]                ;  |   |               o           RGB plane base
   mov       ecx, [UPlane]                   ;  |   |       x       |     
  mov        edx, [VPlane]                   ;  |   |       |   x   |      
   mov       ebx, [FrameHeight]              ;  |   |   x   |   |   |           Outer loop control
  sar        esi, 1                          ;  o   |   |   |   |   |
   xor       ebp, ebp                        ;  |   |   |   |   |   |   +                         
  add        ecx, esi                        ;  +   |   |   o   |   |   |       U plane base       
   add       edx, esi                        ;  +   |   |   |   o   |   |       V plane base       
  lea        eax, [eax+2*esi]                ;  +   o   |   |   |   |   |       Y plane base             
   sub       ebp, esi                        ;  -   |   |   |   |   |   o       Inner loop control
  mov        [localWidth], ebp               ;  +   |   |   |   |   |   |       
   xor       esi, esi                        ; 	x   |   |   |   |   |   |       Stash pointer
                                             ;  v   v   v   v   v   v   v           
                                             ; esi eax ebx ecx esi edi ebp

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;
  ; ALGORITHM:
  ;  The following outer loop (do_two_lines) does two lines of Y (sharing 
  ;  one line of UV) per iteration.  It contains two inner loops.
  ;
  ;  The first inner loop (do_next_even_line) does 8 pels of the even line 
  ;  per iteration and stashes the chroma contribution on the stack.
  ;
  ;  The second inner loop (do_next_odd_line) reads the stashed chroma and 
  ;  does 8 pels of the odd line per iteration.
  ;
  ;  Aspect Adjustment is accomplished by skipping the second inner loop
  ;  if needed.
  ;
  ; CORE REGISTERS:
  ;  (all registers are pre-loaded):
  ;    eax    Y plane base address.
  ;    ebx    outer loop control.  Starts at Height, runs down to 0.
  ;    ecx    U plane base address.
  ;    edx    V plane base address.
  ;    esi    stash pointer.
  ;    edi    output RGB plane base address.
  ;    ebp    inner loop control.  Starts at -Width/2, runs up to 0.
  ;
  ;  All plane base addresses are previously biased by Width (y plane),
  ;  Width/2 (uv plane), or 4*Width (rgb plane) and are used in conjunction 
  ;  with the inner loop control, ebp.  The base addresses are updated after 
  ;  the first inner loop (Y/U/V/RGB), and after the second inner loop (Y/RGB).
  ;
  ;  The stash pointer is referenced in chromaC (with esp).  It is updated 
  ;  inside each inner loop and reset to 0 after each inner loop.
  ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; start outer loop
  ;    start first inner loop
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
do_two_lines:
do_next_even_line:
  movd       mm3, [ecx+ebp]                  ; ...3....  xxxxxxxx U76 U54 U32 U10
   ;
  movd       mm4, [edx+ebp]                  ; ...34...  xxxxxxxx V76 V54 V32 V10
   punpcklbw mm3, mmx_zero                   ; ...34...  .U76 .U54 .U32 .U10
  psubw      mm3, UVsub                      ; ...34...  unbias U (sub 128)
   punpcklbw mm4, mmx_zero                   ; ...34...  .V76 .V54 .V32 .V10
  psubw      mm4, UVsub                      ; ...34...  unbias V (sub 128)
   movq      mm1, mm3                        ; .1.34...  .U76 .U54 .U32 .U10
  pmullw     mm3, UtG                        ; .1.34...  .G76 .G54 .G32 .G10 (from U)
   movq      mm2, mm4                        ; .1234...  .V76 .V54 .V32 .V10
  pmullw     mm4, VtG                        ; .1234...  .G76 .G54 .G32 .G10 (from V)
   ;
  movq       mm6, [eax+2*ebp]                ; .123..6.  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   ;
  movq       mm7, mm6                        ; .123..67  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   punpcklbw mm6, mmx_zero                   ; .123..67  ..Y3 ..Y2 ..Y1 ..Y0
  psubw      mm6, Ysub                       ; .123..67  unbias Y (sub 16) & clip at 0
   punpckhbw mm7, mmx_zero                   ; .123..67  ..Y7 ..Y6 ..Y5 ..Y4
  psubw      mm7, Ysub                       ; .123..67  unbias Y (sub 16) & clip at 0
   paddsw    mm3, mm4                        ; .123..67  .G76 .G54 .G32 .G10 (from chroma)
  pmullw     mm6, Ymul0                      ; .123..67  RGB3 RGB2 RGB1 RGB0 (from luma) 
   movq      mm5, mm3                        ; .123.567  .G76 .G54 .G32 .G10 (from chroma)
  pmullw     mm7, Ymul0                      ; .123.567  RGB7 RGB6 RGB5 RGB4 (from luma)
   punpcklwd mm3, mm3                        ; .123.567  ..G3 ..G2 ..G1 ..G0 (from chroma)
  pmullw     mm1, UtB                        ; .123.567  .B76 .B54 .B32 .B10 (from U)
   punpckhwd mm5, mm5                        ; .123.567  ..G7 ..G6 ..G5 ..G4 (from chroma)
  movq       [stash_base+esi+00h], mm3       ; .123.567  stash low green from chroma
   paddsw    mm3, mm6                        ; .123.567  ..G3 ..G2 ..G1 ..G0 (scaled total)
  movq       [stash_base+esi+08h], mm5       ; .123.567  stash high green from chroma
   paddsw    mm5, mm7                        ; .123.567  ..G7 ..G6 ..G5 ..G4 (scaled total)
  movq       mm4, mm1                        ; .1234567  .B76 .B54 .B32 .B10 (from U)
   psraw     mm3, 6                          ; .1234567  ..G3 ..G2 ..G1 ..G0 (total)
  pmullw     mm2, VtR                        ; .1234567  .R76 .R54 .R32 .R10 (from V)
   psraw     mm5, 6                          ; .1234567  ..G7 ..G6 ..G5 ..G4 (total)
  packuswb   mm3, mm5                        ; .1234.67  G7 G6 G5 G4 G3 G2 G1 G0
   movq      mm5, mm2                        ; .1234567  .R76 .R54 .R32 .R10 (from V)
                                             ;           -------- green done --------

  punpcklwd  mm1, mm1                        ; .1234567  ..B3 ..B2 ..B1 ..B0 (from U)
   ;
  punpckhwd  mm4, mm4                        ; .1234567  ..B7 ..B6 ..B5 ..B4 (from U)
   ;
  movq       [stash_base+esi+10h], mm1       ; .1234567  stash low blue from chroma
   punpcklwd mm2, mm2                        ; .1234567  ..R3 ..R2 ..R1 ..R0 (from V)
  movq       [stash_base+esi+18h], mm4       ; .1234567  stash high blue from chroma
   punpckhwd mm5, mm5                        ; .1234567  ..R7 ..R6 ..R5 ..R4 (from V)
  paddsw     mm1, mm6                        ; .1234567  ..B3 ..B2 ..B1 ..B0 (scaled total)
   paddsw    mm4, mm7                        ; .1234567  ..B7 ..B6 ..B5 ..B4 (scaled total)
  movq       [stash_base+esi+20h], mm2       ; .1234567  stash low red from chroma
   psraw     mm1, 6                          ; .1234567  ..B3 ..B2 ..B1 ..B0 (total)
  movq       [stash_base+esi+28h], mm5       ; .1234567  stash high red from chroma
   psraw     mm4, 6                          ; .1234567  ..B7 ..B6 ..B5 ..B4 (total)
  paddsw     mm2, mm6                        ; .12345.7  ..R3 ..R2 ..R1 ..R0 (total scaled)
   packuswb  mm1, mm4                        ; .123.5.7  B7 B6 B5 B4 B3 B2 B1 B0
                                             ;           -------- blue  done --------
  paddsw     mm5, mm7                        ; .123.5..  ..R7 ..R6 ..R5 ..R4 (total scaled)
   psraw     mm2, 6                          ; .123.5..  ..R3 ..R2 ..R1 ..R0 (total)
  psraw      mm5, 6                          ; .123.5..  ..R7 ..R6 ..R5 ..R4 (total)
   ;
  packuswb   mm2, mm5                        ; .123....  R7 R6 R5 R4 R3 R2 R1 R0
   ;                                         ;           --------  red done  --------
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; shuffle up the results:
  ;   red = mm2
  ; green = mm4
  ;  blue = mm1
  ; into red-green-blue order and store
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       mm5, mm1                        ; .123.5..  blue copy
   punpcklbw mm1, mm3                        ; .123.5..  G3 B3 G2 B2 G1 B1 G0 B0
  movq       mm4, mm2                        ; .12345..  red copy
   punpcklbw mm2, mmx_zero                   ; .12345..  -- R3 -- R2 -- R1 -- R0
  movq       mm6, mm1                        ; .123456.  G3 B3 G2 B2 G1 B1 G0 B0
   punpcklwd mm1, mm2                        ; .123456.  R1 G1 B1 -- R0 G0 B0
  punpckhwd  mm6, mm2                        ; .1.3456.  -- R3 G3 B3 -- R2 G2 B2
   ;
  movq       [edi+8*ebp+00], mm1             ; ...3456.  write first two pels
   punpckhbw mm5, mm3                        ; ....456.  G7 B7 G6 B6 G5 B5 G4 B4
  movq       [edi+8*ebp+08], mm6             ; ....45..  write second two pels
   punpckhbw mm4, mmx_zero                   ; ....45..  -- R7 -- R6 -- R5 -- R4
  movq       mm7, mm5                        ; ....45.7  G7 B7 G6 B6 G5 B5 G4 B4
   punpcklwd mm5, mm4                        ; ....45.7  -- R5 G5 B5 -- R4 G4 B4
  punpckhwd  mm7, mm4                        ; .....5.7  -- R7 G7 B7 -- R6 G6 B6
   add       esi, 30h                        ; increment stash pointer
  movq       [edi+8*ebp+16], mm5             ; .......7  write third two pels
   ;
  movq       [edi+8*ebp+24], mm7             ; ........  write fourth two pels
   ;
  add        ebp, 4                          ; increment loop control
   jl        do_next_even_line               ; back up if not done
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do next even line loop 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ; add pitches to base plane addresses and check aspect
  mov        ebp, [localOutPitch]
   mov       esi, [localUVPitch]
  add        edi, ebp                        ; update RGB plane base address
   add       edx, esi                        ; update V plane base address
  add        ecx, esi                        ; update U plane base address
   mov       esi, [localYPitch]
  add        eax, esi                        ; update Y plane base address
   mov       ebp, [localAspectCount]
  sub        ebp, 2
   jle       skip_odd_line
  mov        [localAspectCount], ebp         ; store aspect count
   mov       ebp, [localWidth]               ; load inner loop control
  xor        esi, esi                        ; reset stash pointer
   ;
  movq       mm7, Ymul1                      ; pre-load Y scaling factor to mm7
   ;
  ;
  ; start odd line loop
  ;
do_next_odd_line:
  movq       mm3, [eax+2*ebp]                ; ...3....  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   ;
  movq       mm4, mm3                        ; ...34...  Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0
   punpcklbw mm3, mmx_zero                   ; ...34...  ..Y3 ..Y2 ..Y1 ..Y0
  psubw      mm3, Ysub                       ; ...34...  unbias Y
   punpckhbw mm4, mmx_zero                   ; ...34...  ..Y7 ..Y6 ..Y5 ..Y4
  psubw      mm4, Ysub                       ; ...34...  unbias Y
   pmullw    mm3, mm7                        ; ...34...  RGB3 RGB2 RGB1 RGB0 (from luma)
  movq       mm2, [stash_base+esi+20h]       ; ..234...  ..R3 ..R2 ..R1 ..R0 (from V)
   pmullw    mm4, mm7                        ; ...34...  RGB7 RGB6 RGB5 RGB4 (from luma)
  movq       mm5, [stash_base+esi+28h]       ; ..2345..  ..R7 ..R6 ..R5 ..R4 (from V)
   paddsw    mm2, mm3                        ; ..2345..  ..R3 ..R2 ..R1 ..R0 (scaled total)
  movq       mm1, [stash_base+esi+10h]       ; .12345..  ..B3 ..B2 ..B1 ..B0 (from U)
   paddsw    mm5, mm4                        ; .12345..  ..R7 ..R6 ..R5 ..R4 (scaled total)
  movq       mm6, [stash_base+esi+18h]       ; .123456.  ..B7 ..B6 ..B5 ..B4 (from U)
   psraw     mm2, 6                          ; .123456.  ..R3 ..R2 ..R1 ..R0 (total) 
  paddsw     mm1, mm3                        ; .123456.  ..B3 ..B2 ..B1 ..B0 (scaled total)
   psraw     mm5, 6                          ; .123456.  ..R7 ..R6 ..R5 ..R4 (total)
  paddsw     mm6, mm4                        ; .123456.  ..B7 ..B6 ..B5 ..B4 (scaled total)
   packuswb  mm2, mm5                        ; .1234.6.  R7 R6 R5 R4 R3 R2 R1 R0
                                             ;           --------  red done  --------
  paddsw     mm3, [stash_base+esi+00h]       ; .1234.6.  ..G3 ..G2 ..G1 ..G0 (scaled total)
   psraw     mm1, 6                          ; .1234.6.  ..B3 ..B2 ..B1 ..B0 (total)
  paddsw     mm4, [stash_base+esi+08h]       ; .1234.6.  ..G7 ..G6 ..G5 ..G4 (scaled total)
   psraw     mm6, 6                          ; .1234.6.  ..B7 ..B6 ..B5 ..B4 (total)
  packuswb   mm1, mm6                        ; .1234...  B7 B6 B5 B4 B3 B2 B1 B0
   ;                                         ;           -------- blue  done --------
  psraw      mm3, 6                          ; .1234...  ..G3 ..G2 ..G1 ..G0 (total)
   ;
  psraw      mm4, 6                          ; .1234...  ..G7 ..G6 ..G5 ..G4 (total)
   ;
  packuswb   mm3, mm4                        ; .123....  G7 G6 G5 G4 G3 G2 G1 G0
   ;                                         ;           -------- green done --------
  ;
  ; shuffle up the results:
  ;   red = mm2
  ; green = mm3
  ;  blue = mm1
  ; into red-green-blue order and store
  ;
  movq       mm5, mm1                        ; .123.5..  blue copy
   punpcklbw mm1, mm3                        ; .123.5..  G3 B3 G2 B2 G1 B1 G0 B0
  movq       mm4, mm2                        ; .12345..  red copy
   punpcklbw mm2, mmx_zero                   ; .12345..  -- R3 -- R2 -- R1 -- R0
  movq       mm6, mm1                        ; .123456.  G3 B3 G2 B2 G1 B1 G0 B0
   punpcklwd mm1, mm2                        ; .123456.  R1 G1 B1 -- R0 G0 B0
  punpckhwd  mm6, mm2                        ; .1.3456.  -- R3 G3 B3 -- R2 G2 B2
   ;
  movq       [edi+8*ebp+00], mm1             ; ...3456.  write first two pels
   punpckhbw mm5, mm3                        ; ....456.  G7 B7 G6 B6 G5 B5 G4 B4
  movq       [edi+8*ebp+08], mm6             ; ....45..  write second two pels
   punpckhbw mm4, mmx_zero                   ; ....45..  -- R7 -- R6 -- R5 -- R4
  movq       mm1, mm5                        ; .1..45..  G7 B7 G6 B6 G5 B5 G4 B4
   punpcklwd mm5, mm4                        ; .1..45..  -- R5 G5 B5 -- R4 G4 B4
  punpckhwd  mm1, mm4                        ; .1...5..  -- R7 G7 B7 -- R6 G6 B6
   add       esi, 30h                        ; increment stash pointer
  movq       [edi+8*ebp+16], mm5             ; .1......  write third two pels
   ;
  movq       [edi+8*ebp+24], mm1             ; ........  write fourth two pels
   ;
  add        ebp, 4                          ; increment loop control
   jl        do_next_odd_line                ; back up if not done
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do next odd line loop 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [localYPitch]
   mov       esi, [localOutPitch]
  add        eax, ebp                        ; update Y plane base address
   add       edi, esi                        ; update RGB plane base address
  mov        ebp, [localWidth]               ; load inner loop control
   xor       esi, esi                        ; reset stash pointer
  sub        ebx, 2                          ; decrement outer loop control
   jg        do_two_lines
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; end do two lines loop 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

finish:
  mov        esp, [localStashEsp]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret        52

skip_odd_line:
  add        eax, esi                        ; update Y plane base address
   mov       esi, [localAspectAdjustment]
  add        ebp, esi                        ; reset aspect adjustment count
   xor       esi, esi                        ; reset stash pointer
  mov        [localAspectCount], ebp         ; store aspect count
   mov       ebp, [localWidth]               ; load inner loop control
  sub        ebx, 2                          ; decrement outer loop control
   jg        do_two_lines                    ; back up if not done
; else go home
  mov        esp, [localStashEsp]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret
MMX_YUV12ToRGB32 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12322.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;//
;// $Header:   S:\h26x\src\dec\cxm12322.asv
;//
;// $Log:   S:\h26x\src\dec\cxm12322.asv  $
;// 
;//    Rev 1.6   01 Apr 1997 12:53:20   BNICKERS
;// Fix bugs # 153 and 156 -- wrong color when U is small;  right edge flickeri
;// 
;//    Rev 1.5   11 Mar 1997 13:50:24   JMCVEIGH
;// Same ARC bug fix (#94) as was done in cxm12162.asm. Without
;// this, zoom by 2 and ARC causes black lines in output (every 12th).
;// 
;//    Rev 1.4   06 Sep 1996 16:08:16   BNICKERS
;// Re-written to filter new points.
;// 
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- Version for Intel Microprocessors with MMX Technology
; |||++------ Convert from YUV12.
; |||||++---- Convert to RGB32.
; |||||||+--- Zoom by two.
; ||||||||
; cxm12322 -- This function performs zoom-by-2 YUV12-to-RGB32 color conversion
;             for H26x.  It is tuned for best performance on Intel
;             Microprocessors with MMX Technology.  This version adds new rows
;             and columns by averaging them with the originals to either side.
;
;             The YUV12 input is planar, 8 bits per pel.  The Y plane may have
;             a pitch of up to 768.  It may have a width less than or equal
;             to the pitch.  It must be QWORD aligned.  Pitch and Width must
;             be a multiple of eight.  Height may be any amount, but must be
;             a multiple of two.  The U and V planes may have a different
;             pitch than the Y plane, subject to the same limitations.
;
;             The color convertor is non-destructive;  the input Y, U, and V
;             planes will not be clobbered.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include ccinst.inc

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCCDATA SEGMENT PAGE
ALIGN 16

Luma0020004000200000 LABEL DWORD
REPEAT 16
 DD 0, 0
ENDM
CNT = 0
REPEAT 219
 DW 0
 DW (CNT*04A7FH)/00200H
 DW (CNT*04A7FH)/00100H
 DW (CNT*04A7FH)/00200H
 CNT = CNT + 1
ENDM
REPEAT 21
 DW 00000H
 DW 01FFFH
 DW 03FFFH
 DW 01FFFH
ENDM

UContribToBandG LABEL DWORD
DW -(-128*0C83H)/00040H
DW	08000H
DW -(-127*0C83H)/00040H
DW  08000H
CNT = -126
REPEAT 253
 DW -(CNT*00C83H)/00040H
 DW  (CNT*0408BH)/00040H
 CNT = CNT + 1
ENDM
DW  (127*0C83H)/00040H
DW  07FFFH

VContribToRandG LABEL DWORD
CNT = -128
REPEAT 256
 DW -(CNT*01A04H)/00040H
 DW  (CNT*03312H)/00040H
 CNT = CNT + 1
ENDM

CFF00FF00FF00FF00 DD 0FF00FF00H, 0FF00FF00H

MMXCCDATA ENDS

.CODE

ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT

; void FAR ASM_CALLTYPE YUV12ToRGB32ZoomBy2 (U8 * YPlane,
;                                            U8 * VPlane,
;                                            U8 * UPlane,
;                                            UN   FrameWidth,
;                                            UN   FrameHeight,
;                                            UN   YPitch,
;                                            UN   VPitch,
;                                            UN   AspectAdjustmentCount,
;                                            U8 * ColorConvertedFrame,
;                                            U32  DCIOffset,
;                                            U32  CCOffsetToLine0,
;                                            IN   CCOPitch,
;                                            IN   CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

PUBLIC MMX_YUV12ToRGB32ZoomBy2

MMX_YUV12ToRGB32ZoomBy2 proc DIST LANG AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD

MAXWIDTH = 768
LocalFrameSize = MAXWIDTH*20+64
RegisterStorageSize = 16

; Arguments:

YPlane_arg                = RegisterStorageSize +  4
VPlane_arg                = RegisterStorageSize +  8
UPlane_arg                = RegisterStorageSize + 12
FrameWidth_arg            = RegisterStorageSize + 16
FrameHeight               = RegisterStorageSize + 20
YPitch_arg                = RegisterStorageSize + 24
ChromaPitch_arg           = RegisterStorageSize + 28
AspectAdjustmentCount_arg = RegisterStorageSize + 32
ColorConvertedFrame       = RegisterStorageSize + 36
DCIOffset                 = RegisterStorageSize + 40
CCOffsetToLine0           = RegisterStorageSize + 44
CCOPitch_arg              = RegisterStorageSize + 48
CCType                    = RegisterStorageSize + 52
EndOfArgList              = RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                EQU  [esp+  0]
CCOPitch                 EQU  [esp+  4]
YCursor                  EQU  [esp+  8]

YLimit                   EQU  [esp+ 12]
YPitch                   EQU  [esp+ 16]
UCursor                  EQU  [esp+ 20]
DistanceFromUToV         EQU  [esp+ 24]
ChromaPitch              EQU  [esp+ 28]
AspectCount              EQU  [esp+ 32]
AspectAdjustmentCount    EQU  [esp+ 36]
StartIndexOfYLine        EQU  [esp+ 40]
StashESP                 EQU  [esp+ 44]

FiltLine0                EQU  [esp+ 64]  ; Must be 32 byte aligned.
FiltLine1                EQU  [esp+ 72]
FiltLine2                EQU  [esp+ 80]
FiltLine3                EQU  [esp+ 88]
HFiltLinePrev            EQU  [esp+ 96]

  push       esi
  push       edi
  push       ebp
  push       ebx

  mov        edi,esp
  and        esp,0FFFFF000H
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,4096
  mov        eax,[esp]
  sub        esp,LocalFrameSize-12288
  mov        eax,[esp]

  mov        eax,768
  sub        eax,[edi+FrameWidth_arg]
  imul       eax,20
  mov        StartIndexOfYLine,eax

  mov        eax,[edi+YPlane_arg]
  mov        YCursor,eax

  mov        ebx,[edi+YPitch_arg]
  mov        YPitch,ebx
  mov        ecx,[edi+FrameHeight]
  imul       ebx,ecx
  add        eax,ebx
  mov        YLimit,eax

  mov        eax,[edi+UPlane_arg]
  mov        ebx,[edi+VPlane_arg]
  mov        UCursor,eax
  sub        ebx,eax
  mov        DistanceFromUToV,ebx

  mov        eax,[edi+ColorConvertedFrame]
  add        eax,[edi+DCIOffset]
  add        eax,[edi+CCOffsetToLine0]
  mov        CCOCursor,eax

  mov        eax,[edi+ChromaPitch_arg]
  mov        ChromaPitch,eax

  mov        eax,[edi+CCOPitch_arg]
  mov        CCOPitch,eax

  mov        eax,[edi+AspectAdjustmentCount_arg]
  mov        AspectAdjustmentCount,eax
  mov        AspectCount,eax

  mov        StashESP,edi

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   xor       eax,eax
  lea        edx,[esi+ebp*2]
   xor       ebx,ebx
  mov        YCursor,edx
   mov       bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOfFirst2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  mov        al,[esi+1]                       ; Get B.
   add       edi,40                           ; Inc filtered luma temp stg idx.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >

  movq       HFiltLinePrev[edi-40],mm1        ; Save L1 as next iters LPrev.
   paddw     mm1,mm0                          ; L0+L1
  paddw      mm0,mm0                          ; 2L0
   add       esi,2                            ; Increment input index.
  movq       FiltLine3[edi-40],mm1            ; Save filtered line L0+L1.
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi-40],mm0            ; Save filtered line 2L0.
   movq      mm0,mm2                          ; Next iters A.
  mov        bl,[esi+ebp*1+2]                 ; Get c.
   cmp       edi,MAXWIDTH*20-40               ; Done yet.
  mov        al,[esi+2]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOfFirst2LumaLines

  mov        ebp,DistanceFromUToV
   lea       eax,FiltLine2
  mov        esi,UCursor
   mov       edx,StartIndexOfYLine
  jmp        DoOutputLine


Last2OutputLines:

  mov        ebp,DistanceFromUToV
   lea       esi,[edi+40]
  ja         Done

;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  mm0-mm6 -- Scratch.


  movq       mm0,HFiltLinePrev[edi]   ; Fetch horizontally filtered line LP.
  paddw      mm0,mm0                  ; 2LP

Next2PelsOfLast2LumaLines:

  movq       FiltLine3[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       FiltLine2[edi],mm0       ; Save horz and vert filt line 2LP.
  movq       mm0,HFiltLinePrev[edi+40]; Fetch horizontally filtered line LP.
  add        edi,40
   paddw     mm0,mm0                  ; 2LP
  cmp        edi,MAXWIDTH*20          ; Done yet.
   jne       Next2PelsOfLast2LumaLines

  lea        eax,FiltLine2
   mov       edx,StartIndexOfYLine
  mov        esi,UCursor
   jmp       DoOutputLine


Next4OutputLines:

  mov        esi,YCursor
   mov       ebp,YPitch
  mov        edi,StartIndexOfYLine
   mov       ecx,YLimit
  lea        edx,[esi+ebp*2]
   xor       eax,eax
  mov        YCursor,edx
   xor       ebx,ebx
  mov        al,[esi]                   ; Get Y00 (A of line L2; for left edge).
   cmp       esi,ecx
  mov        bl,[esi+ebp*1]             ; Get Y10 (a of line L3; for left edge).
   jae       Last2OutputLines

  movq       mm1,Luma0020004000200000[ebx*8]  ; L1:< 32a     64a 32a     0   >
  mov        bl,[esi+ebp*1+2]                 ; Get c.
  movq       mm0,Luma0020004000200000[eax*8]  ; L0:< 32A     64A 32A     0   >
  mov        al,[esi+2]                       ; Get C.

;  esi -- Cursor over input line of Y.
;  edi -- Index to lines of filtered Y.  Quit when MAXWIDTH*20.
;  ebp -- Pitch from one line of Y to the next.
;  al, bl  -- Y pels
;  mm0 -- For line 0, contribution of pel to left of two pels under cursor now.
;  mm1 -- For line 1, contribution of pel to left of two pels under cursor now.
;  mm2-mm6 -- Scratch.

Next2PelsOf2LumaLines:

  movq       mm3,Luma0020004000200000[ebx*8]  ; L1:< 32c     64c 32c     0   >
   psrlq     mm1,32                           ; L1:< 0       0   32a     64a >
  movq       mm2,Luma0020004000200000[eax*8]  ; L0:< 32C     64C 32C     0   >
   punpckldq mm1,mm3                          ; L1:< 32c     0   32a     64a >
  movq       mm4,HFiltLinePrev[edi]           ; LP
   psrlq     mm0,32                           ; L0:< 0       0   32A     64A >
  xor        ebx,ebx
   xor       eax,eax
  mov        bl,[esi+ebp*1+1]                 ; Get b.
   movq      mm5,mm4                          ; LP
  mov        al,[esi+1]                       ; Get B.
   add       esi,2                            ; Increment input index.
  paddw      mm1,Luma0020004000200000[ebx*8]  ; L1:< 32b+32c 64b 32a+32b 64a >
   punpckldq mm0,mm2                          ; L0:< 32C     0   32A     64A >
  paddw      mm0,Luma0020004000200000[eax*8]  ; L0:< 32B+32C 64B 32A+32B 64A >
   paddw     mm5,mm5                          ; 2LP
  movq       HFiltLinePrev[edi],mm1           ; Save L1 as next iters LPrev.
   paddw     mm4,mm0                          ; LP+L0
  movq       FiltLine0[edi],mm5               ; Save 2LP
   paddw     mm1,mm0                          ; L0+L1
  movq       FiltLine1[edi],mm4               ; Save LP+L0
   paddw     mm0,mm0                          ; 2L0
  movq       FiltLine3[edi],mm1               ; Save L0+L1
   movq      mm1,mm3                          ; Next iters a.
  movq       FiltLine2[edi],mm0               ; Save 2L0
   movq      mm0,mm2                          ; Next iters A.
  add        edi,40                           ; Inc filtered luma temp stg idx.
   mov       bl,[esi+ebp*1+2]                 ; Get c.
  cmp        edi,MAXWIDTH*20-40               ; Done yet.
   mov       al,[esi+2]                       ; Get C.
  jl         Next2PelsOf2LumaLines

  xor        ebx,ebx
   xor       ecx,ecx
  mov        bl,[esi+ebp*1+1]                 ; Get c.
   cmp       edi,MAXWIDTH*20                  ; Done yet.
  mov        al,[esi+1]                       ; Get C.
   jl        Next2PelsOf2LumaLines

  mov        ebp,DistanceFromUToV
   mov       esi,UCursor
  lea        eax,FiltLine0
   mov       edx,StartIndexOfYLine

DoOutputLine:

  mov        edi,CCOCursor
   mov       ecx,AspectCount
  dec        ecx                    ; If count is non-zero, we keep the line.
   mov       ebx,CCOPitch
  mov        AspectCount,ecx
   je        SkipOutputLine

  add        ebx,edi
   xor       ecx,ecx
  mov        cl,[esi]
   add       eax,MAXWIDTH*20
  mov        CCOCursor,ebx
   pcmpeqw   mm6,mm6
  movdt      mm0,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gu >
   psllw     mm6,15                        ; Four words of -32768
  mov        cl,[esi+ebp*1]
   sub       edx,MAXWIDTH*20
  jmp        StartDoOutputLine

; ebp -- Distance from U to V
; esi -- Cursor over U
; edi -- Cursor over output
; edx -- Index over Y storage area
; eax -- Base address of Y line
; mm6 -- Four words of -32768, to clamp at floor.

DoNext4OutputPels:

  movq       [edi-8],mm3                   ; Save 2 output pels.
   movq      mm0,mm4

StartDoOutputLine:

  movdt      mm2,VContribToRandG[ecx*4]    ; <  0    0   Rv   Gv  >
   punpcklwd mm0,mm0                       ; < Bu   Bu   Gu   Gu  >
  movq       mm1,mm0                       ; < junk junk Gu   Gu  >
   punpcklwd mm2,mm2                       ; < Rv   Rv   Gv   Gv  >
  paddw      mm1,mm2                       ; < junk junk Guv  Guv >
   punpckhdq mm0,mm0                       ; < Bu   Bu   Bu   Bu  >
  paddsw     mm0,[eax+edx]                 ; < B B B B > with ceiling clamped.
   punpckldq mm1,mm1                       ; < Guv  Guv  Guv  Guv >
  paddsw     mm1,[eax+edx]                 ; < G G G G > with ceiling clamped.
   punpckhdq mm2,mm2                       ; < Rv   Rv   Rv   Rv  >
  paddsw     mm2,[eax+edx]                 ; < R R R R > with ceiling clamped.
   paddsw    mm0,mm6                       ; B with floor clamped.
  psubsw     mm0,mm6                       ; B back in range.
   paddsw    mm1,mm6                       ; G with floor clamped.
  psubsw     mm1,mm6                       ; G back in range.
   paddsw    mm2,mm6                       ; R with floor clamped.
  add        edi,16                        ; Advance output cursor.
   xor       ecx,ecx
  psubsw     mm2,mm6                       ; R back in range.
   psrlw     mm0,7                         ; Position B bits.
  mov        cl,[esi+1]                    ; Fetch next U.
   paddw     mm1,mm1                       ; Position G bits.
  pand       mm1,CFF00FF00FF00FF00         ; Extract G bits.
   psrlw     mm2,7                         ; Position R bits.
  movdt      mm4,UContribToBandG[ecx*4]    ; <  0    0   Bu   Gv  > next iter.
   por       mm1,mm0                       ; <G3 B3 G2 B2 G1 B1 G0 B0>
  movq       mm3,mm1
   punpcklwd mm1,mm2                       ; < 0 R1 G1 B1  0 R0 G0 B0>
  inc        esi                           ; Advance input cursor
   add       edx,40                        ; Increment Y index.
  movq       [edi-16],mm1                  ; Store 2 output pels.
   punpckhwd mm3,mm2                       ; < 0 R3 G3 B3  0 R2 G2 B2>
  mov        cl,[esi+ebp*1]                ; Fetch next V.
   jne       DoNext4OutputPels

  movq       [edi-8],mm3                   ; Save 2 output pels.

PrepareForNextOutputLine:

  mov        edx,StartIndexOfYLine
   add       eax,8-MAXWIDTH*20                        ; Advance to next filtered line of Y.
  mov        esi,UCursor
   test      al,8                         ; Jump if just did line 0 or 2.
  mov        ebx,ChromaPitch
   jne       DoOutputLine

  add        esi,ebx                      ; Advance to next chroma line.
   test      al,16                        ; Jump if about to do line 2.
  mov        UCursor,esi
   jne       DoOutputLine

  sub        esi,ebx                      ; Done with 4 lines.  Restore UCursor.
  mov        UCursor,esi
   jmp       Next4OutputLines

SkipOutputLine:
  mov        ecx,AspectAdjustmentCount
   add       eax,MAXWIDTH*20
  mov        AspectCount,ecx
   jmp       PrepareForNextOutputLine

Done:

  mov        esp,StashESP
  pop        ebx
  pop        ebp
  pop        edi
  pop        esi
  rturn

MMX_YUV12ToRGB32ZoomBy2 endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx512y2.asm ===
OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include memmodel.inc
.list
.DATA

; any data would go here

.CODE

ASSUME cs: FLAT
ASSUME ds: FLAT
ASSUME es: FLAT
ASSUME fs: FLAT
ASSUME gs: FLAT
ASSUME ss: FLAT

PUBLIC  YUV12ToYUY2


YUV12ToYUY2   proc DIST LANG AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  52
RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane            =	LocalFrameSize + RegisterStorageSize + 4
uVPlane        	   = 	LocalFrameSize + RegisterStorageSize + 8
uUPlane            =	LocalFrameSize + RegisterStorageSize + 12
uWidth             = 	LocalFrameSize + RegisterStorageSize + 16
uHeight            =	LocalFrameSize + RegisterStorageSize + 20
uYPitch 	         =  LocalFrameSize + RegisterStorageSize + 24
uUVPitch           =	LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag       =  LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer    =  LocalFrameSize + RegisterStorageSize + 36
lOutput            =  LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0     =  LocalFrameSize + RegisterStorageSize + 44
intPitch           =  LocalFrameSize + RegisterStorageSize + 48
CCType             =  LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

ASMTMP1            = 48         ; 13
Y                  = 44         ; 12
U                  = 40         ; 11
V                  = 36         ; 10
Outt               = 32         ; 9
YTemp              = 28         ; 8
UTemp              = 24         ; 7 
VTemp              = 20         ; 6
ASMTMP2            = 16         ; 5
Col                = 12         ; 4
OutTemp            = 8          ; 3
VAL                = 4          ; 2
LineCount          = 0          ; 1

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_ASMTMP1                 EQU    [esp + ASMTMP1]
_Y                       EQU    [esp + Y]
_U                       EQU    [esp + U]
_V                       EQU    [esp + V]
_Out                     EQU    [esp + Outt]
_YTemp                   EQU    [esp + YTemp]
_UTemp                   EQU    [esp + UTemp]
_VTemp                   EQU    [esp + VTemp]
_ASMTMP2                 EQU    [esp + ASMTMP2]
_Col                     EQU    [esp + Col]
_OutTemp                 EQU    [esp + OutTemp]
_VAL                     EQU    [esp + VAL]
_LineCount               EQU    [esp + LineCount]


; Save registers and start working

        push       ebx
         push      esi
        push       edi
         push      ebp

        sub        esp, LocalFrameSize

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
         mov       ecx, DWORD PTR _uYPlane         ; ecx = uYPlane
        dec        eax                             ; eax = bShapingFlag - 1
         mov       edx, DWORD PTR _uUPlane         ; edx = uUPlane
        mov        DWORD PTR _LineCount, eax       ; eax = FREE, LineCount 
         mov       DWORD PTR _Y, ecx               ; ecx = FREE, Y

        mov        eax, DWORD PTR _uVPlane         ; eax = uVPlane
         mov       ecx, DWORD PTR _uOffsetToLine0  ; ecx = uOffsetToLine0
        mov        DWORD PTR _U, edx               ; edx = FREE, U
         add       ecx, DWORD PTR _lOutput         ; ecx = uOffsetToLine0 +

        mov        DWORD PTR _V, eax               ; eax = FREE, V
        mov        eax, DWORD PTR _uCCOutputBuffer ; eax = uCCOutputBuffer
        add        eax, ecx                        ; eax = uCCOutputBuffer +
                                                   ;       uOffsetToLine0 +
                                                   ;       lOutput
                                                   ;       ecx = FREE
        mov        DWORD PTR _Out, eax             ; eax = FREE, Out
        mov        eax, DWORD PTR _uHeight         ; eax = uHeight

	      sar	       eax, 1                          ; eax = uHeight/2
        mov        DWORD PTR _ASMTMP2, eax         ; eax = FREE, Row ready to 
                                                   ; count down

RowLoop:; L27704 outer loop over all rows


        mov        ecx, DWORD PTR _Y               ; ecx = Y: ecx EQU YTemp
         mov       edi, DWORD PTR _U               ; edi = U: edi EQU UTemp
        mov        ebp, DWORD PTR _V               ; ebp = V: ebp EQU VTemp 
         mov       esi, DWORD PTR _Out             ; esi = OutTemp
        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
	      test	     eax, eax                        ; is LineCount == 0? eax = FREE
        je         SHORT SkipEvenRow               ; L27708 loop if so, skip the even loop
        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2                          ; eax = uWidth/4	** assume uWidth/4 != 0


EvenRowPels:; L27709 loop over columns in even row - two YUY2 pels at a time.

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         jne       SHORT EvenRowPels               ; L27709 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
        jmp        SHORT UpdatePointers						 ; L27770

SkipEvenRow:; L27708

        mov        eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out
         
UpdatePointers:	; L27770


        mov        ecx, DWORD PTR _Y               ; ecx = Y
         dec       eax                             ; eax = LineCount-1 OR bShapingFlag - 1
        mov        edx, DWORD PTR _intPitch        ; edx = intPitch
         mov       esi, DWORD PTR _Out             ; esi = Out
				mov        DWORD PTR _LineCount, eax       ; store decremented linecount
                                                   ; eax = FREE
        add        esi, edx                        ; (esi) Out += intPitch ***
         mov       eax, DWORD PTR _uYPitch         ; eax = uYPitch
        mov        edi, DWORD PTR _U               ; edi = U	***
         add       ecx, eax                        ; (ecx) Y += uYPitch ***
        mov        ebp, DWORD PTR _V               ; ebp = V	***
         mov       DWORD PTR _Y, ecx               ; store updated Y 
      
        mov        DWORD PTR _Out, esi             ; store Out
         mov       eax, DWORD PTR _LineCount       ; eax = LineCount
    
        test       eax, eax                        ; is LineCount == 0?
                                                   ; if so, ignore the odd
                                                   ; row loop over columns
         je        SHORT SkipOddRow						  	 ; L27714

        mov        eax, DWORD PTR _uWidth          ; eax = uWidth
	      sar	       eax, 2											 ; eax = uWidth/4
	      

OddRowPels: ;L27715 loop over columns of odd rows

        mov        bl, BYTE PTR [ecx+1]            ; bl = *(YTemp + 1)
				 add       ecx, 2													 ; YTemp += 2
		    mov        bh, BYTE PTR [ebp]              ; bh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        ebx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        bh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        bl, BYTE PTR [ecx-2]            ; bl = *YTemp 			           BANK CONFLICT HERE !!!
         mov       dl, BYTE PTR [ecx+1]            ; dl = *(YTemp + 1)					 BANK CONFLICT HERE !!!
        mov        DWORD PTR [esi-4], ebx          ; store VAL in the right place 
				 add       ecx, 2													 ; YTemp += 2
		    mov        dh, BYTE PTR [ebp]              ; dh = *VTemp
				 add       esi, 4													 ; DWORD *OutTemp++;
        shl        edx, 16                         ; move VY2 to high word in ebx
				 inc       ebp                             ; VTemp++
        mov        dh, BYTE PTR [edi]              ; bh = *UTemp 
         inc       edi                         		 ; UTemp++;                                              
        mov        dl, BYTE PTR [ecx-2]            ; bl = *YTemp 
         dec       eax														 ; loop counter decrement
        mov        DWORD PTR [esi-4], edx          ; store VAL in the right place 
         
         
        jne        SHORT OddRowPels                ; L27715 loop done ? if not, go
                                                   ; around once again.

        mov        eax, DWORD PTR _LineCount       ; eax = LineCount
         jmp       SHORT UpdateAllPointers	  		 ; L27771

SkipOddRow: ;L27714 

        mov        eax, DWORD PTR _bShapingFlag		 ; eax = bShapingFlag
				 mov       edx, DWORD PTR _Out             ; edx = Out
				mov        ebx, DWORD PTR _intPitch        ; edx = intPitch
				sub        edx, ebx                        ; edx = Out - intPitch
				mov        DWORD PTR _Out, edx             ; save Out

UpdateAllPointers: ; L27771 update pointers

      	dec	       eax														 ; eax = LineCount-1 OR bShapingFlag - 1
         mov       ecx, DWORD PTR _Y							 ; ecx = Y
        mov        edx, DWORD PTR _intPitch				 ; edx = intPitch
         mov       ebx, DWORD PTR _Out						 ; ebx = Out
	      add	       ebx, edx												 ; ebx = Out + intPitch
         mov       ebp, DWORD PTR _ASMTMP2				 ; ebp = row loop counter
        mov        DWORD PTR _LineCount, eax			 ; store updated LineCount
         mov       DWORD PTR _Out, ebx						 ; store updated Out
				mov        edx, DWORD PTR _uUVPitch        ; edx = uUVPitch
				 mov       eax, DWORD PTR _U               ; eax = U
				mov        esi, DWORD PTR _V               ; esi = V
				 add       eax, edx                        ; eax = U + uUVPitch
				add        esi, edx                        ; esi = V + uUVPitch
				 mov       DWORD PTR _U, eax               ; store updated U
				mov        DWORD PTR _V, esi               ; store updated V
         add       ecx, DWORD PTR _uYPitch				 ; ecx = Y + uYPitch
	      dec	       ebp														 ; decrement loop counter
         mov       DWORD PTR _Y, ecx							 ; store updated Y
        mov        DWORD PTR _ASMTMP2, ebp				 ; store updated loop counter
        
        jne        RowLoop                         ; back to L27704 row loop



CleanUp:

        add        esp, LocalFrameSize             ; restore esp to registers                               


      	pop	ebp
	       pop	edi
	      pop	esi
	       pop	ebx

        ret     52                                 ; 13*4 bytes of arguments

YUV12ToYUY2 ENDP


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cx5128a2.asm ===
;*************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;*************************************************************************
;//
;// $Header:   S:\h26x\src\dec\cx5128a2.asv
;//
;// $Log:   S:\h26x\src\dec\cx5128a2.asv  $
;// 
;//    Rev 1.6   18 Mar 1996 09:57:48   bnickers
;// Make color convertors non-destructive.
;// 
;//    Rev 1.5   05 Feb 1996 13:35:32   BNICKERS
;// Fix RGB16 color flash problem, by allowing different RGB16 formats at oce.
;// 
;//    Rev 1.4   16 Jan 1996 11:23:02   BNICKERS
;// Fix starting point in output stream, so we don't start at line two and
;// write off the end of the output frame.
;// 
;//    Rev 1.3   22 Dec 1995 15:59:12   KMILLS
;// 
;// added new copyright notice
;// 
;//    Rev 1.2   20 Nov 1995 10:33:52   BNICKERS
;// Implement YUV12 to CLUT8AP.
;// 
;//    Rev 1.1   26 Oct 1995 09:45:24   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;// 
;//    Rev 1.0   25 Oct 1995 17:59:24   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
; +--------- Color convertor.
; |+-------- For both H261 and H263.
; ||+------- Version for the Pentium Microprocessor.
; |||++----- Convert from YUV12.
; |||||+---- Convert to CLUT8.
; ||||||+--- Active palette.
; |||||||+-- Zoom by two
; cx5128a2  -- This function performs YUV12 to CLUT8, zoom by two color
;              conversion for H26x.  It converts the input to the clut8
;              index dyncamically computed for a given active palette.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc
include ccinst.inc
include decconst.inc  

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_cx5128a2>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE YUV12ToCLUT8APZoomBy2 (U8 * YPlane,
;                                              U8 * VPlane,
;                                              U8 * UPlane,
;                                              UN  FrameWidth,
;                                              UN  FrameHeight,
;                                              UN  YPitch,
;                                              UN  VPitch,
;                                              UN  AspectAdjustmentCount,
;                                              U8 FAR * ColorConvertedFrame,
;                                              U32 DCIOffset,
;                                              U32 CCOffsetToLine0,
;                                              IN  CCOPitch,
;                                              IN  CCType)
;
;  CCOffsetToLine0 is relative to ColorConvertedFrame.
;

PUBLIC  YUV12ToCLUT8APZoomBy2

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

YUV12ToCLUT8APZoomBy2    proc DIST LANG AYPlane: DWORD,
AVPlane: DWORD,
AUPlane: DWORD,
AFrameWidth: DWORD,
AFrameHeight: DWORD,
AYPitch: DWORD,
AVPitch: DWORD,
AAspectAdjustmentCount: DWORD,
AColorConvertedFrame: DWORD,
ADCIOffset: DWORD,
ACCOffsetToLine0: DWORD,
ACCOPitch: DWORD,
ACCType: DWORD

IFDEF WIN32

LocalFrameSize = 24
RegisterStorageSize = 16

; Arguments:

YPlane                   = LocalFrameSize + RegisterStorageSize +  4
VPlane                   = LocalFrameSize + RegisterStorageSize +  8
UPlane                   = LocalFrameSize + RegisterStorageSize + 12
FrameWidth               = LocalFrameSize + RegisterStorageSize + 16
FrameHeight              = LocalFrameSize + RegisterStorageSize + 20
YPitch                   = LocalFrameSize + RegisterStorageSize + 24
ChromaPitch              = LocalFrameSize + RegisterStorageSize + 28
AspectAdjustmentCount    = LocalFrameSize + RegisterStorageSize + 32
ColorConvertedFrame      = LocalFrameSize + RegisterStorageSize + 36
DCIOffset                = LocalFrameSize + RegisterStorageSize + 40
CCOffsetToLine0          = LocalFrameSize + RegisterStorageSize + 44
CCOPitch                 = LocalFrameSize + RegisterStorageSize + 48
CCType                   = LocalFrameSize + RegisterStorageSize + 52
EndOfArgList             = LocalFrameSize + RegisterStorageSize + 56

; Locals (on local stack frame)

CCOCursor                =   0
ChromaLineLen            =   4
YLimit                   =   8
DistanceFromVToU         =  12
EndOfLine                =  16
AspectCount              =  20

LCL EQU <esp+>

ELSE

; Arguments:

RegisterStorageSize = 20           ; Put local variables on stack.
InstanceBase_zero          = RegisterStorageSize +  4
InstanceBase_SegNum        = RegisterStorageSize +  6
YPlane_arg                 = RegisterStorageSize +  8
VPlane_arg                 = RegisterStorageSize + 12
UPlane_arg                 = RegisterStorageSize + 16
FrameWidth_arg             = RegisterStorageSize + 20
FrameHeight_arg            = RegisterStorageSize + 22
YPitch_arg                 = RegisterStorageSize + 24
VPitch_arg                 = RegisterStorageSize + 26
AspectAdjustmentCount_arg  = RegisterStorageSize + 28
ColorConvertedFrame        = RegisterStorageSize + 30
ColorConvertedFrame_SegNum = RegisterStorageSize + 32
DCIOffset                  = RegisterStorageSize + 34
CCOffsetToLine0            = RegisterStorageSize + 38
CCOPitch_arg               = RegisterStorageSize + 42
EndOfArgList               = RegisterStorageSize + 44

; Locals (in per-instance data segment)

CCOCursor                  = LocalStorageCC +   0
ChromaLineLen              = LocalStorageCC +   4
YLimit                     = LocalStorageCC +   8
YPlane                     = LocalStorageCC +  12
VPlane                     = LocalStorageCC +  16
FrameWidth                 = LocalStorageCC +  20
FrameHeight                = LocalStorageCC +  24
YPitch                     = LocalStorageCC +  28
ChromaPitch                = LocalStorageCC +  32
DistanceFromVToU           = LocalStorageCC +  36
CCOPitch                   = LocalStorageCC +  40
EndOfLine                  = LocalStorageCC +  44
AspectAdjustmentCount      = LocalStorageCC +  48
AspectCount                = LocalStorageCC +  52
 
LCL EQU <>

ENDIF

  ; UV dither pattern:
  ; 2 3 2 3
  ; 0 1 0 1
  ; 2 3 2 3
  ; 0 1 0 1
  ;
  ; Y dither pattern:
  ; 0 4 1 5
  ; 6 2 7 3
  ; 1 5 0 4
  ; 7 3 6 2

  ; DS:ESI points to the beginning of the Y input block
  ; ES:EBP points to the output location
  ; EBX is available (and clear except for low 8 bits)
Ydither00 = 0
Ydither01 = 4
Ydither02 = 1
Ydither03 = 5
Ydither10 = 6
Ydither11 = 2
Ydither12 = 7
Ydither13 = 3
Ydither20 = 1
Ydither21 = 5
Ydither22 = 0
Ydither23 = 4
Ydither30 = 7
Ydither31 = 3
Ydither32 = 6
Ydither33 = 2

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  sub   esp,LocalFrameSize
  mov   ebx,PD [esp+VPlane]
  mov   ecx,PD [esp+UPlane]
  sub   ecx,ebx
  mov   PD [esp+DistanceFromVToU],ecx
  mov   eax,PD [esp+ColorConvertedFrame]
  add   eax,PD [esp+DCIOffset]
  add   eax,PD [esp+CCOffsetToLine0]
  mov   PD [esp+CCOCursor],eax
ELSE
  xor   eax,eax
  mov   eax,ds
  push  eax
  mov   ebp,esp
  and   ebp,00000FFFFH
  mov   ds, PW [ebp+InstanceBase_SegNum]
  mov   es, PW [ebp+ColorConvertedFrame_SegNum]

  mov   ebx,PD [ebp+YPlane_arg]              ; Make YPlane accessible
  mov   ds:PD YPlane,ebx
  mov   ebx,PD [ebp+VPlane_arg]              ; Make VPlane accessible.  Pre-dec.
  mov   ds:PD VPlane,ebx
  mov   ecx,PD [ebp+UPlane_arg]
  sub   ecx,ebx
  mov   ds:PD DistanceFromVToU,ecx
  mov   ax,PW [ebp+FrameWidth_arg]           ; Make FrameWidth accessible
  mov   ds:PD FrameWidth,eax
  mov   ax,PW [ebp+FrameHeight_arg]          ; Make FrameHeight accessible
  mov   ds:PD FrameHeight,eax
  mov   ax,PW [ebp+YPitch_arg]               ; Make YPitch accessible
  mov   ds:PD YPitch,eax
  mov   ax,PW [ebp+VPitch_arg]               ; Make ChromaPitch accessible
  mov   ds:PD ChromaPitch,eax
  mov   ax,PW [ebp+AspectAdjustmentCount_arg]; Make count accessible
  mov   ds:PD AspectAdjustmentCount,eax
  mov   ax,PW [ebp+ColorConvertedFrame]      ; Init CCOCursor
  add   eax,PD [ebp+DCIOffset]
  mov   ebx,PD [ebp+CCOffsetToLine0]
  add   eax,ebx
  mov   ds:PD CCOCursor,eax
  movsx ebx,PW [ebp+CCOPitch_arg]            ; Make CCOPitch accessible
  mov   ds:PD CCOPitch,ebx
ENDIF

  Ledx  FrameHeight
   Lecx YPitch
  imul  edx,ecx
   Lebx FrameWidth
  sar   ebx,1
   Lesi YPlane                   ; Fetch cursor over luma plane.
  add   edx,esi
  Sedx  YLimit
   Ledx AspectAdjustmentCOunt
  Sedx  AspectCount
   Sebx ChromaLineLen

NextFourLines:

; Convert line of U and V pels to the corresponding UVDitherPattern Indices.
;
;  Register Usage
;
;    edi -- Cursor over V line
;    esi -- Y line cursor minus 2 times V line cursor.
;    ebp -- Distance from V line to U line.
;    edx -- UVDitherPattern index:  ((V:{0:8}*9) + U:{0:8}) * 2 + 1
;    bl  -- U pel value
;    al  -- V pel value
; edx -- U contribution to active palette addresses (dithered 4 ways).
; ecx -- V contribution to active palette addresses (dithered 4 ways).


  Ledi  VPlane
   Lecx ChromaLineLen
  add   ecx,edi
   sub  esi,edi
  Lebp  DistanceFromVToU
   sub  esi,edi
  xor   eax,eax
   Ledx ChromaPitch
  mov   al,PB [edi]                  ; Fetch V pel.
   xor  ebx,ebx
  mov   bl,PB [edi+ebp*1]            ; Fetch U pel.
   add  edx,edi
  Secx  EndOfLine
   Sedx VPlane

@@:

  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+1]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1-4],ecx   ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+1]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+2]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+2]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   mov  ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
  mov   PD [esi+edi*2-768*2-8],edx   ; Store chroma contrib.
   mov  edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
  add   ecx,edx                      ; Chroma contrib to active palette address.
   mov  al,PB [edi+3]                ; Fetch next V pel.
  mov   PD [esi+edi*2-768*1+4-4],ecx ; Store chroma contrib.
   mov  bl,PB [edi+ebp*1+3]          ; Fetch U pel.
  mov   ecx,PD VContribToAPIdx[eax*4]; V contrib actv pal addr, dithered 4 ways.
   mov  al,PB [edi+4]                ; Fetch next V pel.
  mov   edx,PD UContribToAPIdx[ebx*4]; U contrib actv pal addr, dithered 4 ways.
   mov  bl,PB [edi+ebp*1+4]          ; Fetch U pel.
  add   edx,ecx                      ; Chroma contrib to active palette address.
   Lecx EndOfLine
  mov   PD [esi+edi*2-768*2+4-8],edx ; Store chroma contrib.
   add  edi,4
  sub   ecx,edi
   jne  @b

  xor   eax,eax
   xor  ebx,ebx
  lea   ebp,[esi+edi*2]              ; Compute end-of-line luma address.
   Lesi YPlane                       ; Reload luma cursor.
  Ledi  CCOCursor                    ; Re-load color converted output cursor.
   Sebp EndOfLine
  sub   edi,esi
   Lebp YPitch

; ebp -- not used.
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+0]        ; 01UL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1]        ; 01UR  Fetch UV contrib to Active Pal addr
  sub   edi,esi
   mov  PB [esi+1],cl                ; 01    Stash 7 bit luma for next line

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+2]        ; 00UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shr   cl,1                         ; 00    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+3]        ; 00UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 01    Position high order pels
   mov  PB [esi+0],cl                ; 00    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 03UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  shr   cl,1                         ; 03    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+1]        ; 03UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  PB [esi+3],cl                ; 03    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither03 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 02UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither02 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shr   cl,1                         ; 02    Reduce luma to 7 bits
   mov  bh,PB [esi-768*2-8+3]        ; 02UR  Fetch UV contrib to Active Pal addr
  shl   edx,16                       ; 03    Position high order pels
   mov  PB [esi+2],cl                ; 02    Stash 7 bit luma for next line
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither01 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+0+4]      ; 01UL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither00 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  shr   cl,1                         ; 01    Reduce luma to 7 bits
   mov  bh,PB [esi-768*1-4+1+4]      ; 01UR  Fetch UV contrib to Active Pal addr
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  PB [esi+1+4],cl              ; 01    Stash 7 bit luma for next line
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor                    ; Re-load color converted output cursor.
  Lesi  YPlane                       ; Reload luma cursor.
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine1

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine1

KeepLine1:

  mov   ah,PB [esi-768*1-4+2]        ; 01LL  Fetch UV contrib to Active Pal addr
   mov  cl,PB [esi+1]                ; 01    Fetch luma for Pel01
  mov   bh,PB [esi-768*1-4+3]        ; 01LR  Fetch UV contrib to Active Pal addr
   sub  edi,esi

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 01UL clut index
   mov  ah,PB [esi-768*1-4+0]        ; 00LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 01UR clut index
   mov  cl,PB [esi+0]                ; 00    Fetch luma for Pel00
  shl   edx,16                       ; 01    Position high order pels
   mov  bh,PB [esi-768*1-4+1]        ; 00LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 00UL clut index
   mov  ah,PB [esi-768*2-8+2]        ; 03LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 00UR clut index
   mov  cl,PB [esi+3]                ; 03    Fetch luma for Pel03
  mov   PD es:[edi+esi*2],edx        ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*2-8+3]        ; 03LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither13 -8] ; 03UL clut index
   mov  ah,PB [esi-768*2-8+0]        ; 02LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither12 -8] ; 03UR clut index
   mov  cl,PB [esi+2]                ; 02    Fetch luma for Pel02
  shl   edx,16                       ; 03    Position high order pels
   mov  bh,PB [esi-768*2-8+1]        ; 02LR  Fetch UV contrib to Active Pal addr
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither11 -8] ; 02UL clut index
   mov  ah,PB [esi-768*1-4+2+4]      ; 01LL  Fetch UV contrib to Active Pal addr
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither10 -8] ; 02UR clut index
   mov  cl,PB [esi+1+4]              ; 01    Fetch luma for Pel01
  mov   PD es:[edi+esi*2+4],edx      ; Write 4 pels to display adapter.
   mov  bh,PB [esi-768*1-4+3+4]      ; 01LR  Fetch UV contrib to Active Pal addr
  add   esi,4                        ; Advance cursor.
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine1:

  Sedi  CCOCursor
   Lesi YPlane                       ; Reload luma cursor.
  sub   edi,esi
   xor  eax,eax

; ebp -- Luma pitch
; esi -- Cursor over line 0 of row of luma blocks.
; edi -- Cursor over output line, minus twice esi.
; edx -- Area in which to build 4 pels of active-palette clut8 output.
; ecx, ebx, eax -- Index of Active palette entry for a pel.

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  sub   edi,esi
   mov  bh,PB [esi-768*1-4+0]

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+0]
  shl   edx,16
   mov  bh,PB [esi-768*1-4+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+3]
  mov   PD es:[edi+esi*2],edx
   mov  bh,PB [esi-768*2-8+0]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither23 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither22 -8]
   mov  cl,PB [esi+ebp*1+2]
  shl   edx,16
   mov  bh,PB [esi-768*2-8+2]
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither21 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither20 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  bh,PB [esi-768*1-4+0+4]
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b
    
  Ledx  CCOPitch
   Ledi CCOCursor
  Lesi  YPlane
   add  edi,edx
  Sedi  CCOCursor
   Ledx AspectCount
  sub   edi,esi
   sub  edx,2
  Sedx  AspectCount
   jg   KeepLine3

  ADDedx AspectAdjustmentCount
  Sedx  AspectCount
   jmp  SkipLine3

KeepLine3:

  mov   ah,PB [esi-768*1-4+1]
   mov  cl,PB [esi+ebp*1+1]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0]
  sub   edi,esi
   mov  PB [esi+ebp*1+1],cl

@@:

  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*1-4+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+0]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+2]
  shl   edx,16
   mov  PB [esi+ebp*1+0],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*2-8+1]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+3]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+0]
  mov   PD es:[edi+esi*2],edx
   mov  PB [esi+ebp*1+3],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither33 -8]
   mov  ah,PB [esi-768*2-8+3]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither32 -8]
   mov  cl,PB [esi+ebp*1+2]
  shr   cl,1
   mov  bh,PB [esi-768*2-8+2]
  shl   edx,16
   mov  PB [esi+ebp*1+2],cl
  mov   dh,PB ActivePaletteIdxTable[eax+ecx+Ydither31 -8]
   mov  ah,PB [esi-768*1-4+1+4]
  mov   dl,PB ActivePaletteIdxTable[ebx+ecx+Ydither30 -8]
   mov  cl,PB [esi+ebp*1+1+4]
  shr   cl,1
   mov  bh,PB [esi-768*1-4+0+4]
  mov   PD es:[edi+esi*2+4],edx
   mov  PB [esi+ebp*1+1+4],cl
  add   esi,4
   Ledx EndOfLine
  sub   edx,esi
   jne  @b

  Ledi  CCOCursor
   Ledx CCOPitch
  add   edi,edx

SkipLine3:

  add   ebp,ebp
   Lesi YPlane
  Sedi  CCOCursor
   add  esi,ebp
  Sesi  YPlane
   Ledx YLimit
  cmp   esi,edx
   jne  NextFourLines


IFDEF WIN32
  add   esp,LocalFrameSize
ELSE
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

YUV12ToCLUT8APZoomBy2 endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm1281.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;// $Header:   S:\h26x\src\dec\cx51281.asv
;//
;// $Log:   S:\h26x\src\dec\cxm1281.asv  $
;// 
;//    Rev 1.7   25 Jul 1996 13:47:58   AGUPTA2
;// Fixed blockiness problem; dither matrices were not created properly.
;// 
;//    Rev 1.6   14 Jun 1996 16:28:24   AGUPTA2
;// Cosmetic changes to adhere to common coding convention.
;// 
;//    Rev 1.5   13 May 1996 11:01:34   AGUPTA2
;// Final drop from IDC.
;//
;//    Rev 1.1   20 Mar 1996 11:19:24   RMCKENZX
;// March 96 version.
;//
;//    Rev 1.2   01 Feb 1996 10:45:58   vladip
;// Reduced number of locals, DataSegment changed to PARA
;//
;//    Rev 1.1   29 Jan 1996 18:53:40   vladip
;//
;// IFDEF TIMING is added
;//
;//    Rev 1.0   29 Jan 1996 17:28:06   vladip
;// Initial mmx verision.
;//
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by one, i.e. non-zoom.
; |||||||
; cxm1281  -- This function performs YUV12 to CLUT8 color conversion for H26x.
;             It dithers among 9 chroma points and 26 luma points, mapping the
;             8 bit luma pels into the 26 luma points by clamping the ends and
;             stepping the luma by 8.
;
;                Color convertor is not destructive.
; Requirement:
;                U and V plane SHOULD be followed by 4 bytes (for read only)
;                Y plane SHOULD be followed by 8 bytes (for read only)

OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8

PUBLIC Y0_low
PUBLIC Y1_low
PUBLIC U_low_value
PUBLIC V_low_value
PUBLIC U2_V0high_bound
PUBLIC U2_V0low_bound
PUBLIC V2_U0high_bound
PUBLIC V2_U0low_bound
PUBLIC return_from_Y_high
PUBLIC saturate_to_Y_high
PUBLIC clean_MSB_mask
PUBLIC convert_to_sign

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;  U,V,Y impacts are calculated as follows:
;              0    U < 64h
;    U impact  1ah  64h <= U < 84h
;              24h  U >= 84h
;
;              0    V < 64h
;    V impact  4eh  64h <= V < 84h
;              9ch  V >= 84h
;
;              0    Y < 1bh
;    Y impact  Y/8  1bh <= Y < ebh
;              19h  Y >= ebh
;  and the dither pattern is added to the input Y,U,V values and is a
;  4X4 matrix as defined below:
;    U
;      10h  8   18h  0
;      18h  0   10h  8
;      8    10h 0    18h
;      0    18h 8    10h
;    V 
;      8    10h 0    18h
;      0    18h 8    10h
;      10h  8   18h  0
;      18h  0   10h  8
;    Y
;      4    2   6    0
;      6    0   4    2
;      2    4   0    6
;      0    6   2    4
;  Note the following equalities in dither matrices which will explain funny
;  data declarations below:
;    U0=V2
;    U1=V3
;    U2=V0
;    U3=V1
;  More gory details can be found in the color convertor document written 
;  by IDC.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
V2_U0low_bound   DWORD  0f3ebfbe3h, 0f3ebfbe3h   ; 746c7c64746c7c64 - 8080808080808080
U2_V0low_bound   DWORD  0ebf3e3fbh, 0ebf3e3fbh,  ; 6c74647c6c74647c - 8080808080808080
                        0f3ebfbe3h, 0f3ebfbe3h   ; 746c7c64746c7c64 - 8080808080808080

U3_V1low_bound   DWORD  0e3fbebf3h, 0e3fbebf3h   ; 647c6c74647c6c74 - 8080808080808080
V3_U1low_bound   DWORD  0fbe3f3ebh, 0fbe3f3ebh,  ; 7c64746c7c64746c - 8080808080808080
                        0e3fbebf3h, 0e3fbebf3h   ; 647c6c74647c6c74 - 8080808080808080

V2_U0high_bound  DWORD  0130b1b03h, 0130b1b03h   ; 948c9c84948c9c84 - 8080808080808080
U2_V0high_bound  DWORD  00b13031bh, 00b13031bh,  ; 8c94849c8c94849c - 8080808080808080
                        0130b1b03h, 0130b1b03h   ; 948c9c84948c9c84 - 8080808080808080

U3_V1high_bound  DWORD  0031b0b13h, 0031b0b13h   ; 849c8c94849c8c94 - 8080808080808080
V3_U1high_bound  DWORD  01b03130bh, 01b03130bh,  ; 9c84948c9c84948c - 8080808080808080
                        0031b0b13h, 0031b0b13h   ; 849c8c94849c8c94 - 8080808080808080


U_low_value      DWORD  01a1a1a1ah, 01a1a1a1ah
V_low_value      DWORD  04e4e4e4eh, 04e4e4e4eh
convert_to_sign  DWORD  080808080h, 080808080h


; Y0_low,Y1_low are arrays
Y0_low           DWORD  01719151bh, 01719151bh,  ; 1b1b1b1b1b1b1b1b - 0402060004020600 ; for line%4=0
                        019171b15h, 019171b15h   ; 1b1b1b1b1b1b1b1b - 0204000602040006 ; for line%4=2

Y1_low           DWORD  0151b1719h, 0151b1719h,  ; 1b1b1b1b1b1b1b1b - 0600040206000402 ; for line%4=1
                        01b151917h, 01b151917h   ; 1b1b1b1b1b1b1b1b - 0006020400060204 ; for line%4=3

clean_MSB_mask      DWORD  01f1f1f1fh, 01f1f1f1fh
saturate_to_Y_high  DWORD  0e6e6e6e6h, 0e6e6e6e6h   ; ffh-19h
return_from_Y_high  DWORD  0dcdcdcdch, 0dcdcdcdch   ; ffh-19h-ah (return back and ADD ah);

MMXDATA1 ENDS

MMXCODE1 SEGMENT
MMX_YUV12ToCLUT8 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD
LocalFrameSize           =   108
RegisterStorageSize      =   16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU   argument_base +  4
VPlane                   EQU   argument_base +  8
UPlane                   EQU   argument_base + 12
FrameWidth               EQU   argument_base + 16
FrameHeight              EQU   argument_base + 20
YPitch                   EQU   argument_base + 24
ChromaPitch              EQU   argument_base + 28
AspectAdjustmentCount    EQU   argument_base + 32
ColorConvertedFrame      EQU   argument_base + 36
DCIOffset                EQU   argument_base + 40
CCOffsetToLine0          EQU   argument_base + 44
CCOPitch                 EQU   argument_base + 48
CCType                   EQU   argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
tmpV2_U0low_bound        EQU   local_base + 0       ; qword
tmpU2_V0low_bound        EQU   local_base + 8       ; qword
tmpU3_V1low_bound        EQU   local_base + 16      ; qword
tmpV3_U1low_bound        EQU   local_base + 24      ; qword
tmpV2_U0high_bound       EQU   local_base + 32      ; qword
tmpU2_V0high_bound       EQU   local_base + 40      ; qword
tmpU3_V1high_bound       EQU   local_base + 48      ; qword
tmpV3_U1high_bound       EQU   local_base + 56      ; qword
tmpY0_low                EQU   local_base + 64      ; qword
tmpY1_low                EQU   local_base + 72      ; qword
tmpBlockParity           EQU   local_base + 80
YLimit                   EQU   local_base + 84
AspectCount              EQU   local_base + 88
tmpYCursorEven           EQU   local_base + 92
tmpYCursorOdd            EQU   local_base + 96
tmpCCOPitch              EQU   local_base + 100
StashESP                 EQU   local_base + 104

U_low                    EQU   mm6
V_low                    EQU   mm7
U_high                   EQU   U_low
V_high                   EQU   V_low
		
  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32                        ; align at cache line boundary
   mov       [StashESP], ebp

  mov        ecx, [YPitch]
   mov       edx, [FrameHeight]
  mov        ebx, [FrameWidth]
   ;
  imul       edx, ecx
   ;
  mov        eax, [YPlane]
   add       edx, eax                        ; edx is relative to YPlane
  add        eax, ebx                        ; Points to end of Y even line
   ;
  mov        [tmpYCursorEven], eax
   add       eax, ecx                        ; add YPitch
  mov        [tmpYCursorOdd], eax
   lea       edx, [edx+2*ebx]                ; final value of Y-odd-pointer
  mov        [YLimit], edx
   mov       esi, [VPlane]
  mov        edx, [UPlane]
   mov       eax, [ColorConvertedFrame]
  add        eax, [DCIOffset]
   ;
  add        eax, [CCOffsetToLine0]
   sar       ebx, 1
  add        esi, ebx
   add       edx, ebx
  lea        edi, [eax+2*ebx]                ; CCOCursor
   mov       ecx, [AspectAdjustmentCount]
  mov        [AspectCount], ecx
   test      ecx, ecx                        ; if AspectCount=0 we should not drop any lines
  jnz        non_zero_AspectCount
   dec       ecx
non_zero_AspectCount:
  mov        [AspectCount], ecx
   cmp       ecx, 1
  jbe        finish
   ;
  neg        ebx
   ;
  mov        [FrameWidth], ebx
   ;
  movq       mm6, U_low_value                ; store some frequently used values in registers
   ;
  movq       mm7, V_low_value
   xor       eax, eax
  mov        [tmpBlockParity], eax

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Register Usage:
  ;
  ;  esi -- points to the end of V Line
  ;  edx -- points to the end of U Line.
  ;  edi -- points to the end of even line of output.
  ;  ebp -- points to the end of odd  line of output.
  ;
  ;  ecx -- points to the end of even/odd Y Line
  ;  eax -- 8*(line&2) == 0,  on line%4=0,1
  ;                    == 8,  on line%4=2,3
  ;         in the loop, eax points to the end of even Y line
  ;  ebx -- Number of points, we havn't done yet. (multiplyed by -0.5)
  ;
  ;
  ; Noise matrix is of size 4x4 , so we have different noise values in even 
  ; pair of lines, and in odd pair of lines. But in our loop we are doing 2 
  ; lines. So here we are prepairing constants for next two lines.  This code
  ; is done each time we are starting to convert next pair of lines.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PrepareNext2Lines:
  mov        eax, [tmpBlockParity]
   ;
  ;constants for odd line
  movq       mm0, V3_U1low_bound[eax]
   ;
  movq       mm1, V3_U1high_bound[eax]
   ;
  movq       mm2, U3_V1low_bound[eax]
   ;
  movq       mm3, U3_V1high_bound[eax]
   ;
  movq       [tmpV3_U1low_bound], mm0
   ;
  movq       [tmpV3_U1high_bound], mm1
   ;
  movq       [tmpU3_V1low_bound], mm2
   ;
  movq       [tmpU3_V1high_bound], mm3
   ;
  ;
  ;constants for even line
  ;
  movq       mm0, V2_U0low_bound[eax]
   ;
  movq       mm1, V2_U0high_bound[eax]
   ;
  movq       mm2, U2_V0low_bound[eax]
   ;
  movq       mm3, U2_V0high_bound[eax]
   ;
  movq       [tmpV2_U0low_bound], mm0
   ;
  movq       [tmpV2_U0high_bound], mm1
   ;
  movq       [tmpU2_V0low_bound], mm2
   ;
  movq       [tmpU2_V0high_bound], mm3
   ;
  ;
  ; Constants for Y values
  ;
  movq       mm4, Y0_low[eax]
   ;
  movq       mm5, Y1_low[eax]
   ;
  xor        eax, 8
   mov       [tmpBlockParity], eax
  movq       [tmpY0_low], mm4
   ;
  movq       [tmpY1_low], mm5
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; if AspectCount<2 we should skip a line. In this case we are still doing two
  ; lines, but output pointers are the same, so we just overwriting line 
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        eax, [CCOPitch]
   mov       ebx, [AspectCount]
  xor        ecx, ecx
   sub       ebx, 2
  mov        [tmpCCOPitch], eax
   ja        continue
  mov        eax, [AspectAdjustmentCount]
   mov       [tmpCCOPitch], ecx              ; 0
  lea        ebx, [ebx+eax]                  ; calculate new AspectCount
   jnz       continue                        ; skiping even line
  ;
  ;skip_odd_line
  ;
  mov       eax, [tmpYCursorEven]
   ;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; set odd constants to be equal to even_constants
  ; Odd line will be performed as even
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  movq       [tmpV3_U1low_bound], mm0
   ;
  movq       [tmpV3_U1high_bound], mm1
   ;
  movq       [tmpU3_V1low_bound], mm2
   ;
  movq       [tmpU3_V1high_bound], mm3
   ;
  movq       [tmpY1_low], mm4
   ;
  mov        [tmpYCursorOdd], eax
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; when we got here, we already did all preparations.
  ; we are entering a main loop which is starts at do_next_2x8_block label
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
continue:
  mov        [AspectCount], ebx
   mov       ebx, [FrameWidth]
  mov        ebp, edi
   ;
  add        ebp, [tmpCCOPitch]              ; ebp points to the end of odd line
   mov       eax, [tmpYCursorEven]
  mov        ecx, [tmpYCursorOdd]
   ;
  movdt      mm0, [edx+ebx]                  ; 0:0:0:0|u3:u2:u1:u0 unsigned
   ;
  movdt      mm2, [esi+ebx]                  ; 0:0:0:0|v3:v2:v1:v0 unsigned
   punpcklbw mm0, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0 unsigned
  psubb      mm0, convert_to_sign            ; u3:u3:u2:u2|u1:u1:u0:u0 signed
   punpcklbw mm2, mm2                        ; v3:v3:v2:v2|v1:v1:v0:v0 unsigned
  movq       mm4, [eax+2*ebx]                ; y7|..|y0
   ;
  movq       mm1, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0
   ;
do_next_2x8_block:
  psubb      mm2, convert_to_sign            ; v3:v3:v2:v2|v1:v1:v0:v0 signed
   movq      mm5, mm1                        ; u3:u3:u2:u2|u1:u1:u0:u0
  pcmpgtb    mm0, [tmpV2_U0low_bound]
   movq      mm3, mm2
  pcmpgtb    mm1, [tmpV2_U0high_bound]
   pand      mm0, U_low
  psubusb    mm4, [tmpY0_low]
   pand      mm1, U_high
  pcmpgtb    mm2, [tmpU2_V0low_bound]
   psrlq     mm4, 3
  pand       mm4, clean_MSB_mask
   pand      mm2, V_low
  paddusb    mm4, saturate_to_Y_high
   paddb     mm0, mm1                        ; U03:U03:U02:U02|U01:U01:U00:U00
  psubusb    mm4, return_from_Y_high
   movq      mm1, mm5
  pcmpgtb    mm5, [tmpV3_U1low_bound]
   paddd     mm0, mm2
  pcmpgtb    mm1, [tmpV3_U1high_bound]
   pand      mm5, U_low
  paddd      mm0, mm4
   movq      mm2, mm3
  pcmpgtb    mm3, [tmpU2_V0high_bound]
   pand      mm1, U_high
  movq       mm4, [ecx+2*ebx]                ; read next 8 Y points from odd line
   paddb     mm5, mm1                        ; u impact on odd line
  psubusb    mm4, [tmpY1_low]
   movq      mm1, mm2
  pcmpgtb    mm2, [tmpU3_V1low_bound]
   psrlq     mm4, 3
  pand       mm4, clean_MSB_mask
   pand      mm2, V_low
  paddusb    mm4, saturate_to_Y_high
   paddd     mm5, mm2
  psubusb    mm4, return_from_Y_high
   pand      mm3, V_high
  pcmpgtb    mm1, [tmpU3_V1high_bound]
   paddb     mm3, mm0
  movdt      mm0, [edx+ebx+4]                ; read next 4 U points
   pand      mm1, V_high
  movdt      mm2, [esi+ebx+4]                ; read next 4 V points
   paddd     mm5, mm4
  movq       mm4, [eax+2*ebx+8]              ; read next 8 Y points from even line
   paddb     mm5, mm1
  psubb      mm0, convert_to_sign
   punpcklbw mm2, mm2                        ; v3:v3:v2:v2|v1:v1:v0:v0
  movq       [edi+2*ebx], mm3                ; write even line
   punpcklbw mm0, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0
  movq       [ebp+2*ebx], mm5                ; write odd line
   movq      mm1, mm0                        ; u3:u3:u2:u2|u1:u1:u0:u0
  add        ebx, 4
   jl        do_next_2x8_block
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ; update pointes to input and output buffers, to point to the next lines
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [StashESP]
   mov       eax, [tmpYCursorEven]
  mov        ecx, [YPitch]
   add       edi, [CCOPitch]                 ; go to the end of next line
  add        edi, [tmpCCOPitch]              ; skip odd line
   lea       eax, [eax+2*ecx]
  mov        [tmpYCursorEven], eax
   add       eax, [YPitch]
  mov        [tmpYCursorOdd], eax
   add       esi, [ChromaPitch]
  mov        ecx, [YLimit]                   ; Done with last line?
   add       edx, [ChromaPitch]
  cmp        eax, ecx
   jb        PrepareNext2Lines

finish:
  mov        esp, [StashESP]
   ;
  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToCLUT8 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mbimot.asm ===
;--------------------------------------------------------------------------;
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  D3mBiMot.asm
;
;  Description:
;    This module does bi-directional motion compensated prediction for 
;    B frames.  It is called after forward prediction has been computed
;    and will average in the backward prediction for those pels where 
;    the backward motion vector points inside of the referenced P frame.
;
;  MMx Version
;
;  Routines:                          prototypes in:
;    MMX_BiMotionComp                 none
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d3mbimot.asv   1.2   01 Apr 1996 12:35:48   RMCKENZX  $
;  $Log:   S:\h26x\src\dec\d3mbimot.asv  $
;// 
;//    Rev 1.2   01 Apr 1996 12:35:48   RMCKENZX
;// 
;// Added MMXCODE1 and MMXDATA1 segments, moved global data
;// to MMXDATA1 segment.
;// 
;//    Rev 1.1   14 Mar 1996 13:58:00   RMCKENZX
;// 
;// Optimized routine for speed of execution.
;// 
;//    Rev 1.0   07 Mar 1996 18:36:36   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  Routine Name:
;    MMX_BiMotionComp(U32, U32, I32, I32, I32)
;
;  Inputs -- C calling convention:
;    pPrev       flat pointer to prediction from previous P frame
;                used for "forward" motion vector prediction.
;    pCurr       flat pointer into current P frame
;                to be used for "backward" motion vector prediction.
;    mvx         x component of backward motion vector.
;    mvy         y component of backward motion vector.
;    iNum        block number.
;
;  Returns:
;    updates the values pointed to by pPrev.
;
;--------------------------------------------------------------------------;
;
;  Version:     .006
;  Date:        14 March 1996
;  Author:      R. McKenzie
;
;--------------------------------------------------------------------------;

.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

;-------------------;
;     Stack Use     ;
;-------------------;

; register storage (rel to old stack ptr as saved in ebp)
;	esi               ebp+00
;	edi               ebp+04
;	ebp               ebp+08
;	ebx               ebp+12

; return address      ebp+16

; C input parameters
  pPrev        EQU    ebp+20
  pCurr        EQU    ebp+24
  mvx          EQU    ebp+28
  mvy          EQU    ebp+32
  iNum         EQU    ebp+36


; local variables
  uColEnd      EQU    esp+00
  uRowEnd      EQU    esp+02
  uColStart    EQU    esp+04
  uRowStart    EQU    esp+06
  mmxTempL     EQU    esp+08
  mmxTempH     EQU    esp+16


  PITCH         =     384
  FRAMESIZE     =      32

MMXDATA1 SEGMENT
ALIGN 8
                         ;     End        Start
                         ;  Row   Col   Row   Col
                         ;   y     x     y     x
mmxFudge        DWORD       001e001eh,  00010001h 
                DWORD       001e000eh,  0001fff1h 
                DWORD       000e001eh, 0fff10001h 
                DWORD       000e000eh, 0fff1fff1h 
                DWORD       000e000eh,  00010001h
                DWORD       000e000eh,  00010001h

mmxClipT        DWORD       7ff87ff8h,  7ff77ff7h
mmxClipB        DWORD       7ff77ff7h,  7ff77ff7h
                                                    ; start
ColStartMask    DWORD      0ffffffffh, 0ffffffffh   ;   0
                DWORD      0ffffff00h, 0ffffffffh   ;   1      
                DWORD      0ffff0000h, 0ffffffffh   ;   2      
                DWORD      0ff000000h, 0ffffffffh   ;   3      
                DWORD       00000000h, 0ffffffffh   ;   4      
                DWORD       00000000h, 0ffffff00h   ;   5      
                DWORD       00000000h, 0ffff0000h   ;   6      
                DWORD       00000000h, 0ff000000h   ;   7    end      
ColEndMask      DWORD       00000000h,  00000000h   ;   8     0      
                DWORD       000000ffh,  00000000h   ;         1      
                DWORD       0000ffffh,  00000000h   ;         2      
                DWORD       00ffffffh,  00000000h   ;         3      
                DWORD      0ffffffffh,  00000000h   ;         4      
                DWORD      0ffffffffh,  000000ffh   ;         5      
                DWORD      0ffffffffh,  0000ffffh   ;         6      
                DWORD      0ffffffffh,  00ffffffh   ;         7
                DWORD      0ffffffffh, 0ffffffffh   ;         8

ShiftMask       DWORD       7f7f7f7fh,  7f7f7f7fh	; used for byte shifts
BottomBitMask   DWORD       01010101h,  01010101h	; used for packed averages
Round1          DWORD       00010001h,  00010001h

MMXDATA1 ENDS


;-------------------;
;      Set Up       ;
;-------------------;
MMXCODE1 SEGMENT

PUBLIC C MMX_BiMotionComp

MMX_BiMotionComp:
  push       ebx
  push       ebp

  push       edi
  push       esi

  mov        ebp, esp
  and        esp, -32                    ; align the stack on a cache line

  sub        esp, FRAMESIZE              ; make room for locals

  mov        edi, [iNum]
  mov        esi, [pCurr]

                                         ;         start      end
  movd       mm1, [mvx]				     ; mm1 = 0000 0000 .... .mvx

  movd       mm2, [mvy]                  ; mm2 = 0000 0000 .... .mvy

  movq       mm0, [mmxFudge+8*edi]
  punpcklwd  mm1, mm2                    ; mm1 = .... .... .mvy .mvx

  movq       mm3, [mmxClipT]
  punpckldq  mm1, mm1                    ; mm1 = .mvy .mvx .mvy .mvx

  movq       mm4, [mmxClipB]
  psubw      mm0, mm1

  mov        edi, [pPrev]
  psraw      mm0, 1                      ; mm0 = RowStart ColStart RowEnd ColEnd

  mov        ebx, [mvy]
  paddsw     mm0, mm3                    ; clip at 8 or higher

  and        ebx, -2                     ; 2*(mvy>>1)
  psubusw    mm0, mm4				     ; clip at 0 or lower

  shl        ebx, 6                      ; 128*(mvy>>1)
  mov        eax, [mvx]

  movq       [uColEnd], mm0

  sar        eax, 1                      ; mvx>>1
  lea        ebx, [ebx+2*ebx]            ; PITCH*(mvy>>1)

  add        esi, ebx                    ; pCurr += PITCH*(mvy>>1)
  xor        ecx, ecx

  add        esi, eax                    ; pCurr += mvx>>1
  xor        edx, edx

  mov        cl, [uColStart]             ; uColStart
  mov        dl, [uColEnd]               ; uColEnd

  cmp        ecx, edx                    ; iColCount = ColStart - ColEnd
  jge        hasta_la_vista_baby

  movq       mm6, ColStartMask[8*ecx]

  movq       mm7, ColEndMask[8*edx]
  pxor       mm4, mm4                    ; mm4 = 0

  mov        cl, [uRowStart]             ; RowStart
  mov        dl, [uRowEnd]               ; RowEnd

  sub        edx, ecx                    ; iRowCount = RowEnd - RowStart
  jle        hasta_la_vista_baby

  pand       mm7, mm6                    ; mm7 = ff for those cols to use back pred.
  pxor       mm6, mm6

  shl        ecx, 7                      ; 128*RowStart
  mov        eax, [mvx]

  movq       mm5, [ShiftMask]            ; mm5 = 7f 7f 7f 7f  7f 7f 7f 7f
  pcmpeqb    mm6, mm7                    ; mm6 is the complement of mm7
  
  lea        ecx, [ecx+2*ecx]            ; PITCH*RowStart
  mov        ebx, [mvy]

  add        esi, ecx                    ; pCurr += PITCH*RowStart
  add        edi, ecx                    ; pPrev += PITCH*RowStart        

  mov        ecx, PITCH


  and      eax, 1
  je       even_mvx

  and      ebx, 1
  je       odd_even

;
;  mvx is odd (horizontal half pel motion)
;  mvy is odd (vertical half pel motion)
;
odd_odd:
  movq       mm0, [esi+4]

  movq       mm1, mm0
  psrlq      mm0, 8

  movq       mm2, [esi]
  punpcklbw  mm1, mm4

  movq       mm3, mm2
  punpcklbw  mm0, mm4

  paddw      mm0, mm1
  psrlq      mm2, 8

  paddw      mm0, [Round1]
  punpcklbw  mm3, mm4

  punpcklbw  mm2, mm4
  add        esi, ecx

  movq       [mmxTempH], mm0
  paddw      mm2, mm3

  paddw      mm2, [Round1]

  sub        edi, ecx                    ; pre decrement destination pointer

  movq       [mmxTempL], mm2


;
;  This loop is 2-folded and works on 2 results (rows) per pass.
;  It finishes one result per iteration.
;
;  Stage I
;    computes the partial sums of a row with a shifted copy of the row.
;    It stores the partial sums for the next iteration's Stage II.
;  Stage II 
;    reads the partial sums of the prior row and averages them with the
;    just computed (in Stage I) partial sums of the current row to get
;    the backward prediction.  These computations are done unpacked as
;    16-bit words.  A rounding factor is added to each partial sum before
;    storage.  Then stage II averages the result (with truncation) with 
;    the forward prediction.
;
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging of the forward with backward is done packed in 8-bit bytes by 
;    dividing both inputs by 2, adding them together, and then adding in an 
;    adjustment.  To average with truncation, the adjustment is 1 when BOTH 
;    inputs are odd.  Due to the absence of a byte shift instruction, divide
;    by 2 is done by shifting the entire mmx register and then masking off 
;    (zeroing) bits , 15, ..., and 63 (the old low-order bits) using mm5.
;   
OddOddLoop:
  movq       mm1, [esi]                  ; load left half

  movq       mm0, mm1                    ; copy left half
  psrlq      mm1, 8                      ; shift left over

  movq       mm3, [esi+4]                ; load right half
  punpcklbw  mm0, mm4                    ; unpack left half

  movq       mm2, mm3                    ; copy right half
  punpcklbw  mm1, mm4                    ; unpack shifted left half

  paddw      mm1, mm0                    ; add left side
  psrlq      mm3, 8                      ; shift right over

  paddw      mm1, [Round1]               ; add in round to left
  punpcklbw  mm2, mm4                    ; unpack right half

  movq       mm0, [mmxTempL]             ; fetch prior row's left half
  punpcklbw  mm3, mm4                    ; unpack shifted right half

  movq       [mmxTempL], mm1             ; stash this row's left half
  paddw      mm3, mm2                    ; add right side

  paddw      mm3, [Round1]               ; add in round to right
  paddw      mm0, mm1                    ; sum current & prior lefts

  movq       mm2, [mmxTempH]             ; fetch prior row's right half
  psrlw      mm0, 2                      ; divide left sum by four

  movq       [mmxTempH], mm3             ; stash this rows right half
  paddw      mm2, mm3                    ; sum current & prior rights

  movq       mm1, [edi+ecx]              ; fetch forward prediction
  psrlw      mm2, 2                      ; divide right sum by four

  packuswb   mm0, mm2                    ; complete backward prediction
  movq       mm2, mm1                    ; copy forward

  pand       mm0, mm7                    ; mask off unused bytes
  pand       mm2, mm6                    ; create replacement bytes

  por        mm0, mm2                    ; new backward prediction
  movq       mm3, mm1                    ; copy forward for adjustment

  pand       mm3, mm0                    ; adjustment with truncation
  psrlq      mm0, 1                      ; divide new backward by 2

  pand       mm0, mm5                    ; clear extra bits
  psrlq      mm1, 1                      ; divide forward by 2

  pand       mm3, [BottomBitMask]        ; complete adjustment
  pand       mm1, mm5                    ; clear extra bits

  paddb      mm0, mm1                    ; sum quotients
  add        edi, ecx                    ; increment destination pointer

  paddb      mm0, mm3                    ; add addjustment
  add        esi, ecx                    ; increment source pointer

  movq       [edi], mm0                  ; store result
                                         ; *** 1 cycle store penalty ***

  dec        edx                         ; decrement loop control
  jg         OddOddLoop                  ; back up if not done


;  wrap up and go home
  mov        esp, ebp

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  ret


;
;  mvx is odd (horizontal half pel motion)
;  mvy is even (vertical full pel motion)
;
odd_even:
  sub        edi, ecx                    ; pre decrement destination pointer

;
;  This loop is not folded and does 1 result (row) per pass.
;
;    It loads the backward predicted row into mm0 and brings in the last
;    (eighth) byte through al, which is or'd with the shifted row.  It
;    completes the bacward prediction (by averaging the rows with round)
;    and averages the result (with truncation) with the forward prediction.
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging is done by dividing both inputs by 2, adding them together,
;    and then adding in an adjustment.
;    To average with round, the adjustment is 1 when EITHER input is odd. 
;    To average with truncation, the adjustment is 1 when BOTH inputs are odd.
;    Due to the absence of a byte shift instruction, divide by 2 is done
;    by shifting the entire mmx register and then masking off (zeroing) bits
;    7, 15, ..., and 63 (the old low-order bits) using mm5.
;   
OddEvenLoop:
  movq       mm0, [esi]                  ; fetch backward predicted row

  mov        al, [esi+8]                 ; fetch last byte
  movq       mm1, mm0                    ; copy row

  movd       mm2, eax                    ; last byte
  psrlq      mm0, 8	                     ; shift row right 1 byte

  movq       mm3, mm1                    ; copy row for adjustment
  psllq      mm2, 56                     ; move last byte to left end                     

  por        mm0, mm2                    ; or in last byte on left
  psrlq      mm1, 1                      ; divide row by 2

  por        mm3, mm0                    ; averaging with rounding bit
  psrlq      mm0, 1                      ; divide shifted row by 2

  pand       mm0, mm5                    ; clear extra bits
  pand       mm1, mm5                    ; clear extra bits

  pand       mm3, [BottomBitMask]        ; finish adjustment (with round)
  paddb      mm0, mm1                    ; sum quotients

  movq       mm4, [edi+ecx]              ; fetch forward prediction
  paddb      mm3, mm0                    ; add adjustment, got back pred.
  
  movq       mm2, mm4                    ; copy forward
  pand       mm3, mm7                    ; mask off unused bytes

  movq       mm1, mm4                    ; copy forward
  pand       mm2, mm6                    ; mask forward copy

  por        mm3, mm2                    ; backward with forward replacing
  psrlq      mm4, 1                      ; divide forward by 2

  pand       mm1, mm3                    ; adjustment for truncation
  psrlq      mm3, 1                      ; divide bacwards by 2

  pand       mm3, mm5                    ; clear extra bits
  pand       mm4, mm5                    ; clear extra bits

  pand       mm1, [BottomBitMask]        ; finish adjustment (with truncation)
  paddb      mm4, mm3                    ; sum quotients

  paddb      mm4, mm1                    ; add adjusment, have result
  add        edi, ecx                    ; increment destination pointer

  add        esi, ecx                    ; increment source pointer
  dec        edx                         ; decrement loop control

  movq       [edi], mm4                  ; save result

  jg         OddEvenLoop                 ; loop when not done


;  wrap up and go home
  mov        esp, ebp

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  ret

;---------------------------;
;  mvx is even -- test mvy  ;
;---------------------------;
even_mvx:
  and      ebx, 1
  je       even_even

;
;  mvx is even (horizontal full pel motion)
;  mvy is odd (vertical half pel motion)
;
even_odd:
  movq       mm0, [esi]                  ; 1:  first row

  movq       mm1, [esi+ecx]              ; 1:  second row
  movq       mm2, mm0                    ; 1:  copy for rounding

  por        mm2, mm1                    ; 1:  averaging with round
  sub        edi, ecx                    ; pre deccrement destination pointer

  dec        edx                         ; note that edx is positive on entry 
  jz         EvenOddPost

;
;  This loop is 2-folded and works on 2 results (rows) per pass.
;  It finishes one result per iteration.
;  Stage I
;    loads both backward predicted rows into mm0 and mm1, copies the first
;    into mm2, and ors with the second for the rounding adjustment.
;  Stage II
;    completes the bacward prediction (by averaging the rows with round)
;    and averages the result (with truncation) with the forward prediction.
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging is done by dividing both inputs by 2, adding them together,
;    and then adding in an adjustment (in mm2).
;    To average with round, the adjustment is 1 when EITHER input is odd. 
;    To average with truncation, the adjustment is 1 when BOTH inputs are odd.
;    Due to the absence of a byte shift instruction, divide by 2 is done
;    by shifting the entire mmx register and then masking off (zeroing) bits
;    7, 15, ..., and 63 (the old low-order bits) using mm5.
;   
EvenOddLoop:
  psrlq      mm0, 1                      ; 2:  divide first row by 2
  add        edi, ecx                    ; increment destination pointer

  psrlq      mm1, 1                      ; 2:  divide second row by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  rounding bits
  pand       mm1, mm5                    ; 2:  clear extra bits

  movq       mm3, [edi]                  ; 2:  fetch forward prediction
  paddb      mm1, mm0                    ; 2:  average backward rows

  paddb      mm1, mm2                    ; 2:  add in round
  movq       mm4, mm3                    ; 2:  copy for mask  

  pand       mm1, mm7                    ; 2:  masked backward prediction
  pand       mm4, mm6                    ; 2:  masked forward prediction

  por        mm4, mm1                    ; 2:  adjusted backwards prediction
  movq       mm2, mm3                    ; 2:  copy for rounding

  pand       mm2, mm4                    ; 2:  averaging with truncation
  psrlq      mm4, 1                      ; 2:  divide bacwards by 2

  psrlq      mm3, 1                      ; 2:  divide forwards by 2
  pand       mm4, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  "no-round" bits
  pand       mm3, mm5                    ; 2:  clear extra bits

  movq       mm0, [esi+ecx]              ; 1:  first row
  paddb      mm4, mm3                    ; 2:  average forward & backwards

  movq       mm1, [esi+2*ecx]            ; 1:  second row
  paddb      mm4, mm2                    ; 2:  add in "no-round" bits 

  movq       mm2, mm0                    ; 1:  copy for rounding
  add        esi, ecx                    ; increment source pointer

  movq       [edi], mm4                  ; 2:  store resulting row
  por        mm2, mm1                    ; 1:  averaging with rounding bit

  dec        edx                         ; decrement loop count
  jg         EvenOddLoop                 ; back up if not done

EvenOddPost:
  psrlq      mm0, 1                      ; 2:  divide first row by 2
  add        edi, ecx                    ; increment destination pointer

  psrlq      mm1, 1                      ; 2:  divide second row by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  rounding bits
  pand       mm1, mm5                    ; 2:  clear extra bits

  movq       mm3, [edi]                  ; 2:  fetch forward prediction
  paddb      mm1, mm0                    ; 2:  average backward rows

  paddb      mm1, mm2                    ; 2:  add in round
  movq       mm4, mm3                    ; 2:  copy for mask  

  pand       mm1, mm7                    ; 2:  masked backward prediction
  pand       mm4, mm6                    ; 2:  masked forward prediction

  por        mm4, mm1                    ; 2:  adjusted backwards prediction
  movq       mm2, mm3                    ; 2:  copy for rounding

  pand       mm2, mm4                    ; 2:  averaging with truncation
  psrlq      mm4, 1                      ; 2:  divide bacwards by 2

  psrlq      mm3, 1                      ; 2:  divide forwards by 2
  pand       mm4, mm5                    ; 2:  clear extra bits

  pand       mm2, [BottomBitMask]        ; 2:  "no-round" bits
  pand       mm3, mm5                    ; 2:  clear extra bits

  paddb      mm4, mm3                    ; 2:  average forward & backwards
  mov        esp, ebp

  paddb      mm4, mm2                    ; 2:  add in "no-round" bits 
  mov        ecx, edi

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  movq       [ecx], mm4                  ; 2:  store resulting row

  ret


;
;  mvx is even (horizontal full pel motion)
;  mvy is even (vertical full pel motion)
;
even_even:
  movq       mm1, [edi]                  ; 1:  forward prediction

  movq       mm0, [esi]                  ; 1:  backward prediction
  movq       mm2, mm1                    ; 1:  copy forward for mask

  pand       mm0, mm7                    ; 1:  mask off unused bytes
  sub        edi, ecx                    ; pre deccrement destination pointer

  dec        edx                         ; note that edx is positive on entry 
  jz         EvenEvenPost

;
;  This loop is 2-folded and works on 2 results (rows) per pass.
;  It finishes one result per iteration.
;  Stage I
;    loads mm0 and mm1 with the predictions and begins the replacement
;    procedure for the forward prediction.
;  Stage II
;    finishes the replacement procedure for the forward prediction and 
;    averages that (with truncation) with the bacwards prediction.
;    Those bytes of the backwards prediction which are not to be used are
;    replaced by the corresponding bytes of the forwards prediction prior 
;    to averaging (using the masks in registers mm6 and mm7). 
;
;    Averaging is done by dividing both inputs by 2, adding them together,
;    and then adding in an adjustment (in mm2).
;    To average with round, the adjustment is 1 when EITHER input is odd. 
;    To average with truncation, the adjustment is 1 when BOTH inputs are odd.
;    Due to the absence of a byte shift instruction, divide by 2 is done
;    by shifting the entire mmx register and then masking off (zeroing) bits
;    7, 15, ..., and 63 (the old low-order bits) using mm5.
;          
EvenEvenLoop:
  pand       mm2, mm6                    ; 2:  mask corresponding bytes
  add        edi, ecx                    ; increment destination pointer

  por        mm0, mm2                    ; 2:  replace unused back with for.
  movq       mm3, mm1                    ; 2:  copy forward for adjustment

  pand       mm3, mm0                    ; 2:  adjustment for truncation
  psrlq      mm0, 1                      ; 2:  divide back by 2

  psrlq      mm1, 1                      ; 2:  divide forward by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm3, [BottomBitMask]        ; 2:  finish adjustment
  pand       mm1, mm5                    ; 2:  clear extra bits

  paddb      mm0, mm1                    ; 2:  sum quotients
  add        esi, ecx                    ; increment source pointer

  movq       mm1, [edi+ecx]              ; 1:  forward prediction
  paddb      mm3, mm0                    ; 2:  add in adjusment

  movq       mm0, [esi]                  ; 1:  backward prediction
  movq       mm2, mm1                    ; 1:  copy forward for mask

  movq       [edi], mm3                  ; 2:  store result
  pand       mm0, mm7                    ; 1:  mask off unused bytes

  dec        edx                         ; decrement loop control
  jg         EvenEvenLoop                ; loop back when not done
          
EvenEvenPost:
  pand       mm2, mm6                    ; 2:  mask corresponding bytes
  add        ecx, edi

  por        mm0, mm2                    ; 2:  replace unused back with for.
  movq       mm3, mm1                    ; 2:  copy forward for adjustment

  pand       mm3, mm0                    ; 2:  adjustment for truncation
  psrlq      mm0, 1                      ; 2:  divide back by 2

  psrlq      mm1, 1                      ; 2:  divide forward by 2
  pand       mm0, mm5                    ; 2:  clear extra bits

  pand       mm3, [BottomBitMask]        ; 2:  finish adjustment
  pand       mm1, mm5                    ; 2:  clear extra bits

  paddb      mm0, mm1                    ; 2:  sum quotients
  mov        esp, ebp

  paddb      mm3, mm0                    ; 2:  add in adjusment
  nop

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  movq       [ecx], mm3

  ret

;
;  "Remember when I promised to kill you last?"
;
bye_bye:
hasta_la_vista_baby:
  mov        esp, ebp

  pop        esi
  pop        edi

  pop        ebp
  pop        ebx

  ret
MMXCODE1 ENDS

;        1111111111222222222233333333334444444444555555555566666666667777777
;234567890123456789012345678901234567890123456789012345678901234567890123456
;--------------------------------------------------------------------------;
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm1282.asm ===
;-------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;-------------------------------------------------------------------------

;-------------------------------------------------------------------------
;// $Header:   S:\h26x\src\dec\cx51282.asv
;//
;// $Log:   S:\h26x\src\dec\cxm1282.asv  $
;// 
;//    Rev 1.7   14 Jun 1996 16:30:00   AGUPTA2
;// Cosmetic changes to adhere to common coding convention.
;// 
;//    Rev 1.6   13 May 1996 11:03:42   AGUPTA2
;// Final drop from IDC.
;//
;//    Rev 1.3   02 Apr 1996 16:30:54   RMCKENZX
;// Corrected two bugs in set-up.
;//
;//    Rev 1.1   20 Mar 1996 11:19:28   RMCKENZX
;// March 96 version.
;//
;//    Rev 1.2   05 Feb 1996 11:45:02   vladip
;// initial mmx almost optimized version
;//
;//    Rev 1.1   29 Jan 1996 18:53:38   vladip
;//
;// IFDEF TIMING is added
;//
;//    Rev 1.0   29 Jan 1996 17:28:08   vladip
;// Initial revision.
;//
;//    Rev 1.2   03 Nov 1995 14:39:42   BNICKERS
;// Support YUV12 to CLUT8 zoom by 2.
;//
;//    Rev 1.1   26 Oct 1995 09:46:10   BNICKERS
;// Reduce the number of blanks in the "proc" statement because the assembler
;// sometimes has problems with statements longer than 512 characters long.
;//
;//    Rev 1.0   25 Oct 1995 17:59:22   BNICKERS
;// Initial revision.
;-------------------------------------------------------------------------
;
; +---------- Color convertor.
; |+--------- For both H261 and H263.
; ||+-------- MMx Version.
; |||++------ Convert from YUV12.
; |||||+----- Convert to CLUT8.
; ||||||+---- Zoom by two.
; |||||||
; cxm1282  -- This function performs YUV12 to CLUT8 zoom-by-2 color conversion
;             for H26x.  It dithers among 9 chroma points and 26 luma
;             points, mapping the 8 bit luma pels into the 26 luma points by
;             clamping the ends and stepping the luma by 8.
;
;             1. The color convertor is destructive;  the input Y, U, and V
;                planes will be clobbered.  The Y plane MUST be preceded by
;                1544 bytes of space for scratch work.
;             2. U and V planes should be preceded by 4 bytes (for read only)
;
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

.586
.xlist
include iammx.inc
include memmodel.inc
.list


MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

;------------------------------------------------------------
PQ      equ PD
;------------------------------------------------------------

;=============================================================================
MMXDATA1 SEGMENT
ALIGN 8

EXTRN convert_to_sign   : DWORD              ; Defined in cxm1281.asm
EXTRN V2_U0low_bound    : DWORD
EXTRN V2_U0high_bound   : DWORD
EXTRN U2_V0low_bound    : DWORD
EXTRN U2_V0high_bound   : DWORD
EXTRN U_low_value       : DWORD
EXTRN V_low_value       : DWORD
EXTRN Y0_low            : DWORD
EXTRN Y1_low            : DWORD
EXTRN clean_MSB_mask    : DWORD
EXTRN saturate_to_Y_high: DWORD
EXTRN return_from_Y_high: DWORD

Y0_correct               EQU Y1_low+8
Y1_correct               EQU Y0_low+8
Y2_correct               EQU Y1_low
Y3_correct               EQU Y0_low
U_high_value             EQU U_low_value
V_high_value             EQU V_low_value

MMXDATA1 ENDS

MMXCODE1 SEGMENT

MMX_YUV12ToCLUT8ZoomBy2 PROC DIST LANG PUBLIC,
  AYPlane:              DWORD,
  AVPlane:              DWORD,
  AUPlane:              DWORD,
  AFrameWidth:          DWORD,
  AFrameHeight:         DWORD,
  AYPitch:              DWORD,
  AVPitch:              DWORD,
  AAspectAdjustmentCnt: DWORD,
  AColorConvertedFrame: DWORD,
  ADCIOffset:           DWORD,
  ACCOffsetToLine0:     DWORD,
  ACCOPitch:            DWORD,
  ACCType:              DWORD
LocalFrameSize           = 56
RegisterStorageSize      = 16
argument_base            EQU ebp + RegisterStorageSize
local_base               EQU esp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Arguments:
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
YPlane                   EQU   argument_base +  4
VPlane                   EQU   argument_base +  8
UPlane                   EQU   argument_base + 12
FrameWidth               EQU   argument_base + 16
FrameHeight              EQU   argument_base + 20
YPitch                   EQU   argument_base + 24
ChromaPitch              EQU   argument_base + 28
AspectAdjustmentCount    EQU   argument_base + 32
ColorConvertedFrame      EQU   argument_base + 36
DCIOffset                EQU   argument_base + 40
CCOffsetToLine0          EQU   argument_base + 44
CCOPitch                 EQU   argument_base + 48
CCType                   EQU   argument_base + 52
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Locals (on local stack frame)
;   (local_base is aligned at cache-line boundary in the prologue)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
localVPlane              EQU   local_base + 0
localFrameWidth          EQU   local_base + 4
localYPitch              EQU   local_base + 8
localChromaPitch         EQU   local_base + 12
localAspectAdjustmentCount EQU local_base + 16
localCCOPitch            EQU   local_base + 20
CCOCursor                EQU   local_base + 24
YLimit                   EQU   local_base + 28
DistanceFromVToU         EQU   local_base + 32
AspectCount              EQU   local_base + 36
CCOLine1                 EQU   local_base + 40
CCOLine2                 EQU   local_base + 44
CCOLine3                 EQU   local_base + 48
StashESP                 EQU   local_base + 52
  push       esi
   push      edi
  push       ebp
   push      ebx
  mov        ebp, esp
   sub       esp, LocalFrameSize
  and        esp, -32                        ; align at cache line boundary
   mov       [StashESP], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Save some parameters on local stack frame
  ;  localVPlane
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [VPlane]
   ;
  mov        [localVPlane], ebx
   mov       ebx, [FrameWidth]
  mov        [localFrameWidth], ebx
   mov       ebx, [YPitch]
  mov        [localYPitch], ebx
   mov       ebx, [ChromaPitch]
  mov        [localChromaPitch], ebx
   mov       ebx, [AspectAdjustmentCount]
  mov        [localAspectAdjustmentCount], ebx
   mov       ebx, [CCOPitch]
  mov        [localCCOPitch], ebx
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Set-up rest of the local stack frame
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [localVPlane]
   mov       ecx, [UPlane]
  sub        ecx, ebx
   mov       eax, [ColorConvertedFrame]
  mov        [DistanceFromVToU], ecx
   ;
  add        eax, [DCIOffset]
   ;
  add        eax, [CCOffsetToLine0]
   ;
  mov        [CCOCursor], eax
   mov       edx, [FrameHeight]
  mov        ecx, [localYPitch]
   ;
  imul       edx, ecx
   ;
  mov        edi, [localCCOPitch]
   mov       esi, [YPlane]                    ; Fetch cursor over luma plane.
  mov        [CCOCursor], eax
   add       edx, esi
  mov        [YLimit], edx
   mov       edx, [localAspectAdjustmentCount]
  mov        [AspectCount], edx
   mov       edi, esi
  mov        ebx, [localFrameWidth]
   mov       eax, [CCOCursor]                ; CCOLine0
  sar        ebx, 1
   sub       ebx, 4                          ; counter starts from maxvalue-4, and in last iteration it equals 0
  mov        ecx, eax
   ;
  add        edi, [localYPitch]              ; edi = odd Y line cursor
   ;
  add        ecx, [localCCOPitch]
   mov       [localFrameWidth], ebx
  mov        [CCOLine1], ecx
   mov       ebx, [localCCOPitch]
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  in each outer loop iteration,  4 lines of output are done.
  ;  in each inner loop iteration block 4x16 of output is done.
  ;  main task of outer loop is to prepare pointers for inner loop
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Arguments should not be referenced beyond this point
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
NextFourLines:
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  eax : CCOLine0
  ;  ebx : CCOPitch
  ;  ecx : CCOLine1
  ;  edx : available
  ;  esi : Cursor over even Y line
  ;  edi : Cursor over odd Y line
  ;  ebp : available
  ;  prepare output pointers : CCOLine1, CCOLine2, CCOLine3
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [AspectCount]
   ;
  sub        ebp, 2
   jg        continue1                       ; jump if it still>0
  add        ebp, [localAspectAdjustmentCount]
   mov       ecx, eax                        ; Output1 will overwrite Output0 line
  mov        [CCOLine1], ecx
continue1:
  lea        edx, [ecx+ebx]                  ; CCOLine2
   sub       ebp, 2
  mov        [CCOLine2], edx
   jg        continue2                       ; jump if it still>0
  add        ebp, [localAspectAdjustmentCount]
   xor       ebx, ebx                        ; Output3 will overwrite Output2 line
continue2:
  mov        [AspectCount], ebp
   lea       ebp, [edx+ebx]
  mov        [CCOLine3], ebp
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  Inner loop does 4x16 block of output points (2x8 of input points)
  ;  Register Usage
  ;    eax : cursor over Output
  ;    ebx : counter
  ;    ecx : cursor over Output1,2,3
  ;    edx : Cursor over V line
  ;    esi : Cursor over even Y line
  ;    edi : Cursor over odd Y line
  ;    ebp : Cursor over U line.
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebp, [localVPlane]
   mov       ebx, [localFrameWidth]
  mov        edx, ebp
   add       ebp, [DistanceFromVToU]         ; Cursor over U line.
  movdt      mm3, [ebp+ebx]                  ; read 4 U points
   ;
  movdt      mm2, [edx+ebx]                  ; read 4 V points
   punpcklbw mm3, mm3                        ; u3:u3:u2:u2|u1:u1:u0:u0
prepare_next4x8:
  psubb      mm3, convert_to_sign
   punpcklbw mm2, mm2                        ; v3:v3:v2:v2|v1:v1:v0:v0
  psubb      mm2, convert_to_sign
   movq      mm4, mm3
  movdt      mm7, [esi+2*ebx]                ; read even Y line
   punpcklwd mm3, mm3                        ; u1:u1:u1:u1|u0:u0:u0:u0
  mov        ecx, [CCOLine1]
   movq      mm1, mm3
  pcmpgtb    mm3, V2_U0low_bound
   punpcklbw mm7, mm7                        ; y3:y3:y2:y2|y1:y1:y0:y0
  pand       mm3, U_low_value
   movq      mm5, mm7
  psubusb    mm7, Y0_correct
   movq      mm6, mm2
  pcmpgtb    mm1, V2_U0high_bound
   punpcklwd mm2, mm2                        ; v1:v1:v1:v1|v0:v0:v0:v0
  pand       mm1, U_high_value
   psrlq     mm7, 3
  pand       mm7, clean_MSB_mask
   movq      mm0, mm2
  pcmpgtb    mm2, U2_V0low_bound
   ;
  pcmpgtb    mm0, U2_V0high_bound
   paddb     mm3, mm1
  pand       mm2, V_low_value
   pand      mm0, V_high_value
  paddusb    mm7, saturate_to_Y_high
   paddb     mm3, mm2
  psubusb    mm7, return_from_Y_high         ; Y impact on line0
   paddd     mm3, mm0                        ; common U,V impact on line 0
  psubusb    mm5, Y1_correct
   paddb     mm7, mm3                        ; final value of line 0
  movq       mm0, mm3                        ; u31:u21:u11:u01|u30:u20:u10:u00
   psrlq     mm5, 3
  pand       mm5, clean_MSB_mask
   psrld     mm0, 16                         ;    :   :u31:u21|   :   :u30:u20
  paddusb    mm5, saturate_to_Y_high
   pslld     mm3, 16                         ; u11:u01:   :   |u10:u00:   :
  psubusb    mm5, return_from_Y_high         ; Y impact on line0
   por       mm0, mm3                        ; u11:u01:u31:u21|u10:u00:u30:u20
  movdt      mm3, [edi+2*ebx]                ; odd Y line
   paddb     mm5, mm0                        ; final value of line 0
  punpcklbw  mm3, mm3                        ; y3:y3:y2:y2|y1:y1:y0:y0
   movq      mm2, mm0                        ; u11:u01:u31:u21|u10:u00:u30:u20
  movq       [ecx+4*ebx], mm5                ; write Output1 line
   movq      mm1, mm3
  movq       [eax+4*ebx], mm7                ; write Output0 line
   psrlw     mm0, 8                          ; :u11:   :u31|   :u10:   :u30
  psubusb    mm1, Y3_correct
   psllw     mm2, 8                          ; u01:   :u21:   |u00:   :u20:
  psubusb    mm3, Y2_correct
   psrlq     mm1, 3
  pand       mm1, clean_MSB_mask
   por       mm0, mm2                        ; u01:u11:u21:u31|u00:u10:u20:u30
  paddusb    mm1, saturate_to_Y_high
   psrlq     mm3, 3
  psubusb    mm1, return_from_Y_high
   movq      mm5, mm0                        ; u01:u11:u21:u31|u00:u10:u20:u30
  pand       mm3, clean_MSB_mask
   paddb     mm1, mm0
  paddusb    mm3, saturate_to_Y_high
   psrld     mm5, 16
  psubusb    mm3, return_from_Y_high
   pslld     mm0, 16
  mov        ecx, [CCOLine3]
   por       mm5, mm0                        ; u21:u31:u01:u11|u20:u30:u00:u10
  movdt      mm2, [esi+2*ebx+4]              ; read next even Y line
   paddb     mm5, mm3
  movq       [ecx+4*ebx], mm1                ; write Output3 line
   punpckhwd mm4, mm4                        ; u3:u3:u3:u3|u2:u2:u2:u2
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  start next 4x8 block of output
  ;  SECOND uv-QWORD
  ;  mm6, mm4 are live
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ecx, [CCOLine2]
   movq      mm3, mm4
  pcmpgtb    mm4, V2_U0low_bound
   punpckhwd mm6,mm6
  movq       [ecx+4*ebx], mm5                ; write Output2 line
   movq      mm7, mm6
  pand       mm4, U_low_value
   punpcklbw mm2, mm2                        ; y3:y3:y2:y2|y1:y1:y0:y0
  pcmpgtb    mm3, V2_U0high_bound
   movq      mm5, mm2
  pand       mm3, U_high_value
   ;
  pcmpgtb    mm6, U2_V0low_bound
   paddb     mm4, mm3
  pand       mm6, V_low_value
   ;
  pcmpgtb    mm7, U2_V0high_bound
   paddb     mm4, mm6
  pand       mm7, V_high_value
   ;
  psubusb    mm2, Y0_correct
   paddd     mm4, mm7
  psubusb    mm5, Y1_correct
   psrlq     mm2, 3
  pand       mm2, clean_MSB_mask
   movq      mm3, mm4                        ; u31:u21:u11:u01|u30:u20:u10:u00
  paddusb    mm2, saturate_to_Y_high
   pslld     mm3, 16                         ; u11:u01:   :   |u10:u00:   :
  psubusb    mm2, return_from_Y_high
   psrlq     mm5, 3
  pand       mm5, clean_MSB_mask
   paddb     mm2, mm4                        ; MM4=u31:u21:u11:u01|u30:u20:u10:u00, WHERE U STANDS FOR UNATED U AND V IMPACTS
  paddusb    mm5, saturate_to_Y_high
   psrld     mm4, 16                         ;    :   :u31:u21|   :   :u30:u20
  psubusb    mm5, return_from_Y_high
   por       mm4, mm3                        ; u11:u01:u31:u21|u10:u00:u30:u20
  paddb      mm5, mm4
   mov       ecx, [CCOLine1]
  movdt      mm0, [edi+2*ebx+4]              ; read odd Y line
   movq      mm7, mm4                        ; u11:u01:u31:u21|u10:u00:u30:u20
  movq       [ecx+4*ebx+8], mm5              ; write Output1 line
   punpcklbw mm0, mm0                        ; y3:y3:y2:y2|y1:y1:y0:y0
  movq       [eax+4*ebx+8], mm2              ; write Output0 line
   movq      mm1, mm0
  psubusb    mm1, Y2_correct
   psrlw     mm4, 8                          ;    :u11:   :u31|   :u10:   :u30
  psubusb    mm0, Y3_correct
   psrlq     mm1, 3
  pand       mm1, clean_MSB_mask
   psllw     mm7, 8                          ; u01:   :u21:   |u00:   :u20:
  paddusb    mm1, saturate_to_Y_high
   por       mm4, mm7                        ; u01:u11:u21:u31|u00:u10:u20:u30
  psubusb    mm1, return_from_Y_high
   psrlq     mm0, 3
  pand       mm0, clean_MSB_mask
   movq      mm5, mm4                        ; u01:u11:u21:u31|u00:u10:u20:u30
  paddusb    mm0, saturate_to_Y_high
   psrld     mm5, 16
  psubusb    mm0, return_from_Y_high
   ;
  paddb      mm0, mm4
   mov       ecx, [CCOLine3]
  movdt      mm3, [ebp+ebx-4]                ; read next 4 U points
   pslld     mm4, 16
  movq       [ecx+4*ebx+8], mm0              ; write Output3 line
   por       mm5, mm4                        ; u21:u31:u01:u11|u20:u30:u00:u10
  paddb      mm5, mm1
   mov       ecx, [CCOLine2]
  movdt      mm2, [edx+ebx-4]                ; read next 4 V points
   punpcklbw mm3, mm3                        ; u3:u3:u2:u2|u1:u1:u0:u0
  movq       [ecx+4*ebx+8], mm5              ; write Output2 line
   ;
  sub        ebx, 4
   jae       prepare_next4x8
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;  ebp must point to arguments
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  mov        ebx, [localCCOPitch]
   mov       ecx, [CCOLine3]
  mov        ebp, [localYPitch]
   mov       edx, [localVPlane]
  lea        eax, [ecx+ebx]                  ; next Output0 = old Output3 + CCOPitch
   lea       ecx, [ecx+2*ebx]                ; next Output1 = old Output3 + 2* CCOPitch
  add        edx, [localChromaPitch]
   mov       [CCOLine1], ecx
  lea        esi, [esi+2*ebp]                ; even Y line cursor goes to next line
   lea       edi, [edi+2*ebp]                ; odd  Y line cursor goes to next line
  mov        [localVPlane], edx              ; edx will point to V plane
   cmp       esi, [YLimit]
  jb         NextFourLines
done:
  mov        esp, [StashESP]

  pop        ebx
   pop       ebp
  pop        edi
   pop       esi
  ret

MMX_YUV12ToCLUT8ZoomBy2 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\cxm12y2.asm ===
OPTION PROLOGUE: None
OPTION EPILOGUE: ReturnAndRelieveEpilogueMacro

.xlist
include iammx.inc
include memmodel.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXCODE1 SEGMENT
MMX_YUV12ToYUY2   proc DIST LANG PUBLIC,
AuYPlane: DWORD,
AuVPlane: DWORD,
AuUPlane: DWORD,
AuWidth: DWORD,
AuHeight: DWORD,
AuYPitch: DWORD,
AUVPitch: DWORD,
AbShapingFlag: DWORD,
AuCCOutputBuffer: DWORD,
AlOutput: DWORD,
AuOffsetToLine0: DWORD,
AintPitch: DWORD,
ACCType: DWORD

LocalFrameSize  =  52
RegisterStorageSize = 16  ; 4 registers pushed

; Argument offsets (after register pushed)

uYPlane			= LocalFrameSize + RegisterStorageSize + 4
uVPlane			= LocalFrameSize + RegisterStorageSize + 8
uUPlane			= LocalFrameSize + RegisterStorageSize + 12
uWidth			= LocalFrameSize + RegisterStorageSize + 16
uHeight			= LocalFrameSize + RegisterStorageSize + 20
uYPitch			= LocalFrameSize + RegisterStorageSize + 24
uUVPitch		= LocalFrameSize + RegisterStorageSize + 28 
bShapingFlag	= LocalFrameSize + RegisterStorageSize + 32
uCCOutputBuffer	= LocalFrameSize + RegisterStorageSize + 36
lOutput			= LocalFrameSize + RegisterStorageSize + 40
uOffsetToLine0	= LocalFrameSize + RegisterStorageSize + 44
intPitch		= LocalFrameSize + RegisterStorageSize + 48
CCType			= LocalFrameSize + RegisterStorageSize + 52

; Local offsets (after register pushes)

ASMTMP1            = 48         ; 13
Y                  = 44         ; 12
U                  = 40         ; 11
V                  = 36         ; 10
Outt               = 32         ; 9
YTemp              = 28         ; 8
UTemp              = 24         ; 7 
VTemp              = 20         ; 6
ASMTMP2            = 16         ; 5
Col                = 12         ; 4
OutTemp            = 8          ; 3
VAL                = 4          ; 2
LineCount          = 0          ; 1

; Arguments relative to esp

_uYPlane                 EQU    [esp + uYPlane]
_uVPlane                 EQU    [esp + uVPlane]
_UUPlane                 EQU    [esp + uUPlane]
_uWidth                  EQU    [esp + uWidth ]
_uHeight                 EQU    [esp + uHeight]
_uYPitch                 EQU    [esp + uYPitch]
_uUVPitch                EQU    [esp + uUVPitch]
_bShapingFlag            EQU    [esp + bShapingFlag]
_uCCOutputBuffer         EQU    [esp + uCCOutputBuffer]
_lOutput                 EQU    [esp + lOutput]
_uOffsetToLine0          EQU    [esp + uOffsetToLine0]
_intPitch                EQU    [esp + intPitch]
_uCCType                 EQU    [esp + CCType]

; Locals relative to esp

_ASMTMP1                 EQU    [esp + ASMTMP1]
_Y                       EQU    [esp + Y]
_U                       EQU    [esp + U]
_V                       EQU    [esp + V]
_Out                     EQU    [esp + Outt]
_YTemp                   EQU    [esp + YTemp]
_UTemp                   EQU    [esp + UTemp]
_VTemp                   EQU    [esp + VTemp]
_ASMTMP2                 EQU    [esp + ASMTMP2]
_Col                     EQU    [esp + Col]
_OutTemp                 EQU    [esp + OutTemp]
_VAL                     EQU    [esp + VAL]
_LineCount               EQU    [esp + LineCount]

; Save registers and start working

	push	ebx
	push	esi
	push	edi
	push	ebp

	sub		esp, LocalFrameSize

	mov		eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
	mov		ecx, DWORD PTR _uYPlane         ; ecx = uYPlane
	dec		eax                             ; eax = bShapingFlag - 1
	mov		edx, DWORD PTR _uUPlane         ; edx = uUPlane
	mov		DWORD PTR _LineCount, eax       ; eax = FREE, LineCount 
	mov		DWORD PTR _Y, ecx               ; ecx = FREE, Y

	mov		eax, DWORD PTR _uVPlane         ; eax = uVPlane
	mov		ecx, DWORD PTR _uOffsetToLine0  ; ecx = uOffsetToLine0
	mov		DWORD PTR _U, edx               ; edx = FREE, U
	add		ecx, DWORD PTR _lOutput         ; ecx = uOffsetToLine0 +

	mov		DWORD PTR _V, eax               ; eax = FREE, V
	mov		eax, DWORD PTR _uCCOutputBuffer ; eax = uCCOutputBuffer
	add		eax, ecx                        ; eax = uCCOutputBuffer +
											;       uOffsetToLine0 +
											;       lOutput
											;       ecx = FREE
	mov		DWORD PTR _Out, eax             ; eax = FREE, Out
	mov		eax, DWORD PTR _uHeight         ; eax = uHeight

	sar		eax, 1                          ; eax = uHeight/2
	mov		DWORD PTR _ASMTMP2, eax         ; eax = FREE, Row ready to 
											; count down

RowLoop:; L27704 outer loop over all rows

	mov		ecx, DWORD PTR _Y               ; ecx = Y: ecx EQU YTemp
	mov		edi, DWORD PTR _U               ; edi = U: edi EQU UTemp
	mov		ebp, DWORD PTR _V               ; ebp = V: ebp EQU VTemp 
	mov		esi, DWORD PTR _Out             ; esi = OutTemp
	mov		eax, DWORD PTR _LineCount       ; eax = LineCount
	test	eax, eax                        ; is LineCount == 0? eax = FREE
	je		SkipEvenRow						; L27708 loop if so, skip the even loop
	mov		eax, DWORD PTR _uWidth          ; eax = uWidth

; Due to the fact that YUV12 non-compressed input files can be
; any dimension that is a multiple of 4x4 up to CIF, we must
; check for extra bytes that can't be processed in the following
; loop. Here, we don't have the luxury of buffer padding to overrun
; the frame size.

	test	eax, 0FFFFFFF0H
	jz		L100

EvenRowPels:; L27709 loop over columns in even row - two YUY2 pels at a time.

	movq		mm0, [ecx]			; [ Y07 Y06 Y05 Y04 Y03 Y02 Y01 Y00 ]
	movq		mm1, [edi]			; [ U07 U06 U05 U04 U03 U02 U01 U00 ]
	movq		mm2, [ebp]			; [ V07 V06 V05 V04 V03 V02 V01 V00 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V03 U03 V02 U02 V01 U01 V00 U00 ]

	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V01 Y03 U01 Y02 V00 Y01 U00 Y00 ]
	movq		[esi], mm4			; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V03 U03 V02 U02 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y07 Y06 Y05 Y04 ]
	punpcklbw	mm0, mm3			; [ V03 Y07 U03 Y06 V02 Y05 U02 Y04 ]
	movq		[esi+8], mm0		; Write out 8 data values.
	movq		mm0, [ecx+8]		; [ Y15 Y14 Y13 Y12 Y11 Y10 Y09 Y08 ]
	psrlq		mm1, 32				; [   0   0   0   0 U07 U06 U05 U04 ]
	psrlq		mm2, 32				; [   0   0   0   0 V07 V06 V05 V04 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V07 U07 V06 U06 V05 U05 V04 U04 ]
	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V05 Y11 U05 Y10 V04 Y09 U04 Y08 ]
	movq		[esi+16], mm4		; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V07 U07 V06 U06 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y15 Y14 Y13 Y12 ]
	punpcklbw	mm0, mm3			; [ V07 Y15 U07 Y14 V06 Y13 U06 Y12 ]
	movq		[esi+24], mm0		; Write out 8 data values.
	lea			ecx, [ecx+16]		; Advance Y pointer.
	lea			edi, [edi+8]		; Advance U pointer.
	lea			ebp, [ebp+8]		; Advance V pointer.
	lea			esi, [esi+32]		; Advance Out pointer.
	sub			eax, 16
	test		eax, 0FFFFFFF0H
	jnz			EvenRowPels

	test		eax, eax
	jz			L101

; eax can be 4, 8 or 12
L100:
	mov			ebx, [ecx]			; [ Y03 Y02 Y01 Y00 ]
	mov			dl, [edi]			; [ U00 ]
	mov			dh, [ebp]			; [ V00 ]
	mov			[esi], bl
	mov			[esi+1], dl
	mov			[esi+2], bh
	mov			[esi+3], dh
	shr			ebx, 16
	mov			dl, [edi+1]			; [ U01 ]
	mov			dh, [ebp+1]			; [ V01 ]
	mov			[esi+4], bl
	mov			[esi+5], dl
	mov			[esi+6], bh
	mov			[esi+7], dh
	sub			eax, 4
	jz			L101

	mov			ebx, [ecx+4]		; [ Y07 Y06 Y05 Y04 ]
	mov			dl, [edi+2]			; [ U02 ]
	mov			dh, [ebp+2]			; [ V02 ]
	mov			[esi+8], bl
	mov			[esi+9], dl
	mov			[esi+10], bh
	mov			[esi+11], dh
	shr			ebx, 16
	mov			dl, [edi+3]			; [ U03 ]
	mov			dh, [ebp+3]			; [ V03 ]
	mov			[esi+12], bl
	mov			[esi+13], dl
	mov			[esi+14], bh
	mov			[esi+15], dh
	sub			eax, 4
	jz			L101

	mov			ebx, [ecx+8]		; [ Y11 Y10 Y09 Y08 ]
	mov			dl, [edi+4]			; [ U04 ]
	mov			dh, [ebp+4]			; [ V04 ]
	mov			[esi+16], bl
	mov			[esi+17], dl
	mov			[esi+18], bh
	mov			[esi+19], dh
	shr			ebx, 16
	mov			dl, [edi+5]			; [ U05 ]
	mov			dh, [ebp+5]			; [ V05 ]
	mov			[esi+20], bl
	mov			[esi+21], dl
	mov			[esi+22], bh
	mov			[esi+23], dh

L101:
	mov		eax, DWORD PTR _LineCount	; eax = LineCount
	jmp		SHORT UpdatePointers		; L27770

SkipEvenRow:; L27708

	mov		eax, DWORD PTR _bShapingFlag    ; eax = bShapingFlag
	mov		edx, DWORD PTR _Out             ; edx = Out
	mov		ebx, DWORD PTR _intPitch        ; edx = intPitch
	sub		edx, ebx                        ; edx = Out - intPitch
	mov		DWORD PTR _Out, edx             ; save Out
         
UpdatePointers:	; L27770

	mov		ecx, DWORD PTR _Y               ; ecx = Y
	dec		eax                             ; eax = LineCount-1 OR bShapingFlag - 1
	mov		edx, DWORD PTR _intPitch        ; edx = intPitch
	mov		esi, DWORD PTR _Out             ; esi = Out
	mov		DWORD PTR _LineCount, eax       ; store decremented linecount
											; eax = FREE
	add		esi, edx                        ; (esi) Out += intPitch ***
	mov		eax, DWORD PTR _uYPitch         ; eax = uYPitch
	mov		edi, DWORD PTR _U               ; edi = U	***
	add		ecx, eax                        ; (ecx) Y += uYPitch ***
	mov		ebp, DWORD PTR _V               ; ebp = V	***
	mov		DWORD PTR _Y, ecx               ; store updated Y 
      
	mov		DWORD PTR _Out, esi             ; store Out
	mov		eax, DWORD PTR _LineCount       ; eax = LineCount
    
	test	eax, eax                        ; is LineCount == 0?
											; if so, ignore the odd
											; row loop over columns
	je		SkipOddRow						; L27714

	mov		eax, DWORD PTR _uWidth          ; eax = uWidth

; Due to the fact that YUV12 non-compressed input files can be
; any dimension that is a multiple of 4x4 up to CIF, we must
; check for extra bytes that can't be processed in the following
; loop. Here, we don't have the luxury of buffer padding to overrun
; the frame size.

	test	eax, 0FFFFFFF0H
	jz		L102
	      
OddRowPels: ;L27715 loop over columns of odd rows

	movq		mm0, [ecx]			; [ Y07 Y06 Y05 Y04 Y03 Y02 Y01 Y00 ]
	movq		mm1, [edi]			; [ U07 U06 U05 U04 U03 U02 U01 U00 ]
	movq		mm2, [ebp]			; [ V07 V06 V05 V04 V03 V02 V01 V00 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V03 U03 V02 U02 V01 U01 V00 U00 ]
	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V01 Y03 U01 Y02 V00 Y01 U00 Y00 ]
	movq		[esi], mm4			; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V03 U03 V02 U02 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y07 Y06 Y05 Y04 ]
	punpcklbw	mm0, mm3			; [ V03 Y07 U03 Y06 V02 Y05 U02 Y04 ]
	movq		[esi+8], mm0		; Write out 8 data values.
	movq		mm0, [ecx+8]		; [ Y15 Y14 Y13 Y12 Y11 Y10 Y09 Y08 ]
	psrlq		mm1, 32				; [   0   0   0   0 U07 U06 U05 U04 ]
	psrlq		mm2, 32				; [   0   0   0   0 V07 V06 V05 V04 ]
	movq		mm3, mm1
	punpcklbw	mm3, mm2			; [ V07 U07 V06 U06 V05 U05 V04 U04 ]
	movq		mm4, mm0
	punpcklbw	mm4, mm3			; [ V05 Y11 U05 Y10 V04 Y09 U04 Y08 ]
	movq		[esi+16], mm4		; Write out 8 data values.
	psrlq		mm3, 32				; [   0   0   0   0 V07 U07 V06 U06 ]
	psrlq		mm0, 32				; [   0   0   0   0 Y15 Y14 Y13 Y12 ]
	punpcklbw	mm0, mm3			; [ V07 Y15 U07 Y14 V06 Y13 U06 Y12 ]
	movq		[esi+24], mm0		; Write out 8 data values.
	lea			ecx, [ecx+16]		; Advance Y pointer.
	lea			edi, [edi+8]		; Advance U pointer.
	lea			ebp, [ebp+8]		; Advance V pointer.
	lea			esi, [esi+32]		; Advance Out pointer.
	sub			eax, 16
	test		eax, 0FFFFFFF0H
	jnz			OddRowPels

	test		eax, eax
	jz			L103

; eax can be 4, 8 or 12
L102:
	mov			ebx, [ecx]			; [ Y03 Y02 Y01 Y00 ]
	mov			dl, [edi]			; [ U00 ]
	mov			dh, [ebp]			; [ V00 ]
	mov			[esi], bl
	mov			[esi+1], dl
	mov			[esi+2], bh
	mov			[esi+3], dh
	shr			ebx, 16
	mov			dl, [edi+1]			; [ U01 ]
	mov			dh, [ebp+1]			; [ V01 ]
	mov			[esi+4], bl
	mov			[esi+5], dl
	mov			[esi+6], bh
	mov			[esi+7], dh
	sub			eax, 4
	jz			L103

	mov			ebx, [ecx+4]		; [ Y07 Y06 Y05 Y04 ]
	mov			dl, [edi+2]			; [ U02 ]
	mov			dh, [ebp+2]			; [ V02 ]
	mov			[esi+8], bl
	mov			[esi+9], dl
	mov			[esi+10], bh
	mov			[esi+11], dh
	shr			ebx, 16
	mov			dl, [edi+3]			; [ U03 ]
	mov			dh, [ebp+3]			; [ V03 ]
	mov			[esi+12], bl
	mov			[esi+13], dl
	mov			[esi+14], bh
	mov			[esi+15], dh
	sub			eax, 4
	jz			L103

	mov			ebx, [ecx+8]		; [ Y11 Y10 Y09 Y08 ]
	mov			dl, [edi+4]			; [ U04 ]
	mov			dh, [ebp+4]			; [ V04 ]
	mov			[esi+16], bl
	mov			[esi+17], dl
	mov			[esi+18], bh
	mov			[esi+19], dh
	shr			ebx, 16
	mov			dl, [edi+5]			; [ U05 ]
	mov			dh, [ebp+5]			; [ V05 ]
	mov			[esi+20], bl
	mov			[esi+21], dl
	mov			[esi+22], bh
	mov			[esi+23], dh

L103:
	mov			eax, DWORD PTR _LineCount	; eax = LineCount
	jmp			SHORT UpdateAllPointers		; L27771

SkipOddRow: ;L27714 

	mov		eax, DWORD PTR _bShapingFlag	; eax = bShapingFlag
	mov		edx, DWORD PTR _Out             ; edx = Out
	mov		ebx, DWORD PTR _intPitch        ; edx = intPitch
	sub		edx, ebx                        ; edx = Out - intPitch
	mov		DWORD PTR _Out, edx             ; save Out

UpdateAllPointers: ; L27771 update pointers

	dec		eax								; eax = LineCount-1 OR bShapingFlag - 1
	mov		ecx, DWORD PTR _Y				; ecx = Y
	mov		edx, DWORD PTR _intPitch		; edx = intPitch
	mov		ebx, DWORD PTR _Out				; ebx = Out
	add		ebx, edx						; ebx = Out + intPitch
	mov		ebp, DWORD PTR _ASMTMP2			; ebp = row loop counter
	mov		DWORD PTR _LineCount, eax		; store updated LineCount
	mov		DWORD PTR _Out, ebx				; store updated Out
	mov		edx, DWORD PTR _uUVPitch        ; edx = uUVPitch
	mov		eax, DWORD PTR _U               ; eax = U
	mov		esi, DWORD PTR _V               ; esi = V
	add		eax, edx                        ; eax = U + uUVPitch
	add		esi, edx                        ; esi = V + uUVPitch
	mov		DWORD PTR _U, eax               ; store updated U
	mov		DWORD PTR _V, esi               ; store updated V
	add		ecx, DWORD PTR _uYPitch			; ecx = Y + uYPitch
	dec		ebp								; decrement loop counter
	mov		DWORD PTR _Y, ecx				; store updated Y
	mov		DWORD PTR _ASMTMP2, ebp			; store updated loop counter

	jne		RowLoop							; back to L27704 row loop

CleanUp:

	add		esp, LocalFrameSize             ; restore esp to registers                               

	pop		ebp
	pop		edi
	pop		esi
	pop		ebx

	ret		52								; 13*4 bytes of arguments

MMX_YUV12ToYUY2 ENDP

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d35xpand.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995, 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/


;--------------------------------------------------------------------------;
;
;  d3xpand.asm
;
;  Description:
;    This routine expands a picture frame by 16 or 8 bytes in all
;    directions for unrestricted motion vector mode.  It assumes
;    that there is space in memory around the existing frame
;    and simply writes to there (i.e., clobbers it), and that
;    the pitch is 384 (distance in bytes between vertically
;    adjacent pels).  See Below.
;
;  Routines:                          prototypes in:
;    ExpandPlane                      d3dec.cpp
;
;  Data:
;    This routine assumes that the PITCH is 384.
;
;  Inputs (dwords pushed onto stack by caller):
;    StartPtr     flat pointer to the first byte of the
;                 original frame.
;    FrameWidth   Width (in bytes) of the original frame.
;                 THIS MUST BE AT LEAST 32 & A MULTIPLE OF 4.
;    FrameHeight  Height (in rows) of the original frame.
;    Pels         Number of pels to expand the plane.
;                 16 for lumina, 8 for chroma.  This MUST
;                 BE A MULTIPLE OF 8.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35xpand.asv   1.2   08 Mar 1996 16:48:16   AGUPTA2  $
;  $Log:   S:\h26x\src\dec\d35xpand.asv  $
;// 
;//    Rev 1.2   08 Mar 1996 16:48:16   AGUPTA2
;// Changed the meaning of last parameter.  New and faster way to expand planes.
;// 
;// 
;//    Rev 1.0   27 Nov 1995 11:28:30   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;


.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE

.CODE
;--------------------------------------------------------------------------;
;
;  The algorithm fills in (1) the bottom (not including corners),
;  then (2) the sides (including the bottom corners, but not the
;  top corners), then (3) the top (including the top
;  corners) as shown below, replicating the outermost bytes
;  of the original frame outward:
;
;               ----------------------------
;              |                            |
;              |            (3)             |
;              |                            |
;              |----------------------------|
;              |     |                |     |
;              |     |                |     |
;              |     |                |     |
;              |     |    original    |     |
;              |     |     frame      |     |
;              |     |                |     |
;              | (2) |                | (2) |
;              |     |                |     |
;              |     |                |     |
;              |     |----------------|     |
;              |     |                |     |
;              |     |      (1)       |     |
;              |     |                |     |
;               ----------------------------
;
;  Register Usage:
;
;    esi        pointer for stages (1) and (2).
;    edi        pointer for stages (2) and (3).
;    ecx        loop control.
;    eax, ebx   dword to be written.  In stage (2), it is formed
;               from 4 (shifted) copies of the border byte.  (i.e.,
;               byte 0d2h replicates to 0d2d2d2d2h.)
;    edx, ebp   pointers.
;
;--------------------------------------------------------------------------;
;
;    Version:   5.0
;    Date:      4 March 1996
;    Author:    R. McKenzie
;
;    Notes:     The essential features of this version are:
;               1.  Re-organized to fill bottom first, then sides,
;                   finally top
;               2.  Code is optimized for the case that the expanded 
;                   plane is 32-byte aligned.  No checking is performed
;                   to verify this assumption and this routine will run
;                   significantly SLOWER (though correctly) if this
;                   assumption is not true.
;
;--------------------------------------------------------------------------;

;-------------------;
;    Stack Usage    ;
;-------------------;
; register storage
;   edi               esp+00
;   esi               esp+04
;   ebx               esp+08
;   ebp               esp+12

; return address      esp+16

; C input parameters
    StartPtr     EQU  esp+20
    FrameWidth   EQU  esp+24
    FrameHeight  EQU  esp+28
    Pels         EQU  esp+32

PITCH   =   384


PUBLIC C ExpandPlane

ExpandPlane:
  push     ebp
  push     ebx

  push     esi
  push     edi


;--------------------------------------;
;          fill the bottom             ;
;--------------------------------------;
  mov      esi, [StartPtr]             ; ptr1 = StartPtr
  mov      edi, [FrameHeight]

  shl      edi, 7
  mov      ebp, PITCH

  lea      edi, [edi+2*edi-PITCH]      ; PITCH * (FrameHeight-1)
  mov      edx, [FrameWidth]           ; column bound

  add      esi, edi					   ; esi = bottom left corner
  nop


;-------Start Outer Bottom Loop--------;
OuterBottomLoop:
  mov      edi, esi                    ; destination pointer
  mov      ecx, [Pels]                 ; row bound

  mov      eax, 0[esi]
  mov      ebx, 4[esi]


;-------Start Inner Bottom Loop--------;
InnerBottomLoop:
  mov      0[edi+ebp], eax
  mov      4[edi+ebp], ebx

  add      edi, ebp
  dec      ecx

  jne      InnerBottomLoop
;--------End Inner Bottom Loop---------;


  add      esi, 8
  sub      edx, 8

  jne      OuterBottomLoop
;--------End Outer Bottom Loop---------;


;--------------------------------------;
;    Fill both sides from bottom up    ;
;--------------------------------------;
  mov      ecx, [FrameHeight]
  mov      edx, [Pels]

  add      ecx, edx                    ; ecx = row count
  add      edi, 8                      ; edi = Right pointer

  mov      eax, [FrameWidth]
  mov      esi, edi

  sub      esi, eax                    ; esi = Left pointer
  nop


;--------Start Outer Sides Loop--------;
OuterSidesLoop:
  xor      eax, eax
  xor      ebx, ebx

  mov      al, [esi]
  push     ecx                         ; save row counter

  mov      bl, [edi-1]
  mov      ah, [esi]

  mov      bh, [edi-1]
  mov      ebp, eax

  shl      eax, 16
  mov      edx, ebx

  shl      ebx, 16
  or       eax, ebp

  or       ebx, edx
  mov      ebp, esi                    ; Left Pointer

  mov      edx, edi                    ; Right Pointer
  mov      ecx, [Pels+4]               ; column counter


;--------Start Inner Sides Loop--------;
InnerSidesLoop:
  mov      [ebp-4], eax
  mov      [ebp-8], eax

  mov      [edx], ebx
  mov      [edx+4], ebx

  sub      ebp, 8
  add      edx, 8

  sub      ecx, 8
  jne      InnerSidesLoop
;---------End Inner Sides Loop---------;


  pop      ecx
  sub      esi, PITCH

  sub      edi, PITCH
  dec      ecx

  jne      OuterSidesLoop
;---------End Outer Sides Loop---------;


;--------------------------------------;
;          Fill the Top                ;
;--------------------------------------;
  mov      ecx, [Pels]                 ; ptr1 = StartPtr
  mov      edx, [FrameWidth]           ; column bound

  add      esi, PITCH
  mov      ebp, -PITCH

  sub      esi, ecx
  lea      edx, [edx+2*ecx]            ; FrameWidth + 2 * Pels


;---------Start Outer Top Loop---------;
OuterTopLoop:
  mov      edi, esi                    ; destination pointer
  mov      ecx, [Pels]                 ; row bound

  mov      eax, 0[esi]
  mov      ebx, 4[esi]


;---------Start Inner Top Loop---------;
InnerTopLoop:
  mov      0[edi+ebp], eax
  mov      4[edi+ebp], ebx

  add      edi, ebp
  dec      ecx

  jne      InnerTopLoop
;----------End Inner Top Loop----------;


  add      esi, 8
  sub      edx, 8

  jne      OuterTopLoop
;----------End Outer Top Loop----------;

;--------------------------------------;
;          Wrap up and go home         ;
;--------------------------------------;
  pop      edi
  pop      esi

  pop      ebx
  pop      ebp

  ret

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3madvpr.asm ===
;--------------------------------------------------------------------------;
;
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------;
;
;	$Header:   S:\h26x\src\dec\d3madvpr.asv   1.6   01 Oct 1996 16:45:38   KLILLEVO  $
;	$Log:   S:\h26x\src\dec\d3madvpr.asv  $
;// 
;//    Rev 1.6   01 Oct 1996 16:45:38   KLILLEVO
;// removed unneccessary local variable and added code to verify
;// PITCH is 384 at compile-time
;// 
;//    Rev 1.5   01 Oct 1996 11:57:52   KLILLEVO
;// pairing done, saved about 5*4 = 20 cycles per block = 11880 cycles
;// per QCIF picture
;// 
;//    Rev 1.4   27 Sep 1996 17:28:40   KLILLEVO
;// added clipping of extended motion vectors, but pairing is horrible and
;// needs to be improved
;// 
;//    Rev 1.3   01 Apr 1996 12:35:14   RMCKENZX
;// 
;// Added MMXCODE1 and MMXDATA1 segments, moved global data
;// to MMXDATA1 segment.
;// 
;//    Rev 1.2   07 Mar 1996 18:32:16   RMCKENZX
;// 
;// Re-organized and optimized routine.  Interpolaters now
;// interpolate & weight, driver accumulates and averages.  Interpolaters
;// return results in mm4-mm7.  Eliminated include file.
;// 
;//    Rev 1.0   27 Feb 1996 15:03:42   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;
;
; File:
;	d3madvpr.asm
;
; Routines:
;	MMX_AdvancePredict				Driver
;	MMxInterpolateAndAccumulate		Assembly-called interpolate accumulate
;
;--------------------------------------------------------------------------;

.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

;--------------------------------------------------------------------------;
;
; MMX_AdvancePredict
;
; Description:
;	This routine performs advanced prediction, including overlapped
;	block motion compensation.  It uses the assembly routine 
;	MMxInterpolateAndAccumulate.
;
;	This routine is the assembly equivalent of NewAdvancePredict.
;
; Inputs:			(dwords pushed onto stack by caller)
;	DC				flat pointer to decoder catalog.
;	fpBlockAction	flat pointer to block action stream.
;	iNext			flat pointer to offsets for 4 neighboring blocks.
;						0 = left
;						1 = right
;						2 = above
;						3 = below
;
;
; Register Usage:
;
;
; Notes:
;    
;--------------------------------------------------------------------------;

; register storage
;	ebp						esp+00
;	ebx						esp+04
;	edi						esp+08
;	esi						esp+12

; local variable definitions
	lpBlockAction	EQU		esp+16		; local block action stream pointer
	lNext			EQU		esp+20		; local block action offsets pointer
    lClipX          EQU     esp+24      ; local copy of pointer to x vector clipping table
    lClipY          EQU     esp+28      ; local copy of pointer to y vector clipping table
	lNext			EQU		esp+32		; local offsets (4 DWORDS = 16 bytes)
	lAccum			EQU		esp+64		; accumulator (64 WORDS = 128 bytes)

	zero            EQU     mm0
	lDst			EQU		edi			; local destination pointer

; C input parameters
	fpBlockAction	EQU		ebp+08		; block action stream pointer
	iNext			EQU		esp+12		; block action offsets pointer
	pDst			EQU		ebp+16		; destination pointer
    pClipX          EQU     ebp+20      ; x vector clipping table
    pClipY          EQU     ebp+24      ; y vector clipping table

; MMX globals
;  the weight tables are each 64 WORDS stored in Quadrant ascending order
	WtCt			EQU		gMMX_WeightCenter
	WtLR			EQU		gMMX_WeightLeftRight
	WtAB			EQU		gMMX_WeightAboveBelow
	Round1			EQU		gMMX_Round1
	Round2			EQU		gMMX_Round2
	Round4			EQU		gMMX_Round4

PITCH = 384
FRAMESIZE = 256

; **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT ****
;
;  		ANY CHANGES TO THE BLOCK ACTION STRUCTURE
;  		IN d3dec.h MUST BE ECHOED HERE!!!!
;
; **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT **** ALERT ****

; Offsets into Block Action structure T_BlkAction of length 20
;	see the definition in d3dec.h
i8MVx2				=	1		; I8 = signed byte
i8MVy2				=	2		; I8 = signed byte
pRefBlock			=	8		; U32 = unsigned dword

MMXDATA1 SEGMENT
ALIGN 8
gMMX_WeightCenter LABEL DWORD
WORD 5, 5, 5, 4,  5, 5, 5, 5,  6, 6, 5, 5,  6, 6, 5, 5		; Quadrant I 
WORD 4, 5, 5, 5,  5, 5, 5, 5,  5, 5, 6, 6,  5, 5, 6, 6	 	; Quadrant II
WORD 5, 5, 6, 6,  5, 5, 6, 6,  5, 5, 5, 5,  4, 5, 5, 5	 	; Quadrant III
WORD 6, 6, 5, 5,  6, 6, 5, 5,  5, 5, 5, 5,  5, 5, 5, 4	 	; Quadrant IV

gMMX_WeightLeftRight LABEL DWORD
WORD 1, 1, 1, 2,  1, 1, 2, 2,  1, 1, 2, 2,  1, 1, 2, 2		; Quadrant I 
WORD 2, 1, 1, 1,  2, 2, 1, 1,  2, 2, 1, 1,  2, 2, 1, 1		; Quadrant II 
WORD 2, 2, 1, 1,  2, 2, 1, 1,  2, 2, 1, 1,  2, 1, 1, 1		; Quadrant III 
WORD 1, 1, 2, 2,  1, 1, 2, 2,  1, 1, 2, 2,  1, 1, 1, 2		; Quadrant IV 

gMMX_WeightAboveBelow LABEL DWORD
WORD 2, 2, 2, 2,  2, 2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1		; Quadrant I 
WORD 2, 2, 2, 2,  1, 1, 2, 2,  1, 1, 1, 1,  1, 1, 1, 1		; Quadrant II 
WORD 1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 2, 2,  2, 2, 2, 2		; Quadrant III 
WORD 1, 1, 1, 1,  1, 1, 1, 1,  2, 2, 1, 1,  2, 2, 2, 2		; Quadrant IV 

gMMX_Round1 DWORD 00010001h, 00010001h
gMMX_Round2 DWORD 00020002h, 00020002h
gMMX_Round4 DWORD 00040004h, 00040004h
MMXDATA1 ENDS
;--------------------------------------------------------------------------;


;--------------------------------------------------------------------------;
MMXCODE1 SEGMENT

PUBLIC C MMX_AdvancePredict

IF PITCH-384
   ** error: this code assumes PITCH is 384
ENDIF

;--------------------------------------------------------------------------;
;	Start Code
;--------------------------------------------------------------------------;
MMX_AdvancePredict:
	push	ebp
	mov 	ebp, esp

	mov 	edx, [iNext]
	and 	esp, -32					; align stack on cache boundary

	sub 	esp, FRAMESIZE
	pxor	zero, zero					; zero for unpacking

	push	esi
	push	edi

	push	ebx
	push	ebp

    mov eax, [pClipX]
    mov ebx, [pClipY]

    mov [lClipX], eax
    mov [lClipY], ebx

	mov 	lDst, [pDst]
	mov 	eax, 00[edx]

	mov 	ebp, [fpBlockAction]
	mov 	ebx, 04[edx]

	lea 	eax, [eax+4*eax]
	mov 	ecx, 08[edx]

	lea 	ebx, [ebx+4*ebx]
	mov 	edx, 12[edx]

	lea 	ecx, [ecx+4*ecx]
	mov 	00[lNext], eax

	lea 	edx, [edx+4*edx]
	mov 	04[lNext], ebx

	mov 	08[lNext], ecx
	mov 	12[lNext], edx


;-----------------------------------------------------------------------;
;																		;
;								Center                                  ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtCt + 32]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]

	add esi, edx

	; Quadrant II
	call      MMxInterpolateAndAccumulate

	movq      mm3, [Round4]

	paddw     mm4, mm3
	add       esi, 4

	paddw     mm5, mm3
	sub       ebx, 32

	movq      [lAccum+00], mm4
	paddw     mm6, mm3

	movq      [lAccum+16], mm5
	paddw     mm7, mm3

	movq      [lAccum+32], mm6

	movq      [lAccum+48], mm7


	; Quadrant I
	call	  MMxInterpolateAndAccumulate
 
	movq      mm3, [Round4]

	paddw     mm4, mm3
	add       esi, 4*PITCH-4

	paddw     mm5, mm3
	add       ebx, 64

	movq      [lAccum+08], mm4
	paddw     mm6, mm3

	movq      [lAccum+24], mm5
	paddw     mm7, mm3

	movq      [lAccum+40], mm6

	movq      [lAccum+56], mm7


	; Quadrant III
	call	  MMxInterpolateAndAccumulate

	movq      mm3, [Round4]

	paddw     mm4, mm3
	add       esi, 4

	paddw     mm5, mm3
	add       ebx, 32

	movq      [lAccum+64], mm4
	paddw     mm6, mm3

	movq      [lAccum+80], mm5
	paddw     mm7, mm3

	movq      [lAccum+96], mm6

	movq      [lAccum+112], mm7


	; Quadrant IV
	call	  MMxInterpolateAndAccumulate

	movq      mm3, [Round4]

	paddw     mm4, mm3
	mov       ebx, 00[lNext]

	paddw     mm5, mm3

	movq      [lAccum+72], mm4
	paddw     mm6, mm3

	movq      [lAccum+88], mm5
	paddw     mm7, mm3

	movq      [lAccum+104], mm6

	movq      [lAccum+120], mm7


;-----------------------------------------------------------------------;
;																		;
;								Left                                    ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtLR + 32]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]

	add esi, edx

	; Quadrant II
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+00]

	paddw     mm5, [lAccum+16]

	paddw     mm6, [lAccum+32]

	paddw     mm7, [lAccum+48]

	movq      [lAccum+00], mm4

	movq      [lAccum+16], mm5

	movq      [lAccum+32], mm6

	movq      [lAccum+48], mm7


	; Quadrant III
	add       esi, 4*PITCH
	add       ebx, 32

	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+64]

	paddw     mm5, [lAccum+80]

	paddw     mm6, [lAccum+96]

	paddw     mm7, [lAccum+112]

	movq      [lAccum+64], mm4

	movq      [lAccum+80], mm5

	movq      [lAccum+96], mm6
	mov       ebx, 04[lNext]

	movq      [lAccum+112], mm7


;-----------------------------------------------------------------------;
;																		;
;								Right                                   ;
;																		;
;-----------------------------------------------------------------------;
	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtLR]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]
	add esi, 4

	add esi, edx

	; Quadrant I
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+08]

	paddw     mm5, [lAccum+24]

	paddw     mm6, [lAccum+40]

	paddw     mm7, [lAccum+56]

	movq      [lAccum+08], mm4

	movq      [lAccum+24], mm5

	movq      [lAccum+40], mm6

	movq      [lAccum+56], mm7


	; Quadrant IV
	add       esi, 4*PITCH
	add       ebx, 96

	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+72]

	paddw     mm5, [lAccum+88]

	paddw     mm6, [lAccum+104]

	paddw     mm7, [lAccum+120]

	movq      [lAccum+72], mm4

	movq      [lAccum+88], mm5

	movq      [lAccum+104], mm6
	mov       ebx, 08[lNext]

	movq      [lAccum+120], mm7


;-----------------------------------------------------------------------;
;																		;
;								Above                                   ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtAB]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]
	add esi, 4

	add esi, edx

	; Quadrant I
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+08]

	paddw     mm5, [lAccum+24]
	psraw     mm4, 3

	paddw     mm6, [lAccum+40]
	psraw     mm5, 3

	paddw     mm7, [lAccum+56]
	psraw     mm6, 3

	movq      [lAccum+08], mm4
	psraw     mm7, 3

	movq      [lAccum+24], mm5

	movq      [lAccum+40], mm6

	movq      [lAccum+56], mm7


	; Quadrant II
	sub       esi, 4
	add       ebx, 32
	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+00]

	paddw     mm5, [lAccum+16]

	paddw     mm6, [lAccum+32]
	psraw     mm4, 3

	paddw     mm7, [lAccum+48]
	psraw     mm5, 3

	packuswb  mm4, [lAccum+08]

	packuswb  mm5, [lAccum+24]

	movq      [lDst+00], mm4
	psraw     mm6, 3

	movq      [lDst+PITCH], mm5
	psraw     mm7, 3

	packuswb  mm6, [lAccum+40]

	packuswb  mm7, [lAccum+56]

	movq      [lDst+2*PITCH], mm6
	mov       ebx, 12[lNext]

	movq      [lDst+3*PITCH], mm7


;-----------------------------------------------------------------------;
;																		;
;								Below                                   ;
;																		;
;-----------------------------------------------------------------------;

	xor ecx, ecx
	mov esi, [lClipY]

	mov cl, i8MVy2[ebp + 4*ebx]         
	xor edx, edx

	add cl, 64
	mov dl, i8MVx2[ebp + 4*ebx]

	add dl, 64
	mov ebx, [lClipX]

	mov ah, [ecx + esi]
	mov esi, pRefBlock[ebp]  

	mov al, [edx + ebx]
	mov dl, ah

	shl edx, 24
	mov cl, al

	sar edx, 18                  
	xor cl, 080H

	shr ecx, 1
	and edx, 0FFFFFF80H

	lea ebx, [WtAB + 96]
	add esi, ecx

	lea edx, [edx + edx*2 - 64]
	add esi, 4*PITCH+4

	add esi, edx

	; Quadrant IV
	call      MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+72]

	paddw     mm5, [lAccum+88]
	psraw     mm4, 3

	paddw     mm6, [lAccum+104]
	psraw     mm5, 3

	paddw     mm7, [lAccum+120]
	psraw     mm6, 3

	movq      [lAccum+72], mm4
	psraw     mm7, 3

	movq      [lAccum+88], mm5

	movq      [lAccum+104], mm6

	movq      [lAccum+120], mm7


	; Quadrant III
	sub       esi, 4
	sub       ebx, 32

	call	  MMxInterpolateAndAccumulate

	paddw     mm4, [lAccum+64]

	paddw     mm5, [lAccum+80]

	paddw     mm6, [lAccum+96]
	psraw     mm4, 3

	paddw     mm7, [lAccum+112]
	psraw     mm5, 3

	packuswb  mm4, [lAccum+72]

	packuswb  mm5, [lAccum+88]

	movq      [lDst+4*PITCH], mm4
	psraw     mm6, 3

	movq      [lDst+5*PITCH], mm5
	psraw     mm7, 3

	packuswb  mm6, [lAccum+104]

	packuswb  mm7, [lAccum+120]

	movq      [lDst+6*PITCH], mm6

	movq      [lDst+7*PITCH], mm7



	pop 	ebp
	pop 	ebx

	pop 	edi
	pop 	esi

	mov 	esp, ebp

	pop 	ebp

	ret


;--------------------------------------------------------------------------;
;
; Routine:
;	MMxInterpolateAndAccumulate
;
; Inputs:
;	esi			flat pointer to Reference Block Source.
;               it is already adjusted by the motion vector.
;	 al			x component of motion vector.
;	 ah			y component of motion vector.
;	ebx			flat pointer to Weighting values.
;
; Outputs
;	mm4-mm7     Weighted, interpolated values for rows 0-3.
;               Values are in packed word format.
;
; Description:
;	This routine performs motion compensation interpolation, weights the
;	results, and returns them in mmx registers 4-7.
;	It works on a single 4x4 Quadrant per call.  It is an assembly
;	callable routine with its parameters in registers.
;
; Register Usage:
;	This routine modifies no integer registers.
;	All MMx registers are modified.
;
; Notes:
;    
;--------------------------------------------------------------------------;

; asm input parameters
	lpSrc		EQU		esi				; motion compensated source pointer
	lpWt		EQU		ebx				; pointer to matrix of weights 4x4xWORD

MMxInterpolateAndAccumulate:
	test      eax, 100h					; test mvy's parity bit
	jnz       IAAhalf					; jump when it was odd

	test      eax, 1					; test mvx's parity bit
	jnz       IAAhalf_int				; jump when it was odd


IAAint_int:
	movd      mm4, [lpSrc]		; 1 - fetch row
										
	movd      mm5, [PITCH+lpSrc]		; 2 - fetch row  
	punpcklbw mm4, zero					; 1 - unpack row

	pmullw    mm4, 00[lpWt]				; 1 - multiply by weights

	movq      mm6, [PITCH*2+lpSrc]		; 3 - fetch row
	punpcklbw mm5, zero					; 2 - unpack row

	pmullw    mm5, 08[lpWt]				; 2 - multiply by weights
	punpcklbw mm6, zero					; 3 - unpack row

	movq      mm7, [PITCH*3+lpSrc]		; 4 - fetch row

	pmullw    mm6, 16[lpWt]				; 3 - multiply by weights
	punpcklbw mm7, zero					; 4 - unpack row

	pmullw    mm7, 24[lpWt]				; 4 - multiply by weights

	ret


IAAhalf_int:
	movq      mm4, [lpSrc]		; 0 - fetch row

	movq      mm1, mm4					; 0 - copy row
	psrlq     mm4, 8					; 0 - shift row

	movq      mm5, [PITCH+lpSrc]		; 1 - fetch row
	punpcklbw mm4, zero					; 0 - unpack shifted row

	movq      mm6, [PITCH*2+lpSrc]		; 2 - fetch row
	punpcklbw mm1, zero					; 0 - unpack row

	movq      mm2, mm5					; 1 - copy row
	psrlq     mm5, 8					; 1 - shift row

	paddw     mm4, [Round1]				; 0 - add in Round
	punpcklbw mm5, zero					; 1 - unpack shifted row

	paddw     mm4, mm1					; 0 - sum copies of row
 	punpcklbw mm2, zero					; 1 - unpack row

	movq      mm3, mm6					; 2 - copy row
	psrlq     mm6, 8					; 2 - shift row

	paddw     mm5, [Round1]				; 1 - add in Round								 
	punpcklbw mm6, zero					; 2 - unpack shifted row

	paddw     mm5, mm2					; 1 - sum copies of row
	punpcklbw mm3, zero					; 2 - unpack row
									 
	movq      mm7, [PITCH*3+lpSrc]		; 3 - fetch row
	psraw     mm4, 1					; 0 - divide by 2

	pmullw    mm4, 00[lpWt]				; 0 - multiply by weights
	psraw     mm5, 1					; 1 - divide by 2

	movq      mm1, mm7					; 3 - copy row
	psrlq     mm7, 8					; 3 - shift row

	paddw     mm6, [Round1]				; 2 - add in Round
	punpcklbw mm7, zero					; 3 - unpack shifted row

	paddw     mm6, mm3					; 2 - sum copies of rows
	punpcklbw mm1, zero					; 3 - unpack row

	paddw     mm7, [Round1]				; 3 - add in Round
	psraw     mm6, 1					; 2 - divide by 2

	pmullw    mm5, 08[lpWt]				; 1 - multiply by weights
	paddw     mm7, mm1					; 3 - sum copies of row

	pmullw    mm6, 16[lpWt]				; 2 - multiply by weights
	psraw     mm7, 1					; 3 - divide by 2

	pmullw    mm7, 24[lpWt]				; 3 - multiply by weights

	ret


IAAhalf:
	test      eax, 1					; test mvx's parity bit
	jnz       IAAhalf_half				; jump when it was odd


IAAint_half:
	movd      mm4, [lpSrc]		; 0 - fetch row
										
	movd      mm5, [PITCH+lpSrc]		; 1 - fetch row
	punpcklbw mm4, zero					; 0 - unpack row

	movd      mm6, [PITCH*2+lpSrc]		; 2 - fetch row
	punpcklbw mm5, zero					; 1 - unpack row

	paddw     mm4, [Round1]				; 0 - add in Round								 
	punpcklbw mm6, zero					; 2 - unpack row

	paddw     mm4, mm5					; 0 - sum rows
	paddw     mm5, [Round1]				; 1 - add in Round

	movd      mm7, [PITCH*3+lpSrc]		; 3 - fetch row
	psraw     mm4, 1					; 0 - divide by 2

	pmullw    mm4, 00[lpWt]				; 0 - multiply by weights
	paddw     mm5, mm6					; 1 - sum rows

	movd      mm3, [PITCH*4+lpSrc]		; 4 - fetch row
	punpcklbw mm7, zero					; 3 - unpack row

	paddw     mm6, [Round1]				; 2 - add in Round
	psraw     mm5, 1					; 1 - divide by 2

	pmullw    mm5, 08[lpWt]				; 1 - multiply by weights
	punpcklbw mm3, zero					; 4 - unpack row

	paddw     mm6, mm7					; 2 - sum rows
 	paddw     mm7, [Round1]				; 3 - add in Round

	paddw     mm7, mm3					; 3 - sum rows
	psraw     mm6, 1					; 2 - divide by 2

	pmullw    mm6, 16[lpWt]				; 2 - multiply by weights
 	psraw     mm7, 1					; 3 - divide by 2

	pmullw    mm7, 24[lpWt]				; 3 - multiply by weights

	ret


IAAhalf_half:
	movq      mm4, [lpSrc]		; 0 - fetch row

	movq      mm5, [PITCH+lpSrc]		; 1 - fetch row
	movq      mm1, mm4					; 0 - copy row

	movq      mm2, mm5					; 1 - copy row
	psrlq     mm4, 8					; 0 - shift row

	movq      mm6, [PITCH*2+lpSrc]		; 2 - fetch row
	punpcklbw mm4, zero					; 0 - unpack shifted row

	movq      mm3, mm6					; 2 - copy row
	punpcklbw mm1, zero					; 0 - unpack row

	paddw     mm4, mm1					; 0 - parital sum both copies of row
	psrlq     mm5, 8					; 1 - shift row

	paddw     mm4, [Round2]				; 0 - add in Round								 
	punpcklbw mm5, zero					; 1 - unpack shifted row

	movq      mm7, [PITCH*3+lpSrc]		; 3 - fetch row
	punpcklbw mm2, zero					; 1 - unpack row

	paddw     mm5, mm2					; 1 - parital sum both copies of row
	psrlq     mm6, 8					; 2 - shift row

	paddw     mm4, mm5					; 0 - add partial sums
	punpcklbw mm6, zero					; 2 - unpack shifted row

	paddw     mm5, [Round2]				; 1 - add in Round								 
	punpcklbw mm3, zero					; 2 - unpack row

	paddw     mm6, mm3					; 2 - parital sum both copies of row
	movq      mm1, mm7					; 3 - copy row

	movq      mm2, [PITCH*4+lpSrc]		; 4 - fetch row
	psraw     mm4, 2					; 0 - divide by 2

	paddw     mm5, mm6					; 1 - add partial sums
	psrlq     mm7, 8					; 3 - shift row

	paddw     mm6, [Round2]				; 2 - add in Round								 
	punpcklbw mm7, zero					; 3 - unpack shifted row

	movq      mm3, mm2					; 4 - copy row
	punpcklbw mm1, zero					; 3 - unpack row

	paddw     mm7, mm1					; 3 - parital sum both copies of row
	psrlq     mm2, 8					; 4 - shift row

	pmullw    mm4, 00[lpWt]				; 0 - multiply by weights
	punpcklbw mm2, zero					; 4 - unpack shifted row

	paddw     mm6, mm7					; 2 - add partial sums
	punpcklbw mm3, zero					; 4 - unpack row

	paddw     mm7, [Round2]				; 3 - add in Round								 
	psraw     mm5, 2					; 1 - divide by 2

	pmullw    mm5, 08[lpWt]				; 1 - multiply by weights
	paddw     mm2, mm3					; 4 - parital sum both copies of row

	paddw     mm7, mm2					; 3 - add partial sums
	psraw     mm6, 2					; 2 - divide by 2

	pmullw    mm6, 16[lpWt]				; 2 - multiply by weights
	psraw     mm7, 2					; 3 - divide by 2

	pmullw    mm7, 24[lpWt]				; 3 - multiply by weights

	ret	 
MMXCODE1 ENDS

;        11111111112222222222333333333344444444445555555555666666666677777777778
;2345678901234567890123456789012345678901234567890123456789012345678901234567890
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\decconst.inc ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;////////////////////////////////////////////////////////////////////////////
;//
;// $Header:   S:\h26x\src\dec\decconst.inv   1.1   27 Dec 1995 14:36:22   RMCKENZX  $
;// $Log:   S:\h26x\src\dec\decconst.inv  $
;// 
;//    Rev 1.1   27 Dec 1995 14:36:22   RMCKENZX
;// Added copyright notice
;//
;////////////////////////////////////////////////////////////////////////////

;//
;// DECCONST.INC - derived from MRV
;//

IFDEF _DECCONST_INC_
ELSE
_DECCONST_INC = 1

; Constants used by MRV decoder, post filtering functions, and color convertors.

YARCHIVEOFFSET    = 311688
UOFFSET           = 168
VPITCH            = 336

BEFTRIGGER        = 143
BEFWILLING        = 125
BEFUNWILLING      =  10
BEFENDOFLINE      =  21
BEFENDOFFRAME     = 246

YPITCH      = 384           
YSTARTOFF   = YPITCH*16+16  ; offset into output buffer of first pixel to write

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d35bimot.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35bimot.asv   1.5   08 Mar 1996 16:46:04   AGUPTA2  $
;  $Log:   S:\h26x\src\dec\d35bimot.asv  $
;// 
;//    Rev 1.5   08 Mar 1996 16:46:04   AGUPTA2
;// Added segment declaration to place the rtn in the right segment.
;// 
;// 
;//    Rev 1.4   19 Jan 1996 17:51:16   RMCKENZX
;// changed local variables to live on the stack
;// 
;//    Rev 1.3   19 Jan 1996 13:30:34   RMCKENZX
;// Added rounding to int-half bidirectional prediction
;// 
;//    Rev 1.2   05 Jan 1996 15:58:36   RMCKENZX
;// Eliminated separate chroma entry point, using a 
;// block number check instead
;// 
;//    Rev 1.1   27 Dec 1995 14:35:50   RMCKENZX
;// Added copyright notice
;
;  D35BiMot.asm
;
;  Description:
;    This module does bi-directional motion compensated prediction for 
;    B frames.  It is called after forward prediction has been computed
;    and will average in the backward prediction for those pels where 
;    the backward motion vector points inside of the referenced P frame.
;
;  Routines:                          prototypes in:
;    H263BiMotionComp                 none
;
;  Data
;    This routine assumes that the PITCH is 384.
;
;--------------------------------------------------------------------------;

;--------------------------------------------------------------------------;
;
;  $Header:   S:\h26x\src\dec\d35bimot.asv   1.5   08 Mar 1996 16:46:04   AGUPTA2  $
;  $Log$
;// 
;//    Rev 1.0   22 Nov 1995 13:33:52   RMCKENZX
;// Initial revision.
;
;--------------------------------------------------------------------------;


.586

  uDst         EQU    [esp+44]
  uRef         EQU    [esp+48]
  mvx          EQU    [esp+52]
  mvy          EQU    [esp+56]
  iNum         EQU    [esp+60]

  uColStart    EQU    [esp+04]
  uColEnd      EQU    [esp+08]
  uRowStart    EQU    [esp+12]
  uRowEnd      EQU    [esp+16]
  iColCount    EQU    [esp+20]

  PITCH         =     384

IACODE2 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE2 ENDS


IACODE2 SEGMENT
  PUBLIC _H263BiMotionComp


;--------------------------------------------------------------------------;
;
;  Name:
;    H263BiMotionComp(U32, U32, I32, I32, I32)
;
;  Inputs -- C calling convention:
;    uDst        flat pointer to block's forward predicted values.
;    uRef        flat pointer to backward predicted values.
;    mvx         x component of backward motion vector for this block.
;    mvy         y component of backward motion vector for this block.
;    iNum        block number.
;
;  Returns:
;    updates the values pointed to by uDst.
;
;--------------------------------------------------------------------------;
;
;  Version:     2.0
;  Date:        9 November 1995
;  Author:      R. McKenzie
;
;--------------------------------------------------------------------------;


;
;  set up
;
_H263BiMotionComp:
  push     edi
   push    ebx
  push     esi
   push    ebp
  sub      esp, 24
   ;
  mov      ebx, mvy
   mov     edx, iNum
  cmp      edx, 4					    ; check block number
   jge     Chroma						; do things differently for chroma                        

;  compute adjusted_mvx and adjusted_mvy
  mov      ecx, edx
   and     edx, 2
  and      ecx, 1
   mov     eax, mvx
  sal      ecx, 4
   lea     ebx, [ebx+8*edx]             ; avoid the shift with lea
  add      eax, ecx                     ; adjusted_mvx
   mov     edi, uDst

;  check bounds  
  cmp      eax, -14
   jl      hasta_la_vista_baby
  cmp      eax, 30
   jg      hasta_la_vista_baby
  cmp      ebx, -14
   jl      hasta_la_vista_baby
  cmp      ebx, 30
   jg      hasta_la_vista_baby

;  compute row and column start & end positions
;      17 cycles
  mov      esi, 1
   mov     edi, 30
  sub      esi, eax                    ; 1 - adjusted_mvx
   sub     edi, eax                    ; 30 - adjusted_mvx
  sar      edi, 1                      ; End = (30 - adjusted_mvx) >> 1
   mov     eax, 1                      ; DELAY SLOT, preload 1
  sar      esi, 1                      ; Start = (1 - adjusted_mvx) >> 1
   sub     edi, 7                      ; End-7
  mov      ecx, esi                    ; Start
   mov     edx, edi                    ; End-7
  sar      esi, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     ebp, 30                     ; DELAY SLOT, preload 30
  sar      edi, 31                     ; end_mask = 0fffffffh if End < 7
   xor     esi, -1                     ; toggle start_mask
  and      esi, ecx                    ; max(0, Start)
   and     edi, edx                    ; min(0, End-7)
  mov      uColStart, esi              ; save Start
   add     edi, 7                      ; min(7, End)

  sub      eax, ebx                    ; 1 - adjusted_mvy
   sub     ebp, ebx                    ; 30 - adjusted_mvy
  sar      ebp, 1                      ; End = (30 - adjusted_mvy) >> 1
   mov     uColEnd, edi                ; DELAY SLOT, save End
  sar      eax, 1                      ; Start = (1 - adjusted_mvy) >> 1
   sub     ebp, 7                      ; End-7
  mov      ecx, eax                    ; Start
   mov     edx, ebp                    ; End-7
  sar      eax, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     esi, uRef                   ; DELAY SLOT, preload ref. pointer
  sar      ebp, 31                     ; end_mask = 0fffffffh if End < 7
   xor     eax, -1                     ; toggle start mask
  and      ecx, eax                    ; max(0, Start)
   and     ebp, edx                    ; min(0, End-7)
  mov      uRowStart, ecx              ; save Start
   add     ebp, 7                      ; min(7, End)


;  Compute pBackRef for BBlockAdjust
  mov      eax, mvx
   mov     ebx, mvy
  sar      eax, 1
   and     ebx, -2
  shl      ebx, 6                      ; (mvy>>1) << 7 = (mvy&(-2)) << 6
   add     esi, eax                    ; pBackRef += mvx>>1
  add      esi, ebx                    ; pBackRef += 128*(mvy>>1)
   mov     uRowEnd, ebp
  shl      ebx, 1
   mov     eax, mvx
  add      esi, ebx                    ; pBackRef += 256*(mvy>>1)
   mov     ebx, mvy
  mov      edi, uDst
   jmp     H263BBlockAdjust			   ; Off to do the actual adjustment


Chroma:
  mov      eax, mvx
   mov     ebx, mvy

;  check bounds  
  cmp      eax, -14
   jl      hasta_la_vista_baby
  cmp      eax, 14
   jg      hasta_la_vista_baby
  cmp      ebx, -14
   jl      hasta_la_vista_baby
  cmp      ebx, 14
   jg      hasta_la_vista_baby

;  compute row and column start & end positions
;      17 cycles
;  note that mvy slides through the following code in register ebx!
  mov      esi, 1
   mov     edi, 14
  sub      esi, eax                    ; 1 - mvx
   sub     edi, eax                    ; 14 - mvx
  sar      edi, 1                      ; End = (14 - mvx) >> 1
   mov     eax, 1                      ; DELAY SLOT, preload 1
  sar      esi, 1                      ; Start = (1 - mvx) >> 1
   sub     edi, 7                      ; End-7
  mov      ecx, esi                    ; Start
   mov     edx, edi                    ; End-7
  sar      esi, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     ebp, 14                     ; DELAY SLOT, preload 14
  sar      edi, 31                     ; end_mask = 0fffffffh if End < 7
   xor     esi, -1                     ; toggle start_mask
  and      esi, ecx                    ; max(0, Start)
   and     edi, edx                    ; min(0, End-7)
  mov      uColStart, esi              ; save Start
   add     edi, 7                      ; min(7, End)

  sub      eax, ebx                    ; 1 - mvy
   sub     ebp, ebx                    ; 14 - mvy
  sar      ebp, 1                      ; End = (14 - mvy) >> 1
   mov     uColEnd, edi                ; DELAY SLOT, save End
  sar      eax, 1                      ; Start = (1 - mvy) >> 1
   sub     ebp, 7                      ; End-7
  mov      ecx, eax                    ; Start
   mov     edx, ebp                    ; End-7
  sar      eax, 31                     ; start_mask = 0ffffffffh if Start < 0
   mov     esi, uRef                   ; DELAY SLOT, preload ref. pointer
  sar      ebp, 31                     ; end_mask = 0fffffffh if End < 7
   xor     eax, -1                     ; toggle start mask
  and      ecx, eax                    ; max(0, Start)
   and     ebp, edx                    ; min(0, End-7)
  mov      uRowStart, ecx              ; save Start
   add     ebp, 7                      ; min(7, End)


;  Compute pBackRef for BBlockAdjust
  mov      eax, mvx
   mov     edi, uDst                   ; DELAY SLOT, preload dest. pointer
  sar      eax, 1
   and     ebx, -2
  shl      ebx, 6                      ; (mvy>>1) << 7 = (mvy&(-2)) << 6
   add     esi, eax                    ; pBackRef += mvx>>1
  add      esi, ebx                    ; pBackRef += 128*(mvy>>1)
   mov     uRowEnd, ebp                ; DELAY SLOT, save End
  shl      ebx, 1
   mov     eax, mvx                    ; DELAY SLOT, restore mvx
  add      esi, ebx                    ; pBackRef += 256*(mvy>>1)
   mov     ebx, mvy                    ; DELAY SLOT, restore mvy


;--------------------------------------------------------------------------;
;
;  Name:
;    H263BBlockAdjust
;
;  Inputs:
;    pBiRef      edi    flat pointer to block's forward predicted values
;    pBackRef    esi    flat pointer to block's bacward predicted values as
;                       adjusted by the motion vectors
;    mvx         eax    x component of backward motion vector,
;                       used for parity only
;    mvy         ebx    y component of backward motion vector,
;                       used for parity only
;    uColStart          starting index for columns
;    uColEnd            ending index for columns
;    uRowStart          starting index for rows
;    uRowEnd            ending index for rows
;
;  Returns:
;    Updated values pointed to by pBiRef.
;
;  Notes:
;    1.  This routine is jumped into from either H263BiMotionCompLuma or
;        H263BiMotionCompChroma and effects the returns for those routines.
;
;    2.  The values of the starting and ending indicies MUST satisfy:
;            0  <=  Start  <=  End  <=  7
;
;    3.  Only the last (least significant) bits of mvx and mvy are used
;        to determine whether we need to use half-pel or full-pel 
;        prediction.
;
;    4.  The address in pBackRef must have been adjusted by the motion
;        vectors to point to the target pels.
;
;--------------------------------------------------------------------------;
;
;  Version:     1.1
;  Date:        10 November 1995
;  Author:      R. McKenzie
;
;--------------------------------------------------------------------------;

;-------------------------------;
;  common set up for all loops  ;
;-------------------------------;
H263BBlockAdjust:
  mov      ecx, uRowStart              ; row = uRowStart
   mov     edx, uColEnd
  shl      ecx, 7                      ; 128*row
   mov     ebp, uColStart
  sub      ebp, edx                    ; uColStart - uColEnd
   add     edx, ecx                    ; uColEnd += 128*row
  shl      ecx, 1                      ; 256*row
   mov     iColCount, ebp              ; inner loop starting position
  add      edx, ecx                    ; uColEnd += 256*row
   xor     ecx, ecx                    ; clear ecx
  add      esi, edx                    ; pBackRef += PITCH*row+uColEnd
   add     edi, edx                    ; pBiRef += PITCH*row+uColEnd


  and      eax, 1
   je      even_mvx
  and      ebx, 1
   je      odd_even

;
;  mvx is odd (horizontal half pel motion)
;  mvy is odd (vertical half pel motion)
;
odd_odd:
  mov      ebx, uRowStart
   mov     eax, uRowEnd
  xor      edx, edx
   sub     eax, ebx

loopoo_preamble:
  push     eax                         ; save outer count
   mov     al, [esi+ebp]               ; I
  mov      bl, [esi+ebp+1]             ; I unpaired instruction
  add      eax, ebx                    ; I
   mov     bl, [esi+ebp+PITCH]         ; I
  add      eax, ebx                    ; I
   mov     cl, [esi+ebp+PITCH+1]       ; I
  add      ecx, eax                    ; I
   inc     ebp                         ; I
  mov      eax, 0                      ; I
   jg      loopoo_postamble

loopoo_inner:
  add      ecx, 2                      ; II
   mov     al, [esi+ebp]               ; I
  shr      ecx, 2                      ; II
   mov     bl, [esi+ebp+1]             ; I
  mov      dl, [edi+ebp-1]             ; II
   add     eax, ebx                    ; I
  add      edx, ecx                    ; II
   mov     bl, [esi+ebp+PITCH]         ; I
  shr      edx, 1                      ; II
   add     eax, ebx                    ; I
  mov      [edi+ebp-1], dl             ; II
   mov     cl, [esi+ebp+PITCH+1]       ; I
  add      ecx, eax                    ; I
   inc     ebp
  mov      eax, 0                      ; I
   jle     loopoo_inner

loopoo_postamble:
  add      ecx, 2                      ; II
   add     esi, PITCH
  shr      ecx, 2                      ; II
   mov     dl, [edi+ebp-1]             ; II
  add      edx, ecx                    ; II
   add     edi, PITCH
  shr      edx, 1                      ; II
   pop     eax                         ; fetch outer count
  mov      [edi+ebp-1-PITCH], dl       ; II
   mov     ebp, iColCount
  dec      eax
   jge     loopoo_preamble

  add	   esp, 24
   jmp	   bye_bye


;
;  mvx is odd (horizontal half pel motion)
;  mvy is even (vertical full pel motion)
;
odd_even:
  mov      dl, BYTE PTR uRowStart
   mov     cl, BYTE PTR uRowEnd
  sub      dl, cl                      ; outer loop control
   sub     edi, PITCH                  ; adjust destination pointer

loopoe_preamble:
  mov      al, [esi+ebp]               ; I
   mov     bl, [esi+ebp+1]             ; I Probable (75%) Bank Conflict
  add      edi, PITCH
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jg      loopoe_postamble

loopoe_inner:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   mov     al, [esi+ebp]               ; I
  shr      ecx, 1                      ; II
   mov     bl, [esi+ebp+1]             ; I
  mov      [edi+ebp-1], cl             ; II
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jle     loopoe_inner

loopoe_postamble:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   add     esi, PITCH
  shr      ecx, 1                      ; II
   inc     dl
  mov      [edi+ebp-1], cl             ; II
   mov     ebp, iColCount
  jle      loopoe_preamble             ; unpaired

  add	   esp, 24
   jmp     bye_bye


;---------------------------;
;  mvx is even -- test mvy  ;
;---------------------------;
even_mvx:
  and      ebx, 1
   je      even_even

;
;  mvx is even (horizontal full pel motion)
;  mvy is odd (vertical half pel motion)
;
even_odd:
  mov      dl, BYTE PTR uRowStart
   mov     cl, BYTE PTR uRowEnd
  sub      dl, cl                      ; outer loop control
   sub     edi, PITCH                  ; adjust destination pointer

loopeo_preamble:
  mov      al, [esi+ebp]               ; I
   mov     bl, [esi+ebp+PITCH]         ; I Probable (75%) Bank Conflict
  add      edi, PITCH
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jg      loopeo_postamble

loopeo_inner:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   mov     al, [esi+ebp]               ; I
  shr      ecx, 1                      ; II
   mov     bl, [esi+ebp+PITCH]         ; I
  mov      [edi+ebp-1], cl             ; II
   inc     ebp
  lea      ecx, [eax+ebx+1]            ; I
   jle     loopeo_inner

loopeo_postamble:
  shr      ecx, 1                      ; II
   mov     al, [edi+ebp-1]             ; II
  add      ecx, eax                    ; II
   add     esi, PITCH
  shr      ecx, 1                      ; II
   inc     dl
  mov      [edi+ebp-1], cl             ; II
   mov     ebp, iColCount
  jle      loopeo_preamble             ; unpaired

  add	   esp, 24
   jmp     bye_bye


;
;  mvx is even (horizontal full pel motion)
;  mvy is even (vertical full pel motion)
;
even_even:
  mov      dl, BYTE PTR uRowStart
   mov     cl, BYTE PTR uRowEnd
  sub      dl, cl

loopee_preamble:
  mov      al, [esi+ebp]               ; I
   mov     bl, [edi+ebp]               ; I possbile bank conflict
  test     ebp, ebp
   je      loopee_postamble

loopee_inner:
  lea      ecx, [eax+ebx]              ; II
   mov     al, [esi+ebp+1]             ; I
  shr      ecx, 1                      ; II
   mov     bl, [edi+ebp+1]             ; I
  mov      [edi+ebp], cl               ; II
   inc     ebp
  jl       loopee_inner                ; unpaired

loopee_postamble:
  add      eax, ebx                    ; II
   add     edi, PITCH
  shr      eax, 1                      ; II
   add     esi, PITCH
  mov      [edi+ebp-PITCH], al         ; II
   mov     ebp, iColCount
  inc      dl
   jle     loopee_preamble


;
;  "Remember when I promised to kill you last?"
;
hasta_la_vista_baby:
  add	   esp, 24
bye_bye:
  pop      ebp
   pop     esi
  pop      ebx
   pop     edi
  ret

;  biMotionCompLuma ENDP
;        1111111111222222222233333333334444444444555555555566666666667777777
;234567890123456789012345678901234567890123456789012345678901234567890123456
;--------------------------------------------------------------------------;
IACODE2 ENDS

END
//  bimot.asm	page 9	1:41 PM, 11/21/95  //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dx5frmcp.asm ===
;* *************************************************************************
;*    INTEL Corporation Proprietary Information
;*
;*    This listing is supplied under the terms of a license
;*    agreement with INTEL Corporation and may not be copied
;*    nor disclosed except in accordance with the terms of
;*    that agreement.
;*
;*    Copyright (c) 1995 Intel Corporation.
;*    All Rights Reserved.
;*
;* *************************************************************************
;//
;//
;// $Header:   S:\h26x\src\dec\dx5frmcp.asv
;//
;// $Log:   S:\h26x\src\dec\dx5frmcp.asv  $
;// 
;//    Rev 1.1   20 Dec 1995 15:55:42   RMCKENZX
;// Added FrameMirror function to file to support mirror imaging
;// 
;//    Rev 1.0   25 Oct 1995 18:11:36   BNICKERS
;// Initial revision.
;// 
;////////////////////////////////////////////////////////////////////////////
;
; File:
;   dx5frmcp 
;
; Functions:
;   FrameCopy
;     This function copies a frame from one frame buffer to another.
;     It is tuned for best performance on the Pentium(r) Microprocessor.
;
;     It is assumed that the frames have the same height, width, and
;     pitch, and that, if width is NOT a multiple of 8, it is okay
;     to copy up to the next multiple of 8.
;
;   FrameMirror
;     This function mirror images a frame from one frame buffer to
;     another.  It is tuned for best performance on the Pentium.
;
;     It is assumed that the frames have the same height, width, and
;     pitch.  The width may be any (non-negative) value.

OPTION PROLOGUE:None
OPTION EPILOGUE:ReturnAndRelieveEpilogueMacro

include locals.inc

IFNDEF DSEGNAME
IFNDEF WIN32
DSEGNAME TEXTEQU <Data_FrameCopy>
ENDIF
ENDIF

IFDEF WIN32
.xlist
include memmodel.inc
.list
.DATA
ELSE
DSEGNAME SEGMENT WORD PUBLIC 'DATA'
ENDIF

; any data would go here

IFNDEF WIN32
DSEGNAME ENDS
.xlist
include memmodel.inc
.list
ENDIF

IFNDEF SEGNAME
IFNDEF WIN32
SEGNAME TEXTEQU <_CODE32>
ENDIF
ENDIF

ifdef WIN32
.CODE
else
SEGNAME        SEGMENT PARA PUBLIC USE32 'CODE'
endif


ifdef WIN32
ASSUME cs : FLAT
ASSUME ds : FLAT
ASSUME es : FLAT
ASSUME fs : FLAT
ASSUME gs : FLAT
ASSUME ss : FLAT
else
ASSUME CS : SEGNAME
ASSUME DS : Nothing
ASSUME ES : Nothing
ASSUME FS : Nothing
ASSUME GS : Nothing
endif

; void FAR ASM_CALLTYPE FrameCopy (U8 FAR * InputBase,
;                                  X32 InputPlane,
;                                  U8 FAR * OutputBase,
;                                  X32 OutputPlane,
;                                  UN  FrameHeight,
;                                  UN  FrameWidth,
;                                  UN  Pitch)

PUBLIC  FrameCopy

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

        FrameCopy    proc DIST LANG AInputPlane:        DWORD,
                                    AOutputPlane:       DWORD,
                                    AFrameHeight:       DWORD,
                                    AFrameWidth:        DWORD,
                                    APitch:             DWORD

IFDEF WIN32

RegisterStorageSize = 16

; Arguments:

InputPlane                 = RegisterStorageSize +  4
OutputPlane                = RegisterStorageSize +  8
FrameHeight                = RegisterStorageSize + 12
FrameWidth                 = RegisterStorageSize + 16
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 24

ELSE

; Arguments:

RegisterStorageSize = 24           ; Put local variables on stack.
InputPlane                 = RegisterStorageSize +  4
InputPlane_SegNum          = RegisterStorageSize +  6
OutputPlane                = RegisterStorageSize +  8
OutputPlane_SegNum         = RegisterStorageSize + 10
OutputPlane                = RegisterStorageSize + 12
FrameHeight                = RegisterStorageSize + 16
FrameWidth                 = RegisterStorageSize + 18
Pitch                      = RegisterStorageSize + 20
EndOfArgList               = RegisterStorageSize + 22

ENDIF

  push  esi
  push  edi
  push  ebp
  push  ebx
IFDEF WIN32
  mov  esi,PD [esp+InputPlane]
   mov  edi,PD [esp+OutputPlane]
  mov   ebp,PD [esp+Pitch]
   mov  edx,PD [esp+FrameWidth]
  mov   ecx,PD [esp+FrameHeight]
ELSE
  mov   ax,ds
  mov   bx,es
  push  eax
   push ebx
  mov   ax,PW [esp+InputBase_SegNum]
  movzx esi,PW [esp+InputPlane]
  mov   bx,PW [esp+OutputBase_SegNum]
  movzx edi,PW [esp+OutputPlane]
  mov   ds,ebx
  mov   es,eax
  movzx ebp,PW [esp+Pitch]
  movzx edx,PW [esp+FrameWidth]
  movzx ecx,PW [esp+FrameHeight]
ENDIF
  add   edx,7
  and   edx,0FFFFFFF8H
  sub   ebp,edx
  sub   edi,esi

  push  edx

CopyLineLoop:

  mov   eax,Ze PD [esi]
   mov  ebx,PD [esi+edi]      ; Load output cache line
  mov   ebx,Ze PD [esi+4]
   mov  PD [esi+edi],eax
  mov   PD [esi+edi+4],ebx
   add  esi,8
  sub   edx,8
   jg   CopyLineLoop

  add   esi,ebp
   dec  ecx                  ; Reduce count of lines.
  mov   edx,PD [esp]         ; Reload frame width.
   jg   CopyLineLoop

  pop   edx

IFDEF WIN32
ELSE
  pop   ebx
  mov   es,ebx
  pop   ebx
  mov   ds,ebx
ENDIF
  pop   ebx
  pop   ebp
  pop   edi
  pop   esi
  rturn

FrameCopy endp



PUBLIC  FrameMirror

; due to the need for the ebp reg, these parameter declarations aren't used,
; they are here so the assembler knows how many bytes to relieve from the stack

FrameMirror    proc DIST LANG BInputPlane:        DWORD,
                              BOutputPlane:       DWORD,
                              BFrameHeight:       DWORD,
                              BFrameWidth:        DWORD,
                              BPitch:             DWORD

;  save registers
  push    esi
   push   edi
  push    ebp
   push   ebx

;  setup and get parameters
IFDEF WIN32
  mov     esi, PD [esp+InputPlane]
   mov    edi, PD [esp+OutputPlane]
  mov     ebp, PD [esp+Pitch]
   mov    edx, PD [esp+FrameWidth]
  mov     ecx, PD [esp+FrameHeight]

ELSE
  mov     ax, ds
   mov    bx, es
  push    eax
   push   ebx
  mov     ax, PW [esp+InputBase_SegNum]
   movzx  esi, PW [esp+InputPlane]
  mov     bx, PW [esp+OutputBase_SegNum]
   movzx  edi, PW [esp+OutputPlane]
  mov     ds, ebx
   mov    es, eax
  movzx   ebp, PW [esp+Pitch]
   movzx  edx, PW [esp+FrameWidth]
  movzx   ecx, PW [esp+FrameHeight]
ENDIF

;  start processing

;  prepare for the loop
   push   edx                   ; save width

per_line_loop:
  test    edx, 7				; check for short count
   je     skip_short_count		; skip when no short count

short_count_loop:
  mov     al, [esi+edx-1]
   dec    edx
  mov     [edi], al
   inc    edi
  test    edx, 7
   jne    short_count_loop

skip_short_count:
  test    edx, edx
   je     skip_inner_loop

;  inner loop is unrolled to do 8 bytes per iteration
inner_loop:
  mov     al, [edi]			  ; heat cache
   add    edi, 8
  mov     al, [esi+edx-1]
   mov    bl, [esi+edx-5]
  mov     [edi-8], al
   mov    [edi-4], bl
  mov     al, [esi+edx-2]
   mov    bl, [esi+edx-6]
  mov     [edi-7], al
   mov    [edi-3], bl
  mov     al, [esi+edx-3]
   mov    bl, [esi+edx-7]
  mov     [edi-6], al
   mov    [edi-2], bl
  mov     al, [esi+edx-4]
   mov    bl, [esi+edx-8]
  mov     [edi-5], al
   mov    [edi-1], bl
  sub     edx, 8
   jne    inner_loop

;  now move down to the next line
skip_inner_loop:
  mov     edx, [esp]		; restore width
   add    edi, ebp			; increment destination
  add     esi, ebp			; increment source
   sub    edi, edx			; correct destination by width
  dec     ecx
   jne    per_line_loop

;  restore stack pointer
  pop     eax

IFDEF WIN32
ELSE
  pop     ebx
   pop    eax
  mov     es, bx
   mov    ds, ax
ENDIF

;  restore registers and return
  pop     ebx
   pop    ebp
  pop     edi
   pop    esi
  rturn

FrameMirror endp

IFNDEF WIN32
SEGNAME ENDS
ENDIF

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dx5aspec.asm ===
;* *************************************************************************
;*    INTEL Corporation Proprietary Information
;*
;*    This listing is supplied under the terms of a license
;*    agreement with INTEL Corporation and may not be copied
;*    nor disclosed except in accordance with the terms of
;*    that agreement.
;*
;*    Copyright (c) 1995 Intel Corporation.
;*    All Rights Reserved.
;*
;* *************************************************************************

;* -------------------------------------------------------------------------
;* PVCS Source control information:
;*
;*	$Header:   S:\h26x\src\dec\dx5aspec.asv   1.2   01 Sep 1995 17:12:12   DBRUCKS  $
;*
;*	$Log:   S:\h26x\src\dec\dx5aspec.asv  $
;// 
;//    Rev 1.2   01 Sep 1995 17:12:12   DBRUCKS
;// fix shaping
;// 
;//    Rev 1.1   29 Aug 1995 16:49:02   DBRUCKS
;// cleanup comment
;// 
;//    Rev 1.0   23 Aug 1995 12:20:32   DBRUCKS
;// Initial revision.
;*  
;*  NOTE: 
;*			The starting source for this routine came from the PVCS database
;*			for the H261 decoder (aspeccor.asm version 1.1, which is a working
;*          16-bit version).
;* -------------------------------------------------------------------------

;////////////////////////////////////////////////////////////////////////////
; AspectCorrect  -- This function converts the U & V data from 8 bits to 7 bits
;                   and moves the data into the YVU9 format the MRV color
;                   convertors want.  Note: the Y data was already converted
;                   from 8 bits to 7 bits in Convert_Y_8to7_Bit.
;
; 	if (Input Format == YVU9)
;		/* This is needed for looking glass output */
;		copy U and V from src to dst
;	else { /* Input Format == YVU12 */
;		if (shaping) {
;			copy Y from src to dst skiping every 12th line
;			copy UV from src to dst subsampling and dropping one in 12 lines 
;				(although not every 12th).
;		} else {
;			copy UV from src to dst subsampling
;		}
;	}
;        
;	Notes: 
;	* the MRV color converters expect YVU9
;	* we may need to drop every 12th line for aspect ratio correction of the
;	  YVU12 input.
;
;   ASSUMPTIONS/LIMITATIONS:
;   * IF input in YVU12, only 128x96, 176x144, & 352x288 resolutions are 
;     supported.  YVU9 should support all sizes.
;
;-------------------------------------------------------------------------------

include decconst.inc

ifndef WIN32
.MODEL SMALL
endif

.486

ifdef WIN32
.MODEL FLAT
.DATA

else ;; WIN16
_DATA	SEGMENT PUBLIC 'DATA'
endif

;;	Toss lines for aspect ratio correction 12 to 9
;;        6, 19, 30, 43, 54, 67,
;;       78, 91,102,115,126,139

;;	Lookup Table for 8->7 bit conversion and clamping.
;;  U and V range from 16..240->8..120
gTAB_UVtbl8to7  BYTE      8,  8,  8,  8,  8,  8,  8,  8
				BYTE      8,  8,  8,  8,  8,  8,  8,  8  
				BYTE      8,  8,  9,  9, 10, 10, 11, 11
				BYTE     12, 12, 13, 13, 14, 14, 15, 15
				BYTE     16, 16, 17, 17, 18, 18, 19, 19
				BYTE     20, 20, 21, 21, 22, 22, 23, 23
				BYTE     24, 24, 25, 25, 26, 26, 27, 27
				BYTE     28, 28, 29, 29, 30, 30, 31, 31
				BYTE     32, 32, 33, 33, 34, 34, 35, 35
				BYTE     36, 36, 37, 37, 38, 38, 39, 39
				BYTE     40, 40, 41, 41, 42, 42, 43, 43 
				BYTE     44, 44, 45, 45, 46, 46, 47, 47
				BYTE     48, 48, 49, 49, 50, 50, 51, 51
				BYTE     52, 52, 53, 53, 54, 54, 55, 55
				BYTE     56, 56, 57, 57, 58, 58, 59, 59
				BYTE     60, 60, 61, 61, 62, 62, 63, 63
				BYTE     64, 64, 65, 65, 66, 66, 67, 67
				BYTE     68, 68, 69, 69, 70, 70, 71, 71
				BYTE     72, 72, 73, 73, 74, 74, 75, 75
				BYTE     76, 76, 77, 77, 78, 78, 79, 79
				BYTE     80, 80, 81, 81, 82, 82, 83, 83
				BYTE     84, 84, 85, 85, 86, 86, 87, 87
				BYTE     88, 88, 89, 89, 90, 90, 91, 91
				BYTE     92, 92, 93, 93, 94, 94, 95, 95
				BYTE     96, 96, 97, 97, 98, 98, 99, 99
				BYTE    100,100,101,101,102,102,103,103
				BYTE    104,104,105,105,106,106,107,107
				BYTE    108,108,109,109,110,110,111,111
				BYTE    112,112,113,113,114,114,115,115
				BYTE    116,116,117,117,118,118,119,119
				BYTE    120,120,120,120,120,120,120,120
				BYTE    120,120,120,120,120,120,120,120

_DATA	ENDS

ifdef WIN32
.CODE
assume cs : flat
assume ds : flat
assume es : flat
assume fs : flat
assume gs : flat

else
_TEXT32 SEGMENT PUBLIC READONLY USE32 'CODE'
ASSUME	DS:_DATA
ASSUME	CS:_TEXT32
ASSUME	ES:nothing
ASSUME	FS:nothing
ASSUME	GS:nothing
endif

;C function prototype
;
;long AspectCorrect(
;			HPBYTE      pYPlaneInput,  /*ptr Y plane*/
;		    HPBYTE      pVPlaneInput,  /*ptr V plane*/
;		    HPBYTE      pUPlaneInput,  /*ptr U plane*/
;		    DWORD       YResolution,   /*Y plane height*/
;		    DWORD       XResolution,   /*Y plane width*/
;		    WORD far  * pyNewHeight,   /*Pitch of Y plane in*/
;		    DWORD		YVU9InputFlag, /*flag = YUV9 or YUV12*/
;		    HPBYTE      pYPlaneOutput, /*pYOut*/
;		    HPBYTE      pVPlaneOutput, /*pUOut*/
;		    DWORD       YPitchOut,     /*Pitch of Y plane out*/
;		    DWORD		ShapingFlag	   /*flag = Shaping or not*/
;		    )

PUBLIC _AspectCorrect

ifdef WIN32
_AspectCorrect proc

else
_AspectCorrect proc far
;   parmD    pYPlaneIn        ;ptr to Y input plane
;   parmD    pVPlaneIn        ;ptr to V input plane
;   parmD    pUPlaneIn        ;ptr to U input plane
;   parmD    YRes             ;Y plane height
;   parmD    XRes             ;Y plane width
;   parmD    pYNewHeight      ;Pitch of Y plane input
;   parmD    YVU9Flag         ;Flag=1 if YUV9
;   parmD    pYPlaneOut       ;ptr to Y output plane
;   parmD    pVPlaneOut       ;ptr to V output plane
;   parmD    YPitchOut        ;Pitch of Y plane output
;   parmD    ShapingFlag      ;Flag=1 if Shaping

endif


;set up equates
pYPlaneIn   EQU  DWORD PTR[ebp+8]
pVPlaneIn   EQU  DWORD PTR[ebp+12]
pUPlaneIn   EQU  DWORD PTR[ebp+16]
YRes        EQU  DWORD PTR[ebp+20]
XRes        EQU  DWORD PTR[ebp+24]
pYNewHeight EQU  DWORD PTR[ebp+28]
YVU9Flag    EQU  DWORD PTR[ebp+32]
pYPlaneOut  EQU  DWORD PTR[ebp+36]
pVPlaneOut  EQU  DWORD PTR[ebp+40]
YPitchOut   EQU  DWORD PTR[ebp+44]
ShapingFlag EQU  DWORD PTR[ebp+48]

;; stack usage
; previous ebp at ebp 
; previous edi at ebp - 4
; previous esi at ebp - 8
; lXRes        at ebp -12
; lYRes        at ebp -16
; lYPitchOut   at ebp -20
; YDiff        at ebp -24
; outloopcnt   at ebp -28
; uvWidth      at ebp -32
; inloopcnt    at ebp -36
; luvcounter   at ebp -40
; uvoutloopcnt at ebp -44
; VDiff        at ebp -48
; VInDiff	   at ebp -52

lXRes        EQU  DWORD PTR[ebp-12]
lYRes        EQU  DWORD PTR[ebp-16]
lYPitchOut   EQU  DWORD PTR[ebp-20]
YDiff        EQU  DWORD PTR[ebp-24]
outloopcnt   EQU  DWORD PTR[ebp-28]
uvWidth      EQU  DWORD PTR[ebp-32]
inloopcnt    EQU  DWORD PTR[ebp-36]
luvcounter   EQU  DWORD PTR[ebp-40]
uvoutloopcnt EQU  DWORD PTR[ebp-44]
VDiff        EQU  DWORD PTR[ebp-48]
VInDiff      EQU  DWORD PTR[ebp-52]

  xor   ax,ax           ; These two instructions give definitive proof we are
  mov   eax,0CCCCCCCCH  ; in a 32-bit code segment.  INT 3 occurs if not.

;get params
	push    ebp

ifdef WIN32
	mov     ebp, esp
else
	movzx  	ebp, sp	        ;ebp now pointing to last pushed reg
endif
	  push    edi
	push    esi

; zero out registers
	xor 	edx, edx

	xor	esi, esi
	xor	edi, edi

; move stack variables to local space
	mov	eax, XRes
	push	eax		; store lXRes on stack

	mov	ebx, YRes
	push	ebx		; store lYRes on stack

	mov	ecx, YPitchOut
	push	ecx		; store lYpitchOut on stack
	sub	ecx, eax	; YDiff = YPitchOut - XRes
	push	ecx		; store YDiff on stack

; push stack with 0 6 additional times to make room for other locals
	push	edx		; outloopcnt
	push	edx		; uvWidth
	push	edx		; inloopcnt
	push	edx		; luvcounter
	push	edx		; uvoutloopcnt
	push	edx		; VDiff
	push    edx     ; VInDiff

; test if YUV9 mode
	mov     edx, YVU9Flag
	test    edx,edx
	jz      YVU12;      ; If the flag is false it must be YVU12

;**********************************************************************
;**********************************************************************
; know input was YVU9, Y Plane was processed in cc12to7.asm

	mov esi, pYNewHeight
	mov	WORD PTR [esi], bx	; store YRes into address pYNewHeight

; ********************
; Copy V and U Plane from source to destination converting to 7 bit
; ********************
; Description of V & U Plane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes/4 lines 
;       Collp1 loops for number of columns
;         - Read 1 U
;	  - Read 1 V
;         - Convert each value from 8-bit to 7-bit
;         - Store 1 U
;         - Store 1 V
;
; Register usage
;   eax	U plane input address
;   ebx	source value and index into gTAB_UVtbl8to7
;   ecx	source value and index into gTAB_UVtbl8to7
;   edx	inner most loop counter 
;   esi	V plane src address
;   edi	des address
;   ebp	stack pointer stuff
;
; if (16-bit)
;   es	input plane segment
;   fs	output plane segment
;   ds	table segment
; endif
;
; local variables
;  outloopcnt
;  lXRes
;  lYRes
;  uvWidth
;  VDiff
;
; know input was YVU9
	mov	ecx, lYRes
	  mov	ebx, lXRes
	shr	ebx, 2			; uvWidth=XRes/4
	  mov	eax, VPITCH		; get Fixed offset
	shr	ecx, 2			; outloopcnt=YRes/4
	  mov	uvWidth,ebx		; uvWidth=XRes/4
	sub	eax, ebx		; VPITCH - uvWidth

	mov	esi,  pVPlaneIn		; Initialize input cursor
	mov	edi,  pVPlaneOut	; Initialize output cursor
	  mov	VDiff, eax		; store V difference
	mov	eax,  pUPlaneIn		; Initialize input cursor
	
Row9lp2:
	mov	outloopcnt,ecx		; store updated outer loop count
	  mov	edx, uvWidth		; init dx
	xor	ebx, ebx
	  xor	ecx, ecx

Col9lpv1:
  	mov  	cl, BYTE PTR [eax]	      ; Fetch *PUtemp_IN
	  inc	edi			              ; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	      ; Fetch *pVtemp_IN
	  inc	eax			              ; pUtemp+=1
	mov	    cl, gTAB_UVtbl8to7[ecx]	  ; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  inc	esi			              ; Inc source by 1,pVtemp+=1
	mov  	BYTE PTR [edi+167],cl     ; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	  ; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	      ; store in PVtemp_OUT
	  xor	ecx, ecx	              ; dummy op
	dec	edx
	  jg  	Col9lpv1

;; increment to beginning of next line
	mov	edx, VDiff

	mov	ecx, outloopcnt		; get outer loop count
	  add	edi,edx			; Point to next output row
	dec	ecx
	  jnz	Row9lp2			; if more to do loop

	jmp	Cleanup

;*****************************************************************
;*****************************************************************
; know input was YVU12
;
;    if (!ShapingFlag) {
;        goto YVU12_NO_SHAPING;
;    } else {
;        switch (YRes) {  // YRes = YRes * 11 / 12;
;        case  96: *pyNewHeight =  88; break;
;        case 144: *pyNewHeight = 132; break;
;        case 288: *pyNewHeight = 264; break;
;        default: error;
;        }
;    }
;
YVU12:
	mov  eax, ShapingFlag
	test eax, eax
	jz   YVU12_NO_SHAPING
	
	cmp lYRes, 96       ; If 96
	je  YRes96
	cmp	lYRes, 144		; If 144 
	je	YRes144
	cmp	lYRes, 288		; If 288
	je	YRes288
	jmp	Error
;
YRes96:
	mov	ax, 88          ; pyNewHeight = ax = 132
	mov	ecx, 7			; for YRes lines loopcounter=11
	mov	uvoutloopcnt, 1	; process 1 full set of 13&11 lines
	jmp	Rejoin2

YRes144:
	mov	ax, 132			; pyNewHeight = ax = 132
	mov	ecx, 11			; for YRes lines loopcounter=11
	mov	uvoutloopcnt, 2	; process 2 full sets of 13&11 lines
	jmp	Rejoin2

YRes288:
	mov	ax, 264			; pyNewHeight = ax = 264
	mov	ecx, 23			; for YRes lines loopcounter=23
	mov	uvoutloopcnt, 5	; process 5 full sets of 13&11 lines

Rejoin2:
	mov	esi, pYNewHeight
	mov	[esi], ax	    ; store adjusted height into 
					            ; address pYNewHeight
; ********************
; Copy Y Plane from soure to dest skipping every 12th line 
; ********************
; Description of YPlane processing:
;
; Triple nested loop with 
; Outlp1 executed 11 or 23 times based on 144 or 288 lines respectively
;   Rowlp1 is executed 11 times 
;     Collp1 loops for number of columns
;
; Register usage
;  eax	rows loop count
;  ebx	input and output
;  ecx	outer loop count
;  edx	column loop counter 
;  esi	src address
;  edi	des address
;  ebp	stack pointer stuff
;
;  es	input plane segment
;  fs	output plane segment
;  ds	table segment
;
; local variables
;  lXRes
;  YDiff
;  lYPitchOut
;
	mov esi,  pYPlaneIn		; Initialize input cursor
	mov	edi,  pYPlaneOut		; Initialize output cursor

; No need to re-copy first 11 lines
	mov	eax, lYPitchOut
	  mov	edx, YDiff
	add	edi, eax		; des + 1*lYPitchOut
	shl	eax, 1			; lYPitchOut*2
;;;	add	esi, edx		; Adjust for difference in YPitchOut
					;   and XRes
	  add	edi, eax		; des + 3*lYpitchOut
	shl	eax, 1			; lYPirchOut*4
;;;	add	edi, edx		; Adjust for difference in YPitchOut
					;   and XRes
	  add	esi, eax		; source + 4*lYpitchOut
	shl	eax, 1			; lYPitchOut*8
	add	esi, eax		; source +12*lYpitchOut
	  add	edi, eax		; des + 11*lYPitchOut

Outlp1:
	mov	eax, 11 		; Initialize rows loop cnter
	  mov	edx, lXRes		; edx = number of columns

Rowlp1:
Collp1:
  	mov  	ebx, [esi+edx-4]	; Fetch source, 4 at a time
	  sub  	edx,4			; decrement loop counter
	mov  	[edi+edx],ebx	; Store 4 converted values
	  jnz  	Collp1			; if not done loop

	mov	edx, lYPitchOut
	  mov	ebx, YDiff
	add	edi, edx		; Increment to where just processed
	  add	esi, edx
;;;	add	edi, ebx		; Adjust for difference in YPitchOut
;;;	  add	esi, ebx		;  and XRes
	dec	eax			; decrement rows loop counter
	  jg	Rowlp1

	mov	eax,lYPitchOut		; Skip 12th line
	add	esi,eax			; Point to next input row

	dec	ecx			; decrement outer loop counter
	  jg	Outlp1			; if more to do loop

; ************************************************************
; Copy V and U Plane from source to destination converting to 7 bit
;   skipping every other line and sometimes two moving only ever other 
;   pixel in a row.
; ********************
;
; Description of V & U Plane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes/4 lines 
;       Collp1 loops for number of columns
;         - Read 1 U
;	  - Read 1 V
;         - Convert each value from 8-bit to 7-bit
;         - Store 1 U
;         - Store 1 V
;
; Register usage
;   eax	U plane input address
;   ebx	source value and index into gTAB_UVtbl8to7
;   ecx	source value and index into gTAB_UVtbl8to7
;   edx	counter
;   esi	V plane src address
;   edi	des address, V Plane and U Plane
;   ebp	stack pointer stuff
;
;   es	input plane segment
;   fs	output plane segment
;   ds	table segment
;
; local variables
;  luvcounter
;  uvoutloopcnt
;  inloopcnt
;  lXRes
;  uvWidth
;  VDiff
;
	mov	ebx, lXRes
	  mov	eax, VPITCH		; get Fixed offset
	shr	ebx, 1			; uvWidth=XRes/2
	mov	uvWidth, ebx		; uvWidth=XRes/2
	shr	ebx, 1
	sub	eax, ebx		; VPITCH - uvWidth
	mov	VDiff, eax		; store V difference
	  mov	luvcounter, ebx		; luvcounter = XRes/4

	mov     ecx, YPITCH		; Distance to the next V
	  add   ecx, ecx
	sub     ecx, uvWidth           
	  mov   VInDiff, ecx    ;	 = YPITCH + YPITCH - uvWidth 

	mov	esi,  pVPlaneIn		; Initialize input cursor
	mov	edi,  pVPlaneOut		; Initialize output cursor
	mov	eax,  pUPlaneIn		; Initialize input cursor

; Process 6 first lines special
	mov	ebx, 3			; initialize inner loop count 
	
Rowlp2_6:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1

; increment to beginning of next line then skip next input line
	add	    edi,VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 6 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_6		; if more to do loop

; Skipping extra line
	mov	edx,YPITCH		; Need same sized for add
	  mov	ecx, uvoutloopcnt
	add	esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

; Process groups of 13 and 11 lines
Outlp2:

;   Process 13 lines
	mov	ebx, 6			; initialize inner loop count 
	  mov	uvoutloopcnt, ecx

Rowlp2_13:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_13:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_13

; increment to beginning of next line then skip next input line
	add	    edi,VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 13 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_13		; if more to do loop

; Skipping extra line
	mov	    edx,YPITCH 		; Need same sized for add
	  mov	ebx, 5			; initialize inner loop count 
	add	    esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

;   Process 11 lines
Rowlp2_11:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_11:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_11

; increment to beginning of next line, then skip next input line
	add	    edi, VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 11 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_11		; if more to do loop

; Skipping extra line
	mov	    edx,YPITCH		; Need same sized for add
	  mov	ecx, uvoutloopcnt
	add	    esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

	dec	ecx
	  jnz	Outlp2			; if more to do loop

;
; Process last set of 13
;
	mov	ebx, 6			; initialize inner loop count 

Rowlp2_13l:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx		; store updated inloopcnt
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_13l:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_13l

; increment to beginning of next line then skip next input line
	add	    edi,VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed 13 lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_13l		; if more to do loop

; Skipping extra line
	mov	    edx,YPITCH		; Need same sized for add
	  mov	ebx, 2			; initialize inner loop count 
	add	    esi,edx			; Point to next input row
	  add	eax,edx			; Point to next input row

; Process final 4 lines
Rowlp2_f:
	mov	edx, luvcounter		; init dx
	  mov	inloopcnt, ebx
	xor	ebx, ebx
	  xor	ecx, ecx

Collpv1_f:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_f

; increment to beginning of next line then skip next input line
	add	    edi, VDiff		; Point to next output row
	  mov	edx,VInDiff		; Skip to next input row
	add	    esi,edx			; 
	  add	eax,edx			; 

; test if have processed last lines yet
	mov	ebx, inloopcnt
	dec	ebx
	  jg	Rowlp2_f		; if more to do loop

	jmp	Cleanup

; ************************************************************
; Copy V and U Plane from source to destination converting to 7 bit
;   skipping every other line moving only ever other pixel in a row.
; ********************
;
; Description of V & U Plane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes/4 lines 
;       Collp1 loops for number of columns
;         - Read 1 U
;	  - Read 1 V
;         - Convert each value from 8-bit to 7-bit
;         - Store 1 U
;         - Store 1 V
;
; Register usage
;   eax	U plane input address
;   ebx	source value and index into gTAB_UVtbl8to7
;   ecx	source value and index into gTAB_UVtbl8to7
;   edx	counter
;   esi	V plane src address
;   edi	des address, V Plane and U Plane
;   ebp	stack pointer stuff
;
;   es	input plane segment
;   fs	output plane segment
;   ds	table segment
;
; local variables
;  luvcounter
;  inloopcnt
;  lYRes
;  lXRes
;  uvWidth
;  VDiff
;  VInDiff
;
YVU12_NO_SHAPING:   
	cmp lYRes, 98
	je  YRes98_NS
	cmp	lYRes, 144		 
	je	YRes144_NS
	cmp	lYRes, 288		
	je	YRes288_NS
	jmp	Error
;
YRes98_NS:    ;  98 No Shaping           
YRes144_NS:	  ; 144 No Shaping
YRes288_NS:   ; 288 No Shaping
	mov	eax, lYRes		; pyNewHeight = ax = YRes
	mov	esi, pYNewHeight
	mov	[esi], ax	; store adjusted height into 

	shr	eax, 2			; inloopcnt=YRes/2
	 mov	ebx, lXRes
	shr	ebx, 1			; uvWidth=XRes/2
	  mov	inloopcnt, eax		; initialize inner loop count 
	mov	uvWidth, ebx		; uvWidth=XRes/2
	  mov	ecx, VPITCH		; get output plane V pitch
	shr	ebx, 1
	  sub	ecx, ebx		; VPITCH - uvWidth/2
	mov	luvcounter, ebx		; luvcounter = XRes/4
	  mov	VDiff, ecx		; Store VDiff

	mov     ecx, YPITCH		; Distance to the next V
	  add   ecx, ecx
	sub     ecx, uvWidth           
	  mov   VInDiff, ecx    ;	 = YPITCH + YPITCH - uvWidth 

	mov	esi,  pVPlaneIn		; Initialize input cursor
	mov	edi,  pVPlaneOut		; Initialize output cursor
	mov	eax,  pUPlaneIn		; Initialize input cursor
	  mov	ecx, inloopcnt

; Process all lines skipping just every other

Rowlp2_NS:
	mov	inloopcnt, ecx		; store update inloopcnt
	  xor	ebx, ebx
	mov	edx, luvcounter		; init dx
	  xor	ecx, ecx

Collpv1_NS:
  	mov  	cl, BYTE PTR [eax]	; Fetch *PUtemp_IN
	  inc	edi			; Inc des by 1, PVtemp_OUT++
  	mov  	bl, BYTE PTR [esi]	; Fetch *pVtemp_IN
	  add	eax,2			; pUtemp+=2
	mov	cl, gTAB_UVtbl8to7[ecx]	; cl = gTAB_UVtbl8to7[*pUtemp_IN]
	  add	esi,2			; Inc source by 2,pVtemp+=2
	mov  	BYTE PTR [edi+167],cl; store in PUtemp_OUT
	  mov	bl, gTAB_UVtbl8to7[ebx]	; bl = gTAB_UVtbl8to7[*pVtemp_IN]
	mov  	BYTE PTR [edi-1],bl	; store in PVtemp_OUT
	  xor	ecx, ecx		; dummy op
	dec	edx
	  jg  	Collpv1_NS

; increment to beginning of next line then skip next input line
	add	edi, VDiff		; Point to next output row
	  mov	edx,VInDiff	; Skip to next input row
	add	esi,edx			; 
	  add	eax,edx			; 
	mov	ecx, inloopcnt		; get inloopcnt

; test if have processed all lines yet
	dec	ecx			; Process next line
	  jne	Rowlp2_NS		; if more to do loop

Error:
Cleanup:
; clean out local variables on stack
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop	ecx
	  pop	ebx
	pop ecx

;clear special seg registers, restore stack, pop saved registers
ifndef WIN32
	xor     ecx, ecx
	xor     ebx, ebx
	mov     es, cx
	mov     fs, bx
endif
	  pop     esi
	pop     edi
	  pop     ebp

ifdef WIN32
	ret
else
	db      066h
	retf
endif

_AspectCorrect endp

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mbkadd.asm ===
;--------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------

;--------------------------------------------------------------------------
;
; $Author:   SCDAY  $
; $Date:   31 Oct 1996 09:00:56  $
; $Archive:   S:\h26x\src\dec\d3mbkadd.asv  $
; $Header:   S:\h26x\src\dec\d3mbkadd.asv   1.8   31 Oct 1996 09:00:56   SCDAY  $
; $Log:   S:\h26x\src\dec\d3mbkadd.asv  $
;// 
;//    Rev 1.8   31 Oct 1996 09:00:56   SCDAY
;// Raj added IFDEF H261 MMX_BlockAddSpecial and MMX_BlockCopySpecial
;// 
;//    Rev 1.7   09 Jul 1996 16:50:42   AGUPTA2
;// DC value for INTRA blocks is added back in ClipAndMove routine.
;// Cleaned-up code.
;// 
;//    Rev 1.6   04 Apr 1996 13:42:58   AGUPTA2
;// Removed a store stall from MMX_BlockAdd
;// 
;//    Rev 1.5   03 Apr 1996 17:42:30   AGUPTA2
;// Added MMX version of BlockCopy routine.
;// 
;//    Rev 1.4   03 Apr 1996 11:08:22   RMCKENZX
;// Added clearing of IDCT output.  Cleaned comments.
;// 
;//    Rev 1.3   22 Mar 1996 15:43:30   AGUPTA2
;// Fixed fastcall bug: return from rtns with more than 2 params.
;// 
;//    Rev 1.2   14 Mar 1996 17:15:14   AGUPTA2
;// 
;// Included Bob's MMX_ClipAndMove rtn.  This rtn works on INTRA output.
;// 
;//    Rev 1.1   27 Feb 1996 16:48:52   RMCKENZX
;// Added rounding of IDCT output.
; 
;--------------------------------------------------------------------------

;==========================================================================
;
;  d3mbkadd.asm
;
;  Routines:
;    MMX_BlockAdd
;    MMX_ClipAndMove
;
;  Prototypes in d3mblk.h:
;		extern "C" {
;			void __fastcall MMX_BlockAdd(
;				U32 uResidual,   // pointer to IDCT output
;				U32 uRefBlock,   // pointer to predicted values
;				U32 uDstBlock);  // pointer to destination
;
;			void __fastcall MMX_ClipAndMove(
;				U32 uResidual,   // pointer to IDCT output
;				U32 uDstBlock,   // pointer to destination
;               U32 ScaledDC);   // scaled DC
;		}
;
;==========================================================================


;--------------------------------------------------------------------------
;
;  MMX_BlockAdd
;
;  Description:
;    This routine performs block addition of the IDCT output with the
;    predicted value to find the final value.  The IDCT values are converted
;    to integers then added to the prediction.  The result of the addition is 
;    then clipped to 0...255. The routine is called with the __fastcall option,
;    with the first two parameters in ecx and edx and the third on the stack.
;
;    The routine clears the IDCT output after reading it.    
;  Parameters:
;    ecx = uSrc1 pointer to IDCT output.  Values are signed, 16 bit values with
;          6 fractional bits.  They are not clipped to -256 ... +255.
;          They are packed into a qword aligned 8x8 array of dwords.
;
;    edx = uSrc2 pointer to prediction values.  Vaules are unsigned, 8-bit 
;          values. They are packed into a (possibly unaligned) 8x8 array of 
;          bytes.
;    esp+4 = uDst pointer to output values.  Values will be unsigned, 8-bit 
;            values.  They will be written into a qword aligned 8x8 array 
;            of bytes with a PITCH of 384 in between rows. 
;
;--------------------------------------------------------------------------

.586
.MODEL FLAT
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS


MMXDATA1 SEGMENT
ALIGN 8
MMX_Round32 DWORD 000200020H, 000200020H
MMXDATA1 ENDS

MMXCODE1 SEGMENT

ALIGN 4
@MMX_BlockAdd@12 PROC 
;  Parameters
pSrc1       EQU      ecx      
pSrc2       EQU      edx
pDst        EQU      eax
PITCH       EQU      384


  ;
  ;	This loop is 2-folded and fully unrolled.  2-folded means that
  ;	it works on 2 results per "pass" (8-pixel line).  Fully unrolled means that
  ;	it doesn't really loop at all -- all 8 "passes" are placed
  ;	in succession.
  ;
  ;	The result which each instruction is working on is identified
  ;	by a number as the first item in the comment field.
  ;
  movq       mm6, [MMX_Round32]              ; rounding for IDC output
   ;
  movq       mm3, [ecx+8]                    ; 1 - last 4 words of In1
   pxor      mm7, mm7                        ; zero for PUNPCK and clearing.
  movq       mm1, [ecx]                      ; 1 - first 4 words of In1
   ;
  movq       [ecx+8], mm7                    ; 1 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 1 - add in rounding
  movq       [ecx], mm7                      ; 1 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 1 - add in rounding
  mov        eax, [esp+4]                    ; destination pointer
   psraw     mm3, 6                          ; 1 - convert to int
  movq       mm2, [edx]                      ; 1 - 8 bytes of In2
   psraw     mm1, 6                          ; 1 - convert to int
  ; pass 1
  movq       mm0, mm2                        ; 1 - second copy of In2
   punpckhbw mm2, mm7                        ; 1 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 1 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 1 - first 4 bytes of In2
  movq       mm3, [ecx+24]                   ; 2 - last 4 words of In1
   paddw     mm0, mm1                        ; 1 - sum first 4 bytes
  movq       mm1, [ecx+16]                   ; 2 - first 4 words of In1
   packuswb  mm0, mm2                        ; 1 - combine & clip sum
  movq       [ecx+24], mm7                   ; 2 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 2 - add in rounding
  movq       [ecx+16], mm7                   ; 2 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 2 - add in rounding
  movq       mm2, [edx+PITCH]                ; 2 - 8 bytes of In2   
   psraw     mm3, 6                          ; 2 - convert to int
  movq       [eax], mm0                      ; 1 - store result
   psraw     mm1, 6                          ; 2 - convert to int
  ; pass 2
  movq       mm0, mm2                        ; 2 - second copy of In2
   punpckhbw mm2, mm7                        ; 2 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 2 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 2 - first 4 bytes of In2
  movq       mm3, [ecx+40]                   ; 3 - last 4 words of In1
   paddw     mm0, mm1                        ; 2 - sum first 4 bytes
  movq       mm1, [ecx+32]                   ; 3 - first 4 words of In1
   packuswb  mm0, mm2                        ; 2 - combine & clip sum
  movq       [ecx+40], mm7                   ; 3 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 3 - add in rounding
  movq       [ecx+32], mm7                   ; 3 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 3 - add in rounding
  movq       mm2, [edx+2*PITCH]              ; 3 - 8 bytes of In2
   psraw     mm3, 6                          ; 3 - convert to int
  movq       [eax+PITCH], mm0                ; 2 - store result
   psraw     mm1, 6                          ; 3 - convert to int
  ; pass 3
  movq       mm0, mm2                        ; 3 - second copy of In2
   punpckhbw mm2, mm7                        ; 3 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 3 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 3 - first 4 bytes of In2
  movq       mm3, [ecx+56]                   ; 4 - last 4 words of In1
   paddw     mm0, mm1                        ; 3 - sum first 4 bytes
  movq       mm1, [ecx+48]                   ; 4 - first 4 words of In1
   packuswb  mm0, mm2                        ; 3 - combine & clip sum
  movq       [ecx+56], mm7                   ; 4 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 4 - add in rounding
  movq       [ecx+48], mm7                   ; 4 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 4 - add in rounding
  movq       mm2, [edx+3*PITCH]              ; 4 - 8 bytes of In2   
   psraw     mm3, 6                          ; 4 - convert to int
  movq       [eax+2*PITCH], mm0              ; 3 - store result
   psraw     mm1, 6                          ; 4 - convert to int
  ; pass 4
  movq       mm0, mm2                        ; 4 - second copy of In2
   punpckhbw mm2, mm7                        ; 4 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 4 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 4 - first 4 bytes of In2
  movq       mm3, [ecx+72]                   ; 5 - last 4 words of In1
   paddw     mm0, mm1                        ; 4 - sum first 4 bytes
  movq       mm1, [ecx+64]                   ; 5 - first 4 words of In1
   packuswb  mm0, mm2                        ; 4 - combine & clip sum
  movq       [ecx+72], mm7                   ; 5 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 5 - add in rounding
  movq       [ecx+64], mm7                   ; 5 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 5 - add in rounding
  movq       mm2, [edx+4*PITCH]              ; 5 - 8 bytes of In2   
   psraw     mm3, 6                          ; 5 - convert to int
  movq       [eax+3*PITCH], mm0              ; 4 - store result
   psraw     mm1, 6                          ; 5 - convert to int
  ; pass 5
  movq       mm0, mm2                        ; 5 - second copy of In2
   punpckhbw mm2, mm7                        ; 5 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 5 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 5 - first 4 bytes of In2
  movq       mm3, [ecx+88]                   ; 6 - last 4 words of In1
   paddw     mm0, mm1                        ; 5 - sum first 4 bytes
  movq       mm1, [ecx+80]                   ; 6 - first 4 words of In1
   packuswb  mm0, mm2                        ; 5 - combine & clip sum
  movq       [ecx+88], mm7                   ; 6 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 6 - add in rounding
  movq       [ecx+80], mm7                   ; 6 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 6 - add in rounding
  movq       mm2, [edx+5*PITCH]              ; 6 - 8 bytes of In2   
   psraw     mm3, 6                          ; 6 - convert to int
  movq       [eax+4*PITCH], mm0              ; 5 - store result
   psraw     mm1, 6                          ; 6 - convert to int
  ; pass 6
  movq       mm0, mm2                        ; 6 - second copy of In2
   punpckhbw mm2, mm7                        ; 6 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 6 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 6 - first 4 bytes of In2
  movq       mm3, [ecx+104]                  ; 7 - last 4 words of In1
   paddw     mm0, mm1                        ; 6 - sum first 4 bytes
  movq       mm1, [ecx+96]                   ; 7 - first 4 words of In1
   packuswb  mm0, mm2                        ; 6 - combine & clip sum
  movq       [ecx+104], mm7                  ; 7 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 7 - add in rounding
  movq       [ecx+96], mm7                   ; 7 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 7 - add in rounding
  movq       mm2, [edx+6*PITCH]              ; 7 - 8 bytes of In2   
   psraw     mm3, 6                          ; 7 - convert to int
  movq       [eax+5*PITCH], mm0              ; 6 - store result
   psraw     mm1, 6                          ; 7 - convert to int
  ; pass 7
  movq       mm0, mm2                        ; 7 - second copy of In2
   punpckhbw mm2, mm7                        ; 7 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 7 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 7 - first 4 bytes of In2
  movq       mm3, [ecx+120]                  ; 8 - last 4 words of In1
   paddw     mm0, mm1                        ; 7 - sum first 4 bytes
  movq       mm1, [ecx+112]                  ; 8 - first 4 words of In1
   packuswb  mm0, mm2                        ; 7 - combine & clip sum
  movq       [ecx+120], mm7                  ; 8 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 8 - add in rounding
  movq       [ecx+112], mm7                  ; 8 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 8 - add in rounding
  movq       mm2, [edx+7*PITCH]              ; 8 - 8 bytes of In2   
   psraw     mm3, 6                          ; 8 - convert to int
  movq       [eax+6*PITCH], mm0              ; 7 - store result
   psraw     mm1, 6                          ; 8 - convert to int
  ;
  ; pass 8
  ; wrap up
  ;
  movq       mm0, mm2                        ; 8 - second copy of In2
   punpckhbw mm2, mm7                        ; 8 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 8 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 8 - first 4 bytes of In2
  paddw      mm0, mm1                        ; 8 - sum first 4 bytes
   ;
  packuswb   mm0, mm2                        ; 8 - combine & clip sum
   ;
  movq       [eax+7*PITCH], mm0              ; 8 - store result
   ret       4

@MMX_BlockAdd@12 ENDP

IFDEF H261
ALIGN 4
@MMX_BlockAddSpecial@12 PROC 
;  Parameters
pSrc1       EQU      ecx      
pSrc2       EQU      edx
pDst        EQU      eax
PITCH       EQU      384


  ;
  ;	This loop is 2-folded and fully unrolled.  2-folded means that
  ;	it works on 2 results per "pass" (8-pixel line).  Fully unrolled means that
  ;	it doesn't really loop at all -- all 8 "passes" are placed
  ;	in succession.
  ;
  ;	The result which each instruction is working on is identified
  ;	by a number as the first item in the comment field.
  ;
  movq       mm6, [MMX_Round32]              ; rounding for IDC output
   ;
  movq       mm3, [ecx+8]                    ; 1 - last 4 words of In1
   pxor      mm7, mm7                        ; zero for PUNPCK and clearing.
  movq       mm1, [ecx]                      ; 1 - first 4 words of In1
   ;
  movq       [ecx+8], mm7                    ; 1 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 1 - add in rounding
  movq       [ecx], mm7                      ; 1 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 1 - add in rounding
  mov        eax, [esp+4]                    ; destination pointer
   psraw     mm3, 6                          ; 1 - convert to int
  movq       mm2, [edx]                      ; 1 - 8 bytes of In2
   psraw     mm1, 6                          ; 1 - convert to int
  ; pass 1
  movq       mm0, mm2                        ; 1 - second copy of In2
   punpckhbw mm2, mm7                        ; 1 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 1 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 1 - first 4 bytes of In2
  movq       mm3, [ecx+24]                   ; 2 - last 4 words of In1
   paddw     mm0, mm1                        ; 1 - sum first 4 bytes
  movq       mm1, [ecx+16]                   ; 2 - first 4 words of In1
   packuswb  mm0, mm2                        ; 1 - combine & clip sum
  movq       [ecx+24], mm7                   ; 2 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 2 - add in rounding
  movq       [ecx+16], mm7                   ; 2 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 2 - add in rounding
  movq       mm2, [edx+8]                ; 2 - 8 bytes of In2   
   psraw     mm3, 6                          ; 2 - convert to int
  movq       [eax], mm0                      ; 1 - store result
   psraw     mm1, 6                          ; 2 - convert to int
  ; pass 2
  movq       mm0, mm2                        ; 2 - second copy of In2
   punpckhbw mm2, mm7                        ; 2 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 2 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 2 - first 4 bytes of In2
  movq       mm3, [ecx+40]                   ; 3 - last 4 words of In1
   paddw     mm0, mm1                        ; 2 - sum first 4 bytes
  movq       mm1, [ecx+32]                   ; 3 - first 4 words of In1
   packuswb  mm0, mm2                        ; 2 - combine & clip sum
  movq       [ecx+40], mm7                   ; 3 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 3 - add in rounding
  movq       [ecx+32], mm7                   ; 3 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 3 - add in rounding
  movq       mm2, [edx+2*8]              ; 3 - 8 bytes of In2
   psraw     mm3, 6                          ; 3 - convert to int
  movq       [eax+PITCH], mm0                ; 2 - store result
   psraw     mm1, 6                          ; 3 - convert to int
  ; pass 3
  movq       mm0, mm2                        ; 3 - second copy of In2
   punpckhbw mm2, mm7                        ; 3 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 3 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 3 - first 4 bytes of In2
  movq       mm3, [ecx+56]                   ; 4 - last 4 words of In1
   paddw     mm0, mm1                        ; 3 - sum first 4 bytes
  movq       mm1, [ecx+48]                   ; 4 - first 4 words of In1
   packuswb  mm0, mm2                        ; 3 - combine & clip sum
  movq       [ecx+56], mm7                   ; 4 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 4 - add in rounding
  movq       [ecx+48], mm7                   ; 4 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 4 - add in rounding
  movq       mm2, [edx+3*8]              ; 4 - 8 bytes of In2   
   psraw     mm3, 6                          ; 4 - convert to int
  movq       [eax+2*PITCH], mm0              ; 3 - store result
   psraw     mm1, 6                          ; 4 - convert to int
  ; pass 4
  movq       mm0, mm2                        ; 4 - second copy of In2
   punpckhbw mm2, mm7                        ; 4 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 4 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 4 - first 4 bytes of In2
  movq       mm3, [ecx+72]                   ; 5 - last 4 words of In1
   paddw     mm0, mm1                        ; 4 - sum first 4 bytes
  movq       mm1, [ecx+64]                   ; 5 - first 4 words of In1
   packuswb  mm0, mm2                        ; 4 - combine & clip sum
  movq       [ecx+72], mm7                   ; 5 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 5 - add in rounding
  movq       [ecx+64], mm7                   ; 5 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 5 - add in rounding
  movq       mm2, [edx+4*8]              ; 5 - 8 bytes of In2   
   psraw     mm3, 6                          ; 5 - convert to int
  movq       [eax+3*PITCH], mm0              ; 4 - store result
   psraw     mm1, 6                          ; 5 - convert to int
  ; pass 5
  movq       mm0, mm2                        ; 5 - second copy of In2
   punpckhbw mm2, mm7                        ; 5 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 5 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 5 - first 4 bytes of In2
  movq       mm3, [ecx+88]                   ; 6 - last 4 words of In1
   paddw     mm0, mm1                        ; 5 - sum first 4 bytes
  movq       mm1, [ecx+80]                   ; 6 - first 4 words of In1
   packuswb  mm0, mm2                        ; 5 - combine & clip sum
  movq       [ecx+88], mm7                   ; 6 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 6 - add in rounding
  movq       [ecx+80], mm7                   ; 6 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 6 - add in rounding
  movq       mm2, [edx+5*8]              ; 6 - 8 bytes of In2   
   psraw     mm3, 6                          ; 6 - convert to int
  movq       [eax+4*PITCH], mm0              ; 5 - store result
   psraw     mm1, 6                          ; 6 - convert to int
  ; pass 6
  movq       mm0, mm2                        ; 6 - second copy of In2
   punpckhbw mm2, mm7                        ; 6 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 6 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 6 - first 4 bytes of In2
  movq       mm3, [ecx+104]                  ; 7 - last 4 words of In1
   paddw     mm0, mm1                        ; 6 - sum first 4 bytes
  movq       mm1, [ecx+96]                   ; 7 - first 4 words of In1
   packuswb  mm0, mm2                        ; 6 - combine & clip sum
  movq       [ecx+104], mm7                  ; 7 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 7 - add in rounding
  movq       [ecx+96], mm7                   ; 7 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 7 - add in rounding
  movq       mm2, [edx+6*8]              ; 7 - 8 bytes of In2   
   psraw     mm3, 6                          ; 7 - convert to int
  movq       [eax+5*PITCH], mm0              ; 6 - store result
   psraw     mm1, 6                          ; 7 - convert to int
  ; pass 7
  movq       mm0, mm2                        ; 7 - second copy of In2
   punpckhbw mm2, mm7                        ; 7 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 7 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 7 - first 4 bytes of In2
  movq       mm3, [ecx+120]                  ; 8 - last 4 words of In1
   paddw     mm0, mm1                        ; 7 - sum first 4 bytes
  movq       mm1, [ecx+112]                  ; 8 - first 4 words of In1
   packuswb  mm0, mm2                        ; 7 - combine & clip sum
  movq       [ecx+120], mm7                  ; 8 - zero last 4 words of In1
   paddw     mm3, mm6                        ; 8 - add in rounding
  movq       [ecx+112], mm7                  ; 8 - zero first 4 words of In1
   paddw     mm1, mm6                        ; 8 - add in rounding
  movq       mm2, [edx+7*8]              ; 8 - 8 bytes of In2   
   psraw     mm3, 6                          ; 8 - convert to int
  movq       [eax+6*PITCH], mm0              ; 7 - store result
   psraw     mm1, 6                          ; 8 - convert to int
  ;
  ; pass 8
  ; wrap up
  ;
  movq       mm0, mm2                        ; 8 - second copy of In2
   punpckhbw mm2, mm7                        ; 8 - last 4 bytes of In2
  paddw      mm2, mm3                        ; 8 - sum last 4 bytes
   punpcklbw mm0, mm7                        ; 8 - first 4 bytes of In2
  paddw      mm0, mm1                        ; 8 - sum first 4 bytes
   ;
  packuswb   mm0, mm2                        ; 8 - combine & clip sum
   ;
  movq       [eax+7*PITCH], mm0              ; 8 - store result
   ret       4

@MMX_BlockAddSpecial@12 ENDP
ENDIF

;----------------------------------------------------------------------------
;
;  MMX_ClipAndMove
;
;  Description:
;   This routine takes the MMx IDCT output, converts (with round)
;   to integer, and clips to 0...255.  Routine is called with the
;   __fastcall option, with the two parameters in ecx and edx.
;
;   The routine clears the IDCT output after reading it.    
;
;  	MMx version.
;
;  Parameters:
;    ecx = uSrc1 pointer to IDCT output.  Values are signed, 16 bit values  
;               with 6 fractional bits.  They are not clipped to -256 ...
;               +255.  They are packed into a qword aligned 8x8 array
;               of words.     
;
;    edx = uDst pointer to output values.  Values will be unsigned, 8-bit 
;               values.  They will be written into a qword aligned 8x8 array 
;               of bytes with a PITCH of 384 in between rows. 
;    esp + 4 =  Scaled DC value with 7 fraction bits
;----------------------------------------------------------------------------
ALIGN 4
@MMX_ClipAndMove@12 PROC
;  Parameters
pSrc1     EQU      ecx      
pDst      EQU      edx
ScaledDC  EQU      DWORD PTR [esp + 4]
;
; preamble
;
  movd       mm0, ScaledDC                   ; Scaled DC value 
   pxor      mm6, mm6                        ; zero
  movq       mm1, mm0
   psllq     mm0, 16
  movq       mm2, [ecx]                      ; 3:  fetch first 4 words
   por       mm0, mm1			             ; lower 2 WORDS have ScaledDC
  movq       mm7, mm0
   psllq     mm0, 32
  por        mm7, mm0			             ; all 4 WORDS have ScaledDC
   mov       eax, 3                          ; loop control
  movq       mm3, [ecx+8]                    ; 3:  fetch last 4 words
   psrlw     mm7, 1			                 ; DC with 6 bits of fraction
  paddw      mm7, [MMX_Round32]              ; rounding+DC for IDCT output
   ; 
  movq       [ecx], mm6                      ; 3:  zero first 4 words
   paddw     mm2, mm7                        ; 3:  add in round
  movq       [ecx+8], mm6                    ; 3:  zero first 4 words
   paddw     mm3, mm7                        ; 3:  add in round
  psraw      mm2, 6                          ; 3:  convert to integer
   ; 
  ;
  ;  main loop:
  ;	This loop is 3-folded and 2-unrolled.  3-folded means that it
  ;	works on 3 different results per iteration.  2-unrolled that
  ;	it produces 2 results per iteration.
  ;
  ;	The result which each instruction works on is identified by a 
  ;	number (1:, 2:, or 3:) at the start of the comment field.  These
  ;	identify 3 stages as follows:
  ;
  ;	Stage	Description
  ;	-----	-----------
  ;	1		Convert the last 4 words of a line to integer, pack together
  ;			into 8 bytes, and write the result. 
  ;	2		Do all processing for the next line:  load and clear 8 words, 
  ;			add in round, convert to integer, pack to bytes, and write
  ;			the result. 
  ;	3		Load and zero all 8 words of a line, add in round,
  ;			and convert the first 4 of them to integers.  (Processing
  ;			of this stage is completed as stage 1 of the next pass.)
  ;
MainLoop:
  movq       mm0, [ecx+16]                   ; 2:  fetch first 4 words
   psraw     mm3, 6                          ; 1:  convert to integer
  movq       mm1, [ecx+24]                   ; 2:  fetch last 4 words
   packuswb  mm2, mm3                        ; 1:  pack and clip
  movq       [ecx+16], mm6                   ; 2:  zero first 4 words
   paddw     mm0, mm7                        ; 2:  add in round
  movq       [ecx+24], mm6                   ; 2:  zero last 4 words
   paddw     mm1, mm7                        ; 2:  add in round
  movq       [edx], mm2                      ; 1:  store result
   psraw     mm0, 6                          ; 2:  convert to integer
  movq       mm2, [ecx+32]                   ; 3:  fetch first 4 words
   psraw     mm1, 6                          ; 2:  convert to integer
  movq       mm3, [ecx+40]                   ; 3:  fetch last 4 words
   packuswb  mm0, mm1                        ; 2:  pack and clip
  movq       [ecx+32], mm6                   ; 2:  zero first 4 words
   paddw     mm2, mm7                        ; 3:  add in round
  movq       [ecx+40], mm6                   ; 2:  zero first 4 words
   paddw     mm3, mm7                        ; 3:  add in round
  movq       [edx+PITCH], mm0                ; 2:  store result
   psraw     mm2, 6                          ; 3:  convert to integer
  add        ecx, 32                         ; increment source pointer
   add       edx, 2*PITCH                    ; increment destination pointer
  dec        eax                             ; decrement loop control
   jne       MainLoop                        ; repeat three times
  ;
  ;  postamble
  ;
  movq       mm0, [ecx+16]                   ; 2:  fetch first 4 words
   psraw     mm3, 6                          ; 1:  convert to integer
  movq       mm1, [ecx+24]                   ; 2:  fetch last 4 words
   packuswb  mm2, mm3                        ; 1:  pack and clip
  paddw      mm0, mm7                        ; 2:  add in round
   paddw     mm1, mm7                        ; 2:  add in round
  movq       [edx], mm2                      ; 1:  store result
   psraw     mm0, 6                          ; 2:  convert to integer
  movq       [ecx+16], mm6                   ; 2:  zero first 4 words
   psraw     mm1, 6                          ; 2:  convert to integer
  movq       [ecx+24], mm6                   ; 2:  zero last 4 words
   packuswb  mm0, mm1                        ; 2:  pack and clip
  movq       [edx+PITCH], mm0                ; 2:  store result
   ret       4

@MMX_ClipAndMove@12 ENDP

;----------------------------------------------------------------------------
;
;  MMX_BlockCopy
;    Copy in chunks of 4 as suggested in MMX guide.  (
;  Parameters:
;    ecx = Pointer to output values
;
;    edx = Pointer to input values
;----------------------------------------------------------------------------
ALIGN 4
@MMX_BlockCopy@8 PROC
;  Parameters
pDst      EQU      ecx      
pSrc      EQU      edx
  movq       mm0, [pSrc]
   ;
  movq       mm1, [pSrc + PITCH]
   ;
  movq       mm2, [pSrc + PITCH*2]
   ;
  movq       mm3, [pSrc + PITCH*3]
   ;
  movq       [pDst], mm0
   ;
  movq       [pDst + PITCH], mm1
   ;
  movq       [pDst + PITCH*2], mm2
   ;
  movq       [pDst + PITCH*3], mm3
   ;
  movq       mm4, [pSrc + PITCH*4]
   ;
  movq       mm5, [pSrc + PITCH*5]
   ;
  movq       mm6, [pSrc + PITCH*6]
   ;
  movq       mm7, [pSrc + PITCH*7]
   ;
  movq       [pDst + PITCH*4], mm4
   ;
  movq       [pDst + PITCH*5], mm5
   ;
  movq       [pDst + PITCH*6], mm6
   ;
  movq       [pDst + PITCH*7], mm7
   ;
  ret
@MMX_BlockCopy@8 ENDP

IFDEF H261
;----------------------------------------------------------------------------
;
;  MMX_BlockCopySpecial
;    Copy in chunks of 4 as suggested in MMX guide.  (
;  Parameters:
;    ecx = Pointer to output values
;
;    edx = Pointer to input values
;----------------------------------------------------------------------------
ALIGN 4
@MMX_BlockCopySpecial@8 PROC
;  Parameters
pDst      EQU      ecx      
pSrc      EQU      edx
PITCH8    EQU      8

  movq       mm0, [pSrc]
   ;
  movq       mm1, [pSrc + PITCH8]
   ;
  movq       mm2, [pSrc + PITCH8*2]
   ;
  movq       mm3, [pSrc + PITCH8*3]
   ;
  movq       [pDst], mm0
   ;
  movq       [pDst + PITCH], mm1
   ;
  movq       [pDst + PITCH*2], mm2
   ;
  movq       [pDst + PITCH*3], mm3
   ;
  movq       mm4, [pSrc + PITCH8*4]
   ;
  movq       mm5, [pSrc + PITCH8*5]
   ;
  movq       mm6, [pSrc + PITCH8*6]
   ;
  movq       mm7, [pSrc + PITCH8*7]
   ;
  movq       [pDst + PITCH*4], mm4
   ;
  movq       [pDst + PITCH*5], mm5
   ;
  movq       [pDst + PITCH*6], mm6
   ;
  movq       [pDst + PITCH*7], mm7
   ;
  ret
@MMX_BlockCopySpecial@8 ENDP
ENDIF


MMXCODE1 ENDS
   
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dx5cnvy.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/

;* -------------------------------------------------------------------------
;* PVCS Source control information:
;*
;*  $Header:   S:\h26x\src\dec\dx5cnvy.asv   1.1   29 Aug 1995 16:50:02   DBRUCKS  $
;*
;*  $Log:   S:\h26x\src\dec\dx5cnvy.asv  $
;// 
;//    Rev 1.1   29 Aug 1995 16:50:02   DBRUCKS
;// add in and out pitch parameters
;// 
;//    Rev 1.0   23 Aug 1995 12:20:32   DBRUCKS
;// Initial revision.
;*  
;*  NOTE:
;*         The starting source for this routine came for the PVCS database 
;*         for the H.261 decoder.  cc12to7.asm version 1.6.  This is a 
;*         working 16-bit version.
;* -------------------------------------------------------------------------

;////////////////////////////////////////////////////////////////////////////
;  Convert_Y_8to7_Bit -- This function converts the Y data from 8 bits to 7 bits
;                        and moves the data into the format the MRV color
;                        convertors want.
;
;                        Input to this function is either YVU12 from the decoder,
;                        or YVU9 for looking glass.
;
; NOTES:
;   Routine uses 4 DWORDs on stack for local variables
;   The 16-bit code is not up to date.
;
; ASSUMPTIONS/LIMITATIONS:
;   -- YPitchOut >= XResolution
;   -- YPitch    >= XResolution
;
;-------------------------------------------------------------------------------

ifndef WIN32
.MODEL SMALL
endif

.486

ifdef WIN32
.MODEL FLAT
.DATA

else ;; WIN16
_DATA	SEGMENT PUBLIC 'DATA'
endif


;;	Lookup Table for 8->7 bit conversion and clamping.
tbl8to7	BYTE      8,  8,  8,  8,  8,  8,  8,  8
        BYTE      8,  8,  8,  8,  8,  8,  8,  8  
        BYTE      8,  8,  9,  9, 10, 10, 11, 11
        BYTE     12, 12, 13, 13, 14, 14, 15, 15
        BYTE     16, 16, 17, 17, 18, 18, 19, 19
        BYTE     20, 20, 21, 21, 22, 22, 23, 23
        BYTE     24, 24, 25, 25, 26, 26, 27, 27
        BYTE     28, 28, 29, 29, 30, 30, 31, 31
        BYTE     32, 32, 33, 33, 34, 34, 35, 35
        BYTE     36, 36, 37, 37, 38, 38, 39, 39
        BYTE     40, 40, 41, 41, 42, 42, 43, 43 
        BYTE     44, 44, 45, 45, 46, 46, 47, 47
        BYTE     48, 48, 49, 49, 50, 50, 51, 51
        BYTE     52, 52, 53, 53, 54, 54, 55, 55
        BYTE     56, 56, 57, 57, 58, 58, 59, 59
        BYTE     60, 60, 61, 61, 62, 62, 63, 63
        BYTE     64, 64, 65, 65, 66, 66, 67, 67
        BYTE     68, 68, 69, 69, 70, 70, 71, 71
        BYTE     72, 72, 73, 73, 74, 74, 75, 75
        BYTE     76, 76, 77, 77, 78, 78, 79, 79
        BYTE     80, 80, 81, 81, 82, 82, 83, 83
        BYTE     84, 84, 85, 85, 86, 86, 87, 87
        BYTE     88, 88, 89, 89, 90, 90, 91, 91
        BYTE     92, 92, 93, 93, 94, 94, 95, 95
        BYTE     96, 96, 97, 97, 98, 98, 99, 99
        BYTE    100,100,101,101,102,102,103,103
        BYTE    104,104,105,105,106,106,107,107
        BYTE    108,108,109,109,110,110,111,111
        BYTE    112,112,113,113,114,114,115,115
        BYTE    116,116,117,117,118,118,119,119
        BYTE    120,120,120,120,120,120,120,120
        BYTE    120,120,120,120,120,120,120,120

_DATA	ENDS

ifdef WIN32
.CODE
assume cs : flat
assume ds : flat
assume es : flat
assume fs : flat
assume gs : flat
assume ss : flat

else
_TEXT32 SEGMENT PUBLIC READONLY USE32 'CODE'
ASSUME	DS:_DATA
ASSUME	CS:_TEXT32
ASSUME	ES:nothing
ASSUME	FS:nothing
ASSUME	GS:nothing
endif

;32-bit version of call
;C function prototype
;
;long Convert_Y_8to7_Bit(HPBYTE      pYPlaneInput,  /* ptr Y plane */
;			             DWORD       YResolution,   /* Y plane height */
;			             DWORD       XResolution,   /* Y plane width */
;			             DWORD		 YInPitch,      /* Y input pitch */
;			             HPBYTE      pYPlaneOutput, /* pYOut */
;                        DWORD       YOutPitch      /* Y output pitch */
;			            )
;
;16-bit version of call
;C function prototype  -- not up to date
;
;long Convert_Y_8to7_Bit(HPBYTE      pYPlaneInput,  /*ptr Y plane*/
;			WORD        YResolution,   /*Y plane height*/
;			WORD        XResolution,   /*Y plane width*/
;			HPBYTE      pYPlaneOutput, /*pYOut*/
;			WORD        YPitchOut      /*Pitch of Y plane Out*/
;			)

PUBLIC _Convert_Y_8to7_Bit

ifdef WIN32
_Convert_Y_8to7_Bit proc
;   parmD    pYPlaneIn        ;ptr to Y input plane
;   parmD    YRes             ;Y plane height
;   parmD    XRes             ;Y plane width
;   parmD    YInPitch         ;Y input pitch
;   parmD    pYPlaneOut       ;ptr to Y output plane
;   parmD    YOutPitch        ;ptr to Y output pitch
else
_Convert_Y_8to7_Bit proc far
;   parmD    pYPlaneIn        ;ptr to Y input plane
;   parmW    YRes             ;Y plane height
;   parmW    XRes             ;Y plane width
;   parmD    pYPlaneOut       ;ptr to Y output plane
;   parmW    YPitchOut        ;Pitch of Y plane output

endif

;set up equates
ifdef WIN32
pYPlaneIn   EQU  DWORD PTR[ebp+8]
YRes        EQU  DWORD PTR[ebp+12]
XRes        EQU  DWORD PTR[ebp+16]
YInPitch    EQU  DWORD PTR[ebp+20]
pYPlaneOut  EQU  DWORD PTR[ebp+24]
YOutPitch   EQU  DWORD PTR[ebp+28]
else
pYPlaneIn   EQU  DWORD PTR[ebp+8]
YRes        EQU  WORD  PTR[ebp+12]
XRes        EQU  WORD  PTR[ebp+14]
pYPlaneOut  EQU  DWORD PTR[ebp+16]
YPitchOut   EQU  WORD  PTR[ebp+20]
endif

;; stack usage
; previous ebp at ebp 
; previous edi at ebp - 4
; previous esi at ebp - 8
; lXResDiv4    at ebp -12
; YInDiff      at ebp -16
; YOutDiff     at ebp -20
; outloopcnt   at ebp -24
; inloopcnt    at ebp -28

lXResDiv4    EQU  DWORD PTR[ebp-12]
YInDiff      EQU  DWORD PTR[ebp-16]
YOutDiff	 EQU  DWORD PTR[ebp-20]
outloopcnt   EQU  DWORD PTR[ebp-24]
inloopcnt    EQU  DWORD PTR[ebp-28]

    xor   ax,ax           ; These two instructions give definitive proof we are
    mov   eax,0CCCCCCCCH  ; in a 32-bit code segment.  INT 3 occurs if not.

;get params
    push    ebp

ifdef WIN32

      mov   ebp, esp
else
	movzx  	ebp, sp	   
endif
	push    edi
	  push  esi

ifdef WIN32
; zero out registers

else
; zero out registers
   	xor     esi, esi
      xor	edi, edi
endif

; move variables to local space on stack
ifdef WIN32
    mov     eax, XRes
      mov   ecx, YInPitch
    mov     edx, YOutPitch    
else
	movzx	eax, XRes
	movzx	ecx, YPitchOut
endif
	  sub   ecx, eax       ; YInDiff = YInPitch - XRes
	sub     edx, eax       ; YOutDiff = YOutPitch - XRes
	shr     eax, 2
	push	eax            ; store lXResDiv4 == XRes/4 on stack
	  push	ecx            ; store YInDiff on stack
	push    edx            ; store YOutDiff on stack

; push stack with 0 2 additional times to make room for other locals
	xor     edx, edx
	  push  edx            ; outloopcnt
	push    edx            ; inloopcnt

; ********************
; Copy Y Plane from soure to dest and convert to 7 bits
; ********************
; Description of YPlane processing:
;   - Double nested loop with 
;     Outlp1 executed YRes lines 
;       Collp1 loops for number of columns/4
;         - Read 4 inputs in one DWORD
;         - Convert each value from 8-bit to 7-bit
;         - Store 4 output in one DWORD
;
; Register usage
;  eax	holds 4 output value 8 bits each
;  ebx	holds 4 source value and index into tbl8to7
;  ecx	index into tbl8to7
;  edx	index into tbl8to7
;  esi	src address
;  edi	des address
;  ebp	stack pointer stuff
;
; if 16-bit
;  es	input plane segment
;  fs	output plane segment
;  ds	table segment
; endif
;
; local variables
;  outloopcnt
;  inloopcnt
;  lXResDiv4
;  YInDiff
;  YOutDiff
;
ifdef WIN32
    mov     esi, pYPlaneIn  ; Initialize input cursor
      mov   edi, pYPlaneOut ; Initialize output cursor
    mov     ebx, YRes		; get YResolution
    sub     edi, YOutDiff	; Pre-adjust for add in loop of
							;   difference between YPitchOut and
							;   XRes
	sub		esi, YInDiff
else
	les	si,  pYPlaneIn		; Initialize input cursor
	lfs	di,  pYPlaneOut		; Initialize output cursor
	sub	edi, YOutDiff		; Pre-adjust for add in loop of
							;   difference between YPitchOut and
							;   XRes
	sub esi, YInDiff
	movzx	ebx, YRes		; get YResolution
endif

Outlp:
    mov	    edx, lXResDiv4	; edx = number of columns/4
      mov	outloopcnt, ebx	; initialize/store updated outloopcnt
    add     edi, YOutDiff	; adjust for difference
      mov   inloopcnt, edx	; set inner loop count
	add		esi, YInDiff	; adjust for difference

; Preamble
ifdef WIN32
    mov     ebx, [esi]		; Fetch source, 4 at a time
      nop
	mov	    ecx, ebx		; Move source to temp
      nop
else
  	mov	    ebx, es:[esi]	; Fetch source, 4 at a time
	mov	    ecx,ebx			; Move source to temp
endif
    shr	    ecx,24			; shift to get 4th address
      mov   edx,ebx			; Move source to temp
    shr     edx,16			; Shift to get 3rd address
      add   esi,4			; increment source to next 4
    mov     ah, tbl8to7[ecx]; convert 4th element to 7 bits
      and   edx,0000000ffh	; and off 3rd element
    mov     ecx,ebx			; Move source to temp
      add   edi,4			; incrment to next destination
    shr     ecx,8			; Shift to get 2nd address
      and   ebx,0000000ffh	; and off 1st element
    and     ecx,0000000ffh	; And off 2nd element
      mov   al, tbl8to7[edx]; convert 3rd element to 7 bits
    shl     eax,16			; Shift output up
      mov   edx, inloopcnt	; get inner loop count
    mov     al, tbl8to7[ebx]; convert 1st element to 7 bits
      dec   edx				; decrement inner loop counter
    mov     ah, tbl8to7[ecx]; convert 2nd element to 7 bits

Collp:
ifdef WIN32
  	mov  	ebx, [esi]		; Fetch source, 4 at a time
	  mov	inloopcnt, edx	; store updated inner loop count
	mov  	[edi-4],eax		; Store 4 converted values
else
  	mov  	ebx, es:[esi]	; Fetch source, 4 at a time
	  mov	inloopcnt, edx	; store updated inner loop count
	mov  	fs:[edi-4],eax	; Store 4 converted values
endif
       mov  ecx,ebx			; Move source to temp
    shr     ecx,24			; shift to get 4th address
      mov   edx,ebx			; Move source to temp
    shr     edx,16			; Shift to get 3rd address
      add   esi,4			; increment source to next 4
    mov     ah, tbl8to7[ecx]; convert 4th element to 7 bits
      and   edx,0000000ffh	; and off 3rd element
    mov     ecx,ebx			; Move source to temp
      add   edi,4			; incrment to next destination
    shr     ecx,8			; Shift to get 2nd address
      and   ebx,0000000ffh	; and off 1st element
    and     ecx,0000000ffh	; And off 2nd element
      mov   al, tbl8to7[edx]; convert 3rd element to 7 bits
    shl     eax,16			; Shift output up
      mov   edx, inloopcnt	; get inner loop count
    mov     al, tbl8to7[ebx]; convert 1st element to 7 bits
      dec   edx				; decrement inner loop counter
    mov     ah, tbl8to7[ecx]; convert 2nd element to 7 bits
      jg    Collp			; if not done loop

; Postscript
ifdef WIN32
    mov  	[edi-4],eax		; Store 4 converted values
else
    mov  	fs:[edi-4],eax	; Store 4 converted values
endif
      mov	ebx, outloopcnt	; get outer loop count
    dec	ebx					; decrement outer loop count
      jnz	Outlp			; if more to do loop

; clean out local variables on stack
    pop     ecx
      pop   eax
    pop     ecx
      pop   eax
	pop		ecx

;clear special seg registers, restore stack, pop saved registers
ifndef WIN32
    xor     ecx, ecx
    mov     es, cx
    mov     fs, cx
endif

    pop     esi
      pop   edi
    pop     ebp

ifdef WIN32
    ret
else
    db      066h
    retf
endif

_Convert_Y_8to7_Bit endp


END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\dxmidct.asm ===
;/* *************************************************************************
;**    INTEL Corporation Proprietary Information
;**
;**    This listing is supplied under the terms of a license
;**    agreement with INTEL Corporation and may not be copied
;**    nor disclosed except in accordance with the terms of
;**    that agreement.
;**
;**    Copyright (c) 1995 Intel Corporation.
;**    Copyright (c) 1996 Intel Corporation.
;**    All Rights Reserved.
;**
;** *************************************************************************
;*/
;/* *************************************************************************
;** $Header:   S:\h26x\src\dec\dxmidct.asv   1.5   09 Jul 1996 16:51:26   AGUPTA2  $
;** $Log:   S:\h26x\src\dec\dxmidct.asv  $
;// 
;//    Rev 1.5   09 Jul 1996 16:51:26   AGUPTA2
;// IDCT now expects actual number of coeffs.
;// 
;//    Rev 1.4   08 Jul 1996 11:42:50   AGUPTA2
;// Fixed the accuracy problem where a shift was in the wrong place.
;// 
;//    Rev 1.3   30 May 1996 12:25:02   AGUPTA2
;// Fixed the overflow problem in computing u0-u3 in first four columns.
;// 
;//    Rev 1.2   09 Apr 1996 09:42:08   agupta2
;// Code to clear IDCT buffer moved to MMX_BlockCopy and MMX_BlockMove.
;// 
;//    Rev 1.1   22 Mar 1996 10:17:26   agupta2
;// Initial revision of MMX version of IDCT.
;// 
;//    Rev 1.0   14 Mar 1996 14:38:02   AGUPTA2
;// Initial revision.
;** *************************************************************************
;*/
.586
.model flat
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

MMXCODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
MMXCODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
;
;Constants CONSTBITS, BETA1, NEGBETA2, BETA3, BETA4, and BETA5 are used in the 
;IDCT.  All *BETA* constants are represented in CONSTBITS fraction bits.  Their
;floating-point values are:
;  BETA1 = 1.414213562
;  BETA2 = 2.613125930
;  BETA3 = 1.414213562
;  BETA4 = 1.082392200
;  BETA5 = 0.765366865
;Thus scaled integral value of BETA1 is computed as:
; BETA1 = ROUND(1.414213562*2^13) = 02D41H
;
CONSTBITS = 13
ALIGN 8
BETA1 LABEL DWORD
BETA3 LABEL DWORD
  DWORD 02D410000H, 02D410000H
ALIGN 8
NEGBETA2 LABEL DWORD
  DWORD 0AC610000H, 0AC610000H
ALIGN 8
BETA4 LABEL DWORD
  DWORD 022A30000H, 022A30000H
ALIGN 8
BETA5 LABEL DWORD
  DWORD 0187E0000H, 0187E0000H
ALIGN 8
CONSTBITS_P_1_RND LABEL DWORD
  DWORD 02000H, 02000H
ALIGN 8
CONSTBITS_RND LABEL DWORD
  DWORD 01000H, 01000H
ALIGN 8
ONE  LABEL DWORD
  DWORD 000010001H, 000010001H
MMXDATA1 ENDS

MMXCODE1 SEGMENT
;
;
;
@MMX_DecodeBlock_IDCT@12 PROC
;  Parameters:
;    pIQ_INDEX:  DWORD PTR (in ecx)
;      Pointer to an array of coeff. structures; each structure consists of 
;      DWORD of inverse quantized and scaled coeff. and a DWORD of its index.
;    CountCoeff: DWORD (in edx)
;      Number of coefficients <= 64.
;    pBuf:       WORD PTR (at <[esp+4]> at the entry of this routine
;      Output area for the IDCT; an 8X8 matrix of WORD values with 6 frac. bits
;  Algorithm:
;    It uses scaled IDCT algorithm credited to Arai, Agui, and Nakajima (AAN).
;    High-level steps are:
;      1) Decode pIQ_INDEX array and populate the output buffer
;      2) IDCT and write to output buffer
;  Note:
;    If called from a C function, this routine must be declared as:
;    extern "C" void _fastcall MMX_DecodeBlock_IDCT(...)
;
  LocalFrameSize = 24

  Tu7      textequ <[esp+0]>
  Tv5      textequ <[esp+8]>
  StashESP textequ <[esp+16]>

  push      esi
   push     edi
  mov       edi, esp
   sub      esp, LocalFrameSize
  and       esp, 0FFFFFFF8H                ;Align at 8-byte boundary
   pxor     mm0, mm0
  mov       StashESP, edi
   mov      edi, DWORD PTR [edi+12]        ;pBuf
  add       edi, 64                        ;pBuf+64
   xor      eax, eax

  ;
  ;  Decode coefficients and place them in the output buffer
  ;    ecx: pIQ_INDEX
  ;    edx: No_Coeff
  ;    edi: pBuf+64
  ;    eax, esi: available
  ;
decode_coeff:
  mov       esi, [ecx+edx*8-4]              ;Index
   mov      eax, [ecx+edx*8-8]              ;Inverse quantized scaled coeff
  mov       WORD PTR [edi+esi*2-64], ax     ;
   dec      edx
  jnz       decode_coeff

IDCT_Start:

cols_0_3:
  CLINE0 = 0  - 64
  CLINE1 = 16 - 64
  CLINE2 = 32 - 64
  CLINE3 = 48 - 64
  CLINE4 = 64 - 64
  CLINE5 = 80 - 64
  CLINE6 = 96 - 64
  CLINE7 = 112- 64

   pxor      mm4, mm4                        ;
  movq       mm0, [edi+CLINE5]               ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+CLINE1]               ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+CLINE3]               ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+CLINE7]               ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_P_1_RND          ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_P_1_RND          ;s4h rounded
   psrad     mm4, CONSTBITS+1                ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS+1                ;s4h rounded descaled
  paddd      mm6, CONSTBITS_P_1_RND          ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_P_1_RND          ;s6h rounded
   psrad     mm6, CONSTBITS+1                ;s6l rounded descaled
  movq       mm0, [edi+CLINE1]               ;
   psrad     mm7, CONSTBITS+1                ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+CLINE7]               ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+CLINE3]               ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+CLINE5]               ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   psraw     mm7, 1                          ;q5>>1
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   psraw     mm2, 1                          ;q7>>1
  movq       mm0, [edi+CLINE2]
   paddw     mm7, mm2                        ;r7=s7=u7
  paddd      mm5, CONSTBITS_P_1_RND          ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_P_1_RND          ;s5h rounded
   psrad     mm5, CONSTBITS+1                ;s5l rounded descaled
  psubw      mm0, [edi+CLINE6]               ;r2
   psrad     mm3, CONSTBITS+1                ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  movq       Tu7, mm7                        ;Save u7
   pxor      mm7, mm7
  movq       mm2, [edi+CLINE0]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+CLINE2]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=u7
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+CLINE6]               ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+CLINE4]               ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  psraw      mm0, 1                          ;t3>>1
   ;
  psraw      mm2, 1                          ;t1>>1
   ;
  psraw      mm1, 1                          ;t2>>1
   ;
  paddw      mm3, [edi+CLINE4]               ;t0
   movq      mm7, mm0                        ;t3>>1 copy
  psraw      mm3, 1                          ;t0>>1
   ;
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
;  psraw      mm3, 1                          ;u3>>1
   movq      mm7, mm1                        ;t2
  paddw      mm1, mm2                        ;u1=t2+t1
   psubw     mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
;  psraw      mm2, 1                          ;u2>>1
   movq      mm7, mm3                        ;u3>>1
  psubw      mm3, mm4                        ;v3=u3-(-u4)
   paddw     mm4, mm7                        ;v4=-u4+u3
;  psraw      mm1, 1                          ;u1>>1
   movq      mm7, mm2                        ;u2>>1
;  psraw      mm0, 1                          ;u0>>1
   psubw     mm2, mm5                        ;v5=u2-u5
  paddw      mm5, mm7                        ;v2=u5+u2
   movq      mm7, mm1                        ;u1>>1
  psubw      mm1, mm6                        ;v6=u1-u6
   paddw     mm6, mm7                        ;v1=u6+u1
  movq       Tv5, mm2                        ;Save v5
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;v0
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;v7
   punpckldq mm7, mm5                        ;T1
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+CLINE2], mm7               ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+CLINE3], mm6               ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+CLINE0], mm3               ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+CLINE1], mm5               ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+CLINE6], mm4               ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+CLINE7], mm2               ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+CLINE5], mm1               ;T2
   ;                                         ;cols 4-7
  movq       [edi+CLINE4], mm7               ;T2
   ;                                         ;cols 4-7
cols_4_7:
; Add 8 to CLINE offsets
   pxor      mm4, mm4                        ;
  movq       mm0, [edi+CLINE5+8]             ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+CLINE1+8]             ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+CLINE3+8]             ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+CLINE7+8]             ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_RND              ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_RND              ;s4h rounded
   psrad     mm4, CONSTBITS                  ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS                  ;s4h rounded descaled
  paddd      mm6, CONSTBITS_RND              ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_RND              ;s6h rounded
   psrad     mm6, CONSTBITS                  ;s6l rounded descaled
  movq       mm0, [edi+CLINE1+8]             ;
   psrad     mm7, CONSTBITS                  ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+CLINE7+8]             ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+CLINE3+8]             ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+CLINE5+8]             ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   ;TODO
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   ;TODO
  movq       mm0, [edi+CLINE2+8]
   paddw     mm7, mm2                        ;r7=s7=u7
  paddd      mm5, CONSTBITS_RND              ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_RND              ;s5h rounded
   psrad     mm5, CONSTBITS                  ;s5l rounded descaled
  psubw      mm0, [edi+CLINE6+8]             ;r2
   psrad     mm3, CONSTBITS                  ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  movq       Tu7, mm7                        ;Save u7
   pxor      mm7, mm7
  movq       mm2, [edi+CLINE0+8]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+CLINE2+8]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=u7
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+CLINE6+8]             ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+CLINE4+8]             ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  paddw      mm3, [edi+CLINE4+8]             ;t0
   movq      mm7, mm0                        ;t3
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
  movq       mm7, mm1                        ;t2
   paddw     mm1, mm2                        ;u1=t2+t1
  psubw      mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
  
   movq      mm7, mm3                        ;
  psubw      mm3, mm4                        ;u3-(-u4)
   paddw     mm4, mm7                        ;-u4+u3
  psraw      mm3, 1                          ;v3
   movq      mm7, mm2                        ;
  psraw      mm4, 1                          ;v4
   psubw     mm2, mm5                        ;u2-u5
  psraw      mm2, 1                          ;v5
   paddw     mm5, mm7                        ;u5+u2
  psraw      mm5, 1                          ;v2
   movq      mm7, mm1                        ;
  psubw      mm1, mm6                        ;u1-u6
   paddw     mm6, mm7                        ;u6+u1
  movq       Tv5, mm2                        ;Save v5
   psraw     mm1, 1                          ;v6
  psraw      mm6, 1                          ;v1
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;
   ;TODO
  psraw      mm7, 1                          ;v0
   ;TODO
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;
   punpckldq mm7, mm5                        ;T1
  psraw      mm0, 1                          ;v7
   ;TODO
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+CLINE2+8], mm7             ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+CLINE3+8], mm6             ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+CLINE0+8], mm3             ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+CLINE1+8], mm5             ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+CLINE6+8], mm4             ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+CLINE7+8], mm2             ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+CLINE5+8], mm1             ;T2
   ;                                         ;cols 4-7
  movq       [edi+CLINE4+8], mm7             ;T2
   ;                                         ;cols 4-7
rows_0_3:

RLINE0 = 0  - 64
RLINE1 = 16 - 64
RLINE2 = 32 - 64
RLINE3 = 48 - 64
RLINE4 = 8  - 64
RLINE5 = 24 - 64
RLINE6 = 40 - 64
RLINE7 = 56 - 64
   pxor      mm4, mm4                        ;
  movq       mm0, [edi+RLINE5]               ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+RLINE1]               ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+RLINE3]               ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+RLINE7]               ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_P_1_RND          ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_P_1_RND          ;s4h rounded
   psrad     mm4, CONSTBITS+1                ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS+1                ;s4h rounded descaled
  paddd      mm6, CONSTBITS_P_1_RND          ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_P_1_RND          ;s6h rounded
   psrad     mm6, CONSTBITS+1                ;s6l rounded descaled
  movq       mm0, [edi+RLINE1]               ;
   psrad     mm7, CONSTBITS+1                ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+RLINE7]               ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+RLINE3]               ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+RLINE5]               ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   paddw     mm7, mm2                        ;r7=q5+q7
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   ;TODO
  paddw      mm7, ONE                        ;
   ;TODO
  movq       mm0, [edi+RLINE2]
   psraw     mm7, 1                          ;s7
  paddd      mm5, CONSTBITS_P_1_RND          ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_P_1_RND          ;s5h rounded
   psrad     mm5, CONSTBITS+1                ;s5l rounded descaled
  psubw      mm0, [edi+RLINE6]               ;r2
   psrad     mm3, CONSTBITS+1                ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  psllw      mm7, 1                          ;u7<<1
   ;
  movq       Tu7, mm7                        ;Save u7<<1
   pxor      mm7, mm7
  movq       mm2, [edi+RLINE0]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+RLINE2]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+RLINE6]               ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+RLINE4]               ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  paddw      mm3, [edi+RLINE4]               ;t0
   movq      mm7, mm0                        ;t3
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
  ;TODO
   movq      mm7, mm1                        ;t2
  paddw      mm1, mm2                        ;u1=t2+t1
   psubw     mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
  psllw      mm4, 1                          ;-u4<<1
   movq      mm7, mm3                        ;
  psubw      mm3, mm4                        ;v3=u3-(-u4<<1)
   paddw     mm4, mm7                        ;v4=(-u4<<1)+u3
  psllw      mm5, 1                          ;u5<<1
   movq      mm7, mm2                        ;
  psubw      mm2, mm5                        ;v5=u2-(u5<<1)
   paddw     mm5, mm7                        ;v2=(u5<<1)+u2
  psllw      mm6, 1                          ;u6<<1
   movq      mm7, mm1                        ;
  psubw      mm1, mm6                        ;v6=u1-(u6<<1)
   paddw     mm6, mm7                        ;v1=(u6<<1)+u1
  movq       Tv5, mm2                        ;Save v5
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;v0=u0+(u7<<1)
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;v7=u0-(u7<<1)
   punpckldq mm7, mm5                        ;T1
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+RLINE2], mm7               ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+RLINE3], mm6               ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+RLINE0], mm3               ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+RLINE1], mm5               ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+RLINE6], mm4               ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+RLINE7], mm2               ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+RLINE5], mm1               ;T2
   ;                                         ;cols 4-7
  movq       [edi+RLINE4], mm7               ;T2
   ;                                         ;cols 4-7
rows_4_7:
; Add 64 to RLINE offsets
   pxor      mm4, mm4                        ;
  movq       mm0, [edi+RLINE5+64]            ;
   pxor      mm5, mm5                        ;
  movq       mm1, [edi+RLINE1+64]            ;
   pxor      mm2, mm2                        ;
  psubw      mm0, [edi+RLINE3+64]            ;q4=r4
   pxor      mm3, mm3                        ;
  psubw      mm1, [edi+RLINE7+64]            ;q6=r6
   punpcklwd mm4, mm0                        ;
  pmaddwd    mm4, NEGBETA2                   ;
   punpckhwd mm5, mm0                        ;
  pmaddwd    mm5, NEGBETA2                   ;
   psubw     mm0, mm1                        ;r4-r6
  punpcklwd  mm2, mm0                        ;
   pxor      mm6, mm6                        ;
  pmaddwd    mm2, BETA5                      ;
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA5                      ;
   punpcklwd mm6, mm1                        ;
  pmaddwd    mm6, BETA4                      ;
   pxor      mm7, mm7                        ;
  punpckhwd  mm7, mm1                        ;
   paddd     mm4, mm2                        ;s4l
  pmaddwd    mm7, BETA4                      ;
   paddd     mm5, mm3                        ;s4h
  paddd      mm4, CONSTBITS_P_1_RND          ;s4l rounded
   psubd     mm6, mm2                        ;s6l
  paddd      mm5, CONSTBITS_P_1_RND          ;s4h rounded
   psrad     mm4, CONSTBITS+1                ;s4l rounded descaled
  psubd      mm7, mm3                        ;s6h
   psrad     mm5, CONSTBITS+1                ;s4h rounded descaled
  paddd      mm6, CONSTBITS_P_1_RND          ;s6l rounded
   packssdw  mm4, mm5                        ;s4
  paddd      mm7, CONSTBITS_P_1_RND          ;s6h rounded
   psrad     mm6, CONSTBITS+1                ;s6l rounded descaled
  movq       mm0, [edi+RLINE1+64]            ;
   psrad     mm7, CONSTBITS+1                ;s6h rounded descaled
                                             ;mm0=q5   mm4=s4
                                             ;mm2=q7   mm6=s6
  paddw      mm0, [edi+RLINE7+64]            ;q5
   packssdw  mm6, mm7                        ;s6
  movq       mm2, [edi+RLINE3+64]            ;
   pxor      mm5, mm5                        ;
  paddw      mm2, [edi+RLINE5+64]            ;q7
   movq      mm7, mm0                        ;q5
  psubw      mm0, mm2                        ;r5=q5-q7
   paddw     mm7, mm2                        ;r7=q5+q7
  punpcklwd  mm5, mm0                        
   pxor      mm3, mm3
  pmaddwd    mm5, BETA3                      ;s5l
   punpckhwd mm3, mm0                        ;
  pmaddwd    mm3, BETA3                      ;s5h
   ;TODO
  paddw      mm7, ONE                        ;
   ;TODO
  movq       mm0, [edi+RLINE2+64]
   psraw     mm7, 1                          ;s7
  paddd      mm5, CONSTBITS_P_1_RND          ;s5l rounded
   psubw     mm6, mm7                        ;u6
  paddd      mm3, CONSTBITS_P_1_RND          ;s5h rounded
   psrad     mm5, CONSTBITS+1                ;s5l rounded descaled
  psubw      mm0, [edi+RLINE6+64]            ;r2
   psrad     mm3, CONSTBITS+1                ;s5h rounded descaled
  packssdw   mm5, mm3                        ;s5
   pxor      mm1, mm1
                                             ;mm0=r2   mm4=s4
                                             ;mm1      mm5=u5
                                             ;mm2      mm6=u6
                                             ;mm3      mm7=Tu7
  psllw      mm7, 1                          ;u7<<1
   ;
  movq       Tu7, mm7                        ;Save u7<<1
   pxor      mm7, mm7
  movq       mm2, [edi+RLINE0+64]
   punpcklwd mm1, mm0
  pmaddwd    mm1, BETA1                      ;s2l
   punpckhwd mm7, mm0
  pmaddwd    mm7, BETA1                      ;s2h
   psubw     mm5, mm6                        ;u5
  movq       mm0, [edi+RLINE2+64]
   paddw     mm4, mm5                        ;-u4
                                             ;mm4=-u4  mm5=u5
                                             ;mm6=u6   mm7=
  paddd      mm1, CONSTBITS_RND              ;s2l rounded
   ;
  paddd      mm7, CONSTBITS_RND              ;s2h rounded
   psrad     mm1, CONSTBITS                  ;s2l rounded descaled
  paddw      mm0, [edi+RLINE6+64]               ;r3=s3=t3
   psrad     mm7, CONSTBITS                  ;s2h rounded descaled
  movq       mm3, mm2                        ;
   packssdw  mm1, mm7                        ;s2
  psubw      mm2, [edi+RLINE4+64]            ;t1
   psubw     mm1, mm0                        ;t2=s2-s3
  paddw      mm3, [edi+RLINE4+64]            ;t0
   movq      mm7, mm0                        ;t3
  paddw      mm0, mm3                        ;u0=t3+t0
   psubw     mm3, mm7                        ;u3=t0-t3
  ;TODO
   movq      mm7, mm1                        ;t2
  paddw      mm1, mm2                        ;u1=t2+t1
   psubw     mm2, mm7                        ;u2=t1-t2
                                             ;mm0=u0   mm4=-u4
                                             ;mm1=u1   mm5=u5
                                             ;mm2=u2   mm6=u6
                                             ;mm3=u3   mm7=avail.
  psllw      mm4, 1                          ;-u4<<1
   movq      mm7, mm3                        ;
  psubw      mm3, mm4                        ;v3=u3-(-u4<<1)
   paddw     mm4, mm7                        ;v4=(-u4<<1)+u3
  psllw      mm5, 1                          ;u5<<1
   movq      mm7, mm2                        ;
  psubw      mm2, mm5                        ;v5=u2-(u5<<1)
   paddw     mm5, mm7                        ;v2=(u5<<1)+u2
  psllw      mm6, 1                          ;u6<<1
   movq      mm7, mm1                        ;
  psubw      mm1, mm6                        ;v6=u1-(u6<<1)
   paddw     mm6, mm7                        ;v1=(u6<<1)+u1
  movq       Tv5, mm2                        ;Save v5
   movq      mm7, mm0                        ;
  movq       mm2, mm5                        ;T1
   punpckhwd mm5, mm3                        ;T1(c,d)
  paddw      mm7, Tu7                        ;v0=u0+(u7<<1)
                                             ;v0=mm7   v4=mm4
                                             ;v1=mm6   v5=Tv5 (to mm2 later)
                                             ;v2=mm5   v6=mm1
                                             ;v3=mm3   v7=mm0 (later)
   punpcklwd mm2, mm3                        ;T1(c,d);mm3 free
  movq       mm3, mm7                        ;T1(a,b)
   punpckhwd mm7, mm6                        ;T1(a,b)
  punpcklwd  mm3, mm6                        ;T1(a,b);mm6 free
   movq      mm6, mm7                        ;T1
  psubw      mm0, Tu7                        ;v7=u0-(u7<<1)
   punpckldq mm7, mm5                        ;T1
  punpckhdq  mm6, mm5                        ;T1;mm5 free
   movq      mm5, mm3                        ;T1
  movq       [edi+RLINE2+64], mm7            ;T1
   punpckldq mm3, mm2                        ;T1
  movq       [edi+RLINE3+64], mm6            ;T1
   punpckhdq mm5, mm2                        ;T1
  movq       [edi+RLINE0+64], mm3            ;T1
   movq      mm6, mm1                        ;T2(c,d)
  movq       [edi+RLINE1+64], mm5            ;T1
   punpckhwd mm1, mm0                        ;T2(c,d)
  movq       mm2, Tv5
   punpcklwd mm6, mm0                        ;T2(c,d);mm0 free
  movq       mm7, mm4                        ;T2(a,b)
   punpckhwd mm4, mm2                        ;T2(a,b)
  punpcklwd  mm7, mm2                        ;T2(a,b);mm2 free
   movq      mm2, mm4                        ;T2
  punpckldq  mm4, mm1                        ;T2
   ;                                         ;cols 4-7
  punpckhdq  mm2, mm1                        ;T2
   movq      mm1, mm7                        ;T2
  movq       [edi+RLINE6+64], mm4            ;T2
   punpckhdq mm1, mm6                        ;T2
  movq       [edi+RLINE7+64], mm2            ;T2
   punpckldq mm7, mm6                        ;T2
  movq       [edi+RLINE5+64], mm1            ;T2
   ;                                         ;cols 4-7
  movq       [edi+RLINE4+64], mm7            ;T2
   ;                                         ;cols 4-7
IDCT_Done:
  mov        esp, StashESP
  pop        edi
  pop        esi
  ret        4

@MMX_DecodeBlock_IDCT@12 endp

MMXCODE1 ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h263\i386\d3mbvriq.asm ===
;--------------------------------------------------------------------------------
;    INTEL Corporation Proprietary Information
;
;    This listing is supplied under the terms of a license
;    agreement with INTEL Corporation and may not be copied
;    nor disclosed except in accordance with the terms of
;    that agreement.
;
;    Copyright (c) 1996 Intel Corporation.
;    All Rights Reserved.
;
;--------------------------------------------------------------------------------

;--------------------------------------------------------------------------------
;
; $Author:   RMCKENZX  $
; $Date:   03 Apr 1996 17:31:22  $
; $Archive:   S:\h26x\src\dec\d3mbvriq.asv  $
; $Header:   S:\h26x\src\dec\d3mbvriq.asv   1.6   03 Apr 1996 17:31:22   RMCKENZX  $
; $Log:   S:\h26x\src\dec\d3mbvriq.asv  $
;// 
;//    Rev 1.6   03 Apr 1996 17:31:22   RMCKENZX
;// Additional optimizations.
;// 
;//    Rev 1.5   01 Apr 1996 11:37:50   AGUPTA2
;// Moved the routine to IACODE1 segment.
;// 
;//    Rev 1.4   14 Mar 1996 14:21:56   AGUPTA2
;// Moved tables from mmxtable.c to this file.  Added segment decls.
;// 
;//    Rev 1.3   13 Mar 1996 11:17:08   RMCKENZX
;// Added scaling of INTRA DC coefficient.
;// 
;//    Rev 1.2   12 Mar 1996 08:39:34   RMCKENZX
;// changed to fixed point scaling tables.
;// 
;//    Rev 1.0   27 Feb 1996 15:24:14   RMCKENZX
;// Initial revision.
; 
;--------------------------------------------------------------------------------

;--------------------------------------------------------------------------------
;
;  d3mbvriq.asm
;
;  Description:
;    This routine performs run length decoding and inverse quantization
;    of transform coefficients for one block.
;	 MMx version.
;
;  Routines:
;    VLD_RLD_IQ_Block
;
;  Inputs (dwords pushed onto stack by caller):
;    lpBlockAction  pointer to Block action stream for current block.
;
;	 lpSrc			The input bitstream.
;
;	 lBitsInOut		Number of bits already read.
;
;    pIQ_INDEX		Pointer to coefficients and indices.
;
;    pN				Pointer to number of coefficients read.
;
;  Returns:
;     				total number of bits read (including number read
;					prior to call).  On error, returns 0.
;
;--------------------------------------------------------------------------------
;
; TABLES 
;	The structure of the MMx tables (DWORD entries) is:
;		bits    name    description
;		31-16   level   signed 16-bit quantized value
;		15      last    0 = more coef., 1 = last coef.
;		14-8    bits    number of bits used by VLC
;		7-0     run     number of preceeding 0s + 1
;	
;	special table values:  (all signaled by run == 0)
;		0x00000000      escape code
;		0x80000000      illegal code
;		0xffffff00      major table miss
;
;
; ALGORITHM
;	We use the following 4 cases to compute the reconstructed value
;	depending on the sign of L=level and the parity of Q=quantizer:
;
;				L pos		L neg
;	Q even		2QL+(Q-1)	2QL-(Q-1)
;	Q odd		2QL+(Q)		2QL-(Q)
;
;	The Q or Q-1 term is formed by subtracting 1 and then oring
;   with 1.  This leaves odd Qs unchanged, and decreases even Qs by 1.
;   This is done in the function header and kept in mm3.
;
;	The + or - on this term (moved to mm4) is gotten by using a mask 
;	in mm1 formed from the sign bit of L.  This mask is exclusive or'd
;   with the term and then subtracted from the result.  When the mask is 0, 
;   this leaves the term unchanged.  When the mask is -1, it first forms 
;   the one's complement, then changes it to the 2's complement.
;
;
; SCALING
;	The scale factor is stored as a fixed point WORD.  After multiplication 
;   by the scale and shifting , we have 8 fraction bits.  Then a round   
;	bit is added in, and a final shift leaves 7 fraction bits.
;
;
; CLIPPING
;	Clipping of the reconstructed coefficient to the range of -2048, ... 
;	+2047 is done for the (escape signalled) fixed length decodes.  It is
;   not needed for the variable length decodes as the most extreme level
;   for any of the variable length coded events is +-12.  Since the maximum
;   quantizer is 31, this can generate at most a coefficient of +-775.
;
;   Clipping is done by:
;		1.  Adding (with SIGNED Saturation) TopClip	(30720 or 0x7800)
;		2.  Subtracting (with UNSIGNED Saturation) LowClip (28672 or 0x7000)
;		3.  Adding MidClip (-2048 or 0xf800)
; 
;	since TopClip - LowClip + MidClip = 0, This will leave the coefficient
;   unchanged unless:
;		(1) the result of the first add is negative, or
;		(2) saturation takes place.
;        
;	Since the maximum level is +-127, the most extreme coefficient (prior to 
;	clipping) is +-7905.  Thus the result of the first add will always be
;	positive.
;
;	If the input value is 2047 or larger, the result of the first add will
;	clip to 32767, then subtract to 4095, then add to +2047 as desired.
;
;	If the input value is -2048 or smaller, the result of the first add
;	will be 28672 or smaller (but at least 22815), hence the unsigned 
;	subtract will clip to 0.  The final add will then yield -2048 as desired.
;
;--------------------------------------------------------------------------------
;
;	Register Usage:
;       eax = bitstream value
;		ebx = lBitsInOut>>3 (byte offset into bitstream)
;		 cl = lBitsInOut&7 (bit offset into bitstream)
;		 dl = block type ([lpBlockAction])
;		esi = bitstream source pointer (lpSrc)
;		edi = coefficient destination pointer (pIQ_INDEX)
;		ebp = coefficent counter (init to 0)
;
;       mm0 = accumulator (initially level, finally coefficient*scale)
;       mm1 = mask (0 when level positive, -1 when level negative)
;       mm2 = 2Q 2*quantizer
;       mm3 = term (see description above)
;       mm4 = +- term (see description above)
;       mm5 = rounding value
;       mm6 = TopClip
;       mm7 = LowClip
;
;--------------------------------------------------------------------------------

.586
.MODEL FLAT

;  make all symbols case sensitive
OPTION CASEMAP:NONE
OPTION PROLOGUE:None
OPTION EPILOGUE:None

.xlist
include iammx.inc
.list

IACODE1 SEGMENT PARA USE32 PUBLIC 'CODE'
IACODE1 ENDS

MMXDATA1 SEGMENT PARA USE32 PUBLIC 'DATA'
MMXDATA1 ENDS

MMXDATA1 SEGMENT
ALIGN 8
MMX_Scale LABEL DWORD
DWORD 040000000H, 058c50000H, 0539f0000H, 04b420000H, 040000000H, 032490000H, 022a30000H, 011a80000H  ; row 0
DWORD 058c50000H, 07b210000H, 073fc0000H, 068620000H, 058c50000H, 045bf0000H, 0300b0000H, 0187e0000H  ; row 1
DWORD 0539f0000H, 073fc0000H, 06d410000H, 062540000H, 0539f0000H, 041b30000H, 02d410000H, 017120000H  ; row 2
DWORD 04b420000H, 068620000H, 062540000H, 0587e0000H, 04b420000H, 03b210000H, 028ba0000H, 014c30000H  ; row 3
DWORD 040000000H, 058c50000H, 0539f0000H, 04b420000H, 040000000H, 032490000H, 022a30000H, 011a80000H  ; row 4
DWORD 032490000H, 045bf0000H, 041b30000H, 03b210000H, 032490000H, 027820000H, 01b370000H, 00de00000H  ; row 5
DWORD 022a30000H, 0300b0000H, 02d410000H, 028ba0000H, 022a30000H, 01b370000H, 012bf0000H, 0098e0000H  ; row 6
DWORD 011a80000H, 0187e0000H, 017120000H, 014c30000H, 011a80000H, 00de00000H, 0098e0000H, 004df0000H   ; row 7

ALIGN 8
MidClip         DWORD      0f800f800h	; = Low

ALIGN 4
Round           DWORD       00000200h 
TopClip         DWORD       78007800h	; = max_pos - High
LowClip         DWORD       70007000h 	; = TopClip + Low

ALIGN 4
MMX_TCOEFF_MAJOR LABEL DWORD 
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 000000000H, 000000000H  ; 0-7
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H  ; 8-15
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H  ; 16-23
DWORD 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H, 0ffffff00H  ; 24-31
DWORD 000018809H, 0ffff8809H, 000018808H, 0ffff8808H, 000018807H, 0ffff8807H, 000018806H, 0ffff8806H  ; 32-39
DWORD 00001080dH, 0ffff080dH, 00001080cH, 0ffff080cH, 00001080bH, 0ffff080bH, 000040801H, 0fffc0801H  ; 40-47
DWORD 000018705H, 000018705H, 0ffff8705H, 0ffff8705H, 000018704H, 000018704H, 0ffff8704H, 0ffff8704H  ; 48-55
DWORD 000018703H, 000018703H, 0ffff8703H, 0ffff8703H, 000018702H, 000018702H, 0ffff8702H, 0ffff8702H  ; 56-63
DWORD 00001070aH, 00001070aH, 0ffff070aH, 0ffff070aH, 000010709H, 000010709H, 0ffff0709H, 0ffff0709H  ; 64-71
DWORD 000010708H, 000010708H, 0ffff0708H, 0ffff0708H, 000010707H, 000010707H, 0ffff0707H, 0ffff0707H  ; 72-79
DWORD 000020702H, 000020702H, 0fffe0702H, 0fffe0702H, 000030701H, 000030701H, 0fffd0701H, 0fffd0701H  ; 80-87
DWORD 000010606H, 000010606H, 000010606H, 000010606H, 0ffff0606H, 0ffff0606H, 0ffff0606H, 0ffff0606H  ; 88-95
DWORD 000010605H, 000010605H, 000010605H, 000010605H, 0ffff0605H, 0ffff0605H, 0ffff0605H, 0ffff0605H  ; 96-103
DWORD 000010604H, 000010604H, 000010604H, 000010604H, 0ffff0604H, 0ffff0604H, 0ffff0604H, 0ffff0604H  ; 104-111
DWORD 000018501H, 000018501H, 000018501H, 000018501H, 000018501H, 000018501H, 000018501H, 000018501H  ; 112-119
DWORD 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H, 0ffff8501H  ; 120-127
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 128-135
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 136-143
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 144-151
DWORD 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H, 000010301H  ; 152-159
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 160-167
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 168-175
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 176-183
DWORD 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H, 0ffff0301H  ; 184-191
DWORD 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H  ; 192-199
DWORD 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H, 000010402H  ; 200-207
DWORD 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H  ; 208-215
DWORD 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H, 0ffff0402H  ; 216-223
DWORD 000010503H, 000010503H, 000010503H, 000010503H, 000010503H, 000010503H, 000010503H, 000010503H  ; 224-231
DWORD 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H, 0ffff0503H  ; 232-239
DWORD 000020501H, 000020501H, 000020501H, 000020501H, 000020501H, 000020501H, 000020501H, 000020501H  ; 240-247
DWORD 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H, 0fffe0501H   ; 248-255

ALIGN 4
MMX_TCOEFF_MINOR LABEL DWORD 
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 0-7  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 8-15  ILLEGAL CODES
DWORD 000028c02H, 000028c02H, 0fffe8c02H, 0fffe8c02H, 000038c01H, 000038c01H, 0fffd8c01H, 0fffd8c01H  ; 16-23
DWORD 0000b0c01H, 0000b0c01H, 0fff50c01H, 0fff50c01H, 0000a0c01H, 0000a0c01H, 0fff60c01H, 0fff60c01H  ; 24-31
DWORD 000018b1dH, 000018b1dH, 000018b1dH, 000018b1dH, 0ffff8b1dH, 0ffff8b1dH, 0ffff8b1dH, 0ffff8b1dH  ; 32-39
DWORD 000018b1cH, 000018b1cH, 000018b1cH, 000018b1cH, 0ffff8b1cH, 0ffff8b1cH, 0ffff8b1cH, 0ffff8b1cH  ; 40-47
DWORD 000018b1bH, 000018b1bH, 000018b1bH, 000018b1bH, 0ffff8b1bH, 0ffff8b1bH, 0ffff8b1bH, 0ffff8b1bH  ; 48-55
DWORD 000018b1aH, 000018b1aH, 000018b1aH, 000018b1aH, 0ffff8b1aH, 0ffff8b1aH, 0ffff8b1aH, 0ffff8b1aH  ; 56-63
DWORD 000020b0aH, 000020b0aH, 000020b0aH, 000020b0aH, 0fffe0b0aH, 0fffe0b0aH, 0fffe0b0aH, 0fffe0b0aH  ; 64-71
DWORD 000020b09H, 000020b09H, 000020b09H, 000020b09H, 0fffe0b09H, 0fffe0b09H, 0fffe0b09H, 0fffe0b09H  ; 72-79
DWORD 000020b08H, 000020b08H, 000020b08H, 000020b08H, 0fffe0b08H, 0fffe0b08H, 0fffe0b08H, 0fffe0b08H  ; 80-87
DWORD 000020b07H, 000020b07H, 000020b07H, 000020b07H, 0fffe0b07H, 0fffe0b07H, 0fffe0b07H, 0fffe0b07H  ; 88-95
DWORD 000020b06H, 000020b06H, 000020b06H, 000020b06H, 0fffe0b06H, 0fffe0b06H, 0fffe0b06H, 0fffe0b06H  ; 96-103
DWORD 000030b04H, 000030b04H, 000030b04H, 000030b04H, 0fffd0b04H, 0fffd0b04H, 0fffd0b04H, 0fffd0b04H  ; 104-111
DWORD 000030b03H, 000030b03H, 000030b03H, 000030b03H, 0fffd0b03H, 0fffd0b03H, 0fffd0b03H, 0fffd0b03H  ; 112-119
DWORD 000040b02H, 000040b02H, 000040b02H, 000040b02H, 0fffc0b02H, 0fffc0b02H, 0fffc0b02H, 0fffc0b02H  ; 120-127
DWORD 0000c0c01H, 0000c0c01H, 0fff40c01H, 0fff40c01H, 000050c02H, 000050c02H, 0fffb0c02H, 0fffb0c02H  ; 128-135
DWORD 000010c18H, 000010c18H, 0ffff0c18H, 0ffff0c18H, 000010c19H, 000010c19H, 0ffff0c19H, 0ffff0c19H  ; 136-143
DWORD 000018c1eH, 000018c1eH, 0ffff8c1eH, 0ffff8c1eH, 000018c1fH, 000018c1fH, 0ffff8c1fH, 0ffff8c1fH  ; 144-151
DWORD 000018c20H, 000018c20H, 0ffff8c20H, 0ffff8c20H, 000018c21H, 000018c21H, 0ffff8c21H, 0ffff8c21H  ; 152-159
DWORD 000060d02H, 0fffa0d02H, 000040d03H, 0fffc0d03H, 000030d05H, 0fffd0d05H, 000030d06H, 0fffd0d06H  ; 160-167
DWORD 000030d07H, 0fffd0d07H, 000020d0bH, 0fffe0d0bH, 000010d1aH, 0ffff0d1aH, 000010d1bH, 0ffff0d1bH  ; 168-175
DWORD 000018d22H, 0ffff8d22H, 000018d23H, 0ffff8d23H, 000018d24H, 0ffff8d24H, 000018d25H, 0ffff8d25H  ; 176-183
DWORD 000018d26H, 0ffff8d26H, 000018d27H, 0ffff8d27H, 000018d28H, 0ffff8d28H, 000018d29H, 0ffff8d29H  ; 184-191
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 192-199  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 200-207  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 208-215  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 216-223  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 224-231  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 232-239  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 240-247  ILLEGAL CODES
DWORD 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H, 080000000H  ; 248-255  ILLEGAL CODES
DWORD 000090b01H, 000090b01H, 000090b01H, 000090b01H, 0fff70b01H, 0fff70b01H, 0fff70b01H, 0fff70b01H  ; 256-263
DWORD 000080b01H, 000080b01H, 000080b01H, 000080b01H, 0fff80b01H, 0fff80b01H, 0fff80b01H, 0fff80b01H  ; 264-271
DWORD 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H, 000018a19H  ; 272-279
DWORD 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H, 0ffff8a19H  ; 280-287
DWORD 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H, 000018a18H  ; 288-295
DWORD 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H, 0ffff8a18H  ; 296-303
DWORD 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H, 000018a17H  ; 304-311
DWORD 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H, 0ffff8a17H  ; 312-319
DWORD 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H, 000018a16H  ; 320-327
DWORD 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H, 0ffff8a16H  ; 328-335
DWORD 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H, 000018a15H  ; 336-343
DWORD 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H, 0ffff8a15H  ; 344-351
DWORD 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H, 000018a14H  ; 352-359
DWORD 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H, 0ffff8a14H  ; 360-367
DWORD 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H, 000018a13H  ; 368-375
DWORD 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H, 0ffff8a13H  ; 376-383
DWORD 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H, 000018a12H  ; 384-391
DWORD 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H, 0ffff8a12H  ; 392-399
DWORD 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H, 000028a01H  ; 400-407
DWORD 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H, 0fffe8a01H  ; 408-415
DWORD 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H, 000010a17H  ; 416-423
DWORD 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H, 0ffff0a17H  ; 424-431
DWORD 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H, 000010a16H  ; 432-439
DWORD 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H, 0ffff0a16H  ; 440-447
DWORD 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H, 000010a15H  ; 448-455
DWORD 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H, 0ffff0a15H  ; 456-463
DWORD 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H, 000010a14H  ; 464-471
DWORD 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H, 0ffff0a14H  ; 472-479
DWORD 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H, 000010a13H  ; 480-487
DWORD 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H, 0ffff0a13H  ; 488-495
DWORD 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H, 000010a12H  ; 496-503
DWORD 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H, 0ffff0a12H  ; 504-511
DWORD 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H, 000010a11H  ; 512-519
DWORD 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H, 0ffff0a11H  ; 520-527
DWORD 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H, 000010a10H  ; 528-535
DWORD 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H, 0ffff0a10H  ; 536-543
DWORD 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H, 000020a05H  ; 544-551
DWORD 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H, 0fffe0a05H  ; 552-559
DWORD 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H, 000020a04H  ; 560-567
DWORD 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H, 0fffe0a04H  ; 568-575
DWORD 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H, 000070a01H  ; 576-583
DWORD 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H, 0fff90a01H  ; 584-591
DWORD 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H, 000060a01H  ; 592-599
DWORD 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H, 0fffa0a01H  ; 600-607
DWORD 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H  ; 608-615
DWORD 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H, 000018911H  ; 616-623
DWORD 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H  ; 624-631
DWORD 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H, 0ffff8911H  ; 632-639
DWORD 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H  ; 640-647
DWORD 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H, 000018910H  ; 648-655
DWORD 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H  ; 656-663
DWORD 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H, 0ffff8910H  ; 664-671
DWORD 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH  ; 672-679
DWORD 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH, 00001890fH  ; 680-687
DWORD 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH  ; 688-695
DWORD 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH, 0ffff890fH  ; 696-703
DWORD 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH  ; 704-711
DWORD 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH, 00001890eH  ; 712-719
DWORD 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH  ; 720-727
DWORD 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH, 0ffff890eH  ; 728-735
DWORD 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH  ; 736-743
DWORD 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH, 00001890dH  ; 744-751
DWORD 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH  ; 752-759
DWORD 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH, 0ffff890dH  ; 760-767
DWORD 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH  ; 768-775
DWORD 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH, 00001890cH  ; 776-783
DWORD 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH  ; 784-791
DWORD 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH, 0ffff890cH  ; 792-799
DWORD 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH  ; 800-807
DWORD 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH, 00001890bH  ; 808-815
DWORD 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH  ; 816-823
DWORD 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH, 0ffff890bH  ; 824-831
DWORD 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH  ; 832-839
DWORD 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH, 00001890aH  ; 840-847
DWORD 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH  ; 848-855
DWORD 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH, 0ffff890aH  ; 856-863
DWORD 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH  ; 864-871
DWORD 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH, 00001090fH  ; 872-879
DWORD 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH  ; 880-887
DWORD 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH, 0ffff090fH  ; 888-895
DWORD 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH  ; 896-903
DWORD 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH, 00001090eH  ; 904-911
DWORD 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH  ; 912-919
DWORD 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH, 0ffff090eH  ; 920-927
DWORD 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H  ; 928-935
DWORD 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H, 000020903H  ; 936-943
DWORD 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H  ; 944-951
DWORD 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H, 0fffe0903H  ; 952-959
DWORD 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H  ; 960-967
DWORD 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H, 000030902H  ; 968-975
DWORD 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H  ; 976-983
DWORD 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H, 0fffd0902H  ; 984-991
DWORD 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H  ; 992-999
DWORD 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H, 000050901H  ; 1000-1007
DWORD 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H  ; 1008-1015
DWORD 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H, 0fffb0901H  ; 1016-1023

ALIGN 4
TAB_ZZ_RUN LABEL DWORD
DWORD  0,  1,  8,  16, 9,  2,  3,  10
DWORD 17, 24, 32, 25, 18, 11, 4,  5
DWORD 12, 19, 26, 33, 40, 48, 41, 34
DWORD 27, 20, 13, 6,  7,  14, 21, 28
DWORD 35, 42, 49, 56, 57, 50, 43, 36
DWORD 29, 22, 15, 23, 30, 37, 44, 51
DWORD 58, 59, 52, 45, 38, 31, 39, 46
DWORD 53, 60, 61, 54, 47, 55, 62, 63

MMXDATA1 ENDS

; global tables
MajorTbl        EQU     MMX_TCOEFF_MAJOR
MinorTbl        EQU     MMX_TCOEFF_MINOR
RunTbl          EQU     TAB_ZZ_RUN
Scale           EQU     MMX_Scale
PITCH   		=   384

IACODE1 SEGMENT

MMX_VLD_RLD_IQ_Block PROC C

;  Stack Use
FRAMESIZE		=	 12					; 12 bytes locals

;  local variables
lpN				EQU		esp+00			; pointer to number of coef. decoded
lBitsInOut      EQU		esp+04			; bit offset
lCumulativeRun	EQU		esp+08			; cumulative run

;  saved registers
;	ebx					esp+12
;	edi					esp+16
;	esi					esp+20
;	ebp					esp+24

;  return address       esp+28

;  input parameters
lpBlockAction 	EQU		esp+32		
lpSrc			EQU		esp+36
uBitsReadIn		EQU		esp+40
pN				EQU		esp+44
pIQ_INDEX		EQU		esp+48

; save registers
	push      ebp
	push      esi
	 
	push      edi			
	push      ebx

	sub       esp, FRAMESIZE
 	xor       eax, eax					; zero eax for quantizer & coef. counter

;
; initialize
;
	movd      mm5, [Round]				; mm5 = rounding value

	movd      mm6, [TopClip]			; mm6 = TopClip

	movd      mm7, [LowClip]			; mm7 = LowClip

	mov       ebx, -1					; beginning cumulative run value
 	mov       edx, [pN]					; fetch pointer to coefficient read

	mov       [lpN], edx				; store pN pointer locally
	mov       ecx, [uBitsReadIn]		; fetch bits read in

	mov       [lCumulativeRun], ebx		; init cumulative run to -1
	mov       ebx, ecx					; copy bits read to ebx

	mov       [lBitsInOut], ecx			; store bits read locally
	mov       edx, [lpBlockAction]      ; fetch block action pointer

	and       ecx, 7					; mask the shift value for input
	mov       esi, [lpSrc]  			; fetch bitstream source pointer

	shr       ebx, 3					; compute offset for input
	mov       al, [edx+3]				; fetch quantizer

 	shl	      eax, 16					; 2*quantizer to high order word
	mov       dl, [edx]					; fetch block type (save it in dl)

	movd      mm2, eax					; mm2 = quantizer (Q)

	sub       eax, 10000h
	xor       ebp, ebp					; got inputs, init coefficient counter

	or        eax, 10000h
	cmp       dl, 1						; check for INTRA block type

	movd      mm3, eax					; mm3 = Q if odd, else = Q-1
	paddw     mm2, mm2                  ; mm2 = 2*quantizer (2Q)

	mov       edi, [pIQ_INDEX]			; fetch coefficient output pointer
	ja        get_next_coefficient		; if type 2 or larger, no INTRADC
	 
;
; Decode INTRADC
;
;	uses dword load & bitswap to achieve big endian ordering.
;	prior code prepares ebx, cl, and dl as follows:
;		ebx = lBitsInOut>>3
;		cl  = lBitsInOut&7
;		dl  = BlockType (0=INTRA_DC, 1=INTRA, 2=INTER, etc.)
;
	mov       eax, [esi+ebx]			; *** PROBABLE MALALIGNMENT ***
	inc       ebp						; one coefficient decoded

	bswap     eax						; big endian order
										; *** NOT PAIRABLE ***

	shl       eax, cl					; left justify bitstream buffer
										; *** NOT PAIRABLE ***
										; *** 4 CYCLES ***

	shr       eax, 17					; top 11 bits to bits 14-04
 	mov       ecx, [lBitsInOut]			; ecx = lBitsInOut

	and       eax, 07f80h				; mask to get scaled coeff.
	add       ecx, 8					; bits used += 8 for INTRADC

	cmp       eax, 07f80h				; check for 11111111 codeword
	jne       @f

	mov       eax, 04000h				; 11111111 decodes to 400h = 1024 

@@:
	mov       [lBitsInOut], ecx			;  update bits used
	xor       ebx, ebx

	mov       [lCumulativeRun], ebx		; save total run (starts with zero)
	mov       [edi], eax				; save decoded DC coefficient

	mov       [edi+4], ebx				; save 0 index
	mov       ebx, ecx					; ebx = lBitsInOut

	shr       ebx, 3					; offset for input
	add       edi, 8					; update coefficient pointer

;  check 