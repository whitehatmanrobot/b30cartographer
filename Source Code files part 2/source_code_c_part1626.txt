  
                pAddress->get_Label( &bstrLabel );

                LOG((RTC_INFO, "CMainFrm::OnRedialSelect - "
                                "Call [%ws]", bstrAddress));

                if ( m_pControlIntf != NULL )
                {
                    //
                    // Place the call
                    //

                    Call((enType == RTCAT_PHONE),   // bCallPhone
                         bstrLabel,                 // pDestName
                         bstrAddress,               // pDestAddress
                         FALSE                      // bDestAddressEditable
                         );
                }

                SysFreeString(bstrLabel);
            }
            SysFreeString(bstrAddress);
        }
    }
    else
    {
        LOG((RTC_ERROR, "CMainFrm::OnRedialSelect - "
                            "GetMenuItemInfo failed"));
    }
    
    LOG((RTC_INFO, "CMainFrm::OnRedialSelect - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnKeypadButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    // LOG((RTC_INFO, "CMainFrm::OnKeypadButton - enter"));

    if ((wNotifyCode == BN_CLICKED) || (wNotifyCode == 1))
    {
        if (::IsWindowEnabled( GetDlgItem(wID) ))
        {
            if(wNotifyCode == 1)
            {
                // Do visual feedback
                ::SendMessage(GetDlgItem(wID), BM_SETSTATE, (WPARAM)TRUE, 0);
                
                // Set a timer for depressing the key
                // 
                if (0 == SetTimer(wID - ID_KEYPAD0 + TID_KEYPAD_TIMER_BASE, 150))
                {
                    LOG((RTC_ERROR, "CMainFrm::OnKeypadButton - failed to create a timer"));

                    // revert the button if SetTimer has failed
                    ::SendMessage(GetDlgItem(wID), BM_SETSTATE, (WPARAM)FALSE, 0);
                }
            }

            if (m_pClientIntf != NULL)
            {
                m_pClientIntf->SendDTMF((RTC_DTMF)(wID - ID_KEYPAD0));
            }
        }
    }
    else
    {
        bHandled = FALSE;
    }
    
    // LOG((RTC_INFO, "CMainFrm::OnKeypadButton - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnPresenceSelect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnPresenceSelect - enter"));

    RTC_PRESENCE_STATUS enStatus;

    switch(wID)
    {
    case IDM_PRESENCE_ONLINE:
        enStatus = RTCXS_PRESENCE_ONLINE;
        break;
    
    case IDM_PRESENCE_OFFLINE:
        enStatus = RTCXS_PRESENCE_OFFLINE;
        break;

    case IDM_PRESENCE_AWAY:
    case IDM_PRESENCE_CUSTOM_AWAY:
        enStatus = RTCXS_PRESENCE_AWAY;
        break;

    case IDM_PRESENCE_BUSY:
    case IDM_PRESENCE_CUSTOM_BUSY:
        enStatus = RTCXS_PRESENCE_BUSY;
        break;

    case IDM_PRESENCE_ON_THE_PHONE:
        enStatus = RTCXS_PRESENCE_ON_THE_PHONE;
        break;

    case IDM_PRESENCE_BE_RIGHT_BACK:
        enStatus = RTCXS_PRESENCE_BE_RIGHT_BACK;
        break;
    
    case IDM_PRESENCE_OUT_TO_LUNCH:
        enStatus = RTCXS_PRESENCE_OUT_TO_LUNCH;
        break;

    }

    CCustomPresenceDlgParam Param;
    Param.bstrText = NULL;

    if( wID == IDM_PRESENCE_CUSTOM_AWAY 
      || wID == IDM_PRESENCE_CUSTOM_BUSY )
    {
        Param.bstrText = SysAllocString(m_bstrLastCustomStatus);

        CCustomPresenceDlg      dlg;

        INT_PTR     iRet = dlg.DoModal(
            m_hWnd, reinterpret_cast<LPARAM>(&Param));

        if(iRet == E_ABORT)
        {
            LOG((RTC_INFO, "CMainFrm::OnPresenceSelect - dialog dismissed, exiting"));
            SysFreeString(Param.bstrText);

            return 0;
        }
    }

    if(m_pClientIntf)
    {
        IRTCClientPresence * pClientPresence = NULL;

        hr = m_pClientIntf->QueryInterface(
            IID_IRTCClientPresence,
            (void **)&pClientPresence);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::OnPresenceSelect - "
                        "error (%x) returned by QI, exit", hr));

            SysFreeString(Param.bstrText);
            return 0;
        }

        hr = pClientPresence->SetLocalPresenceInfo(enStatus, Param.bstrText);

        RELEASE_NULLIFY(pClientPresence);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::OnPresenceSelect - "
                                "SetLocalPresenceInfo failed 0x%lx", hr));
        }
        else
        {
            if(Param.bstrText && *Param.bstrText)
            {
                SysFreeString(m_bstrLastCustomStatus);
                m_bstrLastCustomStatus = SysAllocString(Param.bstrText);
            }
            
            CheckMenuRadioItem(m_hPresenceStatusMenu, IDM_PRESENCE_ONLINE, IDM_PRESENCE_CUSTOM_AWAY, wID, MF_BYCOMMAND);
        }
    }

    SysFreeString(Param.bstrText);

    LOG((RTC_INFO, "CMainFrm::OnPresenceSelect - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr;

    //LOG((RTC_INFO, "CMainFrm::OnCustomDraw"));

    //
    // Is this for the buddy list?
    //
    if (pnmh->hwndFrom == m_hBuddyList)
    {
        LPNMLVCUSTOMDRAW pCD = (LPNMLVCUSTOMDRAW)pnmh;

        if (pCD->nmcd.dwDrawStage == CDDS_PREPAINT)
        {
            return CDRF_NOTIFYITEMDRAW;
        }
        else if (pCD->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
        {
            if (m_hPalette)
            {
                SelectPalette(pCD->nmcd.hdc, m_hPalette, m_bBackgroundPalette);
                RealizePalette(pCD->nmcd.hdc);
            }

            return CDRF_DODEFAULT;
        }

    }

    bHandled = FALSE;

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnToolbarDropDown(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnToolbarDropDown - enter"));

    LPNMTOOLBAR pNMToolBar = (LPNMTOOLBAR)pnmh;

    if ( (pNMToolBar->iItem >= IDC_MENU_ITEM) && (pNMToolBar->iItem <= IDC_MENU_ITEM_MAX) )
    {
        LOG((RTC_INFO, "CMainFrm::OnToolbarDropDown - IDC_MENU_ITEM + %d", pNMToolBar->iItem - IDC_MENU_ITEM));
        
        //
        // Create a popup menu
        //

        RECT        rc;
        TPMPARAMS   tpm;

        ::SendMessage(pnmh->hwndFrom, TB_GETRECT, (WPARAM)pNMToolBar->iItem, (LPARAM)&rc);

        ::MapWindowPoints(pnmh->hwndFrom, HWND_DESKTOP, (LPPOINT)&rc, 2);                         

        tpm.cbSize = sizeof(TPMPARAMS);
        tpm.rcExclude.top    = rc.top;
        tpm.rcExclude.left   = rc.left;
        tpm.rcExclude.bottom = rc.bottom;
        tpm.rcExclude.right  = rc.right;       
        
        //
        // Get the menu
        //

        HMENU hSubMenu;
        
        hSubMenu = GetSubMenu(m_hMenu, pNMToolBar->iItem - IDC_MENU_ITEM);

        //
        // Init the menu
        //

        BOOL bHandled = TRUE;

        OnInitMenuPopup(WM_INITMENUPOPUP, (WPARAM)hSubMenu, MAKELPARAM(pNMToolBar->iItem - IDC_MENU_ITEM, FALSE), bHandled);

        //
        // Install the MenuAgent
        //

        m_MenuAgent.InstallHook(m_hWnd, m_hToolbarMenuCtl, hSubMenu);

        //
        // Show the menu
        //

        BOOL fResult;

        fResult = TrackPopupMenuEx(hSubMenu, TPM_LEFTALIGN|TPM_LEFTBUTTON|TPM_VERTICAL|TPM_NOANIMATION,             
                                      rc.left, rc.bottom, m_hWnd, &tpm);

        //
        // Remove the MenuAgent
        //

        m_MenuAgent.RemoveHook();

        if ( fResult == FALSE )
        {           
            LOG((RTC_ERROR, "CMainFrm::OnToolbarDropDown - "
                    "TrackPopupMenuEx failed"));

            return 0;
        } 

        //
        // If the menu was cancelled, we should put up the new menu
        //

        switch(m_MenuAgent.WasCancelled())
        {

        case MENUAGENT_CANCEL_HOVER:
            {
                // Get the accelerator key
                TCHAR szButtonText[256];

                SendMessage(m_hToolbarMenuCtl, TB_GETBUTTONTEXT, m_nLastHotItem, (LPARAM)szButtonText);

                TCHAR key = GetAccelerator(szButtonText, TRUE);

                // Send the key to the menu
                ::PostMessage(m_hToolbarMenuCtl, WM_KEYDOWN, key, 0);
            }
            break;

        case MENUAGENT_CANCEL_LEFT:
            {
                int nItem;

                if (pNMToolBar->iItem == IDC_MENU_ITEM)
                {
                    nItem = (int)::SendMessage(m_hToolbarMenuCtl, TB_BUTTONCOUNT, 0,0) + IDC_MENU_ITEM - 1;
                }
                else
                {
                    nItem = pNMToolBar->iItem - 1;
                }

                // Get the accelerator key
                TCHAR szButtonText[256];

                SendMessage(m_hToolbarMenuCtl, TB_GETBUTTONTEXT, nItem, (LPARAM)szButtonText);

                TCHAR key = GetAccelerator(szButtonText, TRUE);

                // Send the key to the menu
                ::PostMessage(m_hToolbarMenuCtl, WM_KEYDOWN, key, 0);
            }
            break;

        case MENUAGENT_CANCEL_RIGHT:
            {
                int nItem;

                if (pNMToolBar->iItem == (::SendMessage(m_hToolbarMenuCtl, TB_BUTTONCOUNT, 0,0) + IDC_MENU_ITEM - 1))
                {
                    nItem = IDC_MENU_ITEM;
                }
                else
                {
                    nItem = pNMToolBar->iItem + 1;
                }

                // Get the accelerator key
                TCHAR szButtonText[256];

                SendMessage(m_hToolbarMenuCtl, TB_GETBUTTONTEXT, nItem, (LPARAM)szButtonText);

                TCHAR key = GetAccelerator(szButtonText, TRUE);

                // Send the key to the menu
                ::PostMessage(m_hToolbarMenuCtl, WM_KEYDOWN, key, 0);
            }
            break;
        }

    }

    LOG((RTC_INFO, "CMainFrm::OnToolbarDropDown - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnToolbarHotItemChange(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr;

    // LOG((RTC_INFO, "CMainFrm::OnToolbarHotItemChange - enter"));

    LPNMTBHOTITEM pHotItem = (LPNMTBHOTITEM)pnmh;

//    LOG((RTC_INFO, "CMainFrm::OnToolbarHotItemChange - idOld [%d] idNew [%d]",
//        pHotItem->idOld, pHotItem->idNew));

//  LOG((RTC_INFO, "CMainFrm::OnToolbarHotItemChange - m_nLastHotItem [%d]",
//        m_nLastHotItem));

    if (!(pHotItem->dwFlags & HICF_LEAVING))
    {                        
        if (m_nLastHotItem != pHotItem->idNew)
        {
            //
            // A new hot item was selected
            //

            if (m_MenuAgent.IsInstalled())
            {
                //
                // Cancel the menu
                //

                m_MenuAgent.CancelMenu(MENUAGENT_CANCEL_HOVER);
            }
        }

        m_nLastHotItem = pHotItem->idNew;
    }

    // LOG((RTC_INFO, "CMainFrm::OnToolbarHotItemChange - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::CreateRedialPopupMenu()
{
    MENUITEMINFO    mii; 
    HRESULT         hr;

    LOG((RTC_TRACE, "CMainFrm::CreateRedialPopupMenu - enter"));

    //
    // Load the image lists
    //

    HBITMAP hBitmap;

    if ( m_hRedialImageList == NULL )
    {
        m_hRedialImageList = ImageList_Create(BITMAPMENU_DEFAULT_WIDTH,
                                              BITMAPMENU_DEFAULT_WIDTH,
                                              ILC_COLOR8 | ILC_MASK , 2, 2);
        if (m_hRedialImageList)
        {       
            // Open a bitmap
            hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_REDIAL_NORMAL));
            if(hBitmap)
            {
                // Add the bitmap to the image list
                ImageList_AddMasked(m_hRedialImageList, hBitmap, BMP_COLOR_MASK);

                DeleteObject(hBitmap);
                hBitmap = NULL;
            }
        }
    }

    if ( m_hRedialDisabledImageList == NULL )
    {
        m_hRedialDisabledImageList = ImageList_Create(BITMAPMENU_DEFAULT_WIDTH,
                                              BITMAPMENU_DEFAULT_WIDTH,
                                              ILC_COLOR8 | ILC_MASK , 2, 2);
        if (m_hRedialDisabledImageList)
        {       
            // Open a bitmap
            hBitmap = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_REDIAL_DISABLED));
            if(hBitmap)
            {
                // Add the bitmap to the image list
                ImageList_AddMasked(m_hRedialDisabledImageList, hBitmap, BMP_COLOR_MASK);

                DeleteObject(hBitmap);
                hBitmap = NULL;
            }
        }
    }

    //
    // Destroy the old menu if it exists
    //

    if ( m_hRedialPopupMenu != NULL )
    {
        DestroyMenu( m_hRedialPopupMenu );
        m_hRedialPopupMenu = NULL;
    }

    //
    // Create the popup menu
    //

    m_hRedialPopupMenu = CreatePopupMenu();

    if ( m_hRedialPopupMenu == NULL )
    {
        LOG((RTC_ERROR, "CMainFrm::CreateRedialPopupMenu - "
                "CreatePopupMenu failed %d", GetLastError() ));

        return NULL;
    }

    //
    // Add it as a submenu of the call menu
    //

    ZeroMemory( &mii, sizeof(MENUITEMINFO) );

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = m_hRedialPopupMenu;

    SetMenuItemInfo( m_hMenu, IDM_CALL_REDIAL_MENU, FALSE, &mii );


    //
    // Attach it to the notifyMenu too..
    //

    SetMenuItemInfo( m_hNotifyMenu, IDM_CALL_REDIAL_MENU, FALSE, &mii );


    //
    // Release the old enumeration if it exists
    //

    RELEASE_NULLIFY( m_pRedialAddressEnum);

    //
    // Enumerate addresses to populate the menu
    //  

    hr = EnumerateMRUAddresses( &m_pRedialAddressEnum );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::CreateRedialPopupMenu - "
                "EnumerateMRUAddresses failed 0x%lx", hr));

        DestroyMenu( m_hRedialPopupMenu );
        m_hRedialPopupMenu = NULL;

        return NULL;
    }

    IRTCAddress       * pAddress = NULL;
    BSTR                bstrLabel = NULL;
    BSTR                bstrAddress = NULL;
    TCHAR               szString[256];
    ULONG               ulCount = 0;

    while ( m_pRedialAddressEnum->Next( 1, &pAddress, NULL) == S_OK )
    {     
        hr = pAddress->get_Address(&bstrAddress);

        if (SUCCEEDED(hr))
        {
            hr = pAddress->get_Label(&bstrLabel);

            //
            // Build the string
            //

            if (SUCCEEDED(hr))
            {                             
                _stprintf(szString, _T("%ws: %ws"), bstrLabel, bstrAddress);

                SysFreeString(bstrLabel);
                bstrLabel = NULL;
            }
            else
            {
                _stprintf(szString, _T("%ws"), bstrAddress);
            }

            SysFreeString(bstrAddress);
            bstrAddress = NULL;

            //
            // Add the menu item
            //

            ZeroMemory( &mii, sizeof(MENUITEMINFO) );
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE | MIIM_DATA;
            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED;
            mii.wID = IDM_REDIAL + ulCount;
            mii.dwTypeData = szString;
            mii.dwItemData = (ULONG_PTR)pAddress; // enum holds ref
            mii.cch = lstrlen(szString);

            InsertMenuItem( m_hRedialPopupMenu, ulCount, TRUE, &mii);

            //
            // Make item owner drawn
            //

            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_STRING | MFT_OWNERDRAW;

            SetMenuItemInfo( m_hRedialPopupMenu, ulCount, TRUE, &mii);
           
            ulCount++;            
        }

        RELEASE_NULLIFY(pAddress);
    }

    if ( ulCount == 0 )
    {
        //
        // We didn't have any addresses to add. Put a "(empty)" entry.
        //

        TCHAR   szString[256];

        LoadString(_Module.GetResourceInstance(),
               IDS_REDIAL_NONE,
               szString,
               256);

        ZeroMemory( &mii, sizeof(MENUITEMINFO) );
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_DISABLED | MFS_GRAYED;
        mii.wID = IDM_REDIAL + ulCount;
        mii.dwTypeData = szString;
        mii.cch = lstrlen(szString);

        InsertMenuItem( m_hRedialPopupMenu, ulCount, TRUE, &mii);
    }

    LOG((RTC_TRACE, "CMainFrm::CreateRedialPopupMenu - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::DestroyRedialPopupMenu()
{
    LOG((RTC_TRACE, "CMainFrm::DestroyRedialPopupMenu - enter"));

    //
    // Remove it as a submenu of the call menu
    //

    MENUITEMINFO mii;

    ZeroMemory( &mii, sizeof(MENUITEMINFO) );

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = NULL;

    SetMenuItemInfo( m_hMenu, IDM_CALL_REDIAL_MENU, FALSE, &mii );

    //
    // Destroy the menu
    // 

    if ( m_hRedialPopupMenu != NULL )
    {
        DestroyMenu( m_hRedialPopupMenu );
        m_hRedialPopupMenu = NULL;
    }

    //
    // Release the enumeration
    //

    RELEASE_NULLIFY( m_pRedialAddressEnum );

    //
    // Destroy the image lists
    //

    if ( m_hRedialImageList != NULL )
    {
        ImageList_Destroy( m_hRedialImageList );
        m_hRedialImageList = NULL;
    }

    if ( m_hRedialDisabledImageList != NULL )
    {
        ImageList_Destroy( m_hRedialDisabledImageList );
        m_hRedialDisabledImageList = NULL;
    }

    LOG((RTC_TRACE, "CMainFrm::DestroyRedialPopupMenu - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnAutoAnswer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnAutoAnswer - enter"));

    ATLASSERT(m_pControlIntf.p);

    UINT    iSetting = GetMenuState(m_hMenu, IDM_CALL_AUTOANSWER, MF_BYCOMMAND);

    m_bAutoAnswerMode = !(iSetting & MF_CHECKED);

    CheckMenuItem(m_hMenu, IDM_CALL_AUTOANSWER, m_bAutoAnswerMode ? MF_CHECKED : MF_UNCHECKED);  

    put_SettingsDword( SD_AUTO_ANSWER, m_bAutoAnswerMode ? 1 : 0 );
    
    // We have to update the menu for the notify icon too..
    CheckMenuItem(m_hNotifyMenu, IDM_CALL_AUTOANSWER, m_bAutoAnswerMode ? MF_CHECKED : MF_UNCHECKED);  

    // control the DND menu
    EnableMenuItem(m_hMenu, IDM_CALL_DND, m_bAutoAnswerMode ? MF_GRAYED : MF_ENABLED);
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_DND, m_bAutoAnswerMode ? MF_GRAYED : MF_ENABLED);

    LOG((RTC_INFO, "CMainFrm::OnAutoAnswer - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnDND(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnDND - enter"));

    ATLASSERT(m_pControlIntf.p);

    UINT    iSetting = GetMenuState(m_hMenu, IDM_CALL_DND, MF_BYCOMMAND);

    m_bDoNotDisturb = !(iSetting & MF_CHECKED);

    CheckMenuItem(m_hMenu, IDM_CALL_DND, m_bDoNotDisturb ? MF_CHECKED : MF_UNCHECKED);  

    // We have to update the menu for the notify icon too..
    CheckMenuItem(m_hNotifyMenu, IDM_CALL_DND, m_bDoNotDisturb ? MF_CHECKED : MF_UNCHECKED);  
    
    // control the aitoanswer menu
    EnableMenuItem(m_hMenu, IDM_CALL_AUTOANSWER, m_bDoNotDisturb ? MF_GRAYED : MF_ENABLED);
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_AUTOANSWER, m_bDoNotDisturb ? MF_GRAYED : MF_ENABLED);

    LOG((RTC_INFO, "CMainFrm::OnDND - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnIncomingVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    LONG        lMediaPreferences;

    LOG((RTC_INFO, "CMainFrm::OnIncomingVideo - enter"));

    ATLASSERT(m_pControlIntf.p);

    // this doesn't fail
    m_pControlIntf -> get_MediaPreferences(&lMediaPreferences);

    // toggle the setting
    lMediaPreferences ^= RTCMT_VIDEO_RECEIVE;

    // set it

    hr = m_pControlIntf -> put_MediaPreferences(lMediaPreferences);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnIncomingVideo - "
                    "error (%x) returned by put_MediaPreferences, exit", hr));

        return 0;
    }
    
    LOG((RTC_INFO, "CMainFrm::OnIncomingVideo - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnOutgoingVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    LONG        lMediaPreferences;
    LOG((RTC_INFO, "CMainFrm::OnOutgoingVideo - enter"));

    ATLASSERT(m_pControlIntf.p);


    // this doesn't fail
    m_pControlIntf -> get_MediaPreferences(&lMediaPreferences);

    // toggle the setting
    lMediaPreferences ^= RTCMT_VIDEO_SEND;

    // set it
    hr = m_pControlIntf -> put_MediaPreferences(lMediaPreferences);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnOutgoingVideo - "
                    "error (%x) returned by put_MediaPreferences, exit", hr));

        return 0;
    }
    
  
    LOG((RTC_INFO, "CMainFrm::OnOutgoingVideo - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnVideoPreview(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    BOOL        bVideoPreference;
    
    LOG((RTC_INFO, "CMainFrm::OnVideoPreview - enter"));

    ATLASSERT(m_pControlIntf.p);

    // this doesn't fail
    m_pControlIntf -> get_VideoPreview(&bVideoPreference);

    // toggle the setting
    bVideoPreference = !bVideoPreference;

    // set it
    hr = m_pControlIntf -> put_VideoPreview(bVideoPreference);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnVideoPreview - "
                    "error (%x) returned by put_VideoPreview, exit", hr));

        return 0;
    }
    
  
    LOG((RTC_INFO, "CMainFrm::OnVideoPreview - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnMuteSpeaker(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    BOOL        bSetting;

    LOG((RTC_INFO, "CMainFrm::OnMuteSpeaker - enter"));

    ATLASSERT(m_pControlIntf.p);

    // this doesn't fail
    hr = m_pControlIntf -> get_AudioMuted(RTCAD_SPEAKER, &bSetting);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnMuteSpeaker - "
                    "error (%x) returned by get_AudioMuted, exit", hr));

        return 0;
    }
    
    // toggle
    bSetting = !bSetting;

    // set it

    hr = m_pControlIntf -> put_AudioMuted(RTCAD_SPEAKER, bSetting);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnMuteSpeaker - "
                    "error (%x) returned by put_AudioMuted, exit", hr));

        return 0;
    }
    
   
    LOG((RTC_INFO, "CMainFrm::OnMuteSpeaker - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnMuteMicrophone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    BOOL        bSetting;

    LOG((RTC_INFO, "CMainFrm::OnMuteMicrophone - enter"));

    ATLASSERT(m_pControlIntf.p);

    // this doesn't fail
    hr = m_pControlIntf -> get_AudioMuted(RTCAD_MICROPHONE, &bSetting);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnMuteMicrophone - "
                    "error (%x) returned by get_AudioMuted, exit", hr));

        return 0;
    }
    
    // toggle
    bSetting = !bSetting;

    // set it

    hr = m_pControlIntf -> put_AudioMuted(RTCAD_MICROPHONE, bSetting);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnMuteMicrophone - "
                    "error (%x) returned by put_AudioMuted, exit", hr));

        return 0;
    }
    
   
    LOG((RTC_INFO, "CMainFrm::OnMuteMicrophone - exit"));

    return 0;
}
/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnNameOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    DWORD       dwMinimizeOnClose;
    
    LOG((RTC_INFO, "CMainFrm::OnNameOptions - enter"));

    if (m_pClientIntf != NULL)
    {
        INT_PTR ipReturn = ShowNameOptionsDialog(m_hWnd, m_pClientIntf);
      
        if(ipReturn < 0)
        {
            LOG((RTC_ERROR, "CMainFrm::OnNameOptions - "
                        "error (%d) returned by DialogBoxParam, exit", ipReturn));

            return 0;
        }

        // Read the content of the registry and set the flag for enabling MinimizeOnClose
        hr = get_SettingsDword(
                                SD_MINIMIZE_ON_CLOSE, 
                                &dwMinimizeOnClose);

        if ( SUCCEEDED( hr ) )
        {
            if (dwMinimizeOnClose == BST_CHECKED)
            {
                m_fMinimizeOnClose = TRUE;
            }
            else
            {
                m_fMinimizeOnClose = FALSE;
            }
        }
    }

    LOG((RTC_INFO, "CMainFrm::OnNameOptions - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnCallFromOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnCallFromOptions - enter"));

    ATLASSERT(m_pControlIntf.p);

    hr = m_pControlIntf -> ShowCallFromOptions();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnCallFromOptions - "
                    "error (%x) returned by ShowCallFromOptions, exit", hr));

        return 0;
    }

    UpdateFrameVisual();

    LOG((RTC_INFO, "CMainFrm::OnCallFromOptions - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnUserPresenceOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnUserPresenceOptions - enter"));

    ATLASSERT(m_pClientIntf.p);
    
    CUserPresenceInfoDlgParam   Param;

    IRTCClientPresence * pClientPresence = NULL;

    hr = m_pClientIntf->QueryInterface(
        IID_IRTCClientPresence,
        (void **)&pClientPresence);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnCallFromOptions - "
                    "error (%x) returned by QI, exit", hr));

        return 0;
    }

    Param.pClientPresence = pClientPresence;

    CUserPresenceInfoDlg   dlg;

    INT_PTR iRet = dlg.DoModal(
        m_hWnd,
        reinterpret_cast<LPARAM>(&Param));

    RELEASE_NULLIFY( pClientPresence );

    if(iRet == -1 )
    {
        LOG((RTC_ERROR, "CMainFrm::OnCallFromOptions - "
                    "error -1 (%x) returned by DoModal, exit", GetLastError()));

        return 0;
    }
    LOG((RTC_INFO, "CMainFrm::OnUserPresenceOptions - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnWhiteboard(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    LONG        lMediaPreferences;

    LOG((RTC_INFO, "CMainFrm::OnWhiteboard - enter"));

    ATLASSERT(m_pControlIntf.p);

    // this doesn't fail
    m_pControlIntf -> get_MediaPreferences(&lMediaPreferences);

    // Mark the setting
    lMediaPreferences |= RTCMT_T120_SENDRECV;

    // set it
    hr = m_pControlIntf -> put_MediaPreferences(lMediaPreferences);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnWhiteboard - "
                    "error (%x) returned by put_MediaPreferences, exit", hr));

        return 0;
    }
    
    hr = m_pControlIntf -> StartT120Applet(RTCTA_WHITEBOARD);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnWhiteboard - "
                    "error (%x) returned by StartT120Applet, exit", hr));

        return 0;
    } 

    LOG((RTC_INFO, "CMainFrm::OnWhiteboard - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnSharing(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;
    LONG        lMediaPreferences;

    LOG((RTC_INFO, "CMainFrm::OnSharing - enter"));

    ATLASSERT(m_pControlIntf.p);

    // this doesn't fail
    m_pControlIntf -> get_MediaPreferences(&lMediaPreferences);

    // Mark the setting
    lMediaPreferences |= RTCMT_T120_SENDRECV;

    // set it
    hr = m_pControlIntf -> put_MediaPreferences(lMediaPreferences);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnSharing - "
                    "error (%x) returned by put_MediaPreferences, exit", hr));

        return 0;
    }
    
    hr = m_pControlIntf -> StartT120Applet(RTCTA_APPSHARING);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnSharing - "
                    "error (%x) returned by StartT120Applet, exit", hr));

        return 0;
    } 

    LOG((RTC_INFO, "CMainFrm::OnSharing - exit"));

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnServiceProviderOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr;

    LOG((RTC_INFO, "CMainFrm::OnServiceProviderOptions - enter"));

    ATLASSERT(m_pControlIntf.p);

    hr = m_pControlIntf -> ShowServiceProviderOptions();

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CMainFrm::OnServiceProviderOptions - "
                    "error (%x) returned by ShowServiceProviderOptions, exit", hr));

        return 0;
    } 

    UpdateFrameVisual();
   
    LOG((RTC_INFO, "CMainFrm::OnServiceProviderOptions - exit"));

    return 0;
}
   
/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnTuningWizard(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CMainFrm::OnTuningWizard - enter"));

    if (m_pClientIntf != NULL)
    {
        HRESULT     hr;
 
        // invoke tuning wizard
        // It is modal, so the main window will be disabled for the UI input

        hr = m_pClientIntf->InvokeTuningWizard((OAHWND)m_hWnd);
    }

    LOG((RTC_TRACE, "CMainFrm::OnTuningWizard - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnHelpTopics(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND hwndHelp;

    hwndHelp = HtmlHelp(GetDesktopWindow(),
             _T("rtcclnt.chm"),
             HH_DISPLAY_TOPIC,
             0L);

    if ( hwndHelp == NULL )
    {
        DisplayMessage(
            _Module.GetResourceInstance(),
            m_hWnd,
            IDS_ERROR_NO_HELP,
            IDS_APPNAME
            );
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnAbout(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR szText[256];

    LoadString(_Module.GetResourceInstance(),
               IDS_APPNAME,
               szText,
               256);

    ShellAbout(m_hWnd,
               szText,
               _T(""),
              m_hIcon);
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
// Enhances the default IsDialogMessage with a TranslateAccelerator behavior
// 
//

BOOL CMainFrm::IsDialogMessage(LPMSG lpMsg)
{
    // is there  any modeless dialog open

    static BOOL bJustTurnedMenuOff = FALSE;
    static POINT ptLastMove = {0};

    // incoming call ?
    if(m_pIncomingCallDlg && m_pIncomingCallDlg->m_hWnd)
    {
        // delegate to it
        return m_pIncomingCallDlg->IsDialogMessage(lpMsg);
    }

    if ( m_bWindowActive )
    {   
        // apply toolbar menu accelerators
        if (m_hToolbarMenuCtl != NULL)
        {
            switch(lpMsg->message)
            {

            case WM_MOUSEMOVE:
                {
                    POINT pt;
                            
                    // In screen coords....
                    pt.x = LOWORD(lpMsg->lParam);
                    pt.y = HIWORD(lpMsg->lParam);  
            
                    // Ignore duplicate mouse move
                    if (ptLastMove.x == pt.x && 
                        ptLastMove.y == pt.y)
                    {
                        return TRUE;
                    }

                    ptLastMove = pt;
                }
                break;

            case WM_SYSKEYDOWN:
                {       
                    //LOG((RTC_TRACE, "CMainFrm::IsDialogMessage - WM_SYSKEYDOWN"));

                    if ( !(lpMsg->lParam & 0x40000000) )
                    {
                        UINT idBtn;

                        if (SendMessage(m_hToolbarMenuCtl, TB_MAPACCELERATOR, lpMsg->wParam, (LPARAM)&idBtn))
                        {
                            TCHAR szButtonText[MAX_PATH];

                            //  comctl says this one is the one, let's make sure we aren't getting
                            //  one of the unwanted "use the first letter" accelerators that it
                            //  will return.
        
                            if ((SendMessage(m_hToolbarMenuCtl, TB_GETBUTTONTEXT, idBtn, (LPARAM)szButtonText) > 0) &&
                                (GetAccelerator(szButtonText, FALSE) != (TCHAR)-1))
                            {                           
                                // Set keyboard focus to the menu
                                ::SetFocus(m_hToolbarMenuCtl);

                                // Send the key to the menu
                                ::PostMessage(m_hToolbarMenuCtl, WM_KEYDOWN, lpMsg->wParam, 0);

                                if (bJustTurnedMenuOff)
                                {
                                    // Enable the keyboard shortcuts
                                    SendMessage(m_hWnd, WM_CHANGEUISTATE,
                                        MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL), 0);
                                }

                                return TRUE;
                            }
                        }
                        else if ((lpMsg->wParam == VK_MENU) || (lpMsg->wParam == VK_F10))
                        {                        
                            if (GetFocus() == m_hToolbarMenuCtl)
                            {
                                // If focus is on the menu...

                                // Turn hot item off
                                SendMessage(m_hToolbarMenuCtl, TB_SETHOTITEM, (WPARAM)-1, 0);

                                // Clear the keyboard shortcuts
                                SendMessage(m_hWnd, WM_CHANGEUISTATE,
                                    MAKEWPARAM(UIS_SET, UISF_HIDEACCEL), 0);

                                // Bring keyboard focus back to the main window
                                ::SetFocus(m_hWnd);

                                bJustTurnedMenuOff = TRUE;
                            }
                            else
                            {
                                // Focus is not on the menu....

                                // Enable the keyboard shortcuts
                                SendMessage(m_hWnd, WM_CHANGEUISTATE,
                                    MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL), 0);

                                bJustTurnedMenuOff = FALSE;
                            }

                            return TRUE;
                        }   
                    }
                    else
                    {
                        // eat repeating key presses
                        return TRUE;
                    }
                }
                break;

            case WM_SYSKEYUP:
                {
                    if (!bJustTurnedMenuOff)
                    {
                        // Set the hot item to the first one.
                        SendMessage(m_hToolbarMenuCtl, TB_SETHOTITEM, (WPARAM)0, 0);

                        // Set keyboard focus to the menu
                        ::SetFocus(m_hToolbarMenuCtl);

                        return TRUE;
                    }              
                }
                break;

            case WM_KEYDOWN:
                {               
                    if ( !(lpMsg->lParam & 0x40000000) && (GetFocus() == m_hToolbarMenuCtl))
                    {
                        LRESULT lrHotItem;

                        if ((lrHotItem = SendMessage(m_hToolbarMenuCtl, TB_GETHOTITEM, 0, 0)) != -1)
                        {
                            if (lpMsg->wParam == VK_ESCAPE)
                            {                            
                                // If there is a hot item...

                                // Turn hot item off
                                SendMessage(m_hToolbarMenuCtl, TB_SETHOTITEM, (WPARAM)-1, 0);

                                // Clear the keyboard shortcuts
                                SendMessage(m_hWnd, WM_CHANGEUISTATE,
                                    MAKEWPARAM(UIS_SET, UISF_HIDEACCEL), 0);

                                // Bring keyboard focus back to the main window
                                ::SetFocus(m_hWnd);

                                bJustTurnedMenuOff = TRUE;

                                return TRUE;
                            }
                            else if (lpMsg->wParam == VK_RETURN)
                            {
                                // translate to a space      
                                lpMsg->wParam = VK_SPACE;
                            }
                        }
                    }
                }
                break;
            }

        }

        // apply local accelerators
        if(m_hAccelTable)
        {
            if(::TranslateAccelerator(
                m_hWnd,
                m_hAccelTable,
                lpMsg))
            {
                LOG((RTC_TRACE, "CMainFrm::IsDialogMessage - translated accelerator"));

                // Clear the keyboard shortcuts
                SendMessage(m_hWnd, WM_CHANGEUISTATE,
                    MAKEWPARAM(UIS_SET, UISF_HIDEACCEL), 0);

                if (GetFocus() == m_hToolbarMenuCtl)
                {
                    // If focus is on the menu...

                    // Turn hot item off
                    SendMessage(m_hToolbarMenuCtl, TB_SETHOTITEM, (WPARAM)-1, 0);

                    // Bring keyboard focus back to the main window
                    ::SetFocus(m_hWnd);              
                }

                bJustTurnedMenuOff = TRUE;

                return TRUE;
            }
        }
    }

    // the frame is "active"
    // try to delegate to the control first
    //
    if(m_pControlIntf!=NULL)
    {
        if(m_pControlIntf->PreProcessMessage(lpMsg) == S_OK)
        {
            return TRUE;
        }
    }

    return CWindow::IsDialogMessage(lpMsg);
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnBuddyList(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr;

    if ( (pnmh->code == NM_CLICK) || (pnmh->code == NM_RCLICK) )
    {
        LOG((RTC_INFO, "CMainFrm::OnBuddyList - click"));

        if ( m_pClientIntf != NULL )
        {
            HMENU                   hMenuResource;
            HMENU                   hMenu;
            IRTCBuddy             * pSelectedBuddy = NULL;
            MENUITEMINFO            mii;
        
            //
            // Load the popup menu
            //

            hMenuResource = LoadMenu( _Module.GetResourceInstance(),
                              MAKEINTRESOURCE(IDC_BUDDY_CONTEXT) );   

            if ( hMenuResource == NULL )
            {
                LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                        "LoadMenu failed"));

                return 0;
            }

            hMenu = GetSubMenu(hMenuResource, 0);

            EnableMenuItem (hMenu, IDM_NEW_BUDDY, MF_BYCOMMAND | MF_ENABLED );

            //
            // Was an item clicked?
            //

            HWND            hwndCtl = pnmh->hwndFrom;
            LV_HITTESTINFO  ht;
            POINT           pt;

            GetCursorPos(&pt);
            ht.pt = pt;

            ::MapWindowPoints( NULL, hwndCtl, &ht.pt, 1 );
            ListView_HitTest(hwndCtl, &ht);

            if (ht.flags & LVHT_ONITEM)
            {
                //
                // Click was on an item
                //
        
                LV_ITEM                 lvi;               
                int                     iSel;
            
                lvi.mask = LVIF_PARAM;
                lvi.iSubItem = 0;

                //
                // Get the index of the selected item
                //

                iSel = ListView_GetNextItem(hwndCtl, -1, LVNI_SELECTED);

                if (-1 != iSel)
                {
                    //
                    // Extract the IRTCContact pointer from the item
                    //
                   
                    lvi.iItem = iSel;

                    ListView_GetItem(hwndCtl, &lvi);

                    pSelectedBuddy = (IRTCBuddy *)lvi.lParam;
                }

                if ( pSelectedBuddy != NULL )
                {  
                    TCHAR szString[256];
                    ULONG ulCount = 0;

                    //
                    // We got an IRTCBuddy pointer.
                    // Enable the edit and delete menu items.
                    //

                    EnableMenuItem (hMenu, IDM_EDIT_BUDDY, MF_BYCOMMAND | MF_ENABLED );
                    EnableMenuItem (hMenu, IDM_DELETE_BUDDY, MF_BYCOMMAND | MF_ENABLED );                                    

                    // add call to buddy menu item

                    szString[0] = _T('\0');
                
                    LoadString(
                        _Module.GetModuleInstance(),
                        IDS_TEXT_CALL_BUDDY,
                        szString,
                        sizeof(szString)/sizeof(szString[0]));

                    ZeroMemory( &mii, sizeof(MENUITEMINFO) );
                    mii.cbSize = sizeof(MENUITEMINFO);
                    mii.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.fState = 
                        (m_nState == RTCAX_STATE_IDLE) ? MFS_ENABLED : (MFS_DISABLED | MFS_GRAYED);
                    mii.wID = IDM_CALL_BUDDY;

                    mii.dwTypeData = szString;
                    mii.cch = lstrlen(szString);

                    InsertMenuItem( hMenu, ulCount, TRUE, &mii);

                    ulCount++;

                    // add send message to buddy menu item

                    szString[0] = _T('\0');

                    LoadString(
                        _Module.GetModuleInstance(),
                        IDS_TEXT_SEND_MESSAGE_BUDDY,
                        szString,
                        sizeof(szString)/sizeof(szString[0]));

                    ZeroMemory( &mii, sizeof(MENUITEMINFO) );
                    mii.cbSize = sizeof(MENUITEMINFO);
                    mii.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.fState = 
                        (m_nState >= RTCAX_STATE_IDLE) ? MFS_ENABLED : (MFS_DISABLED | MFS_GRAYED);
                    mii.wID = IDM_SEND_MESSAGE_BUDDY;

                    mii.dwTypeData = szString;
                    mii.cch = lstrlen(szString);

                    InsertMenuItem( hMenu, ulCount, TRUE, &mii);

                    ulCount++;

                    //
                    // Separator
                    //
                    if ( ulCount != 0 )
                    {
                        ZeroMemory( &mii, sizeof(MENUITEMINFO) );
                        mii.cbSize = sizeof(MENUITEMINFO);
                        mii.fMask = MIIM_TYPE;
                        mii.fType = MFT_SEPARATOR;

                        InsertMenuItem( hMenu, ulCount, TRUE, &mii);
                    }
                } 
            }

            //
            // Show popup menu
            //

            UINT uID;
            BOOL fResult;
    
            uID = TrackPopupMenu( hMenu, 
                   TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, 
                   pt.x, pt.y, 0, m_hWnd, NULL);

            LOG((RTC_INFO, "CMainFrm::OnBuddyList - "
                                        "uID %d", uID));

            if ( uID == IDM_NEW_BUDDY )
            {      
                //
                // Add a new buddy
                //

                CAddBuddyDlgParam  Param;
                ZeroMemory(&Param, sizeof(Param));

                CAddBuddyDlg    dlg;

                INT_PTR iRet = dlg.DoModal(m_hWnd, reinterpret_cast<LPARAM>(&Param));
        
                if(iRet == S_OK)
                {                                
                    IRTCClientPresence * pClientPresence = NULL;

                    hr = m_pClientIntf->QueryInterface(
                        IID_IRTCClientPresence,
                        (void **)&pClientPresence);

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                    "error (%x) returned by QI, exit", hr));
                    }
                    else
                    {
                        hr = pClientPresence->AddBuddy( Param.bstrEmailAddress,
                                                        Param.bstrDisplayName,
                                                        NULL,
                                                        VARIANT_TRUE,
                                                        NULL,
                                                        0,
                                                        NULL
                                                      );

                        RELEASE_NULLIFY(pClientPresence);

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                        "error (%x) returned by AddBuddy, exit", hr));
                        }
                    }

                    if(Param.bAllowWatcher)
                    {
                        hr = AddToAllowedWatchers(
                            Param.bstrEmailAddress,
                            Param.bstrDisplayName);

                        if(FAILED(hr))
                        {
                            LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                    "AddToAllowedWatchers failed 0x%lx", hr));
                        }
                    }

                    SysFreeString(Param.bstrDisplayName);
                    SysFreeString(Param.bstrEmailAddress);

                    ReleaseBuddyList();
                    UpdateBuddyList();   
                }
                else if (iRet == E_ABORT)
                {
                    LOG((RTC_INFO, "CMainFrm::OnBuddyList - "
                                "CAddBuddyDlg dismissed "));
                }
                else
                { 
                    if(iRet == -1)
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "DoModal failed 0x%lx", GetLastError()));
                    }
                    else
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "DoModal returned 0x%lx", iRet));
                    }
                }
            }
            else if ( uID == IDM_EDIT_BUDDY )
            {
                //
                // Edit this buddy
                //

                CEditBuddyDlgParam  Param;
                ZeroMemory(&Param, sizeof(Param));

                hr = pSelectedBuddy->get_Name( &Param.bstrDisplayName );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "error (%x) returned by get_Name, exit", hr));
                }

                hr = pSelectedBuddy->get_PresentityURI( &Param.bstrEmailAddress );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "error (%x) returned by get_PresentityURI, exit", hr));
                }

                CEditBuddyDlg    dlg;
    
                INT_PTR iRet = dlg.DoModal(m_hWnd, reinterpret_cast<LPARAM>(&Param));
            
                if(iRet == S_OK)
                {
                    hr = pSelectedBuddy->put_PresentityURI( Param.bstrEmailAddress );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                    "error (%x) returned by put_PresentityURI, exit", hr));
                    } 
                    else
                    {
                        hr = pSelectedBuddy->put_Name( Param.bstrDisplayName );

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                        "error (%x) returned by put_Name, exit", hr));
                        }
                             
                        ReleaseBuddyList();
                        UpdateBuddyList();      
                    }
                }
                else if (iRet == E_ABORT)
                {
                    LOG((RTC_INFO, "CMainFrm::OnBuddyList - "
                                "CEditBuddyDlg dismissed "));
                }
                else
                { 
                    if(iRet == -1)
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "DoModal failed 0x%lx", GetLastError()));
                    }
                    else
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "DoModal returned 0x%lx", iRet));
                    }
                }

                SysFreeString(Param.bstrDisplayName);
                SysFreeString(Param.bstrEmailAddress);
            }
            else if ( uID == IDM_DELETE_BUDDY )
            {
                //
                // Delete this buddy
                //

                IRTCClientPresence * pClientPresence = NULL;

                hr = m_pClientIntf->QueryInterface(
                    IID_IRTCClientPresence,
                    (void **)&pClientPresence);

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "error (%x) returned by QI, exit", hr));
                }
                else
                {
                    hr = pClientPresence->RemoveBuddy( pSelectedBuddy );

                    RELEASE_NULLIFY( pClientPresence );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                    "error (%x) returned by RemoveBuddy, exit", hr));
                    }
                }

                ReleaseBuddyList();
                UpdateBuddyList();
            }
            else if ( (uID == IDM_CALL_BUDDY) ||
                      (uID == IDM_SEND_MESSAGE_BUDDY) )
            {
                BSTR    bstrName = NULL;
                BSTR    bstrAddress = NULL;

                //
                // Get the contact name
                //
       
                hr = pSelectedBuddy->get_Name( &bstrName );

                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "get_Name failed 0x%lx", hr));
                }
                else
                {       
                    //
                    // Get the address
                    //

                    hr = pSelectedBuddy->get_PresentityURI(&bstrAddress);

                    if( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                "get_PresentityURI failed 0x%lx", hr));
                    }
                    else
                    {
                        // if address not empty
                        if(bstrAddress !=NULL && *bstrAddress!=L'\0')
                        {                        
                            if ( m_pControlIntf != NULL )
                            {                    
                                if ( uID == IDM_CALL_BUDDY )
                                {
                                    // place the call or send the message
                                    if(m_nState == RTCAX_STATE_IDLE)
                                    {
                                        //
                                        // Place the call
                                        //

                                        LOG((RTC_INFO, "CMainFrm::OnBuddyList - "
                                                "Call [%ws]", bstrAddress));

                                        hr = Call(
                                            FALSE,              // bCallPhone
                                            bstrName,           // pDestName
                                            bstrAddress,        // pDestAddress
                                            FALSE               // bDestAddressEditable
                                            );

                                        if( FAILED(hr) )
                                        {
                                            LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                                    "Call failed 0x%lx", hr));
                                        }
                                    }
                                }
                                else
                                {
                                    //
                                    // Send the message
                                    //

                                    hr = Message(
                                             bstrName,          // pDestName
                                             bstrAddress,       // pDestAddress
                                             FALSE              // bDestAddressEditable
                                             );

                                    if( FAILED(hr) )
                                    {
                                        LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                                "Message failed 0x%lx", hr));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                LOG((RTC_ERROR, "CMainFrm::OnBuddyList - "
                                    "TrackPopupMenu failed"));
            }
        
            DestroyMenu(hMenuResource);
        }
        else if ( pnmh->code == LVN_COLUMNCLICK )
        {
            LOG((RTC_INFO, "CMainFrm::OnBuddyList - column"));

            DWORD dwStyle;

            dwStyle = m_hBuddyList.GetStyle();

            if (dwStyle & LVS_SORTASCENDING)
            {
                m_hBuddyList.ModifyStyle( LVS_SORTASCENDING, LVS_SORTDESCENDING); 
            }
            else
            {
                m_hBuddyList.ModifyStyle( LVS_SORTDESCENDING, LVS_SORTASCENDING);
            } 
        
            ReleaseBuddyList();
            UpdateBuddyList();
        }
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::AddToAllowedWatchers(
        BSTR    bstrPresentityURI,
        BSTR    bstrUserName)
{

    HRESULT     hr;

    //
    // Is the new buddy already a watcher ?
    //

    IRTCWatcher        * pWatcher = NULL;
    IRTCClientPresence * pClientPresence = NULL;

    hr = m_pClientIntf->QueryInterface(
        IID_IRTCClientPresence,
        (void **)&pClientPresence);

    if ( SUCCEEDED(hr) )
    {
        hr = pClientPresence->get_Watcher(
            bstrPresentityURI,
            &pWatcher);       

        if(hr == S_OK)
        {
            // yes. Verify if it's in the allowed list:
            RTC_WATCHER_STATE       enState;

            hr = pWatcher -> get_State(&enState);
            if(SUCCEEDED(hr))
            {
                //
                // for OFFERING, don't ask (there's already a popup...)
                // for ALLOWED, don't ask
                // for BLOCKED, ask
                if(enState == RTCWS_BLOCKED)
                {
                    // Change the state of the watcher
                    hr = pWatcher->put_State(RTCWS_ALLOWED);
                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CMainFrm::AddToAllowedWatchers - "
                                    "put_State failed 0x%lx", hr));
                    }
                }
            }
        }
        else
        {
            // Add to list of allowed watchers
            hr = pClientPresence->AddWatcher(
                bstrPresentityURI,
                bstrUserName ? bstrUserName : L"",
                NULL,
                VARIANT_FALSE,
                VARIANT_TRUE,
                NULL);

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::AddToAllowedWatchers - "
                            "AddWatcher failed 0x%lx", hr));
            }
        }

        RELEASE_NULLIFY( pClientPresence );
    }
	
	RELEASE_NULLIFY( pWatcher );

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnShellNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // This function gets the WM_TIMER event from OnTimer method which catches all the
    // timer events. it passes lParam = WM_TIMER and wParam = TimerId

    // LOG((RTC_TRACE, "CMainFrm::OnShellNotify - enter"));

    static UINT nTimerId = 0;

 

    // If frame is busy, do nothing
    // XXX To implement better menus here...

    if(!IsWindowEnabled())
    {
        // LOG((RTC_TRACE, "CMainFrm::OnShellNotify - exit(disabled window)"));
        return 0;
    }

    switch(lParam)
    {
        case WM_LBUTTONUP:
        {

            if (nTimerId)
            {
                // This is a double click, so stop the timer and show the window.
                
                // LOG((RTC_TRACE, "CMainFrm::OnShellNotify - DblClick"));
                
                KillTimer(nTimerId);
        
                nTimerId = 0;
        
                ShowWindow(SW_RESTORE);
                SetForegroundWindow(m_hWnd);
            }
            else
            {
                // Set the timer so that double-click is trapped. interval is 
                // the system-configured interval for double-click.
                // LOG((RTC_TRACE, "CMainFrm::OnShellNotify - First Click"));

                nTimerId = (unsigned int)SetTimer(TID_DBLCLICK_TIMER, GetDoubleClickTime()); 
                if (nTimerId == 0)
                {
                    LOG((RTC_ERROR, "CMainFrm::OnShellNotify: Failed to "
                                    "create timer(%d)", GetLastError()));
                }
            }
            break;
        }
        case WM_RBUTTONUP:
        case WM_TIMER:
        {

            HWND hwndOwnerWindow;

            // LOG((RTC_TRACE, "CMainFrm::OnShellNotify - Showing Menu"));
            // Kill the timer
            KillTimer(nTimerId);

            nTimerId = 0;
            
            // Timer expired, and we didn't get any click, so we have to show the menu.

            SetMenuDefaultItem(m_hNotifyMenu, IDM_OPEN, FALSE);
            POINT pt;
            GetCursorPos(&pt);

            
            // Disable the status help in the main window

            m_bHelpStatusDisabled = TRUE;

            // What is the current foreground window? save it.

            HWND hwndPrev = ::GetForegroundWindow();    // to restore


            // if m_hwndHiddenWindow exists, we use it as the owner window, otherwise
            // use the main window as the owner window. 

            hwndOwnerWindow = ( ( m_hwndHiddenWindow ) ? m_hwndHiddenWindow : m_hWnd );

            // Set the owner app to foreground
            // See Q135788
            SetForegroundWindow(hwndOwnerWindow);

            // track popup menu
            

            TrackPopupMenu(
                        m_hNotifyMenu,
                        TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                        pt.x,
                        pt.y,
                        0,
                        hwndOwnerWindow,
                        NULL);

            // Enable the status help in the main window

            m_bHelpStatusDisabled = FALSE;


            // Shake the message loop
            // See Q135788

            PostMessage(WM_NULL); 

            // Restore the previous foreground window.

            if (hwndPrev)
            {
                ::SetForegroundWindow(hwndPrev);
            }

            break;
        }


    }
    
    // LOG((RTC_TRACE, "CMainFrm::OnShellNotify - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CMainFrm::OnTaskbarRestart(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr;
    
    LOG((RTC_TRACE, "CMainFrm::OnTaskbarRestart - enter"));
    
    //
    // Shell status is not active any more
    //
    m_bShellStatusActive = FALSE;
    
    //
    //  Create shell status icon
    //

    hr = CreateStatusIcon();
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CMainFrm::OnTaskbarRestart - failed to create shell icon "
                        "- 0x%08x",
                        hr));
    }

    //
    // it just sets the shell status
    //

    UpdateFrameVisual();
    
    LOG((RTC_TRACE, "CMainFrm::OnTaskbarRestart - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::ShowIncomingCallDlg(BOOL bShow)
{
    HRESULT     hr = E_UNEXPECTED;

    LOG((RTC_TRACE, "CMainFrm::ShowIncomingCallDlg(%s) - enter", bShow ? "true" : "false"));

    if(bShow)
    {
        // If the dialog is already opened, this is an error
        if(!m_pIncomingCallDlg)
        {
            // create the dialog object
            m_pIncomingCallDlg = new CIncomingCallDlg;
            if(m_pIncomingCallDlg)
            {
                HWND    hWnd;

                ATLASSERT(m_pControlIntf != NULL);

                // Create the dialog box
                hWnd = m_pIncomingCallDlg->Create(m_hWnd, reinterpret_cast<LPARAM>(m_pControlIntf.p));
                
                if(hWnd)
                {
                    // show dialog
                    m_pIncomingCallDlg->ShowWindow(SW_SHOWNORMAL);

                    // activates the app
                    SetForegroundWindow(m_hWnd);

                    // Sets the focus to the dialog
                    ::SetFocus(m_pIncomingCallDlg->m_hWnd);

                    hr = S_OK;
                }
                else
                {
                    LOG((RTC_ERROR, "CMainFrm::ShowIncomingCallDlg(true) - couldn't create dialog"));

                    delete m_pIncomingCallDlg;
                    m_pIncomingCallDlg = NULL;

                    hr = E_FAIL;
                }
            }
            else
            {
                // OOM !!!
                LOG((RTC_ERROR, "CMainFrm::ShowIncomingCallDlg - OOM"));

                hr = E_OUTOFMEMORY;
            }

        }
        else
        {
            LOG((RTC_ERROR, "CMainFrm::ShowIncomingCallDlg(true) - the dialog is already opened !!!"));

            hr = E_UNEXPECTED;
        }
    }
    else
    {
        if(m_pIncomingCallDlg)
        {
            // prevents recursive executions of the same codepath
            CIncomingCallDlg *pDialog = m_pIncomingCallDlg;

            m_pIncomingCallDlg = NULL;
            
            // close the dialog box
            if(pDialog -> m_hWnd)
            {
                // but don't close it if it is already autodestroying itself
                if(!pDialog -> IsWindowDestroyingItself())
                {
                    LOG((RTC_TRACE, "CMainFrm::ShowIncomingCallDlg(false) - going to send a CANCEL to the dlgbox"));
                    
                    pDialog->SendMessage(WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), NULL);
                }
                else
                {
                    LOG((RTC_TRACE, "CMainFrm::ShowIncomingCallDlg(false) - the dlgbox is going to autodestroy, do nothing"));
                }
            }
        }
    }

    LOG((RTC_TRACE, "CMainFrm::ShowIncomingCallDlg(%s) - exit", bShow ? "true" : "false"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::UpdateBuddyList(void)
{   
    HRESULT                hr;
    int                    nCount = 0;

    IRTCClientPresence * pClientPresence = NULL;

    if ( m_pClientIntf != NULL )
    {
        hr = m_pClientIntf->QueryInterface(
            IID_IRTCClientPresence,
            (void **)&pClientPresence);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::UpdateBuddyList - "
                        "error (%x) returned by QI, exit", hr));
        }
        else
        {
            //
            // Enumerate the buddies
            //

            IRTCEnumBuddies * pEnum;
            IRTCBuddy * pBuddy;

            hr = pClientPresence->EnumerateBuddies(&pEnum);

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CMainFrm::UpdateBuddyList - "
                            "error (%x) returned by EnumerateBuddies, exit", hr));
            }
            else
            {
                while (pEnum->Next( 1, &pBuddy, NULL) == S_OK)
                {                        
                    int      iImage = ILI_BL_NONE;
                    BSTR     bstrName = NULL;
       
                    // Process the buddy
                    hr = GetBuddyTextAndIcon(
                        pBuddy,
                        &iImage,
                        &bstrName);

                    if(SUCCEEDED(hr))
                    {
                        LVITEM              lv = {0};
                        int                 iItem;

                        //
                        // Add the buddy to the list box
                        //

                        nCount++;

                        lv.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
                        lv.iItem = 0x7FFFFFFF;
                        lv.iSubItem = 0;
                        lv.iImage = iImage;
                        lv.lParam = reinterpret_cast<LPARAM>(pBuddy);
                        lv.pszText = bstrName;

                        iItem = ListView_InsertItem(m_hBuddyList, &lv);

                        pBuddy->AddRef();

                        SysFreeString( bstrName );
                    }
                    else
                    {
                        LOG((RTC_ERROR, "CMainFrm::UpdateBuddyList - GetBuddyTextAndIcon "
                                        "failed - 0x%08x",
                                        hr));
                    }
   
                    RELEASE_NULLIFY( pBuddy );
                }

                RELEASE_NULLIFY(pEnum);
            }

            RELEASE_NULLIFY(pClientPresence);
        }

        if (nCount == 0)
        {
            //
            // Add a "No Buddies" entry
            //

            LVITEM     lv = {0};
            TCHAR      szString[256];

            LoadString(_Module.GetResourceInstance(), IDS_NO_BUDDIES, szString, 256);

            lv.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
            lv.iItem = 0x7FFFFFFF;
            lv.iSubItem = 0;
            lv.iImage = ILI_BL_BLANK;
            lv.lParam = NULL;
            lv.pszText = szString;

            ListView_InsertItem(m_hBuddyList, &lv);
        }
    }    
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::ReleaseBuddyList(void)
{
    int         iItem;
    LVITEM      lv;

    while(TRUE)
    {
        //
        // Get an item to delete
        //

        iItem = ListView_GetNextItem(m_hBuddyList, -1, 0);
        
        if(iItem<0)
        {
            //
            // No more items
            //

            break;
        }

        lv.mask = LVIF_PARAM;
        lv.iItem = iItem;
        lv.iSubItem = 0;
        lv.lParam = NULL;
        
        ListView_GetItem(m_hBuddyList, &lv);

        IRTCBuddy *pBuddy = (IRTCBuddy *)lv.lParam;

        //
        // Delete the listview entry
        //

        ListView_DeleteItem(m_hBuddyList, iItem);
        
		//
		// Release the IRTCBuddy interface
		//
		
		RELEASE_NULLIFY(pBuddy );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//

// buddy related functions
HRESULT CMainFrm::GetBuddyTextAndIcon(
        IRTCBuddy *pBuddy,
        int       *pIconID,
        BSTR      *pbstrText)
{
    HRESULT     hr;
    int         iIconID;
    BOOL        bFormatted = FALSE;
    int         iStatusID = 0;

    // offline by default
    iIconID = ILI_BL_OFFLINE;
 
    RTC_PRESENCE_STATUS enStatus;

    hr = pBuddy->get_Status( &enStatus);

    if(SUCCEEDED(hr))
    {
        switch ( enStatus )
        {
        case RTCXS_PRESENCE_OFFLINE:
            iIconID = ILI_BL_OFFLINE;
            break;

        case RTCXS_PRESENCE_ONLINE:
            iIconID = ILI_BL_ONLINE_NORMAL;
            break;

        case RTCXS_PRESENCE_AWAY:
        case RTCXS_PRESENCE_IDLE:
            iIconID = ILI_BL_ONLINE_TIME;
            iStatusID = IDS_TEXT_BUDDY_AWAY;
            bFormatted = TRUE;
            break;

        case RTCXS_PRESENCE_BUSY:
            iIconID = ILI_BL_ONLINE_BUSY;
            iStatusID = IDS_TEXT_BUDDY_BUSY;
            bFormatted = TRUE;
            break;

        case RTCXS_PRESENCE_BE_RIGHT_BACK:
            iIconID = ILI_BL_ONLINE_TIME;
            iStatusID = IDS_TEXT_BUDDY_BE_RIGHT_BACK;
            bFormatted = TRUE;
            break;

        case RTCXS_PRESENCE_ON_THE_PHONE:
            iIconID = ILI_BL_ONLINE_BUSY;
            iStatusID = IDS_TEXT_BUDDY_ON_THE_PHONE;
            bFormatted = TRUE;
            break;

        case RTCXS_PRESENCE_OUT_TO_LUNCH:
            iIconID = ILI_BL_ONLINE_TIME;
            iStatusID = IDS_TEXT_BUDDY_OUT_TO_LUNCH;
            bFormatted = TRUE;
            break;
        }
    }
    else
    {
        iIconID = ILI_BL_OFFLINE;
        bFormatted = TRUE;
        iStatusID = IDS_TEXT_BUDDY_ERROR;
    }

    BSTR    bstrName = NULL;
    
    hr = pBuddy->get_Name( &bstrName );

    if(FAILED(hr))
    {
        return hr;
    }

    if(bFormatted)
    {
        BSTR    bstrNotes = NULL;       
        TCHAR   szFormat[0x40];
        TCHAR   szText[0x40];
        DWORD   dwSize;
        LPTSTR  pString = NULL;
        LPTSTR  pszArray[2];

        szFormat[0] = _T('\0');
        LoadString(_Module.GetResourceInstance(),
            IDS_TEXT_BUDDY_FORMAT,
            szFormat,
            sizeof(szFormat)/sizeof(szFormat[0]));

        pszArray[0] = bstrName;
        pszArray[1] = NULL;

        hr = pBuddy->get_Notes( &bstrNotes );

        if ( SUCCEEDED(hr) )
        {      
            pszArray[1] = bstrNotes;
        }
        else
        {
            szText[0] = _T('\0');
            LoadString(_Module.GetResourceInstance(),
                iStatusID,
                szText,
                sizeof(szText)/sizeof(szText[0]));

            pszArray[1] = szText;
        }
        
        dwSize = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szFormat,
            0,
            0,
            (LPTSTR)&pString, // what an ugly hack
            0,
            (va_list *)pszArray
            );
        
        SysFreeString(bstrName);

        if(bstrNotes)
        {
            SysFreeString(bstrNotes);
            bstrNotes = NULL;
        }

        bstrName = SysAllocString(pString);
   
        if(pString)
        {
            LocalFree(pString);
            pString = NULL;
        }

        if(!bstrName)
        {
            return E_OUTOFMEMORY;
        }
    }
    
    *pIconID = iIconID;
    *pbstrText = bstrName;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::UpdateFrameVisual(void)
{
   
    //
    // Cancel any menu
    //

    SendMessage(WM_CANCELMODE);

    //
    // Show/Hide the center panel controls
    //

    if(m_nState <= RTCAX_STATE_IDLE)
    {
        //
        // Idle (or none or error), show the call controls
        //

        m_hMainCtl.ShowWindow(SW_HIDE);

#ifdef MULTI_PROVIDER

        m_hProviderCombo.ShowWindow(SW_SHOW);
        m_hProviderText.ShowWindow(SW_SHOW);
        m_hProviderEditList.ShowWindow(SW_SHOW);

#endif MULTI_PROVIDER

        m_hCallFromCombo.ShowWindow(SW_SHOW);
        m_hCallFromText.ShowWindow(SW_SHOW);
        m_hCallFromRadioPhone.ShowWindow(SW_SHOW);
        m_hCallFromTextPhone.ShowWindow(SW_SHOW);
        m_hCallFromRadioPC.ShowWindow(SW_SHOW);
        m_hCallFromTextPC.ShowWindow(SW_SHOW);
        m_hCallToText.ShowWindow(SW_SHOW);        
        m_hCallPCButton.ShowWindow(SW_SHOW);
        m_hCallPCText.ShowWindow(SW_SHOW);
        m_hCallPhoneButton.ShowWindow(SW_SHOW);
        m_hCallPhoneText.ShowWindow(SW_SHOW);
        m_hCallFromEditList.ShowWindow(SW_SHOW);

        if(m_nState == RTCAX_STATE_IDLE)
        {
            //
            // Disable the dialpad
            //

            m_hKeypad0.EnableWindow(FALSE);
            m_hKeypad1.EnableWindow(FALSE);
            m_hKeypad2.EnableWindow(FALSE);
            m_hKeypad3.EnableWindow(FALSE);
            m_hKeypad4.EnableWindow(FALSE);
            m_hKeypad5.EnableWindow(FALSE);
            m_hKeypad6.EnableWindow(FALSE);
            m_hKeypad7.EnableWindow(FALSE);
            m_hKeypad8.EnableWindow(FALSE);
            m_hKeypad9.EnableWindow(FALSE);
            m_hKeypadStar.EnableWindow(FALSE);
            m_hKeypadPound.EnableWindow(FALSE);

#ifdef MULTI_PROVIDER

            //
            // Repopulate service provider combo
            //

            IRTCProfile * pProfile = NULL;
            GUID CurrentProfileGuid = GUID_NULL;

            GetServiceProviderListSelection(
                m_hWnd,
                IDC_COMBO_SERVICE_PROVIDER,
                TRUE,
                &pProfile
                );

            if ( pProfile != NULL )
            {
                pProfile->get_Guid( &CurrentProfileGuid );
            }

            PopulateServiceProviderList(
                                          m_hWnd,
                                          m_pClientIntf,
                                          IDC_COMBO_SERVICE_PROVIDER,
                                          TRUE,
                                          NULL,
                                          &CurrentProfileGuid,
                                          0xF,
                                          IDS_NONE
                                         );

#endif MULTI_PROVIDER

            //
            // Repopulate call from combo
            //
        
            IRTCPhoneNumber * pPhoneNumber = NULL;
            BSTR bstrCurrentPhoneNumber = NULL;

            GetCallFromListSelection(
                                     m_hWnd,
                                     IDC_COMBO_CALL_FROM,
                                     TRUE,
                                     &pPhoneNumber
                                    );

            if ( pPhoneNumber != NULL )
            {          
                pPhoneNumber->get_Canonical( &bstrCurrentPhoneNumber );
            }

            PopulateCallFromList(
                           m_hWnd,
                           IDC_COMBO_CALL_FROM,
                           TRUE,
                           bstrCurrentPhoneNumber
                          );

            if ( bstrCurrentPhoneNumber != NULL )
            {
                SysFreeString(bstrCurrentPhoneNumber);
                bstrCurrentPhoneNumber = NULL;
            }

            //
            // Poke the service provider combo, so it updates the web browser
            // and call area controls.
            // 
            
            BOOL bHandled = TRUE;

            OnCallFromSelect(0, IDC_COMBO_SERVICE_PROVIDER, m_hProviderCombo, bHandled);            
        }
        else
        {
            // NONE or ERROR

            // disable lots of controls
            m_hCallPCButton.EnableWindow( FALSE );
            m_hCallPhoneButton.EnableWindow( FALSE );

            EnableMenuItem(m_hMenu, IDM_CALL_CALLPC, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_CALL_CALLPHONE, MF_GRAYED);
            EnableMenuItem(m_hMenu, IDM_CALL_MESSAGE, MF_GRAYED);

            EnableMenuItem(m_hNotifyMenu, IDM_CALL_CALLPC, MF_GRAYED);
            EnableMenuItem(m_hNotifyMenu, IDM_CALL_CALLPHONE, MF_GRAYED);
            EnableMenuItem(m_hNotifyMenu, IDM_CALL_MESSAGE, MF_GRAYED);
            
#ifdef MULTI_PROVIDER

            m_hProviderCombo.EnableWindow(FALSE);
            m_hProviderEditList.EnableWindow(FALSE);

#endif MULTI_PROVIDER

            m_hCallFromCombo.EnableWindow(FALSE);
            m_hCallFromRadioPhone.EnableWindow(FALSE);
            m_hCallFromRadioPC.EnableWindow(FALSE);
            m_hCallFromEditList.EnableWindow(FALSE);

            m_hKeypad0.EnableWindow(FALSE);
            m_hKeypad1.EnableWindow(FALSE);
            m_hKeypad2.EnableWindow(FALSE);
            m_hKeypad3.EnableWindow(FALSE);
            m_hKeypad4.EnableWindow(FALSE);
            m_hKeypad5.EnableWindow(FALSE);
            m_hKeypad6.EnableWindow(FALSE);
            m_hKeypad7.EnableWindow(FALSE);
            m_hKeypad8.EnableWindow(FALSE);
            m_hKeypad9.EnableWindow(FALSE);
            m_hKeypadStar.EnableWindow(FALSE);
            m_hKeypadPound.EnableWindow(FALSE);
        }
    }
    else 
    {
        //
        // Not idle, turn off the call buttons and menu items
        //

        m_hCallPCButton.EnableWindow( FALSE );
        m_hCallPhoneButton.EnableWindow( FALSE );

        EnableMenuItem(m_hMenu, IDM_CALL_CALLPC, MF_GRAYED);
        EnableMenuItem(m_hMenu, IDM_CALL_CALLPHONE, MF_GRAYED);

        EnableMenuItem(m_hNotifyMenu, IDM_CALL_CALLPC, MF_GRAYED);
        EnableMenuItem(m_hNotifyMenu, IDM_CALL_CALLPHONE, MF_GRAYED);

        if((m_nState == RTCAX_STATE_CONNECTING) ||
            (m_nState == RTCAX_STATE_ANSWERING))
        {
            //
            // Connecting a call, show the activex control
            //

            m_hMainCtl.ShowWindow(SW_SHOW);

#ifdef MULTI_PROVIDER

            m_hProviderCombo.ShowWindow(SW_HIDE);
            m_hProviderText.ShowWindow(SW_HIDE);
            m_hProviderEditList.ShowWindow(SW_HIDE);

#endif MULTI_PROVIDER

            m_hCallFromCombo.ShowWindow(SW_HIDE);
            m_hCallFromText.ShowWindow(SW_HIDE);
            m_hCallFromRadioPhone.ShowWindow(SW_HIDE);
            m_hCallFromTextPhone.ShowWindow(SW_HIDE);
            m_hCallFromRadioPC.ShowWindow(SW_HIDE);
            m_hCallFromTextPC.ShowWindow(SW_HIDE);
            m_hCallToText.ShowWindow(SW_HIDE);
            m_hCallPCButton.ShowWindow(SW_HIDE);
            m_hCallPCText.ShowWindow(SW_HIDE);
            m_hCallPhoneButton.ShowWindow(SW_HIDE);
            m_hCallPhoneText.ShowWindow(SW_HIDE);
            m_hCallFromEditList.ShowWindow(SW_HIDE);            
        }
    }

    //
    // Enable/Disable other buttons and menu items
    //

    BOOL    bRedialEnable = (m_nState == RTCAX_STATE_IDLE);
    BOOL    bHupEnable = (m_nState == RTCAX_STATE_CONNECTED ||
                          m_nState == RTCAX_STATE_CONNECTING ||
                          m_nState == RTCAX_STATE_ANSWERING);

    BOOL    bAXControlOK =    (m_nState != RTCAX_STATE_NONE &&
                               m_nState != RTCAX_STATE_ERROR );

    BOOL    bOptionsEnabled = (m_nState == RTCAX_STATE_IDLE);

    
    m_hRedialButton.EnableWindow( bRedialEnable );
    m_hHangupButton.EnableWindow( bHupEnable );
    
    EnableMenuItem(m_hMenu, IDM_CALL_REDIAL_MENU, bRedialEnable ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_CALL_HANGUP, bHupEnable ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hMenu, IDM_CALL_AUTOANSWER, bAXControlOK ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_CALL_DND, bAXControlOK ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hMenu, IDM_TOOLS_NAME_OPTIONS, bOptionsEnabled ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_TOOLS_CALL_FROM_OPTIONS, bOptionsEnabled ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_TOOLS_SERVICE_PROVIDER_OPTIONS, bOptionsEnabled ? MF_ENABLED : MF_GRAYED);
    
    EnableMenuItem(m_hMenu, IDM_TOOLS_PRESENCE_OPTIONS, bAXControlOK ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hMenu, IDM_TOOLS_WHITEBOARD, bAXControlOK ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_TOOLS_SHARING, bAXControlOK ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hMenu, IDM_TOOLS_TUNING_WIZARD, bOptionsEnabled ? MF_ENABLED : MF_GRAYED);
    
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_REDIAL_MENU, bRedialEnable ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_HANGUP, bHupEnable ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hMenu, IDM_TOOLS_PRESENCE_STATUS, bAXControlOK ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hNotifyMenu, IDM_TOOLS_PRESENCE_STATUS, bAXControlOK ? MF_ENABLED : MF_GRAYED);
    
    EnableMenuItem(m_hMenu, IDM_CALL_AUTOANSWER, bAXControlOK && !m_bDoNotDisturb
                                            ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hMenu, IDM_CALL_DND, bAXControlOK && !m_bAutoAnswerMode 
                                            ? MF_ENABLED : MF_GRAYED);

    EnableMenuItem(m_hNotifyMenu, IDM_CALL_AUTOANSWER, bAXControlOK  && !m_bDoNotDisturb
                                            ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(m_hNotifyMenu, IDM_CALL_DND, bAXControlOK && !m_bAutoAnswerMode 
                                            ? MF_ENABLED : MF_GRAYED);

    //
    // Set status line...
    //
    //  The resource ID and the resource itself are
    // provided by the RTC AX control

    if(m_pControlIntf != NULL)
    {
        // Load the string for the first part
        m_szStatusText[0] = _T('\0');

        m_pControlIntf -> LoadStringResource(
            m_nStatusStringResID,
            sizeof(m_szStatusText)/sizeof(TCHAR),
            m_szStatusText
            );

        // set the text
        m_hStatusText.SendMessage(
            WM_SETTEXT,
            (WPARAM)0,
            (LPARAM)m_szStatusText);

        //
        // Set Shell Status
        //
        TCHAR   szShellFormat[0x40];
        TCHAR   szShellStatusText[0x80];
    
        // Load the format
        szShellFormat[0] = _T('\0');

        LoadString(
            _Module.GetResourceInstance(), 
            (UINT)(IDS_FORMAT_SHELL_STATUS),
            szShellFormat,
            sizeof(szShellFormat)/sizeof(szShellFormat[0])
            );

        // format the text
        _sntprintf(
            szShellStatusText,
            sizeof(szShellStatusText)/sizeof(szShellStatusText[0]),
            szShellFormat,
            m_szStatusText);

        // set the status
        UpdateStatusIcon(NULL, szShellStatusText);

        //
        // Set the title
        //
        TCHAR   szTitle[0x80];
        TCHAR   szAppName[0x40];
        TCHAR   szTitleFormat[0x40];

        BOOL    bTitleChanged = FALSE;
        
        if(m_nState == RTCAX_STATE_CONNECTED)
        {
            if(!m_bTitleShowsConnected)
            {
                // display the app name and status
                
                // load the app name
                szAppName[0] = _T('\0');

                LoadString(
                    _Module.GetResourceInstance(),
                    IDS_APPNAME,
                    szAppName,
                    sizeof(szAppName)/sizeof(szAppName[0]));
                
                // load the format
                szTitleFormat[0] = _T('\0');

                LoadString(
                    _Module.GetResourceInstance(),
                    IDS_FORMAT_TITLE_WITH_STATUS,
                    szTitleFormat,
                    sizeof(szTitleFormat)/sizeof(szTitleFormat[0]));

                // format the string using FormatMessage 
                LPTSTR  pszArray[2];
                
                pszArray[0] = szAppName;
                pszArray[1] = m_szStatusText;

                szTitle[0] = _T('\0');

                FormatMessage(
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    szTitleFormat,
                    0,
                    0,
                    szTitle,
                    sizeof(szTitle)/sizeof(szTitle[0]) - 1,
                    (va_list *)pszArray
                    );
                
                m_bTitleShowsConnected = TRUE;

                bTitleChanged = TRUE;
            }
        }
        else
        {
            if(m_bTitleShowsConnected)
            {
                // display the app name
                szTitle[0] = _T('\0');

                LoadString(
                    _Module.GetResourceInstance(),
                    IDS_APPNAME,
                    szTitle,
                    sizeof(szTitle)/sizeof(szTitle[0]));


                m_bTitleShowsConnected = FALSE;
                
                bTitleChanged = TRUE;
            }
        }

        if(bTitleChanged)
        {
            SetWindowText(szTitle);

            InvalidateTitleBar(FALSE);
        }
    }

    //
    // manage call timer
    //

    switch(m_nState)
    {
    case RTCAX_STATE_CONNECTING:

        // "prepare" the timer - it will be started when CONNECTED
        m_bUseCallTimer = TRUE;
        
        // display timer
        ShowCallTimer();

        break;

    case RTCAX_STATE_CONNECTED:
        
        // Start the timer, if necessary
        if(m_bUseCallTimer && !m_bCallTimerActive)
        {
            StartCallTimer();

            m_bCallTimerActive = TRUE;
        }

        break;

    case RTCAX_STATE_DISCONNECTING:
    case RTCAX_STATE_IDLE:
    case RTCAX_STATE_UI_BUSY:

        // Stop the timer (if any)
        if(m_bCallTimerActive)
        {
            StopCallTimer();

            m_bCallTimerActive = FALSE;
        }
        
        m_bUseCallTimer = FALSE;

        break;

    default:

        // clear the time area
        ClearCallTimer();
        break;
    }

    //
    // Set a timer to clear the status area
    //
    if(m_nState == RTCAX_STATE_IDLE)
    {
        if(!m_bMessageTimerActive)
        {
            // Start a timer
            if(0!=SetTimer(TID_MESSAGE_TIMER, 20000))
            {
                m_bMessageTimerActive = TRUE;
            }
        }
    }
    else
    {
        if(m_bMessageTimerActive)
        {
            KillTimer(TID_MESSAGE_TIMER);

            m_bMessageTimerActive = FALSE;
        }
    }

    if(m_nState == RTCAX_STATE_CONNECTED)
    {
        // stop the browser cycling and 
        // go to "in a call" URL of the provider
        CComPtr<IRTCSession> pSession;
        CComPtr<IRTCProfile> pProfile;
        
        HRESULT hr;

        ATLASSERT(m_pControlIntf.p);

        // Get the active session
        //
        hr = m_pControlIntf -> GetActiveSession(&pSession);
        if(SUCCEEDED(hr))
        {
            //  Get the profile used for that session
            //  
            //  Don't log any error

            hr = pSession->get_Profile(&pProfile);
            if(SUCCEEDED(hr))
            {
                CComBSTR  bstrURL;
                
                // Try to get the "in a call" URL, if any
                hr = pProfile->get_ProviderURI(RTCPU_URIDISPLAYDURINGCALL, &bstrURL);
                
                if ( SUCCEEDED(hr) )
                {
                    BrowseToUrl(bstrURL);
                }
            }
        }
        else
        {
            LOG((RTC_ERROR, "CMainFrm::UpdateFrameVisual - error (%x)"
                " returned by GetActiveSession", hr));
        }
    }
}

// /////////////////////////////////////////////////////////////////////////////
// PlaceWindowsAtTheirInitialPosition
//      Positions and sizes all the controls to their "initial" position
//  This function also establishes the right tab order

void CMainFrm::PlaceWindowsAtTheirInitialPosition()
{
    HWND   hPrevious = NULL;

#define POSITION_WINDOW(m,x,y,cx,cy,f)                  \
    m.SetWindowPos(                                     \
        hPrevious,                                      \
        x,                                              \
        y,                                              \
        cx,                                             \
        cy,                                             \
        SWP_NOACTIVATE | f );                           \
    hPrevious = (HWND)m;       

    // toolbar control (no size/move)
    POSITION_WINDOW(m_hToolbarMenuCtl, 
        MENU_LEFT, MENU_TOP, 
        MENU_WIDTH, MENU_HEIGHT,
        SWP_NOZORDER);

    // close and minimize buttons
    POSITION_WINDOW(m_hCloseButton, 
        CLOSE_LEFT, CLOSE_TOP, 
        CLOSE_WIDTH, CLOSE_HEIGHT,
        0);

    POSITION_WINDOW(m_hMinimizeButton, 
        MINIMIZE_LEFT, MINIMIZE_TOP, 
        MINIMIZE_WIDTH, MINIMIZE_HEIGHT,
        0);

    // contact list
    POSITION_WINDOW(m_hBuddyList, 
        0, 0,  
        0, 0,
        SWP_NOMOVE | SWP_NOSIZE);

    // redial
    POSITION_WINDOW(m_hRedialButton, 
        REDIAL_LEFT, REDIAL_TOP, 
        REDIAL_WIDTH, REDIAL_HEIGHT,
        0);

    // hangup
    POSITION_WINDOW(m_hHangupButton, 
        HANGUP_LEFT, HANGUP_TOP, 
        HANGUP_WIDTH, HANGUP_HEIGHT,
        0);

#ifdef MULTI_PROVIDER

    // provider text
    POSITION_WINDOW(m_hProviderText, 
        PROVIDER_TEXT_LEFT, PROVIDER_TEXT_TOP, 
        PROVIDER_TEXT_WIDTH, PROVIDER_TEXT_HEIGHT,
        0);
    
    // provider combo
    POSITION_WINDOW(m_hProviderCombo, 
        PROVIDER_LEFT, PROVIDER_TOP, 
        PROVIDER_WIDTH, PROVIDER_HEIGHT,
        0);
    
    // provider edit button
    POSITION_WINDOW(m_hProviderEditList, 
        PROVIDER_EDIT_LEFT, PROVIDER_EDIT_TOP, 
        PROVIDER_EDIT_WIDTH, PROVIDER_EDIT_HEIGHT,
        0);
    
#else

    // Call to text
    POSITION_WINDOW(m_hCallToText, 
        CALLTO_TEXT_LEFT, CALLTO_TEXT_TOP, 
        CALLTO_TEXT_WIDTH, CALLTO_TEXT_HEIGHT,
        0);
    
    // Call to PC
    POSITION_WINDOW(m_hCallPCButton, 
        CALLPC_LEFT, CALLPC_TOP, 
        CALLPC_WIDTH, CALLPC_HEIGHT,
        0);

    // Call to PC text
    POSITION_WINDOW(m_hCallPCText, 
        CALLPC_TEXT_LEFT, CALLPC_TEXT_TOP, 
        CALLPC_TEXT_WIDTH, CALLPC_TEXT_HEIGHT,
        0);

    // Call to Phone
    POSITION_WINDOW(m_hCallPhoneButton, 
        CALLPHONE_LEFT, CALLPHONE_TOP, 
        CALLPHONE_WIDTH, CALLPHONE_HEIGHT,
        0);

    // Call to Phone text
    POSITION_WINDOW(m_hCallPhoneText, 
        CALLPHONE_TEXT_LEFT, CALLPHONE_TEXT_TOP, 
        CALLPHONE_TEXT_WIDTH, CALLPHONE_TEXT_HEIGHT,
        0);

#endif MULTI_PROVIDER

    // call from text
    POSITION_WINDOW(m_hCallFromText, 
        CALLFROM_TEXT_LEFT, CALLFROM_TEXT_TOP, 
        CALLFROM_TEXT_WIDTH, CALLFROM_TEXT_HEIGHT,
        0);
    
    // call pc radio
    POSITION_WINDOW(m_hCallFromRadioPC, 
        CALLFROM_RADIO1_LEFT, CALLFROM_RADIO1_TOP, 
        CALLFROM_RADIO1_WIDTH, CALLFROM_RADIO1_HEIGHT,
        0);
    
    // call from pc text
    POSITION_WINDOW(m_hCallFromTextPC, 
        CALLFROM_RADIO1_LEFT+20, CALLFROM_RADIO1_TOP, 
        CALLFROM_RADIO1_WIDTH-20, CALLFROM_RADIO1_HEIGHT,
        0);

    // call phone radio
    POSITION_WINDOW(m_hCallFromRadioPhone, 
        CALLFROM_RADIO2_LEFT, CALLFROM_RADIO2_TOP, 
        CALLFROM_RADIO2_WIDTH, CALLFROM_RADIO2_HEIGHT,
        0);
    
    // call from phone text
    POSITION_WINDOW(m_hCallFromTextPhone, 
        CALLFROM_RADIO2_LEFT+20, CALLFROM_RADIO2_TOP, 
        CALLFROM_RADIO2_WIDTH-20, CALLFROM_RADIO2_HEIGHT,
        0);

    // Call from combo
    POSITION_WINDOW(m_hCallFromCombo, 
        CALLFROM_LEFT, CALLFROM_TOP, 
        CALLFROM_WIDTH, CALLFROM_HEIGHT,
        0);
    
    // Call from edit button
    POSITION_WINDOW(m_hCallFromEditList, 
        CALLFROM_EDIT_LEFT, CALLFROM_EDIT_TOP, 
        CALLFROM_EDIT_WIDTH, CALLFROM_EDIT_HEIGHT,
        0);
    
#ifdef MULTI_PROVIDER

    // Call to text
    POSITION_WINDOW(m_hCallToText, 
        CALLTO_TEXT_LEFT, CALLTO_TEXT_TOP, 
        CALLTO_TEXT_WIDTH, CALLTO_TEXT_HEIGHT,
        0);
    
    // Call to PC
    POSITION_WINDOW(m_hCallPCButton, 
        CALLPC_LEFT, CALLPC_TOP, 
        CALLPC_WIDTH, CALLPC_HEIGHT,
        0);

    // Call to PC text
    POSITION_WINDOW(m_hCallPCText, 
        CALLPC_TEXT_LEFT, CALLPC_TEXT_TOP, 
        CALLPC_TEXT_WIDTH, CALLPC_TEXT_HEIGHT,
        0);

    // Call to Phone
    POSITION_WINDOW(m_hCallPhoneButton, 
        CALLPHONE_LEFT, CALLPHONE_TOP, 
        CALLPHONE_WIDTH, CALLPHONE_HEIGHT,
        0);

    // Call to Phone text
    POSITION_WINDOW(m_hCallPhoneText, 
        CALLPHONE_TEXT_LEFT, CALLPHONE_TEXT_TOP, 
        CALLPHONE_TEXT_WIDTH, CALLPHONE_TEXT_HEIGHT,
        0);

#endif MULTI_PROVIDER

    // AX control
    POSITION_WINDOW(m_hMainCtl, 
        0, 0,  
        0, 0,
        SWP_NOMOVE | SWP_NOSIZE);

    // dialpad buttons
#define POSITION_DIALPAD_BUTTON(s,x,y)                      \
    POSITION_WINDOW(m_hKeypad##s,                           \
        x, y, KEYPAD_WIDTH, KEYPAD_HEIGHT, 0)

    POSITION_DIALPAD_BUTTON(1,      KEYPAD_COL1,  KEYPAD_ROW1)  
    POSITION_DIALPAD_BUTTON(2,      KEYPAD_COL2,  KEYPAD_ROW1)  
    POSITION_DIALPAD_BUTTON(3,      KEYPAD_COL3,  KEYPAD_ROW1)  
    POSITION_DIALPAD_BUTTON(4,      KEYPAD_COL1,  KEYPAD_ROW2)  
    POSITION_DIALPAD_BUTTON(5,      KEYPAD_COL2,  KEYPAD_ROW2)  
    POSITION_DIALPAD_BUTTON(6,      KEYPAD_COL3,  KEYPAD_ROW2)  
    POSITION_DIALPAD_BUTTON(7,      KEYPAD_COL1,  KEYPAD_ROW3)  
    POSITION_DIALPAD_BUTTON(8,      KEYPAD_COL2,  KEYPAD_ROW3)  
    POSITION_DIALPAD_BUTTON(9,      KEYPAD_COL3,  KEYPAD_ROW3)  
    POSITION_DIALPAD_BUTTON(Star,   KEYPAD_COL1,  KEYPAD_ROW4)  
    POSITION_DIALPAD_BUTTON(0,      KEYPAD_COL2,  KEYPAD_ROW4)  
    POSITION_DIALPAD_BUTTON(Pound,  KEYPAD_COL3,  KEYPAD_ROW4)  

#undef POSITION_DIALPAD_BUTTON

    // status text
    POSITION_WINDOW(m_hStatusText, 
        STATUS_LEFT, STATUS_TOP, 
        STATUS_WIDTH, STATUS_HEIGHT,
        0);

    POSITION_WINDOW(m_hStatusElapsedTime, 
        TIMER_LEFT, TIMER_TOP, 
        TIMER_WIDTH, TIMER_HEIGHT,
        0);

#ifdef WEBCONTROL
    // browser
    POSITION_WINDOW(m_hBrowser, 
        BROWSER_LEFT, BROWSER_TOP, 
        BROWSER_WIDTH, BROWSER_HEIGHT,
        0);
#endif

#undef POSITION_WINDOW
}


/////////////////////////////////////////////////////////////////////////////
//
// CreateToolbarMenuControl
//      Creates the toolbar menu control
// 

HRESULT CMainFrm::CreateToolbarMenuControl(void)
{
    HRESULT     hr = E_FAIL;
    HWND        hToolbar;
    HBITMAP     hBitmap = NULL;
    TBBUTTON  * tbb;
    int       * iRes;
    TCHAR       szBuf[MAX_STRING_LEN];

    // Create the toolbar
    hToolbar = CreateWindowEx(
        WS_EX_TRANSPARENT, 
        TOOLBARCLASSNAME, 
        (LPTSTR) NULL,
        WS_CHILD | WS_VISIBLE | TBSTYLE_LIST | TBSTYLE_FLAT | CCS_NORESIZE | CCS_NOPARENTALIGN, 
        0, 
        0, 
        0, 
        0, 
        m_hWnd, 
        (HMENU) IDC_TOOLBAR_MENU, 
        _Module.GetResourceInstance(), 
        NULL); 

    if(hToolbar!=NULL)
    {       
        // backward compatibility
        SendMessage(hToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);      

        // Set the image lists
        SendMessage(hToolbar, TB_SETIMAGELIST, 0, (LPARAM)NULL); 
        SendMessage(hToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)NULL); 
        SendMessage(hToolbar, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)NULL); 

        // Load text strings for buttons    
        UINT uMenuCount = ::GetMenuItemCount(m_hMenu);

        tbb = (TBBUTTON *)RtcAlloc( uMenuCount * sizeof(TBBUTTON) );
        iRes = (int *)RtcAlloc( uMenuCount * sizeof(int) );

        if (tbb && iRes)
        {
            memset(tbb, 0, uMenuCount * sizeof(TBBUTTON) );

            for (int i=0;i<(int)uMenuCount;i++)
            {
                MENUITEMINFO menuiteminfo;

                memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
                menuiteminfo.fMask = MIIM_TYPE;
                menuiteminfo.cbSize = sizeof(MENUITEMINFO);
                menuiteminfo.dwTypeData = szBuf;
                menuiteminfo.cch = MAX_STRING_LEN-1;

                memset(szBuf, 0, MAX_STRING_LEN*sizeof(TCHAR));

                ::GetMenuItemInfo(m_hMenu,i,TRUE,&menuiteminfo);

                LOG((RTC_INFO, "CMainFrm::CreateToolbarMenuControl - %ws", szBuf));

                iRes[i] = (UINT)SendMessage(hToolbar, TB_ADDSTRING, 0, (LPARAM) szBuf);

                // Prepare the button structs
                tbb[i].iBitmap = I_IMAGENONE;
                tbb[i].iString = iRes[i];
                tbb[i].dwData = 0;
                tbb[i].fsStyle = BTNS_DROPDOWN | BTNS_AUTOSIZE;
                tbb[i].fsState = TBSTATE_ENABLED;
                tbb[i].idCommand = IDC_MENU_ITEM+i;
            }

            // Add the buttons to the toolbar
            SendMessage(hToolbar, TB_ADDBUTTONS, uMenuCount, 
                (LPARAM) (LPTBBUTTON) tbb); 
 
            // Indent the toolbar
            //SendMessage(hToolbar, TB_SETINDENT, EDGE_WIDTH, 0); 

            // Autosize the generated toolbar
            SendMessage(hToolbar, TB_AUTOSIZE, 0, 0); 

            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (tbb != NULL)
        {
            RtcFree(tbb);
        }

        if (iRes != NULL)
        {
            RtcFree(iRes);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// DestroyToolbarMenuControl
//      Destroys the toolbar menu control.
// 

void CMainFrm::DestroyToolbarMenuControl(void)
{
    
    HWND    hToolbar = m_hToolbarMenuCtl.Detach();

    if(hToolbar)
    {
        ::DestroyWindow(hToolbar);
    }
}

/////////////////////////////////////////////////////////////////////////////
//  
//
void CMainFrm::UpdateLocaleInfo(void)
{
    LOG((RTC_TRACE, "CMainFrm::UpdateLocaleInfo - enter"));

    //
    //  Read the time separator
    //

    int iNrChars;

    iNrChars = GetLocaleInfo(
        LOCALE_USER_DEFAULT,
        LOCALE_STIME,
        m_szTimeSeparator,
        sizeof(m_szTimeSeparator)/sizeof(m_szTimeSeparator[0])
        );
    
    if(iNrChars == 0)
    {
        LOG((RTC_ERROR, "CMainFrm::UpdateLocaleInfo - error (%x) returned by GetLocaleInfo", GetLastError()));

        // use ':'..
        m_szTimeSeparator[0] = _T(':');
        m_szTimeSeparator[1] = _T('\0');
    }

    LOG((RTC_TRACE, "CMainFrm::UpdateLocaleInfo - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::StartCallTimer(void)
{
    LOG((RTC_TRACE, "CMainFrm::StartCallTimer - enter"));

    // Get the current tick count
    m_dwTickCount = GetTickCount();

    // Start the timer, one second interval
    if (0 == SetTimer(TID_CALL_TIMER, 1000))
    {
        LOG((RTC_ERROR, "CMainFrm::StartCallTimer - error (%x) returned by SetTimer", GetLastError()));
        return;
    }

    // Put 0 seconds in elapsed.
    SetTimeStatus(TRUE, 0);

    LOG((RTC_TRACE, "CMainFrm::StartCallTimer - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::StopCallTimer(void)
{
    LOG((RTC_TRACE, "CMainFrm::StopCallTimer - enter"));

    // kill the timer
    KillTimer(TID_CALL_TIMER);


    LOG((RTC_TRACE, "CMainFrm::StopCallTimer - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::ClearCallTimer(void)
{
    LOG((RTC_TRACE, "CMainFrm::ClearCallTimer - enter"));

    // clear the timer status
    SetTimeStatus(FALSE, 0);

    LOG((RTC_TRACE, "CMainFrm::ClearCallTimer - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::ShowCallTimer(void)
{
    LOG((RTC_TRACE, "CMainFrm::ShowCallTimer - enter"));

    // enable the timer status
    SetTimeStatus(TRUE, 0);

    LOG((RTC_TRACE, "CMainFrm::ShowCallTimer - exit"));
}



/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::SetTimeStatus(
        BOOL    bSet,
        DWORD   dwTotalSeconds)
{
    // if bSet == FALSE, the time is cleared
    // if bSet == TRUE, the elapsed time specified in dwSeconds is displayed.
    if(bSet)
    {
        // Format
        // h:mm:ss  (: is the time separator, maximum four characters, based on the locale)
        TCHAR   szText[0x40];
        DWORD   dwSeconds;
        DWORD   dwMinutes;
        DWORD   dwHours;

        dwSeconds = dwTotalSeconds % 60;

        dwMinutes = (dwTotalSeconds / 60) % 60;

        dwHours = dwTotalSeconds / 3600;

        // two tabs for right alignement
        wsprintf(szText, _T("%u%s%02u%s%02u"), 
            dwHours,
            m_szTimeSeparator,
            dwMinutes,
            m_szTimeSeparator,
            dwSeconds);

        m_hStatusElapsedTime.SendMessage(
            WM_SETTEXT,
            (WPARAM)0,
            (LPARAM)szText);
    }
    else
    {
        m_hStatusElapsedTime.SendMessage(
            WM_SETTEXT,
            (WPARAM)0,
            (LPARAM)_T(""));
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::CreateStatusIcon(void)
{
    NOTIFYICONDATA  nd;
    
/*
    //
    // Set W2K style (Shell 5.0) notifications
    // This is a dependency...
    //
    nd.cbSize = sizeof(NOTIFYICONDATA);
    nd.uVersion = NOTIFYICON_VERSION;
    Shell_NotifyIcon(NIM_SETVERSION, &nd);
*/
    

    // Load app icon (this is the default)
    HICON   hIcon = NULL;

    hIcon = LoadIcon(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDI_APPICON)
        );

    // don't need v5.0 features
    nd.cbSize = NOTIFYICONDATA_V1_SIZE;
    nd.uFlags = NIF_ICON | NIF_MESSAGE; 
    nd.hIcon = hIcon;
    nd.hWnd = m_hWnd;
    nd.uID = IDX_MAIN;
    nd.uCallbackMessage = WM_SHELL_NOTIFY;

    //
    // Call the shell
    //
    
    if(!Shell_NotifyIcon(
        NIM_ADD,
        &nd
        ))
    {
        LOG((RTC_ERROR, "CMainFrm::CreateStatusIcon - "
                        "Shell_NotifyIcon failed"));

        return E_FAIL;
    }

    //
    // The shell is listening for our messages...
    //
    m_bShellStatusActive = TRUE;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::DeleteStatusIcon(void)
{
    NOTIFYICONDATA  nd;

    // don't need v5.0 features
    nd.cbSize = NOTIFYICONDATA_V1_SIZE;
    nd.uFlags = 0;
    nd.hWnd = m_hWnd;
    nd.uID = IDX_MAIN;

    //
    // Call the shell
    //
    
    Shell_NotifyIcon(
        NIM_DELETE,
        &nd
        );

    m_bShellStatusActive = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CMainFrm::UpdateStatusIcon(HICON hIcon, LPTSTR pszTip)
{
    NOTIFYICONDATA  nd;

    //
    // return if no shell status active
    //

    if(!m_bShellStatusActive)
    {
        return;
    }

    // don't need v5.0 features
    nd.cbSize = NOTIFYICONDATA_V1_SIZE;
    nd.uFlags = 0;
    nd.hWnd = m_hWnd;
    nd.uID = IDX_MAIN;

    if(hIcon)
    {
        nd.uFlags |= NIF_ICON;
        nd.hIcon = hIcon;
    }

    if(pszTip)
    {
        nd.uFlags |= NIF_TIP;
        _tcsncpy(nd.szTip, pszTip, sizeof(nd.szTip)/sizeof(nd.szTip[0]));

        *(pszTip + sizeof(nd.szTip)/sizeof(nd.szTip[0]) -1) = _T('\0');
    }
    
    
    if(!Shell_NotifyIcon(
        NIM_MODIFY,
        &nd
        ))
    {
        LOG((RTC_ERROR, "CMainFrm::UpdateStatusIcon - "
                        "Shell_NotifyIcon failed"));

        return;
    }
}



/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::PlacePendingCall(
    void
    )
{
    HRESULT hr;
    BSTR bstrLocalCallParam;

    LOG((RTC_TRACE, "CMainFrm::PlacePendingCall: Entered"));
    if (m_bstrCallParam == NULL)
    {
        // No call to place, return success anyway!
        LOG((RTC_TRACE, "CMainFrm::PlacePendingCall: called with NULL m_bstrCallParam"));
        return S_OK;
    }

    // Check if we can place a call at this stage, check the variable..
    if (m_fInitCompleted == FALSE)
    {
        LOG((RTC_WARN, "CMainFrm::PlacePendingCall: can't place call during Init."));
        return E_FAIL;
    }
    // We make a local copy of the call string and free the original one, since a call
    // to ParseAndPlaceCall() may cause the OnUpdateState() to fire again, causing us 
    // to go in a loop.

    bstrLocalCallParam = m_bstrCallParam;
    
    m_bstrCallParam = NULL;

    // Now place the call.
    hr = ParseAndPlaceCall(m_pControlIntf, bstrLocalCallParam);
    ::SysFreeString(bstrLocalCallParam);
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "CMainFrm::PlacePendingCall: Unable to place a pending call(string=%S, hr=0x%x)",
            bstrLocalCallParam, hr));
        return E_FAIL;
    }
    
    
    LOG((RTC_TRACE, "CMainFrm::PlacePendingCall: Exited"));
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::SetPendingCall(
    BSTR bstrCallString
    )
{
    LOG((RTC_TRACE, "CMainFrm::SetPendingCall: Entered"));
    m_bstrCallParam = bstrCallString;
    LOG((RTC_TRACE, "CMainFrm::SetPendingCall: Exited"));
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::PlaceWindowCorrectly(void)
{
    LOG((RTC_TRACE, "CMainFrm::PlaceWindowCorrectly: Entered"));

    BSTR bstrWindowPosition = NULL;
    HRESULT hr;
    int diffCord;
    BOOL fResult; 
    RECT rectWorkArea;
    RECT rectWindow;

    hr = get_SettingsString( SS_WINDOW_POSITION, &bstrWindowPosition );

    if ( FAILED( hr ) || ( SUCCEEDED( hr ) && (bstrWindowPosition == NULL) )  )
    {
        // If this failed, or if it didn't return a value, we need to get the
        // current position of the window. This takes care of initial case
        // when the current position has some portions not visible.

        GetClientRect(&rectWindow);
        ::MapWindowPoints( m_hWnd, NULL, (LPPOINT)&rectWindow, 2 );
    }
    else
    {
        // Success, parse the window position string

        swscanf(bstrWindowPosition, L"%d %d %d %d",
            &rectWindow.left, &rectWindow.top,
            &rectWindow.right, &rectWindow.bottom);

        SysFreeString(bstrWindowPosition);
        bstrWindowPosition = NULL;
    }

    // Get the coordinates to be repositioned and apply the transformation  

    LOG((RTC_INFO, "CMainFrm::PlaceWindowCorrectly - original coords are "
                    "%d, %d %d %d ",
                    rectWindow.left, rectWindow.top, 
                    rectWindow.right, rectWindow.bottom));
   
    // Get the monitor that has the largest area of intersecion with the
    // window rectangle. If the window rectangle intersects with no monitors
    // then we will use the nearest monitor.

    HMONITOR hMonitor = NULL;

    hMonitor = MonitorFromRect( &rectWindow, MONITOR_DEFAULTTONEAREST );

    LOG((RTC_INFO, "CMainFrm::PlaceWindowCorrectly - hMonitor [%p]", hMonitor));

    // Get the visible work area on the monitor

    if ( (hMonitor != NULL) && (hMonitor != INVALID_HANDLE_VALUE) )
    {      
        MONITORINFO monitorInfo;
        monitorInfo.cbSize = sizeof(MONITORINFO);

        fResult = GetMonitorInfo( hMonitor, &monitorInfo );

        rectWorkArea = monitorInfo.rcWork;

        //  hMonitor must not be deleted using DeleteObject;

        if (!fResult)
        {
            LOG((RTC_ERROR, "CMainFrm::PlaceWindowCorrectly - Failed GetMonitorInfo(%d)", 
                        GetLastError() ));
        }
    }
    else
    {
        // we can always fall back to non-multimon APIs if
        // MonitorFromRect failed.

        fResult = SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);

        if (!fResult)
        {
            LOG((RTC_ERROR, "CMainFrm::PlaceWindowCorrectly - Failed SystemParametersInfo(%d)", 
                        GetLastError() ));
        }
    }   
      
    if (fResult)
    {
        LOG((RTC_INFO, "CMainFrm::PlaceWindowCorrectly - monitor work area is "
                    "%d, %d %d %d ",
                    rectWorkArea.left, rectWorkArea.top, 
                    rectWorkArea.right, rectWorkArea.bottom));

        // update x and y coordinates.

        // if top left is not visible, move it to the edge of the visible
        // area

        if (rectWindow.left < rectWorkArea.left) 
        {
            rectWindow.left = rectWorkArea.left;
        }

        if (rectWindow.top < rectWorkArea.top)
        {
            rectWindow.top = rectWorkArea.top;
        }

        // if bottom right corner is outside work area, we move the 
        // top left cornet back so that it becomes visible. Here the 
        // assumption is that the actual size is smaller than the 
        // visible work area.

        diffCord = rectWindow.left + UI_WIDTH - rectWorkArea.right;

        if (diffCord > 0) 
        {
            rectWindow.left -= diffCord;
        }

        diffCord = rectWindow.top + UI_HEIGHT - rectWorkArea.bottom;

        if (diffCord > 0) 
        {
            rectWindow.top -= diffCord;
        }

        rectWindow.right = rectWindow.left + UI_WIDTH;
        rectWindow.bottom = rectWindow.top + UI_HEIGHT;

        LOG((RTC_INFO, "CMainFrm::PlaceWindowCorrectly - new coords are "
                        "%d, %d %d %d ",
                        rectWindow.left, rectWindow.top, 
                        rectWindow.right, rectWindow.bottom));
    } 

    AdjustWindowRect( &rectWindow, GetStyle(), FALSE );
    
    fResult = ::SetWindowPos(
                    m_hWnd,
                    HWND_TOP, 
                    rectWindow.left, 
                    rectWindow.top, 
                    rectWindow.right - rectWindow.left,
                    rectWindow.bottom - rectWindow.top,
                    SWP_SHOWWINDOW | SWP_NOSIZE);

    if (!fResult)
    {
        LOG((RTC_ERROR, "CMainFrm::PlaceWindowCorrectly - Failed SetWindowPos(%d)", 
                        GetLastError()));
        return E_FAIL;
    }
    
    LOG((RTC_TRACE, "CMainFrm::PlaceWindowCorrectly: Exited"));

    return S_OK;

}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::SaveWindowPosition(void)
{
    LOG((RTC_TRACE, "CMainFrm::SaveWindowPosition: Entered"));

    BSTR bstrWindowPosition = NULL;
    HRESULT hr;
    RECT rect;
    
    WCHAR szWindowPosition[100];

    // Get the coordinates of the window.
    GetClientRect(&rect);
    ::MapWindowPoints( m_hWnd, NULL, (LPPOINT)&rect, 2 );

    // We need only the top left coordinates.

    swprintf(szWindowPosition, L"%d %d %d %d",  rect.left, rect.top, 
                                                rect.right, rect.bottom);
    
    bstrWindowPosition = SysAllocString(szWindowPosition);
    
    if (bstrWindowPosition)
    {
        hr = put_SettingsString( SS_WINDOW_POSITION, bstrWindowPosition );

        //Free the memory allocated
        SysFreeString(bstrWindowPosition);
        
        if (SUCCEEDED( hr ) )
        {
            LOG((RTC_INFO, "CMainFrm::SaveWindowPosition - Set successfully"
                        "(%s)", bstrWindowPosition));
        }
        else
        {
            LOG((RTC_ERROR, "CMainFrm::SaveWindowPosition - Error in "
                            "put_SettingsString[%s] for "
                            "SS_WINDOW_POSITION(0x%x)", bstrWindowPosition, 
                            hr));
            return hr;
        }

    }
    else
    {
        LOG((RTC_ERROR, "CMainFrm::SaveWindowPosition - Error in allocating for"
                        "SS_WINDOW_POSITION put_SettingString()"));
        return E_OUTOFMEMORY;
    }
    
    LOG((RTC_TRACE, "CMainFrm::SaveWindowPosition: Exited"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CMainFrm::ShowCallDropPopup(BOOL fExit, BOOL * pfProceed)
{
    int nResult;

    LOG((RTC_TRACE, "CMainFrm::ShowCallDropPopup: Entered"));

    if (
        (m_nState == RTCAX_STATE_CONNECTING)    ||
        (m_nState == RTCAX_STATE_CONNECTED)     ||
        (m_nState == RTCAX_STATE_ANSWERING) 
    )

    {      
        RTC_CALL_SCENARIO   enScenario;
        HRESULT             hr;
        LONG                lMsgId;

        hr = m_pControlIntf->get_CurrentCallScenario( &enScenario );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CMainFrm::ShowCallDropPopup: get_CurrentCallScenario failed 0x%lx", hr));

            // continue anyways .... assume PC-to-PC which is the most restrictive case

            enScenario = RTC_CALL_SCENARIO_PCTOPC;
        }

        if ( enScenario == RTC_CALL_SCENARIO_PHONETOPHONE )
        {
            // This is a phone to phone scenario, so releasing the call without
            // dropping it is an option

            if (fExit)
            {
                lMsgId = IDS_MESSAGE_EXITANDRELEASECALL;
            }
            else
            {
                lMsgId = IDS_MESSAGE_CLOSEANDRELEASECALL;
            }

            nResult = DisplayMessage(
                _Module.GetResourceInstance(),
                m_hWnd,
                lMsgId,
                IDS_APPNAME,
                MB_YESNOCANCEL | MB_ICONEXCLAMATION);
        }
        else
        {
            if (fExit)
            {
                lMsgId = IDS_MESSAGE_EXITANDDROPCALL;
            }
            else
            {
                lMsgId = IDS_MESSAGE_CLOSEANDDROPCALL;
            }

            nResult = DisplayMessage(
                _Module.GetResourceInstance(),
                m_hWnd,
                lMsgId,
                IDS_APPNAME,
                MB_OKCANCEL | MB_ICONEXCLAMATION);
        }

    
        if ((nResult == IDOK) || (nResult == IDYES))
        {
            // User wants to drop the current call, so do it. 
            // But the call may have been dropped in this time by the other
            // party. SO the new state can either be idle or disconnecting. 
            // In this case, we check if it is already idle, we need not call
            // HangUp.

        
            if  (
                (m_nState == RTCAX_STATE_CONNECTING)    ||
                (m_nState == RTCAX_STATE_CONNECTED)     ||
                (m_nState == RTCAX_STATE_ANSWERING) 
                )
            {
                // These states are safe for HangUp, so go ahead and do it.
                m_pControlIntf->HangUp();
            }

            // Call is dropped.

            *pfProceed = TRUE;

        }
        else if (nResult == IDNO)
        {
            // User does no want to drop the current call, so just release it. 
            // But the call may have been dropped in this time by the other
            // party. SO the new state can either be idle or disconnecting. 
            // In this case, we check if it is already idle, we need not call
            // ReleaseSession.

        
            if  (
                (m_nState == RTCAX_STATE_CONNECTING)    ||
                (m_nState == RTCAX_STATE_CONNECTED)     ||
                (m_nState == RTCAX_STATE_ANSWERING) 
                )
            {
                // These states are safe for ReleaseSession, so go ahead and do it.
                m_pControlIntf->ReleaseSession();
            }

            // Call is released.

            *pfProceed = TRUE;
        }
        else
        {
            // User said no. This means the caller shouldn't proceed.

            *pfProceed = FALSE;
        }
    }
    else
    {
        // There is no call to drop. Caller can proceed with the call. 
        *pfProceed = TRUE;
    }

    LOG((RTC_TRACE, "CMainFrm::ShowCallDropPopup: Exited"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\options.h ===
// options.h : header file for property pages
//  

#pragma once

#include "stdafx.h"

INT_PTR ShowNameOptionsDialog(HWND, IRTCClient *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\options.cpp ===
// options.cpp : Implementation of property pages
//
 
#include "stdafx.h"
#include "options.h"
#include "exereshm.h"
#include "urlreg.h"

typedef struct _NAME_OPTIONS_PARAM {
    IRTCClient * pClient;
} NAME_OPTIONS_PARAM;

HRESULT SetRunOnStartupKey(BOOL fRunOnStart);

INT_PTR CALLBACK NameOptionsDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    );

//////////////////////////////////////////////////////////////////////////////
//
// Help array
//
static DWORD   g_dwHelpArray[] =
{
    IDC_EDIT_DISPLAYNAME,       IDH_DIALOG_NAME_OPTIONS_EDIT_DISPLAYNAME,
    IDC_EDIT_USERURI,           IDH_DIALOG_NAME_OPTIONS_EDIT_ADDRESS,
    IDC_CHECK_RUNATSTARTUP,     IDH_DIALOG_NAME_OPTIONS_CHECK_RUN_STARTUP,
    IDC_CHECK_MINIMIZEONCLOSE,  IDH_DIALOG_NAME_OPTIONS_CHECK_MINIMIZE_CLOSE,
    IDC_CHECK_CHECKDEFAULTAPP,  IDH_DIALOG_NAME_OPTIONS_CHECK_DEFAULT_TELEPHONYAPP,
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR ShowNameOptionsDialog(HWND hParent, IRTCClient *pClient)
{
    static NAME_OPTIONS_PARAM nameOptionParam;

    INT_PTR ipReturn;

    nameOptionParam.pClient = pClient;

    ipReturn = DialogBoxParam(
        _Module.GetResourceInstance(),
        (LPCTSTR) IDD_DIALOG_NAME_OPTIONS,
        hParent,
        (DLGPROC) NameOptionsDialogProc,
        (LPARAM)&nameOptionParam
        );
    return ipReturn;
}


/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT SetRunOnStartupKey(
    BOOL fRunOnStart
    )
{
    LOG((RTC_TRACE, "SetRunOnStartupKey: Entered"));
    
    WCHAR szRunKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    
    WCHAR szAppName[] = L"Phoenix";
    
    // Open the reg key for HKCU\\..\\Run

    HKEY  hKey;
    LONG lResult;

    lResult = RegCreateKeyExW(
                    HKEY_CURRENT_USER,
                    szRunKey,
                    0,
                    NULL,
                    0,
                    KEY_WRITE,  
                    NULL,
                    &hKey,
                    NULL
                   );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "SetRunOnStartupKey - "
            "RegCreateKeyExW(%ws) failed %d", szRunKey, lResult));
    
        return E_FAIL;
    }
    else
    {
        LOG((RTC_ERROR, "SetRunOnStartupKey - "
            "RegCreateKeyExW(%ws) succeeded", szRunKey));
    }

    // If the flag fRunOnStart is not set, it means we have to delete
    // the existing key. Otherwise we will add it.

    if (!fRunOnStart)
    {
        RegDeleteValue(
                hKey,
                szAppName
                );
        
        RegCloseKey(hKey);
        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "SetRunOnStartupKey - "
                "RegDeleteValue(%ws) failed %d", szAppName, lResult));
    
            return E_FAIL;
        }
        LOG((RTC_TRACE, "SetRunOnStartupKey: Exited"));
        return S_OK;

    }

    // So we have to add the entry to the registry key.

    // Get the path of the executable.

    WCHAR szPath[MAX_PATH+3];
    ZeroMemory(szPath, (MAX_PATH+3)*sizeof(WCHAR));

    if (GetShortModuleFileNameW(_Module.GetModuleInstance(), szPath, MAX_PATH) == 0)
    {
        LOG((RTC_ERROR, "SetRunOnStartupKey - "
            "GetModuleFileName failed %d", GetLastError()));

        return E_FAIL;
    }

    LOG((RTC_INFO, "SetRunOnStartupKey - "
            "GetModuleFileName [%ws]", szPath));

    // Add this path to the registry
    
    lResult = RegSetValueExW(
                             hKey,
                             szAppName,
                             0,
                             REG_SZ,
                             (LPBYTE)szPath,
                             sizeof(WCHAR) * (lstrlenW(szPath) + 1)
                            );

    RegCloseKey(hKey);

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "SetRunOnStartupKey - "
            "RegSetValueExW(%ws) failed %d", szAppName, lResult));

        return E_FAIL;
    }
    else
    {
        LOG((RTC_INFO, "SetRunOnStartupKey - "
                "Successfully set the key [%ws]", szAppName));
    }

    // So we added the entry successfully, let's return success.


    LOG((RTC_TRACE, "SetRunOnStartupKey: Exited"));
    return S_OK;
}

////////////////////////////////////////////////////
//
//
//

INT_PTR CALLBACK NameOptionsDialogProc(
    IN  HWND   hwndDlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
{
    static IRTCClient * pClient = NULL;

    static HWND hwndDisplayName;
    static HWND hwndUserURI;
    static HWND hwndMinimizeOnClose;
    static HWND hwndRunAtStartup;
    static HWND hwndCheckIfDefaultApp;

    HRESULT hr;


    BSTR bstrDisplayName = NULL; 
    BSTR bstrUserURI = NULL;
    
    DWORD dwMinimizeOnClose = 0;
    DWORD dwRunAtStartup = 0;
    DWORD dwUrlRegDontAskMe = 0;

    static WCHAR szDefaultDisplayName[256]; 
    static WCHAR szDefaultUserURI[256];

    WCHAR szDisplayName[256];
    
    WCHAR szUserURI[256];

    PWSTR szUserName;

    PWSTR szComputerName;

    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            pClient = ((NAME_OPTIONS_PARAM *)lParam)->pClient;

            hr = pClient->get_LocalUserName( &bstrDisplayName );

            if (FAILED(hr))
			{
				LOG((RTC_ERROR, "NameOptionsDialogProc - "
								"get_LocalUserName failed 0x%lx", hr));
				return TRUE;
			}

            hr = pClient->get_LocalUserURI( &bstrUserURI );

            if (FAILED(hr))
			{
				LOG((RTC_ERROR, "NameOptionsDialogProc - "
								"get_LocalUserURI failed 0x%lx", hr));
				return TRUE;
			}

            hr = get_SettingsDword(SD_RUN_AT_STARTUP, &dwRunAtStartup);
            if (FAILED( hr ) )
            {
                LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to get "
                                "SD_RUN_AT_STARTUP(default=1)"));
                dwRunAtStartup = BST_UNCHECKED;
            }

            hr = get_SettingsDword(SD_MINIMIZE_ON_CLOSE, &dwMinimizeOnClose);
            if (FAILED( hr ) )
            {
                LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to get "
                                "SD_MINIMIZE_ON_CLOSE(default=1)"));
                dwMinimizeOnClose = BST_UNCHECKED;
            }

            hr = get_SettingsDword(SD_URL_REG_DONT_ASK_ME, &dwUrlRegDontAskMe);
            if (FAILED( hr ) )
            {
                LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to get "
                                "SD_URL_REG_DONT_ASK_ME(default=0)"));
                dwUrlRegDontAskMe = 0;
            }
            
            hwndDisplayName = GetDlgItem(hwndDlg, IDC_EDIT_DISPLAYNAME);

            hwndUserURI = GetDlgItem(hwndDlg, IDC_EDIT_USERURI);

            hwndRunAtStartup = GetDlgItem(hwndDlg, IDC_CHECK_RUNATSTARTUP);

            hwndMinimizeOnClose = GetDlgItem(hwndDlg, IDC_CHECK_MINIMIZEONCLOSE);

            hwndCheckIfDefaultApp = GetDlgItem(hwndDlg, IDC_CHECK_CHECKDEFAULTAPP);

            // Now set these values in the text box.

            // Display Name

            if (bstrDisplayName)
            {
                SendMessage(
                        hwndDisplayName,
                        WM_SETTEXT,
                        0,
                        (LPARAM)bstrDisplayName
                        );

                SysFreeString(bstrDisplayName);
                bstrDisplayName = NULL;
            }
		
            // User URI

            if (bstrUserURI)
            {
                SendMessage(
                        hwndUserURI,
                        WM_SETTEXT,
                        0,
                        (LPARAM)bstrUserURI
                        );

                SysFreeString(bstrUserURI);
                bstrUserURI = NULL;
            }
		
            // Run at Startup Check Box

            SendMessage(
                    hwndRunAtStartup,
                    BM_SETCHECK,
                    (WPARAM)dwRunAtStartup,
                    0
                    );


            // Minimize on Close Check Box

            SendMessage(
                    hwndMinimizeOnClose,
                    BM_SETCHECK,
                    (WPARAM)dwMinimizeOnClose,
                    0
                    );

            // Check if Default App Check Box

            SendMessage(
                    hwndCheckIfDefaultApp,
                    BM_SETCHECK,
                    (WPARAM)!dwUrlRegDontAskMe,
                    0
                    );

            return TRUE;
        }
        break;

        case WM_DESTROY:
        {
            // Cleanup, if any
            return TRUE;
        }
        break;
        
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szExeContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArray);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szExeContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArray);

            return TRUE;

            break;

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                {                   


                    // Now get those values from the text box.

                    // Display Name

                    SendMessage(
                            hwndDisplayName,
                            WM_GETTEXT,
                            sizeof( szDisplayName )/sizeof( TCHAR ),
                            (LPARAM)szDisplayName
                            );

                    // User URI

                    SendMessage(
                            hwndUserURI,
                            WM_GETTEXT,
                            sizeof( szUserURI )/sizeof( TCHAR ),
                            (LPARAM)szUserURI
                            );

                    // Run At Startup Check Box

                    dwRunAtStartup = (DWORD)SendMessage(
                                                hwndRunAtStartup,
                                                BM_GETCHECK,
                                                0,
                                                0
                                                );

                    // Minimize on Close Check Box

                    dwMinimizeOnClose = (DWORD)SendMessage(
                                                    hwndMinimizeOnClose,
                                                    BM_GETCHECK,
                                                    0,
                                                    0
                                                    );

                    // Minimize on Close Check Box

                    dwUrlRegDontAskMe = (DWORD)!SendMessage(
                                                    hwndCheckIfDefaultApp,
                                                    BM_GETCHECK,
                                                    0,
                                                    0
                                                    );

                    // Set these values in the registry.

                    // Display Name

					bstrDisplayName = SysAllocString(szDisplayName);

					if ( bstrDisplayName == NULL )
					{
						LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to "
										"allocate for display name."));
						return TRUE;
					}

					hr = put_SettingsString( SS_USER_DISPLAY_NAME, bstrDisplayName );

                    if ( FAILED(hr) )
					{
						LOG((RTC_ERROR, "NameOptionsDialogProc - "
										"put_SettingsString failed for display name 0x%lx", hr));
					}

                    hr = pClient->put_LocalUserName( bstrDisplayName );

                    if ( FAILED(hr) )
					{
						LOG((RTC_ERROR, "NameOptionsDialogProc - "
										"put_LocalUserName failed 0x%lx", hr));
					}
                
					SysFreeString(bstrDisplayName);
                    bstrDisplayName = NULL;

                    // User URI

					bstrUserURI = SysAllocString(szUserURI);

					if ( bstrUserURI == NULL )
					{
						LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to "
										"allocate for UserURI."));
						return TRUE;
					}

					hr = put_SettingsString( SS_USER_URI, bstrUserURI );

                    if ( FAILED(hr) )
					{
						LOG((RTC_ERROR, "NameOptionsDialogProc - "
										"put_SettingsString failed for user uri 0x%lx", hr));
					}

                    hr = pClient->put_LocalUserURI( bstrUserURI );

                    if ( FAILED(hr) )
					{
						LOG((RTC_ERROR, "NameOptionsDialogProc - "
										"put_LocalUserName failed 0x%lx", hr));
					}
                
					SysFreeString(bstrUserURI);
                    bstrUserURI = NULL;

                    // Run At Startup check box

                    hr = put_SettingsDword(SD_RUN_AT_STARTUP, dwRunAtStartup);
                    if (FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to set "
                                        "SD_RUN_AT_STARTUP(value=%d)", 
                                        dwRunAtStartup ));
                    }

                    // Now make the entry in the registry so that it can be actually
                    // run at startup.

                    if (dwRunAtStartup == BST_CHECKED)
                    {
                        SetRunOnStartupKey(TRUE);
                    }
                    else
                    {
                        SetRunOnStartupKey(FALSE);
                    }

                    // Minimize on Close check box

                    hr = put_SettingsDword(SD_MINIMIZE_ON_CLOSE, dwMinimizeOnClose);
                    if (FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to get "
                                        "SD_MINIMIZE_ON_CLOSE(value=%d)",
                                        dwMinimizeOnClose));
                    }

                    // Check if Default App check box

                    hr = put_SettingsDword(SD_URL_REG_DONT_ASK_ME, dwUrlRegDontAskMe);
                    if (FAILED( hr ) )
                    {
                        LOG((RTC_ERROR, "NameOptionsDialogProc - Failed to get "
                                        "SD_URL_REG_DONT_ASK_ME(value=%d)",
                                        dwMinimizeOnClose));
                    }

                    EndDialog( hwndDlg, (LPARAM) S_OK );

                    return TRUE;
                }
                
                case IDCANCEL:
                {
                    EndDialog( hwndDlg, (LPARAM) E_ABORT );

                    return TRUE;
                }
				case IDC_EDIT_USERURI:
				{
					// Handle it only when it is a change event
					if (HIWORD(wParam) == EN_CHANGE)
					{


                        // Get the handle to the OK button. 
                        HWND hwndControl;
                        
                        int iResult;

                        hwndControl = GetDlgItem(
                            hwndDlg,
                            IDOK
                            );

                        ATLASSERT( hwndControl != NULL );


                        // if text box is empty, disable the OK button.
						iResult = (int)SendMessage(
										hwndUserURI,
										EM_LINELENGTH,
										0,
										0);

						if (iResult == 0)
						{
							// nothing in textbox, grey out the OK button.

                            EnableWindow(
                                hwndControl,
                                FALSE // disable
                                );
						}
                        else
						{
                            //enable the OK button.

                            EnableWindow(
                                hwndControl,
                                TRUE // enable
                                );
							
						}
                        
                        return TRUE;
					}
				}
            }
            break;
        }
    }
        //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\rtcaddress.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCAddress.cpp

Abstract:

    Implementation of the CRTCAddress class

--*/

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCAddress::FinalConstruct()
{
    // LOG((RTC_TRACE, "CRTCAddress::FinalConstruct - enter"));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( 1 );
#endif

    // LOG((RTC_TRACE, "CRTCAddress::FinalConstruct - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCAddress::FinalRelease()
{
    // LOG((RTC_TRACE, "CRTCAddress::FinalRelease - enter"));

    if ( m_szAddress != NULL )
    {
        RtcFree(m_szAddress);
        m_szAddress = NULL;
    }

    if ( m_szLabel != NULL )
    {
        RtcFree(m_szLabel);
        m_szLabel = NULL;
    }

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    // LOG((RTC_TRACE, "CRTCAddress::FinalRelease - exit"));
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::put_Address
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCAddress::put_Address(
        BSTR bstrAddress
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::put_Address - enter"));

    if ( IsBadStringPtrW( bstrAddress, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCAddress::put_Address - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szAddress != NULL )
    {
        RtcFree(m_szAddress);
        m_szAddress = NULL;
    }

    m_szAddress = RtcAllocString( bstrAddress );

    if ( m_szAddress == NULL )
    {
        LOG((RTC_ERROR, "CRTCAddress::put_Number - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCAddress::put_Address - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::get_Address
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCAddress::get_Address(
        BSTR * pbstrAddress
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::get_Address - enter"));

    if ( IsBadWritePtr( pbstrAddress, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCAddress::get_Number - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szAddress == NULL )
    {
        LOG((RTC_ERROR, "CRTCAddress::get_Address - "
                            "no string"));

        return E_FAIL;
    }

    *pbstrAddress = SysAllocString( m_szAddress );

    if ( *pbstrAddress == NULL )
    {
        LOG((RTC_ERROR, "CRTCAddress::get_Address - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCAddress::get_Address - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::put_Label
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCAddress::put_Label(
        BSTR bstrLabel
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::put_Label - enter"));

    if ( IsBadStringPtrW( bstrLabel, -1 ) )
    {
        LOG((RTC_ERROR, "CRTCAddress::put_Label - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szLabel != NULL )
    {
        RtcFree(m_szLabel);
        m_szLabel = NULL;
    }

    m_szLabel = RtcAllocString( bstrLabel );

    if ( m_szLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCAddress::put_Label - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCAddress::put_Label - exit S_OK"));

    return S_OK;
} 
        
/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::get_Label
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCAddress::get_Label(
        BSTR * pbstrLabel
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::get_Label - enter"));

    if ( IsBadWritePtr( pbstrLabel, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCAddress::get_Label - "
                            "bad string pointer"));

        return E_POINTER;
    }

    if ( m_szLabel == NULL )
    {
        //LOG((RTC_ERROR, "CRTCAddress::get_Label - "
        //                    "no string"));

        return E_FAIL;
    }

    *pbstrLabel = SysAllocString( m_szLabel );

    if ( *pbstrLabel == NULL )
    {
        LOG((RTC_ERROR, "CRTCAddress::get_Label - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCAddress::get_Label - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::put_Type
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCAddress::put_Type(
        RTC_ADDRESS_TYPE enType
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::put_Type - enter"));

    m_enType = enType;

    // LOG((RTC_TRACE, "CRTCAddress::put_Type - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::get_Type
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCAddress::get_Type(
        RTC_ADDRESS_TYPE * penType
        ) 
{
    // LOG((RTC_TRACE, "CRTCAddress::get_Type - enter"));

    if ( IsBadWritePtr( penType, sizeof(RTC_ADDRESS_TYPE) ) )
    {
        LOG((RTC_ERROR, "CRTCAddress::get_Type - "
                            "bad RTC_ADDRESS_TYPE pointer"));

        return E_POINTER;
    }

    *penType = m_enType;

    // LOG((RTC_TRACE, "CRTCAddress::get_Type - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::RegStore
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCAddress::RegStore(
        HKEY hkey
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::RegStore - enter"));

    LONG lResult;

    //
    // Store the Label
    //

    if ( m_szLabel != NULL )
    {
        lResult = RegSetValueExW(
                                 hkey,
                                 L"Label",
                                 0,
                                 REG_SZ,
                                 (LPBYTE)m_szLabel,
                                 sizeof(WCHAR) * (lstrlenW(m_szLabel) + 1)
                                );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "CRTCAddress::RegStore - "
                                "RegSetValueEx failed %d", lResult));

            return HRESULT_FROM_WIN32(lResult);
        }
    }
    else
    {
        lResult = RegDeleteValue(
                             hkey,
                             _T("Label")
                            );
    }

    //
    // Store the Address
    //

    if ( m_szAddress != NULL )
    {
        lResult = RegSetValueExW(
                                 hkey,
                                 L"Address",
                                 0,
                                 REG_SZ,
                                 (LPBYTE)m_szAddress,
                                 sizeof(WCHAR) * (lstrlenW(m_szAddress) + 1)
                                );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "CRTCAddress::RegStore - "
                                "RegSetValueEx failed %d", lResult));        

            return HRESULT_FROM_WIN32(lResult);
        }
    }
    else
    {
        lResult = RegDeleteValue(
                             hkey,
                             _T("Address")
                            );
    }

    //
    // Store the Type
    //

    lResult = RegSetValueExW(
                             hkey,
                             L"Type",
                             0,
                             REG_BINARY,
                             (LPBYTE)&m_enType,
                             sizeof(RTC_ADDRESS_TYPE)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegStore - "
                            "RegSetValueEx failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }

    // LOG((RTC_TRACE, "CRTCAddress::RegStore - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::RegRead
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCAddress::RegRead(
        HKEY hkey
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::RegRead - enter"));

    LONG lResult;

    //
    // Read the Label
    //

    m_szLabel = RtcRegQueryString( hkey, L"Label" );

    if ( m_szLabel == NULL )
    {
        //LOG((RTC_ERROR, "CRTCAddress::RegRead - "
        //                    "RtcRegQueryString(Label) failed"));
    }

    //
    // Read the Address
    //

    m_szAddress = RtcRegQueryString( hkey, L"Address" );

    if ( m_szAddress == NULL )
    {
        LOG((RTC_ERROR, "CRTCAddress::RegRead - "
                            "RtcRegQueryString(Address) failed"));
    }

    //
    // Read the Type
    //

    DWORD cbSize = sizeof(RTC_ADDRESS_TYPE);

    lResult = RegQueryValueExW(
                               hkey,
                               L"Type",
                               0,
                               NULL,
                               (LPBYTE)&m_enType,
                               &cbSize
                              );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "CRTCPhoneNumber::RegRead - "
                            "RegQueryValueExW(Type) failed %d", lResult));
    }

    // LOG((RTC_TRACE, "CRTCAddress::RegRead - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCAddress::RegDelete
//
/////////////////////////////////////////////////////////////////////////////

HRESULT
CRTCAddress::RegDelete(
        HKEY hkey
        )
{
    // LOG((RTC_TRACE, "CRTCAddress::RegDelete - enter"));

    LONG lResult;

    //
    // Delete the label
    //

    lResult = RegDeleteValue(
                             hkey,
                             _T("Label")
                            );

    //
    // Delete the address
    //

    lResult = RegDeleteValue(
                             hkey,
                             _T("Address")
                            );

    // LOG((RTC_TRACE, "CRTCAddress::RegDelete - exit S_OK"));

    return S_OK;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CreateAddress
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CreateAddress(
        IRTCAddress ** ppAddress
        )
{
    HRESULT hr;
    
    //LOG((RTC_TRACE, "CreateAddress - enter"));
    
    //
    // Create the address
    //

    CComObject<CRTCAddress> * pCAddress;
    hr = CComObject<CRTCAddress>::CreateInstance( &pCAddress );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CreateAddress - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCAddress interface
    //

    IRTCAddress * pAddress = NULL;

    hr = pCAddress->QueryInterface(
                           IID_IRTCAddress,
                           (void **)&pAddress
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CreateAddress - "
                            "QI failed 0x%lx", hr));
        
        delete pCAddress;
        
        return hr;
    }
   
    *ppAddress = pAddress;

    //LOG((RTC_TRACE, "CreateAddress - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// StoreMRUAddress
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
StoreMRUAddress(
            IRTCAddress * pAddress
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "StoreMRUAddress enter"));

    if ( IsBadReadPtr( pAddress, sizeof( IRTCAddress ) ) )
    {
        LOG((RTC_ERROR, "StoreMRUAddress - "
                            "bad IRTCAddress pointer"));

        return E_POINTER;
    }

    LONG lResult;
    HKEY hkeyMRU;

    //
    // Open the MRU key
    //

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             _T("Software\\Microsoft\\Phoenix\\MRU"),
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyMRU,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "StoreMRUAddress - "
                            "RegCreateKeyEx(MRU) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Enumerate existing MRU addresses
    //

    IRTCEnumAddresses * pEnumA = NULL;

    hr = EnumerateMRUAddresses( &pEnumA );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "StoreMRUAddress - "
                            "EnumerateMRUAddresses failed 0x%lx", hr ));
    
        RegCloseKey( hkeyMRU );

        return hr;
    }

    //
    // Get info from the new address, for matching later
    //

    BSTR          bstrNewLabel = NULL;
    BSTR          bstrNewAddress = NULL;

    hr = pAddress->get_Address( &bstrNewAddress );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "StoreMRUAddress - "
                            "get_Address failed 0x%lx", hr ));
    
        RegCloseKey( hkeyMRU );
        pEnumA->Release();

        return hr;
    }

    if ( lstrlenW( bstrNewAddress ) == 0 )
    {
        LOG((RTC_ERROR, "StoreMRUAddress - "
                            "empty address string"));
                   
        RegCloseKey( hkeyMRU );
        pEnumA->Release();
        SysFreeString( bstrNewAddress );

        return E_INVALIDARG;
    }

    pAddress->get_Label( &bstrNewLabel ); // NULL is okay

    //
    // Go through the list
    //

    HKEY            hkeySubkey;
    TCHAR           szSubkey[256];
    IRTCAddress   * pA = NULL;

    for ( int n=0; n < 10; n++ )
    {
        if (n == 0)
        {
            //
            // Insert the new address at the top of the list
            //        

            pA = pAddress;
            pA->AddRef();
        }
        else
        {
            //
            // Get an address from the enumeration
            //

            hr = pEnumA->Next( 1, &pA, NULL);

            if (hr == S_FALSE)
            {
                //
                // No more addresses, we are done.
                //

                break;
            }
            else if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "StoreMRUAddress - "
                                    "Next failed 0x%lx", hr ));

                RegCloseKey( hkeyMRU );
                pEnumA->Release();
                SysFreeString( bstrNewAddress );
                SysFreeString( bstrNewLabel );

                return hr;
            }

            //
            // We got the address, check if it matches the new address
            //

            BSTR            bstrLabel = NULL;
            BSTR            bstrAddress = NULL;
            BOOL            fMatch = TRUE;

            hr = pA->get_Address( &bstrAddress );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "StoreMRUAddress - "
                                    "get_Address failed 0x%lx", hr ));

                RegCloseKey( hkeyMRU );
                pEnumA->Release();
                SysFreeString( bstrNewAddress );
                SysFreeString( bstrNewLabel );

                return hr;
            }

            pA->get_Label( &bstrLabel ); // NULL is okay            

            //
            // Check address string
            // 
            
            if ( wcscmp( bstrNewAddress, bstrAddress ) != 0 )
            {
                fMatch = FALSE;
            }          

            //
            // Check label string
            //

            if (bstrNewLabel != NULL)
            {
                if (bstrLabel != NULL) 
                {
                    if ( wcscmp( bstrNewLabel, bstrLabel ) != 0 )
                    {
                        fMatch = FALSE;
                    }
                }
                else
                {
                    fMatch = FALSE;
                }
            }
            else
            {
                if (bstrLabel != NULL)
                {
                    fMatch = FALSE;
                }
            }

            SysFreeString( bstrAddress );
            SysFreeString( bstrLabel );

            if ( fMatch == TRUE )
            {
                //
                // We got a match, we need to skip this item
                //

                pA->Release();
                n--;                

                continue;
            }
        }

        //
        // Store the address
        //

        _stprintf( szSubkey, _T("%d"), n );

        lResult = RegCreateKeyEx(
                                 hkeyMRU,
                                 szSubkey,
                                 0,
                                 NULL,
                                 0,
                                 KEY_WRITE,
                                 NULL,
                                 &hkeySubkey,
                                 NULL
                                );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "StoreMRUAddress - "
                                "RegCreateKeyEx(Subkey) failed %d", lResult));
                    
            RegCloseKey( hkeyMRU );
            pA->Release();
            pEnumA->Release();
            SysFreeString( bstrNewAddress );
            SysFreeString( bstrNewLabel );

            return HRESULT_FROM_WIN32(lResult);
        }

        CRTCAddress * pCAddress;

        pCAddress = static_cast<CRTCAddress *>(pA);

        hr = pCAddress->RegStore( hkeySubkey );

        pA->Release();
        RegCloseKey( hkeySubkey );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "StoreMRUAddress - "
                                "RegStore failed 0x%lx", hr ));

            RegCloseKey( hkeyMRU );
            pEnumA->Release();
            SysFreeString( bstrNewAddress );
            SysFreeString( bstrNewLabel );

            return hr;
        }
    }                          

    pEnumA->Release();

    RegCloseKey( hkeyMRU );

    SysFreeString( bstrNewAddress );
    SysFreeString( bstrNewLabel );

    LOG((RTC_TRACE, "StoreMRUAddress - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// EnumerateMRUAddresses
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
EnumerateMRUAddresses(
            IRTCEnumAddresses ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "EnumerateMRUAddresses enter"));

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumAddresses * ) ) )
    {
        LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                            "bad IRTCEnumAddresses pointer"));

        return E_POINTER;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumAddresses,
                          IRTCAddress,
                          &IID_IRTCEnumAddresses > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumAddresses,
                               IRTCAddress,
                               &IID_IRTCEnumAddresses > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize();

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    LONG lResult;
    HKEY hkeyMRU;

    //
    // Open the MRU key
    //

    lResult = RegCreateKeyEx(
                             HKEY_CURRENT_USER,
                             _T("Software\\Microsoft\\Phoenix\\MRU"),
                             0,
                             NULL,
                             0,
                             KEY_READ,
                             NULL,
                             &hkeyMRU,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                            "RegCreateKeyEx(MRU) failed %d", lResult));
        
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Enumerate subkeys
    //
    
    WCHAR szSubkey[256];
    DWORD cSize;

    for ( int n = 0; TRUE; n++ )
    {
        cSize = 256;

        lResult = RegEnumKeyExW(
                                hkeyMRU,
                                n,
                                szSubkey,
                                &cSize,
                                NULL,
                                NULL,
                                NULL,
                                NULL
                               );

        if ( lResult == ERROR_NO_MORE_ITEMS )
        {
            LOG((RTC_INFO, "EnumerateMRUAddresses - "
                            "no more items"));
            break;
        }
        else if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                            "RegKeyEnumKeyExW failed %d", lResult));
        
            RegCloseKey( hkeyMRU );

            p->Release();

            return HRESULT_FROM_WIN32(lResult);
        }

        //
        // Open the subkey
        //

        HKEY  hkeySubkey;

        lResult = RegOpenKeyExW(
                        hkeyMRU,
                        szSubkey,
                        0,
                        KEY_READ,                         
                        &hkeySubkey
                       );

        if ( lResult != ERROR_SUCCESS )
        {
            LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                                "RegOpenKeyExW failed %d", lResult));

            RegCloseKey( hkeyMRU );

            p->Release();
        
            return HRESULT_FROM_WIN32(lResult);
        }

        //
        // Create an address
        //

        IRTCAddress * pAddress;

        hr = CreateAddress( &pAddress );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                                "CreateAddress failed 0x%lx", hr));

            RegCloseKey( hkeyMRU );
            RegCloseKey( hkeySubkey );

            p->Release();
        
            return HRESULT_FROM_WIN32(lResult);
        }

        //
        // Read in the address data
        //

        CRTCAddress * pCAddress;

        pCAddress = static_cast<CRTCAddress *>(pAddress);

        hr = pCAddress->RegRead( hkeySubkey );

        RegCloseKey( hkeySubkey );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                                "RegRead failed 0x%lx", hr));

            RegCloseKey( hkeyMRU );

            pAddress->Release();
            p->Release();
        
            return HRESULT_FROM_WIN32(lResult);
        }

        //
        // Add address to the enumeration
        //

        hr = p->Add( pAddress );

        pAddress->Release();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "EnumerateMRUAddresses - "
                                "Add failed 0x%lx", hr));

            RegCloseKey( hkeyMRU );

            p->Release();
        
            return HRESULT_FROM_WIN32(lResult);
        }        
    }

    RegCloseKey( hkeyMRU );

    *ppEnum = p;

    LOG((RTC_TRACE, "EnumerateMRUAddresses - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\rtcaddress.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCAddress.h

Abstract:

    Definition of the CRTCAddress class

--*/

#ifndef __RTCADDRESS__
#define __RTCADDRESS__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRTCAddress

class ATL_NO_VTABLE CRTCAddress : 
    public IRTCAddress, 
    public CComObjectRoot
{
public:
    CRTCAddress() : m_szAddress(NULL),
                    m_szLabel(NULL),
                    m_enType(RTCAT_PHONE)
    {}
    
BEGIN_COM_MAP(CRTCAddress)
    COM_INTERFACE_ENTRY(IUnknown)
    COM_INTERFACE_ENTRY(IRTCAddress)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();   

    HRESULT RegStore(
        HKEY hkey
        );

    HRESULT RegRead(
        HKEY hkey
        );

    HRESULT RegDelete(
        HKEY hkey
        );

private:

    PWSTR               m_szAddress;
    PWSTR               m_szLabel;
    RTC_ADDRESS_TYPE    m_enType;

#if DBG
    PWSTR               m_pDebug;
#endif
    
// IRTCAddress
public:
         
    STDMETHOD(put_Address)(
            BSTR bstrAddress
            );  
            
    STDMETHOD(get_Address)(
            BSTR * pbstrAddress
            );  
            
    STDMETHOD(put_Label)(
            BSTR bstrLabel
            );  
            
    STDMETHOD(get_Label)(
            BSTR * pbstrLabel
            );  

    STDMETHOD(put_Type)(
            RTC_ADDRESS_TYPE enType
            );  
            
    STDMETHOD(get_Type)(
            RTC_ADDRESS_TYPE * penType
            );  

};


HRESULT CreateAddress(
        IRTCAddress ** ppAddress
        );

HRESULT StoreMRUAddress(
        IRTCAddress * pAddress
        );

HRESULT EnumerateMRUAddresses(   
        IRTCEnumAddresses ** ppEnum
        ); 

#endif //__RTCADDRESS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\urlreg.h ===
#ifndef __URLREG_H_
#define __URLREG_H_

void CheckURLRegistration(HWND hParent);
void InstallUrlMonitors(BOOL  bInstall);

DWORD GetShortModuleFileNameW(
  HMODULE hModule,    // handle to module
  LPTSTR szPath,  // file name of module
  DWORD nSize         // size of buffer
);

#endif __URLREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\rtcclnt.cpp ===
//
// rtcclnt.cpp : Implementation of WinMain
//

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f frameps.mk in the project directory.

#include "stdafx.h"
#include "mainfrm.h"
#include "coresink.h"
#include "ctlsink.h"
#include <initguid.h>
#include "windows.h"
#include "frameimpl.h"
#include "webctl.h"
#include "dplayhlp.h"

#include "rtcctl_i.c"
#include "rtcframe_i.c"
#include "RTCSip_i.c"

HANDLE g_hMutex = NULL;

extern const TCHAR * g_szWindowClassName;

// Global pointer to access the frame object within the code. 
CMainFrm * g_pMainFrm = NULL;

// This name has to be a system-wise unique name.
const WCHAR * g_szRTCClientMutexName = L"RTCClient.GlobalMutex.1";

// Contextual help file
WCHAR   g_szExeContextHelpFileName[] = L"RTCCLNT.HLP";

// Sink for the activeX control notifications
CComObjectGlobal<CRTCCtlNotifySink> g_NotifySink;

// Sink for the core api notifications
CComObjectGlobal<CRTCCoreNotifySink> g_CoreNotifySink;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RTCFrame, CRTCFrame)
OBJECT_ENTRY_NON_CREATEABLE(CRTCDPlay)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//
//

LPCTSTR SkipToken(LPCTSTR p)
{
	LONG lNumQuotes = 0;

	while ((p != NULL) && (*p != _T('\0')))
	{
		if (*p == _T('\"'))
		{
            // increment the count of quotes that we have seen
			lNumQuotes++;
		}
		else if (*p == _T(' '))
		{
            // ignore spaces inside a set of quotes
			if ( !(lNumQuotes & 1) )
			{
                // find the next non-space character
                while (*p == _T(' '))
                {
                    p = CharNext(p);

                    if (*p == _T('\0'))
                    {
                        // this is the end of line
                        return NULL;
                    }
                }

                // found it, return this pointer
				return p;
			}
		}

        // move on to next character
		p = CharNext(p);
	}

    // null pointer or end of line
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT PlaceOnTop(IRTCFrame * pRTCFrame)
{
    LOG((RTC_TRACE, "PlaceOnTop - enter"));

    HWND hWnd;

    LONG result;

    HRESULT hr;

    hr = pRTCFrame->OnTop();
    
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "PlaceOnTop - Failed while invoking OnTop: (0x%x)", hr));
        return hr;
    }

    // Now find the window, given its class. 

    hWnd = FindWindow(g_szWindowClassName, NULL);

    if (hWnd == NULL)
    {
        result = GetLastError();

        LOG((RTC_ERROR, "PlaceOnTop - Failed to get window handle(%d)", 
                        result));

        return E_FAIL;
    }
    else
    {
        LOG((RTC_INFO, "PlaceOnTop - found a window(handle=0x%x)", hWnd));
    }

    // Now set this window to foreground

    SetForegroundWindow(hWnd);

    // Window should be in the foreground now.

    LOG((RTC_TRACE, "PlaceOnTop - exit"));

    return S_OK;


}
/////////////////////////////////////////////////////////////////////////////
//
//

extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    IRTCFrame * pRTCFrame;
    IUnknown * pUnk;

    WCHAR data[100]; // for debugging purposes; temporary

    BOOL fMakeCall = FALSE;

    BSTR bstrCallString;

    WCHAR * szCallString;

    HRESULT hr;

    DWORD dwErrorCode;

    LOGREGISTERTRACING(_T("RTCCLNT"));
    LOGREGISTERDEBUGGER(_T("RTCCLNT"));

    LOG((RTC_INFO, "_tWinMain - enter"));

    //
    // Create a heap for memory allocation
    //
    if ( RtcHeapCreate() == FALSE )
    {

        return 0;
    }
    
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_RTCFRAMELib);
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    BOOL bLobbied = FALSE;
    LPCTSTR lpszParam = SkipToken(lpCmdLine);   

    if (lpszParam != NULL)
    {
		if ( (*lpszParam == _T('/')) || (*lpszParam == _T('-')) )
		{
			lpszParam = CharNext(lpszParam);

			if ( lstrcmpi(lpszParam, _T("UnregServer"))==0 )
			{
				InstallUrlMonitors(FALSE);
				nRet = _Module.UnregisterServer(TRUE);
				_Module.UnRegisterTypeLib(_T("\\1"));
				bRun = FALSE;
			}
			else if (lstrcmpi(lpszParam, _T("RegServer"))==0)
			{
				nRet = _Module.RegisterServer(TRUE);
				hr = _Module.RegisterTypeLib(_T("\\1"));
				InstallUrlMonitors(TRUE);
				bRun = FALSE;
			}
			else if (lstrcmpi(lpszParam, _T("Embedding"))==0)
			{
				bRun = TRUE;
			}
			else if (lstrcmpi(lpszParam, LAUNCHED_FROM_LOBBY_SWITCH)==0)
			{
				bLobbied = TRUE;
			}
		}
		else
		{
			// this must be a call parameter

			if ( (*lpszParam) != NULL )
			{
				fMakeCall = TRUE;
				szCallString = (WCHAR *)lpszParam;
			}
		}
	}

    if (bRun)
    {

        if(bLobbied)
        {
            hr = dpHelper.DirectPlayConnect();

            if(SUCCEEDED(hr))
            {
                szCallString = dpHelper.s_Address;

                if(*szCallString != L'\0')
                {
                    fMakeCall = TRUE;
                }
            }
            else
            {
                LOG((RTC_ERROR, "_tWinMain - DirectPlayConnect failed: (0x%x)", hr));

                // don't fail..
            }
        }
                
        g_hMutex = CreateMutex(NULL,
                             FALSE,
                             g_szRTCClientMutexName
                             );
        dwErrorCode = GetLastError();
        if (g_hMutex == NULL)
        {
            LOG((RTC_ERROR, "_tWinMain - Failed to CreateMutex: (0x%x)", dwErrorCode));
            return HRESULT_FROM_WIN32(dwErrorCode);
        }

        // check if this is the first instance or the second.
        if (dwErrorCode == ERROR_ALREADY_EXISTS)
        {
            // Another instance is running. 
            LOG((RTC_TRACE, "_tWinMain - Another instance is running"));

            // Close the mutex since we don't need it.
            CloseHandle(g_hMutex);

            // CoCreate on the other instance object.
            hr  = CoCreateInstance(
                    CLSID_RTCFrame,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    IID_IUnknown,
                    (void **)&pUnk);

            if ( SUCCEEDED( hr ) )
            {
                // this is the second instance running.
                
                // Get the IRTCFrame interface
        
                hr = pUnk->QueryInterface(IID_IRTCFrame, (void **)&pRTCFrame);
        
                pUnk->Release();
        
                if ( FAILED( hr ) )
                {
                    LOG((RTC_ERROR, "_tWinMain - Failed to QI for Frame: (0x%x)", hr));

                    return hr;
                }

                // Bring the other instance on top first.
                
                LOG((RTC_TRACE, "Bringing the first instance on top"));
                
                hr = PlaceOnTop(pRTCFrame);
                
                if ( FAILED( hr ) )
                {
                    LOG((RTC_ERROR, "_tWinMain - Failed while invoking PlaceOnTop: (0x%x)", hr));
            
                    // do we want to go ahead or do we exit??
                    pRTCFrame->Release();
                    return hr;
                }

                // Check if we have to make a call, if so, pass the 
                // command-line parameter to the other instance.

                if (fMakeCall)
                {
                    // allocate BSTR for the call parameter to be passed.
                
                    bstrCallString = SysAllocString(szCallString);
                    
                    if ( bstrCallString == NULL )
                    {
                        // can't allocate memory for the call string.

                        LOG((RTC_ERROR, "_tWinMain - Failed to allocate memory for CallString"));
                    
                        return E_OUTOFMEMORY;
                    }
                    
                    LOG((RTC_TRACE, "_tWinMain - Call parameter: %s", bstrCallString));
                    
                    hr = pRTCFrame->PlaceCall(bstrCallString);

                    // release the string since we don't need it now.

                    SysFreeString(bstrCallString);
            
                    // check if the call succeeded or not..

                    if ( FAILED( hr ) )
                    {
            
                        LOG((RTC_ERROR, "_tWinMain - Failed while invoking MakeCall: (0x%x)", hr));

                        pRTCFrame->Release();

                        // do we want to go ahead or do we exit??
                        return hr;
                    }

                    // Call message was passed successfully to the other 
                    // instance, now exit.
            
                    LOG((RTC_TRACE, "_tWinMain - Exiting the second instance after making call."));

                    pRTCFrame->Release();
                    
                    return S_OK;
                }

                else
                {
                    // We don't have to make call, so nothing to do except exit.

                    LOG((RTC_TRACE, "_tWinMain - Exiting the second instance"));
                    
                    pRTCFrame->Release();

                    return S_OK;
                }
            } // SUCCEEDED
            
            else
            {
                // CoCreate failed, can't proceed.

                LOG((RTC_ERROR, "_tWinMain - Failed in CoCreate: (0x%x)", hr));
                
                return hr;
            }

        } // ERROR_ALREADY_EXISTS

        // This is the first instance. So go ahead and do the usual stuff.

        // Register the class in class store.

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));

        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        InitCommonControls();

        AtlAxWinInit();

        AtlAxWebWinInit();

        //
        // Do some cleanup
        //

        SHDeleteKey(HKEY_CURRENT_USER, _T("Software\\Microsoft\\RTCClient"));
        SHDeleteKey(HKEY_CURRENT_USER, _T("Software\\Microsoft\\RTCMedia"));
        SHDeleteValue(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Phoenix"), _T("PreferredMediaTypes"));
        SHDeleteValue(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Phoenix"), _T("TermAudioCapture"));
        SHDeleteValue(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Phoenix"), _T("TermAudioRender"));
        SHDeleteValue(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Phoenix"), _T("TermVideoCapture"));
        SHDeleteValue(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Phoenix"), _T("Tuned"));

        //
        // Create the CMainFrm object.
        //
        
        LOG((RTC_TRACE, "_tWinMain - creating CMainFrm"));

        CMainFrm * pMainFrm = NULL;

        pMainFrm = new CMainFrm;

        if ( pMainFrm )
        {
            _ASSERTE( pMainFrm != NULL );
        
            LOG((RTC_TRACE, "_tWinMain - CMainFrm created, creating the dialog box"));

            g_pMainFrm = pMainFrm;
           
            // We put the command-line callParam as a member variable here, 
            // so that it can be used to make a call when the state is idle. 
            // allocate BSTR for the call parameter to be passed.

            if (fMakeCall)
            {
                bstrCallString = SysAllocString(szCallString);
            
                if ( bstrCallString == NULL )
                {
                    // can't allocate memory for the call string.

                    LOG((RTC_ERROR, "_tWinMain - Failed to allocate memory for CallString"));
                    // This is not fatal, we just can't place this call..
                }
                else
                {
                    // Put the call paramter now..
                    LOG((RTC_TRACE, "_tWinMain - Call parameter: %S", bstrCallString));
                    pMainFrm->SetPendingCall(bstrCallString);
                }
            
            }

            //
            // Create the window
            //

            HWND    hWnd;
            RECT    rcPos = {
                            0, 0,
                            UI_WIDTH + 2*GetSystemMetrics(SM_CXFIXEDFRAME),
                            UI_HEIGHT + 2*GetSystemMetrics(SM_CYFIXEDFRAME) + GetSystemMetrics(SM_CYCAPTION)
                            };
            
            hWnd = pMainFrm->Create(  NULL, rcPos, NULL,
                WS_POPUP | WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_CLIPCHILDREN | WS_VISIBLE, 0);

            if ( hWnd )
            {

                LOG((RTC_TRACE, "_tWinMain - Entering message loop"));

                MSG msg;
                while ( 0 < GetMessage( &msg, 0, 0, 0 ) )
                {
                    if( ! pMainFrm->IsDialogMessage( &msg) )
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
      
                LOG((RTC_TRACE, "_tWinMain - Message loop exited"));
            }
            else
            {
                LOG((RTC_ERROR, "_tWinMain - Cannot create the window"));
            }

        } // if got non-NULL hWnd from pMainFrm->Create()
    
        // release any DirectPlay pointers
        dpHelper.DirectPlayDisconnect();

    } // if bRun

    _Module.RevokeClassObjects();
    _Module.Term();
    CoUninitialize();
        
#if DBG
    //
    // Make sure we didn't leak anything
    //
             
    RtcDumpMemoryList();
#endif

    //
    // Destroy the heap
    //
        
    RtcHeapDestroy();        

    //
    // Unregister for debug tracing
    //
   
    LOG((RTC_INFO, "_tWinMain - exit"));

    LOGDEREGISTERDEBUGGER() ;
    LOGDEREGISTERTRACING();

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\rtcwab.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWAB.h

Abstract:

    Definition of the CRTCWAB and CRTCWABContact classes

--*/

#ifndef __RTCWAB__
#define __RTCWAB__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CRTCWABContact;

/////////////////////////////////////////////////////////////////////////////
// CRTCWAB

class ATL_NO_VTABLE CRTCWAB : 
    public IRTCContactList, 
    public IMAPIAdviseSink,
    public CComObjectRoot
{
public:
    CRTCWAB() : m_hinstWAB(NULL),
                m_lpfnWABOpen(NULL),
                m_lpAdrBook(NULL),
                m_lpWABObject(NULL),
                m_ulConnection(0)
    {}

    friend CRTCWABContact;
    
BEGIN_COM_MAP(CRTCWAB)
    COM_INTERFACE_ENTRY(IRTCContactList)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();   

private:

#if DBG
    PWSTR                   m_pDebug;
#endif

    HINSTANCE               m_hinstWAB;
    LPWABOPEN               m_lpfnWABOpen;
    LPADRBOOK               m_lpAdrBook;
    LPWABOBJECT             m_lpWABObject;
    ULONG                   m_ulConnection;
    HWND                    m_hWndAdvise;
    UINT                    m_uiEventID;
    
// IRTCContactList
public:

    STDMETHOD(EnumerateContacts)(   
            IRTCEnumContacts ** ppEnum
            ); 

    STDMETHOD(NewContact)(
            HWND hWnd,
            IRTCContact ** ppContact
            );

    STDMETHOD(get_Name)(
            BSTR * pbstrName
            ); 

    STDMETHOD(Advise)(
            HWND hWnd,
            UINT uiEventID
            );

    STDMETHOD(Unadvise)();
    
    STDMETHOD(NewContactNoUI)(
            BSTR bstrDisplayName,
            BSTR bstrEmailAddress,
            BOOL bIsBuddy
            );

// IMAPIAdviseSink
public:

    STDMETHOD_(ULONG,OnNotify)(
            ULONG cNotif,
            LPNOTIFICATION lpNotification
            );
};

/////////////////////////////////////////////////////////////////////////////
// CRTCWABContact

class ATL_NO_VTABLE CRTCWABContact : 
    public IRTCContact, 
    public CComObjectRoot
{
public:
    CRTCWABContact() : m_lpEID(NULL)
    {}
    
BEGIN_COM_MAP(CRTCWABContact)
    COM_INTERFACE_ENTRY(IUnknown)
    COM_INTERFACE_ENTRY(IRTCContact)
END_COM_MAP()

    HRESULT FinalConstruct();

    void FinalRelease();   

    HRESULT Initialize(
                       LPENTRYID lpEID,
                       ULONG cbEID,                     
                       LPABCONT lpContainer,
                       CRTCWAB * pCWAB
                      );

private:

#if DBG
    PWSTR                   m_pDebug;
#endif

    LPENTRYID               m_lpEID;
    ULONG                   m_cbEID;    
    LPABCONT                m_lpContainer;
    CRTCWAB               * m_pCWAB;

    HRESULT InternalCreateAddress(
            PWSTR szLabel,
            PWSTR szAddress,
            RTC_ADDRESS_TYPE enType,
            IRTCAddress ** ppAddress
            );
    
// IRTCContact
public:
    STDMETHOD(get_DisplayName)(
            BSTR * pbstrName
            ); 

    STDMETHOD(EnumerateAddresses)(   
            IRTCEnumAddresses ** ppEnum
            );

    STDMETHOD(Edit)(
            HWND hWnd
            );

    STDMETHOD(get_ContactList)(
            IRTCContactList ** ppContactList
            );

    STDMETHOD(Delete)();
    
    STDMETHOD(get_IsBuddy)(
            BOOL   *pVal
            );

    STDMETHOD(put_IsBuddy)(
            BOOL   bVal
            );
   
    STDMETHOD(get_DefaultEmailAddress)(
            BSTR   *pbstrVal
            );

    STDMETHOD(put_DefaultEmailAddress)(
            BSTR   bstrVal
            );

    STDMETHOD(GetEntryID)(
			ULONG	*pcbSize,
			BYTE	**ppEntryID
			);

};

HRESULT
CreateWAB(IRTCContactList ** ppContactList);

#endif //__RTCWAB__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\rtcwab.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCWAB.cpp

Abstract:

    Implementation of the CRTCWAB and CRTCWABContact classes

--*/

#include "stdafx.h"
#include "rtcwab.h"

enum {
    ieidPR_ENTRYID = 0,
	ieidPR_OBJECT_TYPE,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_ENTRYID,
		PR_OBJECT_TYPE,
    }
};


enum {
    inuiPR_DISPLAY_NAME = 0,
	inuiPR_EMAIL_ADDRESS,
    inuiPR_RTC_ISBUDDY,
    inuiMax
};

enum {
    inidPR_ENTRYID = 0,
    inidMax
};
static const SizedSPropTagArray(inidMax, ptaNid)=
{
    inidMax,
    {
        PR_ENTRYID,
    }
};

enum {
    inmPR_DISPLAY_NAME = 0,
    inmMax
};
static const SizedSPropTagArray(inmMax, ptaNm)=
{
    inmMax,
    {
        PR_DISPLAY_NAME
    }
};


enum {
    idemPR_EMAIL_ADDRESS = 0,
    idemMax
};
static const SizedSPropTagArray(idemMax, ptaDem)=
{
    idemMax,
    {
        PR_EMAIL_ADDRESS
    }
};


#define PRNAME_RTC_ISBUDDY      L"MS_RTC_IsBuddy"
const GUID PRGUID_RTC_ISBUDDY = {   // GUID for IsBuddy property
    0x621833ca,
    0x2636,
    0x4b7e,
    {0x82, 0xA0, 0x62, 0xe8, 0xb8, 0x3f, 0x02, 0x4f}
};

const   LPWSTR  CONTACT_IS_BUDDY  =  L"B";
const   LPWSTR  CONTACT_IS_NORMAL =  L"";


#define PR_IP_PHONE   PROP_TAG( PT_TSTRING, 0x800a )

enum {
    iadPR_BUSINESS_TELEPHONE_NUMBER = 0,
    iadPR_BUSINESS2_TELEPHONE_NUMBER,
    iadPR_CALLBACK_TELEPHONE_NUMBER,
    iadPR_CAR_TELEPHONE_NUMBER,
    iadPR_HOME_TELEPHONE_NUMBER,
    iadPR_HOME2_TELEPHONE_NUMBER,
    iadPR_MOBILE_TELEPHONE_NUMBER,
    iadPR_OTHER_TELEPHONE_NUMBER,
    iadPR_PAGER_TELEPHONE_NUMBER,
    iadPR_PRIMARY_TELEPHONE_NUMBER,
    iadPR_RADIO_TELEPHONE_NUMBER,
    iadPR_TTYTDD_PHONE_NUMBER,
    iadPR_IP_PHONE,
    iadPR_EMAIL_ADDRESS,
    iadMax
};
static const SizedSPropTagArray(iadMax, ptaAd)=
{
    iadMax,
    {
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS2_TELEPHONE_NUMBER,
		PR_CALLBACK_TELEPHONE_NUMBER,
        PR_CAR_TELEPHONE_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME2_TELEPHONE_NUMBER,
        PR_MOBILE_TELEPHONE_NUMBER,
        PR_OTHER_TELEPHONE_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_PRIMARY_TELEPHONE_NUMBER,
        PR_RADIO_TELEPHONE_NUMBER,
        PR_TTYTDD_PHONE_NUMBER,
        PR_IP_PHONE,
        PR_EMAIL_ADDRESS
    }
};

enum {
    icrPR_DEF_CREATE_MAILUSER = 0,
    icrPR_DEF_CREATE_DL,
    icrMax
};
const SizedSPropTagArray(icrMax, ptaCreate)=
{
    icrMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWAB::FinalConstruct()
{
    LOG((RTC_TRACE, "CRTCWAB::FinalConstruct - enter"));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( 1 );
#endif

    TCHAR  szWABDllPath[MAX_PATH];
    DWORD  dwType = 0;
    ULONG  cbData = sizeof(szWABDllPath);
    HKEY   hKey = NULL;
    LONG   lResult;

    *szWABDllPath = '\0';
    
    //
    // First we look under the default WAB DLL path location in the Registry. 
    // WAB_DLL_PATH_KEY is defined in wabapi.h
    //

    lResult = RegOpenKeyEx(
                           HKEY_LOCAL_MACHINE,
                           WAB_DLL_PATH_KEY,
                           0,
                           KEY_READ,
                           &hKey
                          );

    if ( lResult == ERROR_SUCCESS )
    {
        RegQueryValueEx( hKey, L"", NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

        RegCloseKey(hKey);
    }

    //
    // If the Registry came up blank, we do a LoadLibrary on the wab32.dll
    // WAB_DLL_NAME is defined in wabapi.h
    //

    m_hinstWAB = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME );

    if ( m_hinstWAB == NULL )
    {
        LOG((RTC_ERROR, "CRTCWAB::FinalConstruct - "
                            "LoadLibrary failed"));

        return E_FAIL;
    }

    //
    // If we loaded the dll, get the entry point 
    //

    m_lpfnWABOpen = (LPWABOPEN) GetProcAddress( m_hinstWAB, "WABOpen" );

    if ( m_lpfnWABOpen == NULL )
    {
        LOG((RTC_ERROR, "CRTCWAB::FinalConstruct - "
                            "GetProcAddress failed"));

        return E_FAIL;
    }

    //
    // We choose not to pass in a WAB_PARAM object, 
    // so the default WAB file will be opened up
    //

    HRESULT hr;

    hr = m_lpfnWABOpen(&m_lpAdrBook, &m_lpWABObject, NULL, 0);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::FinalConstruct - "
                            "WABOpen failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCWAB::FinalConstruct - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWAB::FinalRelease()
{
    LOG((RTC_TRACE, "CRTCWAB::FinalRelease - enter"));

#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    if( m_lpAdrBook != NULL )
    {        
        m_lpAdrBook->Release();
        m_lpAdrBook = NULL;
    }

    if( m_lpWABObject != NULL )
    {
        m_lpWABObject->Release();
        m_lpWABObject = NULL;
    }

    if( m_hinstWAB != NULL )
    {
        FreeLibrary(m_hinstWAB);
        m_hinstWAB = NULL;
    }

    LOG((RTC_TRACE, "CRTCWAB::FinalRelease - exit"));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::Advise
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWAB::Advise(
            HWND hWnd,
            UINT uiEventID
            )
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCWAB::Advise - enter"));

    //
    // Register for notification of changes in WAB
    //

    hr = m_lpAdrBook->Advise( 
                             0, 
                             NULL, 
                             fnevObjectModified, 
                             static_cast<IMAPIAdviseSink *>(this), 
                             &m_ulConnection
                            );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::Advise - "
                            "Advise failed 0x%lx", hr));

        //
        // Note: Versions of WAB prior to 4.5 don't support Advise
        //

        return hr;
    }
    
    LOG((RTC_INFO, "CRTCWAB::Advise - "
                        "connection [%d]", m_ulConnection));
 
    m_hWndAdvise = hWnd;
    m_uiEventID = uiEventID;

    LOG((RTC_TRACE, "CRTCWAB::Advise - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::Unadvise
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWAB::Unadvise()
{
    HRESULT hr = S_OK;

    LOG((RTC_TRACE, "CRTCWAB::Unadvise - enter"));

    if ( m_ulConnection != 0 )
    {
        hr = m_lpAdrBook->Unadvise( m_ulConnection );
    }

    LOG((RTC_TRACE, "CRTCWAB::Unadvise - exit 0x%lx", hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::EnumerateContacts
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWAB::EnumerateContacts(
            IRTCEnumContacts ** ppEnum
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCWAB::EnumerateContacts enter"));

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumContacts * ) ) )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "bad IRTCEnumContacts pointer"));

        return E_POINTER;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumContacts,
                          IRTCContact,
                          &IID_IRTCEnumContacts > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumContacts,
                               IRTCContact,
                               &IID_IRTCEnumContacts > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize();

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    //
    // Get the entryid of the root PAB container
    //

    ULONG       cbEID;
    LPENTRYID   lpEID = NULL;

    hr = m_lpAdrBook->GetPAB( &cbEID, &lpEID);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "GetPAB failed 0x%lx", hr));

        p->Release();
        
        return hr;
    }

    //
    // Open the root PAB container
    // This is where all the WAB contents reside
    //

    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;

    hr = m_lpAdrBook->OpenEntry(cbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);
	lpEID = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "OpenEntry failed 0x%lx", hr));

        p->Release();
        
        return hr;
    }

    //
    // Get a contents table of all the contents in the
    // WAB's root container
    //

    LPMAPITABLE lpAB =  NULL;

    hr = lpContainer->GetContentsTable( MAPI_UNICODE,
            							&lpAB);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "GetContentsTable failed 0x%lx", hr));

        
        lpContainer->Release();      
        p->Release();
        
        return hr;
    }

    //
    // Order the columns in the ContentsTable to conform to the
    // ones we want - which are mainly EntryID and ObjectType
    // The table is guaranteed to set the columns in the order 
    // requested
    //

	hr = lpAB->SetColumns( (LPSPropTagArray)&ptaEid, 0 );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "SetColumns failed 0x%lx", hr));

        
        lpAB->Release();
        lpContainer->Release();      
        p->Release();
        
        return hr;
    }

    //
    // Reset to the beginning of the table
    //
	hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                            "SeekRow failed 0x%lx", hr));

        
        lpAB->Release();
        lpContainer->Release();      
        p->Release();
        
        return hr;
    }
    
    //
    // Read all the rows of the table one by one
    //

    LPSRowSet   lpRowAB = NULL;
    int         cNumRows = 0;

	do 
    {
		hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                                "QueryRows failed 0x%lx", hr));

        
            lpAB->Release();
            lpContainer->Release();      
            p->Release();
        
            return hr;
        }

        cNumRows = lpRowAB->cRows;

		if (cNumRows)
		{
            LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
            ULONG cbEID = lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

            //
            // There are 2 kinds of objects - the MAPI_MAILUSER contact object
            // and the MAPI_DISTLIST contact object
            // For the purposes of this sample, we will only consider MAILUSER
            // objects
            //

            if(lpRowAB->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
            {
                //
                // Create the contact
                //

                CComObject<CRTCWABContact> * pCWABContact;
                hr = CComObject<CRTCWABContact>::CreateInstance( &pCWABContact );

                if ( hr == S_OK ) // CreateInstance deletes object on S_FALSE
                {
                    //
                    // Get the IRTCContact interface
                    //

                    IRTCContact * pContact = NULL;

                    hr = pCWABContact->QueryInterface(
                                           IID_IRTCContact,
                                           (void **)&pContact
                                          );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                                            "QI failed 0x%lx", hr));
        
                        delete pCWABContact;
                    } 
                    else
                    {
                        //
                        // Initialize the contact
                        //

                        hr = pCWABContact->Initialize(
                                                      lpEID,
                                                      cbEID,                                                     
                                                      lpContainer,
                                                      this
                                                      );

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                                                "Initialize failed 0x%lx", hr));
                        }
                        else
                        {
                            //
                            // Success, add it to the enumerator
                            //

                            hr = p->Add( pContact );

                            if ( FAILED(hr) )
                            {
                                LOG((RTC_ERROR, "CRTCWAB::EnumerateContacts - "
                                                    "Add failed 0x%lx", hr));
                            }
                        }

                        pContact->Release();
                    }
                    
                }
                else
                {
                    LOG((RTC_ERROR, "CRTCClient::EnumerateContacts - "
                                        "CreateInstance failed 0x%lx", hr));
                }
            }
		}

        //
        // Free the memory for this row
        //

        for (ULONG ulRow = 0; ulRow < lpRowAB->cRows; ++ulRow)
        {
            m_lpWABObject->FreeBuffer( lpRowAB->aRow[ulRow].lpProps );
        }

        m_lpWABObject->FreeBuffer( lpRowAB );

    } while ( cNumRows && lpRowAB );

    lpAB->Release();
    lpAB = NULL;

    lpContainer->Release();
    lpContainer = NULL;

    *ppEnum = p;

    LOG((RTC_TRACE, "CRTCWAB::EnumerateContacts - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::NewContact
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWAB::NewContact(
            HWND hWnd,
            IRTCContact ** ppContact
            )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCWAB::NewContact enter"));

    //
    // Chech argument (NULL is okay)
    //

    if ( (ppContact != NULL) &&
         IsBadWritePtr( ppContact, sizeof( IRTCContact * ) ) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                            "bad IRTCContact pointer"));

        return E_POINTER;
    }

    //
    // Get the entryid of the root PAB container
    //

    ULONG       cbContainerEID;
    LPENTRYID   lpContainerEID = NULL;

    hr = m_lpAdrBook->GetPAB( &cbContainerEID, &lpContainerEID);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                            "GetPAB failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Open the root PAB container
    // This is where all the WAB contents reside
    //

    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;

    hr = m_lpAdrBook->OpenEntry(cbContainerEID,
					    		(LPENTRYID)lpContainerEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);



    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                            "OpenEntry failed 0x%lx", hr));

        m_lpWABObject->FreeBuffer(lpContainerEID);
	    lpContainerEID = NULL;
        
        return hr;
    }

    //
    // Get the create templates
    //

    LPSPropValue lpCreateEIDs = NULL;
    ULONG cCreateEIDs;

    hr = lpContainer->GetProps(
                               (LPSPropTagArray)&ptaCreate,
                               0,
                               &cCreateEIDs,
                               &lpCreateEIDs
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                            "GetProps failed 0x%lx", hr));

        m_lpWABObject->FreeBuffer(lpContainerEID);
	    lpContainerEID = NULL;

        lpContainer->Release();
        lpContainer = NULL;
        
        return hr;
    }

    //
    // Validate the properties of the create templates (why)
    //

    if ( (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER) ||
         (lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                            "invalid properties"));

        m_lpWABObject->FreeBuffer(lpCreateEIDs);
        lpCreateEIDs = NULL;

        m_lpWABObject->FreeBuffer(lpContainerEID);
	    lpContainerEID = NULL;

        lpContainer->Release();
        lpContainer = NULL;
        
        return E_FAIL;
    }

    ULONG cbNewEID = 0;
    LPENTRYID lpNewEID = NULL;

    hr = m_lpAdrBook->NewEntry(
                               PtrToInt(hWnd),
                               0,
                               cbContainerEID,
                               lpContainerEID,
                               lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                               (LPENTRYID)lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.lpb,                              
                               &cbNewEID,
                               &lpNewEID
                              );

    m_lpWABObject->FreeBuffer(lpCreateEIDs);
    lpCreateEIDs = NULL;

    m_lpWABObject->FreeBuffer(lpContainerEID);
	lpContainerEID = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                            "NewEntry failed 0x%lx", hr));

        lpContainer->Release();
        lpContainer = NULL;

        return hr;
    }

    if ( ppContact != NULL )
    {
        //
        // Create the contact
        //

        CComObject<CRTCWABContact> * pCWABContact;
        hr = CComObject<CRTCWABContact>::CreateInstance( &pCWABContact );

        if ( hr != S_OK ) // CreateInstance deletes object on S_FALSE
        {
            LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                                    "CreateInstance failed 0x%lx", hr));

            m_lpWABObject->FreeBuffer(lpNewEID);
            lpNewEID = NULL;

            lpContainer->Release();
            lpContainer = NULL;

            return hr;
        }

        //
        // Get the IRTCContact interface
        //

        IRTCContact * pContact = NULL;

        hr = pCWABContact->QueryInterface(
                               IID_IRTCContact,
                               (void **)&pContact
                              );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                                "QI failed 0x%lx", hr));

            m_lpWABObject->FreeBuffer(lpNewEID);
            lpNewEID = NULL;

            lpContainer->Release();
            lpContainer = NULL;

            delete pCWABContact;

            return hr;
        } 

        //
        // Initialize the contact
        //

        hr = pCWABContact->Initialize(
                                      lpNewEID,
                                      cbNewEID,                                                     
                                      lpContainer,
                                      this
                                      );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWAB::NewContact - "
                                "Initialize failed 0x%lx", hr));

            pContact->Release();

            m_lpWABObject->FreeBuffer(lpNewEID);
            lpNewEID = NULL;

            lpContainer->Release();
            lpContainer = NULL;

            return hr;
        }

        *ppContact = pContact;
    }

    lpContainer->Release();
    lpContainer = NULL;
            
    m_lpWABObject->FreeBuffer(lpNewEID);
    lpNewEID = NULL;

    LOG((RTC_TRACE, "CRTCWAB::NewContact - exit S_OK"));

    return S_OK;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::NewContactNoUI
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWAB::NewContactNoUI(
    BSTR bstrDisplayName,
    BSTR bstrEmailAddress,
    BOOL bIsBuddy
    )
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCWAB::NewContactNoUI enter"));

    //
    // Check arguments
    //

    if (IsBadStringPtrW( bstrDisplayName, -1 ) ||
        IsBadStringPtrW( bstrEmailAddress, -1 ))
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "bad parameters"));

        return E_POINTER;
    }

    //
    // Get the entryid of the root PAB container
    //

    ULONG       cbContainerEID;
    LPENTRYID   lpContainerEID = NULL;

    hr = m_lpAdrBook->GetPAB( &cbContainerEID, &lpContainerEID);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "GetPAB failed 0x%lx", hr));
        
        return hr;
    }

    //
    // Open the root PAB container
    // This is where all the WAB contents reside
    //

    ULONG       ulObjType = 0;
    LPABCONT    lpContainer = NULL;

    hr = m_lpAdrBook->OpenEntry(cbContainerEID,
					    		(LPENTRYID)lpContainerEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);



    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "OpenEntry failed 0x%lx", hr));

        m_lpWABObject->FreeBuffer(lpContainerEID);
	    lpContainerEID = NULL;
        
        return hr;
    }

    //
    // Get the create templates
    //

    LPSPropValue lpCreateEIDs = NULL;
    ULONG cCreateEIDs;

    hr = lpContainer->GetProps(
                               (LPSPropTagArray)&ptaCreate,
                               0,
                               &cCreateEIDs,
                               &lpCreateEIDs
                              );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "GetProps failed 0x%lx", hr));

        m_lpWABObject->FreeBuffer(lpContainerEID);
	    lpContainerEID = NULL;

        lpContainer->Release();
        lpContainer = NULL;
        
        return hr;
    }

    //
    // Validate the properties of the create templates (why)
    //

    if ( (lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER) ||
         (lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "invalid properties"));

        m_lpWABObject->FreeBuffer(lpCreateEIDs);
        lpCreateEIDs = NULL;

        m_lpWABObject->FreeBuffer(lpContainerEID);
	    lpContainerEID = NULL;

        lpContainer->Release();
        lpContainer = NULL;
        
        return E_FAIL;
    }

    //
    // Create a new entry based on MAILUSER template
    //
    
    
    ULONG cbNewEID = 0;
    LPENTRYID lpNewEID = NULL;

    LPMAPIPROP   lpMapiProp = NULL;

    hr = lpContainer->CreateEntry(
                               lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                               (LPENTRYID)lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.lpb,                              
                               0, // no flags here
                               &lpMapiProp);
    
    m_lpWABObject->FreeBuffer(lpCreateEIDs);
    lpCreateEIDs = NULL;

    m_lpWABObject->FreeBuffer(lpContainerEID);
	lpContainerEID = NULL;

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "CreateEntry failed 0x%lx", hr));

        lpContainer->Release();
        lpContainer = NULL;

        return hr;
    }
    
    //
    // Find the id of the custom named property
    //
    
    MAPINAMEID  mnId;
    LPMAPINAMEID lpmnid = (LPMAPINAMEID)&mnId;
    LPSPropTagArray ptag = NULL;
    
    mnId.lpguid = (LPGUID)&PRGUID_RTC_ISBUDDY;
    mnId.ulKind = MNID_STRING;
    mnId.Kind.lpwstrName = PRNAME_RTC_ISBUDDY;

    hr = lpMapiProp -> GetIDsFromNames(
        1,
        &lpmnid,
        MAPI_CREATE,  // create it if it doesn't exist
        &ptag);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCWABContact::NewContactNoUI - "
                            "GetIDsFromNames failed 0x%lx", hr ));
        
        lpContainer->Release();
        lpContainer = NULL;
        
        lpMapiProp->Release();
        lpMapiProp = NULL;

        return hr;
    }
    
    //
    // Set properties
    //

    SPropValue PropValues[inuiMax];
    
    PropValues[inuiPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
    PropValues[inuiPR_DISPLAY_NAME].Value.lpszW = bstrDisplayName;
    PropValues[inuiPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
    PropValues[inuiPR_EMAIL_ADDRESS].Value.lpszW = bstrEmailAddress;
    PropValues[inuiPR_RTC_ISBUDDY].ulPropTag = PROP_TAG(PT_TSTRING, PROP_ID(ptag->aulPropTag[0]));
    PropValues[inuiPR_RTC_ISBUDDY].Value.lpszW =  bIsBuddy ? CONTACT_IS_BUDDY : CONTACT_IS_NORMAL;

    hr = lpMapiProp->SetProps(
        inuiMax,
        PropValues,
        NULL
    );
     
    m_lpWABObject->FreeBuffer(ptag);
   
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "SetProps failed 0x%lx", hr));
        
        lpContainer->Release();
        lpContainer = NULL;

        lpMapiProp->Release();
        lpMapiProp = NULL;

        return hr;
    }

    //
    // Save the changes. 
    // 
    
    hr = lpMapiProp->SaveChanges(
        FORCE_SAVE | KEEP_OPEN_READONLY);
    

    lpContainer->Release();
    lpContainer = NULL;
    
    lpMapiProp->Release();
    lpMapiProp = NULL;
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWAB::NewContactNoUI - "
                            "SaveChanges failed 0x%lx", hr));

        return hr;
    }


    LOG((RTC_TRACE, "CRTCWAB::NewContactNoUI - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::get_Name
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWAB::get_Name(
        BSTR * pbstrName
        )
{
    LOG((RTC_TRACE, "CRTCWAB::get_Name - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWAB::get_Name - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    WCHAR   szName[256];
    szName[0] = L'\0';

    //
    // Load the string
    //
   
    LoadString(
        _Module.GetResourceInstance(), 
        (UINT)IDS_WAB,
        szName,
        sizeof(szName)/sizeof(WCHAR)
        );
    
    *pbstrName = SysAllocString(szName);

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWAB::get_Name - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    LOG((RTC_TRACE, "CRTCWAB::get_Name - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWAB::OnNotify
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG) 
CRTCWAB::OnNotify(
        ULONG cNotif,
        LPNOTIFICATION lpNotification
        )
{
    LOG((RTC_TRACE, "CRTCWAB::OnNotify - enter"));

    PostMessage( m_hWndAdvise, m_uiEventID, 0, 0 );

    LOG((RTC_TRACE, "CRTCWAB::OnNotify - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWABContact::FinalConstruct()
{
    // LOG((RTC_TRACE, "CRTCWABContact::FinalConstruct - enter"));

#if DBG
    m_pDebug = (PWSTR) RtcAlloc( 1 );
#endif

    // LOG((RTC_TRACE, "CRTCWABContact::FinalConstruct - exit S_OK"));

    return S_OK;
}  

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////

void 
CRTCWABContact::FinalRelease()
{
    // LOG((RTC_TRACE, "CRTCWABContact::FinalRelease - enter"));
    
#if DBG
    RtcFree( m_pDebug );
    m_pDebug = NULL;
#endif

    if ( m_lpEID != NULL )
    {
        RtcFree( m_lpEID );
        m_lpEID = NULL;
    }

    if ( m_lpContainer != NULL )
    {
        m_lpContainer->Release();
        m_lpContainer = NULL;
    }

    if ( m_pCWAB != NULL )
    {
        m_pCWAB->Release();
        m_pCWAB = NULL;
    }

    // LOG((RTC_TRACE, "CRTCWABContact::FinalRelease - exit"));
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::Initialize
//
/////////////////////////////////////////////////////////////////////////////

HRESULT 
CRTCWABContact::Initialize(
                           LPENTRYID lpEID, 
                           ULONG cbEID,
                           LPABCONT lpContainer,
                           CRTCWAB * pCWAB
                          )
{
    // LOG((RTC_TRACE, "CRTCWABContact::Initialize - enter"));

    m_lpEID = (LPENTRYID) RtcAlloc( cbEID );

    if ( m_lpEID == NULL )
    {
        LOG((RTC_ERROR, "CRTCWABContact::Initialize - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    CopyMemory( m_lpEID, lpEID, cbEID );
    m_cbEID = cbEID;

    m_lpContainer = lpContainer;
    m_lpContainer->AddRef();

    m_pCWAB = pCWAB;
    m_pCWAB->AddRef();

    // LOG((RTC_TRACE, "CRTCWABContact::Initialize - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::get_DisplayName
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWABContact::get_DisplayName(
        BSTR * pbstrName
        )
{
    // LOG((RTC_TRACE, "CRTCWABContact::get_DisplayName - enter"));

    if ( IsBadWritePtr( pbstrName, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DisplayName - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Open the entry
    //

    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;
    HRESULT hr;

    hr = m_lpContainer->OpenEntry(
                                  m_cbEID,
                                  m_lpEID,
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser
                                 );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DisplayName - "
                            "OpenEntry failed 0x%lx", hr ));

        return hr;
    }
    
    //
    // Get the property
    //

    LPSPropValue lpPropArray = NULL;
    ULONG        ulcValues = 0;

    hr = lpMailUser->GetProps(
                              (LPSPropTagArray)&ptaNm,
                              MAPI_UNICODE,
                              &ulcValues,
                              &lpPropArray
                             );

    lpMailUser->Release();
    lpMailUser = NULL;

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DisplayName - "
                            "GetProps failed 0x%lx", hr ));

        return hr;
    }

    //
    // Validate the property
    //

    if ( PROP_TYPE(lpPropArray[inmPR_DISPLAY_NAME].ulPropTag) != PT_TSTRING )
    {     
        LOG((RTC_ERROR, "CRTCWABContact::get_DisplayName - "
                            "invalid propery" ));

        m_pCWAB->m_lpWABObject->FreeBuffer(lpPropArray);
        lpPropArray = NULL;

        return E_FAIL;
    }

    // LOG((RTC_INFO, "CRTCWABContact::get_DisplayName - "
    //        "[%ws]", lpPropArray[inmPR_DISPLAY_NAME].Value.LPSZ));  
    
    *pbstrName = SysAllocString( lpPropArray[inmPR_DISPLAY_NAME].Value.LPSZ );

    m_pCWAB->m_lpWABObject->FreeBuffer(lpPropArray);
    lpPropArray = NULL;

    if ( *pbstrName == NULL )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DisplayName - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCWABContact::get_DisplayName - exit S_OK"));

    return S_OK;
} 


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::get_DefaultEmailAddress
//
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CRTCWABContact::get_DefaultEmailAddress(
        BSTR * pbstrAddress
        )
{
    // LOG((RTC_TRACE, "CRTCWABContact::get_DefaultEmailAddress - enter"));

    if ( IsBadWritePtr( pbstrAddress, sizeof(BSTR) ) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DefaultEmailAddress - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Open the entry
    //

    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;
    HRESULT hr;

    hr = m_lpContainer->OpenEntry(
                                  m_cbEID,
                                  m_lpEID,
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser
                                 );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DefaultEmailAddress - "
                            "OpenEntry failed 0x%lx", hr ));

        return hr;
    }
    
    //
    // Get the property
    //

    LPSPropValue lpPropArray = NULL;
    ULONG        ulcValues = 0;

    hr = lpMailUser->GetProps(
                              (LPSPropTagArray)&ptaDem,
                              MAPI_UNICODE,
                              &ulcValues,
                              &lpPropArray
                             );

    lpMailUser->Release();
    lpMailUser = NULL;

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DefaultEmailAddress - "
                            "GetProps failed 0x%lx", hr ));

        return hr;
    }

    //
    // Validate the property
    //

    if ( PROP_TYPE(lpPropArray[idemPR_EMAIL_ADDRESS].ulPropTag) != PT_TSTRING )
    {     
        LOG((RTC_ERROR, "CRTCWABContact::get_DefaultEmailAddress - "
                            "invalid property" ));

        m_pCWAB->m_lpWABObject->FreeBuffer(lpPropArray);
        lpPropArray = NULL;

        // It's not an error
        *pbstrAddress = NULL;

        return S_FALSE;
    }

    // LOG((RTC_INFO, "CRTCWABContact::get_DefaultEmailAddress - "
    //        "[%ws]", lpPropArray[idemPR_EMAIL_ADDRESS].Value.LPSZ));  
    
    *pbstrAddress = SysAllocString( lpPropArray[idemPR_EMAIL_ADDRESS].Value.LPSZ );

    m_pCWAB->m_lpWABObject->FreeBuffer(lpPropArray);
    lpPropArray = NULL;

    if ( *pbstrAddress == NULL )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_DefaultEmailAddress - "
                            "out of memory"));

        return E_OUTOFMEMORY;
    }

    // LOG((RTC_TRACE, "CRTCWABContact::get_DefaultEmailAddress - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::GetEntryID
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::GetEntryID(
			ULONG	*pcbSize,
			BYTE	**ppEntryID
			)
{
    HRESULT     hr;

    if ( IsBadWritePtr( ppEntryID, sizeof(BYTE *) ) ||
        IsBadWritePtr( pcbSize, sizeof(ULONG *) ))
    {
        LOG((RTC_ERROR, "CRTCWABContact::GetEntryID - "
                            "bad parameter"));

        return E_POINTER;
    }

    // Make a copy of the stored entry id

    BYTE *pEntryID = NULL;

    if(m_cbEID == 0)
    {
        return E_UNEXPECTED;
    }

    pEntryID = (BYTE *)CoTaskMemAlloc(m_cbEID);
    if(!pEntryID)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pEntryID, m_lpEID, m_cbEID);

    *ppEntryID = pEntryID;
    *pcbSize = m_cbEID;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::EnumerateAddresses
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::EnumerateAddresses(
            IRTCEnumAddresses ** ppEnum
            )
{
    HRESULT                 hr;

    // LOG((RTC_TRACE, "CRTCWABContact::EnumerateAddresses enter"));

    if ( IsBadWritePtr( ppEnum, sizeof( IRTCEnumAddresses * ) ) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                            "bad IRTCEnumAddresses pointer"));

        return E_POINTER;
    }

    //
    // Create the enumeration
    //
 
    CComObject< CRTCEnum< IRTCEnumAddresses,
                          IRTCAddress,
                          &IID_IRTCEnumAddresses > > * p;
                          
    hr = CComObject< CRTCEnum< IRTCEnumAddresses,
                               IRTCAddress,
                               &IID_IRTCEnumAddresses > >::CreateInstance( &p );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
        
        return hr;
    }

    //
    // Initialize the enumeration (adds a reference)
    //
    
    hr = p->Initialize();

    if ( S_OK != hr )
    {
        LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                            "could not initialize enumeration" ));
    
        delete p;
        return hr;
    }

    //
    // Open the entry
    //

    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;

    hr = m_lpContainer->OpenEntry(
                                  m_cbEID,
                                  m_lpEID,
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser
                                 );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                            "OpenEntry failed 0x%lx", hr ));
    }
    else
    {
        LPSPropValue lpPropArray = NULL;
        ULONG        ulcValues = 0;

        hr = lpMailUser->GetProps(
                                  (LPSPropTagArray)&ptaAd,
                                  MAPI_UNICODE,
                                  &ulcValues,
                                  &lpPropArray
                                 );

        if( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                                "GetProps failed 0x%lx", hr ));
        }
        else
        {
            for (ULONG ul = 0; ul < ulcValues; ul++ )
            {
                if ( PROP_TYPE(lpPropArray[ul].ulPropTag) == PT_TSTRING )
                {                                       
                    WCHAR   szLabel[256];
                    szLabel[0] = L'\0';

                    //
                    // Load the string for the label
                    //
                   
                    LoadString(
                        _Module.GetResourceInstance(), 
                        (UINT)(ul + IDS_BUSINESS),
                        szLabel,
                        sizeof(szLabel)/sizeof(WCHAR)
                        );

                    // LOG((RTC_INFO, "CRTCWABContact::EnumerateAddresses - "
                    //        "%d: %ws [%ws]", ul, szLabel, lpPropArray[ul].Value.LPSZ));      

                    //
                    // Create the address
                    //

                    IRTCAddress * pAddress = NULL;
        
                    hr = InternalCreateAddress( 
                                               szLabel,
                                               lpPropArray[ul].Value.LPSZ,
                                               ((ul == iadPR_IP_PHONE) || (ul == iadPR_EMAIL_ADDRESS))
                                                    ? RTCAT_COMPUTER : RTCAT_PHONE,
                                               &pAddress
                                              );

                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                                            "InternalCreateAddress failed 0x%lx", hr));                     
                    } 
                    else
                    {
                        //
                        // Success, add it to the enumerator
                        //

                        hr = p->Add( pAddress );

                        pAddress->Release();

                        if ( FAILED(hr) )
                        {
                            LOG((RTC_ERROR, "CRTCWABContact::EnumerateAddresses - "
                                                "Add failed 0x%lx", hr));
                        }
                    }
                }
            }

            m_pCWAB->m_lpWABObject->FreeBuffer(lpPropArray);
            lpPropArray = NULL;
        }

        lpMailUser->Release();
    }

    *ppEnum = p;

    // LOG((RTC_TRACE, "CRTCWABContact::EnumerateAddresses - exit S_OK"));

    return S_OK;
}    

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::Edit
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::Edit(HWND hWnd)
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCWABContact::Edit - enter"));

    hr = m_pCWAB->m_lpAdrBook->Details( 
                                       (LPULONG) &hWnd,
                                       NULL,
                                       NULL,
                                       m_cbEID,
                                       m_lpEID,
                                       NULL,
                                       NULL,
                                       NULL,
                                       0
                                      );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::Edit - "
                            "Details failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCWABContact::Edit - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::get_ContactList
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::get_ContactList(
            IRTCContactList ** ppContactList
            )                               
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCWABContact::get_ContactList - enter"));

    if ( IsBadWritePtr( ppContactList, sizeof( IRTCContactList * ) ) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_ContactList - "
                            "bad IRTCContactList pointer"));

        return E_POINTER;
    }    
    
    //
    // Get the IRTCContactList interface
    //

    IRTCContactList * pContactList = NULL;

    hr = m_pCWAB->QueryInterface(
                           IID_IRTCContactList,
                           (void **)&pContactList
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_ContactList - "
                            "QI failed 0x%lx", hr));
        
        return hr;
    }

    *ppContactList = pContactList;

    LOG((RTC_TRACE, "CRTCWABContact::get_ContactList - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::Delete
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::Delete()
{
    HRESULT                 hr;

    LOG((RTC_TRACE, "CRTCWABContact::Delete - enter"));

    SBinary sb;
    ENTRYLIST el;

    sb.cb = m_cbEID;
    sb.lpb = (LPBYTE)m_lpEID;

    el.cValues = 1;
    el.lpbin = &sb;

    hr = m_lpContainer->DeleteEntries( 
                                      &el,
                                      0
                                     );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::Delete - "
                            "DeleteEntries failed 0x%lx", hr));

        return hr;
    }

    LOG((RTC_TRACE, "CRTCWABContact::Delete - exit S_OK"));

    return S_OK;
} 

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::get_IsBuddy
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::get_IsBuddy(BOOL *pVal)
{
    HRESULT                 hr;

    //LOG((RTC_TRACE, "CRTCWABContact::get_IsBuddy - enter"));

    if ( IsBadWritePtr( pVal, sizeof(BOOL) ) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_IsBuddy - "
                            "bad BSTR pointer"));

        return E_POINTER;
    }

    //
    // Open the entry
    //

    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;

    hr = m_lpContainer->OpenEntry(
                                  m_cbEID,
                                  m_lpEID,
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser
                                 );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_IsBuddy - "
                            "OpenEntry failed 0x%lx", hr ));

        return hr;
    }
    
    //
    // Find the id of the named property
    //
    
    MAPINAMEID  mnId;
    LPMAPINAMEID lpmnid = (LPMAPINAMEID)&mnId;
    LPSPropTagArray ptag = NULL;
    
    mnId.lpguid = (LPGUID)&PRGUID_RTC_ISBUDDY;
    mnId.ulKind = MNID_STRING;
    mnId.Kind.lpwstrName = PRNAME_RTC_ISBUDDY;

    hr = lpMailUser -> GetIDsFromNames(
        1,
        &lpmnid,
        0,  //don't create the property if it doesn't exist
        &ptag);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_IsBuddy - "
                            "GetIDsFromNames failed 0x%lx", hr ));

        return hr;
    }
    
    LPSPropValue lpPropArray = NULL;
    
    if(hr == S_OK)
    {
        //
        // Get the property
        //

        ULONG        ulcValues = 0;

        hr = lpMailUser->GetProps(
                                  ptag,
                                  MAPI_UNICODE,
                                  &ulcValues,
                                  &lpPropArray
                                 );
    }
    else
    {
        hr = S_OK;
    }

    lpMailUser->Release();
    lpMailUser = NULL;
    
    ULONG   nId = ptag->aulPropTag[0];

    m_pCWAB->m_lpWABObject->FreeBuffer(ptag);

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::get_IsBuddy - "
                            "GetProps failed 0x%lx", hr ));

        return hr;
    }

    //
    // Validate the property
    //
    
    *pVal = FALSE; // by default

    if(lpPropArray &&
       PROP_TYPE(lpPropArray[0].ulPropTag) == PT_TSTRING &&
       0 == wcscmp(lpPropArray[0].Value.LPSZ, CONTACT_IS_BUDDY))
    {
        *pVal = TRUE;
    }
   
    if(lpPropArray)
    {
        m_pCWAB->m_lpWABObject->FreeBuffer(lpPropArray);
        lpPropArray = NULL;
    }

    //LOG((RTC_TRACE, "CRTCWABContact::get_IsBuddy - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::put_IsBuddy
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::put_IsBuddy(BOOL bVal)
{
    HRESULT hr;

    //LOG((RTC_TRACE, "CRTCWABContact::put_IsBuddy - enter"));

    //
    // Open the entry
    //

    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;

    hr = m_lpContainer->OpenEntry(
                                  m_cbEID,
                                  m_lpEID,
                                  NULL,         // interface
                                  MAPI_MODIFY,  // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser
                                 );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_IsBuddy - "
                            "OpenEntry failed 0x%lx", hr ));

        return hr;
    }
    
    //
    // Find the id of the named property
    //
    
    MAPINAMEID  mnId;
    LPMAPINAMEID lpmnid = (LPMAPINAMEID)&mnId;
    LPSPropTagArray ptag = NULL;
    
    mnId.lpguid = (LPGUID)&PRGUID_RTC_ISBUDDY;
    mnId.ulKind = MNID_STRING;
    mnId.Kind.lpwstrName = PRNAME_RTC_ISBUDDY;

    hr = lpMailUser -> GetIDsFromNames(
        1,
        &lpmnid,
        MAPI_CREATE,  //create it if it doesn't exist
        &ptag);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_IsBuddy - "
                            "GetIDsFromNames failed 0x%lx", hr ));

        return hr;
    }
    
    //
    // Set the property
    //
    
    SPropValue PropValue;
    
    PropValue.ulPropTag = PROP_TAG(PT_TSTRING, PROP_ID(ptag->aulPropTag[0]));
    PropValue.dwAlignPad = 0;
    PropValue.Value.lpszW = bVal ? CONTACT_IS_BUDDY : CONTACT_IS_NORMAL;

    hr = lpMailUser->SetProps(
        1,
        &PropValue,
        NULL
    );

    
    m_pCWAB->m_lpWABObject->FreeBuffer(ptag);

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_IsBuddy - "
                            "SetProps failed 0x%lx", hr ));
        lpMailUser->Release();
        lpMailUser = NULL;

        return hr;
    }

    //
    // Save changes
    //
    hr = lpMailUser->SaveChanges(FORCE_SAVE);
    
    lpMailUser->Release();
    lpMailUser = NULL;
    
    
    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_IsBuddy - "
                            "SaveChanges failed 0x%lx", hr ));
        return hr;
    }

    //LOG((RTC_TRACE, "CRTCWABContact::put_IsBuddy - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::put_DefaultEmailAddress
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CRTCWABContact::put_DefaultEmailAddress(BSTR bstrAddress)
{
    HRESULT hr;

    //LOG((RTC_TRACE, "CRTCWABContact::put_DefaultEmailAddress - enter"));
    //
    // Chech arguments
    //

    if (IsBadStringPtrW( bstrAddress, -1 ))
    {
        LOG((RTC_ERROR, "CRTCWAB::put_DefaultEmailAddress - "
                            "bad parameter"));

        return E_POINTER;
    }
 
    //
    // Open the entry
    //

    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;

    hr = m_lpContainer->OpenEntry(
                                  m_cbEID,
                                  m_lpEID,
                                  NULL,         // interface
                                  MAPI_MODIFY,  // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser
                                 );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_DefaultEmailAddress - "
                            "OpenEntry failed 0x%lx", hr ));

        return hr;
    }
    
    //
    // Set the property
    //
    
    SPropValue PropValue;
    
    PropValue.ulPropTag = PR_EMAIL_ADDRESS;
    PropValue.dwAlignPad = 0;
    PropValue.Value.lpszW = bstrAddress;

    hr = lpMailUser->SetProps(
        1,
        &PropValue,
        NULL
    );

    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_DefaultEmailAddress - "
                            "SetProps failed 0x%lx", hr ));
        lpMailUser->Release();
        lpMailUser = NULL;

        return hr;
    }

    //
    // Save changes
    //
    hr = lpMailUser->SaveChanges(FORCE_SAVE);
    
    lpMailUser->Release();
    lpMailUser = NULL;
    
    
    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::put_DefaultEmailAddress - "
                            "SaveChanges failed 0x%lx", hr ));
        return hr;
    }

    //LOG((RTC_TRACE, "CRTCWABContact::put_DefaultEmailAddress - exit S_OK"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// CRTCWABContact::InternalCreateAddress
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CRTCWABContact::InternalCreateAddress(
            PWSTR szLabel,
            PWSTR szAddress,
            RTC_ADDRESS_TYPE enType,
            IRTCAddress ** ppAddress
            )
{
    HRESULT hr;
    
    // LOG((RTC_TRACE, "CRTCWABContact::InternalCreateAddress - enter"));   

    //
    // Create the phone number
    //

    CComObject<CRTCAddress> * pCAddress;
    hr = CComObject<CRTCAddress>::CreateInstance( &pCAddress );

    if ( S_OK != hr ) // CreateInstance deletes object on S_FALSE
    {
        LOG((RTC_ERROR, "CRTCWABContact::InternalCreateAddress - "
                            "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // Get the IRTCAddress interface
    //

    IRTCAddress * pAddress = NULL;

    hr = pCAddress->QueryInterface(
                           IID_IRTCAddress,
                           (void **)&pAddress
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::InternalCreateAddress - "
                            "QI failed 0x%lx", hr));
        
        delete pCAddress;
        
        return hr;
    }

    //
    // Put the label
    //
   
    hr = pAddress->put_Label( szLabel );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::InternalCreateAddress - "
                            "put_Label 0x%lx", hr));
        
        pAddress->Release();
        
        return hr;
    }

    //
    // Put the address
    //
   
    hr = pAddress->put_Address( szAddress );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::InternalCreateAddress - "
                            "put_Address 0x%lx", hr));
        
        pAddress->Release();
        
        return hr;
    }

    //
    // Put the type
    //
   
    hr = pAddress->put_Type( enType );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CRTCWABContact::InternalCreateAddress - "
                            "put_Type 0x%lx", hr));
        
        pAddress->Release();
        
        return hr;
    }

    *ppAddress = pAddress;

    // LOG((RTC_TRACE, "CRTCWABContact::InternalCreateAddress - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CreateWAB
//
/////////////////////////////////////////////////////////////////////////////
HRESULT
CreateWAB(IRTCContactList ** ppContactList)
{
    LOG((RTC_TRACE, "CreateWAB - enter"));

    HRESULT hr;

    CComObject<CRTCWAB> * pCWAB;
    hr = CComObject<CRTCWAB>::CreateInstance( &pCWAB );

    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "CreateWAB - "
                "CreateInstance failed 0x%lx", hr));

        if ( hr == S_FALSE )
        {
            hr = E_FAIL;
        }
            
        return hr;
    }

    //
    // We got the WAB, get the IRTCContactList interface
    //

    IRTCContactList * pContactList = NULL;

    hr = pCWAB->QueryInterface(
                           IID_IRTCContactList,
                           (void **)&pContactList
                          );

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CreateWAB - "
                            "QI failed 0x%lx", hr));
    
        delete pCWAB;

        return hr;
    } 

    *ppContactList = pContactList;

    LOG((RTC_TRACE, "CreateWAB - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\webctl.h ===
// webctl.h : header file for the web control wrapper
//  

#pragma once

#include "stdafx.h"

BOOL AtlAxWebWinInit();

/////////////////////////////////////////////////////////////////////////////
// CAxWebWindow

class CAxWebWindow : 
    public CAxWindow
{
public:
    CAxWebWindow();

    ~CAxWebWindow();

    static LPCTSTR GetWndClassName();

    // Creates the browser
    HRESULT     Create(
        LPCTSTR  pszUrl,
        HWND     hwndParent);


    void    Destroy();

private:

    void   SecondThread(void);

private:

    static DWORD WINAPI SecondThreadEntryProc(
        LPVOID );

private:

    // Handle of the second thread
    HANDLE      m_hSecondThread;
    DWORD       m_dwThreadID;
    
    // Used by both threads
    HANDLE      m_hInitEvent;

    IStream    *m_pMarshaledIntf;
    HRESULT     m_hrInitResult;

    IUnknown   *m_pWebUnknown;
    //

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E456B10E_A36A_42F2_B591_3CCF7BE6868F__INCLUDED_)
#define AFX_STDAFX_H__E456B10E_A36A_42F2_B591_3CCF7BE6868F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED
#include <atlbase.h>

#include <commctrl.h>
#include <exdisp.h>
#include <shellapi.h>       // for ShellAbout
#include <htmlhelp.h>       // for HtmlHelp

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>

#include "rtclog.h"
#include "rtcmem.h"
#include "rtcutils.h"

#include "rtcctl.h"
#include "rtcsip.h"     // needed for ISIP* interfaces
#include "rtcframe.h"
#include "exeres.h"
#include "RTCAddress.h"

#include "statictext.h"
#include "button.h"
#include "ui.h"
#include "rtcdib.h"
#include "rtcenum.h"
#include "rtcutil.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E456B10E_A36A_42F2_B591_3CCF7BE6868F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\webctl.cpp ===
// webctl.cpp : Implementation of the web browser wrapper
//
 
#include "stdafx.h"
#include "webctl.h"
#include "webhost.h"

/////////////////////////////////////////////////////////////////////////////
//
//

ATLINLINE AtlAxWebCreateControlEx(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, 
		IUnknown** ppUnkContainer, IUnknown** ppUnkControl, REFIID iidSink, IUnknown* punkSink)
{
    LOG((RTC_TRACE, "AtlAxWebCreateControlEx - enter"));

	AtlAxWebWinInit();
	HRESULT hr;
	CComPtr<IUnknown> spUnkContainer;
	CComPtr<IUnknown> spUnkControl;

	hr = CAxWebHostWindow::_CreatorClass::CreateInstance(NULL, IID_IUnknown, (void**)&spUnkContainer);
	if (SUCCEEDED(hr))
	{
		CComPtr<IAxWinHostWindow> pAxWindow;
		spUnkContainer->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
		CComBSTR bstrName(lpszName);
		hr = pAxWindow->CreateControlEx(bstrName, hWnd, pStream, &spUnkControl, iidSink, punkSink);
	}
	if (ppUnkContainer != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkContainer = spUnkContainer.p;
			spUnkContainer.p = NULL;
		}
		else
			*ppUnkContainer = NULL;
	}
	if (ppUnkControl != NULL)
	{
		if (SUCCEEDED(hr))
		{
			*ppUnkControl = SUCCEEDED(hr) ? spUnkControl.p : NULL;
			spUnkControl.p = NULL;
		}
		else
			*ppUnkControl = NULL;
	}

    LOG((RTC_TRACE, "AtlAxWebCreateControlEx - exit"));

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

ATLINLINE AtlAxWebCreateControl(LPCOLESTR lpszName, HWND hWnd, IStream* pStream, IUnknown** ppUnkContainer)
{
	return AtlAxWebCreateControlEx(lpszName, hWnd, pStream, ppUnkContainer, NULL, IID_NULL, NULL);
}

/////////////////////////////////////////////////////////////////////////////
//
//

static LRESULT CALLBACK AtlAxWebWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch(uMsg)
	{
	case WM_CREATE:
		{
		// create control from a PROGID in the title
			// This is to make sure drag drop works
			::OleInitialize(NULL);

			CREATESTRUCT* lpCreate = (CREATESTRUCT*)lParam;
			int nLen = ::GetWindowTextLength(hWnd);
			LPTSTR lpstrName = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));
			::GetWindowText(hWnd, lpstrName, nLen + 1);
			::SetWindowText(hWnd, _T(""));
			IAxWinHostWindow* pAxWindow = NULL;
			int nCreateSize = 0;
			if (lpCreate && lpCreate->lpCreateParams)
            {
				nCreateSize = *((WORD*)lpCreate->lpCreateParams);
            }
			
            HGLOBAL h = NULL;

            if(nCreateSize)
            {
                h = GlobalAlloc(GHND, nCreateSize);
            }

			CComPtr<IStream> spStream;
			if (h)
			{
				BYTE* pBytes = (BYTE*) GlobalLock(h);
				BYTE* pSource = ((BYTE*)(lpCreate->lpCreateParams)) + sizeof(WORD); 
				//Align to DWORD
				//pSource += (((~((DWORD)pSource)) + 1) & 3);
				memcpy(pBytes, pSource, nCreateSize);
				GlobalUnlock(h);
				CreateStreamOnHGlobal(h, TRUE, &spStream);
			}
			USES_CONVERSION;
			CComPtr<IUnknown> spUnk;
			HRESULT hRet = AtlAxWebCreateControl(T2COLE(lpstrName), hWnd, spStream, &spUnk);
			if(FAILED(hRet))
				return -1;	// abort window creation
			hRet = spUnk->QueryInterface(IID_IAxWinHostWindow, (void**)&pAxWindow);
			if(FAILED(hRet))
				return -1;	// abort window creation
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM)pAxWindow);
			// check for control parent style if control has a window
			HWND hWndChild = ::GetWindow(hWnd, GW_CHILD);
			if(hWndChild != NULL)
			{
				if(::GetWindowLong(hWndChild, GWL_EXSTYLE) & WS_EX_CONTROLPARENT)
				{
					DWORD dwExStyle = ::GetWindowLong(hWnd, GWL_EXSTYLE);
					dwExStyle |= WS_EX_CONTROLPARENT;
					::SetWindowLong(hWnd, GWL_EXSTYLE, dwExStyle);
				}
			}
		// continue with DefWindowProc
		}
		break;
	case WM_NCDESTROY:
		{
			IAxWinHostWindow* pAxWindow = (IAxWinHostWindow*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if(pAxWindow != NULL)
				pAxWindow->Release();
			OleUninitialize();
		}
		break;
	default:
		break;
	}

	return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////
//
//

//This either registers a global class (if AtlAxWinInit is in ATL.DLL)
// or it registers a local class
BOOL AtlAxWebWinInit()
{
    LOG((RTC_TRACE, "AtlAxWebWinInit - enter"));

	EnterCriticalSection(&_Module.m_csWindowCreate);
	WM_ATLGETHOST = RegisterWindowMessage(_T("WM_ATLGETHOST"));
	WM_ATLGETCONTROL = RegisterWindowMessage(_T("WM_ATLGETCONTROL"));
	WNDCLASSEX wc;
// first check if the class is already registered
	wc.cbSize = sizeof(WNDCLASSEX);
	BOOL bRet = ::GetClassInfoEx(_Module.GetModuleInstance(), CAxWebWindow::GetWndClassName(), &wc);

// register class if not

	if(!bRet)
	{
		wc.cbSize = sizeof(WNDCLASSEX);
#ifdef _ATL_DLL_IMPL
		wc.style = CS_GLOBALCLASS;
#else
		wc.style = 0;
#endif
		wc.lpfnWndProc = AtlAxWebWindowProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = 0;
		wc.hInstance = _Module.GetModuleInstance();
		wc.hIcon = NULL;
		wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
		wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = CAxWebWindow::GetWndClassName();
		wc.hIconSm = NULL;

		bRet = (BOOL)::RegisterClassEx(&wc);
	}
	LeaveCriticalSection(&_Module.m_csWindowCreate);

    LOG((RTC_TRACE, "AtlAxWebWinInit - exit"));

	return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// CAxWebWindow

/////////////////////////////////////////////////////////////////////////////
//
//

CAxWebWindow::CAxWebWindow()
{
    LOG((RTC_TRACE, "CAxWebWindow::CAxWebWindow"));

    m_hInitEvent = NULL;

    m_hSecondThread = NULL;
    m_dwThreadID = 0;

    m_pMarshaledIntf = NULL;
    m_hrInitResult = E_UNEXPECTED;

}

/////////////////////////////////////////////////////////////////////////////
//
//

CAxWebWindow::~CAxWebWindow()
{
    LOG((RTC_TRACE, "CAxWebWindow::~CAxWebWindow"));

    ATLASSERT(!m_hInitEvent);
    ATLASSERT(!m_hSecondThread);
    ATLASSERT(!m_pMarshaledIntf);

}

/////////////////////////////////////////////////////////////////////////////
//
//
LPCTSTR 
CAxWebWindow::GetWndClassName()
{
    LOG((RTC_TRACE, "CAxWebWindow::GetWndClassName"));

	return _T("AtlAxWebWin");
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CAxWebWindow::Create
    (LPCTSTR pszUrl,
     HWND    hwndParent)
{
    HRESULT     hr;
    
    
    LOG((RTC_TRACE, "CAxWebWindow::Create - enter"));
    
    //
    // Create event for synchronization
    //
    m_hInitEvent = CreateEvent(
        NULL,
        TRUE,   // manual reset
        FALSE,  // non signaled
        NULL);

    if(m_hInitEvent == NULL)
    {
        DWORD   dwStatus = GetLastError();

        LOG((RTC_ERROR, "CAxWebWindow::Create - CreateEvent failed"
            " with error (%x), exit", dwStatus));

        return HRESULT_FROM_WIN32(dwStatus);
    }

    // 
    // Create a hosting window, no control in it
    //

    RECT    rectDummy;

    rectDummy.bottom = 0;
    rectDummy.left = 0;
    rectDummy.right = 0;
    rectDummy.top = 0;
    
    HWND    hWndTmp;

    hWndTmp = CWindow::Create(
        GetWndClassName(),
        hwndParent,
        &rectDummy,
        NULL, 
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
        0);

    if(hWndTmp == NULL)
    {
        LOG((RTC_ERROR, "CAxWebWindow::Create - cannot Create hosting window, exit"));

        return E_FAIL;
    }

    //
    //  Create the second thread
    //
    LOG((RTC_TRACE, "CAxWebWindow::Create - creating the second thread"));

    m_hSecondThread = CreateThread(
        NULL,
        0,
        SecondThreadEntryProc,
        this,
        0,
        &m_dwThreadID);
    
    if(m_hSecondThread == NULL)
    {
        DWORD   dwStatus = GetLastError();

        LOG((RTC_ERROR, "CAxWebWindow::Create - CreateThread failed"
            " with error (%x), exit", dwStatus));

        return HRESULT_FROM_WIN32(dwStatus);
    }
    
    LOG((RTC_TRACE, "CAxWebWindow::Create - second thread created, wait for init"));

    //
    // The second thread is running (or it will be)
    //  Wait now until the thread CoCreates the web browser and passes 
    // us a marshaled interface
    //  This is a blocking call, but the direct call of CoCreateInstance 
    // would be blocking anyway
    //
    //  We don't try to solve the blocking nature of CoCreateInstance here...
    //

    DWORD   dwErr;

    dwErr = WaitForSingleObject(m_hInitEvent, INFINITE);

    ATLASSERT(dwErr = WAIT_OBJECT_0);

    //
    //  Check the outcome of the initialization of the second thread
    //

    if(FAILED(m_hrInitResult))
    {
        LOG((RTC_ERROR, "CAxWebWindow::Create - second thread failed to initialize, wait and exit"));

        //
        //  Wait for the second thread to terminate

        WaitForSingleObject(m_hSecondThread, INFINITE);
        
        CloseHandle(m_hSecondThread);
        m_hSecondThread = NULL;

        return m_hrInitResult;
    }

    //
    // Lower the priority of the second thread
    //

    SetThreadPriority( m_hSecondThread, THREAD_PRIORITY_LOWEST );

    LOG((RTC_TRACE, "CAxWebWindow::Create - second thread has initialized the control"));

    //
    //  Attach the control to the hosting window
    //  Unfortunately, calling CAxWindow::AttachControl would cause a leak
    //  of a CAxHostWindow object (see "ATL Internals")
    //  So we have to use the real thing - an interface to the existing 
    //  hosting window
    //

    CComPtr<IAxWinHostWindow> pHostWindow;

    hr = QueryHost(&pHostWindow);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CAxWebWindow::Create - QueryHost returned error (%x), exit", hr));

        return hr;
    }

    //
    //  Attach the control
    //

    ATLASSERT(pHostWindow.p);

    hr = pHostWindow->AttachControl(
        m_pWebUnknown,
        m_hWnd);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CAxWebWindow::Create - AttachControl returned error (%x), exit", hr));

        return hr;
    }

    //
    // Navigate the control to the destination
    //
    CComPtr<IWebBrowser2> pBrowser;

    m_pWebUnknown->QueryInterface(&pBrowser);

    // don't need the interface any more
    m_pWebUnknown -> Release();
    m_pWebUnknown = NULL;

    if(pBrowser)
    {
        CComVariant vurl(pszUrl);
        CComVariant ve;

        pBrowser->put_Visible(VARIANT_TRUE);
        pBrowser->Navigate2(&vurl,&ve, &ve, &ve, &ve);

    }

    LOG((RTC_TRACE, "CAxWebWindow::Create - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CAxWebWindow::Destroy(void)
{
    LOG((RTC_TRACE, "CAxWebWindow::Destroy - enter"));

    // Destroy the window (if any)

    if(m_hWnd)
    {
        DestroyWindow();
    }


    // Wait for the thread to stop
    if(m_hSecondThread)
    {
        //
        // Post a WM_QUIT to that thread
        //
        PostThreadMessage(
            m_dwThreadID,
            WM_QUIT,
            0,
            0);
        LOG((RTC_TRACE, "CAxWebWindow::Destroy - wait for the second thread to stop"));

        WaitForSingleObject(m_hSecondThread, INFINITE);

        CloseHandle(m_hSecondThread);
        m_hSecondThread = NULL;
    }

    if(m_hInitEvent)
    {
        CloseHandle(m_hInitEvent);
        m_hInitEvent = NULL;
    }

    LOG((RTC_TRACE, "CAxWebWindow::Destroy - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//


DWORD WINAPI CAxWebWindow::SecondThreadEntryProc(LPVOID Param)
{
    CAxWebWindow *This = (CAxWebWindow *)Param;

    ATLASSERT(This);

    This->SecondThread();

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//


void CAxWebWindow::SecondThread(void)
{

    HRESULT     hr;
    
    LOG((RTC_TRACE, "CAxWebWindow::SecondThread - enter"));

    //
    // Initialize COM
    //
    hr = CoInitialize(NULL);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CAxWebWindow::SecondThread - CoInitialize returned"
            " error (%x), exit", hr));

        m_hrInitResult = hr;

        SetEvent(m_hInitEvent);

        return;
    }

    //
    //  Create a WEB browser control
    //

    hr = CoCreateInstance(
        CLSID_WebBrowser, 
        NULL,
        CLSCTX_SERVER, 
        IID_IUnknown, 
        (void **)&m_pWebUnknown
        );
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CAxWebWindow::SecondThread - cannot Create WebBrowser control"
            " error (%x), exit", hr));

        m_hrInitResult = hr;

        SetEvent(m_hInitEvent);

        return;
    }
    
    //
    //  Initialize the control
    //  Not much to do here, just call InitNew on the IPersistStreamInit interface
    //  exposed by the control

    IPersistStreamInit   *pPersistStreamInit;

    m_pWebUnknown->QueryInterface(IID_IPersistStreamInit, (void **)&pPersistStreamInit);

    if(pPersistStreamInit!=NULL)
    {
        pPersistStreamInit->InitNew();

        pPersistStreamInit->Release();

        pPersistStreamInit = NULL;
    }

    //
    // Signals the main thread 
    //
    
    LOG((RTC_TRACE, "CAxWebWindow::SecondThread - init complete"));

    m_hrInitResult = S_OK;
    SetEvent(m_hInitEvent);

    //
    // Entering message loop
    //
    
    LOG((RTC_TRACE, "CAxWebWindow::SecondThread - entering message loop"));

    MSG msg;
    while ( 0 < GetMessage( &msg, 0, 0, 0 ) )
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    LOG((RTC_TRACE, "CAxWebWindow::SecondThread - Message loop exited"));

    CoUninitialize();

    LOG((RTC_TRACE, "CAxWebWindow::SecondThread - exit"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\urlreg.cpp ===
#include "stdafx.h"
#include "urlreg.h"
#include "exereshm.h"


enum    URLREG_TYPE
{
    URLREG_TYPE_SELF,
    URLREG_TYPE_NONE,
    URLREG_TYPE_OTHER,
    URLREG_TYPE_ERROR
};

#define PATH_WITH_PARAM_FORMAT      L"%s %%1"

//////////////////////////////////////////////////////////////////////////////
//
// Help array
//
static DWORD   g_dwHelpArray[] =
{
    IDC_CHECK_DONT_ASK_ME,  IDH_DIALOG_URL_REGISTER_DONTASK,
    0, 0
};

/////////////////////////////////////////////////////////////////////////////
//
//

URLREG_TYPE IsRegistered(LPCWSTR szProtocol, LPCWSTR pszPath)
{
    LOG((RTC_TRACE, "IsRegistered - enter"));

    //
    // Open the key
    //

    HKEY  hKey;
    LONG lResult;

    lResult = RegOpenKeyExW(
                    HKEY_CLASSES_ROOT,
                    szProtocol,
                    0,
                    KEY_READ,                         
                    &hKey
                   );

    if ( lResult != ERROR_SUCCESS )
    {
        if(lResult == ERROR_FILE_NOT_FOUND)
        {
            LOG((RTC_TRACE, "IsRegistered - "
                "RegOpenKeyExW(%ws) found no key", szProtocol));
        
            return URLREG_TYPE_NONE;
        }
        
        LOG((RTC_TRACE, "IsRegistered - "
            "RegOpenKeyExW(%ws) failed %d", szProtocol, lResult));
    
        return URLREG_TYPE_ERROR;
    }

    //
    // Open the command key
    //

    HKEY  hKeyCommand;

    lResult = RegOpenKeyExW(
                    hKey,
                    L"shell\\open\\command",
                    0,
                    KEY_READ,                         
                    &hKeyCommand
                   );

    RegCloseKey( hKey );

    if ( lResult != ERROR_SUCCESS )
    {
        if(lResult == ERROR_FILE_NOT_FOUND)
        {
            LOG((RTC_TRACE, "IsRegistered - "
                "RegOpenKeyExW(shell\\open\\command) found no key", szProtocol));
        
            return URLREG_TYPE_NONE;
        }

        LOG((RTC_ERROR, "IsRegistered - "
            "RegOpenKeyExW(shell\\open\\command) failed %d", lResult));
    
        return URLREG_TYPE_ERROR;
    }

    //
    // Load the command string
    //

    PWSTR szRegisteredPath;

    szRegisteredPath = RtcRegQueryString( hKeyCommand, NULL );

    RegCloseKey( hKeyCommand );

    if ( szRegisteredPath == NULL )
    {
        LOG((RTC_ERROR, "IsRegistered - "
            "RtcRegQueryString failed"));
    
        return URLREG_TYPE_NONE;
    }

    LOG((RTC_INFO, "IsRegistered - "
            "HKCR\\%ws\\shell\\open\\command = [%ws]",
            szProtocol, szRegisteredPath));

    //
    // Compare the command string to our path
    //
    
    WCHAR szPath[MAX_PATH+10];

    ZeroMemory(szPath, sizeof(szPath));

    _snwprintf(szPath, MAX_PATH+9, PATH_WITH_PARAM_FORMAT, pszPath);

    URLREG_TYPE      nType = URLREG_TYPE_OTHER;

    if ( _wcsicmp( szPath, szRegisteredPath ) == 0 )
    {
        nType = URLREG_TYPE_SELF;
    }

    RtcFree( szRegisteredPath );

    LOG((RTC_TRACE, "IsRegistered - "
        "exit [%s]", nType == URLREG_TYPE_OTHER ? "Other" : "Self"));

    return nType;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT DoRegister(LPCWSTR szProtocol, UINT nNameId, LPCWSTR pszPath)
{
    WCHAR szPathWithParam[MAX_PATH+10];


    LOG((RTC_TRACE, "DoRegister - enter"));

    //
    // Create the key
    //

    HKEY  hKey;
    LONG lResult;

    lResult = RegCreateKeyExW(
                    HKEY_CLASSES_ROOT,
                    szProtocol,
                    0,
                    NULL,
                    0,
                    KEY_WRITE,  
                    NULL,
                    &hKey,
                    NULL
                   );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegCreateKeyExW(%ws) failed %d", szProtocol, lResult));
    
        return FALSE;
    }

    //
    // Set EditFlags value
    //

    DWORD dwEditFlags = 0x00000002;

    lResult = RegSetValueExW(
                             hKey,
                             L"EditFlags",
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwEditFlags,
                             sizeof(DWORD)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegSetValueEx(EditFlags) failed %d", lResult));
        
        RegCloseKey( hKey );

        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Set default value
    //
    WCHAR   szName[0x40];

    szName[0] = L'\0';
    
    LoadString(
        _Module.GetResourceInstance(),
        nNameId,
        szName,
        sizeof(szName)/sizeof(szName[0]));

    lResult = RegSetValueExW(
                             hKey,
                             NULL,
                             0,
                             REG_SZ,
                             (LPBYTE)szName,
                             sizeof(WCHAR) * (lstrlenW(szName) + 1)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegSetValueEx(Default) failed %d", lResult));
        
        RegCloseKey( hKey );

        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Set URL Protocol value
    //

    static WCHAR * szEmptyString = L"";

    lResult = RegSetValueExW(
                             hKey,
                             L"URL Protocol",
                             0,
                             REG_SZ,
                             (LPBYTE)szEmptyString,
                             sizeof(WCHAR) * (lstrlenW(szEmptyString) + 1)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegSetValueEx(URL Protocol) failed %d", lResult));
        
        RegCloseKey( hKey );

        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Open the DefaultIcon key
    //

    HKEY  hKeyIcon;

    lResult = RegCreateKeyExW(
                    hKey,
                    L"DefaultIcon",
                    0,
                    NULL,
                    0,
                    KEY_WRITE,  
                    NULL,
                    &hKeyIcon,
                    NULL
                   );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegCreateKeyExW(DefaultIcon) failed %d", lResult));

        RegCloseKey( hKey );

        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Set default value
    //
    
    ZeroMemory(szPathWithParam, sizeof(szPathWithParam));
    _snwprintf(szPathWithParam, MAX_PATH+9, L"%s,0", pszPath);

    lResult = RegSetValueExW(
                             hKeyIcon,
                             NULL,
                             0,
                             REG_SZ,
                             (LPBYTE)szPathWithParam,
                             sizeof(WCHAR) * (lstrlenW(szPathWithParam) + 1)
                            );

    RegCloseKey( hKeyIcon );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegSetValueEx(Default) failed %d", lResult));
        RegCloseKey( hKey );

        return HRESULT_FROM_WIN32(lResult);
    }


    //
    // Open the command key
    //

    HKEY  hKeyCommand;

    lResult = RegCreateKeyExW(
                    hKey,
                    L"shell\\open\\command",
                    0,
                    NULL,
                    0,
                    KEY_WRITE,  
                    NULL,
                    &hKeyCommand,
                    NULL
                   );

    RegCloseKey( hKey );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegCreateKeyExW(shell\\open\\command) failed %d", lResult));
    
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Set default value
    //
   
    ZeroMemory(szPathWithParam, sizeof(szPathWithParam));
    _snwprintf(szPathWithParam, MAX_PATH+9, PATH_WITH_PARAM_FORMAT, pszPath);

    lResult = RegSetValueExW(
                             hKeyCommand,
                             NULL,
                             0,
                             REG_SZ,
                             (LPBYTE)szPathWithParam,
                             sizeof(WCHAR) * (lstrlenW(szPathWithParam) + 1)
                            );

    RegCloseKey( hKeyCommand );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegSetValueEx(Default) failed %d", lResult));

        return HRESULT_FROM_WIN32(lResult);
    }

    LOG((RTC_TRACE, "DoRegister - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// Deletes the "open" verb for the protcol specified as a parameter.
// Doesn't delete the protocol entry completely


HRESULT DoUnregister(LPCWSTR szProtocol)
{
    LOG((RTC_TRACE, "DoUnregister - enter"));

    //
    // Open the key
    //

    HKEY  hKey;
    LONG lResult;

    lResult = RegOpenKeyExW(
                    HKEY_CLASSES_ROOT,
                    szProtocol,
                    0,
                    KEY_WRITE | KEY_READ,  
                    &hKey
                    );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoUnregister - "
            "RegOpenKeyEx(%ws) failed %d", szProtocol, lResult));
    
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Delete the "open\command" key
    //

    lResult = RegDeleteKeyW(
                    hKey,
                    L"shell\\open\\command"
                   );


    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoUnregister - "
            "RegDeleteKeyW(shell\\open\\command) failed %d", lResult));
        
        RegCloseKey( hKey );
    
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Delete the "open" key
    //

    lResult = RegDeleteKeyW(
                    hKey,
                    L"shell\\open"
                   );


    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoUnregister - "
            "RegDeleteKeyW(shell\\open) failed %d", lResult));
        
        RegCloseKey( hKey );
    
        return HRESULT_FROM_WIN32(lResult);
    }
    
    //
    // Delete the "DefaultIcon" key
    //

    lResult = RegDeleteKeyW(
                    hKey,
                    L"DefaultIcon"
                   );


    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "DoUnregister - "
            "RegDeleteKeyW(DefaultIcon) failed %d", lResult));

        RegCloseKey( hKey );
    
        return HRESULT_FROM_WIN32(lResult);
    }


    RegCloseKey( hKey );


    LOG((RTC_TRACE, "DoUnregister - exit S_OK"));

    return S_OK;
}





/////////////////////////////////////////////////////////////////////////////
//
//

INT_PTR CALLBACK URLRegDialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
{
    switch ( uMsg )
    {
        case WM_ACTIVATE:
            if ( wParam != WA_INACTIVE )
            {
                ::SetFocus( hwndDlg );
            }
            break;

        case WM_COMMAND:

            switch ( LOWORD( wParam ) )
            {
                case ID_YES:
                {
                    if ( IsDlgButtonChecked( hwndDlg, IDC_CHECK_DONT_ASK_ME ) )
                    {
                        EndDialog( hwndDlg, ID_YES_DONT_ASK_ME );
                    }
                    else
                    {
                        EndDialog( hwndDlg, ID_YES );
                    }
                    return TRUE;
                }
                
                case ID_NO:
                {
                    if ( IsDlgButtonChecked( hwndDlg, IDC_CHECK_DONT_ASK_ME ) )
                    {
                        EndDialog( hwndDlg, ID_NO_DONT_ASK_ME );
                    }
                    else
                    {
                        EndDialog( hwndDlg, ID_NO );
                    }

                    return TRUE;
                }

                case IDCANCEL:
                {
                    EndDialog( hwndDlg, ID_NO );

                    return TRUE;
                }

                default:
                    break;
            }
            
        case WM_CONTEXTMENU:

            ::WinHelp(
                (HWND)wParam,
                g_szExeContextHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)g_dwHelpArray);

            return TRUE;

            break;

        case WM_HELP:


            ::WinHelp(
                (HWND)(((HELPINFO *)lParam)->hItemHandle),
                g_szExeContextHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)g_dwHelpArray);

            return TRUE;

            break;

        default:
            break;
    }    

    //
    // We fell through, so this procedure did not handle the message.
    //

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// This is called during setup
//

void InstallUrlMonitors(BOOL  bInstall)
{
    LOG((RTC_TRACE, "InstallUrlMonitors - enter"));

    URLREG_TYPE     regTypeTel;
    URLREG_TYPE     regTypeSip;

    HRESULT         hr;
    
    //
    // Get the full path of our executable
    //

    WCHAR szPath[MAX_PATH+1];

    ZeroMemory(szPath, sizeof(szPath));

    if (GetShortModuleFileNameW(_Module.GetModuleInstance(), szPath, MAX_PATH) == 0)
    {
        LOG((RTC_ERROR, "InstallUrlMonitors - "
            "GetModuleFileName failed %d", GetLastError()));

        return;
    }

    LOG((RTC_INFO, "InstallUrlMonitors - "
            "GetModuleFileName [%ws]", szPath));

    // Check the current URL registration

    regTypeTel = IsRegistered(L"tel", szPath);
    regTypeSip = IsRegistered(L"sip", szPath);
    
    if(bInstall)
    {
        // during install, register with the namespaces if they
        // are not already taken by other app
        
        if(regTypeTel == URLREG_TYPE_NONE)
        {
            hr = DoRegister( L"tel", IDS_URL_TEL, szPath );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "InstallUrlMonitors - "
                    "DoRegister(tel) failed 0x%lx", hr));
            }
        }
        
        if(regTypeSip == URLREG_TYPE_NONE)
        {
            hr = DoRegister( L"sip", IDS_URL_SIP, szPath );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "InstallUrlMonitors - "
                    "DoRegister(sip) failed 0x%lx", hr));
            }
        }
    }
    else
    {
        // during uninstall, unregister 
        if(regTypeTel == URLREG_TYPE_SELF)
        {
            hr = DoUnregister( L"tel");

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "InstallUrlMonitors - "
                    "DoUnregister(tel) failed 0x%lx", hr));
            }
        }
        
        if(regTypeSip == URLREG_TYPE_SELF)
        {
            hr = DoUnregister( L"sip");

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "InstallUrlMonitors - "
                    "DoUnregister(sip) failed 0x%lx", hr));
            }
        }
    }

    LOG((RTC_TRACE, "InstallUrlMonitors - exit"));  
}


/////////////////////////////////////////////////////////////////////////////
// This is called during startup
//

void CheckURLRegistration(HWND hParent)
{
    LOG((RTC_TRACE, "CheckURLRegistration - enter"));  

    //
    // Check registry to see if the user
    // has told us not to ask any more
    //

    DWORD dwDontAskMe;
    HRESULT hr;

    hr = get_SettingsDword( SD_URL_REG_DONT_ASK_ME, &dwDontAskMe );

    if ( SUCCEEDED(hr) && (dwDontAskMe == 1) )
    {
        LOG((RTC_INFO, "CheckURLRegistration - "
            "don't ask me is set"));

        return;
    }
    
    //
    // Get the full path of our executable
    //

    WCHAR szPath[MAX_PATH+1];
    ZeroMemory(szPath, sizeof(szPath));

    if (GetShortModuleFileNameW(_Module.GetModuleInstance(), szPath, MAX_PATH) == 0)
    {
        LOG((RTC_ERROR, "CheckURLRegistration - "
            "GetModuleFileName failed %d", GetLastError()));

        return;
    }

    LOG((RTC_INFO, "CheckURLRegistration - "
            "GetModuleFileName [%ws]", szPath));

    BOOL fRegistered = TRUE;

    //
    // Check if TEL is registered with our app
    //
    
    if ( IsRegistered( L"tel", szPath ) != URLREG_TYPE_SELF )
    {
        fRegistered = FALSE;
    }

    //
    // Check if SIP is registered
    //
    
    if ( IsRegistered( L"sip", szPath ) != URLREG_TYPE_SELF )
    {
        fRegistered = FALSE;
    }

    // At least one namespace is not registered with Phoenix
    //

    if ( fRegistered == FALSE )
    {    
        //
        // Prompt to see if we should register
        //

        int n;

        n = (int)DialogBox( _Module.GetResourceInstance(),
                   MAKEINTRESOURCE(IDD_DIALOG_URL_REGISTER),
                   hParent,
                   URLRegDialogProc
                 );

        if ( n == ID_YES || n == ID_YES_DONT_ASK_ME )
        {
            LOG((RTC_INFO, "CheckURLRegistration - "
                "YES"));

            //
            // Do the registration for both namespaces
            //

            hr = DoRegister( L"tel", IDS_URL_TEL, szPath );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CheckURLRegistration - "
                    "DoRegister(tel) failed 0x%lx", hr));
            }

            hr = DoRegister( L"sip", IDS_URL_SIP, szPath );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CheckURLRegistration - "
                    "DoRegister(sip) failed 0x%lx", hr));
            }
        }

        if ( n == ID_NO_DONT_ASK_ME || n == ID_YES_DONT_ASK_ME )
        {
            LOG((RTC_INFO, "CheckURLRegistration - "
                "DONT_ASK_ME"));

            //
            // Store flag in registry, so we don't ask again
            //

            hr = put_SettingsDword( SD_URL_REG_DONT_ASK_ME, 1 );

            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CheckURLRegistration - "
                    "put_SettingsDword failed 0x%lx", hr));
            }
        }
    }

    LOG((RTC_TRACE, "CheckURLRegistration - exit"));
}


/////////////////////////////////////////////////////////////////////////////
// Helper function to combine GetModuleFileNameW and GetShortPathNameW
//

DWORD GetShortModuleFileNameW(
  HMODULE hModule,    // handle to module
  LPTSTR szPath,  // file name of module
  DWORD nSize         // size of buffer
)
{
	ATLASSERT(nSize>=MAX_PATH);//so we can be sure that buffer is large enough

    if (GetModuleFileNameW(hModule, szPath, nSize) == 0)
    {
        LOG((RTC_ERROR, "GetModuleFileNameW failed %d", GetLastError()));
        return 0;
    }

	return GetShortPathNameW(szPath, szPath, nSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\webhost.cpp ===
// webhost.cpp : Implementation of the web host wrapper
//
 
#include "stdafx.h"
#include "webhost.h"

/////////////////////////////////////////////////////////////////////////////
// CAxWebHostWindow

/////////////////////////////////////////////////////////////////////////////
//
//

CAxWebHostWindow::CAxWebHostWindow() : CAxHostWindow()
{
    LOG((RTC_TRACE, "CAxWebHostWindow::CAxWebHostWindow"));

    m_pFTM = NULL;
    m_dwDocHostFlags = DOCHOSTUIFLAG_NO3DBORDER |
                       DOCHOSTUIFLAG_SCROLL_NO |
                       DOCHOSTUIFLAG_OPENNEWWIN;
}

/////////////////////////////////////////////////////////////////////////////
//
//

CAxWebHostWindow::~CAxWebHostWindow()
{
    LOG((RTC_TRACE, "CAxWebHostWindow::~CAxWebHostWindow"));

    //
    // release the free threaded marshaller
    //
    if ( NULL != m_pFTM )
    {
        m_pFTM->Release();
        m_pFTM = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT WINAPI 
CAxWebHostWindow::IMarshalQI( void * pv, REFIID riid, LPVOID * ppv, DWORD_PTR dw )
{
    HRESULT                   hr;
    IUnknown                * pUnk;

    LOG((RTC_TRACE, "CAxWebHostWindow::IMarshalQI"));

    CAxWebHostWindow * pObject = (CAxWebHostWindow *)pv;

    *ppv = NULL;

    pObject->Lock();

    if ( NULL == pObject->m_pFTM )
    {
        pObject->QueryInterface(IID_IUnknown, (void **)&pUnk);

        hr = CoCreateFreeThreadedMarshaler(
                                           pUnk,
                                           &(pObject->m_pFTM)
                                          );

        pUnk->Release();

        if ( !SUCCEEDED(hr) )
        {
            pObject->Unlock();

            return E_NOINTERFACE;
        }
    }

    pObject->Unlock();

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\button.h ===
// button.h : Declaration of the CButton

#ifndef __BUTTON_H_
#define __BUTTON_H_

/////////////////////////////////////////////////////////////////////////////
// CButton
class CButton : public CWindowImpl<CButton>
{
public:

    CButton();
    ~CButton();
    
    HWND Create(
        HWND hWndParent,
        RECT &rc,  
        LPCTSTR szText,
        DWORD dwStyle,
        LPCTSTR szNormalBitmap,
        LPCTSTR szPressedBitmap,
        LPCTSTR szDisabledBitmap,
        LPCTSTR szHotBitmap,
        LPCTSTR szMaskBitmap,
        UINT nID
        );

    HWND Create(
        HWND hWndParent,
        RECT &rc,  
        LPCTSTR szText,
        DWORD dwStyle,
        LPCTSTR szNormalBitmap,
        LPCTSTR szPressedBitmap,
        LPCTSTR szDisabledBitmap,
        LPCTSTR szHotBitmap,
        LPCTSTR szActiveNormalBitmap,
        LPCTSTR szActivePressedBitmap,
        LPCTSTR szActiveDisabledBitmap,
        LPCTSTR szActiveHotBitmap,
        LPCTSTR szMaskBitmap,
        UINT nID
        );

BEGIN_MSG_MAP(CButton)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
    MESSAGE_HANDLER(BM_GETCHECK, OnGetCheck)
    MESSAGE_HANDLER(BM_SETCHECK, OnSetCheck)
END_MSG_MAP()

    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnGetCheck(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCheck(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    static void OnDrawItem(
        LPDRAWITEMSTRUCT lpDIS,
        HPALETTE hPalette,
        BOOL bBackgroundPalette
        );

private:

    static void BMaskBlt(HDC hdcDest, int x, int y, int width, int height, 
                        HDC hdcSource, int xs, int ys, 
                        HBITMAP hMask, int xm, int ym);

    HANDLE  m_hNormalBitmap;
    HANDLE  m_hPressedBitmap;
    HANDLE  m_hDisabledBitmap;
    HANDLE  m_hHotBitmap;
    HANDLE  m_hActiveNormalBitmap;
    HANDLE  m_hActivePressedBitmap;
    HANDLE  m_hActiveDisabledBitmap;
    HANDLE  m_hActiveHotBitmap;
    HBITMAP m_hMaskBitmap;

    BOOL    m_bMouseInButton;
    BOOL    m_bIsCheckbox;
    BOOL    m_bChecked;

    UINT    m_nID;

private:

    static  CButton *s_pButtonFocus;
    static  CButton *s_pButtonMouse;
    static  BOOL    s_bAllowFocus;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\dllres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by RTCDLL.RC
//
#define IDB_WIZBMP                      100
#define IDR_RTCClient                   101
#define IDR_DLLOLDSTUFF                 102
#define IDR_WAV_TONE                    616
#define IDR_WAV_RINGIN                  617
#define IDR_WAV_MESSAGE                 618
#define IDR_WAV_RINGBACK                619
#define IDS_AUDIO_WARNING               1300
#define IDS_WAVEIN_MUTED                1301
#define IDS_MICROPHONE_MUTED            1302
#define IDS_MICROPHONE_NOT_SELECTED     1303
#define IDC_ATW_SLIDER1                 9000
#define IDC_BUTTON_ATW_TEST             9001
#define IDC_ATW_SLIDER2                 9002
#define IDC_VUMETER                     9003
#define IDC_WIZBMP                      9004
#define IDC_WAVEIN                      9005
#define IDC_AUDIOCHECKREASON            9006
#define IDC_ERRTITLE                    9007
#define IDC_ERRTEXT                     9008
#define IDC_ERRWIZICON                  9009
#define IDC_WAVEOUT                     9010
#define IDC_VWCOMBO                     9011
#define IDC_GROUP_VOLUME                9012
#define IDC_AEC                         9013
#define IDC_VIDEOTUNE                   9014
#define IDC_AEC_TEXT                    9015
#define IDS_AEC_DETECT                  9016
#define IDS_AEC_NOT_DETECT              9017
#define IDS_NMAS_TITLE                  9500
#define IDS_NMAS_NOTHING                9501
#define IDS_NMAS_PROGRAMS               9502
#define IDS_NMAS_DESKTOP                9503
#define IDS_NMAS_UNSHAREALL             9504
#define IDS_STOPBUTTON_TEXT             17000
#define IDS_TESTBUTTON_TEXT             17001
#define IDS_NONE                        17002
#define IDS_ERROR_WIZ_AUDIO_RENDERTUNE  17003
#define IDS_ERROR_WIZ_AUDIO_CAPTURETUNE 17004
#define IDS_ERROR_WIZ_AUDIO_CAPTURENOSOUND 17005
#define IDS_ERROR_WIZ_AUDIO_AEC         17006
#define IDS_ERROR_WIZ_VIDEO_CAPTURETUNE 17007
#define IDS_ERROR_WIZ_GENERIC           17008
#define IDS_ERROR_WIZ_INITERROR         17009
#define IDS_ERROR_WIZ_TITLE_AUDIO_RENDERTUNE 17010
#define IDS_ERROR_WIZ_TITLE_AUDIO_CAPTURETUNE 17011
#define IDS_ERROR_WIZ_TITLE_AUDIO_CAPTURENOSOUND 17012
#define IDS_ERROR_WIZ_TITLE_AUDIO_AEC   17013
#define IDS_ERROR_WIZ_TITLE_VIDEO_CAPTURETUNE 17014
#define IDS_ERROR_WIZ_TITLE_GENERIC     17015
#define IDS_ERROR_WIZ_TITLE_INITERROR   17016
#define IDD_AUDIOCALIBWIZ0              20110
#define IDD_AUDIOCALIBWIZ1              20111
#define IDD_AUDIOCALIBWIZ2              20112
#define IDD_AUDIOCALIBWIZ3              20113
#define IDD_AUDIOCALIBWIZ4              20114
#define IDD_DETSOUNDCARDWIZ             20115
#define IDD_AUDIOCALIBERRWIZ            20117
#define IDD_VIDWIZ0                     20119
#define IDD_VIDWIZ1                     20120
#define IDD_INTROWIZ                    20121

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         200
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\exe\webhost.h ===
// webhost.h : header file for the web host wrapper
//  

#pragma once

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CAxWebHostWindow

class CAxWebHostWindow : 
    public CAxHostWindow
{
public:
    CAxWebHostWindow();

    ~CAxWebHostWindow();

    static HRESULT WINAPI IMarshalQI( void * pv, REFIID riid, LPVOID * ppv, DWORD_PTR dw );

    DECLARE_NO_REGISTRY()
    DECLARE_POLY_AGGREGATABLE(CAxWebHostWindow)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CAxWebHostWindow)
        COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
		COM_INTERFACE_ENTRY2(IDispatch, IAxWinAmbientDispatch)
		COM_INTERFACE_ENTRY(IAxWinHostWindow)
		COM_INTERFACE_ENTRY(IOleClientSite)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteWindowless)
		COM_INTERFACE_ENTRY(IOleInPlaceSiteEx)
		COM_INTERFACE_ENTRY(IOleInPlaceSite)
		COM_INTERFACE_ENTRY(IOleWindow)
		COM_INTERFACE_ENTRY(IOleControlSite)
		COM_INTERFACE_ENTRY(IOleContainer)
		COM_INTERFACE_ENTRY(IObjectWithSite)
		COM_INTERFACE_ENTRY(IServiceProvider)
		COM_INTERFACE_ENTRY(IAxWinAmbientDispatch)
#ifndef _ATL_NO_DOCHOSTUIHANDLER
		COM_INTERFACE_ENTRY(IDocHostUIHandler)
#endif
		COM_INTERFACE_ENTRY(IAdviseSink)
	END_COM_MAP()

private:
    IUnknown                      * m_pFTM;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\msgruaid.h ===
#ifndef __MSGRUAID__H__
#define __MSGRUAID__H__

//
// Dispatch IDs for DMessengerEvents
// 
#define DISPID_MUAE_ONSIGNIN				  0x400
#define DISPID_MUAE_ONSIGNOUT				  0x401
#define DISPID_MUAE_ONLISTADD				  0x402
#define DISPID_MUAE_ONLISTREMOVE			  0x403
#define DISPID_MUAE_ONUSERFRIENDLYNAMECHANGE  0x404
#define DISPID_MUAE_ONMYFRIENDLYNAMECHANGE	  0x405
#define DISPID_MUAE_ONUSERSTATECHANGE		  0x406
#define DISPID_MUAE_ONMYSTATECHANGE 		  0x407
#define DISPID_MUAE_ONAPPSHUTDOWN			  0x408
#define DISPID_MUAE_ONMYPROPERTYCHANGE		  0x409
#define DISPID_MUAE_ONUSERPROPERTYCHANGE	  0x40a
#define DISPID_MUAE_ONUSERBLOCKCHANGE		  0x40b
#define DISPID_MUAE_ONUSERPAGERCHANGE		  0x40c
#define DISPID_MUAE_ONUSERPHONECHANGE		  0x40d
#define DISPID_MUAE_ONMYPHONECHANGE 		  0x40e
#define DISPID_MUAE_ONUNREADEMAILCHANGE 	  0x40f

//
// Dispatch IDs for IMessenger
//
#define DISPID_MUAM_RECEIVEDIR				 0x500
#define DISPID_MUAM_STARTVOICE				 0x501
#define DISPID_MUAM_FRIENDLYNAME			 0x502
#define DISPID_MUAM_WINDOW					 0x503
#define DISPID_MUAM_UNREADEMAILCOUNT		 0x504
#define DISPID_MUAM_VIEWPROFILE 			 0x505
#define DISPID_MUAM_GETCONTACT	 			 0x506
#define DISPID_MUAM_OPTIONUI				 0x507
#define DISPID_MUAM_ADDUI					 0x508
#define DISPID_MUAM_FINDUI					 0x509
#define DISPID_MUAM_INSTANTMESSAGE			 0x50a
#define DISPID_MUAM_SIGNOUT 				 0x50b
#define DISPID_MUAM_SENDFILE				 0x50c
#define DISPID_MUAM_OPENINBOX				 0x50d
#define DISPID_MUAM_MYSERVICENAME			 0x50e
#define DISPID_MUAM_INVITEAPP				 0x50f
#define DISPID_MUAM_MYPHONENUMBER			 0x510
#define DISPID_MUAM_SIGNIN					 0x511
#define DISPID_MUAM_SENDMAIL				 0x512
#define DISPID_MUAM_AUTOSIGNIN				 0x513
#define DISPID_MUAM_PHONEUI 				 0x514
#define DISPID_MUAM_AUDIOUI 				 0x515
#define DISPID_MUAM_PAGERUI 				 0x516
#define DISPID_MUAM_CONTACTS				 0x517
#define DISPID_MUAM_SIGNINNAME				 0x518
#define DISPID_MUAM_STATUS					 0x519
#define DISPID_MUAM_MYPROPERTY				 0x51a
#define DISPID_MUAM_SERVICEID				 0x51b
#define DISPID_MUAM_SERVICES	 			 0x51c


//
// Dispatch IDs for IMessengerContact
//

#define DISPID_MUAC_FRIENDLYNAME			 0x600
#define DISPID_MUAC_STATUS					 0x601
#define DISPID_MUAC_SIGNINNAME				 0x602
#define DISPID_MUAC_SERVICENAME 			 0x603
#define DISPID_MUAC_BLOCK					 0x604
#define DISPID_MUAC_ISSELF					 0x605
#define DISPID_MUAC_PROPERTY				 0x606
#define DISPID_MUAC_CANPAGE 				 0x607
#define DISPID_MUAC_PHONENUMBER 			 0x608
#define DISPID_MUAC_SERVICEID				 0x609


//
// Dispatch IDs for IMessengerContacts
//

#define DISPID_MUAC_COUNT					 0x700
#define DISPID_MUAC_REMOVE					 0x701


//
// Dispatch IDs for IMessengerWindow
//

#define DISPID_MUAW_HWND					0x800
#define DISPID_MUAW_LEFT					0x801
#define DISPID_MUAW_TOP 					0x802
#define DISPID_MUAW_WIDTH					0x803
#define DISPID_MUAW_HEIGHT					0x804
#define DISPID_MUAW_CLOSE					0x805
#define DISPID_MUAW_SHOW					0x806
#define DISPID_MUAW_ISCLOSED				0x807
#define DISPID_MUAW_PROPERTY				0x808

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\mdispid.h ===
#ifndef _MDISPID_H_
#define _MDISPID_H_

//
// Dispatch IDs for DMsgrObjectEvents Dispatch Events.
//
#define DISPID_ONLOGONRESULT				  100
#define DISPID_ONLOGOFF 					  101
#define DISPID_ONLISTADDRESULT				  102
#define DISPID_ONLISTREMOVERESULT			  103
#define DISPID_ONMESSAGEPRIVACYCHANGERESULT   104
#define DISPID_ONPROMPTCHANGERESULT 		  105
#define DISPID_ONUSERFRIENDLYNAMECHANGERESULT 106
#define DISPID_ONUSERSTATECHANGED			  107
#define DISPID_ONTEXTRECEIVED				  108
#define DISPID_ONLOCALFRIENDLYNAMECHANGERESULT 109
#define DISPID_ONLOCALSTATECHANGERESULT 	  110
#define DISPID_ONAPPINVITERECEIVED			  111
#define DISPID_ONAPPINVITEACCEPTED			  112
#define DISPID_ONAPPINVITECANCELLED 		  113
#define DISPID_ONSENDRESULT 				  114
#define DISPID_ONNEWERCLIENTAVAILABLE		  115
#define DISPID_ONFINDRESULT 				  116
#define DISPID_ONINVITEMAILRESULT			  117
#define DISPID_ONREQUESTURLRESULT			  118
#define DISPID_ONSESSIONSTATECHANGE 		  119
#define DISPID_ONUSERJOIN					  120
#define DISPID_ONUSERLEAVE					  121
#define DISPID_ONNEWSESSIONREQUEST			  122
#define DISPID_ONINVITEUSER 				  123
#define DISPID_ONSERVICELOGOFF				  124
#define DISPID_ONPRIMARYSERVICECHANGED		  125
#define DISPID_ONAPPSHUTDOWN				  126
#define DISPID_ONUNREADEMAILCHANGED 		  127
#define DISPID_ONUSERDROPPED				  128
#define DISPID_ONREQUESTURLPOSTRESULT		  129
#define DISPID_ONNEWERSITESAVAILABLE		  130
#define DISPID_ONTRUSTCHANGED				  131
#define DISPID_ONFILETRANSFERINVITERECEIVED   132
#define DISPID_ONFILETRANSFERINVITEACCEPTED   133
#define DISPID_ONFILETRANSFERINVITECANCELLED  134
#define DISPID_ONFILETRANSFERCANCELLED		  135
#define DISPID_ONFILETRANSFERSTATUSCHANGE	  136
#define DISPID_ONSPMESSAGERECEIVED			  137
#define DISPID_ONLOCALPROPERTYCHANGERESULT	  141
#define DISPID_ONBUDDYPROPERTYCHANGERESULT	  142
#define DISPID_ONNOTIFICATIONRECEIVED		  143
#define DISPID_ONPAGERECEIVED				  144
#define DISPID_ONLOCKCHALLENGE			145
#define DISPID_ONLOCKRESULT 			146
#define DISPID_ONLOCKENABLE 			147


//
// Dispatch IDs for DMessengerAppEvents Dispatch Events.
// (don't overlap DMsgrObjectEvents ids)
//
#define DISPID_ONBEFORELAUNCHIMUI			20000
#define DISPID_ONSHOWIMUI					20001
#define DISPID_ONDESTROYIMUI				20002
#define DISPID_ONINDICATEMESSAGERECEIVED	20003
#define DISPID_ONSTATUSTEXT 				20004
#define DISPID_ONTITLEBARTEXT				20005
#define DISPID_ONINFOBARTEXT				20006
#define DISPID_ONSENDENABLED				20007
#define DISPID_ONTRANSLATEACCELERATOR		20008
#define DISPID_ONFILETRANSFER				20009
#define DISPID_ONVOICESESSIONSTATE			20010
#define DISPID_ONVOICEVOLUMECHANGED 		20011
#define DISPID_ONMICROPHONEMUTE 			20012

//
// Dispatch IDs for IMsgrObject.
//
#define DISPID_CREATEUSER					  100
#define DISPID_LOGON						  104
#define DISPID_LOGOFF						  105
#define DISPID_GETLIST						  0x60020003
#define DISPID_LOCALLOGONNAME				  0x60020004
#define DISPID_LOCALFRIENDLYNAME			  0x60020005
#define DISPID_LOCALSTATE					  0x60020006
#define DISPID_MESSAGEPRIVACY				  0x60020008
#define DISPID_PROMPT						  0x6002000a
#define DISPID_SENDAPPINVITE				  108
#define DISPID_SENDAPPINVITEACCEPT			  109
#define DISPID_SENDAPPINVITECANCEL			  110
#define DISPID_LOCALOPTION					  0x6002000f
#define DISPID_FINDUSER 					  111
#define DISPID_SENDINVITEMAIL				  112
#define DISPID_REQUESTURL					  113
#define DISPID_IMSESSIONS					  0x60020014
#define DISPID_CREATEIMSESSIONS 			  114
#define DISPID_SESSIONREQUESTACCEPT 		  115
#define DISPID_SESSIONREQUESTCANCEL 		  116
#define DISPID_SERVICES 					  0x60020018
#define DISPID_UNREADEMAIL					  0x60020019
#define DISPID_SENDFILETRANSFERINVITE		  117
#define DISPID_SENDFILETRANSFERINVITEACCEPT   118
#define DISPID_SENDFILETRANSFERINVITECANCEL   119
#define DISPID_CANCELFILETRANSFER			  120
#define DISPID_FILETRANSFERSTATUS			  121


//
// Dispatch IDs for IMessengerApp.
//
#define DISPID_APPLICATION					  0x60020000
#define DISPID_PARENT						  0x60020001
#define DISPID_QUIT 						  100
#define DISPID_NAME 						  0x60020003
#define DISPID_FULLNAME 					  0x60020004
#define DISPID_PATH 						  0x60020005
#define DISPID_LAUNCHLOGONUI				  200
#define DISPID_LAUNCHOPTIONSUI				  201
#define DISPID_LAUNCHADDCONTACTUI			  202
#define DISPID_LAUNCHFINDCONTACTUI			  203
#define DISPID_LAUNCHIMUI					  210
#define DISPID_IMWINDOWS					  0x6002000b
#define DISPID_TOOLBAR						  0x6002000c
#define DISPID_STATUSBAR					  0x6002000e
#define DISPID_STATUSTEXT					  0x60020010
#define DISPID_GETHWND						  0x60020012
#define DISPID_LEFT 						  0x60020013
#define DISPID_TOP							  0x60020015
#define DISPID_WIDTH						  0x60020017
#define DISPID_HEIGHT						  0x60020019
#define DISPID_MSGS_VISIBLE 				  0x6002001b
#define DISPID_AUTOLOGON					  222
#define DISPID_FIRSTTIMECREDENTIONS 		  0x6002001e
#define DISPID_CACHEDPASSWORD				  0x6002001f
#define DISPID_REQUESTURLPOST				  223
#define DISPID_MSGS_TASKBARICON 			  224

//
// Dispatch IDs for IMessengerApp2.
//
#define DISPID_LAUNCHPHONEUI				  225
#define DISPID_LAUNCHAUDIOWIZARD			  226

//
// Dispatch IDs for IMessengerApp3
//
#define DISPID_LAUNCHPAGERUI				  227


//
// Dispatch IDs for IMsgrUser.
//
#define DISPID_USERFRIENDLYNAME 			  0x60020000
#define DISPID_USEREMAILADDRESS 			  0x60020002
#define DISPID_USERSTATE					  0x60020003
#define DISPID_USERLOGONNAME				  0x60020004
#define DISPID_USERSENDTEXT 				  101
#define DISPID_USERSERVICE					  0x60020006

//
// Dispatch IDs for IMsgrUsers.
//
#define DISPID_USERSCOUNT					  0x60020000
#define DISPID_USERSADD 					  100
#define DISPID_USERSREMOVE					  101

//
// Dispatch IDs for IMsgrService.
//
#define DISPID_SERVICESERVICENAME			  0x60020000
#define DISPID_SERVICELOGONNAME 			  0x60020001
#define DISPID_SERVICEFRIENDLYNAME			  0x60020002
#define DISPID_SERVICECAPABILITIES			  0x60020004
#define DISPID_SERVICESTATUS				  0x60020005
#define DISPID_SERVICELOGOFF				  0x60020006
#define DISPID_SERVICEFINDUSER				  0x60020007
#define DISPID_SERVICESENDINVITEMAIL		  0x60020008
#define DISPID_SERVICEREQUESTURL			  0x60020009
#define DISPID_SERVICEPROFILEFIELD			  0x6002000a

//
// Dispatch IDs for IMsgrServices.
//
#define DISPID_SERVICESPRIMARYSERVICE		  0x60020000
#define DISPID_SERVICESCOUNT				  0x60020002

//
// Dispatch IDs for DMsgrSessionManagerEvents and DMsgrSessionEvents
//
#define DISPID_ONINVITATION 			100
#define DISPID_ONAPPREGISTERED			101
#define DISPID_ONAPPUNREGISTERED		102
#define DISPID_ONSTATECHANGED			103
#define DISPID_ONAPPNOTPRESENT			104
#define DISPID_ONACCEPTED				105
#define DISPID_ONDECLINED				106
#define DISPID_ONCANCELLED				107
#define DISPID_ONTERMINATION			108
#define DISPID_ONREADYTOLAUNCH			109
#define DISPID_ONCONTEXTDATA			110
#define DISPID_ONSENDERROR				111

#endif // ! _MDISPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcaxctl.h ===
// rtcaxctl.h : Declaration of the CRTCCtl

#ifndef __RTCAXCTL_H_
#define __RTCAXCTL_H_

#include "ctlres.h"
#include "ctlreshm.h"
#include "button.h"
#include "statictext.h"
#include <atlctl.h>
#include <rtccore.h>


#define NR_DTMF_BUTTONS     12

class CKnobCtl;

typedef BOOL (WINAPI *WTSREGISTERSESSIONNOTIFICATION)(HWND, DWORD);
typedef BOOL (WINAPI *WTSUNREGISTERSESSIONNOTIFICATION)(HWND);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CParticipantList
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

struct CParticipantEntry;

class CParticipantList  : public CWindow
{
public:
    
    enum { MAX_STRING_LEN = 0x40 };

    enum { ILI_PART_UNUSED = 0,
           ILI_PART_PENDING,
           ILI_PART_INPROGRESS,
           ILI_PART_CONNECTED,
           ILI_PART_DISCONNECTED
    };

    CParticipantList();

    HRESULT  Initialize(void);

    HRESULT  Change(IRTCParticipant *,  RTC_PARTICIPANT_STATE, long);
    void     RemoveAll(void);

    BOOL     CanDeleteSelected();

    HRESULT  Remove(IRTCParticipant **ppParticipant);

private:
    void    GetStatusString(RTC_PARTICIPANT_STATE, long, TCHAR *, int);
    int     GetImage(RTC_PARTICIPANT_STATE);

    CParticipantEntry 
            *GetParticipantEntry(IRTCParticipant *);

private:

    LIST_ENTRY      ListHead;

};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CRTCCtl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// define this, otherwise it cannot compile
typedef CComUnkArray<1> CComUnkOneEntryArray;

struct RTCAX_ERROR_INFO;
class CIMWindowList;

class ATL_NO_VTABLE CRTCCtl: 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IRTCCtl, &IID_IRTCCtl, &LIBID_RTCCtlLib>,
    public CComCompositeControl<CRTCCtl>,
    public IOleControlImpl<CRTCCtl>,
    public IOleObjectImpl<CRTCCtl>,
    public IOleInPlaceActiveObjectImpl<CRTCCtl>,
    public IViewObjectExImpl<CRTCCtl>,
    public IOleInPlaceObjectWindowlessImpl<CRTCCtl>,
    public ISupportErrorInfo,
    public IConnectionPointContainerImpl<CRTCCtl>,
//    public IPersistStorageImpl<CRTCCtl>,
    public IPersistStreamInitImpl<CRTCCtl>,
    public IPersistPropertyBagImpl<CRTCCtl>,
//    public ISpecifyPropertyPagesImpl<CRTCCtl>,
    public IQuickActivateImpl<CRTCCtl>,
//    public IDataObjectImpl<CRTCCtl>,
    public IProvideClassInfo2Impl<&CLSID_RTCCtl, &DIID__IRTCCtlEvents, &LIBID_RTCCtlLib>,
    public IPropertyNotifySinkCP<CRTCCtl>,
    public IConnectionPointImpl<CRTCCtl,&IID_IRTCCtlNotify,CComUnkOneEntryArray>,
    public IRTCEventNotification,
    public IRTCCtlFrameSupport,
    public CComCoClass<CRTCCtl, &CLSID_RTCCtl>
{
public:
    CRTCCtl();
    ~CRTCCtl();

    HRESULT     FinalConstruct(void);
    void        FinalRelease(void);

DECLARE_REGISTRY_RESOURCEID(IDR_RTCCTL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCCtl)
    COM_INTERFACE_ENTRY(IRTCCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY2(IPersist, IPersistPropertyBag)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
//    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
//    COM_INTERFACE_ENTRY(IPersistStorage)
//    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IRTCEventNotification)
    COM_INTERFACE_ENTRY(IRTCCtlFrameSupport)
END_COM_MAP()

BEGIN_PROP_MAP(CRTCCtl)
//    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
//    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("DestinationUrl",  DISPID_RTCCTL_DESTINATIONURL, CLSID_NULL)
    PROP_ENTRY("DestinationName",  DISPID_RTCCTL_DESTINATIONNAME, CLSID_NULL)
    PROP_ENTRY("AutoPlaceCall", DISPID_RTCCTL_AUTOPLACECALL,CLSID_NULL)
    PROP_ENTRY("CallScenario", DISPID_RTCCTL_CALLSCENARIO,CLSID_NULL)
    PROP_ENTRY("ShowDialpad", DISPID_RTCCTL_SHOWDIALPAD,CLSID_NULL)
    PROP_ENTRY("ProvisioningProfile", DISPID_RTCCTL_PROVISIONINGPROFILE, CLSID_NULL)
    PROP_ENTRY("DisableVideoReception", DISPID_RTCCTL_DISABLEVIDEORECEPTION, CLSID_NULL)
    PROP_ENTRY("DisableVideoTransmission", DISPID_RTCCTL_DISABLEVIDEOTRANSMISSION, CLSID_NULL)
    PROP_ENTRY("DisableVideoPreview", DISPID_RTCCTL_DISABLEVIDEOPREVIEW, CLSID_NULL)
END_PROP_MAP()


// IID_IPropertyNotifySink is not used yet. But I'll keep it here,
// maybe we will implement property pages in the future
BEGIN_CONNECTION_POINT_MAP(CRTCCtl)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
    CONNECTION_POINT_ENTRY(IID_IRTCCtlNotify)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CRTCCtl)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
    MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
    MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
    MESSAGE_HANDLER(WM_WTSSESSION_CHANGE, OnWtsSessionChange)
    COMMAND_HANDLER(IDC_BUTTON_CALL, BN_CLICKED, OnButtonCall)
    COMMAND_HANDLER(IDC_BUTTON_HUP, BN_CLICKED, OnButtonHangUp)
    COMMAND_HANDLER(IDC_BUTTON_CALL, 1, OnToolbarAccel)
    COMMAND_HANDLER(IDC_BUTTON_HUP, 1, OnToolbarAccel)
    COMMAND_HANDLER(IDC_BUTTON_MUTE_SPEAKER, BN_CLICKED, OnButtonMuteSpeaker)
    COMMAND_HANDLER(IDC_BUTTON_MUTE_MICRO, BN_CLICKED, OnButtonMuteMicro)
    COMMAND_HANDLER(IDC_BUTTON_RECV_VIDEO_ENABLED, BN_CLICKED, OnButtonRecvVideo)
    COMMAND_HANDLER(IDC_BUTTON_SEND_VIDEO_ENABLED, BN_CLICKED, OnButtonSendVideo)
    COMMAND_HANDLER(IDC_BUTTON_ADD_PART, BN_CLICKED, OnButtonAddPart)
    COMMAND_HANDLER(IDC_BUTTON_REM_PART, BN_CLICKED, OnButtonRemPart)
    COMMAND_RANGE_HANDLER(IDC_DIAL_0, IDC_DIAL_POUND, OnDialButton)
    // this one precedes the other NOTIFY_ID_HANDLER entries
    NOTIFY_CODE_HANDLER(TTN_GETDISPINFO, OnGetDispInfo)
    //
    NOTIFY_ID_HANDLER(IDC_KNOB_SPEAKER, OnKnobNotify)
    NOTIFY_ID_HANDLER(IDC_KNOB_MICRO, OnKnobNotify)
    NOTIFY_HANDLER(IDC_LIST_PARTICIPANTS, LVN_ITEMCHANGED, OnItemChanged)
    CHAIN_MSG_MAP(CComCompositeControl<CRTCCtl>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDialogColor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBackground(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWtsSessionChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnButtonCall(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonHangUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonMuteSpeaker(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonMuteMicro(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonRecvVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonSendVideo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonAddPart(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnButtonRemPart(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnToolbarAccel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnDialButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnGetDispInfo(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnKnobNotify(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
//BEGIN_SINK_MAP(CRTCCtl)
    //Make sure the Event Handlers have __stdcall calling convention
    // No event sink used
//END_SINK_MAP()

// Fire events to the outside world (to IRTCCtlNotify)
    HRESULT    Fire_OnControlStateChange(
        /*[in]*/ RTCAX_STATE State,
        /*[in]*/ UINT StatusBarResID);

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_OPAQUE | VIEWSTATUS_SOLIDBKGND)

// IRTCCtl
    STDMETHOD(get_ProvisioningProfile)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_ProvisioningProfile)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_AutoPlaceCall)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_AutoPlaceCall)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_DestinationUrl)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DestinationUrl)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ShowDialpad)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ShowDialpad)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_CallScenario)(/*[out, retval]*/ RTC_CALL_SCENARIO *pVal);
    STDMETHOD(put_CallScenario)(/*[in]*/ RTC_CALL_SCENARIO newVal);
    STDMETHOD(get_DestinationName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_DestinationName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_DisableVideoReception)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_DisableVideoReception)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_DisableVideoTransmission)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_DisableVideoTransmission)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_DisableVideoPreview)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_DisableVideoPreview)(/*[in]*/ BOOL newVal);

// IRTCEventNotification
    STDMETHOD(Event)( /*[in]*/ RTC_EVENT enEvent,/* [in]*/ IDispatch * pEvent);

// IRTCCtlFrameSupport
    STDMETHOD(GetClient)(/*[out]*/IRTCClient **ppClient);
    STDMETHOD(GetActiveSession)(/*[out]*/ IRTCSession **ppSession);

    STDMETHOD(Message)(
                    /*[in]*/ BSTR          pDestName,
                    /*[in]*/ BSTR          pDestAddress,
                    /*[in]*/ BOOL          bDestAddressEditable,
                    /*[out]*/ BSTR       * ppDestAddressChosen);

    STDMETHOD(Call)(/*[in]*/ BOOL          bCallPhone,
                    /*[in]*/ BSTR          pDestName,
                    /*[in]*/ BSTR          pDestAddress,
                    /*[in]*/ BOOL          bDestAddressEditable,
                    /*[in]*/ BSTR          pLocalPhoneAddress,
                    /*[in]*/ BOOL          bProfileSelected,
                    /*[in]*/ IRTCProfile * pProfile,
                    /*[out]*/ BSTR       * ppDestAddressChosen);

    STDMETHOD(HangUp)(void);
    STDMETHOD(ReleaseSession)(void);
    STDMETHOD(Accept)(void);
    STDMETHOD(Reject)(RTC_TERMINATE_REASON Reason);
    STDMETHOD(AddParticipant)(/*[in]*/ LPOLESTR pDestName,
                            /*[in]*/ LPOLESTR pDestAddress,
                            /*[in]*/ BOOL bAddressEditable);    
    STDMETHOD(SetZoneLayout)(/* [in] */ CZoneStateArray *pArray,
                             /* [in] */ BOOL bRefreshControls);
    STDMETHOD(PreProcessMessage)(/*[in]*/ LPMSG lpMsg);
    STDMETHOD(LoadStringResource)(
				/*[in]*/ UINT nID,
				/*[in]*/ int nBufferMax,
				/*[out]*/ LPWSTR pszText);
    STDMETHOD(get_ControlState)(/*[out, retval]*/ RTCAX_STATE *pVal);
    STDMETHOD(put_ControlState)(/*[in]*/ RTCAX_STATE pVal);
    STDMETHOD(put_Standalone)(/*[in]*/ BOOL pVal);
    STDMETHOD(put_Palette)(/*[in]*/ HPALETTE hPalette);
    STDMETHOD(put_BackgroundPalette)(/*[in]*/ BOOL bBackgroundPalette);
    STDMETHOD(get_CanAddParticipant)(/*[out, retval]*/ BOOL * pfCan); 
    STDMETHOD(get_CurrentCallScenario)(/*[out, retval]*/ RTC_CALL_SCENARIO *pVal);
    STDMETHOD(put_ListenForIncomingSessions)(/*[in]*/ RTC_LISTEN_MODE enListen);
    STDMETHOD(get_ListenForIncomingSessions)(/*[out, retval]*/ RTC_LISTEN_MODE * penListen); 
    STDMETHOD(get_MediaCapabilities)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_MediaPreferences)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_MediaPreferences)(/*[in]*/ long pVal);
    STDMETHOD(get_AudioMuted)(
            /*[in]*/ RTC_AUDIO_DEVICE enDevice,
            /*[out]*/ BOOL *fpMuted);
    STDMETHOD(put_AudioMuted)(
            /*[in]*/ RTC_AUDIO_DEVICE enDevice,
            /*[in]*/ BOOL pMuted);
    STDMETHOD(put_VideoPreview)(/*[in]*/ BOOL pVal);
    STDMETHOD(get_VideoPreview)(/*[out, retval]*/ BOOL * pVal); 
    STDMETHOD(ShowCallFromOptions)();
    STDMETHOD(ShowServiceProviderOptions)();
    STDMETHOD(StartT120Applet)(RTC_T120_APPLET enApplet);

// IOleInPlaceActiveObject related...(hook for TranslateAccelerator)
    // This is an "ATL-virtual" function...
    BOOL PreTranslateAccelerator(LPMSG /*pMsg*/, HRESULT& /*hRet*/);

// IPersistStream(Init)
    STDMETHOD(Load)(LPSTREAM pStm);

// IPersistPropertyBag
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);


    enum { IDD = IDD_RTCCTL };
    
    enum { MAX_STRING_LEN = 0x40 };
    
    enum { ILI_TB_CALLPC = 0,
           ILI_TB_CALLPHONE,
           ILI_TB_HANGUP,
           ILI_TB_ADD_PART,
           ILI_TB_REMOVE_PART
    };
    
    enum { SBP_STATUS = 0,
           SBP_ICON,
           SBP_NR_PARTS };

    enum CTL_MODE {
        CTL_MODE_UNKNOWN,   // mode not known
        CTL_MODE_HOSTED,    // in a web browser 
        CTL_MODE_STANDALONE // in our EXE app
    };

private:

    void    SetControlState(
        RTCAX_STATE NewState, 
        HRESULT StatusCode = S_OK,
        UINT nID = 0);

    BOOL    ConfButtonsActive();
    
    void    UpdateRemovePartButton();

    void    PlaceAndEnableDisableZone(int, CZoneState *);
    void    MoveWindowVertically(CWindow *, LONG Offset);

    HRESULT CreateToolbarControl(CWindow *);
    void    DestroyToolbarControl(CWindow *);

    BOOL    CreateTooltips();

    void    AdjustVideoFrames();
    void    AdjustVideoFrame(CWindow *pWindow, int iCx, int iCy);

    HRESULT RefreshAudioControls(void);
    HRESULT RefreshVideoControls(void);
    
    void    PlaceWindowsAtTheirInitialPosition();

    HRESULT CoreInitialize();
    void    CoreUninitialize();

    HRESULT CallOneShot(void);
    HRESULT RedirectedCall(HRESULT  *phCallResult);

    HRESULT DoRedirect(/*[in]*/ IRTCProfile *pProfile,
                   /*[in]*/ RTC_CALL_SCENARIO CallScenario,
                   /*[in]*/ BSTR     pLocalPhoneAddress,
                   /*[in]*/ BSTR     pDestName,
                   /*[in]*/ BSTR     pDestAddress);

    HRESULT DoCall(/*[in]*/ IRTCProfile *pProfile,
                   /*[in]*/ RTC_CALL_SCENARIO CallScenario,
                   /*[in]*/ BSTR     pLocalPhoneAddress,
                   /*[in]*/ BSTR     pDestName,
                   /*[in]*/ BSTR     pDestAddress);

    // Notifications
    HRESULT OnSessionStateChangeEvent(IRTCSessionStateChangeEvent *);
    HRESULT OnParticipantStateChangeEvent(IRTCParticipantStateChangeEvent *);
    HRESULT OnClientEvent(IRTCClientEvent *);
    HRESULT OnMediaEvent(IRTCMediaEvent *);
    HRESULT OnIntensityEvent(IRTCIntensityEvent *pEvent);
    HRESULT OnMessageEvent(IRTCMessagingEvent *pEvent);

    // Video events
    HRESULT OnVideoMediaEvent(
        BOOL    bReceiveWindow,
        BOOL    bActivated);

    void    ShowHidePreviewWindow(BOOL);

    // Normalize SIP address 
    HRESULT MakeItASipAddress(BSTR , BSTR *);

    void    CalcSizeAndNotifyContainer(void);

    // Error reporting
    HRESULT PrepareErrorStrings(
        BOOL    bOutgoingCall,
        HRESULT StatusCode,
        LPWSTR  pAddress,
        RTCAX_ERROR_INFO
               *pErrorInfo);

    void    FreeErrorStrings(
        RTCAX_ERROR_INFO
               *pErrorInfo);

private:
    
    // Main interface pointer to the core
    CComPtr<IRTCClient>     m_pRTCClient;

    HANDLE                  m_hCoreShutdownEvent;

    // Active session. It includes the case when the client
    // is ringing (the session is not active from the point
    // of view of the core).
    CComPtr<IRTCSession>    m_pRTCActiveSession;   

    // Profile for one shot scenarios (WebCrm)
    CComPtr<IRTCProfile>    m_pRTCOneShotProfile;

    // Connection point
    IConnectionPoint      * m_pCP;
    ULONG                   m_ulAdvise;
    
    // Current state
    RTCAX_STATE             m_nControlState;

    // Redirecting
    BOOL                    m_bRedirecting;

    // Listening
    RTC_LISTEN_MODE         m_enListen;

    // Libary for terminal services
    HMODULE                 m_hWtsLib;

    // Helpers for AddParticipant related states (temporary)
    BOOL                    m_bAddPartDlgIsActive;

    // Outgoing call
    BOOL                    m_bOutgoingCall;

    // Current destination address, good for error message boxes
    CComBSTR                m_bstrOutAddress;

    // Running mode
    CTL_MODE                m_nCtlMode;

    // Capabilities
    long                    m_lMediaCapabilities;
    
    // Preferences
    long                    m_lMediaPreferences;

    // When TRUE, properties cannot be changed
    BOOL                    m_bReadOnlyProp;

    // One of the boolean properties is invalid
    BOOL                    m_bBoolPropError;

    // Properties
    CComBSTR                m_bstrPropDestinationUrl;
    CComBSTR                m_bstrPropDestinationName;
    RTC_CALL_SCENARIO       m_nPropCallScenario;
    BOOL                    m_bPropAutoPlaceCall;
    BOOL                    m_bPropShowDialpad;
    CComBSTR                m_bstrPropProvisioningProfile;
    BOOL                    m_bPropDisableVideoReception;
    BOOL                    m_bPropDisableVideoTransmission;
    BOOL                    m_bPropDisableVideoPreview;

    // Palette
    HPALETTE                m_hPalette;
    BOOL                    m_bBackgroundPalette;    

    // Accelerator for dialpad
    HACCEL                  m_hAcceleratorDialpad;
    
    // Accelerator for toolbar
    HACCEL                  m_hAcceleratorToolbar;

    // Image lists for the toolbar control
    HIMAGELIST              m_hNormalImageList;
    HIMAGELIST              m_hHotImageList;
    HIMAGELIST              m_hDisabledImageList;

    // Brush for the background
    HBRUSH                  m_hBckBrush;
    HBRUSH                  m_hVideoBrush;

    RTC_CALL_SCENARIO       m_nCachedCallScenario;
    CComPtr<IRTCProfile>    m_pCachedProfile;
    CComPtr<IRTCProfile>    m_pRedirectProfile; // used in redirect
    CComBSTR                m_bstrCachedLocalPhoneURI;

    // bitmap for the background
    HBITMAP                 m_hbmBackground;

    // Tooltip window and hook
    CWindow                 m_hTooltip;

    // wrappers for children
    //
    // zone 0, toolbar
    CWindow                 m_hCtlToolbar;

    // zone 1, logo or video
    CWindow                 m_hReceiveWindow;
    CWindow                 m_hPreviewWindow;
    BOOL                    m_bReceiveWindowActive;
    BOOL                    m_bPreviewWindowActive;
    BOOL                    m_bPreviewWindowIsPreferred;

    CButton                 m_hReceivePreferredButton;
    CButton                 m_hSendPreferredButton;
    //CButton                 m_hPreviewPreferredButton;

    CStaticText             m_hReceivePreferredText;
    CStaticText             m_hSendPreferredText;
    //CStaticText           m_hPreviewPreferredText;

    CStaticText             m_hReceiveText;
    CStaticText             m_hSendText;

    // zone 2, dialpad
    CWindow                 m_hDtmfButtons[NR_DTMF_BUTTONS];

    // zone 3, audio controls
    CKnobCtl              * m_pSpeakerKnob;
    CWindow                 m_hSpeakerKnob;
    CButton                 m_hSpeakerMuteButton;
    CStaticText             m_hSpeakerMuteText;
    
    CKnobCtl              * m_pMicroKnob;
    CWindow                 m_hMicroKnob;
    CButton                 m_hMicroMuteButton;
    CStaticText             m_hMicroMuteText;

    // zone 4, participant list
    CParticipantList        m_hParticipantList;
    CButton                 m_hAddParticipant;
    CButton                 m_hRemParticipant;

    // zone 5, status
    CWindow                 m_hStatusBar;

    // zone state
    CZoneStateArray         m_ZoneStateArray;
    
    // init time layout
    CZoneStateArray        *m_pWebCrmLayout;

    // IM Windows
    CIMWindowList          *m_pIMWindows;

private:
    // Static members (layouts)
    // Initial placement
    static  CZoneStateArray s_InitialZoneStateArray;
    // Nothing to display
    static  CZoneStateArray s_EmptyZoneLayout;
    // WebCrm pc to pc
    static  CZoneStateArray s_WebCrmPCToPCZoneLayout;
    // WebCrm pc to phone, with dialpad
    static  CZoneStateArray s_WebCrmPCToPhoneWithDialpadZoneLayout;
    // WebCrm pc to phone, no dialpad
    static  CZoneStateArray s_WebCrmPCToPhoneZoneLayout;
    // WebCrm phone to phone
    static  CZoneStateArray s_WebCrmPhoneToPhoneZoneLayout;
    // PC to PC, idle or incoming calls
    static CZoneStateArray  s_DefaultZoneLayout;
    // PC to Phone (dialpad by default)
    static CZoneStateArray  s_PCToPhoneZoneLayout;
    // Phone to Phone
    static CZoneStateArray  s_PhoneToPhoneZoneLayout;

};

#endif //__RTCAXCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcclient.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCClient.h

Abstract:

    Definition of the CRTCClient class

--*/

#ifndef __RTCCLIENT__
#define __RTCCLIENT__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "dllres.h"

#define WM_STREAMING            WM_USER+101
#define WM_BUDDY_UNSUB          WM_USER+102
#define WM_PROFILE_UNREG        WM_USER+103
#define WM_ASYNC_CLEANUP_DONE   WM_USER+104

enum 
{
    TID_INTENSITY = 1,
    TID_PRESENCE_STORAGE,
    TID_SHUTDOWN_TIMEOUT,
    TID_VOLUME_CHANGE,
    TID_DTMF_TIMER
};

enum RTC_STATE
{
    RTC_STATE_NULL,
    RTC_STATE_INITIALIZED,
    RTC_STATE_PREPARING_SHUTDOWN,
    RTC_STATE_PREPARING_SHUTDOWN2,
    RTC_STATE_PREPARING_SHUTDOWN3,
    RTC_STATE_READY_FOR_SHUTDOWN,
    RTC_STATE_SHUTDOWN

};

class CWavePlayer;

/////////////////////////////////////////////////////////////////
// Intermediate classes used for DISPID encoding
template <class T>
class  IRTCClientVtbl : public IRTCClient
{};

template <class T>
class  IRTCClientPresenceVtbl : public IRTCClientPresence
{};

template <class T>
class  IRTCClientProvisioningVtbl : public IRTCClientProvisioning
{};

/////////////////////////////////////////////////////////////////////////////
// CRTCClient

class ATL_NO_VTABLE CRTCClient :  

#ifdef TEST_IDISPATCH
    public IDispatchImpl<IRTCClientVtbl<CRTCClient>, &IID_IRTCClient, &LIBID_RTCCORELib>, 
    public IDispatchImpl<IRTCClientPresenceVtbl<CRTCClient>, &IID_IRTCClientPresence, &LIBID_RTCCORELib>, 
    public IDispatchImpl<IRTCClientProvisioningVtbl<CRTCClient>, &IID_IRTCClientProvisioning, &LIBID_RTCCORELib>, 
#else
    public IRTCClient,
    public IRTCClientPresence,
    public IRTCClientProvisioning,
#endif
    public ISipStackNotify,
    public CComObjectRoot,
    public CComCoClass<CRTCClient,&CLSID_RTCClient>,    
    public IProvideClassInfo2Impl<&CLSID_RTCClient, &DIID_IRTCDispatchEventNotification,&LIBID_RTCCORELib>,
    public IConnectionPointContainerImpl<CRTCClient>,
    public CRTCConnectionPoint<CRTCClient>,
    public CRTCDispatchConnectionPoint<CRTCClient>
{
public:
    CRTCClient() : m_pWavePlayerSystemDefault(NULL),
                   m_pWavePlayerRenderTerminal(NULL),
                   m_fEnableIncomingCalls(FALSE), 
                   m_fEnableStaticPort(FALSE),
                   m_pSipStack(NULL),  
                   m_pMediaManage(NULL),
                   m_hWnd(NULL),
                   m_hDevNotifyVideo(NULL),
                   m_hDevNotifyAudio(NULL),
                   m_fMediaCapsCached(FALSE),
                   m_lActiveMedia(0),
                   m_bCaptureDeviceMuted(FALSE),
                   m_hNotificationThreadEvent(NULL),
                   m_hNotificationThreadHandle(NULL),
                   m_lActiveIntensity(0),
                   m_uiMinRender(0),
                   m_uiMaxRender(0),
                   m_uiMinCapture(0),
                   m_uiMaxCapture(0),
                   m_pCaptureAudioCfg(NULL),
                   m_pRenderAudioCfg(NULL),
                   m_pSipWatcherManager(NULL),
                   m_pSipBuddyManager(NULL),
                   m_lEventFilter(RTCEF_ALL),
                   m_szUserURI(NULL),
                   m_szUserName(NULL),
                   m_fPresenceUseStorage(FALSE),
                   m_nOfferWatcherMode(RTCOWM_OFFER_WATCHER_EVENT),
                   m_nPrivacyMode(RTCPM_BLOCK_LIST_EXCLUDED),
                   m_nLocalPresenceStatus(RTCXS_PRESENCE_ONLINE),
                   m_fPresenceEnabled(FALSE),
                   m_enRtcState(RTC_STATE_NULL),
                   m_fVideoCaptureDisabled(FALSE),
                   m_fAudioCaptureDisabled(FALSE),
                   m_fAudioRenderDisabled(FALSE),
                   m_fVolumeChangeInProgress(FALSE),
                   m_fTuned(FALSE),
                   m_fTuning(FALSE),
                   m_lInprogressDTMFPacketsToSend(0),
                   m_dwDTMFToneID(0)
    {
        m_pVideoWindow[RTCVD_PREVIEW] = NULL;
        m_pVideoWindow[RTCVD_RECEIVE] = NULL;
    }

BEGIN_COM_MAP(CRTCClient) 
#ifdef TEST_IDISPATCH
    COM_INTERFACE_ENTRY2(IDispatch, IRTCClient)
#endif
    COM_INTERFACE_ENTRY(IRTCClient)
    COM_INTERFACE_ENTRY(IRTCClientPresence)
    COM_INTERFACE_ENTRY(IRTCClientProvisioning)
    COM_INTERFACE_ENTRY(ISipStackNotify)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CRTCClient)
    CONNECTION_POINT_ENTRY(DIID_IRTCDispatchEventNotification)
    CONNECTION_POINT_ENTRY(IID_IRTCEventNotification)
END_CONNECTION_POINT_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RTCClient)

    HRESULT FinalConstruct();

    void FinalRelease();

    STDMETHOD_(ULONG, InternalAddRef)();

    STDMETHOD_(ULONG, InternalRelease)(); 

    HRESULT FireEvent(
                  RTC_EVENT   enEvent,
                  IDispatch * pDispatch
                 );

    HWND    GetWindow(void) { return m_hWnd;}

    HRESULT GetMediaManager(
        IRTCMediaManage ** ppMediaManager
        );

    HRESULT GetBestProfile(
        RTC_SESSION_TYPE * penType,
        PCWSTR szDestUserURI,
        BOOL fIsRedirect,
        IRTCProfile ** ppProfile
        );

    HRESULT UpdatePresenceStorage();

    HRESULT FindWatcherByURI(
            LPCWSTR     lpwstrPresentityURI,
            BOOL        bHidden,
            IRTCWatcher **ppWatcher);   
    
    HRESULT FindBuddyByURI(
            LPWSTR      lpwstrPresentityURI,
            IRTCBuddy **ppBuddy);
    
    void    RemoveHiddenWatcher(
            IRTCWatcher  *pWatcher)
    {
        m_HiddenWatcherArray.Remove(pWatcher);
    }
    
    HRESULT SetEncryptionKey(
            long lMediaType,
            BSTR EncryptionKey
            );

#ifdef DUMP_PRESENCE
    void    DumpWatchers(PCSTR);
#endif

private:

    RTC_STATE                 m_enRtcState;
    BOOL                      m_fEnableIncomingCalls;
    BOOL                      m_fEnableStaticPort;
    IVideoWindow            * m_pVideoWindow[2];
    ISipStack               * m_pSipStack;
    IRTCMediaManage         * m_pMediaManage;
    CRTCObjectArray<IRTCProfile *> m_ProfileArray;
    CRTCObjectArray<IRTCProfile *> m_HiddenProfileArray;
    
    HWND                      m_hWnd;
    HDEVNOTIFY                m_hDevNotifyVideo;
    HDEVNOTIFY                m_hDevNotifyAudio;
    long                      m_lMediaCaps;
    BOOL                      m_fMediaCapsCached;
    long                      m_lActiveMedia;
    BOOL                      m_bCaptureDeviceMuted;
    long                      m_lEventFilter;

    PWSTR                     m_szUserURI;
    PWSTR                     m_szUserName;

    HANDLE                    m_hNotificationThreadEvent;
    HANDLE                    m_hNotificationThreadHandle;
    HANDLE                    m_hNotificationRegistryEvent;
    HKEY                      m_hNotificationRegistryKey;

    BOOL                      m_fVideoCaptureDisabled;
    BOOL                      m_fAudioCaptureDisabled;
    BOOL                      m_fAudioRenderDisabled;

    // used by the intensity controls
    long                      m_lActiveIntensity;
    UINT                      m_uiMinRender, m_uiMaxRender;
    UINT                      m_uiMinCapture, m_uiMaxCapture;
    IRTCAudioConfigure *      m_pCaptureAudioCfg;
    IRTCAudioConfigure *      m_pRenderAudioCfg;

    // Watcher stuff
    ISIPWatcherManager       *m_pSipWatcherManager;
    CRTCObjectArray<IRTCWatcher *>  m_WatcherArray;
    CRTCObjectArray<IRTCWatcher *>  m_HiddenWatcherArray;

    // Buddy stuff
    ISIPBuddyManager         *m_pSipBuddyManager;
    CRTCObjectArray<IRTCBuddy *>    m_BuddyArray;

    RTC_OFFER_WATCHER_MODE    m_nOfferWatcherMode;
    RTC_PRIVACY_MODE          m_nPrivacyMode;

    CComVariant               m_varPresenceStorage;
    BOOL                      m_fPresenceUseStorage;

    RTC_PRESENCE_STATUS       m_nLocalPresenceStatus;
    BOOL                      m_fPresenceEnabled;

    BOOL                      m_fVolumeChangeInProgress;
    BOOL                      m_fTuned;
    BOOL                      m_fTuning;

#if DBG
    PWSTR                     m_pDebug;
#endif

    CWavePlayer             * m_pWavePlayerSystemDefault;
    CWavePlayer             * m_pWavePlayerRenderTerminal;

    long                      m_lInprogressDTMFPacketsToSend;
    DWORD                     m_dwDTMFToneID;
    RTC_DTMF                  m_enInprogressDTMF;

    HRESULT InternalCreateSession(
            IRTCSession ** ppSession
            );

    HRESULT InternalCreateProfile(
            IRTCProfile ** ppProfile
            );

    static LRESULT CALLBACK WndProc(
            HWND hwnd,
            UINT uMsg,
            WPARAM wParam,
            LPARAM lParam
            );

    void OnStreamingEvent(
            RTCMediaEventItem * pEvent
            );

    void OnDeviceChange();

    void OnMixerChange();

    void OnVolumeChangeTimer();

    void OnDTMFTimer();

    HRESULT AutoSelectDefaultTerminals();

    HRESULT LoadAndSelectDefaultTerminals();

    HRESULT StoreDefaultTerminals();

    HRESULT GetAudioCfg(
            RTC_AUDIO_DEVICE enDevice,
            IRTCAudioConfigure ** ppAudioCfg
            );

    HRESULT GetTerminalList(
            IRTCTerminalManage * pTerminalManage,
            IRTCTerminal *** pppTerminals,
            DWORD * pdwCount
            );
    
    HRESULT FreeTerminalList(
            IRTCTerminal ** ppTerminals,
            DWORD dwCount
            );

    void OnShutdownTimeout();

    //
    // Intensity monitor methods
    //

    HRESULT StartIntensityMonitor(LONG lMediaType);
    
    HRESULT StopIntensityMonitor(LONG lMediaType);

    void OnIntensityTimer();
    
    //
    // Presence methods
    //

    HRESULT InternalCreateWatcher(
            PCWSTR      szPresentityURI,
            PCWSTR      szUserName,
            PCWSTR      szData,
            PCWSTR      szShutdownBlob,
            BOOL        bPersistent,
            IRTCWatcher ** ppWatcher
            );

    HRESULT InternalAddWatcher(   
            PCWSTR	  szPresentityURI,
            PCWSTR    szUserName,
            PCWSTR    szData,
            PCWSTR    szShutdownBlob,
			VARIANT_BOOL   fBlocked,
            VARIANT_BOOL   fPersistent,
            IRTCWatcher ** ppWatcher
            );

    HRESULT InternalCreateBuddy(
            PCWSTR      szPresentityURI,
			PCWSTR	    szUserName,
            PCWSTR      szData,
            BOOL        bPersistent,
            IRTCProfile * pProfile,
            long        lFlags,
            IRTCBuddy ** ppBuddy
            );

    HRESULT CreateXMLDOMNodeForBuddyList(
             IXMLDOMDocument * pXMLDoc,
             IXMLDOMNode     ** ppBuddyList
             );

    HRESULT CreateXMLDOMNodeForWatcherList(
             IXMLDOMDocument * pXMLDoc,
             IXMLDOMNode     ** ppWatcherList,
             IXMLDOMNode     ** ppBlockedList
             );

    HRESULT CreateXMLDOMNodeForProperties( 
             IXMLDOMDocument * pXMLDoc, 
             IXMLDOMNode ** ppXDN 
             );

    HRESULT CreateXMLDOMDocumentForPresence(
             IXMLDOMDocument ** ppXMLDoc
             );

    HRESULT ParseXMLDOMNodeForBuddyList(
             IXMLDOMNode     * pBuddyList
             );

    HRESULT ParseXMLDOMNodeForWatcherList(
             IXMLDOMNode     * pWatcherList,
             VARIANT_BOOL      bAllowed
             );

    HRESULT ParseXMLDOMNodeForProperties(
             IXMLDOMNode     * pProperties,
             RTC_OFFER_WATCHER_MODE * pnOfferWatcherMode,
             RTC_PRIVACY_MODE       * pnPrivacyMode
             );

    HRESULT ParseXMLDOMDocumentForPresence(
             IXMLDOMDocument * pXMLDoc,
             RTC_OFFER_WATCHER_MODE * pnOfferWatcherMode,
             RTC_PRIVACY_MODE       * pnPrivacyMode
             );

    HRESULT InternalExport(
             VARIANT varStorage
             );

    void OnPresenceStorageTimer();

    void OnBuddyUnsub(IRTCBuddy * pBuddy, BOOL bShutdown);    

    void RefreshPresenceSessions(BOOL bIncludingWatchers);

    void OnAsyncCleanupDone();

    BOOL IsIncomingSessionAuthorized(PCWSTR pszCallerURI);

    void OnProfileUnreg(IRTCProfile * pProfile);

    HRESULT InternalPrepareForShutdown(BOOL fAsync);
    HRESULT InternalPrepareForShutdown2(BOOL fAsync);
    HRESULT InternalPrepareForShutdown3(BOOL fAsync);
    HRESULT InternalReadyForShutdown();

public:

#ifdef TEST_IDISPATCH
//
// IDispatch
//

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );  
#endif
//
// IRTCClient
//

    STDMETHOD(Initialize)();  

    STDMETHOD(Shutdown)(); 

    STDMETHOD(PrepareForShutdown)(); 

    STDMETHOD(put_EventFilter)(
            long lFilter
            );

    STDMETHOD(get_EventFilter)(
            long * plFilter
            );

    STDMETHOD(SetPreferredMediaTypes)(
            long lMediaTypes,
            VARIANT_BOOL fPersistent
            );

    STDMETHOD(get_PreferredMediaTypes)(
            long * plMediaTypes
            );  

    STDMETHOD(get_MediaCapabilities)(
            long * plMediaTypes
            );  

    STDMETHOD(CreateSession)(
            RTC_SESSION_TYPE enType,
            BSTR bstrLocalPhoneURI,
            IRTCProfile * pProfile,
            long lFlags,
            IRTCSession ** ppSession
            );

    STDMETHOD(put_ListenForIncomingSessions)(
            RTC_LISTEN_MODE enListen
            );

    STDMETHOD(get_ListenForIncomingSessions)(
            RTC_LISTEN_MODE * penListen
            );

    STDMETHOD(get_NetworkAddresses)(
            VARIANT_BOOL fTCP,
            VARIANT_BOOL fExternal,
            VARIANT * pvAddress
            );
    
    STDMETHOD(put_Volume)(
            RTC_AUDIO_DEVICE enDevice,
            long lVolume
            );  

    STDMETHOD(get_Volume)(
            RTC_AUDIO_DEVICE enDevice,
            long * plVolume
            );  

    STDMETHOD(put_AudioMuted)(
            RTC_AUDIO_DEVICE enDevice,
            VARIANT_BOOL fMuted
            );

    STDMETHOD(get_AudioMuted)(
            RTC_AUDIO_DEVICE enDevice,
            VARIANT_BOOL * pfMuted
            ); 

    STDMETHOD(get_IVideoWindow)(
            RTC_VIDEO_DEVICE enDevice,
            IVideoWindow ** ppIVideoWindow
            );

    STDMETHOD(put_PreferredAudioDevice)(
            RTC_AUDIO_DEVICE enDevice,
            BSTR bstrDeviceName
            );  

    STDMETHOD(get_PreferredAudioDevice)(
            RTC_AUDIO_DEVICE enDevice,
            BSTR * pbstrDeviceName
            );
             
    STDMETHOD(put_PreferredVolume)(
            RTC_AUDIO_DEVICE enDevice,
            long lVolume
            );  

    STDMETHOD(get_PreferredVolume)(
            RTC_AUDIO_DEVICE enDevice,
            long * plVolume
            );   

    STDMETHOD(put_PreferredAEC)(
            VARIANT_BOOL bEnable
            );  

    STDMETHOD(get_PreferredAEC)(
            VARIANT_BOOL * pbEnabled
            );
            
    STDMETHOD(put_PreferredVideoDevice)(
            BSTR bstrDeviceName
            );  

    STDMETHOD(get_PreferredVideoDevice)(
            BSTR * pbstrDeviceName
            );
    
    STDMETHOD(get_ActiveMedia)(
            long * plMediaType
            );

    STDMETHOD(get_MaxBitrate)(
            long * plMaxBitrate
            );

    STDMETHOD(put_MaxBitrate)(
            long lMaxBitrate
            );

    STDMETHOD(get_TemporalSpatialTradeOff)(
            long * plValue
            );

    STDMETHOD(put_TemporalSpatialTradeOff)(
            long lValue
            );

    STDMETHOD(StartT120Applet)(
            RTC_T120_APPLET enApplet
            );

    STDMETHOD(StopT120Applets)();

    STDMETHOD(get_IsT120AppletRunning)(
            RTC_T120_APPLET   enApplet,
            VARIANT_BOOL * pfRunning
            );

    STDMETHOD(get_LocalUserURI)(
            BSTR * pbstrUserURI
            ); 
    
    STDMETHOD(put_LocalUserURI)(
            BSTR bstrUserURI
            ); 

    STDMETHOD(get_LocalUserName)(
            BSTR * pbstrUserName
            );  

    STDMETHOD(put_LocalUserName)(
            BSTR bstrUserName
            ); 

    STDMETHOD(PlayRing)(
            RTC_RING_TYPE enType,
            VARIANT_BOOL bPlay
            );

    STDMETHOD(SendDTMF)(
            RTC_DTMF enDTMF
            );

    STDMETHOD(InvokeTuningWizard)(
            OAHWND hwndParent
            ); 

    STDMETHOD(get_IsTuned)(
            VARIANT_BOOL * pfTuned
            ); 
    
    STDMETHOD(get_NetworkQuality)(
            long * plNetworkQuality
            );

//
// IRTCClientPresence
//

    STDMETHOD(EnablePresence)(            
            VARIANT_BOOL fUseStorage,
            VARIANT varStorage
            );

    STDMETHOD(Export)(
            VARIANT varStorage
            );

    STDMETHOD(Import)(
            VARIANT varStorage,
            VARIANT_BOOL fReplaceAll
            );

    STDMETHOD(EnumerateBuddies)(
            IRTCEnumBuddies ** ppEnum
            );

    STDMETHOD(get_Buddies)(
            IRTCCollection ** ppCollection
            );

    STDMETHOD(get_Buddy)(
            BSTR bstrPresentityURI,
            IRTCBuddy ** ppBuddy
            );

    STDMETHOD(AddBuddy)(
            BSTR bstrPresentityURI,
            BSTR bstrUserName,
            BSTR bstrData,
            VARIANT_BOOL bPersistent,
            IRTCProfile * pProfile,
            long lFlags,
            IRTCBuddy ** ppBuddy
            );

    STDMETHOD(RemoveBuddy)(
            IRTCBuddy * pBuddy
            );

    STDMETHOD(EnumerateWatchers)(   
            IRTCEnumWatchers ** ppEnum
            );

    STDMETHOD(get_Watchers)(
            IRTCCollection ** ppCollection
            );

    STDMETHOD(get_Watcher)(
            BSTR	bstrPresentityURI,
            IRTCWatcher	** ppWatcher
            );
    
    STDMETHOD(AddWatcher)(   
            BSTR	bstrPresentityURI,
            BSTR    bstrUserName,
            BSTR    bstrData,
			VARIANT_BOOL bBlocked,
            VARIANT_BOOL bPersistent,
            IRTCWatcher ** ppWatcher
            );
    
    STDMETHOD(RemoveWatcher)(   
            IRTCWatcher	*pWatcher
            );

    STDMETHOD(SetLocalPresenceInfo)(   
            RTC_PRESENCE_STATUS enStatus,
			BSTR bstrNotes
            );

    STDMETHOD(get_OfferWatcherMode)(   
            RTC_OFFER_WATCHER_MODE * penMode
            );

    STDMETHOD(put_OfferWatcherMode)(
            RTC_OFFER_WATCHER_MODE   enMode
            );

    STDMETHOD(get_PrivacyMode)(   
            RTC_PRIVACY_MODE * penMode
            );

    STDMETHOD(put_PrivacyMode)(
            RTC_PRIVACY_MODE   enMode
            );
 
    //
    // IRTCClientProvisioning
    //

    STDMETHOD(CreateProfile)(
            BSTR bstrProfileXML,
            IRTCProfile ** ppProfile
            );

    STDMETHOD(EnableProfile)(
            IRTCProfile * pProfile,
            long lRegisterFlags
            );

    STDMETHOD(DisableProfile)(
            IRTCProfile * pProfile           
            );

    STDMETHOD(EnumerateProfiles)(            
            IRTCEnumProfiles ** ppEnum
            ); 

    STDMETHOD(get_Profiles)(
            IRTCCollection ** ppCollection
            );

    STDMETHOD(GetProfile)(
            BSTR bstrUserAccount,
            BSTR bstrUserPassword,
            BSTR bstrUserURI,
            BSTR bstrServer,
            long lTransport,
            long lCookie
            );

    STDMETHOD(get_SessionCapabilities)(
            long * plSupportedSessions
            );

    //
    // ISipStackNotify
    //

    STDMETHOD(NotifyIPAddrChange)();

    STDMETHOD(NotifyRegisterRedirect)( 
        SIP_PROVIDER_ID     *pSipProviderID,
        ISipRedirectContext *pRegisterContext,
        SIP_CALL_STATUS     *pRegisterStatus
        );

    STDMETHOD(NotifyProviderStatusChange)(
            SIP_PROVIDER_STATUS * ProviderStatus
            );            

    STDMETHOD(OfferCall)(
            ISipCall       * Call,
            SIP_PARTY_INFO * CallerInfo
            );           

    STDMETHOD(OfferWatcher)(
            ISIPWatcher    * Watcher,
            SIP_PARTY_INFO * CallerInfo
            );
    
    
    STDMETHOD(WatcherOffline)(
            ISIPWatcher    * Watcher,
            WCHAR* pwstrContactAddress
            );

    STDMETHOD(NotifyShutdownReady)();

    STDMETHOD(NotifyIncomingSession)(
		    IIMSession     * pIMSession,
		    BSTR             msg,
            BSTR             ContentType,
		    SIP_PARTY_INFO * CallerInfo
            );

    STDMETHOD(IsIMSessionAuthorized)(
            BSTR pszCallerURI,
            BOOL  * bAuthorized
	        );

    STDMETHOD(GetCredentialsFromUI)(
            SIP_PROVIDER_ID        *pProviderID,
            BSTR                    Realm,
            BSTR                   *Username,
            BSTR                   *Password        
            );

    STDMETHOD(GetCredentialsForRealm)(
            IN  BSTR                 Realm,
            OUT BSTR                *Username,
            OUT BSTR                *Password,
            OUT SIP_AUTH_PROTOCOL   *pAuthProtocol
            );

};

#endif //__RTCCLIENT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcdib.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rtcdib.h

Abstract:

    DIB helpers, copied from NT source tree

--*/



#pragma once

//
// Dib helpers
//
WORD        DibNumColors(VOID FAR * pv);
HANDLE      DibFromBitmap(HBITMAP hbm, DWORD biStyle, WORD biBits, HPALETTE hpal, UINT wUsage);
BOOL        DibBlt(HDC hdc, int x0, int y0, int dx, int dy, HANDLE hdib, int x1, int y1, LONG rop, UINT wUsage);
UINT        PaletteSize(VOID FAR * pv);


#define WIDTHBYTES(i)     ((i+31)/32*4)      /* ULONG aligned ! */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcuri.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rtcuri.h

Abstract:

    URI helpers

--*/

#ifndef __RTCURI__
#define __RTCURI__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

    HRESULT AllocCleanSipString(PCWSTR szIn, PWSTR *pszOut);

    HRESULT AllocCleanTelString(PCWSTR szIn, PWSTR *pszOut);

    BOOL    IsEqualURI(PCWSTR szA, PCWSTR szB);
    
    HRESULT    GetAddressType(
        LPCOLESTR pszAddress, 
        BOOL *pbIsPhoneAddress, 
        BOOL *pbIsSipURL,
        BOOL *pbIsTelURL,
        BOOL *pbIsEmailLike,
        BOOL *pbHasMaddrOrTsp);

#endif //__RTCURI__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcconnect.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCConnect.h

Abstract:

    Definition of the CRTCConnectionPoint class

--*/

#ifndef __RTCCONNECT__
#define __RTCCONNECT__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CRTCConnectionPoint

template <class T>
class CRTCConnectionPoint :
    public IConnectionPointImpl<T, &IID_IRTCEventNotification, CComDynamicUnkArray>
{
public:
    VOID _FireEvent(RTC_EVENT rtce, IDispatch * pEvent)
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0;
                nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();

            if ( sp != NULL )
            {
                IRTCEventNotification * pCallback;
                HRESULT hr;

                hr = sp->QueryInterface(IID_IRTCEventNotification,
                                        (void **)&pCallback
                                       );

                if (SUCCEEDED(hr))
                {
                    pCallback->Event( rtce, pEvent );

                    pCallback->Release(); 
                }
            }
        }
    }
};

/////////////////////////////////////////////////////////////////////////////
// CRTCDispatchConnectionPoint

template <class T>
class CRTCDispatchConnectionPoint :
    public IConnectionPointImpl<T, &DIID_IRTCDispatchEventNotification, CComDynamicUnkArray>
{
public:
    VOID _FireDispatchEvent(RTC_EVENT rtce, IDispatch * pEvent)
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        CComVariant* pvars = new CComVariant[2];

        for (nConnectionIndex = 0;
                nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();

            if ( sp != NULL )
            {
                IDispatch * pDispatch;

                pDispatch = reinterpret_cast<IDispatch*>(sp.p);

                if (pDispatch != NULL)
                {
                    pvars[1] = rtce;
                    pvars[0] = pEvent;
                    DISPPARAMS disp = { pvars, NULL, 2, 0 };

                    pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
            }
        }

        delete[] pvars;
    }
};

#endif //__RTCCONNECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\statictext.h ===
// statictext.h : Declaration of the CStaticText

//
// This is a static text control. Be sure to create it with the
// WS_EX_TRANSPARENT style because we do not paint the background.
//

#ifndef __STATICTEXT_H_
#define __STATICTEXT_H_

/////////////////////////////////////////////////////////////////////////////
// CStaticText
class CStaticText : 
    public CWindowImpl<CStaticText>
{

public:

    CStaticText() : m_dwFlags(DT_HIDEPREFIX)
    {}

BEGIN_MSG_MAP(CStaticText)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETTEXT, OnRefresh)
    MESSAGE_HANDLER(WM_ENABLE, OnRefresh)
    MESSAGE_HANDLER(WM_UPDATEUISTATE, OnUpdateUIState)
END_MSG_MAP()

    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRefresh(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUpdateUIState(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT put_CenterHorizontal(BOOL bCenter);
    HRESULT put_CenterVertical(BOOL bCenter);
    HRESULT put_WordWrap(BOOL bWrap);

private:

    DWORD m_dwFlags;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtclog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCLog.h

Abstract:

    Definitions for logging support.

--*/

#ifndef __RTCLOG__
#define __RTCLOG__

#ifdef RTCLOG

    #include <rtutils.h>

    #define RTC_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define RTC_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define RTC_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define RTC_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)

    BOOL NTAPI LogRegisterDebugger(LPCTSTR szName);
    BOOL NTAPI LogRegisterTracing(LPCTSTR szName);
    void NTAPI LogDeRegisterDebugger();
    void NTAPI LogDeRegisterTracing();
    void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

    // 
    // LOGREGISTERDEBUGGER and LOGDEREGISTERDEBBUGGER handle registration
    // for tracing to the debugger. These are safe to be called in DllMain.
    //
    // LOGREGISTERTRACING and LOGDEREGISTERTRACING handle the steelhead
    // registration for console and file tracing. The are NOT SAFE to be
    // be called from DllMain.
    //
    // For complete tracing support you must do both registrations.
    //

    #define LOGREGISTERDEBUGGER(arg) LogRegisterDebugger(arg)
    #define LOGREGISTERTRACING(arg) LogRegisterTracing(arg)
    #define LOGDEREGISTERDEBUGGER() LogDeRegisterDebugger()
    #define LOGDEREGISTERTRACING() LogDeRegisterTracing()
    #define LOG(arg) LogPrint arg

#else //RTCLOG

    #define LOGREGISTERDEBUGGER(arg)
    #define LOGREGISTERTRACING(arg)
    #define LOGDEREGISTERDEBUGGER() 
    #define LOGDEREGISTERTRACING() 
    #define LOG(arg)

#endif //RTCLOG

#endif //__RTCLOG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcmem.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCMem.h

Abstract:

    Definitions for memory allocation.

--*/

#ifndef __RTCMEM__
#define __RTCMEM__

#include <windows.h>
#include <winbase.h>
#include <setupapi.h>
#include <TCHAR.h>

typedef struct _RTC_MEMINFO
{
    struct _RTC_MEMINFO * pNext;
    struct _RTC_MEMINFO * pPrev;
    DWORD               dwSize;
    DWORD               dwLine;
    PSTR                pszFile;
    DWORD               dwAlign;
} RTC_MEMINFO, *PRTC_MEMINFO;

//
// RtcHeapCreate must be called before RtcAlloc in order the create the heap. This function
// must be called only once.
//

BOOL
WINAPI
RtcHeapCreate();

//
// RtcHeapDestroy must be called after all memory is deallocated.
//

VOID
WINAPI
RtcHeapDestroy();

#if DBG

	//
	// RtcAlloc will allocated memory from the heap.
	//

    #define RtcAlloc( __size__ ) RtcAllocReal( __size__, __LINE__, __FILE__ )

    LPVOID
    WINAPI
    RtcAllocReal(
             DWORD   dwSize,
             DWORD   dwLine,
             PSTR    pszFile
            );

	//
	// RtcDumpMemoryList will list all memory which was allocated with RtcAlloc, but not freed.
	//
	
    VOID
    WINAPI
    RtcDumpMemoryList();

#else

    #define RtcAlloc( __size__ ) RtcAllocReal( __size__ )

    LPVOID
    WINAPI
    RtcAllocReal(
        DWORD   dwSize
        );

#endif

//
// RtcFree must be called to free memory which was allocated with RtcAlloc.
//

VOID
WINAPI
RtcFree(
     LPVOID  p
     );

//
// RtcAllocString uses RtcAlloc to allocate a copy of a wide character string.
//

PWSTR
RtcAllocString(
    PCWSTR sz
    );

//
// RtcAllocString uses RtcAlloc to allocate and load a resource string
//

PWSTR
RtcAllocString(
    HINSTANCE   hInst,
    UINT        uResID
    );

//
// CoTaskAllocString uses CoTaskMemAlloc to allocate a copy of a wide character string.
//

PWSTR
CoTaskAllocString(
    PCWSTR sz
    );

//
// RtcAllocStringFromANSI uses RtcAlloc to allocate a copy of a ANSI character string.
//

PWSTR
RtcAllocStringFromANSI(
    PCSTR sz
    );

//
// SysAllocStringFromANSI uses SysAllocString to allocate a copy of a ANSI character string.
//

BSTR
SysAllocStringFromANSI(
    PCSTR sz
    );

//
// RtcRegQueryString uses RtcAlloc to allocate a string retrieved from the registry.
//

PWSTR
RtcRegQueryString(
    HKEY hKey,
    PCWSTR szValueName
    );

//
// RtcGetUserName uses RtcAlloc to allocate a string containing the user name
//

PWSTR
RtcGetUserName();

//
// RtcGetComputerName uses RtcAlloc to allocate a string containing the computer name
//

PWSTR
RtcGetComputerName();

#endif __RTCMEM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcenum.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCEnum.h

Abstract:

    Template classes for enumerations

--*/

#ifndef __RTCENUM__
#define __RTCENUM__

//////////////////////////////////////////////////////////////////////
// CRTCEnum
//          Template class for enumerations
//////////////////////////////////////////////////////////////////////
template <class Base, class T, const IID* piid> class ATL_NO_VTABLE CRTCEnum :
    public Base,
    public CComObjectRoot
{
public:

    typedef CRTCEnum<Base, T, piid> _CRtcEnumBase;

    BEGIN_COM_MAP(_CRtcEnumBase)
            COM_INTERFACE_ENTRY_IID(*piid, _CRtcEnumBase)
    END_COM_MAP()

protected:

    CRTCObjectArray<T*>    m_Array;
    int                    m_iCurrentLocation;
    
public:

    // initialize the enumerator with a list<T*>
    HRESULT Initialize(
                       CRTCObjectArray<T*> array
                      )
    {
        int         iSize, iCount;

        iSize = array.GetSize();

        for( iCount = 0; iCount < iSize; iCount++ )
        {
            m_Array.Add(array[iCount]);
        }

        m_iCurrentLocation = 0;
        
        this->AddRef();

        return S_OK;
    }

    // overloaded
    HRESULT Initialize(
                       CRTCArray<T*> array
                      )
    {
        int         iSize, iCount;

        iSize = array.GetSize();

        for( iCount = 0; iCount < iSize; iCount++ )
        {
            m_Array.Add(array[iCount]);
        }

        m_iCurrentLocation = 0;
        
        this->AddRef();

        return S_OK;
    }

    // Overloaded function, used with Add to build enum list manually
    HRESULT Initialize( )
    {
        m_iCurrentLocation = 0;
        
        this->AddRef();
        
        return S_OK;
    }    

    // Add - used with non-parameterized initialize() to build enum list manually
    HRESULT Add( T* t)
    {
        BOOL fResult;

        fResult = m_Array.Add( t );

        return fResult ? S_OK : E_OUTOFMEMORY;
    }
    
    
    // FinalRelease - release the objects that were addreffed in
    // initialize
    void FinalRelease()
    {
        m_Array.Shutdown();
    }


    // standard Next method
    HRESULT STDMETHODCALLTYPE Next( 
                                    ULONG celt,
                                    T ** ppElements,
                                    ULONG* pceltFetched
                                  )
    {
        DWORD       dwCount = 0;
        HRESULT     hr = S_OK;

        if ((NULL == ppElements) || (NULL == pceltFetched && celt > 1))
        {
            return E_POINTER;
        }

        // special case
        if (celt == 0)
        {
            return E_INVALIDARG;
        }

        if ( IsBadWritePtr( ppElements, celt * sizeof(T*)) )
        {
            return E_POINTER;
        }

        if ( ( NULL != pceltFetched) &&
             IsBadWritePtr( pceltFetched, sizeof (ULONG) ) )
        {
            return E_POINTER;
        }
        
        // iterator over elements
        while ((m_iCurrentLocation != m_Array.GetSize()) && (dwCount < celt))
        {
            ppElements[dwCount] = m_Array[m_iCurrentLocation];
            
            ppElements[dwCount]->AddRef();
            
            m_iCurrentLocation++;
            
            dwCount++;
        }

        if (NULL != pceltFetched)
        {
            *pceltFetched = dwCount;
        }

        // indicate that we've reached the end
        // of the enumeration.
        if (dwCount < celt)
        {
            return S_FALSE;
        }

        return S_OK;
    }

    // standard Reset method
    HRESULT STDMETHODCALLTYPE Reset( void )
    {
        m_iCurrentLocation = 0;
        
        return S_OK;
    }


    // standard Skip method
    HRESULT STDMETHODCALLTYPE Skip( 
                                   ULONG celt
                                  )
    {
        ULONG        ulCount = 0;
        
        while ( (ulCount < celt) && (m_iCurrentLocation < m_Array.GetSize() ) )
        {
            m_iCurrentLocation++;
            ulCount++;
        }

        return S_OK;
    }

    // standard Clone method
    HRESULT STDMETHODCALLTYPE Clone( 
                                    Base  ** ppEnum
                                   )
    {
        HRESULT                        hr = S_OK;
        CComObject< _CRtcEnumBase > * pNewEnum;

        if ( IsBadWritePtr( ppEnum, sizeof (Base *) ) )
        {
            return E_POINTER;
        }

        CComObject< _CRtcEnumBase >::CreateInstance(&pNewEnum);
        if (pNewEnum == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pNewEnum->Initialize(m_Array);

            pNewEnum->m_iCurrentLocation = m_iCurrentLocation;

            *ppEnum = pNewEnum;
        }
        
        return hr;
    }

};


#endif //__RTCENUM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\rtcutils.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RTCUtils.h

Abstract:

    Utilities

--*/

#ifndef __RTCUTILS__
#define __RTCUTILS__

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CRTCObjectArray - based on from CSimpleArray from atl
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
template <class T>
class CRTCObjectArray
{
private:
    
	T           * m_aT;
	int           m_nSize;
    int           m_nUsed;

public:
	CRTCObjectArray() : m_aT(NULL), m_nSize(0), m_nUsed(0){}

	~CRTCObjectArray()
	{}

	int GetSize() const
	{
		return m_nUsed;
	}
    
	BOOL Add(T& t)
	{
		if(m_nSize == m_nUsed)
		{
			T       * aT;
            int       nNewSize;
                    
			nNewSize = (m_nSize == 0) ? 1 : (m_nSize * 2);
            
			aT = (T*) RtcAlloc (nNewSize * sizeof(T));
            
			if(aT == NULL)
            {
				return FALSE;
            }

            CopyMemory(
                       aT,
                       m_aT,
                       m_nUsed * sizeof(T)
                      );

            RtcFree( m_aT );

            m_aT = aT;
            
			m_nSize = nNewSize;
		}

        m_aT[m_nUsed] = t;

        if(t)
        {
            t->AddRef();
        }

		m_nUsed++;
        
		return TRUE;
	}
    
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
        
		if(nIndex == -1)
			return FALSE;
        
		return RemoveAt(nIndex);
	}
    
	BOOL RemoveAt(int nIndex)
	{
        T t = m_aT[nIndex];
        m_aT[nIndex] = NULL;

        if(t)
        {
            t->Release();
        }

        if(nIndex != (m_nUsed - 1))
        {
			MoveMemory(
                       (void*)&m_aT[nIndex],
                       (void*)&m_aT[nIndex + 1],
                       (m_nUsed - (nIndex + 1)) * sizeof(T)
                      );
        }
        

		m_nUsed--;
        
		return TRUE;
	}
    
	void Shutdown()
	{
		if( NULL != m_aT )
		{
            int     index;

            for (index = 0; index < m_nUsed; index++)
            {
                T t = m_aT[index];
                m_aT[index] = NULL;

                if(t)
                {
                    t->Release();
                }
            }

			RtcFree(m_aT);
            
			m_aT = NULL;
			m_nUsed = 0;
			m_nSize = 0;
		}
	}
    
	T& operator[] (int nIndex) const
	{
		_ASSERTE(nIndex >= 0 && nIndex < m_nUsed);
		return m_aT[nIndex];
	}
    
	int Find(T& t) const
	{
		for(int i = 0; i < m_nUsed; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CRTCArray - based on from CSimpleArray from atl
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
template <class T>
class CRTCArray
{
private:
    
	T           * m_aT;
	int           m_nSize;
    int           m_nUsed;

public:

	CRTCArray() : m_aT(NULL), m_nSize(0), m_nUsed(0){}

	~CRTCArray()
	{}

	int GetSize() const
	{
		return m_nUsed;
	}
    
	BOOL Add(T& t)
	{
		if(m_nSize == m_nUsed)
		{
			T       * aT;
            int       nNewSize;
                    
			nNewSize = (m_nSize == 0) ? 1 : (m_nSize * 2);
            
			aT = (T*) RtcAlloc (nNewSize * sizeof(T));
            
			if(aT == NULL)
            {
				return FALSE;
            }

            CopyMemory(
                       aT,
                       m_aT,
                       m_nUsed * sizeof(T)
                      );

            RtcFree( m_aT );

            m_aT = aT;
            
			m_nSize = nNewSize;
		}

        m_aT[m_nUsed] = t;

		m_nUsed++;
        
		return TRUE;
	}
    
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
        
		if(nIndex == -1)
			return FALSE;
        
		return RemoveAt(nIndex);
	}
    
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nUsed - 1))
        {
			MoveMemory(
                       (void*)&m_aT[nIndex],
                       (void*)&m_aT[nIndex + 1],
                       (m_nUsed - (nIndex + 1)) * sizeof(T)
                      );
        }

		m_nUsed--;
        
		return TRUE;
	}
    
	void Shutdown()
	{
		if( NULL != m_aT )
		{
            int     index;

			RtcFree(m_aT);
            
			m_aT = NULL;
			m_nUsed = 0;
			m_nSize = 0;
		}
	}
    
	T& operator[] (int nIndex) const
	{
		_ASSERTE(nIndex >= 0 && nIndex < m_nUsed);
		return m_aT[nIndex];
	}
    
	int Find(T& t) const
	{
		for(int i = 0; i < m_nUsed; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

#endif // __RTCUTILS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\inc\ui.h ===
//
// ui.h
//

#ifndef __UI_H_
#define __UI_H_

interface IRTCPhoneNumber;
interface IRTCEnumPhoneNumbers;

//////////////////////////////////////////////////////////////////////////////
//
//
//

void CleanupListOrComboBoxInterfaceReferences(
    IN  HWND        hwndDlg,
    IN  int         nIDDlgItem,
    IN  BOOL        fUseComboBox
    );

//////////////////////////////////////////////////////////////////////////////
//
// CallFrom List
//

HRESULT PopulateCallFromList(
    IN   HWND          hwndDlg,
    IN   int           nIDDlgItem,
    IN   BOOL          fUseComboBox,
    IN   BSTR          bstrDefaultCallFrom
    );

HRESULT GetCallFromListSelection(
    IN   HWND               hwndDlg,
    IN   int                nIDDlgItem,
    IN   BOOL               fUseComboBox,
    OUT  IRTCPhoneNumber ** ppNumber
    );

//////////////////////////////////////////////////////////////////////////////
//
// ServiceProvider List
//

HRESULT PopulateServiceProviderList(
    IN   HWND          hwndDlg,
    IN   IRTCClient  * pClient,
    IN   int           nIDDlgItem,
    IN   BOOL          fUseComboBox,
    IN   IRTCProfile * pOneShotProfile,
    IN   BSTR          bstrDefaultProfileKey, 
    IN   long          lSessionMask,
    IN   int           nIDNone
    );

HRESULT GetServiceProviderListSelection(
    IN   HWND               hwndDlg,
    IN   int                nIDDlgItem,
    IN   BOOL               fUseComboBox,
    OUT  IRTCProfile     ** ppProfile
    );

//////////////////////////////////////////////////////////////////////////////
//
//
//

void EnableDisableCallGroupElements(
    IN   HWND          hwndDlg,
    IN   IRTCClient  * pClient,
    IN   long          lSessionMask,
    IN   int           nIDRbComputer,
    IN   int           nIDRbPhone,
    IN   int           nIDComboCallFrom,
    IN   int           nIDComboProvider,
    OUT  BOOL        * pfCallFromComputer,
    OUT  BOOL        * pfCallFromPhone,
    OUT  BOOL        * pfCallToComputer,
    OUT  BOOL        * pfCallToPhone
    );

//////////////////////////////////////////////////////////////////////////////
//
// Phone number helpers
//

HRESULT StoreLocalPhoneNumber(
    IN   IRTCPhoneNumber * pPhoneNumber,
    IN   VARIANT_BOOL fOverwrite
    );

HRESULT DeleteLocalPhoneNumber(
    IN   IRTCPhoneNumber * pPhoneNumber
    );

HRESULT EnumerateLocalPhoneNumbers(
    OUT  IRTCEnumPhoneNumbers ** ppEnum
    );

HRESULT CreatePhoneNumber(
    OUT  IRTCPhoneNumber ** ppPhoneNumber
    );



//////////////////////////////////////////////////////////////////////////////
//
// DisplayMessage
//
// Displays a message box. The message string and caption are loaded from the
// string table based on the IDs passed in. The message box has only a
// single "OK" button.
//
// Parameters
//    hResourceInstance - handle to resource instance used to load strings
//    hwndParent        - parent window. Can be NULL.
//    nTextId           - IDS for the message string
//    nCaptionId        - IDS for the caption
//
// Return value
//    void
//

int DisplayMessage(
    IN   HINSTANCE hResourceInstance,
    IN   HWND      hwndParent,
    IN   int       nTextId,
    IN   int       nCaptionId,
    IN   UINT      uiStyle = MB_OK
    );

//////////////////////////////////////////////////////////////////////////////
//
// Registry
//

typedef enum SETTINGS_STRING
{
    SS_USER_DISPLAY_NAME,
    SS_USER_URI,
    SS_LAST_AREA_CODE,
    SS_LAST_NUMBER,
    SS_LAST_PROFILE,
    SS_LAST_ADDRESS,
    SS_LAST_CALL_FROM,
    SS_WINDOW_POSITION
    
} SETTINGS_STRING;

typedef enum SETTINGS_DWORD
{
    SD_LAST_COUNTRY_CODE,
    SD_URL_REG_DONT_ASK_ME,
    SD_AUTO_ANSWER,
    SD_RUN_AT_STARTUP,
    SD_MINIMIZE_ON_CLOSE,
    SD_VIDEO_PREVIEW
    
} SETTINGS_DWORD;


HRESULT put_SettingsString(
        SETTINGS_STRING enSetting,
        BSTR bstrValue            
        ); 

HRESULT get_SettingsString(
        SETTINGS_STRING enSetting,
        BSTR * pbstrValue            
        ); 

HRESULT DeleteSettingsString(
        SETTINGS_STRING enSetting
        );

HRESULT put_SettingsDword(
        SETTINGS_DWORD enSetting,
        DWORD dwValue            
        ); 

HRESULT get_SettingsDword(
        SETTINGS_DWORD enSetting,
        DWORD * pdwValue            
        ); 

HRESULT DeleteSettingsDword(
        SETTINGS_DWORD enSetting
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\audiotuner.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    AudioTuner.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 24-Aug-2000

--*/

#include "stdafx.h"

//
// CRTCAudioTuner methods
//

CRTCAudioTuner::CRTCAudioTuner()
    :m_pTerminal(NULL)
    ,m_pTerminalPriv(NULL)
    ,m_pAudioDuplexController(NULL)
    ,m_fIsTuning(FALSE)
    ,m_fEnableAEC(FALSE)
{
}

CRTCAudioTuner::~CRTCAudioTuner()
{
    ENTER_FUNCTION("CRTCAudioTuner::~CRTCAudioTuner");

    HRESULT hr;

    // cleanup if necessary
    if (m_fIsTuning ||  m_pTerminal)
    {
        if (FAILED(hr = ShutdownTuning()))
        {
            LOG((RTC_ERROR, "%s shutdown tuning. %x", __fxName, hr));
        }
    }

    _ASSERT(m_pTerminalPriv == NULL);
}

HRESULT
CRTCAudioTuner::InitializeTuning(
    IN IRTCTerminal *pTerminal,
    IN IAudioDuplexController *pAudioDuplexController,
    IN BOOL fEnableAEC
    )
{
    if (m_fIsTuning || m_pTerminal)
    {
        LOG((RTC_ERROR, "CRTCAudioTuner::InitializeTuning: not shutdown yet"));

        // return E_FAIL;
        ShutdownTuning();
    }

    _ASSERT(m_pTerminalPriv == NULL);
    _ASSERT(m_pAudioDuplexController == NULL);

    // keep terminal and terminal private pointer
    m_pTerminal = pTerminal;
    m_pTerminalPriv = static_cast<IRTCTerminalPriv*>(
        static_cast<CRTCTerminal*>(pTerminal));

    m_pTerminal->AddRef();
    m_pTerminal->AddRef();

    if (pAudioDuplexController)
    {
        m_pAudioDuplexController = pAudioDuplexController;
        m_pAudioDuplexController->AddRef();
    }

    m_fEnableAEC = fEnableAEC;

    return S_OK;
}

HRESULT
CRTCAudioTuner::ShutdownTuning()
{
    ENTER_FUNCTION("CRTCAudioTuner::ShutdownTuning");

    // do we have the terminal?
    if (!m_pTerminal)
    {
        LOG((RTC_WARN, "%s no terminal", __fxName));

        return S_OK;
    }

    HRESULT hr;

    // are we in tuning?
    if (m_fIsTuning)
    {
        // stop tuning but do not save setting
        if (FAILED(hr = StopTuning(FALSE, FALSE)))
        {
            LOG((RTC_ERROR, "%s stop tuning. %x", __fxName, hr));
        }

        _ASSERT(!m_fIsTuning);
    }

    // release pointer
    if (m_pTerminal)
    {
        _ASSERT(m_pTerminalPriv);

        m_pTerminal->Release();
        m_pTerminal = NULL;

        m_pTerminalPriv->Release();
        m_pTerminalPriv = NULL;
    }

    if (m_pAudioDuplexController)
    {
        m_pAudioDuplexController->Release();
        m_pAudioDuplexController = NULL;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    save audio setting to registry
////*/

HRESULT
CRTCAudioTuner::StoreVolSetting(
    IN IRTCTerminal *pTerminal,
    IN UINT uiVolume
    )
{
    ENTER_FUNCTION("CRTCAudioTuner::StoreVolSetting");

    HRESULT hr;

    // check input
    if (IsBadReadPtr(pTerminal, sizeof(IRTCTerminal)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    // QI configure interface
    // retrieve terminal type and direction
    RTC_MEDIA_DIRECTION md;

    // no need to check return value
    pTerminal->GetDirection(&md);

    // retrieve terminal discription
    WCHAR *wcsDesp = NULL;

    hr = pTerminal->GetDescription(&wcsDesp);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get description. %x", __fxName, hr));

        return hr;
    }

    // get audio setting
    CMediaReg objMain;

    hr = objMain.OpenKey(
        HKEY_CURRENT_USER,
        md==RTC_MD_CAPTURE?(MediaReg::pwsPathAudCapt):(MediaReg::pwsPathAudRend),
        MediaReg::CREATE
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s main key. %x", __fxName, hr));

        pTerminal->FreeDescription(wcsDesp);
        return hr;
    }

    CMediaReg objKey;

    hr = objKey.OpenKey(
        objMain,
        wcsDesp,
        MediaReg::CREATE
        );

    // free description
    pTerminal->FreeDescription(wcsDesp);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s device key. %x", __fxName, hr));

        return hr;
    }

    // write volume
    DWORD dwValue;

    hr = objKey.WriteDWORD(
        MediaReg::pwsDefaultVolume,
        (DWORD)uiVolume
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s write volume. %x", __fxName, hr));
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    retrieve audio setting from registry
////*/

HRESULT
CRTCAudioTuner::RetrieveVolSetting(
    IN IRTCTerminal *pTerminal,
    OUT UINT *puiVolume
    )
{
    ENTER_FUNCTION("CRTCAudioTuner::RetrieveVolSetting");

    HRESULT hr;

    // init setting
    *puiVolume = RTC_MAX_AUDIO_VOLUME / 2;

    // retrieve terminal type and direction
    RTC_MEDIA_DIRECTION md;

    // no need to check return value
    pTerminal->GetDirection(&md);

    // retrieve terminal discription
    WCHAR *wcsDesp = NULL;

    hr = pTerminal->GetDescription(&wcsDesp);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get description. %x", __fxName, hr));

        return hr;
    }

    // get audio setting
    CMediaReg objMain;

    hr = objMain.OpenKey(
        HKEY_CURRENT_USER,
        md==RTC_MD_CAPTURE?(MediaReg::pwsPathAudCapt):(MediaReg::pwsPathAudRend),
        MediaReg::CREATE
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s main key. %x", __fxName, hr));

        pTerminal->FreeDescription(wcsDesp);
        return hr;
    }

    CMediaReg objKey;

    hr = objKey.OpenKey(
        objMain,
        wcsDesp,
        MediaReg::CREATE
        );

    // free description
    pTerminal->FreeDescription(wcsDesp);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s device key. %x", __fxName, hr));

        return hr;
    }

    // read volume
    DWORD dwValue;

    hr = objKey.ReadDWORD(
        MediaReg::pwsDefaultVolume,
        &dwValue
        );

    if (FAILED(hr))
    {
        // create default
        hr = objKey.ReadDWORD(
            MediaReg::pwsDefaultVolume,
            RTC_MAX_AUDIO_VOLUME / 2,
            &dwValue
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s read volume. %x", __fxName, hr));

            return hr;
        }
    }

    *puiVolume = (UINT)dwValue;

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// AEC setting is stored in registry as
//      data: [1|2|3]   value: [0|1]: audio capt desp; audio rend desp
// This method constructs the value from capt and rend terminal description
//

HRESULT
CRTCAudioTuner::GetRegStringForAEC(
    IN IRTCTerminal *pAudCapt,     // capture
    IN IRTCTerminal *pAudRend,     // render
    IN WCHAR *pBuf,
    IN DWORD dwSize
    )
{
    ENTER_FUNCTION("CRTCAudioTuner::GetRegStringForAEC");

    _ASSERT(pAudCapt != NULL);
    _ASSERT(pAudRend != NULL);

    HRESULT hr;

    // retrieve terminal type and direction
    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;

    // no need to check return value
    pAudCapt->GetMediaType(&mt);
    pAudCapt->GetDirection(&md);

    if (mt != RTC_MT_AUDIO || md != RTC_MD_CAPTURE)
    {
        LOG((RTC_ERROR, "%s not audio capt", __fxName));

        return E_INVALIDARG;
    }

    pAudRend->GetMediaType(&mt);
    pAudRend->GetDirection(&md);

    if (mt != RTC_MT_AUDIO || md != RTC_MD_RENDER)
    {
        LOG((RTC_ERROR, "%s not audio rend", __fxName));

        return E_INVALIDARG;
    }

    // retrieve terminal discription
    WCHAR *wcsCapt = NULL;

    hr = pAudCapt->GetDescription(&wcsCapt);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get description. %x", __fxName, hr));

        return hr;
    }

    WCHAR *wcsRend = NULL;

    hr = pAudRend->GetDescription(&wcsRend);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get description. %x", __fxName, hr));

        pAudCapt->FreeDescription(wcsCapt);

        return hr;
    }

    // construct buf
    int i = (int)(dwSize/2);
    _snwprintf(pBuf, i, L"%ls", wcsCapt);
    pBuf[i-1] = L'\0';

    i = lstrlenW(pBuf);
    _snwprintf(pBuf+i, dwSize-(DWORD)i, L"; %ls", wcsRend);
    pBuf[dwSize-1] = L'\0';

    // free descriptions
    pAudCapt->FreeDescription(wcsCapt);
    pAudRend->FreeDescription(wcsRend);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// RetrieveAECSetting
//
// AEC is on only when the terminal-pair desp string appears in registry
//

#define MAX_AECREGSTRING_LEN   128     // the limit on win95 and 98
#define AEC_HISTORY_SIZE    4

HRESULT
CRTCAudioTuner::RetrieveAECSetting(
    IN IRTCTerminal *pAudCapt,     // capture
    IN IRTCTerminal *pAudRend,     // render
    OUT BOOL *pfEnableAEC,
    OUT DWORD *pfIndex,
    OUT BOOL *pfFound
    )
{
    ENTER_FUNCTION("CRTCAudioTuner::RetrieveAECSetting");

    *pfEnableAEC = FALSE;
    *pfIndex = 0;
    *pfFound = FALSE;

    if (pAudCapt == NULL || pAudRend == NULL)
    {
        // disable aec if one terminal is unavailable
        return S_OK;
    }

    // construct term-pair desp string
    WCHAR buf[MAX_AECREGSTRING_LEN];

    HRESULT hr = GetRegStringForAEC(pAudCapt, pAudRend, buf, MAX_AECREGSTRING_LEN);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get reg string. %x", __fxName, hr));

        return hr;
    }

    // open aec path
    CMediaReg objMain;

    hr = objMain.OpenKey(
        HKEY_CURRENT_USER,
        MediaReg::pwsPathAEC,
        MediaReg::CREATE
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s main key. %x", __fxName, hr));

        return hr;
    }

    // leave space for mark=[0|1] ':' space
    WCHAR data[MAX_AECREGSTRING_LEN+3];
    WCHAR name[20];

    //
    // query aec setting
    //
    for (int i=0; i<AEC_HISTORY_SIZE; i++)
    {
        _itow(i, name, 10);

        hr = objMain.ReadSZ(name, data, MAX_AECREGSTRING_LEN+3);

        if (FAILED(hr))
        {
            // this entry might be deleted, check next one
            continue;
        }

        if (lstrlenW(data) <= 3)
        {
            // invalid entry
            RegDeleteValueW(objMain.m_hKey, name);
            continue;
        }

        if (lstrcmpW(buf, data+3) == 0)
        {
            LOG((RTC_TRACE, "%s found %ls index=%d", __fxName, buf, i));

            if (data[0] == L'1')
            {
                *pfEnableAEC = TRUE;
            }
            else
            {
                *pfEnableAEC = FALSE;
            }
            *pfIndex = (DWORD)i;
            *pfFound = TRUE;
            break;
        }
    }

    // aec disabled
    return S_OK;
}
    

// store AEC settting
HRESULT
CRTCAudioTuner::StoreAECSetting(
    IN IRTCTerminal *pAudCapt,     // capture
    IN IRTCTerminal *pAudRend,     // render
    IN BOOL fEnableAEC
    )
{
    ENTER_FUNCTION("CRTCAudioTuner::StoreAECSetting");

    if (pAudCapt == NULL || pAudRend == NULL)
    {
        // disable aec if one terminal is unavailable
        return S_OK;
    }

    LOG((RTC_TRACE, "%s capt=0x%p rend=0x%p aec=%d",
        __fxName, pAudCapt, pAudRend, fEnableAEC));

    CMediaReg objMain;
    WCHAR name[20];

    // retrieve aec setting
    BOOL fCurrAEC;
    DWORD index;
    BOOL fFound; 

    HRESULT hr = RetrieveAECSetting(
            pAudCapt, pAudRend, &fCurrAEC, &index, &fFound);

    LOG((RTC_TRACE, "%s curr aec=%d found=%d hr=0x%x",
        __fxName, fCurrAEC, fFound, hr));

    if (FAILED(hr))
    {
        return hr;
    }

    if (fFound && index==0 && fEnableAEC==fCurrAEC)
    {
        //
        // no need to update
        //
        return S_OK;
    }

    // get main key
    hr = objMain.OpenKey(
        HKEY_CURRENT_USER, MediaReg::pwsPathAEC, MediaReg::CREATE);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s open aec path. %x", __fxName, hr));
        return hr;
    }

    int i;

    if (fFound)
    {
        // delete it and then recreate it
        // delete index
        _itow(index, name, 10);

        RegDeleteValueW(objMain.m_hKey, name);

        // start below where it is found, might be -1
        i = (int)index-1;
    }
    else
    {
        i = AEC_HISTORY_SIZE-2;
    }

    //
    // need to add aec entry
    //

    WCHAR data[MAX_AECREGSTRING_LEN+3];

    //
    // move cached aec setting to leave a room for the new one
    //

    for (; i>=0; i--)
    {
        _itow(i, name, 10);
        hr = objMain.ReadSZ(name, data, MAX_AECREGSTRING_LEN+3);

        if (FAILED(hr))
        {
            // this entry might not exist
            continue;
        }

        // write to next entry
        _itow(i+1, name, 10);
        objMain.WriteSZ(name, data, MAX_AECREGSTRING_LEN+3);
    }

    // write aec setting
    hr = GetRegStringForAEC(pAudCapt, pAudRend, data+3, MAX_AECREGSTRING_LEN);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get reg string. %x", __fxName, hr));

        return hr;
    }

    // write mark
    if (fEnableAEC)
    {
        data[0] = L'1';
    }
    else
    {
        data[0] = L'0';
    }

    data[1] = L':';
    data[2] = L' ';

    _itow(0, name, 10);
    objMain.WriteSZ(name, data, MAX_AECREGSTRING_LEN+3);

    // aec disabled
    return S_OK;
}

//
// CRTCAudioCaptTuner methods
//

CRTCAudioCaptTuner::CRTCAudioCaptTuner()
    :CRTCAudioTuner()
    ,m_pIGraphBuilder(NULL)
    ,m_pIMediaControl(NULL)
    ,m_pTermFilter(NULL)
    ,m_pNRFilter(NULL)
    ,m_pIAMAudioInputMixer(NULL)
    ,m_pISilenceControl(NULL)
    ,m_lMinAudioLevel(0)
    ,m_lMaxAudioLevel(0)
{
}

HRESULT
CRTCAudioCaptTuner::InitializeTuning(
    IN IRTCTerminal *pTerminal,
    IN IAudioDuplexController *pAudioDuplexController,
    IN BOOL fEnableAEC
    )
{
    // check media type and direction
    RTC_MEDIA_TYPE MediaType;
    RTC_MEDIA_DIRECTION Direction;

    pTerminal->GetMediaType(&MediaType);
    pTerminal->GetDirection(&Direction);

    if (MediaType != RTC_MT_AUDIO ||
        Direction != RTC_MD_CAPTURE)
        return E_UNEXPECTED;

    return CRTCAudioTuner::InitializeTuning(
        pTerminal, pAudioDuplexController, fEnableAEC
        );
}

/*//////////////////////////////////////////////////////////////////////////////
    construct a filter graph
    connect capture filter with a null render filter
    run the graph
////*/

HRESULT
CRTCAudioCaptTuner::StartTuning(
    IN BOOL fAECHelper
    )
{
    CLock lock(m_Lock);

    ENTER_FUNCTION("CRTCAudioCaptTuner::StartTuning");

    // no terminal set
    if (m_pTerminal == NULL)
    {
        return E_UNEXPECTED;
    }

    if (fAECHelper &&
        (m_pAudioDuplexController == NULL || !m_fEnableAEC))
    {
        // AEC not enabled, just return
        return S_OK;
    }

    HRESULT hr;

    CComPtr<IAudioDeviceConfig> pAudioDeviceConfig;

    BOOL fDefaultSetting = FALSE;
    UINT uiVolume;
    BOOL fEnableAEC;

    if (m_fIsTuning)
    {
        LOG((RTC_TRACE, "%s already in tuning", __fxName));

        _ASSERT(m_pIGraphBuilder != NULL);
        _ASSERT(m_pIMediaControl != NULL);
        _ASSERT(m_pTermFilter != NULL);
        _ASSERT(m_pNRFilter != NULL);
    }
    else
    {
        _ASSERT(m_pIGraphBuilder == NULL);
        _ASSERT(m_pIMediaControl == NULL);

        // create a graph
        hr = CoCreateInstance(
            CLSID_FilterGraph,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IGraphBuilder,
            (void**)&m_pIGraphBuilder
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s cocreate graph. %x", __fxName, hr));

            goto Error;
        }

        hr = m_pIGraphBuilder->QueryInterface(
            __uuidof(IMediaControl), (void**)&m_pIMediaControl
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI media control. %x", __fxName, hr));

            goto Error;
        }

        _ASSERT(m_pTerminalPriv);

        _ASSERT(m_pTermFilter == NULL);

        // get a recreated terminal filter
        hr = m_pTerminalPriv->ReinitializeEx();

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s ReinitializeEx terminal", __fxName, hr));

            goto Error;
        }

        hr = m_pTerminalPriv->GetFilter(&m_pTermFilter);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s get terminal filter", __fxName, hr));

            goto Error;
        }

        // set audio duplex controller?
        if (m_pAudioDuplexController)
        {
            hr = m_pTermFilter->QueryInterface(&pAudioDeviceConfig);

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s QI audio device config. %x", __fxName, hr));

                goto Error;
            }

            // set AEC
            hr = pAudioDeviceConfig->SetDuplexController(m_pAudioDuplexController);

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s set duplex controller. %x", __fxName, hr));

                goto Error;
            }
        }

        _ASSERT(m_pNRFilter == NULL);

        // create null render filter
        hr = CNRFilter::CreateInstance(&m_pNRFilter);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s create null rend filter. %x", __fxName, hr));

            goto Error;
        }

        // put filters into the graph
        hr = m_pIGraphBuilder->AddFilter(m_pTermFilter, L"AudCapt");

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s add audio capt filter. %x", __fxName, hr));

            hr = RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE;

            goto Error;
        }

        hr = m_pIGraphBuilder->AddFilter(m_pNRFilter, L"NullRend");

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s add null rend filter. %x", __fxName, hr));

            m_pIGraphBuilder->RemoveFilter(m_pTermFilter);
            goto Error;
        }

        // connect filters
        hr = ::ConnectFilters(m_pIGraphBuilder, m_pTermFilter, m_pNRFilter);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s connect filters. %x", __fxName, hr));

            m_pIGraphBuilder->RemoveFilter(m_pTermFilter);
            m_pIGraphBuilder->RemoveFilter(m_pNRFilter);

            goto Error;
        }

        // enable AEC
        if (m_pAudioDuplexController!=NULL && m_fEnableAEC)
        {
            if (FAILED(hr = ::EnableAEC(m_pAudioDuplexController)))
            {
                LOG((RTC_ERROR, "%s enable AEC. %x", __fxName, hr));
            }
        }

        if (fAECHelper)
        {
            // we configure the graph just for enabling AEC
            m_fIsTuning = TRUE;

            return S_OK;
        }
    }
        
    // get default volume
    hr = RetrieveVolSetting(m_pTerminal, &uiVolume);

    if (hr == S_OK)
    {
        fDefaultSetting = TRUE;
    }

    // start the graph
    hr = m_pIMediaControl->Run();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to start the graph. %x", __fxName, hr));

        m_pIGraphBuilder->RemoveFilter(m_pTermFilter);
        m_pIGraphBuilder->RemoveFilter(m_pNRFilter);

        goto Error;
    }

    // check if AEC is still on
    if (FAILED(hr = m_pAudioDuplexController->GetEffect(EFFECTS_AEC, &fEnableAEC)))
    {
        LOG((RTC_ERROR, "%s GetEffect. %x", __fxName, hr));

        m_pIMediaControl->Stop();

        hr = RTC_E_MEDIA_AEC;

        goto Error;
    }

    if (m_fEnableAEC && !fEnableAEC)
    {
        // AEC failed internally
        m_pIMediaControl->Stop();

        LOG((RTC_ERROR, "AEC failed internally", __fxName, hr));

        hr = RTC_E_MEDIA_AEC;

        goto Error;
    }

    m_fIsTuning = TRUE;

    // set default volume
    if (fDefaultSetting)
    {
        SetVolume(uiVolume);
    }

    return S_OK;

Error:

    // cleanup filters and graph
    if (m_pTermFilter)
    {
        m_pTermFilter->Release();
        m_pTermFilter = NULL;
    }

    if (m_pNRFilter)
    {
        m_pNRFilter->Release();
        m_pNRFilter = NULL;
    }

    if (m_pIGraphBuilder)
    {
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;
    }

    if (m_pIMediaControl)
    {
        m_pIMediaControl->Release();
        m_pIMediaControl = NULL;
    }

    // clean up internal data cached in the filter of the terminal
    m_pTerminalPriv->ReinitializeEx();

    return hr;
}

HRESULT
CRTCAudioCaptTuner::StopTuning(
    IN BOOL fAECHelper,
    IN BOOL fSaveSetting
    )
{
    CLock lock(m_Lock);

    ENTER_FUNCTION("CRTCAudioCaptTuner::StopTuning");

    if (!m_fIsTuning)
    {
        LOG((RTC_TRACE, "%s not in tuning", __fxName));

        return S_OK;
    }

    // no terminal set
    if (m_pTerminal == NULL)
    {
        return E_UNEXPECTED;
    }

    // we should have these interfaces
    _ASSERT(m_pTermFilter);
    _ASSERT(m_pNRFilter);
    _ASSERT(m_pIGraphBuilder);
    _ASSERT(m_pIMediaControl);

    // retrieve setting
    HRESULT hr;
    UINT volume = 0;

    if (!fAECHelper && fSaveSetting)
    {
        hr = GetVolume(&volume);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            volume = (RTC_MAX_AUDIO_VOLUME+RTC_MIN_AUDIO_VOLUME) / 2;
        }

        // save setting
        hr = StoreVolSetting(
            m_pTerminal,
            volume
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s set reg setting. %x", __fxName, hr));

            hr = S_FALSE;
        }
    }

    // stop the graph
    if (!fAECHelper)
        m_pIMediaControl->Stop();

    // remove filters from the graph
    m_pIGraphBuilder->RemoveFilter(m_pTermFilter);
    m_pIGraphBuilder->RemoveFilter(m_pNRFilter);

    // release filters and the graph
    m_pTermFilter->Release();
    m_pTermFilter = NULL;

    m_pNRFilter->Release();
    m_pNRFilter = NULL;

    m_pIGraphBuilder->Release();
    m_pIGraphBuilder = NULL;

    m_pIMediaControl->Release();
    m_pIMediaControl = NULL;

    if (m_pIAMAudioInputMixer)
    {
        m_pIAMAudioInputMixer->Release();
        m_pIAMAudioInputMixer = NULL;
    }

    if (m_pISilenceControl)
    {
        m_pISilenceControl->Release();
        m_pISilenceControl = NULL;
    }

    // clean up the terminal
    m_pTerminalPriv->ReinitializeEx();

    m_fIsTuning = FALSE;

    return S_OK;
}

HRESULT
CRTCAudioCaptTuner::GetVolume(
    OUT UINT *puiVolume
    )
{
    ENTER_FUNCTION("CRTCAudioCaptTuner::GetVolume");

    HRESULT hr;

    if (!m_fIsTuning)
    {
        if (m_pTerminal == NULL)
        {
            LOG((RTC_ERROR, "%s not in tuning", __fxName));

            return E_UNEXPECTED;
        }

        // tuning not start, but terminal set
        // so we can return the value stored in registry

        hr = RetrieveVolSetting(m_pTerminal, puiVolume);

        return S_OK;
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        // get mixer
        hr = m_pTermFilter->QueryInterface(
            __uuidof(IAMAudioInputMixer),
            (void**)&m_pIAMAudioInputMixer
            );
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI mixer. %x", __fxName, hr));

            return hr;
        }
    }

    // get volume
    double dVolume;

    //UINT uiWaveID;

    //dynamic_cast<CRTCTerminalAudCapt*>(m_pTerminalPriv)->GetWaveID(&uiWaveID);

    //if (FAILED(hr = ::DirectGetCaptVolume(uiWaveID, &dVolume)))
    if (FAILED(hr = m_pIAMAudioInputMixer->get_MixLevel(&dVolume)))
    {
        LOG((RTC_ERROR, "%s get mix level. %x", __fxName, hr));

        return hr;
    }

    _ASSERT(dVolume >= MIXER_MIN_VOLUME);
    _ASSERT(dVolume <= MIXER_MAX_VOLUME);

    if (dVolume < MIXER_MIN_VOLUME ||
        dVolume > MIXER_MAX_VOLUME)
    {
        LOG((RTC_ERROR, "%s volume out of range.", __fxName));

        if (dVolume < MIXER_MIN_VOLUME)
            dVolume = MIXER_MIN_VOLUME;
        else
            dVolume = MIXER_MAX_VOLUME;
    }

    // Convert the volume from whatever range of doubles the filter uses
    // to the range 0 - 1.

    _ASSERT(MIXER_MIN_VOLUME == 0 && MIXER_MAX_VOLUME == 1);

    // dVolume = (double)(dVolume - MIXER_MIN_VOLUME) /
    //          (MIXER_MAX_VOLUME - MIXER_MIN_VOLUME);

    // Convert the volume from the range 0 - 1 to the API's range.
    dVolume = RTC_MIN_AUDIO_VOLUME +
          ((RTC_MAX_AUDIO_VOLUME-RTC_MIN_AUDIO_VOLUME) * dVolume);

    UINT uiVolume = (UINT)dVolume;

    if (dVolume-(double)(uiVolume) > 0.5)
        uiVolume ++;

    if (uiVolume > RTC_MAX_AUDIO_VOLUME)
    {
        *puiVolume = RTC_MAX_AUDIO_VOLUME;
    }
    else
    {
        *puiVolume = uiVolume;
    }

    return S_OK;
}

HRESULT
CRTCAudioCaptTuner::SetVolume(
    IN UINT uiVolume
    )
{
    ENTER_FUNCTION("CRTCAudioCaptTuner::SetVolume");

    HRESULT hr;

    if ((INT)uiVolume < RTC_MIN_AUDIO_VOLUME ||
        (INT)uiVolume > RTC_MAX_AUDIO_VOLUME)
    {
        LOG((RTC_ERROR, "%s volume (%d) out of range (%d, %d)",
            __fxName, uiVolume, RTC_MIN_AUDIO_VOLUME, RTC_MAX_AUDIO_VOLUME));

        return E_INVALIDARG;
    }

    if (!m_fIsTuning)
    {
        if (m_pTerminal == NULL)
        {
            LOG((RTC_ERROR, "%s not in tuning", __fxName));

            return E_UNEXPECTED;
        }

        // tuning not start, but terminal set
        // so we save the value in registry

        hr = StoreVolSetting(
            m_pTerminal,
            uiVolume
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s set reg setting. %x", __fxName, hr));
        }

        return hr;
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        // get mixer
        hr = m_pTermFilter->QueryInterface(
            __uuidof(IAMAudioInputMixer),
            (void**)&m_pIAMAudioInputMixer
            );
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI mixer. %x", __fxName, hr));

            return hr;
        }
    }

    // set volume
    double dVolume;

    // convert input vol in 0-1 range
    dVolume = (double)(uiVolume - RTC_MIN_AUDIO_VOLUME) /
              (RTC_MAX_AUDIO_VOLUME - RTC_MIN_AUDIO_VOLUME);

    // convert into mixer range
    dVolume = MIXER_MIN_VOLUME +
             (MIXER_MAX_VOLUME-MIXER_MIN_VOLUME) *dVolume;

    //UINT uiWaveID;

    //dynamic_cast<CRTCTerminalAudCapt*>(m_pTerminalPriv)->GetWaveID(&uiWaveID);

    //if (FAILED(hr = ::DirectSetCaptVolume(uiWaveID, dVolume)))
    if (FAILED(hr = m_pIAMAudioInputMixer->put_MixLevel(dVolume)))
    {
        LOG((RTC_ERROR, "%s put mix level %f", __fxName, dVolume));

        return hr;
    }

    return S_OK;
}

HRESULT
CRTCAudioCaptTuner::GetAudioLevel(
    OUT UINT *puiLevel
    )
{
    ENTER_FUNCTION("CRTCAudioCaptTuner::GetAudioLevel");

    CLock lock(m_Lock);

    if (!m_fIsTuning)
    {
        LOG((RTC_ERROR, "%s not in tuning", __fxName));

        return E_UNEXPECTED;
    }

    HRESULT hr;

    if (m_pISilenceControl == NULL)
    {
        // get output pin on terminal filter
        CComPtr<IEnumPins> pEnum;

        if (FAILED(hr = m_pTermFilter->EnumPins(&pEnum)))
        {
            LOG((RTC_ERROR, "%s enum pins. %x", __fxName, hr));

            return hr;
        }

        // our own terminal, skip checking pin direction
        CComPtr<IPin> pPin;
        DWORD dwNum = 0;

        hr = pEnum->Next(1, &pPin, &dwNum);

        if (FAILED(hr) || dwNum == 0)
        {
            LOG((RTC_ERROR, "%s get pin. hr=%x, pin#=%d", __fxName, hr, dwNum));

            if (hr == S_FALSE) hr = E_FAIL;

            return hr;
        }

        // get silence control
        hr = pPin->QueryInterface(__uuidof(ISilenceControl), (void**)&m_pISilenceControl);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s silence control. %x", __fxName, hr));

            return hr;
        }

        // get audio level range
        LONG lDelta;

        hr = m_pISilenceControl->GetAudioLevelRange(
            &m_lMinAudioLevel,
            &m_lMaxAudioLevel,
            &lDelta
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s get audio level range. %x", __fxName, hr));

            m_pISilenceControl->Release();
            m_pISilenceControl = NULL;

            return hr;
        }

        if (m_lMinAudioLevel >= m_lMaxAudioLevel)
        {
            LOG((RTC_ERROR, "%s audio range wrong. %x", __fxName, hr));

            m_pISilenceControl->Release();
            m_pISilenceControl = NULL;

            return E_FAIL;
        }
    }

    // get audio level
    LONG lAudioLevel;

    if (FAILED(hr = m_pISilenceControl->GetAudioLevel(&lAudioLevel)))
    {
        LOG((RTC_ERROR, "%s get audio level. %x", __fxName, hr));

        return hr;
    }

    // convert audio level to 0-1
    double d;

    d = (double)(lAudioLevel-m_lMinAudioLevel) / (m_lMaxAudioLevel-m_lMinAudioLevel);

    // convert to our range
    *puiLevel = RTC_MIN_AUDIO_LEVEL +
                (UINT)(d * (RTC_MAX_AUDIO_LEVEL-RTC_MIN_AUDIO_LEVEL));

    // LOG((RTC_TRACE, "AudioLevel@@@ %d", *puiLevel));

    return S_OK;
}

//
// CRTCAudioRendTuner methods
//

CRTCAudioRendTuner::CRTCAudioRendTuner()
    :CRTCAudioTuner()
    ,m_pIAudioAutoPlay(NULL)
    ,m_pIBasicAudio(NULL)
{
}

HRESULT
CRTCAudioRendTuner::InitializeTuning(
    IN IRTCTerminal *pTerminal,
    IN IAudioDuplexController *pAudioDuplexController,
    IN BOOL fEnableAEC
    )
{
    // check media type and direction
    RTC_MEDIA_TYPE MediaType;
    RTC_MEDIA_DIRECTION Direction;

    pTerminal->GetMediaType(&MediaType);
    pTerminal->GetDirection(&Direction);

    if (MediaType != RTC_MT_AUDIO ||
        Direction != RTC_MD_RENDER)
        return E_UNEXPECTED;

    return CRTCAudioTuner::InitializeTuning(
        pTerminal, pAudioDuplexController, fEnableAEC
        );
}

/*//////////////////////////////////////////////////////////////////////////////
    put the render filter in a special mode, run the filter
////*/

HRESULT
CRTCAudioRendTuner::StartTuning(
    IN BOOL fAECHelper
    )
{
    ENTER_FUNCTION("CRTCAudioRendTuner::StartTuning");

    // check state
    if (m_fIsTuning)
    {
        LOG((RTC_TRACE, "%s already in tuning", __fxName));

        return S_OK;
    }

    // no terminal set
    if (m_pTerminal == NULL)
    {
        return E_UNEXPECTED;
    }

    if (fAECHelper &&
        (m_pAudioDuplexController == NULL || !m_fEnableAEC))
    {
        // AEC not enabled, just return
        return S_OK;
    }

    _ASSERT(m_pIAudioAutoPlay == NULL);
    _ASSERT(m_pIBasicAudio == NULL);

    HRESULT hr;
    CComPtr<IBaseFilter> pFilter;
    CComPtr<IAudioDeviceConfig> pAudioDeviceConfig;

    BOOL fDefaultSetting = FALSE;
    UINT uiVolume;
    BOOL fEnableAEC;

    // get a recreated terminal filter
    hr = m_pTerminalPriv->ReinitializeEx();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s ReinitializeEx terminal. %x", __fxName, hr));

        goto Error;
    }

    hr = m_pTerminalPriv->GetFilter(&pFilter);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get terminal filter. %x", __fxName, hr));

        goto Error;
    }

    // set audio duplex controller?
    if (m_pAudioDuplexController)
    {
        hr = pFilter->QueryInterface(&pAudioDeviceConfig);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI audio device config. %x", __fxName, hr));

            goto Error;
        }

        // set AEC
        hr = pAudioDeviceConfig->SetDuplexController(m_pAudioDuplexController);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s set duplex controller. %x", __fxName, hr));

            goto Error;
        }
    }

    // get audio tuning interface
    if (FAILED(hr = pFilter->QueryInterface(&m_pIAudioAutoPlay)))
    {
        LOG((RTC_ERROR, "%s QI audio tuning. %x", __fxName, hr));

        goto Error;
    }

    // get default volume
    hr = RetrieveVolSetting(m_pTerminal, &uiVolume);

    if (hr == S_OK)
    {
        fDefaultSetting = TRUE;
    }

    // enable AEC
    if (m_pAudioDuplexController!=NULL && m_fEnableAEC)
    {
        if (FAILED(hr = ::EnableAEC(m_pAudioDuplexController)))
        {
            LOG((RTC_ERROR, "%s enable AEC. %x", __fxName, hr));
        }
    }

    if (FAILED(hr = m_pIAudioAutoPlay->StartAutoPlay(fAECHelper?FALSE:TRUE)))
    {
        LOG((RTC_ERROR, "%s starttuning. %x", __fxName, hr));

        goto Error;
    }

    // check if AEC is still on
    if (FAILED(hr = m_pAudioDuplexController->GetEffect(EFFECTS_AEC, &fEnableAEC)))
    {
        LOG((RTC_ERROR, "%s GetEffect. %x", __fxName, hr));

        m_pIAudioAutoPlay->StopAutoPlay();

        hr = RTC_E_MEDIA_AEC;

        goto Error;
    }

    if (m_fEnableAEC && !fEnableAEC)
    {
        // AEC failed internally
        m_pIAudioAutoPlay->StopAutoPlay();

        LOG((RTC_ERROR, "AEC failed internally", __fxName, hr));

        hr = RTC_E_MEDIA_AEC;

        goto Error;
    }

    m_fIsTuning = TRUE;

    if (fDefaultSetting)
    {
        SetVolume(uiVolume);
    }

    return S_OK;

Error:

    if (m_pIAudioAutoPlay)
    {
        m_pIAudioAutoPlay->Release();
        m_pIAudioAutoPlay = NULL;
    }

    m_pTerminalPriv->ReinitializeEx();

    return hr;
}

HRESULT
CRTCAudioRendTuner::StopTuning(
    IN BOOL fAECHelper,
    IN BOOL fSaveSetting
    )
{
    ENTER_FUNCTION("CRTCAudioRendTuner::StopTuning");

    HRESULT hr;
    UINT volume = 0;

    // check state
    if (!m_fIsTuning)
    {
        LOG((RTC_TRACE, "%s not in tuning", __fxName));

        return S_OK;
    }

    // no terminal set
    if (m_pTerminal == NULL)
    {
        return E_UNEXPECTED;
    }

    _ASSERT(m_pIAudioAutoPlay);

    // retrieve setting
    if (!fAECHelper && fSaveSetting)
    {
        if (FAILED(hr = GetVolume(&volume)))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            volume = (RTC_MAX_AUDIO_VOLUME+RTC_MIN_AUDIO_VOLUME) / 2;
        }

        // save setting
        hr = StoreVolSetting(
            m_pTerminal,
            volume
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s save reg setting. %x", __fxName, hr));

            hr = S_FALSE;
        }
    }

    // stop tuning
    // if (!fAECHelper)
    {
        m_pIAudioAutoPlay->StopAutoPlay();
    }

    // release interfaces
    if (m_pIBasicAudio)
    {
        m_pIBasicAudio->Release();
        m_pIBasicAudio = NULL;
    }

    m_pIAudioAutoPlay->Release();
    m_pIAudioAutoPlay = NULL;

    // cleanup the terminal
    m_pTerminalPriv->ReinitializeEx();

    m_fIsTuning = FALSE;

    return S_OK;
}

HRESULT
CRTCAudioRendTuner::GetVolume(
    OUT UINT *puiVolume
    )
{
    ENTER_FUNCTION("CRTCAudioRendTuner::GetVolume");

    HRESULT hr;

    if (!m_fIsTuning)
    {
        if (m_pTerminal == NULL)
        {
            LOG((RTC_ERROR, "%s not in tuning", __fxName));

            return E_UNEXPECTED;
        }

        // tuning not start, but terminal set
        // so we can return the value stored in registry

        hr = RetrieveVolSetting(m_pTerminal, puiVolume);

        return S_OK;
    }

    if (m_pIBasicAudio == NULL)
    {
        // get basic audio
        hr = m_pIAudioAutoPlay->QueryInterface(
                __uuidof(IBasicAudio),
                (void**)&m_pIBasicAudio
                );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI basic audio. %x", __fxName, hr));

            return hr;
        }
    }

    // get volume
    LONG lVolume;

    if (FAILED(hr = m_pIBasicAudio->get_Volume(&lVolume)))
    {
        LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

        return hr;
    }

    // validate the value
    if (lVolume > RTC_MAX_AUDIO_VOLUME ||
        lVolume < RTC_MIN_AUDIO_VOLUME)
    {
        // implementation of audio filter must have been changed
        LOG((RTC_ERROR, "%s volume %d out of range (%d, %d)",
             __fxName, lVolume, RTC_MIN_AUDIO_VOLUME, RTC_MAX_AUDIO_VOLUME));

        // should recover from this failure
        if (lVolume > RTC_MAX_AUDIO_VOLUME)
            lVolume = RTC_MAX_AUDIO_VOLUME;
        else
            lVolume = RTC_MIN_AUDIO_VOLUME;
    }

    *puiVolume = (UINT)lVolume;

    return S_OK;
}

HRESULT
CRTCAudioRendTuner::SetVolume(
    IN UINT uiVolume
    )
{
    ENTER_FUNCTION("CRTCAudioRendTuner::SetVolume");

    HRESULT hr;

    // check input
    if ((INT)uiVolume > RTC_MAX_AUDIO_VOLUME ||
        (INT)uiVolume < RTC_MIN_AUDIO_VOLUME)
    {
        LOG((RTC_ERROR, "%s volume (%d) out of range (%d, %d)",
            __fxName, uiVolume, RTC_MIN_AUDIO_VOLUME, RTC_MAX_AUDIO_VOLUME));

        return E_INVALIDARG;
    }

    // check state
    if (!m_fIsTuning)
    {
        if (m_pTerminal == NULL)
        {
            LOG((RTC_ERROR, "%s not in tuning", __fxName));

            return E_UNEXPECTED;
        }

        // tuning not start, but terminal set
        // so we save the value in registry

        hr = StoreVolSetting(
            m_pTerminal,
            uiVolume
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s set reg setting. %x", __fxName, hr));
        }

        return hr;
    }

    if (m_pIBasicAudio == NULL)
    {
        // get basic audio
        hr = m_pIAudioAutoPlay->QueryInterface(
                __uuidof(IBasicAudio),
                (void**)&m_pIBasicAudio
                );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI basic audio. %x", __fxName, hr));

            return hr;
        }
    }

    // set volume
    if (FAILED(hr = m_pIBasicAudio->put_Volume((LONG)uiVolume)))
    {
        LOG((RTC_ERROR, "%s put mix level %d", __fxName, uiVolume));

        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\audiotuner.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    AudioTuner.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 24-Aug-2000

--*/

#ifndef _AUDIOTUNER_H
#define _AUDIOTUNER_H

/*//////////////////////////////////////////////////////////////////////////////
    class CRTCAudioTuner
////*/

class CRTCAudioTuner
{
public:

    CRTCAudioTuner();
    ~CRTCAudioTuner();

    HRESULT InitializeTuning(
        IN IRTCTerminal *pTerminal,
        IN IAudioDuplexController *pAudioDuplexController,
        IN BOOL fEnableAEC
        );

    HRESULT ShutdownTuning();

    virtual HRESULT StartTuning(
        IN BOOL fAECHelper
        ) = 0;

    virtual HRESULT StopTuning(
        IN BOOL fAECHelper,
        IN BOOL fSaveSetting
        ) = 0;

    virtual HRESULT GetVolume(
        OUT UINT *puiVolume
        ) = 0;

    virtual HRESULT SetVolume(
        IN UINT uiVolume
        ) = 0;

    virtual HRESULT GetAudioLevel(
        OUT UINT *puiLevel
        ) = 0;

    static HRESULT RetrieveVolSetting(
        IN IRTCTerminal *pTerminal,
        OUT UINT *puiVolume
        );

    static HRESULT StoreVolSetting(
        IN IRTCTerminal *pTerminal,
        IN UINT uiVolume
        );

    BOOL IsTuning() const { return m_fIsTuning; }

    BOOL HasTerminal() const { return (m_pTerminal != NULL); }

    static HRESULT RetrieveAECSetting(
        IN IRTCTerminal *pAudCapt,     // capture
        IN IRTCTerminal *pAudRend,     // render
        OUT BOOL *pfEnableAEC,
        OUT DWORD *pfIndex,
        OUT BOOL *pfFound
        );

    static HRESULT StoreAECSetting(
        IN IRTCTerminal *pAudCapt,     // capture
        IN IRTCTerminal *pAudRend,     // render
        IN BOOL fEnableAEC
        );

    static HRESULT GetRegStringForAEC(
        IN IRTCTerminal *pAudCapt,     // capture
        IN IRTCTerminal *pAudRend,     // render
        IN WCHAR *pBuf,
        IN DWORD dwSize
        );

    IRTCTerminal *GetTerminal()
    {
        if (m_pTerminal != NULL)
        {
            m_pTerminal->AddRef();
        }

        return m_pTerminal;
    }

    // get current aec flag
    BOOL GetAEC() const { return m_fEnableAEC; }

protected:

    IRTCTerminal            *m_pTerminal;
    IRTCTerminalPriv        *m_pTerminalPriv;

    IAudioDuplexController  *m_pAudioDuplexController;

    BOOL                    m_fIsTuning;
    BOOL                    m_fEnableAEC;
};


/*//////////////////////////////////////////////////////////////////////////////
    class CRTCAudioCaptTuner
////*/

class CRTCAudioCaptTuner :
    public CRTCAudioTuner
{
public:

    CRTCAudioCaptTuner();

    HRESULT InitializeTuning(
        IN IRTCTerminal *pTerminal,
        IN IAudioDuplexController *pAudioDuplexController,
        IN BOOL fEnableAEC
        );

    HRESULT StartTuning(
        IN BOOL fAECHelper
        );

    HRESULT StopTuning(
        IN BOOL fAECHelper,
        IN BOOL fSaveSetting
        );

    HRESULT GetVolume(
        OUT UINT *puiVolume
        );

    HRESULT SetVolume(
        IN UINT uiVolume
        );

    HRESULT GetAudioLevel(
        OUT UINT *puiLevel
        );

protected:

    // lock: GetAudioLevel will be called in a separate thread
    CRTCCritSection         m_Lock;

    // graph object
    IGraphBuilder           *m_pIGraphBuilder;
    IMediaControl           *m_pIMediaControl;

    // filters
    IBaseFilter             *m_pTermFilter;
    IBaseFilter             *m_pNRFilter; // null rend

    // mixer: volume
    IAMAudioInputMixer      *m_pIAMAudioInputMixer;

    // silence control: signal level
    ISilenceControl         *m_pISilenceControl;
    LONG                    m_lMinAudioLevel;
    LONG                    m_lMaxAudioLevel;
};


/*//////////////////////////////////////////////////////////////////////////////
    class CRTCAudioRendTuner
////*/

class CRTCAudioRendTuner :
    public CRTCAudioTuner
{
public:

    CRTCAudioRendTuner();

    HRESULT InitializeTuning(
        IN IRTCTerminal *pTerminal,
        IN IAudioDuplexController *pAudioDuplexController,
        IN BOOL fEnableAEC
        );

    HRESULT StartTuning(
        IN BOOL fAECHelper
        );

    HRESULT StopTuning(
        IN BOOL fAECHelper,
        IN BOOL fSaveSetting
        );

    HRESULT GetVolume(
        OUT UINT *puiVolume
        );

    HRESULT SetVolume(
        IN UINT uiVolume
        );

    HRESULT GetAudioLevel(
        OUT UINT *puiLevel
        )
    {
        return E_NOTIMPL;
    }

protected:

    // audio tuning on filter
    IAudioAutoPlay          *m_pIAudioAutoPlay;

    // basic audio: volume
    IBasicAudio             *m_pIBasicAudio;
};

#endif // _AUDIOTUNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\codec.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    CRTCCodec.cpp

Abstract:

    Wrap class of audio, video codec

Author(s):

    Qianbo Huai (qhuai) 21-Feb-2001

--*/

#include "stdafx.h"

// total bandwidth required when there is no video/video stream
#define SIREN_20MS_TOTALBW_NOVIDEO  32000   // 32k
#define SIREN_20MS_TOTALBW_VIDEO    117000  // 32k + 85k

#define SIREN_40MS_TOTALBW_NOVIDEO  24000   // 24k
#define SIREN_40MS_TOTALBW_VIDEO    74000   // 24k + 50k

#define G723_30MS_TOTALBW_NOVIDEO   18000   // 18k
#define G723_30MS_TOTALBW_VIDEO     63000   // 18k + 45k

#define G723_60MS_TOTALBW_NOVIDEO   12000   // 12k
#define G723_60MS_TOTALBW_VIDEO     52000   // 12k + 40k

#define G723_90MS_TOTALBW_NOVIDEO   0       // 0k
#define G723_90MS_TOTALBW_VIDEO     0       // 0k

#define G7221_TOTALBW_NOVIDEO       40000   // 40k
#define G7221_TOTALBW_VIDEO         130000  // 40k + 90k

#define DVI4_16_TOTALBW_NOVIDEO     80000   // 80k
#define DVI4_16_TOTALBW_VIDEO       180000  // 80k + 100k

#define DVI4_8_TOTALBW_NOVIDEO      48000   // 48k
#define DVI4_8_TOTALBW_VIDEO        143000  // 48k + 95k

#define PCMU_TOTALBW_NOVIDEO        80000   // 80k
#define PCMU_TOTALBW_VIDEO          180000  // 80k + 100k

#define PCMA_TOTALBW_NOVIDEO        80000   // 80k
#define PCMA_TOTALBW_VIDEO          180000  // 80k + 100k

#define GSM_TOTALBW_NOVIDEO         0       // 0k
#define GSM_TOTALBW_VIDEO           0       // 0k

// when switching from lower bps codec X to higher bps codec Y
// bandwidth required for higher bps codec Y is the sum of its required bw plus the delta
// the purpose of the delta is to reduce the frequency of codec switching when the estimated
// bandwidth oscillates around the limit.
#define BWDELTA_FOR_CODEC_SWITCH    8000    // 8k

#define MAX_BWDELTA                 100000  // 100k

const CRTCCodec::CODEC_ITEM CRTCCodec::CODEC_ITEM_LIST[] =
{
    // media type,  code,   format tag,             rank,   samplerate, code name,  qos name            bandwidth no video      bandwidth has video
    { RTC_MT_AUDIO, SIREN,  WAVE_FORMAT_SIREN,      10,     16000,      L"SIREN",   RTPQOSNAME_SIREN,   SIREN_40MS_TOTALBW_NOVIDEO,  SIREN_40MS_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, G7221,  WAVE_FORMAT_G722_1,     20,     16000,      L"G7221",   RTPQOSNAME_G722_1,  G7221_TOTALBW_NOVIDEO,  G7221_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, DVI4_16,WAVE_FORMAT_DVI_ADPCM,  30,     16000,      L"DVI4",    RTPQOSNAME_DVI4_16, DVI4_16_TOTALBW_NOVIDEO,DVI4_16_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, PCMU,   WAVE_FORMAT_MULAW,      40,     8000,       L"PCMU",    RTPQOSNAME_G711,    PCMU_TOTALBW_NOVIDEO,   PCMU_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, PCMA,   WAVE_FORMAT_ALAW,       50,     8000,       L"PCMA",    RTPQOSNAME_G711,    PCMA_TOTALBW_NOVIDEO,   PCMA_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, G723,   WAVE_FORMAT_MSG723,     60,     8000,       L"G723",    RTPQOSNAME_G723_1,  G723_90MS_TOTALBW_NOVIDEO,   G723_90MS_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, DVI4_8, WAVE_FORMAT_DVI_ADPCM,  70,     8000,       L"DVI4",    RTPQOSNAME_DVI4_8,  DVI4_8_TOTALBW_NOVIDEO, DVI4_8_TOTALBW_VIDEO},
    { RTC_MT_AUDIO, GSM,    WAVE_FORMAT_GSM610,     80,     8000,       L"GSM",     RTPQOSNAME_GSM6_10, GSM_TOTALBW_NOVIDEO,    GSM_TOTALBW_VIDEO},

    { RTC_MT_VIDEO, H263,   WAVE_FORMAT_UNKNOWN,    10,     90000,      L"H263",    RTPQOSNAME_H263QCIF,0,                      0},
    { RTC_MT_VIDEO, H261,   WAVE_FORMAT_UNKNOWN,    20,     90000,      L"H261",    RTPQOSNAME_H261QCIF,0,                      0}

};

const DWORD CRTCCodec::CODEC_ITEM_NUM = sizeof(CRTCCodec::CODEC_ITEM_LIST) / sizeof(CRTCCodec::CODEC_ITEM);

// return the index of codec item list based on rtp code
int CRTCCodec::IndexFromCode(DWORD dwCode)
{
    for (int i=0; i<CODEC_ITEM_NUM; i++)
    {
        if (dwCode == CODEC_ITEM_LIST[i].dwCode)
            return i;
    }

    return -1;
}

// return the index of codec item list based on format tag
int CRTCCodec::IndexFromFormatTag(WORD wFormatTag)
{
    for (int i=0; i<CODEC_ITEM_NUM; i++)
    {
        if (wFormatTag == CODEC_ITEM_LIST[i].wFormatTag)
            return i;
    }

    return -1;
}

// ctor from code and am media type
CRTCCodec::CRTCCodec(DWORD dwCode, const AM_MEDIA_TYPE *pmt)
{
    ZeroMemory(this, sizeof(CRTCCodec));

    m_dwBitrate = (DWORD)-1;

    if (!IsValid(dwCode, pmt))
    {
        LOG((RTC_ERROR, "ctor. input not valid %d", dwCode));

        return;
    }

    // set code
    m_dwCode = dwCode;
    m_bCodeSet = TRUE;

    // set media type
    if (!SetAMMediaType(pmt))
    {
        LOG((RTC_ERROR, "ctor, set media type"));

        // throw exception?
    }

    // compute bitrate
    m_dwBitrate = GetBitrate(pmt);

    // compute rank and required bandwidth
    int i = IndexFromCode(dwCode);

    if (i < 0)
    {
        LOG((RTC_ERROR, "GetRank code %d not found.", dwCode));

        m_dwRank = (DWORD)-1;
        m_dwTotalBWReqNoVid = (DWORD)-1;
        m_dwTotalBWReqVid = (DWORD)-1;
    }
    else
    {
        m_dwRank = CODEC_ITEM_LIST[i].dwRank;
        m_dwTotalBWReqNoVid = CODEC_ITEM_LIST[i].dwTotalBWReqNoVid;
        m_dwTotalBWReqVid = CODEC_ITEM_LIST[i].dwTotalBWReqVid;
    }
}

// dtor
CRTCCodec::~CRTCCodec()
{
    Cleanup();
}

// cleanup memory
VOID CRTCCodec::Cleanup()
{
    if (m_AMMediaType.pbFormat != NULL)
    {
        RtcFree((PVOID)m_AMMediaType.pbFormat);
    }

    ZeroMemory(this, sizeof(CRTCCodec));

    m_dwCode = (DWORD)-1;
}

// check if the codec matches the other
BOOL CRTCCodec::IsMatch(DWORD dwCode)
{
    if (m_bCodeSet && m_dwCode==dwCode)
    {
        return TRUE;
    }

    return FALSE;
}

// property
DWORD CRTCCodec::Get(CODEC_PROP prop)
{
    switch(prop)
    {
    case CODE:
        {
            return m_dwCode;
        }

    case BITRATE:
        {
            return m_dwBitrate;
        }

    case DURATION:
        {
            return GetPacketDuration(&m_AMMediaType);
        }

    case RANK:
        {
            return m_dwRank;
        }

    default:
        {
            return (DWORD)-1;
        }
    }
}

BOOL CRTCCodec::Set(CODEC_PROP prop, DWORD dwValue)
{
    switch(prop)
    {
    case DURATION:
        {
            return SetPacketDuration(&m_AMMediaType, dwValue);
        }

    case RANK:
        {
            m_dwRank = dwValue;
        }

    default:
        {
            return FALSE;
        }
    }
}

// get/set media type
AM_MEDIA_TYPE * CRTCCodec::GetAMMediaType()
{
    if (!m_bAMMediaTypeSet)
    {
        return NULL;
    }

    // allocate memory for media type
    AM_MEDIA_TYPE *pmt = (AM_MEDIA_TYPE*)RtcAlloc(sizeof(AM_MEDIA_TYPE));

    if (pmt == NULL)
    {
        LOG((RTC_ERROR, "GetAMMediaType out of memory"));
        return NULL;
    }

    // copy
    *pmt = m_AMMediaType;

    // allocate memory for format
    if (m_AMMediaType.pbFormat != NULL)
    {
        _ASSERT(pmt->cbFormat > 0);

        DWORD dwSize = pmt->cbFormat * sizeof(BYTE);

        pmt->pbFormat = (BYTE*)RtcAlloc(dwSize);

        if (pmt->pbFormat == NULL)
        {
            LOG((RTC_ERROR, "GetAMMediaType out of memory"));

            RtcFree(pmt);

            return NULL;
        }

        CopyMemory((PVOID)pmt->pbFormat, (PVOID)m_AMMediaType.pbFormat, dwSize);
    }

    return pmt;
}

// set media type
BOOL CRTCCodec::SetAMMediaType(const AM_MEDIA_TYPE *pmt)
{
    // cleanup
    if (m_bAMMediaTypeSet && m_AMMediaType.pbFormat != NULL)
    {
        RtcFree((PVOID)m_AMMediaType.pbFormat);
    }

    ZeroMemory(&m_AMMediaType, sizeof(AM_MEDIA_TYPE));

    m_dwBitrate = (DWORD)-1;

    m_bAMMediaTypeSet = FALSE;

    if (pmt == NULL)
    {
        return FALSE;
    }

    if (m_bCodeSet && !IsValid(m_dwCode, pmt))
    {
        LOG((RTC_ERROR, "SetAMMediaType not valid"));

        return FALSE;
    }

    m_AMMediaType = *pmt;

    _ASSERT(pmt->pUnk == NULL);

    m_AMMediaType.pUnk = NULL;

    if (pmt->pbFormat == NULL)
        return TRUE;

    _ASSERT(pmt->cbFormat > 0);

    // set format
    DWORD dwSize = pmt->cbFormat * sizeof(BYTE);

    m_AMMediaType.pbFormat = (BYTE*)RtcAlloc(dwSize);

    if (m_AMMediaType.pbFormat == NULL)
    {
        LOG((RTC_ERROR, "SetAMMediaType out of memory"));

        // shall we throw exception?
        m_AMMediaType.cbFormat = 0;

        return FALSE;
    }

    CopyMemory((PVOID)m_AMMediaType.pbFormat, (PVOID)pmt->pbFormat, dwSize);

    m_dwBitrate = GetBitrate(&m_AMMediaType);

    m_bAMMediaTypeSet = TRUE;

    return TRUE;
}

// RtcFree media type returned by GetAMMediaType
VOID CRTCCodec::DeleteAMMediaType(AM_MEDIA_TYPE *pmt)
{
    if (pmt == NULL)
        return;

    if (pmt->cbFormat != 0) {
        RtcFree((PVOID)pmt->pbFormat);

        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    RtcFree((PVOID)pmt);
}

BOOL CRTCCodec::IsValid(DWORD dwCode, const AM_MEDIA_TYPE *pmt)
{
    // get format tag from code
    int i = IndexFromCode(dwCode);

    if (i<0)
    {
        LOG((RTC_ERROR, "IsValid code %d not found", dwCode));

        return FALSE;
    }

    if (pmt == NULL)
    {
        return TRUE;
    }

    WAVEFORMATEX *pwave = (WAVEFORMATEX *) pmt->pbFormat;

    if (pwave == NULL)
    {
        return FALSE;
    }

    if (CODEC_ITEM_LIST[i].wFormatTag == WAVE_FORMAT_UNKNOWN)
    {
        // must be video
        return TRUE;
    }

    return (pwave->wFormatTag == CODEC_ITEM_LIST[i].wFormatTag);
}

DWORD CRTCCodec::GetPacketDuration(const AM_MEDIA_TYPE *pmt)
{
    if (pmt == NULL)
    {
        return DEFAULT_PACKET_DURATION;
    }

    WAVEFORMATEX *pwave = (WAVEFORMATEX *) pmt->pbFormat;

    if (pwave == NULL)
    {
        return DEFAULT_PACKET_DURATION;
    }

    WORD w;

    switch (pwave->wFormatTag)
    {
    case WAVE_FORMAT_SIREN:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPSIREN));

        w = ((WAVEFORMATEX_RTPSIREN *)pwave)->wPacketDuration;

        break;

    case WAVE_FORMAT_G722_1:

        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPG722_1));

        w = ((WAVEFORMATEX_RTPG722_1 *)pwave)->wPacketDuration;

        break;

    case WAVE_FORMAT_ALAW:
    case WAVE_FORMAT_MULAW:

        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPG711));
        
        w = ((WAVEFORMATEX_RTPG711 *)pwave)->wPacketDuration;
        
        break;

    case WAVE_FORMAT_DVI_ADPCM:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPDVI4));

        w = ((WAVEFORMATEX_RTPDVI4 *)pwave)->wPacketDuration;

        break;

    case WAVE_FORMAT_GSM610:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPGSM));

        w = ((WAVEFORMATEX_RTPGSM *)pwave)->wPacketDuration;

        break;

    case WAVE_FORMAT_MSG723:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPG723_1));

        w = ((WAVEFORMATEX_RTPG723_1 *)pwave)->wPacketDuration;

        break;

    default:

        w = DEFAULT_PACKET_DURATION;
    }

    return (DWORD)w;
}

BOOL CRTCCodec::SetPacketDuration(AM_MEDIA_TYPE *pmt, DWORD dwDuration)
{
    if (pmt == NULL)
    {
        return FALSE;
    }

    WAVEFORMATEX *pwave = (WAVEFORMATEX *) pmt->pbFormat;

    if (pwave == NULL)
    {
        return FALSE;
    }

    WORD w = (WORD)dwDuration;
    if (w <= 0)
    {
        return FALSE;
    }

    switch (pwave->wFormatTag)
    {
    case WAVE_FORMAT_SIREN:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPSIREN));

        ((WAVEFORMATEX_RTPSIREN *)pwave)->wPacketDuration = w;

        break;

    case WAVE_FORMAT_G722_1:

        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPG722_1));

        ((WAVEFORMATEX_RTPG722_1 *)pwave)->wPacketDuration = w;

        break;

    case WAVE_FORMAT_ALAW:
    case WAVE_FORMAT_MULAW:

        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPG711));
        
        ((WAVEFORMATEX_RTPG711 *)pwave)->wPacketDuration = w;
        
        break;

    case WAVE_FORMAT_DVI_ADPCM:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPDVI4));

        ((WAVEFORMATEX_RTPDVI4 *)pwave)->wPacketDuration = w;

        break;

    case WAVE_FORMAT_GSM610:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPGSM));

        ((WAVEFORMATEX_RTPGSM *)pwave)->wPacketDuration = w;

        break;

    case WAVE_FORMAT_MSG723:
        _ASSERT(pmt->cbFormat >= sizeof(WAVEFORMATEX_RTPG723_1));

        ((WAVEFORMATEX_RTPG723_1 *)pwave)->wPacketDuration = w;

        break;

    default:

        return FALSE;
    }

    return TRUE;
}

// bitrate
DWORD CRTCCodec::GetBitrate(const AM_MEDIA_TYPE *pmt)
{
    if (pmt == NULL)
    {
        return (DWORD)-1;
    }

    WAVEFORMATEX *pwave = (WAVEFORMATEX *) pmt->pbFormat;

    if (pwave == NULL)
    {
        return (DWORD)-1;
    }

    return pwave->nAvgBytesPerSec * 8;
}

// rank
DWORD CRTCCodec::GetRank(DWORD dwCode)
{
    int i = IndexFromCode(dwCode);

    if (i < 0)
    {
        LOG((RTC_ERROR, "GetRank code %d not found.", dwCode));

        return (DWORD)-1;
    }

    return CODEC_ITEM_LIST[i].dwRank;
}

BOOL CRTCCodec::GetQoSName(DWORD dwCode, WCHAR ** const ppwszName)
{
    int i = IndexFromCode(dwCode);

    if (i < 0)
    {
        LOG((RTC_ERROR, "GetQoS name %d not found.", dwCode));

        return FALSE;
    }

    *ppwszName = CODEC_ITEM_LIST[i].pwszQoSName;

    return TRUE;
}

BOOL CRTCCodec::IsSupported(
    RTC_MEDIA_TYPE MediaType,
    DWORD dwCode,
    DWORD dwSampleRate,
    CHAR *pszName
    )
{
    if (lstrcmpA(pszName, "red") == 0)
    {
        return TRUE;
    }

    int i = IndexFromCode(dwCode);

    if (i<0)
    {
        LOG((RTC_ERROR, "IsSupport code %d not found.", dwCode));

        return FALSE;
    }

    if (MediaType == CODEC_ITEM_LIST[i].MediaType &&
        dwCode == CODEC_ITEM_LIST[i].dwCode &&
        (dwSampleRate == CODEC_ITEM_LIST[i].dwSampleRate ||
         dwSampleRate == 0))
    {
        return TRUE;
    }

    LOG((RTC_ERROR, "IsSupport does not support code %d, mt=%d, rate=%d",
            dwCode, MediaType, dwSampleRate));

    return FALSE;
}

//
// CRTCCodecArray
//

CRTCCodecArray::CRTCCodecArray()
    :m_dwCodeInUse((DWORD)-1)
    ,m_dwBandwidth((DWORD)-1)
{
}

CRTCCodecArray::~CRTCCodecArray()
{
    RemoveAll();
}

DWORD CRTCCodecArray::GetSize()
{
    return m_pCodecs.GetSize();
}

BOOL CRTCCodecArray::AddCodec(CRTCCodec *pCodec)
{
    return m_pCodecs.Add(pCodec);
}

VOID CRTCCodecArray::RemoveAll()
{
    for (int i=0; i<m_pCodecs.GetSize(); i++)
    {
        delete m_pCodecs[i];
    }

    return m_pCodecs.RemoveAll();
}

// return index if the codec matches the code
DWORD CRTCCodecArray::FindCodec(DWORD dwCode)
{
    if (dwCode == (DWORD)-1)
    {
        return (DWORD)-1;
    }

    for (int i=0; i<m_pCodecs.GetSize(); i++)
    {
        if (m_pCodecs[i]->IsMatch(dwCode))
        {
            return i;
        }
    }

    return (DWORD)-1;
}

// get codec at the index
BOOL CRTCCodecArray::GetCodec(DWORD dwIndex, CRTCCodec **ppCodec)
{
    if (IsBadWritePtr(ppCodec, sizeof(CRTCCodec*)))
    {
        LOG((RTC_ERROR, "GetCodec bad pointer"));

        return FALSE;
    }

    if (dwIndex >= (DWORD)m_pCodecs.GetSize())
    {
        LOG((RTC_ERROR, "GetCodec outof range"));

        return FALSE;
    }

    *ppCodec = m_pCodecs[dwIndex];

    return TRUE;
}

// propery
DWORD CRTCCodecArray::Get(CODEC_ARRAY_PROP prop)
{
    switch(prop)
    {
    case BANDWIDTH:
        {
            return m_dwBandwidth;
        }

    case CODE_INUSE:
        {
            return m_dwCodeInUse;
        }
    default:
        {
            return (DWORD)-1;
        }
    }
}

BOOL CRTCCodecArray::Set(CODEC_ARRAY_PROP prop, DWORD dwValue)
{
    switch(prop)
    {
    case BANDWIDTH:
        {
            m_dwBandwidth = dwValue;
            return TRUE;
        }

    case CODE_INUSE:
        {
            m_dwCodeInUse = dwValue;
            return TRUE;
        }

    default:
        {
            return FALSE;
        }
    }
}

VOID CRTCCodecArray::OrderCodecs(BOOL fHasVideo, CRegSetting *pRegSetting)
{
    if (m_pCodecs.GetSize() == 0)
    {
        // no codec
        return;
    }

    // order codecs by rank
    OrderCodecsByRank();

    // get current codec
    int curIndex = -1;

    if (m_dwCodeInUse != (DWORD)-1)
    {
        curIndex = IndexFromCode(m_dwCodeInUse);
    }

    // bandwidth delta for switching codec
    DWORD dwDelta = pRegSetting->BandwidthDelta();

    if (dwDelta <= MAX_BWDELTA)
    {
        // take registry setting
        dwDelta *= 1000;
    }
    else
    {
        dwDelta = BWDELTA_FOR_CODEC_SWITCH;
    }

    // choose a codec
    int i = 0;

    for (i=0; i<m_pCodecs.GetSize(); i++)
    {
        DWORD dwBWReq = m_pCodecs[i]->GetTotalBWReq(fHasVideo);

        // check total bandwidth required for the codec
        if (m_dwBandwidth < dwBWReq)
        {
            // bandwidth is not enough
            continue;
        }

        if (dwBWReq == 0 || m_dwBandwidth >= dwBWReq + dwDelta)
        {
            // bandwidth is enough for switching from a lower bps codec
            // if required bandwidth is zero, we ignore delta
            break;
        }

        if (curIndex == i || curIndex == -1)
        {
            // codec no change or no codec was set
            break;
        }

        if (m_pCodecs[curIndex]->GetTotalBWReq(fHasVideo) <= dwBWReq)
        {
            // bandwidth is within [required, required+delta)
            // codec in-use uses less or same amount of bandwidth
            // do not switch
            continue;
        }
        else
        {
            // either no codec in-use or current codec requires higher
            // bandwidth. so switch.
            break;
        }
    }

    // if not found, i.e. every codec uses more bandwidth than we have
    // default the first one
    if (i >= m_pCodecs.GetSize())
    {
        i = 0;
    }

    if (i != 0)
    {
        // move i to the beginning
        CRTCCodec *pCodec = m_pCodecs[i];

        m_pCodecs.SetAtIndex(i, m_pCodecs[0]);
        m_pCodecs.SetAtIndex(0, pCodec);
    }

    // adjust duration
    DWORD dwDuration;

    // registry setting
    DWORD dwRegPTime = pRegSetting->MaxPTime();

    if (m_pCodecs[0]->IsMatch(CRTCCodec::G723))
    {
        if (fHasVideo)
        {
            if (m_dwBandwidth >= G723_30MS_TOTALBW_VIDEO)
            {
                dwDuration = 30;
            }
            else if (m_dwBandwidth >= G723_60MS_TOTALBW_VIDEO)
            {
                dwDuration = 60;
            }
            else
            {
                dwDuration = 90;
            }
        }
        else
        {
            if (m_dwBandwidth >= G723_30MS_TOTALBW_NOVIDEO)
            {
                dwDuration = 30;
            }
            else if (m_dwBandwidth >= G723_60MS_TOTALBW_NOVIDEO)
            {
                dwDuration = 60;
            }
            else
            {
                dwDuration = 90;
            }
        }

        // apply reg key
        if (dwRegPTime != (DWORD)-1)
        {
            // check reg setting
            if (dwRegPTime < 60)
            {
                dwDuration = 30;
            }
            else if (dwRegPTime < 90 && dwDuration == 90)
            {
                dwDuration = 60;
            }
        }                

        m_pCodecs[0]->Set(CRTCCodec::DURATION, dwDuration);
    }
    else if (m_pCodecs[0]->IsMatch(CRTCCodec::SIREN))
    {
        if (fHasVideo)
        {
            if (m_dwBandwidth >= SIREN_20MS_TOTALBW_VIDEO)
            {
                dwDuration = 20;
            }
            else
            {
                dwDuration = 40;
            }
        }
        else
        {
            if (m_dwBandwidth >= SIREN_20MS_TOTALBW_NOVIDEO)
            {
                dwDuration = 20;
            }
            else
            {
                dwDuration = 40;
            }
        }

        if (dwRegPTime != (DWORD)-1)
        {
            // check reg setting
            if (dwRegPTime < 40)
            {
                dwDuration = 20;
            }
        }

        m_pCodecs[0]->Set(CRTCCodec::DURATION, dwDuration);
    }
    else if (m_pCodecs[0]->IsMatch(CRTCCodec::PCMU) ||
             m_pCodecs[0]->IsMatch(CRTCCodec::PCMA))
    {
        // for interop. some gateways can only accept 20ms G711
        m_pCodecs[0]->Set(CRTCCodec::DURATION, 20);
    }
}

// order codecs
#if 0
VOID CRTCCodecArray::OrderCodecsByBandwidth()
{
    // order codecs by bandwidth low->high

    DWORD dwLen = m_pCodecs.GetSize();

    CRTCCodec *pCodec;

    if (dwLen == 0)
    {
        // no need to order
        return;
    }
    else
    {
        // bubble algo is good enough
        BOOL bSwapped;
        DWORD dwLeft, dwRight;

        for (int i=dwLen-2; i>=0; i--)
        {
            bSwapped = FALSE;

            for (int j=0; j<=i; j++)
            {
                dwLeft = m_pCodecs[j]->Get(CRTCCodec::BITRATE);
                dwRight = m_pCodecs[j+1]->Get(CRTCCodec::BITRATE);

                if (dwLeft > dwRight)
                {
                    bSwapped = TRUE;

                    pCodec = m_pCodecs[j];
                    m_pCodecs.SetAtIndex(j, m_pCodecs[j+1]);
                    m_pCodecs.SetAtIndex(j+1, pCodec);
                }
            }

            if (!bSwapped)
                break;
        }
    }

    if (dwLen > 1)
    {
        // if 1st = gsm, 2nd = g723
        // switch them
        if (m_pCodecs[0]->IsMatch(CRTCCodec::GSM) &&
            m_pCodecs[1]->IsMatch(CRTCCodec::G723)
            )
        {
            // put g723 ahead of gsm
            pCodec = m_pCodecs[0];
            m_pCodecs.SetAtIndex(0, m_pCodecs[1]);
            m_pCodecs.SetAtIndex(1, pCodec);
        }
    }
}
#endif

// order codecs
VOID CRTCCodecArray::OrderCodecsByRank()
{
    // order codecs by rank

    DWORD dwLen = m_pCodecs.GetSize();

    if (dwLen < 2)
    {
        // no need to order
        return;
    }

    // bubble algo is good enough
    BOOL bSwapped;
    DWORD dwLeft, dwRight;

    CRTCCodec *pCodec;

    for (int i=dwLen-2; i>=0; i--)
    {
        bSwapped = FALSE;

        for (int j=0; j<=i; j++)
        {
            dwLeft = m_pCodecs[j]->Get(CRTCCodec::RANK);
            dwRight = m_pCodecs[j+1]->Get(CRTCCodec::RANK);

            if (dwLeft > dwRight)
            {
                bSwapped = TRUE;

                pCodec = m_pCodecs[j];
                m_pCodecs.SetAtIndex(j, m_pCodecs[j+1]);
                m_pCodecs.SetAtIndex(j+1, pCodec);
            }
        }

        if (!bSwapped)
            break;
    }
}

VOID CRTCCodecArray::TraceLogCodecs()
{
#define TRACE_LOG_SIZE 100

    CHAR str[TRACE_LOG_SIZE+1];

    _snprintf(str, TRACE_LOG_SIZE, "Codecs:");

    for (int i=0; i<m_pCodecs.GetSize(); i++)
    {
        _snprintf(
            str+lstrlenA(str),
            TRACE_LOG_SIZE-lstrlenA(str),
            " %d",
            m_pCodecs[i]->Get(CRTCCodec::CODE)
            );
    }

    LOG((RTC_QUALITY, str));
}

// return the index of codec list based on rtp code
int CRTCCodecArray::IndexFromCode(DWORD dwCode)
{
    for (int i=0; i<m_pCodecs.GetSize(); i++)
    {
        if (m_pCodecs[i]->IsMatch(dwCode))
        {
            return i;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\dllres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtcmedia.rc
//
#define IDR_REGISTRY                    101
#define IDS_PROJNAME                    102
#define IDR_RTCMEDIACONTROLLER          103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\debug.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    debug.cpp

Abstract:

    Implements methods for tracing

Author:

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"
#include <stdio.h>

CRTCTracing g_objTracing;

// debug mask, description, etc
typedef struct RTC_DEBUG_MASK
{
    DWORD   dwMask;
    const CHAR * pszDesp;

} RTC_DEBUG_MASK;

const RTC_DEBUG_MASK g_DebugMask[] =
{
    // mask                                 description
    {((DWORD)0x00010000 | TRACE_USE_MASK), "ERROR"},
    {((DWORD)0x00020000 | TRACE_USE_MASK), "WARNING"},
    {((DWORD)0x00040000 | TRACE_USE_MASK), "INFO"},
    {((DWORD)0x00080000 | TRACE_USE_MASK), "TRACE"},
    {((DWORD)0x10000000 | TRACE_USE_MASK), "REFCOUNT"},
    {((DWORD)0x20000000 | TRACE_USE_MASK), "GRAPHEVENT"},
    {((DWORD)0x40000000 | TRACE_USE_MASK), "RTCEVENT"},
    {((DWORD)0x80000000 | TRACE_USE_MASK), "QUALITY"},
    {((DWORD)0x00010000 | TRACE_USE_MASK), "UNKNOWN"}

};

CRTCTracing::CRTCTracing()
    :m_hEvent(NULL)
    ,m_hWait(NULL)
    ,m_dwTraceID(INVALID_TRACEID)
    ,m_dwConsoleTracingMask(0)
    ,m_dwFileTracingMask(0)
    ,m_fInShutdown(FALSE)
    ,m_dwInitCount(0)
{
    m_pszTraceName[0] = L'\0';
}

CRTCTracing::~CRTCTracing()
{
    Shutdown();
}

// register wait on registry change
VOID
CRTCTracing::Initialize(WCHAR *pszName)
{
    _ASSERT(pszName != NULL);

    if (pszName == NULL)
    {
        // oops, null tracing module
        return;
    }

    //_ASSERT(m_pszTraceName[0] == L'\0');

    //if (m_pszTraceName[0] != L'\0')
    //{
        //Shutdown();
    //}

    m_dwInitCount ++;

    if (m_dwInitCount > 1)
    {
        // already initiated
        return;
    }

    // store tracing name

    wcsncpy(m_pszTraceName, pszName, MAX_TRACE_NAME);

    m_pszTraceName[MAX_TRACE_NAME] = L'\0';

    // register tracing
    m_dwTraceID = TraceRegister(pszName);

    if (m_dwTraceID == INVALID_TRACEID)
    {
        // failed to register tracing
        return;
    }

    // open reg key
    CMediaReg reg;

    HRESULT hr = reg.OpenKey(
        HKEY_LOCAL_MACHINE,
        L"Software\\Microsoft\\Tracing",
        KEY_READ
        );

    if (S_OK != hr)
    {
        // failed to open reg key
        Shutdown();
        return;
    }

    hr = m_Reg.OpenKey(reg, m_pszTraceName, KEY_READ);

    if (S_OK != hr)
    {
        Shutdown();
        return;
    }

    // read registry value
    ReadRegistry();

    // create event
    m_hEvent = CreateEvent(
        NULL,       // event attributes
        FALSE,      // manual reset
        FALSE,      // initial state
        NULL        // name
        );

    if (m_hEvent == NULL)
    {
        // failed to create event
        Shutdown();
        return;
    }

    // register wait
    if (!RegisterWaitForSingleObject(
            &m_hWait,               // wait handle
            m_hEvent,               // event
            CRTCTracing::Callback,  // callback
            (PVOID)this,            // context
            INFINITE,               // time-out interval
            WT_EXECUTEDEFAULT       // non-IO worker thread
            ))
    {
        Shutdown();
        return;
    }

    // associate the event with registry key
    if (ERROR_SUCCESS != RegNotifyChangeKeyValue(
            m_Reg.m_hKey,      // key
            FALSE,      // subkey
            REG_NOTIFY_CHANGE_LAST_SET, // notify filter
            m_hEvent,                   // event
            TRUE                        // async report
            ))
    {
        Shutdown();
        return;
    }
}

// unregister wait on registry change
VOID
CRTCTracing::Shutdown()
{
    if (m_dwInitCount > 0)
    {
        m_dwInitCount --;
    }

    if (m_dwInitCount > 0)
    {
        return;
    }

    m_fInShutdown = TRUE;

    // close reg key
    // force event to be signalled

    m_Reg.CloseKey();

    // unregister wait
    if (m_hWait != NULL)
    {
        // blocking cancelling wait
        UnregisterWaitEx(m_hWait, INVALID_HANDLE_VALUE);

        m_hWait = NULL;
    }

    // close event
    if (m_hEvent != NULL)
    {
        CloseHandle(m_hEvent);

        m_hEvent = NULL;
    }

    // deregister tracing
    if (m_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(m_dwTraceID);

        m_dwTraceID = INVALID_TRACEID;
    }

    m_dwConsoleTracingMask = 0;
    m_dwFileTracingMask = 0;
    m_pszTraceName[0] = L'\0';

    m_fInShutdown = FALSE;
}

// registry change callback
VOID NTAPI
CRTCTracing::Callback(PVOID pContext, BOOLEAN fTimer)
{
    ((CRTCTracing*)pContext)->OnChange();
}

// on change
VOID
CRTCTracing::OnChange()
{
    if (!m_fInShutdown && m_Reg.m_hKey!=NULL && m_hEvent!=NULL)
    {
        // read registry
        ReadRegistry();

        // rewait on registry
        RegNotifyChangeKeyValue(
            m_Reg.m_hKey,      // key
            FALSE,      // subkey
            REG_NOTIFY_CHANGE_LAST_SET, // notify filter
            m_hEvent,                   // event
            TRUE                        // async report
            );
    }
}

VOID
CRTCTracing::ReadRegistry()
{
    DWORD dwValue;

    // read console tracing flag
    if (S_OK == m_Reg.ReadDWORD(
            L"EnableConsoleTracing",
            &dwValue
            ))
    {
        if (dwValue != 0)
        {
            // read console tracing mask
            if (S_OK == m_Reg.ReadDWORD(
                    L"ConsoleTracingMask",
                    &dwValue
                    ))
            {
                m_dwConsoleTracingMask = dwValue;
            }
        }
    }

    // read file tracing flag
    if (S_OK == m_Reg.ReadDWORD(
            L"EnableFileTracing",
            &dwValue
            ))
    {
        if (dwValue != 0)
        {
            // read file tracing mask
            if (S_OK == m_Reg.ReadDWORD(
                    L"FileTracingMask",
                    &dwValue
                    ))
            {
                m_dwFileTracingMask = dwValue;
            }
        }
    }
}

//
// tracing functions
//

/*
VOID
CRTCTracing::Log(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
{
#define SHORT_MAX_LEN 128

    if (dwDbgLevel > RTC_LAST)
    {
        dwDbgLevel = RTC_LAST;
    }

    // print tracing?
    if ((g_DebugMask[dwDbgLevel].dwMask & m_dwConsoleTracingMask)==0 &&
        (g_DebugMask[dwDbgLevel].dwMask & m_dwFileTracingMask)==0)
    {
        return;
    }

    va_list arglist;
    va_start(arglist, lpszFormat);
    Println(SHORT_MAX_LEN, dwDbgLevel, lpszFormat, arglist);
    va_end(arglist);
}


VOID
CRTCTracing::LongLog(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
{
#define LONG_MAX_LEN 512

    if (dwDbgLevel > RTC_LAST)
    {
        dwDbgLevel = RTC_LAST;
    }

    // print tracing?
    if ((g_DebugMask[dwDbgLevel].dwMask & m_dwConsoleTracingMask)==0 &&
        (g_DebugMask[dwDbgLevel].dwMask & m_dwFileTracingMask)==0)
    {
        return;
    }

    va_list arglist;
    va_start(arglist, lpszFormat);
    Println(LONG_MAX_LEN, dwDbgLevel, lpszFormat, arglist);
    va_end(arglist);
}
*/

VOID
CRTCTracing::Println(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
{
#define MAX_TRACE_LEN       128
#define MAX_LONG_TRACE_LEN  640

    if (dwDbgLevel > RTC_LAST)
    {
        dwDbgLevel = RTC_LAST;
    }

    // print tracing?
    if ((g_DebugMask[dwDbgLevel].dwMask & m_dwConsoleTracingMask)==0 &&
        (g_DebugMask[dwDbgLevel].dwMask & m_dwFileTracingMask)==0)
    {
        return;
    }

    // console tracing
    if ((g_DebugMask[dwDbgLevel].dwMask & m_dwConsoleTracingMask)!=0)
    {
        // retrieve local time
        SYSTEMTIME SysTime;
        GetLocalTime(&SysTime);

        // time stamp
        WCHAR header[MAX_TRACE_LEN+1];

        if (_snwprintf(
                header,
                MAX_TRACE_LEN,
                L"%s %x:[%02u:%02u.%03u]",
                m_pszTraceName,
                GetCurrentThreadId(),
                SysTime.wMinute,
                SysTime.wSecond,
                SysTime.wMilliseconds
                ) < 0)
        {
            header[MAX_TRACE_LEN] = L'\0';
        }

        OutputDebugStringW(header);

        // trace info
        // debug output
        CHAR info[MAX_LONG_TRACE_LEN+2];

        sprintf(info, "[%s] ", g_DebugMask[dwDbgLevel].pszDesp);
        OutputDebugStringA(info);

        va_list ap;
        va_start(ap, lpszFormat);

        if (_vsnprintf(
                info,
                MAX_LONG_TRACE_LEN,
                lpszFormat,
                ap) < 0)
        {
            info[MAX_LONG_TRACE_LEN] = '\0';
        }

        va_end(ap);

        lstrcatA(info, "\n");

        OutputDebugStringA(info);
    }
    
    // print file tracing
    if ((g_DebugMask[dwDbgLevel].dwMask & m_dwFileTracingMask)!=0 &&
        m_dwTraceID != INVALID_TRACEID)
    {
        CHAR info[MAX_TRACE_LEN+1];

        wsprintfA(
            info,
            "[%s] %s",
            g_DebugMask[dwDbgLevel].pszDesp,
            lpszFormat
            );

        va_list arglist;
        va_start(arglist, lpszFormat);

        TraceVprintfExA(
            m_dwTraceID,
            g_DebugMask[dwDbgLevel].dwMask,
            info,
            arglist
            );

        va_end(arglist);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\codec.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    CRTCCodec.h

Abstract:

    Wrap class of audio, video codec

Author(s):

    Qianbo Huai (qhuai) 12-Feb-2001

--*/

#ifndef _CODEC_H
#define _CODEC_H

class CRTCCodec
{
public:

typedef enum
{
    RANK,
    CODE,
    BITRATE,
    DURATION

} CODEC_PROP;

static const DWORD PCMU     = 0;
static const DWORD GSM      = 3;
static const DWORD G723     = 4;
static const DWORD DVI4_8   = 5;
static const DWORD DVI4_16  = 6;
static const DWORD PCMA     = 8;
static const DWORD SIREN    = 111;
static const DWORD G7221    = 112;

static const DWORD H263     = 34;
static const DWORD H261     = 31;

static const DWORD DEFAULT_BITRATE = (DWORD)-1;
static const DWORD DEFAULT_PACKET_DURATION = 20;

typedef struct CODEC_ITEM
{
    RTC_MEDIA_TYPE      MediaType;      // audio or video
    DWORD               dwCode;         // rtp code
    WORD                wFormatTag;     // am media type tag
    DWORD               dwRank;         // higher value, lower rank
    DWORD               dwSampleRate;   // sample rate
    WCHAR               *pwszCodeName;  // name for rtp code
    WCHAR               *pwszQoSName;   // name for configuring QOS
    DWORD               dwTotalBWReqNoVid;  // minimum bandwidth required without video
    DWORD               dwTotalBWReqVid;    // minimum bandwidth required with video

} CODEC_ITEM;

static const CODEC_ITEM CODEC_ITEM_LIST[];
static const DWORD CODEC_ITEM_NUM;

    // ctro
    //CRTCCodec();

    // ctor from rtp payload code
    //CRTCCodec(DWORD dwCode);

    // ctor from am media type
    //CRTCCodec(AM_MEDIA_TYPE *pmt);

    // ctro from code and amt
    CRTCCodec(DWORD dwCode, const AM_MEDIA_TYPE *pmt);

    // ctor copy
    //CRTCCodec(const CRTCCodec& Codec);

    // dtro
    ~CRTCCodec();

    // = operator
    //CRTCCodec& operator= (const CRTCCodec& Codec);

    // if match, same but some properties may be diff
    //BOOL IsMatch(const CRTCCodec& Codec);

    BOOL IsMatch(DWORD dwCode);

    // update fields if necessary
    //CRTCCodec& Update(const CRTCCodec& Codec);

    // get/set property
    DWORD Get(CODEC_PROP prop);
    BOOL Set(CODEC_PROP prop, DWORD dwValue);

    // get/set am media type
    AM_MEDIA_TYPE * GetAMMediaType();
    BOOL SetAMMediaType(const AM_MEDIA_TYPE *pmt);
    VOID DeleteAMMediaType(AM_MEDIA_TYPE *pmt);

    DWORD GetTotalBWReq(BOOL bVideo) const
    { return bVideo?m_dwTotalBWReqVid:m_dwTotalBWReqNoVid; }

    // check if code and media type match
    static BOOL IsValid(DWORD dwCode, const AM_MEDIA_TYPE *pmt);

    // packet duration
    static DWORD GetPacketDuration(const AM_MEDIA_TYPE *pmt);
    static BOOL SetPacketDuration(AM_MEDIA_TYPE *pmt, DWORD dwDuration);

    // bitrate
    static DWORD GetBitrate(const AM_MEDIA_TYPE *pmt);

    // rank
    static DWORD GetRank(DWORD dwCode);

    // qos name
    static BOOL GetQoSName(DWORD dwCode, WCHAR ** const ppwszName);

    // support rtp format?
    static BOOL IsSupported(
        RTC_MEDIA_TYPE MediaType,
        DWORD dwCode,
        DWORD dwSampleRate,
        CHAR *pszName
        );

protected:

    static int IndexFromCode(DWORD dwCode);
    static int IndexFromFormatTag(WORD wFormatTag);

    void Cleanup();

    BOOL Copy(const CRTCCodec& Codec);

protected:

    // code
    BOOL                m_bCodeSet;
    DWORD               m_dwCode;

    // am media type
    BOOL                m_bAMMediaTypeSet;
    AM_MEDIA_TYPE       m_AMMediaType;

    // name
#define MAX_CODEC_NAME_LEN 20
    WCHAR               m_wstrName[MAX_CODEC_NAME_LEN+1];

    // used by app to determine codec priority
    DWORD               m_dwRank;

    DWORD               m_dwTotalBWReqNoVid;
    DWORD               m_dwTotalBWReqVid;

    DWORD               m_dwBitrate;
};


class CRTCCodecArray
{
public:

typedef enum
{
    BANDWIDTH,
    CODE_INUSE

}  CODEC_ARRAY_PROP;

static const DWORD EXTRA_LOW_BANDWIDTH_THRESHOLD = 15000;   // 15k
static const DWORD LOW_BANDWIDTH_THRESHOLD  =  60000; //  60 k
static const DWORD MID_BANDWIDTH_THRESHOLD  = 130000; // 130 k
static const DWORD HIGH_BANDWIDTH_THRESHOLD = 200000; // 200 k

static const DWORD LAN_INITIAL_BANDWIDTH    = 120000; // 120 k

// if suggested bandwidth deducting raw audio is less than the threshold
// we should order codecs based on bandwidth
//static const DWORD LEFT_FROM_RAWAUDIO_THRESHOLD = 90000; // 90k

// the estimated amount of bw for video when video is enabled
static const DWORD PREFERRED_MIN_VIDEO          = 40000;    // 40k

// if leftover bandwidth which includes audio head is
// below this value, order codec based on bandwidth order
static const DWORD PREFERRED_MIN_LEFTOVER       = 24000;    // 24k

    // ctor
    CRTCCodecArray();

    // dtor
    ~CRTCCodecArray();

    // get size
    DWORD GetSize();

    // add/remote codec
    BOOL AddCodec(CRTCCodec *pCodec);
    //BOOL RemoveCodec(DWORD dwIndex);

    VOID RemoveAll();

    // order codes
    VOID OrderCodecs(BOOL fHasVideo, CRegSetting *pRegSetting);

    // find a codec, return index
    DWORD FindCodec(DWORD dwCode);

    // get codec
    BOOL GetCodec(DWORD dwIndex, CRTCCodec **ppCodec);

    // get/set property
    DWORD Get(CODEC_ARRAY_PROP prop);
    BOOL Set(CODEC_ARRAY_PROP prop, DWORD dwValue);

    VOID TraceLogCodecs();

protected:

    int IndexFromCode(DWORD dwCode);

    //VOID OrderCodecsByBandwidth();
    VOID OrderCodecsByRank();

protected:

    CRTCArray<CRTCCodec*>   m_pCodecs;

    DWORD                   m_dwCodeInUse;

    DWORD                   m_dwBandwidth;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    debug.h

Abstract:

    define tracing class

Author:

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#ifndef _DEBUG_H
#define _DEBUG_H

#include <rtutils.h>

#define RTC_ERROR       0
#define RTC_WARN        1
#define RTC_INFO        2
#define RTC_TRACE       3
#define RTC_REFCOUNT    4
#define RTC_GRAPHEVENT  5
#define RTC_EVENT       6
#define RTC_QUALITY     7
#define RTC_LAST        8

// assumption: the tracing object is used in a single thread
// except the wait-or-timer-callback

class CRTCTracing
{
public:

    CRTCTracing();

    ~CRTCTracing();

    // register wait on registry change
    VOID Initialize(WCHAR *pszName);

    // unregister wait on registry change
    VOID Shutdown();

    // registry change callback
    static VOID NTAPI Callback(PVOID pContext, BOOLEAN fTimer);

    // on change
    VOID OnChange();

    // tracing functions
    VOID Println(/*DWORD dwMaxLen*/ DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...);

//    VOID Log(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...);

//    VOID LongLog(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...);

private:

    VOID ReadRegistry();

#define MAX_TRACE_NAME 64

    BOOL        m_fInShutdown;

    // registry key
    CMediaReg   m_Reg;

    // event on key
    HANDLE      m_hEvent;

    // wait handle
    HANDLE      m_hWait;

    // tracing variables

    DWORD       m_dwTraceID;

    WCHAR       m_pszTraceName[MAX_TRACE_NAME+1];

    DWORD       m_dwConsoleTracingMask;

    DWORD       m_dwFileTracingMask;

    DWORD       m_dwInitCount;
};

extern CRTCTracing g_objTracing;

#ifdef ENABLE_TRACING

    #define DBGREGISTER(arg) g_objTracing.Initialize(arg)
    #define DBGDEREGISTER() g_objTracing.Shutdown()
    #define LOG(arg) g_objTracing.Println arg
    //#define LONGLOG(arg) g_objTracing.LongLog arg

#else

    #define DBGREGISTER(arg)
    #define DBGDEREGISTER()
    #define LOG(arg)
    //#define LONGLOG(arg)

#endif // ENABLE_TRACE

#endif // _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\dtmf.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    DTMF.cpp

Abstract:

    Implement out-of-band DTMF support

Author(s):

    Qianbo Huai (qhuai) 27-Mar-2001

--*/

#include "stdafx.h"

// initialize DTMF support, code, mask
VOID
CRTCDTMF::Initialize()
{
    m_Support = DTMF_UNKNOWN;

    m_dwCode = DEFAULT_RTP_CODE;

    m_dwMask = DEFAULT_SUPPORTED_TONES;
}


// check if dtmf is enabled for the tone
BOOL
CRTCDTMF::GetDTMFSupport(DWORD dwTone)
{
    return ((GetMask(dwTone) & m_dwMask)!=0);
}


VOID
CRTCDTMF::SetDTMFSupport(
    DWORD dwLow,
    DWORD dwHigh
    )
{
    for (DWORD i=dwLow; i<dwHigh && i<=MAX_TONE; i++)
    {
        m_dwMask |= GetMask(i);
    }
}


DWORD
CRTCDTMF::GetMask(DWORD dwTone)
{
    if (dwTone > MAX_TONE)
    {
        return 0;
    }

    return (dwTone >> 1) & 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\filter.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Filter.h

Abstract:
    
    This file implements a null render filter for tuning audio capture.

    Revised based on nullrend.h by Mu Han (muhan).

Author(s):

    Qianbo Huai (qhuai) 25-Aug-2000

--*/

#ifndef _FILTER_H
#define _FILTER_H

/*//////////////////////////////////////////////////////////////////////////////
    input pin
////*/
class CNRFilter;

class CNRInputPin :
    public CBaseInputPin
{
public:

    CNRInputPin(
        IN CNRFilter *pFilter,
        IN CCritSec *pLock,
        OUT HRESULT *phr
        );

    // media sample
    STDMETHOD (Receive) (
        IN IMediaSample *
        );

    STDMETHOD (ReceiveCanBlock) ();

    // media type
    STDMETHOD (QueryAccept) (
        IN const AM_MEDIA_TYPE *
        );
    
    STDMETHOD (EnumMediaTypes) (
        OUT IEnumMediaTypes **
        );

    HRESULT CheckMediaType(
        IN const CMediaType *
        );

    // control
    HRESULT Active(void);

    HRESULT Inactive(void);
};

/*//////////////////////////////////////////////////////////////////////////////
    filter
////*/

class CNRFilter :
    public CBaseFilter
{
public:

    static HRESULT CreateInstance(
        OUT IBaseFilter **ppIBaseFilter
        );

    CNRFilter(
        OUT HRESULT *phr
        );
    
    ~CNRFilter();

    // pin
    CBasePin *GetPin(
        IN int index
        );

    int GetPinCount();

private:

    CCritSec        m_Lock;
    CNRInputPin     *m_pPin;
};

#endif _FILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\dtmf.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    DTMF.h

Abstract:

    Implement out-of-band DTMF support

Author(s):

    Qianbo Huai (qhuai) 27-Mar-2001

--*/

#ifndef _DTMF_H
#define _DTMF_H

class CRTCDTMF
{
public:

    typedef enum
    {
        DTMF_ENABLED,
        DTMF_DISABLED,
        DTMF_UNKNOWN

    } DTMF_SUPPORT;

    static const DWORD DEFAULT_RTP_CODE = 101;

    // support tone 0-15
    static const DWORD DEFAULT_SUPPORTED_TONES = 0x1FFFF;

#define MAX_TONE 16

public:

    CRTCDTMF()
    { Initialize(); }

    //~CRTCDTMF();

    // initialize internal state
    VOID Initialize();

    // check if dtmf is enabled
    DTMF_SUPPORT GetDTMFSupport() const
    { return m_Support; }

    VOID SetDTMFSupport(DTMF_SUPPORT Support)
    { m_Support = Support; }

    // check if dtmf is enabled for the tone
    BOOL GetDTMFSupport(DWORD dwTone);

    // set dtmf support for a range of tones
    VOID SetDTMFSupport(DWORD dwLow, DWORD dwHigh);

    // get dtmf payload code
    DWORD GetRTPCode() const
    { return m_dwCode; }

    VOID SetRTPCode(DWORD dwCode)
    { m_dwCode = dwCode; }

private:

    DWORD GetMask(DWORD dwTone);

private:

    // dtmf mode
    DTMF_SUPPORT            m_Support;

    // dtmf code
    DWORD                   m_dwCode;

    // mask for supported tones
    DWORD                   m_dwMask;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\media.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Media.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 29-Jul-2000

--*/

#ifndef _MEDIA_H
#define _MEDIA_H

// media state
typedef enum RTC_MEDIA_STATE
{
    RTC_MS_CREATED,
    RTC_MS_INITIATED,
    RTC_MS_SHUTDOWN

} RTC_MEDIA_STATE;

/*//////////////////////////////////////////////////////////////////////////////
    class CRTCMedia
////*/

class ATL_NO_VTABLE CRTCMedia :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IRTCMedia
{
public:

BEGIN_COM_MAP(CRTCMedia)
    COM_INTERFACE_ENTRY(IRTCMedia)
END_COM_MAP()

public:

    CRTCMedia();
    ~CRTCMedia();

#ifdef DEBUG_REFCOUNT

    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    //
    // IRTCMedia methods
    //

	STDMETHOD (Initialize) (
		IN ISDPMedia *pISDPMedia,
		IN IRTCMediaManagePriv *pMediaManagePriv
		);

    STDMETHOD (Reinitialize) ();

	STDMETHOD (Shutdown) ();

    STDMETHOD (Synchronize) (
        IN BOOL fLocal,
        IN DWORD dwDirection
        );

	STDMETHOD (GetStream) (
		IN RTC_MEDIA_DIRECTION Direction,
		OUT IRTCStream **ppStream
		);

	STDMETHOD (GetSDPMedia) (
		OUT ISDPMedia **ppISDPMedia
		);

    BOOL IsPossibleSingleStream() const
    {
        return m_fPossibleSingleStream;
    }

protected:

    HRESULT SyncAddStream(
        IN UINT uiIndex,
        IN BOOL fLocal
        );

    HRESULT SyncRemoveStream(
        IN UINT uiIndex,
        IN BOOL fLocal
        );

    HRESULT SyncDataMedia();

#define RTC_MAX_MEDIA_STREAM_NUM 2

    UINT Index(
        IN RTC_MEDIA_DIRECTION Direction
        );

    RTC_MEDIA_DIRECTION ReverseIndex(
        IN UINT uiIndex
        );

public:

    //
    // shared stream setting
    //

    // duplex controller for audio
    IAudioDuplexController          *m_pIAudioDuplexController;

    // rtp session shared by two streams
    HANDLE                          m_hRTPSession;
    RTC_MULTICAST_LOOPBACK_MODE     m_LoopbackMode;

protected:

    // state
    RTC_MEDIA_STATE                 m_State;

    // media type
    RTC_MEDIA_TYPE                  m_MediaType;

    // media manage
    IRTCMediaManagePriv             *m_pIMediaManagePriv;

    // corresponding media description in SDP
    ISDPMedia                       *m_pISDPMedia;

    // streams
    IRTCStream                      *m_Streams[RTC_MAX_MEDIA_STREAM_NUM];

    // hack for checking if AEC might be needed
    BOOL                            m_fPossibleSingleStream;
};

#endif _MEDIA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\filter.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Filter.cpp

Abstract:
    
    This file implements a null render filter for tuning audio capture.

    Revised based on nullrend.cpp by Mu Han (muhan).

Author(s):

    Qianbo Huai (qhuai) 26-Aug-2000

--*/

#include "stdafx.h"

// define GUID for the filter
#include <initguid.h>
DEFINE_GUID(CLSID_NR,
0xa1988f41, 0xb929, 0x419b,
0x9e, 0x2b, 0x57, 0xd6, 0x34, 0x45, 0x1c, 0x0a);

//
// class CNRInputPin
//

CNRInputPin::CNRInputPin(
    IN CNRFilter *pFilter,
    IN CCritSec *pLock,
    OUT HRESULT *phr
    )
    :CBaseInputPin(
        NAME("CNRInputPin"),    // object name
        pFilter,
        pLock,
        phr,
        NAME("InputPin")        // name
        )
{
    //ENTER_FUNCTION("CNRInputPin::CNRInputPin");

    //LOG((RTC_TRACE, "%s entered", __fxName));
}

// media sample
STDMETHODIMP
CNRInputPin::Receive(
    IN IMediaSample *pSample
    )
{
#if LOG_MEDIA_SAMPLE

    ENTER_FUNCTION("CNRInputPin::Receive");

    REFERENCE_TIME tStart, tStop;
    DWORD dwLen;
    BYTE *pBuffer;

    // get buffer
    if (FAILED(pSample->GetPointer(&pBuffer)))
    {
        LOG((RTC_ERROR, "%s get pointer", __fxName));

        return S_OK;
    }

    // get time
    pSample->GetTime(&tStart, &tStop);

    // get data length
    dwLen = pSample->GetActualDataLength();

    // print out time and length info
    LOG((RTC_TRACE, "%s Start(%s) Stop(%s) Bytes(%d)\n",
         __fxName,
         (LPCTSTR) CDisp(tStart),
         (LPCTSTR) CDisp(tStop),
         dwLen
         ));

    // print out the buffer: 8 short per line
    short *pShort = (short*)pBuffer;

    CHAR Cache[160];
    Cache[0] = '\0';
    
    DWORD dw;
    for (dw=0; (dw+dw)<dwLen; dw++)
    {
        sprintf(Cache+lstrlenA(Cache), "%d, ", pShort[dw]);

        if (dw % 8 == 7)
        {
            LOG((RTC_TRACE, "%s", Cache));
            Cache[0] = '\0';
        }
    }

    if (dwLen % 2 == 1)
    {
        // we have one byte not cached
        sprintf(Cache+lstrlenA(Cache), "%d, ", (short)(pBuffer[dwLen-1]));
    }

    // do we have un-printed data?
    if (sizeof(Cache) > 0)
    {
        LOG((RTC_TRACE, "%s", Cache));
    }

    LOG((RTC_TRACE, "EOF\n"));

#endif

    return S_OK;
}

STDMETHODIMP
CNRInputPin::ReceiveCanBlock()
{
    //ENTER_FUNCTION("CNRInputPin::ReceiveCanBlock");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return S_FALSE;
}

// media type
STDMETHODIMP
CNRInputPin::QueryAccept(
    IN const AM_MEDIA_TYPE *
    )
{
    //ENTER_FUNCTION("CNRInputPin::QueryAccept");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return S_OK;
}

STDMETHODIMP
CNRInputPin::EnumMediaTypes(
    OUT IEnumMediaTypes **
    )
{
    //ENTER_FUNCTION("CNRInputPin::EnumMediaTypes");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return E_NOTIMPL;
}

HRESULT
CNRInputPin::CheckMediaType(
    IN const CMediaType *
    )
{
    //ENTER_FUNCTION("CNRInputPin::CheckMediaType");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return S_OK;
}

// control
HRESULT
CNRInputPin::Active(void)
{
    //ENTER_FUNCTION("CNRInputPin::Active");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return S_OK;
}

HRESULT
CNRInputPin::Inactive(void)
{
    //ENTER_FUNCTION("CNRInputPin::Inactive");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return S_OK;
}

//
// class CNRFilter
//

HRESULT
CNRFilter::CreateInstance(
    OUT IBaseFilter **ppIBaseFilter
    )
{
    ENTER_FUNCTION("CNRFilter::CreateInstance");

    HRESULT hr;
    CNRFilter *pFilter;

    pFilter = new CNRFilter(&hr);

    if (pFilter == NULL)
    {
        LOG((RTC_ERROR, "%s create filter. return NULL", __fxName));

        return E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create filter. %x", __fxName, hr));

        delete pFilter;

        return hr;
    }

    *ppIBaseFilter = static_cast<IBaseFilter*>(pFilter);
    (*ppIBaseFilter)->AddRef();

    return S_OK;
}

CNRFilter::CNRFilter(
    OUT HRESULT *phr
    )
    :CBaseFilter(
        NAME("CNRFilter"),
        NULL,
        &m_Lock,
        CLSID_NR
        )
    ,m_pPin(NULL)
{
    //ENTER_FUNCTION("CNRFilter::CNRFilter");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    // create pin
    m_pPin = new CNRInputPin(this, &m_Lock, phr);

    if (m_pPin == NULL)
        *phr = E_OUTOFMEMORY;
}

CNRFilter::~CNRFilter()
{
    //ENTER_FUNCTION("CNRFilter::~CNRFilter");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    if (m_pPin)
        delete m_pPin;
}

// pin
CBasePin *
CNRFilter::GetPin(
    IN int index
    )
{
    //ENTER_FUNCTION("CNRFilter::GetPin");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return index==0?m_pPin:NULL;
}

int
CNRFilter::GetPinCount()
{
    //ENTER_FUNCTION("CNRFilter::GetPinCount");

    //LOG((RTC_TRACE, "%s entered", __fxName));

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\media.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Media.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 29-Jul-2000

--*/

#include "stdafx.h"

#define NETMEETING_PORT 1503

CRTCMedia::CRTCMedia()
    :m_State(RTC_MS_CREATED)
    ,m_pIMediaManagePriv(NULL)
    ,m_pISDPMedia(NULL)
    ,m_pIAudioDuplexController(NULL)
    ,m_hRTPSession(NULL)
    ,m_LoopbackMode(RTC_MM_NO_LOOPBACK)
    ,m_fPossibleSingleStream(TRUE)
{
    for (int i=0; i<RTC_MAX_MEDIA_STREAM_NUM; i++)
    {
        m_Streams[i] = NULL;
    }
}

CRTCMedia::~CRTCMedia()
{
    if (m_State != RTC_MS_SHUTDOWN)
    {
        LOG((RTC_TRACE, "~CRTCMedia is called before shutdown"));
        
        Shutdown();
    }
}

#ifdef DEBUG_REFCOUNT

ULONG
CRTCMedia::InternalAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    LOG((RTC_REFCOUNT, "media(%p) addref=%d",
         static_cast<IRTCMedia*>(this), lRef));

    return lRef;
}

ULONG
CRTCMedia::InternalRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();
    
    LOG((RTC_REFCOUNT, "media(%p) release=%d",
        static_cast<IRTCMedia*>(this), lRef));

    return lRef;
}

#endif

//
// IRTCMedia methods
//

/*//////////////////////////////////////////////////////////////////////////////
    Initialize the media and create a SDP media entry
    Store the SDP media entry index
////*/

STDMETHODIMP
CRTCMedia::Initialize(
    IN ISDPMedia *pISDPMedia,
    IN IRTCMediaManagePriv *pMediaManagePriv
    )
{
    _ASSERT(m_State == RTC_MS_CREATED);

    HRESULT hr;

    // get media type - shouldn't fail
    if (FAILED(hr = pISDPMedia->GetMediaType(&m_MediaType)))
        return hr;

    // create duplex controller
    if (m_MediaType == RTC_MT_AUDIO)
    {
        // create duplex controller
        hr = CoCreateInstance(
            __uuidof(TAPIAudioDuplexController),
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            __uuidof(IAudioDuplexController),
            (void **) &m_pIAudioDuplexController
            );
        
        if (FAILED(hr))
        {
            LOG((RTC_WARN, "CRTCMedia::Initialize, create audio duplex controller. %x", hr));

            m_pIAudioDuplexController = NULL;
        }
    }

    m_pIMediaManagePriv = pMediaManagePriv;
    m_pIMediaManagePriv->AddRef();

    m_pISDPMedia = pISDPMedia;
    m_pISDPMedia->AddRef();

    m_State = RTC_MS_INITIATED;

    return S_OK;
}

STDMETHODIMP
CRTCMedia::Reinitialize()
{
    ENTER_FUNCTION("CRTCMedia::Reinitialize");

    if (m_State != RTC_MS_INITIATED)
    {
        LOG((RTC_ERROR, "%s called at state %d", __fxName, m_State));

        return E_FAIL;
    }

    for (int i=0; i<RTC_MAX_MEDIA_STREAM_NUM; i++)
    {
        if (m_Streams[i] == NULL)
            continue;

        LOG((RTC_ERROR, "%s called while streams exist", __fxName));

        return E_FAIL;
    }

    // clean up rtp session
    // not to confuse rtp filters
    m_hRTPSession = NULL;

    m_fPossibleSingleStream = TRUE;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    shutdown all streams, cleanup all cached vars
////*/

STDMETHODIMP
CRTCMedia::Shutdown()
{
    ENTER_FUNCTION("CRTCMedia::Shutdown");
    LOG((RTC_TRACE, "%s entered", __fxName));

    HRESULT hr;

    if (m_State == RTC_MS_SHUTDOWN)
    {
        LOG((RTC_WARN, "%s shutdown was called before", __fxName));
        return S_OK;
    }

    // shutdown streams before null other pointer
    // sync remove doesn't change sdpmedia
    for (int i=0; i<RTC_MAX_MEDIA_STREAM_NUM; i++)
    {
        if (m_Streams[i])
            SyncRemoveStream(i, TRUE); // true: local request
    }
    
    if (m_pISDPMedia)
    {
        m_pISDPMedia->Release();
        m_pISDPMedia = NULL;
    }

    // clear other var
    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->Release();
        m_pIAudioDuplexController = NULL;
    }

    if (m_pIMediaManagePriv)
    {
        m_pIMediaManagePriv->Release();
        m_pIMediaManagePriv = NULL;
    }

    m_State = RTC_MS_SHUTDOWN;

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
STDMETHODIMP
CRTCMedia::GetStream(
    IN RTC_MEDIA_DIRECTION Direction,
    OUT IRTCStream **ppStream
    )
{
    if (m_MediaType == RTC_MT_DATA)
        return E_NOTIMPL;

    *ppStream = m_Streams[Index(Direction)];

    if (*ppStream)
        (*ppStream)->AddRef();

    return S_OK;
}

STDMETHODIMP
CRTCMedia::GetSDPMedia(
	OUT ISDPMedia **ppISDPMedia
	)
{
    *ppISDPMedia = m_pISDPMedia;

    if (m_pISDPMedia)
        m_pISDPMedia->AddRef();

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    synchronize rtcmedia with sdpmedia
    this method guarantees that sdpmedia's directions match with valid streams
////*/
STDMETHODIMP
CRTCMedia::Synchronize(
    IN BOOL fLocal,
    IN DWORD dwDirection
    )
{
    ENTER_FUNCTION("CRTCMedia::Synchronize");
    LOG((RTC_TRACE, "%s entered", __fxName));

    _ASSERT(m_State == RTC_MS_INITIATED);

    if (m_State != RTC_MS_INITIATED)
    {
        LOG((RTC_ERROR, "%s in wrong state. %d", __fxName, m_State));
        return E_UNEXPECTED;
    }

    if (m_MediaType == RTC_MT_DATA)
    {
        // data stream
        // check if it is allowed
        if (!fLocal)
        {
            // this is a remote request
            if (S_OK != m_pIMediaManagePriv->AllowStream(m_MediaType, RTC_MD_CAPTURE))
            {
                LOG((RTC_TRACE, "%s data stream not allowed", __fxName));

                // we should remove the sdpmedia
                m_pISDPMedia->RemoveDirections(SDP_SOURCE_LOCAL, (DWORD)dwDirection);

                return S_OK;
            }
        }
            
        return SyncDataMedia();
    }

    HRESULT hr = S_OK, hrTmp = S_OK;

    // get media directions
    _ASSERT(m_pISDPMedia != NULL);

    DWORD dwDir;
    
    // shouldn't fail
    if (FAILED(hr = m_pISDPMedia->GetDirections(SDP_SOURCE_LOCAL, &dwDir)))
        return hr;

    RTC_MEDIA_DIRECTION Direction;

    //
    // hack for checking if AEC might be needed
    //

    // remote but not both directions present
    if (!fLocal &&  // remote
        !((dwDir & RTC_MD_CAPTURE) && (dwDir & RTC_MD_RENDER))) // not bi-directional
    {
        m_fPossibleSingleStream = TRUE;
    }
    else
    {
        // both directions allowed?
        if (S_OK != m_pIMediaManagePriv->AllowStream(m_MediaType, RTC_MD_CAPTURE) ||
            S_OK != m_pIMediaManagePriv->AllowStream(m_MediaType, RTC_MD_RENDER))
        {
            m_fPossibleSingleStream = TRUE;
        }
        else
        {
            // have both devices?
            CRTCMediaController *pController = static_cast<CRTCMediaController*>(m_pIMediaManagePriv);
        
            CComPtr<IRTCTerminal> pCapture;
            CComPtr<IRTCTerminal> pRender;

            hr = pController->GetDefaultTerminal(m_MediaType, RTC_MD_CAPTURE, &pCapture);

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s get terminal mt=%d, md=capt. %x",
                        __fxName, m_MediaType, hr));

                return hr;
            }

            hr = pController->GetDefaultTerminal(m_MediaType, RTC_MD_RENDER, &pRender);

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s get terminal mt=%d, md=rend. %x",
                        __fxName, m_MediaType, hr));

                return hr;
            }

            if (pCapture == NULL || pRender == NULL)
            {
                m_fPossibleSingleStream = TRUE;
            }
            else
            {
                m_fPossibleSingleStream = FALSE;
            }
        }
    }

    for (UINT i=0; i<RTC_MAX_MEDIA_STREAM_NUM; i++)
    {
        // direction
        Direction = ReverseIndex(i);

        // only sync streams which need to sync
        if (!(Direction & dwDirection))
            continue;

        if (Direction & dwDir)
        {
            // sdpmedia has the direction

            if (m_Streams[i])
            {
                // stream exists
                if (FAILED(hrTmp = m_Streams[i]->Synchronize()))
                {
                    LOG((RTC_ERROR, "%s failed to sync stream. mt=%x, md=%x. hr=%x",
                         __fxName, m_MediaType, Direction, hrTmp));

                    // clear rtc stream and sdp media direction
                    SyncRemoveStream(i, fLocal);
                    m_pISDPMedia->RemoveDirections(SDP_SOURCE_LOCAL, (DWORD)Direction);

                    hr |= hrTmp;
                }
            }
            else
            {
                // no stream, need to create one

                // but need to check if we are allowed to create
                if (fLocal ||
                    S_OK == m_pIMediaManagePriv->AllowStream(m_MediaType, Direction))
                {
                    // this is a local request or we are allowed
                    if (FAILED(hrTmp = SyncAddStream(i, fLocal)))
                    {
                        LOG((RTC_ERROR, "%s failed to sync create stream. mt=%x, md=%x, hr=%x",
                             __fxName, m_MediaType, Direction, hrTmp));

                        // remove sdp media direction
                        m_pISDPMedia->RemoveDirections(SDP_SOURCE_LOCAL, (DWORD)Direction);

                        hr |= hrTmp;
                    }
                }
                else
                {
                    if (!fLocal)
                    {
                        // this is a remote request and the stream is not needed
                        // we should remove the sdpmedia
                        m_pISDPMedia->RemoveDirections(SDP_SOURCE_LOCAL, (DWORD)Direction);

                        hr = S_OK;
                    }
                }
            }
        }
        else
        {
            // sdpmedia doesn't have the direction

            if (m_Streams[i])
            {
                // stream exists, need to remove it
                SyncRemoveStream(i, fLocal);
            }
        }
    } // for each stream

    // do we have any stream
    BOOL fHasStream = FALSE;

    for (UINT i=0; i<RTC_MAX_MEDIA_STREAM_NUM; i++)
    {
        if (m_Streams[i] != NULL)
        {
            fHasStream = TRUE;
            break;
        }
    }

    if (!fHasStream)
    {
        // reinit media
        Reinitialize();
    }

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return hr;
}

//
// protected methods
//

HRESULT
CRTCMedia::SyncAddStream(
    IN UINT uiIndex,
    IN BOOL fLocal
    )
{
    ENTER_FUNCTION("CRTCMedia::SyncAddStream");

    if (m_MediaType == RTC_MT_DATA)
        return E_NOTIMPL;

    _ASSERT(uiIndex < RTC_MAX_MEDIA_STREAM_NUM);
    _ASSERT(m_Streams[uiIndex] == NULL);

    RTC_MEDIA_DIRECTION dir = ReverseIndex(uiIndex);

    // create stream object
    IRTCStream *pStream;

    HRESULT hr = CRTCStream::CreateInstance(m_MediaType, dir, &pStream);
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to create stream.", __fxName));

        m_pIMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_FAIL,
            RTC_ME_CAUSE_UNKNOWN,
            m_MediaType,
            dir,
            hr
            );

        return hr;
    }

    // initiate the stream
    IRTCMedia *pMedia = static_cast<IRTCMedia*>(this);

    if (FAILED(hr = pStream->Initialize(pMedia, m_pIMediaManagePriv)))
    {
        LOG((RTC_ERROR, "%s failed to initiate stream.", __fxName));

        pStream->Release();

        m_pIMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_FAIL,
            RTC_ME_CAUSE_UNKNOWN,
            m_MediaType,
            dir,
            hr
            );

        return hr;
    }

    // remember the stream
    m_Streams[uiIndex] = pStream;

    // configure stream:
    if (FAILED(hr = pStream->Synchronize()))
    {
        LOG((RTC_ERROR, "%s failed to synchronize stream. %x", __fxName, hr));

        // remove stream
        pStream->Shutdown();
        pStream->Release();
        m_Streams[uiIndex] = NULL;

        //m_pIMediaManagePriv->PostMediaEvent(
            //RTC_ME_STREAM_FAIL,
            //RTC_ME_CAUSE_UNKNOWN,
            //m_MediaType,
            //dir,
            //hr
            //);
    }
    else
    {
        // hook the stream
        if (FAILED(hr = m_pIMediaManagePriv->HookStream(pStream)))
        {
            LOG((RTC_ERROR, "%s failed to hook stream. mt=%x, md=%x, hr=%x",
                 __fxName, m_MediaType, dir, hr));

            // remove stream
            pStream->Shutdown();
            pStream->Release();
            m_Streams[uiIndex] = NULL;

            m_pIMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_FAIL,
                hr==RTCMEDIA_E_CRYPTO?RTC_ME_CAUSE_CRYPTO:RTC_ME_CAUSE_UNKNOWN,
                m_MediaType,
                dir,
                hr
                );
        }
    }

    if (S_OK == hr)
    {
        // post message
        m_pIMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_CREATED,
            fLocal?RTC_ME_CAUSE_LOCAL_REQUEST:RTC_ME_CAUSE_REMOTE_REQUEST,
            m_MediaType,
            dir,
            S_OK
            );
    }
    else
    {
        // do we have any stream
        BOOL fHasStream = FALSE;

        for (UINT i=0; i<RTC_MAX_MEDIA_STREAM_NUM; i++)
        {
            if (m_Streams[i] != NULL)
            {
                fHasStream = TRUE;
                break;
            }
        }

        if (!fHasStream)
        {
            // reinit media
            Reinitialize();
        }
    }

    return hr;
}

HRESULT
CRTCMedia::SyncRemoveStream(
    IN UINT uiIndex,
    IN BOOL fLocal
    )
{
    ENTER_FUNCTION("CRTCMedia::SyncRemoveStream");

    if (m_MediaType == RTC_MT_DATA)
        return E_NOTIMPL;

    _ASSERT(uiIndex < RTC_MAX_MEDIA_STREAM_NUM);

    RTC_MEDIA_DIRECTION dir = ReverseIndex(uiIndex);

    // unhook the stream
    HRESULT hr1 = m_pIMediaManagePriv->UnhookStream(m_Streams[uiIndex]);

    if (FAILED(hr1))
    {
        LOG((RTC_ERROR, "%s failed to unhook stream %p. hr=%x", __fxName, m_Streams[uiIndex], hr1));
        
        // we are having serious trouble
    }

    HRESULT hr2 = m_Streams[uiIndex]->Shutdown();

    if (FAILED(hr2))
    {
        LOG((RTC_ERROR, "%s failed to shutdown stream %p. hr=%x", __fxName, m_Streams[uiIndex], hr2));
    }

    m_Streams[uiIndex]->Release();
    m_Streams[uiIndex] = NULL;

    // post event
    m_pIMediaManagePriv->PostMediaEvent(
        RTC_ME_STREAM_REMOVED,
        fLocal?RTC_ME_CAUSE_LOCAL_REQUEST:RTC_ME_CAUSE_REMOTE_REQUEST,
        m_MediaType,
        dir,
        hr1 | hr2
        );

    return S_OK;
}

UINT
CRTCMedia::Index(
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    if (Direction == RTC_MD_CAPTURE)
        return 0;
    else
        return 1;
}

RTC_MEDIA_DIRECTION
CRTCMedia::ReverseIndex(
    IN UINT uiIndex
    )
{
    _ASSERT(uiIndex < RTC_MAX_MEDIA_STREAM_NUM);

    if (uiIndex == 0)
        return RTC_MD_CAPTURE;
    else
        return RTC_MD_RENDER;
}

// synchronize data stream
HRESULT
CRTCMedia::SyncDataMedia()
{
    ENTER_FUNCTION("CRTCMedia::SyncDataMedia");

    LOG((RTC_TRACE, "%s entered", __fxName));

    _ASSERT(m_MediaType == RTC_MT_DATA);

    // media controller
    CRTCMediaController *pController =
        static_cast<CRTCMediaController*>(m_pIMediaManagePriv);

    //
    // cannot support data media when port manager is in use
    //
    CPortCache &PortCache = pController->GetPortCache();

    if (!PortCache.IsUpnpMapping())
    {
        return pController->RemoveDataStream();
    }

    DWORD md;

    // local direction
    m_pISDPMedia->GetDirections(SDP_SOURCE_LOCAL, &md);

    // remote ip, port
    DWORD dwRemoteIP, dwLocalIP;
    USHORT usRemotePort, usLocalPort;

    m_pISDPMedia->GetConnAddr(SDP_SOURCE_REMOTE, &dwRemoteIP);
    m_pISDPMedia->GetConnPort(SDP_SOURCE_REMOTE, &usRemotePort);

    // check stream state
    RTC_STREAM_STATE state;

    pController->GetDataStreamState(&state);

    // check remote addr
    HRESULT hr;

    if (dwRemoteIP == INADDR_NONE ||
        (usRemotePort == 0 && state != RTC_SS_CREATED))
    {
        // need to remove data stream
        hr = pController->RemoveDataStream();

        return hr;
    }

    //if (state == RTC_SS_STARTED)
    //{
        //return S_OK;
    //}

    // prepare netmeeting
    pController->EnsureNmRunning(TRUE);

    // netmeeting manager controller
    CComPtr<IRTCNmManagerControl> pNmManager;
    
    pNmManager.Attach(pController->GetNmManager());

    if (pNmManager == NULL)
    {
        // no netmeeting
        LOG((RTC_ERROR, "%s null nmmanager", __fxName));
        
        m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

        return E_UNEXPECTED;
    }

    CNetwork *pNetwork = NULL;
    BOOL bInternal = TRUE;

    // check if remote ip, port  are actually internally addr
    {
        DWORD dwRealIP = dwRemoteIP;
        USHORT usRealPort = usRemotePort;

        pNetwork =
        (static_cast<CRTCMediaController*>(m_pIMediaManagePriv))->GetNetwork();

        if (FAILED(hr = pNetwork->GetRealAddrFromMapped(
                    dwRemoteIP,
                    usRemotePort,
                    &dwRealIP,
                    &usRealPort,
                    &bInternal,
                    FALSE   // TCP
                    )))
        {
            LOG((RTC_ERROR, "%s get real addr. %x", __fxName, hr));

            m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

            return hr;
        }

        if (usRemotePort == 0)
        {
            // revert to port 0
            usRealPort = 0;
        }

        // save address back
        dwRemoteIP = dwRealIP;
        usRemotePort = usRealPort;
    }

    // local ip, port
    m_pISDPMedia->GetConnAddr(SDP_SOURCE_LOCAL, &dwLocalIP);
    m_pISDPMedia->GetConnPort(SDP_SOURCE_LOCAL, &usLocalPort);

    // do we need to select local interface?
    if (dwLocalIP == INADDR_NONE)
    {
        if (FAILED(hr = m_pIMediaManagePriv->SelectLocalInterface(
                dwRemoteIP, &dwLocalIP)))
        {
            LOG((RTC_ERROR, "%s select local intf on remote %x. %x",
                 __fxName, dwRemoteIP, hr));

            m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

            return hr;
        }

        usLocalPort = NETMEETING_PORT;
    }
    else
    {
        if (usLocalPort != NETMEETING_PORT)
        {
            LOG((RTC_ERROR, "%s local ip=%x, port=%d", __fxName, dwLocalIP, usLocalPort));

            m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

            return E_UNEXPECTED;
        }
    }

    BOOL bFirewall = (static_cast<CRTCMediaController*>
            (m_pIMediaManagePriv))->IsFirewallEnabled(dwLocalIP);

    // lease address
    if (!bInternal || bFirewall)
    {
        DWORD dw;
        USHORT us, us2;

        if (FAILED(hr = pNetwork->LeaseMappedAddr2(
                dwLocalIP,
                usLocalPort,
                0,
                md&RTC_MD_CAPTURE?RTC_MD_CAPTURE:RTC_MD_RENDER,
                bInternal,
                bFirewall,
                &dw,
                &us,
                &us2,
                FALSE)))    // TCP
        {
            m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

            LOG((RTC_ERROR, "%s lease mapping. %x", __fxName, hr));

            return hr;
        }
    }
    else
    {
        // remote IP internal, release local map
        pNetwork->ReleaseMappedAddr2(
            dwLocalIP,
            usLocalPort,
            0,
            md&RTC_MD_CAPTURE?RTC_MD_CAPTURE:RTC_MD_RENDER
            );
    }

    if (usRemotePort != 0)
    {
        // port is set so setup netmeeting
        if (md & RTC_MD_CAPTURE)
        {
            CComBSTR    bstr;
            CHAR        pszPort[10];

            wsprintfA(pszPort, ":%d", usRemotePort);

            // ip:port
            bstr = CNetwork::GetIPAddrString(dwRemoteIP);
            bstr += pszPort;

            if (NULL == (BSTR)bstr)
            {
                LOG((RTC_ERROR, "%s outofmemory", __fxName));

                m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

                return E_OUTOFMEMORY;
            }

            // create outgoing call
            hr = pNmManager->CreateT120OutgoingCall (
                NM_ADDR_T120_TRANSPORT,
                bstr
                );

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s createt120 outgoing call. %x", __fxName, hr));

                m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

                return hr;
            }
        }
        else
        {
            if (FAILED(hr = pNmManager->AllowIncomingCall ()))
            {
                LOG((RTC_ERROR, "%s failed to allow incoming call", __fxName));

                m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, 0);

                return hr;
            }

            m_pISDPMedia->AddDirections(SDP_SOURCE_LOCAL, RTC_MD_RENDER);
        }
    }

    // remember local ip and port
    m_pISDPMedia->SetConnAddr(SDP_SOURCE_LOCAL, dwLocalIP);
    m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, usLocalPort);

    // change data stream state
    if (usRemotePort != 0)
    {
        pController->SetDataStreamState(RTC_SS_RUNNING);
    }
    else
    {
        // remote port 0, just added stream
        pController->SetDataStreamState(RTC_SS_CREATED);
    }

    LOG((RTC_TRACE, "local %s, port %d",
        CNetwork::GetIPAddrString(dwLocalIP), usLocalPort));
    LOG((RTC_TRACE, "remote %s, port %d",
        CNetwork::GetIPAddrString(dwRemoteIP), usRemotePort));

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\mediacache.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    MediaController.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 9-Aug-2000

--*/

#include "stdafx.h"

CRTCMediaCache::CRTCMediaCache()
    :m_fInitiated(FALSE)
    ,m_fShutdown(FALSE)
    ,m_hMixerCallbackWnd(NULL)
    ,m_AudCaptMixer(NULL)
    ,m_AudRendMixer(NULL)
    ,m_pVideoPreviewTerminal(NULL)
{
    ZeroMemory(m_Preferred, sizeof(BOOL)*RTC_MAX_ACTIVE_STREAM_NUM);

    ZeroMemory(m_DefaultTerminals, sizeof(IRTCTerminal*)*RTC_MAX_ACTIVE_STREAM_NUM);

    ZeroMemory(m_WaitHandles, sizeof(HANDLE)*RTC_MAX_ACTIVE_STREAM_NUM);

    ZeroMemory(m_WaitStreams, sizeof(IRTCStream*)*RTC_MAX_ACTIVE_STREAM_NUM);
}

CRTCMediaCache::~CRTCMediaCache()
{
    if (m_fInitiated && !m_fShutdown)
        Shutdown();
}

VOID
CRTCMediaCache::Initialize(
    IN HWND hMixerCallbackWnd,
    IN IRTCTerminal *pVideoRender,
    IN IRTCTerminal *pVideoPreiew
    )
{
    UINT iVidRend = Index(RTC_MT_VIDEO, RTC_MD_RENDER);

    m_hMixerCallbackWnd = hMixerCallbackWnd;

    // initiate member var
    for (int i=0; i<RTC_MAX_ACTIVE_STREAM_NUM; i++)
    {
        // no stream is allowed
        m_Preferred[i] = FALSE;

        m_DefaultTerminals[i] = NULL;

        m_WaitHandles[i] = NULL;

        m_WaitStreams[i] = NULL;
    }

    m_DefaultTerminals[iVidRend] = pVideoRender;
    m_DefaultTerminals[iVidRend]->AddRef();

    m_pVideoPreviewTerminal = pVideoPreiew;
    m_pVideoPreviewTerminal->AddRef();

    m_fInitiated = TRUE;
}

/*//////////////////////////////////////////////////////////////////////////////
    reinitialize cleans everything except preferred flags
////*/
VOID
CRTCMediaCache::Reinitialize()
{
    _ASSERT(m_fInitiated);

    //int index = Index(RTC_MT_VIDEO, RTC_MD_RENDER);

    for (int i=0; i<RTC_MAX_ACTIVE_STREAM_NUM; i++)
    {
        //m_Preferred[i] = FALSE;

        if (m_WaitStreams[i])
        {
            // stream exists
            _ASSERT(m_WaitHandles[i]);
            // _ASSERT(m_DefaultTerminals[i]);

            if (!::UnregisterWaitEx(m_WaitHandles[i], (HANDLE)-1))
            {
                LOG((RTC_ERROR, "media cache failed to unregister wait for %dth stream. err=%d",
                     i, GetLastError()));
            }

            m_WaitHandles[i] = NULL;

            m_WaitStreams[i]->Release();
            m_WaitStreams[i] = NULL;
        }

        _ASSERT(!m_WaitHandles[i]);

        // do not release default static terminal
        //if (index != i && m_DefaultTerminals[i])
        //{
        //    m_DefaultTerminals[i]->Release();
        //    m_DefaultTerminals[i] = NULL;
        //}

        m_Key[i].Empty();
    }
}

VOID
CRTCMediaCache::Shutdown()
{
    if (m_fShutdown)
    {
        LOG((RTC_WARN, "CRTCMediaCache::Shutdown called already."));

        return;
    }

    Reinitialize();

    // shutdown video render terminal
    CRTCTerminal *pCTerminal;

    UINT index = Index(RTC_MT_VIDEO, RTC_MD_RENDER);

    if (m_DefaultTerminals[index])
    {
        pCTerminal = static_cast<CRTCTerminal*>(m_DefaultTerminals[index]);
        pCTerminal->Shutdown();
    }

    // close mixers
    index = Index(RTC_MT_AUDIO, RTC_MD_CAPTURE);

    if (m_DefaultTerminals[index])
    {
        // close the mixer
        CloseMixer(RTC_MD_CAPTURE);
    }

    index = Index(RTC_MT_AUDIO, RTC_MD_RENDER);

    if (m_DefaultTerminals[index])
    {
        // close the mixer
        CloseMixer(RTC_MD_RENDER);
    }

    // release all terminals
    for (int i=0; i<RTC_MAX_ACTIVE_STREAM_NUM; i++)
    {
        if (m_DefaultTerminals[i])
        {
            m_DefaultTerminals[i]->Release();
            m_DefaultTerminals[i] = NULL;
        }
    }

    // release video preview terminal
    pCTerminal = static_cast<CRTCTerminal*>(m_pVideoPreviewTerminal);
    pCTerminal->Shutdown();
    m_pVideoPreviewTerminal->Release();
    m_pVideoPreviewTerminal = NULL;

    m_fShutdown = TRUE;
}

//
// preference related methods
//

/*//////////////////////////////////////////////////////////////////////////////
    mark which streams (type+direction) are allowed to create when receiving
    a SDP.

    the method fail only when a desired stream does not have a default static
    terminal.
////*/

BOOL
CRTCMediaCache::SetPreference(
    IN DWORD dwPreference
    )
{
    UINT iData = Index(RTC_MP_DATA_SENDRECV);
    
    ENTER_FUNCTION("CRTCMediaCache::SetPreference");

    LOG((RTC_TRACE, "%s dwPreference=%x", __fxName, dwPreference));

    BOOL fSuccess = TRUE;

    for (UINT i=0; i<RTC_MAX_ACTIVE_STREAM_NUM; i++)
    {
        if (HasIndex(dwPreference, i))
        {
            // we don't have a static term but we should,
            if (iData != i && m_DefaultTerminals[i] == NULL)
            {
                LOG((RTC_WARN, "%s no default terminal on %dth stream",
                     __fxName, i));

                fSuccess = FALSE;
                continue;
            }

            // allow this media
            m_Preferred[i] = TRUE;
        }
        else
        {
            m_Preferred[i] = FALSE;
        }
    }

    return fSuccess;
}

/*//////////////////////////////////////////////////////////////////////////////
    return preferred medias
////*/

VOID
CRTCMediaCache::GetPreference(
    OUT DWORD *pdwPreference
    )
{
    *pdwPreference = 0;

    for (UINT i=0; i<RTC_MAX_ACTIVE_STREAM_NUM; i++)
    {
        if (m_Preferred[i])
        {
            // this media is allowed
            *pdwPreference |= ReverseIndex(i);
        }
    }

    return;
}

/*//////////////////////////////////////////////////////////////////////////////
    add preferred medias
////*/
BOOL
CRTCMediaCache::AddPreference(
    IN DWORD dwPreference
    )
{
    DWORD dwPref;

    // get current setting, append the input setting
    GetPreference(&dwPref);

    dwPref |= dwPreference;

    return SetPreference(dwPref);
}

BOOL
CRTCMediaCache::RemovePreference(
    IN DWORD dwPreference
    )
{
    DWORD dwPref;

    GetPreference(&dwPref);

    dwPref &= (~dwPreference);

    return SetPreference(dwPref);
}

DWORD
CRTCMediaCache::TranslatePreference(
    RTC_MEDIA_TYPE MediaType,
    RTC_MEDIA_DIRECTION Direction
    )
{
    DWORD dwPref = 0;

    if (MediaType == RTC_MT_AUDIO)
    {
        if (Direction == RTC_MD_CAPTURE)
            dwPref = (DWORD)RTC_MP_AUDIO_CAPTURE;
        else if (Direction == RTC_MD_RENDER)
            dwPref = (DWORD)RTC_MP_AUDIO_RENDER;
    }
    else if (MediaType == RTC_MT_VIDEO)
    {
        if (Direction == RTC_MD_CAPTURE)
            dwPref = (DWORD)RTC_MP_VIDEO_CAPTURE;
        else if (Direction == RTC_MD_RENDER)
            dwPref = (DWORD)RTC_MP_VIDEO_RENDER;
    }
    else if (MediaType == RTC_MT_DATA)
    {
        dwPref = (DWORD)RTC_MP_DATA_SENDRECV;
    }

    return dwPref;
}

/*//////////////////////////////////////////////////////////////////////////////
    check if the stream is allowed
////*/
BOOL
CRTCMediaCache::AllowStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    return m_Preferred[Index(MediaType, Direction)];
}


//
// stream related methods
//

BOOL
CRTCMediaCache::HasStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    int i = Index(MediaType, Direction);

    if (m_WaitStreams[i])
    {
        _ASSERT(m_WaitHandles[i]);
        return TRUE;
    }
    else
        return FALSE;
}

/*//////////////////////////////////////////////////////////////////////////////\
    cache the stream, change preferred if not set, register wait
////*/

HRESULT
CRTCMediaCache::HookStream(
    IN IRTCStream *pStream
    )
{
    ENTER_FUNCTION("CRTCMediaCache::HookStream");

    LOG((RTC_TRACE, "%s entered. irtcstream=%p", __fxName, pStream));

    HRESULT hr;
    RTC_MEDIA_TYPE MediaType;
    RTC_MEDIA_DIRECTION Direction;

    // get media type and direction
    if (FAILED(hr = pStream->GetMediaType(&MediaType)) ||
        FAILED(hr = pStream->GetDirection(&Direction)))
    {
        LOG((RTC_ERROR, "%s get mediatype or direction. hr=%x", __fxName, hr));

        return hr;
    }

    UINT i = Index(MediaType, Direction);

    // do we already have a stream
    if (m_WaitStreams[i])
    {
        LOG((RTC_ERROR, "%s already had %dth stream %p.",
             __fxName, i, m_WaitStreams[i]));

        return E_UNEXPECTED;
    }

    // we should have a terminal
    if (m_DefaultTerminals[i] == NULL)
    {
        LOG((RTC_ERROR, "%s no default terminal at %d", __fxName, i));

        return RTCMEDIA_E_DEFAULTTERMINAL;
    }

    // set encryption key
    if (m_Key[i] != NULL)
    {
        if (FAILED(hr = pStream->SetEncryptionKey(m_Key[i])))
        {
            LOG((RTC_ERROR, "%s set encryption key. %x", __fxName, hr));

            return RTCMEDIA_E_CRYPTO;
        }
    }

    // register a wait

            // get media event
    IMediaEvent *pIMediaEvent;
    if (FAILED(hr = pStream->GetIMediaEvent((LONG_PTR**)&pIMediaEvent)))
    {
        LOG((RTC_ERROR, "%s failed to get media event. %x", __fxName, hr));

        return hr;
    }

            // get event
    HANDLE hEvent;
    if (FAILED(hr = pIMediaEvent->GetEventHandle((OAEVENT*)&hEvent)))
    {
        LOG((RTC_ERROR, "%s failed to get event handle. %x", __fxName, hr));

        pIMediaEvent->Release();
        return hr;
    }

            // register wait
    if (!RegisterWaitForSingleObject(
        &m_WaitHandles[i],
        hEvent,
        CRTCStream::GraphEventCallback,
        pStream,
        INFINITE,
        WT_EXECUTEINWAITTHREAD
        ))
    {
        LOG((RTC_ERROR, "%s register wait failed. %x", __fxName, GetLastError()));

        pIMediaEvent->Release();
        m_WaitHandles[i] = NULL;
        return hr;
    }

    // cache the stream
    pIMediaEvent->Release();

    pStream->AddRef();
    m_WaitStreams[i] = pStream;

    // update preferred if necessary
    m_Preferred[i] = TRUE;

    LOG((RTC_TRACE, "%s exiting. irtcstream=%p", __fxName, pStream));

    return S_OK;
}


HRESULT
CRTCMediaCache::UnhookStream(
    IN IRTCStream *pStream
    )
{
    ENTER_FUNCTION("CRTCMediaCache::UnhookStream");

    LOG((RTC_TRACE, "%s entered. irtcstream=%p", __fxName, pStream));

    HRESULT hr;
    RTC_MEDIA_TYPE MediaType;
    RTC_MEDIA_DIRECTION Direction;

    // get media type and direction
    if (FAILED(hr = pStream->GetMediaType(&MediaType)) ||
        FAILED(hr = pStream->GetDirection(&Direction)))
    {
        LOG((RTC_ERROR, "%s get mediatype or direction. hr=%x", __fxName, hr));

        return hr;
    }

    UINT i = Index(MediaType, Direction);

    // check if stream matches
    if (m_WaitStreams[i] != pStream)
    {
        LOG((RTC_ERROR, "%s irtcstream input %p, cached %p not match",
             __fxName, pStream, m_WaitStreams[i]));

        return E_UNEXPECTED;
    }

    // stream exists
    _ASSERT(m_WaitHandles[i]);
    // _ASSERT(m_DefaultTerminals[i]);

    if (!UnregisterWaitEx(m_WaitHandles[i], (HANDLE)-1))
    {
        LOG((RTC_ERROR, "media cache failed to unregister wait for %dth stream. err=%d",
             __fxName, GetLastError()));
    }

    // release refcount
    m_WaitStreams[i]->Release();
    m_WaitStreams[i] = NULL;

    m_WaitHandles[i] = NULL;

    LOG((RTC_TRACE, "%s exiting. irtcstream=%p", __fxName, pStream));

    return S_OK;
}

IRTCStream *
CRTCMediaCache::GetStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    UINT i = Index(MediaType, Direction);

    if (m_WaitStreams[i])
    {
        m_WaitStreams[i]->AddRef();
    }

    return m_WaitStreams[i];
}

HRESULT
CRTCMediaCache::SetEncryptionKey(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    BSTR Key
    )
{
    m_Key[Index(MediaType, Direction)] = Key;

    if (!(m_Key[Index(MediaType, Direction)] == Key))
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CRTCMediaCache::GetEncryptionKey(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    BSTR *pKey
    )
{
    return m_Key[Index(MediaType, Direction)].CopyTo(pKey);
}

//
// default terminal related methods
//

IRTCTerminal *
CRTCMediaCache::GetDefaultTerminal(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    UINT i = Index(MediaType, Direction);

    if (m_DefaultTerminals[i])
    {
        m_DefaultTerminals[i]->AddRef();
    }

    return m_DefaultTerminals[i];
}

IRTCTerminal *
CRTCMediaCache::GetVideoPreviewTerminal()
{
    _ASSERT(m_pVideoPreviewTerminal);

    m_pVideoPreviewTerminal->AddRef();
    return m_pVideoPreviewTerminal;
}

/*//////////////////////////////////////////////////////////////////////////////
    OldTerminal     NewTerminal     Stream  ActionOnStream
    ------------------------------------------------------
                                    NULL    NONE
                                    Stream  ChangeTerminal
////*/
VOID
CRTCMediaCache::SetDefaultStaticTerminal(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN IRTCTerminal *pTerminal
    )
{
    _ASSERT(MediaType != RTC_MT_VIDEO || Direction != RTC_MD_RENDER);

    UINT i = Index(MediaType, Direction);

#ifdef ENABLE_TRACING

    // logging purpose
    if (pTerminal)
    {
        WCHAR *pDesp = NULL;

        if (S_OK == pTerminal->GetDescription(&pDesp))
        {
            LOG((RTC_TRACE, "SetDefaultStaticTerminal: mt=%x, md=%x, desp=%ws",
                 MediaType, Direction, pDesp));

            pTerminal->FreeDescription(pDesp);
        }
    }
    else
    {
        LOG((RTC_TRACE, "SetDefaultStaticTerminal: mt=%x, md=%x, NULL",
             MediaType, Direction));
    }

#endif

    // update the terminal
    if (m_DefaultTerminals[i])
    {
        if (MediaType == RTC_MT_AUDIO)
        {
            // close the mixer
            CloseMixer(Direction);
        }

        m_DefaultTerminals[i]->Release();
    }

    if (pTerminal)
        pTerminal->AddRef();

    m_DefaultTerminals[i] = pTerminal;

    if (m_WaitStreams[i])
    {
        // we have stream running
        HRESULT hr = m_WaitStreams[i]->ChangeTerminal(pTerminal);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%dth stream failed to change terminal %p", i, pTerminal));
        }
    }

    HRESULT hr;

    if (MediaType == RTC_MT_AUDIO &&
        pTerminal != NULL)
    {
        // open the mixer
        if (FAILED(hr = OpenMixer(Direction)))
        {
            LOG((RTC_ERROR, "SetDefaultStaticTerminal: mt=%d, md=%d, open mixer %x",
                 MediaType, Direction, hr));
        }
    }
}

//
// Protected methods
//

UINT
CRTCMediaCache::Index(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    if (MediaType == RTC_MT_AUDIO)
    {
        if (Direction == RTC_MD_CAPTURE)
            // aud cap
            return Index(RTC_MP_AUDIO_CAPTURE);
        else
            // aud rend
            return Index(RTC_MP_AUDIO_RENDER);
    }
    else if (MediaType == RTC_MT_VIDEO) // video
    {
        if (Direction == RTC_MD_CAPTURE)
            // vid cap
            return Index(RTC_MP_VIDEO_CAPTURE);
        else
            // vid rend
            return Index(RTC_MP_VIDEO_RENDER);
    }
    else
    {
        // data
        return Index(RTC_MP_DATA_SENDRECV);
    }            
}

UINT
CRTCMediaCache::Index(
    IN RTC_MEDIA_PREFERENCE Preference
    )
{
    switch (Preference)
    {
    case RTC_MP_AUDIO_CAPTURE:

        return 0;

    case RTC_MP_AUDIO_RENDER:

        return 1;

    case RTC_MP_VIDEO_CAPTURE:

        return 2;

    case RTC_MP_VIDEO_RENDER:

        return 3;

    case RTC_MP_DATA_SENDRECV:

        return 4;
    default:
        
        _ASSERT(FALSE);

        return 0;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    check if input media types and directions contains the index associated
    media type and direction
////*/
BOOL
CRTCMediaCache::HasIndex(
    IN DWORD dwPreference,
    IN UINT uiIndex
    )
{
    _ASSERT(uiIndex < RTC_MAX_ACTIVE_STREAM_NUM);

    return (dwPreference & ReverseIndex(uiIndex));
}

RTC_MEDIA_PREFERENCE
CRTCMediaCache::ReverseIndex(
    IN UINT uiIndex
    )
{
    _ASSERT(uiIndex < RTC_MAX_ACTIVE_STREAM_NUM);

    switch(uiIndex)
    {
    case 0:

        return RTC_MP_AUDIO_CAPTURE;

    case 1:

        return RTC_MP_AUDIO_RENDER;

    case 2:

        return RTC_MP_VIDEO_CAPTURE;

    case 3:

        return RTC_MP_VIDEO_RENDER;

    case 4:

        return RTC_MP_DATA_SENDRECV;

    default:

        _ASSERT(FALSE);
        return RTC_MP_AUDIO_CAPTURE;

    }
}

/*//////////////////////////////////////////////////////////////////////////////
    open a mixer with the callback window
////*/

HRESULT
CRTCMediaCache::OpenMixer(
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("CRTCMediaCache::OpenMixer");

    // terminal index
    UINT index = Index(RTC_MT_AUDIO, Direction);

    _ASSERT(m_DefaultTerminals[index]);

    UINT waveid;            // step 1, get wave id
    DWORD flag;

    HMIXEROBJ mixerid;      // step 2, get mixer id

    HMIXER *pmixer;         // step 3, open mixer

    if (Direction == RTC_MD_CAPTURE)
    {
        _ASSERT(m_AudCaptMixer == NULL);

        pmixer = &m_AudCaptMixer;
        flag = MIXER_OBJECTF_WAVEIN;
    }
    else
    {
        _ASSERT(m_AudRendMixer == NULL);

        pmixer = &m_AudRendMixer;
        flag = MIXER_OBJECTF_WAVEOUT;
    }

    // QI audio configure
    CComPtr<IRTCAudioConfigure> pAudio;

    HRESULT hr = m_DefaultTerminals[index]->QueryInterface(
        __uuidof(IRTCAudioConfigure),
        (void**)&pAudio
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s QI audio configure. %x", __fxName, hr));

        return hr;
    }
        
    // get wave id
    hr = pAudio->GetWaveID(&waveid);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get wave id", __fxName));

        return hr;
    }

    // get mixer id
    MMRESULT mmr = mixerGetID(
        (HMIXEROBJ)IntToPtr(waveid),
        (UINT*)&mixerid,
        flag
        );

    if (mmr != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get mixer id, md=%d, mmr=%d",
            __fxName, Direction, mmr));

        return HRESULT_FROM_WIN32(mmr);
    }

    // open the mixer
    mmr = mixerOpen(
        pmixer,                         // return mixer handler
        (UINT)((UINT_PTR)mixerid),      // mixer id
        (DWORD_PTR)m_hMixerCallbackWnd, // callback window
        (DWORD_PTR)0,                   // callback data
        (DWORD)CALLBACK_WINDOW          // flag
        );

    if (mmr != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s open mixer, md=%d, mmr=%d",
            __fxName, Direction, mmr));

        *pmixer = NULL;
        return HRESULT_FROM_WIN32(mmr);
    }

    return S_OK;
}

HRESULT
CRTCMediaCache::CloseMixer(
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("CRTCMediaCache::CloseMixer");

    HMIXER *pmixer;

    if (Direction == RTC_MD_CAPTURE)
    {
        pmixer = &m_AudCaptMixer;
    }
    else
    {
        pmixer = &m_AudRendMixer;
    }

    if (*pmixer == NULL)
        return S_OK;

    // close the mixer
    MMRESULT mmr = mixerClose(*pmixer);
    *pmixer = NULL;

    if (mmr != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s close mixer, md=%d, mmr=%d",
            __fxName, Direction, mmr));

        return HRESULT_FROM_WIN32(mmr);
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\mediacache.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    MediaCache.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#ifndef _MEDIACACHE_H
#define _MEDIACACHE_H

// class to hold preferences, default terminals, active medias, wait handles
class CRTCMediaCache
{
public:

    CRTCMediaCache();

    ~CRTCMediaCache();

    VOID Initialize(
        IN HWND hMixerCallbackWnd,
        IN IRTCTerminal *pVideoRender,
        IN IRTCTerminal *pVideoPreiew
        );

    VOID Reinitialize();

    VOID Shutdown();

    //
    // preference related methods
    //

    BOOL SetPreference(
        IN DWORD dwPreference
        );

    VOID GetPreference(
        OUT DWORD *pdwPreference
        );

    BOOL AddPreference(
        IN DWORD dwPreference
        );

    BOOL RemovePreference(
        IN DWORD dwPreference
        );

    BOOL AllowStream(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    DWORD TranslatePreference(
        RTC_MEDIA_TYPE MediaType,
        RTC_MEDIA_DIRECTION Direction
        );

    //
    // stream related methods
    //

    BOOL HasStream(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    HRESULT HookStream(
        IN IRTCStream *pStream
        );

    HRESULT UnhookStream(
        IN IRTCStream *pStream
        );

    IRTCStream *GetStream(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    HRESULT SetEncryptionKey(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        BSTR Key
        );

    HRESULT GetEncryptionKey(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        BSTR *pKey
        );
    
    //
    // default terminal related methods
    //

    IRTCTerminal *GetDefaultTerminal(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    IRTCTerminal *GetVideoPreviewTerminal();

    VOID SetDefaultStaticTerminal(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN IRTCTerminal *pTerminal
        );

protected:

    UINT Index(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    UINT Index(
        IN RTC_MEDIA_PREFERENCE Preference
        );

    BOOL HasIndex(
        IN DWORD dwPreference,
        IN UINT uiIndex
        );

    RTC_MEDIA_PREFERENCE ReverseIndex(
        IN UINT uiIndex
        );

    HRESULT OpenMixer(
        IN RTC_MEDIA_DIRECTION Direction
        );

    HRESULT CloseMixer(
        IN RTC_MEDIA_DIRECTION Direction
        );

protected:

#define RTC_MAX_ACTIVE_STREAM_NUM 5

    BOOL            m_fInitiated;
    BOOL            m_fShutdown;

    // flags to decide if stream is allowed
    BOOL            m_Preferred[RTC_MAX_ACTIVE_STREAM_NUM];

    // default terminals
    IRTCTerminal    *m_DefaultTerminals[RTC_MAX_ACTIVE_STREAM_NUM];

    // mixer id of default audio terminals
    HWND            m_hMixerCallbackWnd;

    HMIXER          m_AudCaptMixer;
    HMIXER          m_AudRendMixer;

    IRTCTerminal    *m_pVideoPreviewTerminal;

    // wait handle
    HANDLE          m_WaitHandles[RTC_MAX_ACTIVE_STREAM_NUM];

    // wait context: stream pointer
    IRTCStream      *m_WaitStreams[RTC_MAX_ACTIVE_STREAM_NUM];

    CComBSTR        m_Key[RTC_MAX_ACTIVE_STREAM_NUM];
};
    
#endif // _MEDIACACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\mediacontroller.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    MediaController.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#ifndef _MEDIACONTROLLER_H
#define _MEDIACONTROLLER_H

// controller state
typedef enum RTC_MEDIACONTROLLER_STATE
{
    RTC_MCS_CREATED,
    RTC_MCS_INITIATED,
    RTC_MCS_TUNING,
    RTC_MCS_INSHUTDOWN,     // for debugging
    RTC_MCS_SHUTDOWN

} RTC_MEDIACONTROLLER_STATE;


typedef enum RTC_DATASTREAM_STATE
{
    RTC_DSS_VOID,
    RTC_DSS_ADDED,
    RTC_DSS_STARTED
} RTC_DATASTREAM_STATE;

/*//////////////////////////////////////////////////////////////////////////////
    class CRTCMediaController
////*/

class ATL_NO_VTABLE CRTCMediaController :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
#ifdef RTCMEDIA_DLL
    public CComCoClass<CRTCMediaController, &CLSID_RTCMediaController>,
#endif
    public IRTCMediaManage,
    public IRTCMediaManagePriv,
    public IRTCTerminalManage,
    public IRTCTuningManage
//    public IRTCQualityControl
{
public:

#ifdef RTCMEDIA_DLL
DECLARE_REGISTRY_RESOURCEID(IDR_RTCMEDIACONTROLLER)
#endif

BEGIN_COM_MAP(CRTCMediaController)
    COM_INTERFACE_ENTRY(IRTCMediaManage)
    COM_INTERFACE_ENTRY(IRTCMediaManagePriv)
    COM_INTERFACE_ENTRY(IRTCTerminalManage)
    COM_INTERFACE_ENTRY(IRTCTuningManage)
//    COM_INTERFACE_ENTRY(IRTCQualityControl)
END_COM_MAP()

public:

    CRTCMediaController();

    ~CRTCMediaController();

#ifdef DEBUG_REFCOUNT

    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    //
    // IRTCMediaManage methods
    //

    STDMETHOD (Initialize) (
        IN HWND hWnd,
        IN UINT uiEventID
        );

    STDMETHOD (SetDirectPlayNATHelpAndSipStackInterfaces) (
        IN IUnknown *pDirectPlayNATHelp,
        IN IUnknown *pSipStack
        );
    
    STDMETHOD (Reinitialize) ();

    STDMETHOD (Shutdown) ();

    //STDMETHOD (SetSDPBlob) (
        //IN CHAR *szSDP
        //);

    STDMETHOD (GetSDPBlob) (
        IN DWORD dwSkipMask,
        OUT CHAR **pszSDP
        );

    STDMETHOD (GetSDPOption) (
        IN DWORD dwLocalIP,
        OUT CHAR **pszSDP
        );

    STDMETHOD (FreeSDPBlob) (
        IN CHAR *szSDP
        );

    STDMETHOD (ParseSDPBlob) (
        IN CHAR *szSDP,
        OUT IUnknown **ppSession
        );

    //STDMETHOD (TrySDPSession) (
        //IN IUnknown *pSession,
        //OUT DWORD *pdwHasMedia
        //);

    STDMETHOD (VerifySDPSession) (
        IN IUnknown *pSession,
        IN BOOL fNewSession,
        OUT DWORD *pdwHasMedia
        );

    STDMETHOD (SetSDPSession) (
        IN IUnknown *pSession
        );

    STDMETHOD (SetPreference) (
        IN DWORD dwPreference
        );

    STDMETHOD (GetPreference) (
        OUT DWORD *pdwPreference
        );

    STDMETHOD (AddPreference) (
        IN DWORD dwPreference
        );

    STDMETHOD (AddStream) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN DWORD dwRemoteIP
        );

    STDMETHOD (HasStream) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (RemoveStream) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (StartStream) (       
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (StopStream) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (GetStreamState) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        OUT RTC_STREAM_STATE *pState
        );

    STDMETHOD (FreeMediaEvent) (
        OUT RTCMediaEventItem *pEventItem
        );

    STDMETHOD (SendDTMFEvent) (
        IN DWORD dwId,
        IN DWORD dwEvent,
        IN DWORD dwVolume,
        IN DWORD dwDuration,
        IN BOOL fEnd
        );

    STDMETHOD (OnLossrate) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN DWORD dwLossrate
        );

    STDMETHOD (OnBandwidth) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN DWORD dwBandwidth
        );

    STDMETHOD (SetMaxBitrate)(
        IN DWORD dwMaxBitrate
        );

    STDMETHOD (GetMaxBitrate)(
        OUT DWORD *pdwMaxBitrate
        );

    STDMETHOD (SetTemporalSpatialTradeOff)(
        IN DWORD dwValue
        );

    STDMETHOD (GetTemporalSpatialTradeOff)(
        OUT DWORD *pdwValue);

    STDMETHOD (StartT120Applet) (
        IN UINT uiAppletID
            );

    STDMETHOD (StopT120Applets) ();

    STDMETHOD (SetEncryptionKey) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN BSTR Key
        );

    // network quality: [0, 100].
    // higher value better quality
    STDMETHOD (GetNetworkQuality) (
        OUT DWORD *pdwValue
        );

    STDMETHOD (IsOutOfBandDTMFEnabled) ()
    {   return (m_DTMF.GetDTMFSupport()==CRTCDTMF::DTMF_ENABLED)?S_OK:S_FALSE; }

    STDMETHOD (SetPortManager) (
        IN IUnknown *pPortManager
        );

    //
    // IRTCMediaManagePriv methods
    //

    STDMETHOD (PostMediaEvent) (
        IN RTC_MEDIA_EVENT Event,
        IN RTC_MEDIA_EVENT_CAUSE Cause,
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN HRESULT hrError
        );

    STDMETHOD (SendMediaEvent) (
        IN RTC_MEDIA_EVENT Event
        );

    STDMETHOD (AllowStream) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (HookStream) (
        IN IRTCStream *pStream
        );

    STDMETHOD (UnhookStream) (
        IN IRTCStream *pStream
        );

    STDMETHOD (SelectLocalInterface) (
        IN DWORD dwRemoteIP,
        OUT DWORD *pdwLocalIP
        );

    //
    // IRTCTerminalManage methods
    //

    STDMETHOD (GetStaticTerminals) (
        IN OUT DWORD *pdwCount,
        OUT IRTCTerminal **ppTerminal
        );

    STDMETHOD (GetDefaultTerminal) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        OUT IRTCTerminal **ppTerminal
        );

    STDMETHOD (GetVideoPreviewTerminal) (
        OUT IRTCTerminal **ppTerminal
        );

    STDMETHOD (SetDefaultStaticTerminal) (
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN IRTCTerminal *pTerminal
        );

    STDMETHOD (UpdateStaticTerminals) ();

    //
    // IRTCTuningManage methods
    //

    STDMETHOD (IsAECEnabled) (
        IN IRTCTerminal *pAudCapt,     // capture
        IN IRTCTerminal *pAudRend,     // render
        OUT BOOL *pfEnableAEC
        );

    STDMETHOD (InitializeTuning) (
        IN IRTCTerminal *pAudCaptTerminal,
        IN IRTCTerminal *pAudRendTerminal,
        IN BOOL fEnableAEC
        );

    // save AEC settting
    STDMETHOD (SaveAECSetting) ();

    STDMETHOD (ShutdownTuning) ();

    STDMETHOD (StartTuning) (
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (StopTuning) (
        IN BOOL fSaveSetting
        );

    STDMETHOD (GetVolumeRange) (
        IN RTC_MEDIA_DIRECTION Direction,
        OUT UINT *puiMin,
        OUT UINT *puiMax
        );

    STDMETHOD (GetVolume) (
        IN RTC_MEDIA_DIRECTION Direction,
        OUT UINT *puiVolume
        );

    STDMETHOD (SetVolume) (
        IN RTC_MEDIA_DIRECTION Direction,
        IN UINT uiVolume
        );

    STDMETHOD (GetAudioLevelRange) (
        IN RTC_MEDIA_DIRECTION Direction,
        OUT UINT *puiMin,
        OUT UINT *puiMax
        );

    STDMETHOD (GetAudioLevel) (
        IN RTC_MEDIA_DIRECTION Direction,
        OUT UINT *puiLevel
        );

    // video tuning
    STDMETHOD (StartVideo) (
        IN IRTCTerminal *pVidCaptTerminal,
        IN IRTCTerminal *pVidRendTerminal
        );

    STDMETHOD (StopVideo) ();

    // get system volume
    STDMETHOD (GetSystemVolume) (
        IN IRTCTerminal *pTerminal,
        OUT UINT *puiVolume
        );

#if 0
    //
    // IRTCQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN RTC_QUALITY_PROPERTY Property,
        OUT LONG *plMin,
        OUT LONG *plMax,
        OUT RTC_QUALITY_CONTROL_MODE *pMode
        );

    STDMETHOD (Get) (
        IN RTC_QUALITY_PROPERTY Property,
        OUT LONG *plValue,
        OUT RTC_QUALITY_CONTROL_MODE *pMode
        );

    STDMETHOD (Set) (
        IN RTC_QUALITY_PROPERTY Property,
        IN LONG lValue,
        IN RTC_QUALITY_CONTROL_MODE Mode
        );
#endif

    // internal helper
    CQualityControl *GetQualityControl()
    { return &m_QualityControl; }

    CNetwork *GetNetwork()
    { return &m_Network; }

    CRegSetting *GetRegSetting()
    { return &m_RegSetting; }

    HRESULT GetCurrentBitrate(
        IN DWORD dwMediaType,
        IN DWORD dwDirection,
        IN BOOL fHeader,
        OUT DWORD *pdwBitrate
        );

    IRTCNmManagerControl *GetNmManager();

    HRESULT EnsureNmRunning (
        BOOL        fNoMsgPump
        );

    HRESULT GetDataStreamState (
        OUT RTC_STREAM_STATE * pState
        );

    HRESULT SetDataStreamState (
        OUT RTC_STREAM_STATE State
        );

    HRESULT RemoveDataStream (
        );

    // local ip in host order
    BOOL IsFirewallEnabled(DWORD dwLocalIP);

    // return port cache
    CPortCache& GetPortCache()
    { return m_PortCache; }

protected:

    HRESULT GetDevices(
        OUT DWORD *pdwCount,
        OUT RTCDeviceInfo **ppDeviceInfo
        );

    HRESULT FreeDevices(
        IN RTCDeviceInfo *pDeviceInfo
        );

    HRESULT CreateIVideoWindowTerminal(
        IN ITTerminalManager *pTerminalManager,
        OUT IRTCTerminal **ppTerminal
        );

    HRESULT AddMedia(
        IN ISDPMedia *pISDPMedia,
        OUT IRTCMedia **ppMedia
        );

    HRESULT RemoveMedia(
        IN IRTCMedia *pMedia
        );

    HRESULT SyncMedias();

    HRESULT FindEmptyMedia(
        IN RTC_MEDIA_TYPE MediaType,
        OUT IRTCMedia **ppMedia
        );

    HRESULT AdjustBitrateAlloc();

    HRESULT AddDataStream (
        IN DWORD    dwRemoteIp
        );

    HRESULT StartDataStream (
        );

    HRESULT StopDataStream (
        );

    HRESULT GetDataMedia(
        OUT IRTCMedia **ppMedia
        );

protected:

    // with netmeeting t120 support
    // events will be posted from another thread
    CRTCCritSection             m_EventLock;

    RTC_MEDIACONTROLLER_STATE   m_State;

    // dxmrtp
    HMODULE                     m_hDxmrtp;

    // handle to post message
    HWND                        m_hWnd;

    // event mask
    UINT                        m_uiEventID;

    // static terminals
    CRTCArray<IRTCTerminal*>    m_Terminals;

    // sdp blob
    ISDPSession                 *m_pISDPSession;

    // medias
    CRTCArray<IRTCMedia*>       m_Medias;

    // media cache stores active streams, preferences, wait handle, etc
    CRTCMediaCache              m_MediaCache;

    // quality control
    CQualityControl             m_QualityControl;

    // audio tuner
    CRTCAudioCaptTuner          m_AudioCaptTuner;
    CRTCAudioRendTuner          m_AudioRendTuner;

    BOOL                        m_fAudCaptInTuning;

    // video tuner
    CRTCVideoTuner              m_VideoTuner;

    // socket
    SOCKET                      m_hSocket;
    SOCKET                      m_hIntfSelSock; // select local interface

    //  Netmeeting 3.0 stuff
    CComPtr<IRTCNmManagerControl>   m_pNmManager;
    RTC_DATASTREAM_STATE            m_uDataStreamState;
    DWORD                           m_dwRemoteIp;

    // if BW not report, we assume 128k for LAN.
    BOOL                        m_fBWSuggested;

    // network for NAT travesal or more network related func
    CNetwork                    m_Network;

    // out of band dtmf
    CRTCDTMF                    m_DTMF;

    // registry setting
    CRegSetting                 m_RegSetting;

    // sip stack
    CComPtr<ISipStack>          m_pSipStack;

    // port manager
    CPortCache                  m_PortCache;
};

#endif // _MEDIACONTROLLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\network.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    CNetwork.h

Abstract:

    This module wraps methods to access NAT traversal.

Author(s):

    Qianbo Huai (qhuai) 01-Mar-2000

--*/

class CNetwork
{
public:

    static const USHORT UNUSED_PORT = 0;

    static const CHAR * const GetIPAddrString(
        IN DWORD dwAddr
        );

public:

    CNetwork();

    ~CNetwork();

    // store IDirectPlayNATHelp
    HRESULT SetIDirectPlayNATHelp(
        IN IDirectPlayNATHelp *pIDirectPlayNATHelp
        );

    // mapped -> real
    HRESULT GetRealAddrFromMapped(
        IN DWORD dwMappedAddr,
        IN USHORT usMappedPort,
        OUT DWORD *pRealdwAddr,
        OUT USHORT *pRealusPort,
        OUT BOOL *pbInternal,
        IN BOOL bUDP = TRUE
        );

    // real -> mapped
    HRESULT GetMappedAddrFromReal2(
        IN DWORD dwRealAddr,
        IN USHORT usRealPort,
        IN USHORT usRealPort2,
        OUT DWORD *pdwMappedAddr,
        OUT USHORT *pusMappedPort,
        OUT USHORT *pusMappedPort2
        );

    //HRESULT LeaseMappedAddr(
        //IN DWORD dwRealAddr,
        //IN USHORT usRealPort,
        //IN RTC_MEDIA_DIRECTION Direction,
        //IN BOOL bInternal,
        //IN BOOL bFirewall,
        //OUT DWORD *pdwMappedAddr,
        //OUT USHORT *pusMappedPort,
        //IN BOOL bUDP = TRUE
        //);

    HRESULT LeaseMappedAddr2(
        IN DWORD dwRealAddr,
        IN USHORT usRealPort,
        IN USHORT usRealPort2,
        IN RTC_MEDIA_DIRECTION Direction,
        IN BOOL bInternal,
        IN BOOL bFirewall,
        OUT DWORD *pdwMappedAddr,
        OUT USHORT *pusMappedPort,
        OUT USHORT *pusMappedPort2,
        IN BOOL bUDP = TRUE
        );

    HRESULT ReleaseMappedAddr2(
        IN DWORD dwRealAddr,
        IN USHORT usRealPort,
        IN USHORT usRealPort2,
        IN RTC_MEDIA_DIRECTION Direction
        );

    VOID ReleaseAllMappedAddrs();

    VOID Cleanup();

private:

    BOOL FindEntry2(
        IN DWORD dwAddr,
        IN USHORT dwPort,
        IN USHORT dwPort2,
        OUT DWORD *pdwIndex
        );

    typedef struct LEASE_ITEM
    {
        BOOL        bInUse;
        DWORD       dwRealAddr;
        USHORT      usRealPort;
        USHORT      usRealPort2;
        DWORD       dwDirection;
        DWORD       dwMappedAddr;
        USHORT      usMappedPort;
        USHORT      usMappedPort2;
        DPNHHANDLE  handle;         // registerred ports

    } LEASE_ITEM;

#define MAX_LEASE_ITEM_NUM 8

    // lease item array
    LEASE_ITEM                  m_LeaseItems[MAX_LEASE_ITEM_NUM];

    DWORD                       m_dwNumLeaseItems;

    IDirectPlayNATHelp          *m_pIDirectPlayNATHelp;

    // cache the result of mapped address to real address
    // during each call to speed up
    typedef struct MAPPED_TO_REAL_CACHE
    {
        BOOL        bInUse;             // valid cache value
        DWORD       dwMappedAddr;
        DWORD       dwRealAddr;
        BOOL        bInternal;          // mapped address internal?
        HRESULT     hr;                 // hr result of query

    } MAPPED_TO_REAL_CACHE;

    MAPPED_TO_REAL_CACHE        m_MappedToRealCache;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\network.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    CNetwork.cpp

Abstract:

    This module wraps methods to access NAT traversal.

Author(s):

    Qianbo Huai (qhuai) 01-Mar-2000

--*/

#include "stdafx.h"

CNetwork::CNetwork()
    :m_dwNumLeaseItems(0)
    ,m_pIDirectPlayNATHelp(NULL)
{
    for (int i=0; i<MAX_LEASE_ITEM_NUM; i++)
    {
        ZeroMemory(&m_LeaseItems[i], sizeof(LEASE_ITEM));
        //m_LeaseItems[i].bInUse = FALSE;
    }

    ZeroMemory(&m_MappedToRealCache, sizeof(MAPPED_TO_REAL_CACHE));
}

VOID
CNetwork::Cleanup()
{
    if (m_pIDirectPlayNATHelp != NULL)
    {
        ReleaseAllMappedAddrs();

        m_pIDirectPlayNATHelp->Release();
        m_pIDirectPlayNATHelp = NULL;
    }

    _ASSERT(m_dwNumLeaseItems == 0);
}

VOID
CNetwork::ReleaseAllMappedAddrs()
{
    if (m_pIDirectPlayNATHelp == NULL)
    {
        _ASSERT(m_dwNumLeaseItems == 0);

        return;
    }

    if (m_dwNumLeaseItems > 0)
    {
        HRESULT hr;

        // release leased item
        for (int i=0; i<MAX_LEASE_ITEM_NUM; i++)
        {
            if (m_LeaseItems[i].bInUse == TRUE)
            {
                if (FAILED(hr = m_pIDirectPlayNATHelp->DeregisterPorts(
                                    m_LeaseItems[i].handle, 0)))
                {
                    LOG((RTC_ERROR, "DeregisterPorts: real %s %d",
                         GetIPAddrString(m_LeaseItems[i].dwRealAddr),
                         m_LeaseItems[i].usRealPort));

                    LOG((RTC_ERROR, "               mapped %s %d",
                         GetIPAddrString(m_LeaseItems[i].dwMappedAddr),
                         m_LeaseItems[i].usMappedPort));
                }

                ZeroMemory(&m_LeaseItems[i], sizeof(LEASE_ITEM));

                //m_LeaseItems[i].bInUse = FALSE;
            }
        }

        m_dwNumLeaseItems = 0;
    }

    // clean up cached mapped-to-real address
    ZeroMemory(&m_MappedToRealCache, sizeof(MAPPED_TO_REAL_CACHE));
}

CNetwork::~CNetwork()
{
    if (m_dwNumLeaseItems != 0)
    {
        LOG((RTC_ERROR, "CNetwork::~CNetwork. lease # %d", m_dwNumLeaseItems));
    }

    Cleanup();
}

// store IDirectPlayNATHelp
HRESULT
CNetwork::SetIDirectPlayNATHelp(
    IN IDirectPlayNATHelp *pIDirectPlayNATHelp
    )
{
    if (m_pIDirectPlayNATHelp != NULL)
    {
        LOG((RTC_ERROR, "IDirectPlayNATHelp was already set"));

        return E_UNEXPECTED;
    }

    m_pIDirectPlayNATHelp = pIDirectPlayNATHelp;
    m_pIDirectPlayNATHelp->AddRef();

    _ASSERT(m_dwNumLeaseItems == 0);

    return S_OK;
}

// mapped -> real
HRESULT
CNetwork::GetRealAddrFromMapped(
    IN DWORD dwMappedAddr,
    IN USHORT usMappedPort,
    OUT DWORD *pdwRealAddr,
    OUT USHORT *pusRealPort,
    OUT BOOL *pbInternal,
    IN BOOL bUDP
    )
{
    ENTER_FUNCTION("NAT:Mapped->Real");

    if (m_pIDirectPlayNATHelp == NULL)
    {
        *pdwRealAddr = dwMappedAddr;
        *pusRealPort = usMappedPort;
        *pbInternal = TRUE;

        return S_OK;
    }

    HRESULT hr;

    // check cache
    if (m_MappedToRealCache.bInUse)
    {
        // already looked up a mapped address
        // chances are we need to look up the same address
        if (dwMappedAddr == m_MappedToRealCache.dwMappedAddr)
        {
            if (m_MappedToRealCache.hr != S_OK ||
                usMappedPort == 0)
            {
                *pdwRealAddr = m_MappedToRealCache.dwRealAddr;
                *pusRealPort = usMappedPort;
                *pbInternal = m_MappedToRealCache.bInternal;

                LOG((RTC_TRACE, "%s mapped %s %d (use cached value)", __fxName,
                        GetIPAddrString(dwMappedAddr), usMappedPort));

                return S_OK;
            }
        }
    }

    SOCKADDR_IN srcAddr, destAddr, realAddr;

    // source address
    ZeroMemory(&srcAddr, sizeof(srcAddr));
    srcAddr.sin_family = AF_INET;
    srcAddr.sin_addr.s_addr = htonl(INADDR_ANY);

    // possible mapped address
    ZeroMemory(&destAddr, sizeof(destAddr));
    destAddr.sin_family = AF_INET;
    destAddr.sin_addr.s_addr = htonl(dwMappedAddr);
    destAddr.sin_port = htons(usMappedPort);

    DWORD dwQueryFlags = DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED;
    
    if (!bUDP)
    {
        // TCP
        dwQueryFlags |= DPNHQUERYADDRESS_TCP;
    }

    hr = m_pIDirectPlayNATHelp->QueryAddress(
            (SOCKADDR*)&srcAddr,
            (SOCKADDR*)&destAddr,
            (SOCKADDR*)&realAddr,
            sizeof(SOCKADDR_IN),
            dwQueryFlags
            );

    if (hr == S_OK)
    {
        LOG((RTC_TRACE, "%s found mapped private addr", __fxName));

        *pdwRealAddr = ntohl(realAddr.sin_addr.s_addr);
        *pusRealPort = ntohs(realAddr.sin_port);
        *pbInternal = TRUE;
    }
    else if (hr == DPNHERR_NOMAPPINGBUTPRIVATE)
    {
        LOG((RTC_TRACE, "%s input addr is private", __fxName));

        *pdwRealAddr = dwMappedAddr;
        *pusRealPort = usMappedPort;
        *pbInternal = TRUE;
    }
    else if (hr == DPNHERR_NOMAPPING)
    {
        LOG((RTC_TRACE, "%s external address", __fxName));

        *pdwRealAddr = dwMappedAddr;
        *pusRealPort = usMappedPort;
        *pbInternal = FALSE;   
    }
    else
    {
        LOG((RTC_ERROR, "%s failed to query address. %x", __fxName, hr));

        *pdwRealAddr = dwMappedAddr;
        *pusRealPort = usMappedPort;
        *pbInternal = TRUE;   
    }

    // save result in cache
    m_MappedToRealCache.bInUse = TRUE;
    m_MappedToRealCache.hr = hr;
    m_MappedToRealCache.dwMappedAddr = dwMappedAddr;
    m_MappedToRealCache.dwRealAddr = *pdwRealAddr;
    m_MappedToRealCache.bInternal = *pbInternal;

    LOG((RTC_TRACE, "%s mapped %s %d", __fxName,
            GetIPAddrString(dwMappedAddr), usMappedPort));

    LOG((RTC_TRACE, "%s   real %s %d, private %d", __fxName,
            GetIPAddrString(*pdwRealAddr), *pusRealPort,
            *pbInternal));

    return S_OK;
}

// real -> mapped
HRESULT
CNetwork::GetMappedAddrFromReal2(
    IN DWORD dwRealAddr,
    IN USHORT usRealPort,
    IN USHORT usRealPort2,
    OUT DWORD *pdwMappedAddr,
    OUT USHORT *pusMappedPort,
    OUT USHORT *pusMappedPort2
    )
{
    DWORD i;

    if (usRealPort == UNUSED_PORT)
    {
        // special case
        // just need address
        if (m_dwNumLeaseItems > 0)
        {
            for (i=0; i<MAX_LEASE_ITEM_NUM; i++)
            {
                // stop at the 1st address that matchs
                if (m_LeaseItems[i].bInUse &&
                    m_LeaseItems[i].dwRealAddr == dwRealAddr)
                {
                    *pdwMappedAddr = m_LeaseItems[i].dwMappedAddr;
                    *pusMappedPort = m_LeaseItems[i].usMappedPort;
                    *pusMappedPort2 = m_LeaseItems[i].usMappedPort2;

                    return S_OK;
                }
            }
        }

        // no matched address
        *pdwMappedAddr = dwRealAddr;
        *pusMappedPort = usRealPort;
        *pusMappedPort2 = usRealPort2;

        return S_OK;
    }

    // normal port
    if (m_pIDirectPlayNATHelp != NULL &&
        FindEntry2(dwRealAddr, usRealPort, usRealPort2, &i))
    {
        *pdwMappedAddr = m_LeaseItems[i].dwMappedAddr;
        *pusMappedPort = m_LeaseItems[i].usMappedPort;
        *pusMappedPort2 = m_LeaseItems[i].usMappedPort2;

        return S_OK;
    }

    // not match
    *pdwMappedAddr = dwRealAddr;
    *pusMappedPort = usRealPort;
    *pusMappedPort2 = usRealPort2;

    return S_OK;
}

HRESULT
CNetwork::LeaseMappedAddr2(
    IN DWORD dwRealAddr,
    IN USHORT usRealPort,
    IN USHORT usRealPort2,
    IN RTC_MEDIA_DIRECTION Direction,
    IN BOOL bInternal,
    IN BOOL bFirewall,
    OUT DWORD *pdwMappedAddr,
    OUT USHORT *pusMappedPort,
    OUT USHORT *pusMappedPort2,
    IN BOOL bUDP
    )
{
    ENTER_FUNCTION("NAT:Real->Mapped");

    LOG((RTC_TRACE, "%s   Real %s %d %d. Internal=%d. Firewall=%d",
            __fxName, GetIPAddrString(dwRealAddr), usRealPort, usRealPort2,
            bInternal, bFirewall));

    DWORD i;

    if (m_pIDirectPlayNATHelp == NULL)
    {
        *pdwMappedAddr = dwRealAddr;
        *pusMappedPort = usRealPort;
        *pusMappedPort2 = usRealPort2;

        return S_OK;
    }

    // check if already leased
    if (FindEntry2(dwRealAddr, usRealPort, usRealPort2, &i))
    {
        *pdwMappedAddr = m_LeaseItems[i].dwMappedAddr;
        *pusMappedPort = m_LeaseItems[i].usMappedPort;
        *pusMappedPort2 = m_LeaseItems[i].usMappedPort2;
        m_LeaseItems[i].dwDirection |= (DWORD)Direction;

        //LOG((RTC_WARN, "Double leasing %s %d",
            //GetIPAddrString(dwRealAddr), usRealPort));

        return S_OK;
    }

    // find empty slot
    if (m_dwNumLeaseItems == MAX_LEASE_ITEM_NUM)
    {
        LOG((RTC_ERROR, "no empty lease slot for NAT traversal"));

        return E_UNEXPECTED;
    }

    for (i=0; i<MAX_LEASE_ITEM_NUM; i++)
    {
        if (!m_LeaseItems[i].bInUse)
            break;
    }

    _ASSERT(i < MAX_LEASE_ITEM_NUM);

    // register port
    SOCKADDR_IN addr[2];

    ZeroMemory(addr, sizeof(SOCKADDR_IN)*2);

    addr[0].sin_family = AF_INET;
    addr[0].sin_addr.s_addr = htonl(dwRealAddr);
    addr[0].sin_port = htons(usRealPort);

    if (usRealPort2 != 0)
    {
        addr[1].sin_family = AF_INET;
        addr[1].sin_addr.s_addr = htonl(dwRealAddr);
        addr[1].sin_port = htons(usRealPort2);
    }

    DWORD dwAddSize = sizeof(SOCKADDR_IN);
    
    if (usRealPort2 != 0)
    {
        dwAddSize += dwAddSize;
    }

    HRESULT hr = m_pIDirectPlayNATHelp->RegisterPorts(
        (SOCKADDR*)addr,
        dwAddSize,
        usRealPort2==0?1:2,          // 1 or 2 ports
        3600000,    // 1 hour
        &m_LeaseItems[i].handle,
        bUDP?0:DPNHREGISTERPORTS_TCP           // UDP
        );

    if (hr != DPNH_OK)
    {
        LOG((RTC_ERROR, "%s RegisterPorts failed %s %d %d. %x",
                __fxName,
                GetIPAddrString(dwRealAddr), usRealPort, usRealPort2,
                hr));

        if (hr == DPNHERR_PORTUNAVAILABLE)
        {
            return hr;
        }
    }

    // get registerred address
    if (hr == DPNH_OK)
    {        
        DWORD dwAddrTypeFlags;
        DWORD dwFlag = 0;

        if (bInternal && bFirewall)
        {
            // mapping is for firewall only
            dwFlag = DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY;
        }

        hr = m_pIDirectPlayNATHelp->GetRegisteredAddresses(
                m_LeaseItems[i].handle,
                (SOCKADDR*)addr,
                &dwAddSize,
                &dwAddrTypeFlags,
                NULL,
                dwFlag
                );

        if (hr == DPNHERR_PORTUNAVAILABLE)
        {
            LOG((RTC_ERROR, "%s port unavailable", __fxName));

            m_pIDirectPlayNATHelp->DeregisterPorts(m_LeaseItems[i].handle, 0);
            m_LeaseItems[i].handle = NULL;

            return hr;
        }

        if (hr != DPNH_OK ||
            (ntohl(addr[0].sin_addr.s_addr) == dwRealAddr &&  // mapped=real
             !bFirewall) // but no local firewall
            )
        {
            if (hr != DPNH_OK)
            {
                LOG((RTC_WARN, "%s GetRegisteredAddresses. %s %d. %x",
                    __fxName,
                    GetIPAddrString(dwRealAddr), usRealPort,
                    hr));
            }
            else
            {
                LOG((RTC_TRACE, "%s mapped addr == real addr", __fxName));

                hr = S_FALSE;
            }

            m_pIDirectPlayNATHelp->DeregisterPorts(m_LeaseItems[i].handle, 0);
            m_LeaseItems[i].handle = NULL;

            //if (hr != DPNHERR_SERVERNOTAVAILABLE)
            //{
                //return hr;
            //}
            // else: if a server does not present, RegisterPorts still succeeds.
        }
    }
    
    if (hr == DPNH_OK)
    {
        // save address
        m_LeaseItems[i].dwRealAddr = dwRealAddr;
        m_LeaseItems[i].usRealPort = usRealPort;
        m_LeaseItems[i].usRealPort2 = usRealPort2;
        m_LeaseItems[i].dwMappedAddr = ntohl(addr[0].sin_addr.s_addr);
        m_LeaseItems[i].usMappedPort = ntohs(addr[0].sin_port);
        m_LeaseItems[i].usMappedPort2 = usRealPort2==0?0:ntohs(addr[1].sin_port);
        m_LeaseItems[i].bInUse = TRUE;
        m_LeaseItems[i].dwDirection |= (DWORD)Direction;

        m_dwNumLeaseItems ++;

        *pdwMappedAddr = m_LeaseItems[i].dwMappedAddr;
        *pusMappedPort = m_LeaseItems[i].usMappedPort;
        *pusMappedPort2 = m_LeaseItems[i].usMappedPort2;
    }
    else
    {
        *pdwMappedAddr = dwRealAddr;
        *pusMappedPort = usRealPort;
        *pusMappedPort2 = usRealPort2;
    }

    LOG((RTC_TRACE, "%s Mapped %s %d %d",
            __fxName, GetIPAddrString(*pdwMappedAddr), *pusMappedPort, *pusMappedPort2));

    return S_OK;
}

HRESULT
CNetwork::ReleaseMappedAddr2(
    IN DWORD dwRealAddr,
    IN USHORT usRealPort,
    IN USHORT usRealPort2,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("NAT:Release  Map");

    DWORD i;

    if (m_pIDirectPlayNATHelp == NULL)
    {
        return S_OK;
    }

    if (!FindEntry2(dwRealAddr, usRealPort, usRealPort2, &i))
    {
        //LOG((RTC_WARN, "Releasing %s %d: not exist",
            //GetIPAddrString(dwRealAddr), usRealPort));

        return S_OK;
    }

    LOG((RTC_TRACE, "%s   Real %s %d %d",
            __fxName,
            GetIPAddrString(m_LeaseItems[i].dwRealAddr),
            m_LeaseItems[i].usRealPort,
            m_LeaseItems[i].usRealPort2
            ));

    LOG((RTC_TRACE, "%s Mapped %s %d",
            __fxName,
            GetIPAddrString(m_LeaseItems[i].dwMappedAddr),
            m_LeaseItems[i].usMappedPort,
            m_LeaseItems[i].usMappedPort2
            ));

    // release for this media type
    m_LeaseItems[i].dwDirection &= (DWORD)(~Direction);

    if (m_LeaseItems[i].dwDirection != 0)
    {
        LOG((RTC_TRACE, "%s md=%d removed", __fxName, Direction));

        return S_OK;
    }

    HRESULT hr = m_pIDirectPlayNATHelp->DeregisterPorts(
        m_LeaseItems[i].handle,
        0
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to dereg ports. %x", __fxName, hr));
    }

    ZeroMemory(&m_LeaseItems[i], sizeof(LEASE_ITEM));

    m_dwNumLeaseItems --;

    return S_OK;
}

const CHAR * const
CNetwork::GetIPAddrString(
    IN DWORD dwAddr
    )
{
    struct in_addr addr;
    addr.s_addr = htonl(dwAddr);

    return inet_ntoa(addr);
}

BOOL
CNetwork::FindEntry2(
    IN DWORD dwAddr,
    IN USHORT dwPort,
    IN USHORT dwPort2,
    OUT DWORD *pdwIndex
    )
{
     if (m_pIDirectPlayNATHelp == NULL ||
         m_dwNumLeaseItems == 0)
         return FALSE;

     for (DWORD i=0; i<MAX_LEASE_ITEM_NUM; i++)
     {
         if (m_LeaseItems[i].bInUse &&
             m_LeaseItems[i].dwRealAddr == dwAddr &&
             (m_LeaseItems[i].usRealPort == dwPort ||
              m_LeaseItems[i].usRealPort2 == dwPort2)
             )
         {
             ASSERT(m_LeaseItems[i].usRealPort == dwPort &&
                    m_LeaseItems[i].usRealPort2 == dwPort2);

             *pdwIndex = i;

             return TRUE;
         }
     }

     return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\mediacontroller.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    MediaController.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"
#include "rtcerr.h"
#include "imsconf3_i.c"
#include "sdkinternal_i.c"

#ifndef RTCMEDIA_DLL
HRESULT
CreateMediaController(
    IRTCMediaManage **ppIRTCMediaManage
    )
{
    if (IsBadWritePtr(ppIRTCMediaManage, sizeof(IRTCMediaManage*)))
    {
        // log here
        return E_POINTER;
    }

    CComObject<CRTCMediaController> *pController = NULL;

    HRESULT hr = ::CreateCComObjectInstance(&pController);

    if (FAILED(hr))
    {
        // log here
        return hr;
    }

    if (FAILED(hr = pController->_InternalQueryInterface(
            __uuidof(IRTCMediaManage),
            (void**)ppIRTCMediaManage
            )))
    {
        // log here
        delete pController;
        return hr;
    }

    return S_OK;
}
#endif

/*//////////////////////////////////////////////////////////////////////////////
    constructor and destructor of CRTCMediaController
////*/

CRTCMediaController::CRTCMediaController()
    :m_State(RTC_MCS_CREATED)
    ,m_hWnd(NULL)
    ,m_uiEventID(0)
    ,m_pISDPSession(NULL)
    ,m_hSocket(NULL)
    ,m_fBWSuggested(FALSE)
    ,m_hDxmrtp(NULL)
    ,m_hIntfSelSock(INVALID_SOCKET)
{
    DBGREGISTER(L"rtcmedia");
}

CRTCMediaController::~CRTCMediaController()
{
    LOG((RTC_TRACE, "CRTCMediaController::~CRTCMediaController entered"));

    _ASSERT(m_State == RTC_MCS_CREATED ||
           m_State == RTC_MCS_SHUTDOWN);

    if (m_State != RTC_MCS_CREATED &&
        m_State != RTC_MCS_SHUTDOWN)
    {
        LOG((RTC_ERROR, "CRTCMediaController is being destructed in wrong state: %d", m_State));

        this->Shutdown();
    }

    DBGDEREGISTER();
}

#ifdef DEBUG_REFCOUNT

ULONG
CRTCMediaController::InternalAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    LOG((RTC_REFCOUNT, "MediaController addref=%d", lRef));

    return lRef;
}

ULONG
CRTCMediaController::InternalRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();
    
    LOG((RTC_REFCOUNT, "MediaController release=%d", lRef));

    return lRef;
}

#endif

//
// IRTCMediaManage methods
//

/*//////////////////////////////////////////////////////////////////////////////
    initializes event list, terminal manage, thread
////*/

STDMETHODIMP
CRTCMediaController::Initialize(
    IN HWND hWnd,
    IN UINT uiEventID
    )
{
    ENTER_FUNCTION("CRTCMediaController::Initialize");
    LOG((RTC_TRACE, "%s entered", __fxName));

#ifdef PERFORMANCE

    // frequency

    if (!QueryPerformanceFrequency(&g_liFrequency))
    {
        g_liFrequency.QuadPart = 1000;
    }

    LOG((RTC_TRACE, "%s frequency %d kps", g_strPerf, g_liFrequency.QuadPart/1000));


#endif

#ifdef PERFORMANCE

    // beginning of initialize
    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    // check state
    if (m_State != RTC_MCS_CREATED)
        return RTC_E_MEDIA_CONTROLLER_STATE;

    // check input parameter
    if (hWnd == NULL)
        return E_INVALIDARG;
    
    // store input parameters
    m_hWnd = hWnd;
    m_uiEventID = uiEventID;

    HRESULT hr;

    // create video render window

    // create terminal manage
    CComPtr<ITTerminalManager> pTerminalManager;
    CComPtr<IRTCTerminal> pVidRender;
    CComPtr<IRTCTerminal> pVidPreview;

    hr = CoCreateInstance(
        CLSID_TerminalManager,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTerminalManager,
        (void**)&pTerminalManager
        );
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to create terminal manager. %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = CreateIVideoWindowTerminal(
            pTerminalManager,
            &pVidRender
            )))
    {
        LOG((RTC_ERROR, "%s create vid rend terminal. %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = CreateIVideoWindowTerminal(
            pTerminalManager,
            &pVidPreview
            )))
    {
        LOG((RTC_ERROR, "%s create vid preview terminal. %x", __fxName, hr));

        return hr;
    }

    // initialize media cache
    m_MediaCache.Initialize(m_hWnd, pVidRender, pVidPreview);

    m_QualityControl.Initialize(this);

    m_DTMF.Initialize();

    // initiate socket
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0)
    {
        LOG((RTC_ERROR, "WSAStartup failed with:%x", WSAGetLastError()));

        return E_FAIL;
    }

    // allocate control socket
    m_hSocket = WSASocket(
        AF_INET,            // af
        SOCK_DGRAM,         // type
        IPPROTO_IP,         // protocol
        NULL,               // lpProtocolInfo
        0,                  // g
        0                   // dwFlags
        );

    // validate handle
    if (m_hSocket == INVALID_SOCKET) {

        LOG((RTC_ERROR, "error %d creating control socket", WSAGetLastError()));

        WSACleanup();
     
        return E_FAIL;
    }
        
    // create terminals
    if (FAILED(hr = UpdateStaticTerminals()))
    {
        LOG((RTC_ERROR, "%s update static terminals. %x", __fxName, hr));

        // close socket
        closesocket(m_hSocket);

        // shutdown
        WSACleanup();

        return hr;
    }

    // success !
    m_State = RTC_MCS_INITIATED;

    m_uDataStreamState = RTC_DSS_VOID;

    m_fBWSuggested = FALSE;

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s MediaController.Initialize %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    initializes event list, terminal manage, thread
////*/

STDMETHODIMP
CRTCMediaController::SetDirectPlayNATHelpAndSipStackInterfaces(
    IN IUnknown *pDirectPlayNATHelp,
    IN IUnknown *pSipStack
    )
{
    CComPtr<IDirectPlayNATHelp> pDirect;
    CComPtr<ISipStack> pSip;

    HRESULT hr;

    // store SIP stack
    if (FAILED(hr = pSipStack->QueryInterface(&pSip)))
    {
        LOG((RTC_ERROR, "QI SipStack"));

        return hr;
    }

    m_pSipStack = pSip;

    // store directplay intf
    if (FAILED(hr = pDirectPlayNATHelp->QueryInterface(
            IID_IDirectPlayNATHelp,
            (VOID**)&pDirect
            )))
    {
        LOG((RTC_ERROR, "QI DirectPlayNATHelper intf"));

        return hr;
    }

    return m_Network.SetIDirectPlayNATHelp(pDirect);
}


/*//////////////////////////////////////////////////////////////////////////////
    Reinitialize cleans up media controller, return it to initiated state
////*/
STDMETHODIMP
CRTCMediaController::Reinitialize()
{
    ENTER_FUNCTION("CRTCMediaController::Reinitialize");
    LOG((RTC_TRACE, "%s entered", __fxName));

    if (m_State != RTC_MCS_INITIATED)
    {
        LOG((RTC_ERROR, "%s in wrong state %d", __fxName, m_State));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    // clear medias
    for (int i=0; i<m_Medias.GetSize(); i++)
    {
        m_Medias[i]->Shutdown();
        m_Medias[i]->Release();
    }

    m_Medias.RemoveAll();

    // clear media cache
    m_MediaCache.Reinitialize();

    m_QualityControl.Reinitialize();

    m_DTMF.Initialize();

    // clear sdp
    if (m_pISDPSession)
    {
        m_pISDPSession->Release();
        m_pISDPSession = NULL;
    }

    if (m_pNmManager)
    {
        m_pNmManager->Shutdown ();
        m_pNmManager->Initialize (TRUE, static_cast<IRTCMediaManagePriv*>(this));
    }

    m_uDataStreamState = RTC_DSS_VOID;

    // cleanup address mapping
    m_Network.ReleaseAllMappedAddrs();

    m_fBWSuggested = FALSE;

    // cleanup interface selection socket
    if (m_hIntfSelSock != INVALID_SOCKET)
    {
        closesocket(m_hIntfSelSock);
        m_hIntfSelSock = INVALID_SOCKET;
    }

    // reinit port manager
    m_PortCache.Reinitialize();

    LOG((RTC_TRACE, "%s exiting", __fxName));
    return S_OK;
}

/*////////////////////////////////////////////////////////////////////////////
    clears media, terminal & manager, sdp, thread, events
////*/

STDMETHODIMP
CRTCMediaController::Shutdown()
{
    ENTER_FUNCTION("CRTCMediaController::Shutdown");
    LOG((RTC_TRACE, "%s entered", __fxName));

    // check state
    if (m_State != RTC_MCS_INITIATED)
    {
        LOG((RTC_ERROR, "%s shutdown in wrong state: %d", __fxName, m_State));

        //return E_UNEXPECTED;
    }

    m_State = RTC_MCS_INSHUTDOWN;

    // close socket
    if (m_hSocket != INVALID_SOCKET)
    {
        closesocket(m_hSocket);
        m_hSocket = INVALID_SOCKET;
    }

    // cleanup interface selection socket
    if (m_hIntfSelSock != INVALID_SOCKET)
    {
        closesocket(m_hIntfSelSock);
        m_hIntfSelSock = INVALID_SOCKET;
    }

    WSACleanup();

    // shutdown and clear all media
    for (int i=0; i<m_Medias.GetSize(); i++)
    {
        m_Medias[i]->Shutdown();
        m_Medias[i]->Release();
    }

    m_Medias.RemoveAll();

    // shutdown and release all terminals
    for (int i=0; i<m_Terminals.GetSize(); i++)
    {
        CRTCTerminal *pCTerminal = static_cast<CRTCTerminal*>(m_Terminals[i]);
        pCTerminal->Shutdown();

        m_Terminals[i]->Release();
    }

    m_Terminals.RemoveAll();

    // clear media cache
    m_MediaCache.Shutdown();

    // clear SDP
    if (m_pISDPSession)
    {
        m_pISDPSession->Release();
        m_pISDPSession = NULL;
    }

    // clear all events
    m_hWnd = NULL;

    m_State = RTC_MCS_SHUTDOWN;

    if (m_pNmManager)
    {
        m_pNmManager->Shutdown ();
    }

    m_pNmManager.Release();

    m_uDataStreamState = RTC_DSS_VOID;

    // upload dxmrtp
    if (m_hDxmrtp != NULL)
    {
        FreeLibrary(m_hDxmrtp);

        m_hDxmrtp = NULL;
    }

    // cleanup network object (NAT stuff)
    m_Network.Cleanup();

    // release sip stack
    m_pSipStack.Release();

    // shutdown (reinit) port manager
    m_PortCache.Reinitialize();

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

#if 0
/*//////////////////////////////////////////////////////////////////////////////
    receives sdp blob, stores in CRTCSDP, mark if media needs to sync
////*/
STDMETHODIMP
CRTCMediaController::SetSDPBlob(
    IN CHAR *szSDP
    )
{
    ENTER_FUNCTION("CRTCMediaController::SetSDPBlob");
    LOG((RTC_TRACE, "%s entered", __fxName));

    if (IsBadStringPtrA(szSDP, (UINT_PTR)(-1)))
    {
        LOG((RTC_ERROR, "%s: bad string pointer", __fxName));
        return E_POINTER;
    }

    _ASSERT(m_State == RTC_MCS_INITIATED);

    HRESULT hr;

    // create a new sdp parser
    CComPtr<ISDPParser> pParser;
    
    if (FAILED(hr = CSDPParser::CreateInstance(&pParser)))
    {
        LOG((RTC_ERROR, "%s create sdp parser. %x", __fxName, hr));

        return hr;
    }

    // parse the sdp blob
    CComPtr<ISDPSession> pSession;

    hr = pParser->ParseSDPBlob(
        szSDP,                  // sdp string
        SDP_SOURCE_REMOTE,      // sdp origin
        &pSession
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to parse the sdp. %x", __fxName, hr));

        // get error desp
        HRESULT hr2;
        CHAR *pszError;

        if (FAILED(hr2 = pParser->GetParsingError(&pszError)))
        {
            LOG((RTC_ERROR, "%s failed to get error description. %x", __fxName, hr2));
        }
        else
        {
            LOG((RTC_ERROR, "%s parsing error: %s", __fxName, pszError));

            pParser->FreeParsingError(pszError);
        }

        return hr;
    }

    // do we already have a sdp session
    if (m_pISDPSession == NULL)
    {
        // save the session
        m_pISDPSession = pSession;
        m_pISDPSession->AddRef();
    }
    else
    {
        // merge these two sdps
        if (FAILED(hr = m_pISDPSession->Update(pSession)))
        {
            // usually? out of memory? format error?
            LOG((RTC_ERROR, "%s failed to merged sdps. %x", __fxName, hr));

            return hr;
        }
    }

    // sync media
    if (FAILED(hr = SyncMedias()))
    {
        LOG((RTC_ERROR, "%s failed to sync medias. %x", __fxName, hr));
    }

    // start streams
    BOOL fHasStream = FALSE;
    hr = S_OK;

    HRESULT hr2;

    if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_CAPTURE))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_AUDIO, RTC_MD_CAPTURE)))
        {
            LOG((RTC_ERROR, "%s failed to start aud cap. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_RENDER))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_AUDIO, RTC_MD_RENDER)))
        {
            LOG((RTC_ERROR, "%s failed to start aud rend. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_CAPTURE))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_VIDEO, RTC_MD_CAPTURE)))
        {
            LOG((RTC_ERROR, "%s failed to start vid cap. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_RENDER))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_VIDEO, RTC_MD_RENDER)))
        {
            LOG((RTC_ERROR, "%s failed to start vid rend. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    LOG((RTC_TRACE, "%s exiting", __fxName));

    if (fHasStream || m_uDataStreamState==RTC_DSS_STARTED)
    {
        // do not propagate the error code
        return S_OK;
    }
    else
    {
        // no stream
        if (hr == S_OK)
        {
            // no stream is created
            return RTC_E_SIP_NO_STREAM;
        }
        else
        {
            // return error code
            return hr;
        }
    }
}
#endif

/*//////////////////////////////////////////////////////////////////////////////
    retrieves SDP blob
////*/

STDMETHODIMP
CRTCMediaController::GetSDPBlob(
    IN DWORD dwSkipMask,
    OUT CHAR **pszSDP
    )
{
    ENTER_FUNCTION("CRTCMediaController::GetSDPBlob");

#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    if (IsBadWritePtr(pszSDP, sizeof(CHAR*)))
    {
        LOG((RTC_ERROR, "CRTCMediaController::GetSDPBlob: bad pointer"));
        return E_POINTER;
    }

    if (m_pISDPSession == NULL)
    {
        LOG((RTC_ERROR, "%s no sdp session.", __fxName));

        return RTC_E_SDP_NO_MEDIA;
    }

    // create sdp parser
    CComPtr<ISDPParser> pParser;
    
    // create parser
    HRESULT hr;

    if (FAILED(hr = CSDPParser::CreateInstance(&pParser)))
    {
        LOG((RTC_ERROR, "%s create sdp parser. %x", __fxName, hr));

        if (hr == E_FAIL)
        {
            hr = RTC_E_SDP_FAILED_TO_BUILD;
        }

        return hr;
    }

    // adjust bitrate setting before building SDP blob
    AdjustBitrateAlloc();

    // adjust audio codec before computing video bitrate
    DWORD dwBitrate = m_QualityControl.GetBitrateLimit(CQualityControl::LOCAL);

    // max bitrate set by app
    DWORD dwMax = m_QualityControl.GetMaxBitrate();

    if (dwBitrate > dwMax)
    {
        dwBitrate = dwMax;
    }

    m_pISDPSession->SetLocalBitrate(dwBitrate);

    // create sdp blob
    hr = pParser->BuildSDPBlob(
        m_pISDPSession,
        SDP_SOURCE_LOCAL,
        (DWORD_PTR*)&m_Network,
        (DWORD_PTR*)&m_PortCache,
        (DWORD_PTR*)&m_DTMF,
        pszSDP
        );

    if (FAILED(hr))
    {
        LOG((RTC_TRACE, "%s failed to get sdp. %x", __fxName, hr));
    }
    else
    {
        LOG((RTC_TRACE, "%s:\n\n%s\n\n", __fxName, *pszSDP));
    }

    if (hr == E_FAIL)
    {
        hr = RTC_E_SDP_FAILED_TO_BUILD;
    }
    else if (hr == S_OK)
    {
        // verify we have media in sdp
        if (S_OK != HasStream(RTC_MT_AUDIO, RTC_MD_CAPTURE) &&
            S_OK != HasStream(RTC_MT_AUDIO, RTC_MD_RENDER) &&
            S_OK != HasStream(RTC_MT_VIDEO, RTC_MD_CAPTURE) &&
            S_OK != HasStream(RTC_MT_VIDEO, RTC_MD_RENDER) &&
            S_OK != HasStream(RTC_MT_DATA, RTC_MD_CAPTURE))
        {
            LOG((RTC_ERROR, "%s no media", __fxName));

            hr = RTC_E_SDP_NO_MEDIA;
        }
    }

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s GetSDPBlob %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    retrieves SDP blob for SIP OPTION
////*/

STDMETHODIMP
CRTCMediaController::GetSDPOption(
    IN DWORD dwLocalIP,
    OUT CHAR **pszSDP
    )
{
    ENTER_FUNCTION("CRTCMediaController::GetSDPOption");

    if (IsBadWritePtr(pszSDP, sizeof(CHAR*)))
    {
        LOG((RTC_ERROR, "%s: bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr;

    // select local interface
    //DWORD dwLocalIP2;

    //if (FAILED(hr = SelectLocalInterface(0x22222222, &dwLocalIP2)))
    //{
        //LOG((RTC_ERROR, "%s select local ip. %x", __fxName, hr));
        //return hr;
    //}

    // get bandwidth limit
    DWORD dwBandwidth = m_QualityControl.GetBitrateLimit(CQualityControl::LOCAL);

    if (dwBandwidth == (DWORD)(-1))
    {
        // not in a session yet
        if (FAILED(hr = ::GetLinkSpeed(dwLocalIP, &dwBandwidth)))
        {
            LOG((RTC_ERROR, "%s Failed to get link speed %x", __fxName, hr));

            dwBandwidth = (DWORD)(-1);
        }
        else
        {
            m_QualityControl.SetBitrateLimit(CQualityControl::LOCAL, dwBandwidth);

            dwBandwidth = m_QualityControl.GetBitrateLimit(CQualityControl::LOCAL);
        }
    }

    // max bitrate set by app
    DWORD dwMax = m_QualityControl.GetMaxBitrate();

    if (dwBandwidth > dwMax)
    {
        dwBandwidth = dwMax;
    }

    // need to create a sdp session
    CComPtr<ISDPParser> pParser;
    
    // create parser
    if (FAILED(hr = CSDPParser::CreateInstance(&pParser)))
    {
        LOG((RTC_ERROR, "%s create sdp parser. %x", __fxName, hr));

        return hr;
    }

    // create sdp session
    CComPtr<ISDPSession> pISDPSession;

    if (FAILED(hr = pParser->CreateSDP(SDP_SOURCE_LOCAL, &pISDPSession)))
    {
        LOG((RTC_ERROR, "%s create sdp session. %x", __fxName, hr));

        return hr;
    }

    // create sdp option
    DWORD dwAudioDir = 0;
    DWORD dwVideoDir = 0;

    if (m_MediaCache.AllowStream(RTC_MT_AUDIO, RTC_MD_CAPTURE))
    {
        dwAudioDir |= RTC_MD_CAPTURE;
    }
    if (m_MediaCache.AllowStream(RTC_MT_AUDIO, RTC_MD_RENDER))
    {
        dwAudioDir |= RTC_MD_RENDER;
    }

    if (m_MediaCache.AllowStream(RTC_MT_VIDEO, RTC_MD_CAPTURE))
    {
        dwVideoDir |= RTC_MD_CAPTURE;
    }
    if (m_MediaCache.AllowStream(RTC_MT_VIDEO, RTC_MD_RENDER))
    {
        dwVideoDir |= RTC_MD_RENDER;
    }

    hr = pParser->BuildSDPOption(
        pISDPSession,
        dwLocalIP,
        dwBandwidth,
        dwAudioDir,
        dwVideoDir,
        pszSDP
        );

    if (FAILED(hr))
    {
        LOG((RTC_TRACE, "%s failed to get sdp. %x", __fxName, hr));
    }
    else
    {
        LOG((RTC_TRACE, "%s:\n\n%s\n\n", __fxName, *pszSDP));
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    RtcFree SDP blob
////*/

STDMETHODIMP
CRTCMediaController::FreeSDPBlob(
    IN CHAR *szSDP
    )
{
    if (IsBadStringPtrA(szSDP, (UINT_PTR)(-1)))
    {
        LOG((RTC_ERROR, "CRTCMediaController::FreeSDPBlob: bad string pointer"));
        return E_POINTER;
    }

    RtcFree(szSDP);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    Parse SDP blob, return session object
////*/

STDMETHODIMP
CRTCMediaController::ParseSDPBlob(
    IN CHAR *szSDP,
    OUT IUnknown **ppSession
    )
{
    ENTER_FUNCTION("CRTCMediaController::ParseSDPBlob");

    if (IsBadStringPtrA(szSDP, (UINT_PTR)(-1)) ||
        IsBadWritePtr(ppSession, sizeof(IUnknown*)))
    {
        LOG((RTC_ERROR, "%s: bad string pointer", __fxName));
        return E_POINTER;
    }

    // _ASSERT(m_State == RTC_MCS_INITIATED);

    m_RegSetting.Initialize();

    HRESULT hr;

    // create a new sdp parser
    CComPtr<ISDPParser> pParser;
    
    if (FAILED(hr = CSDPParser::CreateInstance(&pParser)))
    {
        LOG((RTC_ERROR, "%s create sdp parser. %x", __fxName, hr));

        return hr;
    }

    // parse the sdp blob
    ISDPSession *pSession;

    hr = pParser->ParseSDPBlob(
        szSDP,                  // sdp string
        SDP_SOURCE_REMOTE,      // sdp origin
        (DWORD_PTR*)&m_DTMF,
        &pSession
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to parse the sdp. %x", __fxName, hr));

        // get error desp
        HRESULT hr2;
        CHAR *pszError;

        if (FAILED(hr2 = pParser->GetParsingError(&pszError)))
        {
            LOG((RTC_ERROR, "%s failed to get error description. %x", __fxName, hr2));
        }
        else
        {
            LOG((RTC_ERROR, "%s parsing error: %s", __fxName, pszError));

            pParser->FreeParsingError(pszError);
        }

        return RTC_E_SDP_PARSE_FAILED;
    }

    *ppSession = static_cast<IUnknown*>(pSession);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    Merged the input session with the internal one
    return the updated session
////*/

STDMETHODIMP
CRTCMediaController::VerifySDPSession(
    IN IUnknown *pSession,
    IN BOOL fNewSession,
    OUT DWORD *pdwHasMedia
    )
{
    ENTER_FUNCTION("CRTCMediaController::VerifySDPSession");

    // get session pointer
    ISDPSession *pISDPSession = static_cast<ISDPSession*>(pSession);

    // test session
    HRESULT hr = S_OK;

    if (m_pISDPSession == NULL || fNewSession)
    {
        hr = pISDPSession->TryCopy(pdwHasMedia);
    }
    else
    {
        hr = m_pISDPSession->TryUpdate(pISDPSession, pdwHasMedia);
    }

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s TryUpdate", __fxName));

        if (hr == E_FAIL) hr = RTC_E_SDP_UPDATE_FAILED;
    }

    // AND allow media with internal preferences

    DWORD dwPreference;

    m_MediaCache.GetPreference(&dwPreference);

    *pdwHasMedia = *pdwHasMedia & dwPreference;

    return hr;
}

STDMETHODIMP
CRTCMediaController::SetSDPSession(
    IN IUnknown *pSession
    )
{
    ENTER_FUNCTION("CRTCMediaController::SetSDPBlob(Session)");

    if (m_State != RTC_MCS_INITIATED)
    {
        LOG((RTC_ERROR, "%s in state %d", __fxName, m_State));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    // get session pointer
    ISDPSession *pISDPSession = static_cast<ISDPSession*>(pSession);

    if (pISDPSession == NULL)
    {
        LOG((RTC_ERROR, "%s static_cast", __fxName));

        return E_INVALIDARG;
    }

    // update port mapping method i.e. 'state'
    m_PortCache.ChangeState();

    HRESULT hr = S_OK;

    if (m_pISDPSession == NULL)
    {
        // save the session
        m_pISDPSession = pISDPSession;
        m_pISDPSession->AddRef();
    }
    else
    {
        // merge these two sdps
        if (FAILED(hr = m_pISDPSession->Update(pISDPSession)))
        {
            // usually? out of memory? format error?
            LOG((RTC_ERROR, "%s failed to merged sdps. %x", __fxName, hr));

            Reinitialize();

            return hr;
        }
    }

    // sync media
    if (FAILED(hr = SyncMedias()))
    {
        LOG((RTC_ERROR, "%s failed to sync medias. %x", __fxName, hr));
    }

    // adjust bitrate before start stream
    AdjustBitrateAlloc();

    // start streams
    BOOL fHasStream = FALSE;
    hr = S_OK;

    HRESULT hr2;

    if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_CAPTURE))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_AUDIO, RTC_MD_CAPTURE)))
        {
            LOG((RTC_ERROR, "%s failed to start aud cap. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_RENDER))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_AUDIO, RTC_MD_RENDER)))
        {
            LOG((RTC_ERROR, "%s failed to start aud rend. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_CAPTURE))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_VIDEO, RTC_MD_CAPTURE)))
        {
            LOG((RTC_ERROR, "%s failed to start vid cap. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_RENDER))
    {
        if (FAILED(hr2 = StartStream(RTC_MT_VIDEO, RTC_MD_RENDER)))
        {
            LOG((RTC_ERROR, "%s failed to start vid rend. %x", __fxName, hr2));

            hr |= hr2;
        }
        else
        {
            fHasStream = TRUE;
        }
    }

    LOG((RTC_TRACE, "%s exiting", __fxName));

    if (fHasStream || m_uDataStreamState==RTC_DSS_STARTED)
    {
        // do not propagate the error code
        return S_OK;
    }
    else
    {
        //Reinitialize();

        // no stream
        if (hr == S_OK)
        {
            // no stream is created
            return RTC_E_SIP_NO_STREAM;
        }
        else
        {
            // return error code
            return hr;
        }
    }
}

STDMETHODIMP
CRTCMediaController::SetPreference(
    IN DWORD dwPreference
    )
{
    if (m_MediaCache.SetPreference(dwPreference))
        return S_OK;
    else
        return S_FALSE;
}

STDMETHODIMP
CRTCMediaController::GetPreference(
    IN DWORD *pdwPreference
    )
{
    if (IsBadWritePtr(pdwPreference, sizeof(DWORD)))
    {
        LOG((RTC_ERROR, "CRTCMediaController::GetPreference bad pointer"));

        return E_POINTER;
    }

    m_MediaCache.GetPreference(pdwPreference);

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::AddPreference(
    IN DWORD dwPreference
    )
{
    if (m_MediaCache.AddPreference(dwPreference))
        return S_OK;
    else
        return S_FALSE;
}

/*//////////////////////////////////////////////////////////////////////////////
    add a new stream. if fShareSession is true, we will find the other
    stream (same media type, opposite direction), if the other session is
    found, remote ip will be ignored.
////*/
STDMETHODIMP
CRTCMediaController::AddStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN DWORD dwRemoteIP
    )
{
    ENTER_FUNCTION("CRTCMediaController::AddStream");

    LOG((RTC_TRACE, "%s entered. mt=%x, md=%x, remote=%d",
         __fxName, MediaType, Direction, dwRemoteIP));

    // update port mapping method i.e. 'state'
    m_PortCache.ChangeState();

#ifdef PERFORMANCE

    // beginning of initialize
    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    HRESULT hr;

    m_RegSetting.Initialize();

    //  Is this about T120 data stream
    if (MediaType == RTC_MT_DATA)
    {
        if (!m_PortCache.IsUpnpMapping())
        {
            // data stream cannot be added when port manager is in use
            LOG((RTC_ERROR, "%s mapping method=app", __fxName));

            return RTC_E_PORT_MAPPING_UNAVAILABLE;
        }

        if (S_OK == HasStream(MediaType, Direction))
        {
            return RTC_E_SIP_STREAM_PRESENT;
        }

        hr = AddDataStream (dwRemoteIP);

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s AddStream (mt=%d, md=%d) %d ms",
        g_strPerf, MediaType, Direction, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

        return hr;
    }

    // do we already have the stream?
    if (m_MediaCache.HasStream(MediaType, Direction))
    {
        LOG((RTC_ERROR, "%s already had stream", __fxName));
        return RTC_E_SIP_STREAM_PRESENT;
    }

    // if we don't have terminal, return S_OK
    // we need to prepare when a video device is plugged in again
    IRTCTerminal *pTerminal = m_MediaCache.GetDefaultTerminal(MediaType, Direction);

    if (pTerminal == NULL)
    {
        LOG((RTC_ERROR, "%s no terminal available for mt=%d, md=%d",
            __fxName, MediaType, Direction));

        return RTC_E_MEDIA_NEED_TERMINAL;
    }
    else
    {
        pTerminal->Release();
        pTerminal = NULL;
    }

    // get other direction
    RTC_MEDIA_DIRECTION other_dir;

    if (Direction == RTC_MD_CAPTURE)
        other_dir = RTC_MD_RENDER;
    else
        other_dir = RTC_MD_CAPTURE;

    // get the other stream
    CComPtr<IRTCStream> pOther;
    
    pOther.p = m_MediaCache.GetStream(MediaType, other_dir);

    DWORD dwMediaIndex;
    IRTCMedia *pMedia = NULL;
    ISDPMedia *pISDPMedia = NULL;

    // do we share session
    if (dwRemoteIP == INADDR_NONE || (IRTCStream*)pOther == NULL)
    {
        if (m_pISDPSession == NULL)
        {
            // need to create a sdp session
            CComPtr<ISDPParser> pParser;
            
            // create parser
            if (FAILED(hr = CSDPParser::CreateInstance(&pParser)))
            {
                LOG((RTC_ERROR, "%s create sdp parser. %x", __fxName, hr));

                return hr;
            }

            // create sdp session
            if (FAILED(hr = pParser->CreateSDP(SDP_SOURCE_LOCAL, &m_pISDPSession)))
            {
                LOG((RTC_ERROR, "%s create sdp session. %x", __fxName, hr));

                return hr;
            }
        }

        // do we need to add media if we are to add a video stream?
        if (MediaType == RTC_MT_VIDEO)
        {
            if (FAILED(hr = FindEmptyMedia(MediaType, &pMedia)))
            {
                LOG((RTC_ERROR, "%s find empty media. %x", __fxName, hr));

                return hr;
            }
        }

        if (pMedia == NULL)
        {
            // need to create new sdp and rtc media
            hr = m_pISDPSession->AddMedia(SDP_SOURCE_LOCAL, MediaType, Direction, &pISDPMedia);

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s failed to add sdpmedia. %x", __fxName, hr));

                return hr;
            }

            // setup remote ip
            if (FAILED(hr = pISDPMedia->SetConnAddr(SDP_SOURCE_REMOTE, dwRemoteIP)))
            {
                LOG((RTC_ERROR, "%s set remote ip. %x", __fxName, hr));

                pISDPMedia->Release();  // this is a fake release on session
                m_pISDPSession->RemoveMedia(pISDPMedia);

                return hr;
            }

            // create a new rtcmedia & add to list
            if (FAILED(hr = AddMedia(pISDPMedia, &pMedia)))
            {
                LOG((RTC_ERROR, "%s failed to create rtcmedia. %x", __fxName, hr));

                pISDPMedia->Release();  // this is a fake release on session
                m_pISDPSession->RemoveMedia(pISDPMedia);

                return hr;
            }
        }
        else
        {
            // we have sdp and rtc media already but were not in use

            // get sdpmedia
            if (FAILED(hr = pMedia->GetSDPMedia(&pISDPMedia)))
            {
                LOG((RTC_ERROR, "%s get sdp media. %x", __fxName, hr));

                pMedia->Release();

                return hr;
            }

            // add direction
            if (FAILED(hr = pISDPMedia->AddDirections(SDP_SOURCE_LOCAL, Direction)))
            {
                LOG((RTC_ERROR, "%s media (%p) add direction (%d). %x", __fxName, pISDPMedia, Direction, hr));

                pISDPMedia->Release();  // this is a fake release on session
                pMedia->Release();

                return hr;
            }

            // setup remote ip
            if (FAILED(hr = pISDPMedia->SetConnAddr(SDP_SOURCE_REMOTE, dwRemoteIP)))
            {
                LOG((RTC_ERROR, "%s set remote ip. %x", __fxName, hr));

                pISDPMedia->Release();  // this is a fake release on session
                pMedia->Release();

                return hr;
            }
        }
    }
    else
    {
        // have stream, sdp session shouldn't be null
        _ASSERT(m_pISDPSession != NULL);

        // share session, ignore remote ip

        // get rtcmedia from stream
        if (FAILED(hr = pOther->GetMedia(&pMedia)))
        {
            LOG((RTC_ERROR, "%s get rtc media from stream. %x", __fxName, hr));

            return hr;
        }

        // get sdpmedia
        if (FAILED(hr = pMedia->GetSDPMedia(&pISDPMedia)))
        {
            LOG((RTC_ERROR, "%s get sdp media. %x", __fxName, hr));

            pMedia->Release();

            return hr;
        }

        // add direction
        if (FAILED(hr = pISDPMedia->AddDirections(SDP_SOURCE_LOCAL, Direction)))
        {
            LOG((RTC_ERROR, "%s media (%p) add direction (%d). %x", __fxName, pISDPMedia, Direction, hr));

            pMedia->Release();
            pISDPMedia->Release();  // this is a fake release on session

            return hr;
        }
    }

    //
    // at this point, we have both rtcmedia and sdpmedia ready but sync-ed
    //

    // sync rtcmedia
    if (FAILED(hr = pMedia->Synchronize(TRUE, (DWORD)Direction)))
    {
        // when sync fails, stream is not created.
        LOG((RTC_ERROR, "%s failed to sync media. %x", __fxName, hr));

        if (dwRemoteIP == INADDR_NONE || pOther == NULL)
        {
            // remove both sdp and rtc media
            // rtcmedia keep a pointer to sdpmedia
            // we should remove rtcmedia before removing sdpmedia

            RemoveMedia(pMedia);
            pMedia->Release();

            pISDPMedia->Release();  // this is a fake release on session
            m_pISDPSession->RemoveMedia(pISDPMedia);
        }
        else
        {
            pISDPMedia->RemoveDirections(SDP_SOURCE_LOCAL, (DWORD)Direction);

            pMedia->Release();
            pISDPMedia->Release();
        }

        return hr;
    }

    if (pMedia)
        pMedia->Release();

    if (pISDPMedia)
        pISDPMedia->Release();

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s AddStream (mt=%d, md=%d) %d ms",
        g_strPerf, MediaType, Direction, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    // add preference
    DWORD dwPref = m_MediaCache.TranslatePreference(MediaType, Direction);

    m_MediaCache.AddPreference(dwPref);

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::HasStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    if (MediaType == RTC_MT_DATA)
    {
        if (m_uDataStreamState != RTC_DSS_VOID)
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }
    }
    else
    {
        if (m_MediaCache.HasStream(MediaType, Direction))
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }
    }
}

STDMETHODIMP
CRTCMediaController::RemoveStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("CRTCMediaController::RemoveStream");
    LOG((RTC_TRACE, "%s entered. mt=%x, md=%x", __fxName, MediaType, Direction));

    CComPtr<IRTCStream> pStream;
    CComPtr<IRTCMedia> pMedia;

    // remove preference
    DWORD dwPref = m_MediaCache.TranslatePreference(MediaType, Direction);

    m_MediaCache.RemovePreference(dwPref);

    if (MediaType == RTC_MT_DATA)
    {
        if (S_OK == HasStream(MediaType, Direction))
        {
            return RemoveDataStream ();
        }
        else
        {
            return RTC_E_SIP_STREAM_NOT_PRESENT;
        }
    }

    // get stream
    pStream.p = m_MediaCache.GetStream(MediaType, Direction);

    if (pStream == NULL)
    {
        LOG((RTC_ERROR, "%s no stream"));

        return RTC_E_SIP_STREAM_NOT_PRESENT;
    }

    // get media
    pStream->GetMedia(&pMedia);

    if (pMedia == NULL)
    {
        LOG((RTC_ERROR, "oops %s no media"));
        return E_FAIL;
    }

    // get sdp media
    CComPtr<ISDPMedia> pISDPMedia;

    HRESULT hr;
    if (FAILED(hr = pMedia->GetSDPMedia(&pISDPMedia)))
    {
        LOG((RTC_ERROR, "%s get sdp media. %x", __fxName, hr));

        return hr;
    }

    // remove direction from sdpmedia
    pISDPMedia->RemoveDirections(SDP_SOURCE_LOCAL, (DWORD)Direction);

    hr = pMedia->Synchronize(TRUE, (DWORD)Direction);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to sync media. %x", __fxName));

        return hr;
    }

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::StartStream(       
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("CRTCMediaController::StartStream");

#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    IRTCStream *pStream = m_MediaCache.GetStream(MediaType, Direction);

    if (MediaType == RTC_MT_DATA)
    {
        return StartDataStream ();
    }

    if (pStream == NULL)
    {
        LOG((RTC_ERROR, "%s stream (mt=%x, md=%x) does not exist",
             __fxName, MediaType, Direction));

        return RTC_E_SIP_STREAM_NOT_PRESENT;
    }

    HRESULT hr = pStream->StartStream();

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s StartStream (mt=%d, md=%d) %d ms",
        g_strPerf, MediaType, Direction, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    pStream->Release();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to start stream %p. %x", __fxName, pStream, hr));

        if (hr == E_FAIL)
        {
            return RTC_E_START_STREAM;
        };

        return hr;
    }

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::StopStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("CRTCMediaController::StopStream");

    IRTCStream *pStream = m_MediaCache.GetStream(MediaType, Direction);

    if (MediaType == RTC_MT_DATA)
    {
        return StopDataStream();
    }

    if (pStream == NULL)
    {
        LOG((RTC_ERROR, "%s stream (mt=%x, md=%x) does not exist", __fxName, MediaType, Direction));

        return RTC_E_SIP_STREAM_NOT_PRESENT;
    }

    HRESULT hr = pStream->StopStream();

    pStream->Release();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to stop stream %p. %x", __fxName, pStream, hr));

        return hr;
    }

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::GetStreamState(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    OUT RTC_STREAM_STATE *pState
    )
{
    ENTER_FUNCTION("CRTCMediaController::GetStreamState");

    if (MediaType == RTC_MT_DATA)
    {
        return GetDataStreamState (pState);
    }

    if (IsBadWritePtr(pState, sizeof(RTC_STREAM_STATE)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    // get stream
    IRTCStream *pStream = m_MediaCache.GetStream(MediaType, Direction);

    if (pStream == NULL)
    {
        LOG((RTC_ERROR, "%s stream (mt=%x, md=%x) does not exist", MediaType, Direction));

        return E_UNEXPECTED;
    }

    HRESULT hr = pStream->GetState(pState);

    pStream->Release();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to get stream %p. %x", __fxName, pStream, hr));

        return hr;
    }

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::FreeMediaEvent(
    OUT RTCMediaEventItem *pEventItem
    )
{
    RtcFree(pEventItem);

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::SendDTMFEvent(
    IN DWORD dwId,
    IN DWORD dwEvent,
    IN DWORD dwVolume,
    IN DWORD dwDuration,
    IN BOOL fEnd
    )
{
    ENTER_FUNCTION("CRTCMediaController::SendDTMFEvent");

    // check state
    if (m_State != RTC_MCS_INITIATED)
    {
        LOG((RTC_ERROR, "%s in wrong state. %d", __fxName, m_State));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    // check stream
    CComPtr<IRTCStream> pStream;
    
    pStream.p = m_MediaCache.GetStream(
        RTC_MT_AUDIO, RTC_MD_CAPTURE);

    if (pStream == NULL)
    {
        LOG((RTC_ERROR, "%s no audio send stream.", __fxName));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    return pStream->SendDTMFEvent(
        m_DTMF.GetDTMFSupport()==CRTCDTMF::DTMF_ENABLED, // out-of-band support
        m_DTMF.GetRTPCode(),
        dwId,
        dwEvent,
        dwVolume,
        dwDuration,
        fEnd
        );
}

STDMETHODIMP
CRTCMediaController::OnLossrate(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN DWORD dwLossrate
    )
{
    LOG((RTC_QUALITY, "Lossrate=%d/1000%% mt=%d", dwLossrate, MediaType));

    m_QualityControl.SetPacketLossRate(MediaType, Direction, dwLossrate);

    return AdjustBitrateAlloc();
}

STDMETHODIMP
CRTCMediaController::OnBandwidth(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN DWORD dwBandwidth
    )
{
    LOG((RTC_QUALITY, "Suggested_bw=%d", dwBandwidth));

    if (dwBandwidth == RTP_BANDWIDTH_BANDESTNOTREADY)
    {
        // ignore not ready event
        return S_OK;
    }

    m_QualityControl.SuggestBandwidth(dwBandwidth);

    m_fBWSuggested = TRUE;

    // change audio codec, video bitrate
    AdjustBitrateAlloc();

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::SetMaxBitrate(
    IN DWORD dwMaxBitrate
    )
{
    LOG((RTC_QUALITY, "App_bw=%d", dwMaxBitrate));

    m_QualityControl.SetMaxBitrate(dwMaxBitrate);

    // change audio codec, video bitrate
    AdjustBitrateAlloc();

    return S_OK;
}


STDMETHODIMP
CRTCMediaController::GetMaxBitrate(
    OUT DWORD *pdwMaxBitrate
    )
{
    *pdwMaxBitrate = m_QualityControl.GetMaxBitrate();

    return S_OK;
}


STDMETHODIMP
CRTCMediaController::SetTemporalSpatialTradeOff(
    IN DWORD dwValue
    )
{
    return m_QualityControl.SetTemporalSpatialTradeOff(dwValue);
}

STDMETHODIMP
CRTCMediaController::GetTemporalSpatialTradeOff(
    OUT DWORD *pdwValue
    )
{
    *pdwValue = m_QualityControl.GetTemporalSpatialTradeOff();

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::StartT120Applet(
        UINT    uiAppletID
        )
{
    HRESULT                     hr = S_OK;
    CComPtr<INmObject>          pNmObject;

    LOG((RTC_TRACE, "CRTCMediaController::StartT120Applet - enter"));

    if (S_OK != (hr = EnsureNmRunning(TRUE)))
    {
        goto ExitHere;
    }
    if (S_OK != (hr = m_pNmManager->StartApplet ((NM_APPID)uiAppletID)))
    {
        goto ExitHere;
    }

    LOG((RTC_TRACE, "CRTCMediaController::StartT120Applet - exit S_OK"));

ExitHere:
    return hr;
}  

STDMETHODIMP
CRTCMediaController::StopT120Applets()
{
    LOG((RTC_TRACE, "CRTCMediaController::StopT120Applets - enter"));

    if (m_uDataStreamState != RTC_DSS_VOID)
    {
        LOG((RTC_ERROR, "Data stream not removed"));

        return RTC_E_SIP_STREAM_PRESENT;
    }

    if (m_pNmManager)
    {
        m_pNmManager->Shutdown ();
    }

    m_pNmManager.Release();

    LOG((RTC_ERROR, "CRTCMediaController::StopT120Applets - exit"));

    return S_OK;
}  

STDMETHODIMP
CRTCMediaController::SetEncryptionKey(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN BSTR Key
    )
{
    // only support encryption on audio video
    if (MediaType != RTC_MT_AUDIO && MediaType != RTC_MT_VIDEO)
    {
        return E_INVALIDARG;
    }

    // save the key in mediacache
    HRESULT hr = m_MediaCache.SetEncryptionKey(MediaType, Direction, Key);

    if (FAILED(hr))
        return hr;

    // check if the stream presents
    IRTCStream *pStream = m_MediaCache.GetStream(MediaType, Direction);

    if (pStream == NULL)
        return S_OK;

    hr = pStream->SetEncryptionKey(Key);

    pStream->Release();

    return hr;
}

// network quality: [0, 100].
// higher value better quality
STDMETHODIMP
CRTCMediaController::GetNetworkQuality(
    OUT DWORD *pdwValue
    )
{
    // get audio send and video send stream
    CComPtr<IRTCStream> pAudioSend, pVideoSend;

    pAudioSend.Attach(m_MediaCache.GetStream(RTC_MT_AUDIO, RTC_MD_CAPTURE));
    pVideoSend.Attach(m_MediaCache.GetStream(RTC_MT_VIDEO, RTC_MD_CAPTURE));

    HRESULT hrAud = S_FALSE;
    HRESULT hrVid = S_FALSE;

    DWORD dwAud = 0;
    DWORD dwAudAge = 0;
    DWORD dwVid = 0;
    DWORD dwVidAge = 0;

    // get quality value from audio and video
    if (pAudioSend)
    {
        if (FAILED(hrAud = pAudioSend->GetNetworkQuality(&dwAud, &dwAudAge)))
        {
            LOG((RTC_ERROR, "failed to get net quality on audio. %x", hrAud));

            return hrAud;
        }

        LOG((RTC_TRACE, "NETWORK QUALITY: Audio=%d, Age=%d", dwAud, dwAudAge));
    }

    if (pVideoSend)
    {
        if (FAILED(hrVid = pVideoSend->GetNetworkQuality(&dwVid, &dwVidAge)))
        {
            LOG((RTC_ERROR, "failed to get net quality on video. %x", hrVid));

            return hrVid;
        }

        LOG((RTC_TRACE, "NETWORK QUALITY: Video=%d, Age=%d", dwVid, dwVidAge));
    }

    // both S_FALSE
    if (hrAud==S_FALSE && hrVid==S_FALSE)
    {
        *pdwValue = 0;

        return RTC_E_SIP_NO_STREAM;
    }

#define MAX_AGE_GAP 8

    if (hrAud==S_OK && hrVid==S_OK)
    {
        // both valid value
        if (dwAudAge>dwVidAge && dwAudAge-dwVidAge>=MAX_AGE_GAP)
        {
            // audio is too old
            *pdwValue = dwVid;
        }
        else if (dwVidAge>dwAudAge && dwVidAge-dwAudAge>=MAX_AGE_GAP)
        {
            // video is too old
            *pdwValue = dwAud;
        }
        else
        {
            DOUBLE f = 0.7*dwAud+0.3*dwVid;
            DWORD d = (DWORD)f;

            if (f-d >= 0.5)
            {
                *pdwValue = d+1;
            }
            else
            {
                *pdwValue = d;
            }
        }
    }
    else
    {
        // only one has valid value
        *pdwValue = dwAud+dwVid;
    }

    LOG((RTC_TRACE, "NETWORK QUALITY: result=%d", *pdwValue));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// SetPortManager
//

STDMETHODIMP
CRTCMediaController::SetPortManager(
    IN IUnknown *pPortManager
    )
{
    ENTER_FUNCTION("CRTCMediaController::SetPortManager");

    CComPtr<IRTCPortManager> pIRTCPortManager;

    HRESULT hr;

    if (pPortManager != NULL)
    {
        // QI IRTCPortManager

        if (FAILED(hr = pPortManager->QueryInterface(&pIRTCPortManager)))
        {
            LOG((RTC_ERROR, "%s QI IRTCPortManager %x", __fxName, hr));

            return hr;
        }
    }

    // set pm on port cache
    return m_PortCache.SetPortManager(pIRTCPortManager);
}

//
// IRTCMediaManagePriv methods
//

/*//////////////////////////////////////////////////////////////////////////////
    insert an event into the event list
////*/

const CHAR * const g_pszMediaEventName[] =
{
    "STREAM CREATED",      // new stream created by media
    "STREAM REMOVED",      // stream removed by media
    "STREAM ACTIVE",       // stream active
    "STREAM INACTIVE",     // stream inactive
    "STREAM FAIL",         // stream failed due to some error
    // "TERMINAL_ADDED",   // usb device plugged in
    "TERMINAL REMOVED",    // usb devide removed
    "VOLUME CHANGE",
    "REQUEST RELEASE WAVEBUF",   // request to release wave buf
    "LOSSRATE",
    "BANDWIDTH",
    "NETWORK QUALITY",
    "T120 FAIL"            // t120 related failure
};

STDMETHODIMP
CRTCMediaController::PostMediaEvent(
    IN RTC_MEDIA_EVENT Event,
    IN RTC_MEDIA_EVENT_CAUSE Cause,
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN HRESULT hrError
    )
{
    CLock lock(m_EventLock);

    // DebugInfo holds the number of message being posted.
    static UINT uiDebugInfo = 0;

    RTCMediaEventItem *pEventItem = (RTCMediaEventItem*)RtcAlloc(sizeof(RTCMediaEventItem));

    if (pEventItem == NULL)
    {
        // caller will generate error message
        return E_OUTOFMEMORY;
    }

    _ASSERT(Event < RTC_ME_LAST);

    // event
    pEventItem->Event = Event;
    pEventItem->Cause = Cause;
    pEventItem->MediaType = MediaType;
    pEventItem->Direction = Direction;
    pEventItem->hrError = hrError;
    pEventItem->uiDebugInfo = uiDebugInfo;

    LOG((RTC_EVENT, "PostMediaEvent: event=%s, cause=%x, mt=%x, dir=%x, hr=%x, dbg=%d",
         g_pszMediaEventName[Event], Cause, MediaType, Direction, hrError, uiDebugInfo));

    DWORD dwError = 0;
    if (!PostMessage(m_hWnd, m_uiEventID, (WPARAM)Event, (LPARAM)pEventItem))
    {
        dwError = GetLastError();
        LOG((RTC_ERROR, "CRTCMediaController::PostEvent failed to post message. %d", dwError));

        RtcFree(pEventItem);
        return E_FAIL;
    }

    uiDebugInfo++;

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::SendMediaEvent(
    IN RTC_MEDIA_EVENT Event
    )
{
    RTCMediaEventItem *pEventItem = (RTCMediaEventItem*)RtcAlloc(sizeof(RTCMediaEventItem));

    if (pEventItem == NULL)
    {
        // caller will generate error message
        return E_OUTOFMEMORY;
    }

    // event
    pEventItem->Event = Event;
    pEventItem->Cause = RTC_ME_CAUSE_UNKNOWN;
    pEventItem->MediaType = RTC_MT_AUDIO;
    pEventItem->Direction = RTC_MD_CAPTURE;
    pEventItem->hrError = S_OK;
    pEventItem->uiDebugInfo = 0;

    return (HRESULT)SendMessage(m_hWnd, m_uiEventID, (WPARAM)Event, (LPARAM)pEventItem);
}

STDMETHODIMP
CRTCMediaController::AllowStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    if (m_MediaCache.AllowStream(MediaType, Direction))
        return S_OK;
    else
        return S_FALSE;
}

STDMETHODIMP
CRTCMediaController::HookStream(
    IN IRTCStream *pStream
    )
{
    return m_MediaCache.HookStream(pStream);
}

STDMETHODIMP
CRTCMediaController::UnhookStream(
    IN IRTCStream *pStream
    )
{
    return m_MediaCache.UnhookStream(pStream);
}

/*//////////////////////////////////////////////////////////////////////////////
    select local interface based on remote ip addr
////*/

HRESULT
CRTCMediaController::SelectLocalInterface(
    IN DWORD dwRemoteIP,
    OUT DWORD *pdwLocalIP
    )
{
    ENTER_FUNCTION("SelectLocalInterface");

    *pdwLocalIP = INADDR_NONE;

    if (m_hSocket == NULL)
    {
        LOG((RTC_ERROR, "%s socket is null", __fxName));
        return E_UNEXPECTED;
    }

    // construct destination addr

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = htonl(dwRemoteIP);

    SOCKADDR_IN LocAddr;

    // query for default address based on destination
#if 0
    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    dwStatus = WSAIoctl(
        m_hSocket, // SOCKET s
        SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
        &DestAddr,           // LPVOID lpvInBuffer
        sizeof(SOCKADDR_IN), // DWORD cbInBuffer
        &LocAddr,            // LPVOID lpvOUTBuffer
        dwLocAddrSize,       // DWORD cbOUTBuffer
        &dwNumBytesReturned, // LPDWORD lpcbBytesReturned
        NULL, // LPWSAOVERLAPPED lpOverlapped
        NULL  // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
        );

    if (dwStatus == SOCKET_ERROR) 
    {
        dwStatus = WSAGetLastError();

        LOG((RTC_ERROR, "WSAIoctl failed: %d (0x%X)", dwStatus, dwStatus));

        return E_FAIL;
    } 
#else
    int     RetVal;
    DWORD   WinsockErr;
    int     LocalAddrLen = sizeof(LocAddr);

    // create a new socket
    if (m_hIntfSelSock == INVALID_SOCKET)
    {
        m_hIntfSelSock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

        if (m_hIntfSelSock == INVALID_SOCKET)
        {
            WinsockErr = WSAGetLastError();
            LOG((RTC_ERROR,
                 "%s socket failed : %x", __fxName, WinsockErr));
            return HRESULT_FROM_WIN32(WinsockErr);
        }
    }

    // Fake some port
    DestAddr.sin_port           = htons(5060);
    
    RetVal = connect(m_hIntfSelSock, (SOCKADDR *) &DestAddr,
                     sizeof(SOCKADDR_IN));
    if (RetVal == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR,
             "%s connect failed : %x", __fxName, WinsockErr));
        return HRESULT_FROM_WIN32(WinsockErr);
    }
    
    RetVal = getsockname(m_hIntfSelSock, (SOCKADDR *) &LocAddr,
                         &LocalAddrLen);

    if (RetVal == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR,
             "%s getsockname failed : %x", __fxName, WinsockErr));
        return HRESULT_FROM_WIN32(WinsockErr);
    }

#endif

    DWORD dwAddr = ntohl(LocAddr.sin_addr.s_addr);

    if (dwAddr == 0x7f000001)
    {
        // it is loopback address
        *pdwLocalIP = dwRemoteIP;
    }
    else
    {
        *pdwLocalIP = dwAddr;
    }

    LOG((RTC_TRACE, "%s  input remote %s", __fxName, inet_ntoa(DestAddr.sin_addr)));
    LOG((RTC_TRACE, "%s output  local %s", __fxName, inet_ntoa(LocAddr.sin_addr)));
    return S_OK;
}

//
// IRTCTerminalManage methods
//

STDMETHODIMP
CRTCMediaController::GetStaticTerminals(
    IN OUT DWORD *pdwCount,
    OUT IRTCTerminal **ppTerminal
    )
{
    ENTER_FUNCTION("CRTCMediaController::GetStaticTerminals");

    if (IsBadWritePtr(pdwCount, sizeof(DWORD)))
        return E_POINTER;

    if (ppTerminal == NULL)
    {
        // just return the number of terminals
        *pdwCount = m_Terminals.GetSize();

        return S_FALSE;
    }

    if (IsBadWritePtr(ppTerminal, sizeof(IRTCTerminal*)*(*pdwCount)))
        return E_POINTER;

    // check if *pdwCount is large enough
    if (*pdwCount < (DWORD)m_Terminals.GetSize())
    {
        LOG((RTC_TRACE, "%s: input count is too small", __fxName));

        *pdwCount = (DWORD)m_Terminals.GetSize();
        *ppTerminal = NULL;

        return RTCMEDIA_E_SIZETOOSMALL;
    }

    *pdwCount = (DWORD)m_Terminals.GetSize();

    // copy each media pointer
    for (DWORD i=0; i<*pdwCount; i++)
    {
        m_Terminals[i]->AddRef();
        ppTerminal[i] = m_Terminals[i];
    }

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::GetDefaultTerminal(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    OUT IRTCTerminal **ppTerminal
    )
{
    ENTER_FUNCTION("CRTCMediaController::GetDefaultTerminal");

    if (IsBadWritePtr(ppTerminal, sizeof(IRTCTerminal*)))
        return E_POINTER;

    *ppTerminal = m_MediaCache.GetDefaultTerminal(MediaType, Direction);

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::GetVideoPreviewTerminal(
    OUT IRTCTerminal **ppTerminal
    )
{
    if (IsBadWritePtr(ppTerminal, sizeof(IRTCTerminal*)))
        return E_POINTER;

    *ppTerminal = m_MediaCache.GetVideoPreviewTerminal();

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
////*/
STDMETHODIMP
CRTCMediaController::SetDefaultStaticTerminal(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN IRTCTerminal *pTerminal
    )
{
    ENTER_FUNCTION("CRTCMediaController::SetDefaultStaticTerminal");

    if (pTerminal != NULL)
    {
        if (IsBadReadPtr(pTerminal, sizeof(IRTCTerminal)))
            return E_POINTER;
    }

    if (MediaType == RTC_MT_VIDEO && Direction == RTC_MD_RENDER)
        return E_INVALIDARG;

    m_MediaCache.SetDefaultStaticTerminal(MediaType, Direction, pTerminal);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    get a list of devices
    for every terminal check if it has a device associated
        if yes and it is a video terminal, update the terminal, mark the device
        if no and the terminal is not in use, remove the terminal
        *if no and the terminal is in use, stop the stream, unselect&remove term
    for every unmarked device
        create a new terminal

    if the path with * is hit
        post event to trigger tuning wizard.
////*/

STDMETHODIMP
CRTCMediaController::UpdateStaticTerminals()
{
    ENTER_FUNCTION("UpdateStaticTerminals");
    LOG((RTC_TRACE, "%s entered", __fxName));

    HRESULT hr;

    DWORD dwCount = 0;
    CRTCTerminal *pCTerminal;
    RTCDeviceInfo *pDeviceInfo = NULL;

    // get device list
#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    hr = GetDevices(&dwCount, &pDeviceInfo);

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s GetDevices %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to get device info. %x", __fxName, hr));
        return hr;
    }

    // there is no device
    if (dwCount == 0)
    {
        // remove all terminals
        m_MediaCache.SetDefaultStaticTerminal(RTC_MT_AUDIO, RTC_MD_CAPTURE, NULL);
        m_MediaCache.SetDefaultStaticTerminal(RTC_MT_AUDIO, RTC_MD_RENDER, NULL);
        m_MediaCache.SetDefaultStaticTerminal(RTC_MT_VIDEO, RTC_MD_CAPTURE, NULL);

        for (int i=0; i<m_Terminals.GetSize(); i++)
        {
            pCTerminal = static_cast<CRTCTerminal*>(m_Terminals[i]);
            pCTerminal->Shutdown();
            m_Terminals[i]->Release();
        }

        m_Terminals.RemoveAll();

        return S_OK;
    }

    //
    // now we got some devices
    //

    // for each terminal, check if it is associated with a device
    int iTermIndex = 0;
    BOOL fTermHasDevice;
    RTC_MEDIA_TYPE MediaType;
    RTC_MEDIA_DIRECTION Direction;

    while (m_Terminals.GetSize() > iTermIndex)
    {
        fTermHasDevice = FALSE;

        // get terminal object pointer
        pCTerminal = static_cast<CRTCTerminal*>(m_Terminals[iTermIndex]);
        
        for (DWORD i=0; i<dwCount; i++)
        {
            if (pDeviceInfo[i].uiMark)
                // already matched to a terminal
                continue;

            // does the terminal have this device?

            if (S_OK == pCTerminal->HasDevice(&pDeviceInfo[i]))
            {
                fTermHasDevice = TRUE;

                // mark the device
                pDeviceInfo[i].uiMark = 1;

                // update terminal
                hr = pCTerminal->UpdateDeviceInfo(&pDeviceInfo[i]);
                if (FAILED(hr))
                {
                    LOG((RTC_ERROR, "%s failed to set device info to terminal: %p. %x",
                         __fxName, m_Terminals[iTermIndex], hr));
                }

                break;
            }
        }

        if (!fTermHasDevice)
        {
            // terminal should be removed, is it a default terminal?
            m_Terminals[iTermIndex]->GetMediaType(&MediaType);
            m_Terminals[iTermIndex]->GetDirection(&Direction);

            IRTCTerminal *pDefault = m_MediaCache.GetDefaultTerminal(MediaType, Direction);

            if (m_Terminals[iTermIndex] == pDefault)
            {
                // the default needs to be removed
                m_MediaCache.SetDefaultStaticTerminal(MediaType, Direction, NULL);
            }

            if (pDefault != NULL)
            {
                pDefault->Release();
            }

            hr = pCTerminal->Shutdown();
            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s failed to shutdown terminal. %x", __fxName, hr));
            }

            m_Terminals[iTermIndex]->Release();

            m_Terminals.RemoveAt(iTermIndex);
        }
        else
        {
            // terminal was updated, move to the next one
            iTermIndex ++;
        }
    } // end of loop through each terminal

    // for each new device, create a terminal
    IRTCTerminal *pITerminal;
    IRTCTerminalManage *pTerminalManager = static_cast<IRTCTerminalManage*>(this);

    WCHAR szGUID[CHARS_IN_GUID+1];

    for (DWORD i=0; i<dwCount; i++)
    {
        if (!pDeviceInfo[i].uiMark)
        {
            LOG((RTC_INFO, "new device: type %x, dir %x, desp %ws",
                 pDeviceInfo[i].MediaType,
                 pDeviceInfo[i].Direction,
                 pDeviceInfo[i].szDescription
                 ));

            if (StringFromGUID2(pDeviceInfo[i].Guid, szGUID, CHARS_IN_GUID+1) > 0)
            {
                LOG((RTC_INFO, "            waveid %u, guid %ws",
                    pDeviceInfo[i].uiDeviceID,
                    szGUID
                    ));
            }

            // this is a new device
            hr = CRTCTerminal::CreateInstance(
                pDeviceInfo[i].MediaType,
                pDeviceInfo[i].Direction,
                &pITerminal
                );
            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s: create terminal failure %ws. %x",
                     __fxName, pDeviceInfo[i].szDescription, hr));
                // continue to check devices
                continue;
            }

            pCTerminal = static_cast<CRTCTerminal*>(pITerminal);

            // initiate the terminal
            hr = pCTerminal->Initialize(&pDeviceInfo[i], pTerminalManager);
            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s failed to initiate terminal %p. %x",
                     __fxName, pCTerminal, hr));

                pITerminal->Release();

                continue;
            }

            // insert the terminal into our array
            if (!m_Terminals.Add(pITerminal))
            {
                LOG((RTC_ERROR, "%s failed to add terminal", __fxName));

                // out of memory, should return
                pCTerminal->Shutdown(); // no need to check return value
                pITerminal->Release();

                FreeDevices(pDeviceInfo);

                return E_OUTOFMEMORY;
            }
        } // if new device
    } // end of for each device

    FreeDevices(pDeviceInfo);

    LOG((RTC_TRACE, "%s exiting", __fxName));
    return S_OK;
}

//
// IRTCTuningManage methods
//

STDMETHODIMP
CRTCMediaController::IsAECEnabled(
    IN IRTCTerminal *pAudCapt,     // capture
    IN IRTCTerminal *pAudRend,     // render
    OUT BOOL *pfEnableAEC
    )
{
    DWORD index;
    BOOL fFound = FALSE;

    HRESULT hr = CRTCAudioTuner::RetrieveAECSetting(
                        pAudCapt, pAudRend, pfEnableAEC, &index, &fFound);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "IsAECEnabled 0x%x", hr));

        return hr;
    }

    if (!fFound)
    {
        // default true
        *pfEnableAEC = TRUE;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    initialize internal audio capt and rend tuner
////*/

STDMETHODIMP
CRTCMediaController::InitializeTuning(
    IN IRTCTerminal *pAudCaptTerminal,
    IN IRTCTerminal *pAudRendTerminal,
    IN BOOL fEnableAEC
    )
{
    // start testing
#ifdef TEST_VIDEO_TUNING

    CComPtr<IRTCTerminal> pCapture;
    CComPtr<IRTCTerminal> pRender;

    GetDefaultTerminal(RTC_MT_VIDEO, RTC_MD_CAPTURE, &pCapture);

    GetDefaultTerminal(RTC_MT_VIDEO, RTC_MD_RENDER, &pRender);

    StartVideo(pCapture, pRender);

    // show IVideoWindow
    CComPtr<IRTCVideoConfigure> pVideoConfigure;
    IVideoWindow *pVideoWindow;

    if (pRender)
    {
        if (SUCCEEDED(pRender->QueryInterface(
                        __uuidof(IRTCVideoConfigure),
                        (void**)&pVideoConfigure
                        )))
        {
            if (SUCCEEDED(pVideoConfigure->GetIVideoWindow((LONG_PTR**)&pVideoWindow)))
            {
                pVideoWindow->put_Visible(OATRUE);
                pVideoWindow->Release();
            }
        }
    }
#endif
    // end testing

    ENTER_FUNCTION("CRTCMediaController::InitializeTuning");

    LOG((RTC_TRACE, "%s entered", __fxName));

    // cannot tune while in a call
    if (m_pISDPSession != NULL ||
        m_Medias.GetSize() != 0)
    {
        LOG((RTC_ERROR, "%s in a call", __fxName));

        return E_UNEXPECTED;
    }

    // check input param
    if (pAudCaptTerminal != NULL)
    {
        if (IsBadReadPtr(pAudCaptTerminal, sizeof(IRTCTerminal)))
        {
            LOG((RTC_ERROR, "%s bad pointer", __fxName));

            return E_POINTER;
        }
    }
    if (pAudRendTerminal != NULL)
    {
        if (IsBadReadPtr(pAudRendTerminal, sizeof(IRTCTerminal)))
        {
            LOG((RTC_ERROR, "%s bad pointer", __fxName));

            return E_POINTER;
        }
    }

    if (pAudCaptTerminal == NULL && pAudRendTerminal == NULL)
    {
        LOG((RTC_ERROR, "%s no terminal.", __fxName));

        return E_UNEXPECTED;
    }

    // check state
    if (m_State != RTC_MCS_INITIATED)
    {
        LOG((RTC_ERROR, "%s wrong state. %d", __fxName, m_State));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    // check if we can support AEC
    if (fEnableAEC && (pAudCaptTerminal==NULL || pAudRendTerminal==NULL))
    {
        LOG((RTC_ERROR, "%s not both term available. AEC can't be enabled", __fxName));

        return E_INVALIDARG;
    }

    HRESULT hr;

    // create duplex control
    CComPtr<IAudioDuplexController> pAEC;

    hr = CoCreateInstance(
        __uuidof(TAPIAudioDuplexController),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IAudioDuplexController),
        (void **) &pAEC
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create duplex controller. %x", __fxName, hr));

        return hr;
    }

    UINT uiVolume;

    // init audio tuner
    if (pAudCaptTerminal)
    {
        hr = m_AudioCaptTuner.InitializeTuning(pAudCaptTerminal, pAEC, fEnableAEC);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s init audio capt. %x", __fxName, hr));

            return hr;
        }

        // get system volume
        //GetSystemVolume(pAudCaptTerminal, &uiVolume);

        //m_AudioCaptTuner.SetVolume(uiVolume);
    }

    if (pAudRendTerminal)
    {
        hr = m_AudioRendTuner.InitializeTuning(pAudRendTerminal, pAEC, fEnableAEC);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s init audio rend. %x", __fxName, hr));

            if (pAudCaptTerminal)
            {
                m_AudioCaptTuner.ShutdownTuning();
            }

            return hr;
        }

        // get system volume
        //GetSystemVolume(pAudRendTerminal, &uiVolume);

        //m_AudioRendTuner.SetVolume(uiVolume);
    }

    m_State = RTC_MCS_TUNING;

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::StartTuning(
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    ENTER_FUNCTION("CRTCMediaController::StartTuning");

#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    HRESULT hr = S_OK;

    // check state
    if (m_State != RTC_MCS_TUNING)
    {
        LOG((RTC_ERROR, "%s wrong state. %d", __fxName, m_State));

        return E_UNEXPECTED;
    }

    // clear wave buf
    SendMediaEvent(RTC_ME_REQUEST_RELEASE_WAVEBUF);

    if (Direction == RTC_MD_CAPTURE)
    {
        m_fAudCaptInTuning = TRUE;

        if (m_AudioRendTuner.HasTerminal())
        {
            // start capt tuner in helper mode to have
            // audio duplex controller ready
            if (SUCCEEDED(hr = m_AudioCaptTuner.StartTuning(TRUE)))
            {
                hr = m_AudioRendTuner.StartTuning(TRUE);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_AudioCaptTuner.StartTuning(FALSE);
        }

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s StartTuning (AudCapt) %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

        return hr;
    }
    else
    {
        m_fAudCaptInTuning = FALSE;

        if (m_AudioCaptTuner.HasTerminal())
        {
            hr = m_AudioCaptTuner.StartTuning(TRUE);
        }

        if (SUCCEEDED(hr))
        {
            hr = m_AudioRendTuner.StartTuning(FALSE);
        }

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s StartTuning (AudRend) %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

        return hr;
    }
}

STDMETHODIMP
CRTCMediaController::StopTuning(
    IN BOOL fSaveSetting
    )
{
    ENTER_FUNCTION("CRTCMediaController::StopTuning");

    // check state
    if (m_State != RTC_MCS_TUNING)
    {
        LOG((RTC_ERROR, "%s wrong state. %d", __fxName, m_State));

        return E_UNEXPECTED;
    }

    // stop both audio tuner
    if (m_AudioCaptTuner.IsTuning())
    {
        if (m_fAudCaptInTuning) // we are tuning audio capt
        {
            m_AudioCaptTuner.StopTuning(FALSE, fSaveSetting);
        }
        else
        {
            m_AudioCaptTuner.StopTuning(TRUE, FALSE);
        }
    }

    if (m_AudioRendTuner.IsTuning())
    {
        if (!m_fAudCaptInTuning) // we are tuning audio rend
        {
            m_AudioRendTuner.StopTuning(FALSE, fSaveSetting);
        }
        else
        {
            m_AudioRendTuner.StopTuning(TRUE, FALSE);
        }
    }

    return S_OK;
}

//
// save AEC setting for both terminals
//
STDMETHODIMP
CRTCMediaController::SaveAECSetting()
{
    HRESULT hr = S_OK;

    if (m_AudioCaptTuner.HasTerminal() && m_AudioRendTuner.HasTerminal())
    {
        // both have terminals, save AEC status
        IRTCTerminal *paudcapt, *paudrend;

        paudcapt = m_AudioCaptTuner.GetTerminal();
        paudrend = m_AudioRendTuner.GetTerminal();

        hr = CRTCAudioTuner::StoreAECSetting(
            paudcapt,
            paudrend,
            m_AudioCaptTuner.GetAEC() && m_AudioRendTuner.GetAEC()
            );

        paudcapt->Release();
        paudrend->Release();
    }

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "failed to save AEC"));
    }

    return hr;
}

STDMETHODIMP
CRTCMediaController::ShutdownTuning()
{
    // start testing
#ifdef TEST_VIDEO_TUNING

    StopVideo();

#endif
    // stop testing

    ENTER_FUNCTION("CRTCMediaController::ShutdownTuning");

    // check state
    if (m_State != RTC_MCS_TUNING)
    {
        LOG((RTC_ERROR, "%s wrong state. %d", __fxName, m_State));

        // return S_OK
        // return S_OK;
    }

    m_AudioCaptTuner.ShutdownTuning();
    m_AudioRendTuner.ShutdownTuning();

    m_State = RTC_MCS_INITIATED;

    return S_OK;
}

// video tuning
STDMETHODIMP
CRTCMediaController::StartVideo(
    IN IRTCTerminal *pVidCaptTerminal,
    IN IRTCTerminal *pVidRendTerminal
    )
{
    // check state
    if (m_State != RTC_MCS_INITIATED)
    {
        LOG((RTC_ERROR, "StartVideo wrong state."));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    // cannot tune while in a call
    if (m_pISDPSession != NULL ||
        m_Medias.GetSize() != 0)
    {
        LOG((RTC_ERROR, "StartVideo in a call"));

        return E_UNEXPECTED;
    }

#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    HRESULT hr = m_VideoTuner.StartVideo(pVidCaptTerminal, pVidRendTerminal);

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s PreviewVideo %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    if (hr == S_OK)
    {
        m_State = RTC_MCS_TUNING;
    }

    return hr;
}

STDMETHODIMP
CRTCMediaController::StopVideo()
{
    // cannot tune while in a call
    // check state
    if (m_State != RTC_MCS_TUNING)
    {
        LOG((RTC_ERROR, "StopVideo wrong state."));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    if (m_pISDPSession != NULL ||
        m_Medias.GetSize() != 0)
    {
        LOG((RTC_ERROR, "StopVideo in a call"));

        return E_UNEXPECTED;
    }

    m_State = RTC_MCS_INITIATED;

    return m_VideoTuner.StopVideo();
}

/*//////////////////////////////////////////////////////////////////////////////
    get min and max value of audio volume
////*/

STDMETHODIMP
CRTCMediaController::GetVolumeRange(
    IN RTC_MEDIA_DIRECTION Direction,
    OUT UINT *puiMin,
    OUT UINT *puiMax
    )
{
    if (IsBadWritePtr(puiMin, sizeof(UINT)) ||
        IsBadWritePtr(puiMax, sizeof(UINT)))
    {
        LOG((RTC_ERROR, "CRTCMediaController::GetVolumeRange bad pointer"));

        return E_POINTER;
    }

    *puiMin = RTC_MIN_AUDIO_VOLUME;
    *puiMax = RTC_MAX_AUDIO_VOLUME;

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::GetVolume(
    IN RTC_MEDIA_DIRECTION Direction,
    OUT UINT *puiVolume
    )
{
    if (IsBadWritePtr(puiVolume, sizeof(UINT)))
        return E_POINTER;

    if (Direction == RTC_MD_CAPTURE)
        return m_AudioCaptTuner.GetVolume(puiVolume);
    else
        return m_AudioRendTuner.GetVolume(puiVolume);
}

STDMETHODIMP
CRTCMediaController::SetVolume(
    IN RTC_MEDIA_DIRECTION Direction,
    IN UINT uiVolume
    )
{
    if (Direction == RTC_MD_CAPTURE)
        return m_AudioCaptTuner.SetVolume(uiVolume);
    else
        return m_AudioRendTuner.SetVolume(uiVolume);
}

STDMETHODIMP
CRTCMediaController::GetSystemVolume(
    IN IRTCTerminal *pTerminal,
    OUT UINT *puiVolume
    )
{
    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;

    pTerminal->GetMediaType(&mt);
    pTerminal->GetDirection(&md);

    *puiVolume = RTC_MAX_AUDIO_VOLUME / 2;

    // only support audio
    if (mt != RTC_MT_AUDIO)
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    UINT uiWaveID;
    UINT uiVolume;

    if (md == RTC_MD_CAPTURE)
    {
        // audio capture        
        static_cast<CRTCTerminalAudCapt*>(pTerminal)->GetWaveID(&uiWaveID);

        hr = DirectGetCaptVolume(uiWaveID, &uiVolume);

        if (SUCCEEDED(hr))
        {
            *puiVolume = uiVolume;
        }
    }
    else
    {
        // audio render
        static_cast<CRTCTerminalAudRend*>(pTerminal)->GetWaveID(&uiWaveID);

        hr = DirectGetRendVolume(uiWaveID, &uiVolume);

        if (SUCCEEDED(hr))
        {
            *puiVolume = uiVolume;
        }
    }

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::GetAudioLevelRange(
    IN RTC_MEDIA_DIRECTION Direction,
    OUT UINT *puiMin,
    OUT UINT *puiMax
    )
{
    if (Direction != RTC_MD_CAPTURE)
        return E_NOTIMPL;

    if (IsBadWritePtr(puiMin, sizeof(UINT)) ||
        IsBadWritePtr(puiMax, sizeof(UINT)))
    {
        LOG((RTC_ERROR, "CRTCMediaController::GetAudioLevelRange bad pointer"));

        return E_POINTER;
    }

    *puiMin = RTC_MIN_AUDIO_LEVEL;
    *puiMax = RTC_MAX_AUDIO_LEVEL;

    return S_OK;
}

STDMETHODIMP
CRTCMediaController::GetAudioLevel(
    IN RTC_MEDIA_DIRECTION Direction,
    OUT UINT *puiLevel
    )
{
    if (IsBadWritePtr(puiLevel, sizeof(UINT)))
        return E_POINTER;

    if (Direction == RTC_MD_CAPTURE)
        return m_AudioCaptTuner.GetAudioLevel(puiLevel);
    else
        return m_AudioRendTuner.GetAudioLevel(puiLevel);
}

#if 0
//
// IRTCQualityControl methods
//

STDMETHODIMP
CRTCMediaController::GetRange (
    IN RTC_QUALITY_PROPERTY Property,
    OUT LONG *plMin,
    OUT LONG *plMax,
    OUT RTC_QUALITY_CONTROL_MODE *pMode
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRTCMediaController::Get (
    IN RTC_QUALITY_PROPERTY Property,
    OUT LONG *plValue,
    OUT RTC_QUALITY_CONTROL_MODE *pMode
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRTCMediaController::Set (
    IN RTC_QUALITY_PROPERTY Property,
    IN LONG lValue,
    IN RTC_QUALITY_CONTROL_MODE Mode
    )
{
    return E_NOTIMPL;
}

#endif

//
// protected methods
//

HRESULT
CRTCMediaController::GetDevices(
    OUT DWORD *pdwCount,
    OUT RTCDeviceInfo **ppDeviceInfo
    )
{
    HRESULT hr;

    // audio function pointer
    PFNAudioGetDeviceInfo       pfnGetCaptAudInfo = NULL,
                                pfnGetRendAudInfo = NULL;
    PFNAudioReleaseDeviceInfo   pfnReleaseCaptAudInfo = NULL,
                                pfnReleaseRendAudInfo = NULL;
    // audio device info
    DWORD                       dwNumCaptAud = 0,
                                dwNumRendAud = 0;
    AudioDeviceInfo            *pCaptAudInfo = NULL,
                               *pRendAudInfo = NULL;

    // video function pointer
    PFNGetNumCapDevices         pfnGetCaptVidNum = NULL;
    PFNGetCapDeviceInfo         pfnGetCaptVidInfo = NULL;
    // video device info
    DWORD                       dwNumCaptVid = 0;
    VIDEOCAPTUREDEVICEINFO      CaptVidInfo;

    ENTER_FUNCTION("CRTCMediaController::GetDevices");

    // initiate output value
    *pdwCount = 0;
    *ppDeviceInfo = NULL;

    // load library
    if (m_hDxmrtp == NULL)
    {
        m_hDxmrtp = LoadLibrary(TEXT("dxmrtp"));

        if (m_hDxmrtp == NULL)
        {
            LOG((RTC_ERROR, "%s failed to load dxmrtp.dll. %d", __fxName, GetLastError()));
            return E_FAIL;
        }
    }

    // audio capture: function pointer
    pfnGetCaptAudInfo = (PFNAudioGetDeviceInfo)GetProcAddress(
        m_hDxmrtp, "AudioGetCaptureDeviceInfo"
        );
    if (pfnGetCaptAudInfo == NULL)
    {
        LOG((RTC_ERROR, "%s failed to get audio capt func pointer. %d",
             __fxName, GetLastError()));
    }
    else
    {
        pfnReleaseCaptAudInfo = (PFNAudioReleaseDeviceInfo)GetProcAddress(
            m_hDxmrtp, "AudioReleaseCaptureDeviceInfo"
            );

        if (pfnReleaseCaptAudInfo == NULL)
        {
            pfnGetCaptAudInfo = NULL;

            LOG((RTC_ERROR, "%s failed to get audio capt func pointer. %d",
                 __fxName, GetLastError()));
        }
    }

    // audio render: function pointer
    pfnGetRendAudInfo = (PFNAudioGetDeviceInfo)GetProcAddress(
        m_hDxmrtp, "AudioGetRenderDeviceInfo"
        );
    if (pfnGetRendAudInfo == NULL)
    {
        LOG((RTC_ERROR, "%s failed to get audio rend func pointer. %d",
             __fxName, GetLastError()));
    }
    else
    {
        pfnReleaseRendAudInfo = (PFNAudioReleaseDeviceInfo)GetProcAddress(
            m_hDxmrtp, "AudioReleaseRenderDeviceInfo"
            );

        if (pfnReleaseRendAudInfo == NULL)
        {
            pfnGetRendAudInfo = NULL;

            LOG((RTC_ERROR, "%s failed to get audio rend func pointer. %d",
                 __fxName, GetLastError()));
        }
    }

    // video capture: function pointer
    pfnGetCaptVidNum = (PFNGetNumCapDevices)GetProcAddress(
        m_hDxmrtp, "GetNumVideoCapDevices"
        );
    if (pfnGetCaptVidNum == NULL)
    {
        LOG((RTC_ERROR, "%s failed to get video capt func pointer. %d",
             __fxName, GetLastError()));
    }
    else
    {
        pfnGetCaptVidInfo = (PFNGetCapDeviceInfo)GetProcAddress(
            m_hDxmrtp, "GetVideoCapDeviceInfo"
            );

        if (pfnGetCaptVidInfo == NULL)
        {
            pfnGetCaptVidNum = NULL;

            LOG((RTC_ERROR, "%s failed to get video capt func pointer. %d",
                 __fxName, GetLastError()));
        }
    }

    // audio capture: get devices
    if (pfnGetCaptAudInfo)
    {
        hr = (*pfnGetCaptAudInfo)(&dwNumCaptAud, &pCaptAudInfo);
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s failed to get aud cap info. %x", __fxName, hr));

            dwNumCaptAud = 0;
            pCaptAudInfo = NULL;
        }
    }

    // audio render: get devices
    if (pfnGetRendAudInfo)
    {
        hr = (*pfnGetRendAudInfo)(&dwNumRendAud, &pRendAudInfo);
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s failed to get aud rend info. %x", __fxName, hr));

            dwNumRendAud = 0;
            pRendAudInfo = NULL;
        }
    }

    // video capture: get devices
    if (pfnGetCaptVidNum)
    {
        hr = (*pfnGetCaptVidNum)(&dwNumCaptVid);
        if (hr != S_OK)
        {
            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s failed to get vid capt info. %x", __fxName, hr));
            }
            else
            {
                LOG((RTC_WARN, "%s: no video capture device.", __fxName));
            }

            dwNumCaptVid = 0;
        }
    }

    // is there any device?
    DWORD dwTotal = dwNumCaptAud + dwNumRendAud + dwNumCaptVid;
    if (dwTotal == 0)
    {
        return S_OK;
    }

    // create device info
    RTCDeviceInfo *pDeviceInfo = (RTCDeviceInfo*)RtcAlloc(
        dwTotal * sizeof(RTCDeviceInfo)
        );
    if (pDeviceInfo == NULL)
    {        
        // RtcFree audio device info
        if (pfnReleaseCaptAudInfo)
            (*pfnReleaseCaptAudInfo)(pCaptAudInfo);

        if (pfnReleaseRendAudInfo)
            (*pfnReleaseRendAudInfo)(pRendAudInfo);

        LOG((RTC_ERROR, "%s failed to alloc device info", __fxName));
        return E_OUTOFMEMORY;
    }

    DWORD dwIndex = 0;

    // copy audio capture device info
    for (DWORD dw=0; dw<dwNumCaptAud; dw++)
    {
        wcsncpy(
            pDeviceInfo[dwIndex].szDescription,
            pCaptAudInfo[dw].szDeviceDescription,
            RTC_MAX_DEVICE_DESP
            );
        pDeviceInfo[dwIndex].szDescription[RTC_MAX_DEVICE_DESP] = WCHAR('\0');
        pDeviceInfo[dwIndex].MediaType = RTC_MT_AUDIO;
        pDeviceInfo[dwIndex].Direction = RTC_MD_CAPTURE;
        pDeviceInfo[dwIndex].uiMark = 0;
        pDeviceInfo[dwIndex].Guid = pCaptAudInfo[dw].DSoundGUID;
        pDeviceInfo[dwIndex].uiDeviceID = pCaptAudInfo[dw].WaveID;

        dwIndex ++;
    }

    // copy audio render device info
    for (DWORD dw=0; dw<dwNumRendAud; dw++)
    {
        wcsncpy(
            pDeviceInfo[dwIndex].szDescription,
            pRendAudInfo[dw].szDeviceDescription,
            RTC_MAX_DEVICE_DESP
            );
        pDeviceInfo[dwIndex].szDescription[RTC_MAX_DEVICE_DESP] = WCHAR('\0');
        pDeviceInfo[dwIndex].MediaType = RTC_MT_AUDIO;
        pDeviceInfo[dwIndex].Direction = RTC_MD_RENDER;
        pDeviceInfo[dwIndex].uiMark = 0;
        pDeviceInfo[dwIndex].Guid = pRendAudInfo[dw].DSoundGUID;
        pDeviceInfo[dwIndex].uiDeviceID = pRendAudInfo[dw].WaveID;

        dwIndex ++;
    }

    CHAR szDesp[RTC_MAX_DEVICE_DESP+1];
    // copy video capture device info
    for (DWORD dw=0; dw<dwNumCaptVid; dw++)
    {
        hr = (*pfnGetCaptVidInfo)(dw, &CaptVidInfo);
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s failed to get video capt info at %d. %x",
                 __fxName, dw, hr));
            continue;
        }

        lstrcpynA(szDesp, CaptVidInfo.szDeviceDescription, RTC_MAX_DEVICE_DESP+1);

        MultiByteToWideChar(
            GetACP(),
            0,
            szDesp,
            lstrlenA(szDesp)+1,
            pDeviceInfo[dwIndex].szDescription,
            RTC_MAX_DEVICE_DESP + 1
            );

        pDeviceInfo[dwIndex].MediaType = RTC_MT_VIDEO;
        pDeviceInfo[dwIndex].Direction = RTC_MD_CAPTURE;
        pDeviceInfo[dwIndex].uiMark = 0;
        pDeviceInfo[dwIndex].Guid = GUID_NULL;
        pDeviceInfo[dwIndex].uiDeviceID = dw;

        dwIndex ++;
    }

    // audio capture: release devices
    // unload library
    if (pfnReleaseCaptAudInfo)
        (*pfnReleaseCaptAudInfo)(pCaptAudInfo);

    if (pfnReleaseRendAudInfo)
        (*pfnReleaseRendAudInfo)(pRendAudInfo);

    *pdwCount = dwIndex;
    *ppDeviceInfo = pDeviceInfo;

    return S_OK;
}

HRESULT
CRTCMediaController::FreeDevices(
    IN RTCDeviceInfo *pDeviceInfo
    )
{
    if (pDeviceInfo != NULL)
        RtcFree(pDeviceInfo);

    return S_OK;
}

HRESULT
CRTCMediaController::CreateIVideoWindowTerminal(
    IN ITTerminalManager *pTerminalManager,
    OUT IRTCTerminal **ppTerminal
    )
{
    ENTER_FUNCTION("CRTCMediaController::CreateIVideoWindowTerminal");

    IRTCTerminal *pTerminal;

    // create video terminals
    HRESULT hr = CRTCTerminal::CreateInstance(
        RTC_MT_VIDEO, RTC_MD_RENDER, &pTerminal);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to create terminal instance. %x", __fxName, hr));
        return hr;
    }

    // create ITTerminal
    ITTerminal *pITTerminal;
    hr = pTerminalManager->CreateDynamicTerminal(
        NULL,
        CLSID_VideoWindowTerm,
        TAPIMEDIATYPE_VIDEO,
        TD_RENDER,
        (MSP_HANDLE)this,   // is this dangerous?
        &pITTerminal
        );
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to create ITTerminal. %x", __fxName, hr));

        pTerminal->Release();

        return hr;
    }

    // initiate the terminal: wrap ITTerminal
    CRTCTerminal *pCTerminal = static_cast<CRTCTerminal*>(pTerminal);
    if (FAILED(hr = pCTerminal->Initialize(
            pITTerminal, static_cast<IRTCTerminalManage*>(this))))
    {
        LOG((RTC_ERROR, "%s init rtcterminal. %x", __fxName, hr));

        pTerminal->Release();
        pITTerminal->Release();

        return hr;
    }

    pITTerminal->Release();

    *ppTerminal = pTerminal;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    add a rtc media in the media list. before calling this method a corresponding
    sdp media should have been created
////*/

HRESULT
CRTCMediaController::AddMedia(
    IN ISDPMedia *pISDPMedia,
    OUT IRTCMedia **ppMedia
    )
{
    ENTER_FUNCTION("CRTCMediaController::AddMedia");

    // new a media object
    CComObject<CRTCMedia> *pCMedia;

    HRESULT hr = ::CreateCComObjectInstance(&pCMedia);
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to create media object. %x", __fxName, hr));
        return hr;
    }

    // query IRTCMedia interface
    IRTCMedia *pIMedia;

    hr = pCMedia->_InternalQueryInterface(__uuidof(IRTCMedia), (void**)&pIMedia);
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to query IRTCMedia from media object. %x", __fxName, hr));
        delete pCMedia;
        return hr;
    }

    // initialize media. SDP should be updated by the media
    IRTCMediaManagePriv *pIMediaManagePriv =
        static_cast<IRTCMediaManagePriv*>(this);

    hr = pIMedia->Initialize(pISDPMedia, pIMediaManagePriv);
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to initialize media. %x", __fxName, hr));

        pIMedia->Release();

        return hr;
    }

    // add it to our list
    if (!m_Medias.Add(pIMedia))
    {
        pIMedia->Shutdown();
        pIMedia->Release();

        return E_OUTOFMEMORY;
    }

    pIMedia->AddRef();

    *ppMedia = pIMedia;

    return S_OK;
}

HRESULT
CRTCMediaController::RemoveMedia(
    IN IRTCMedia *pMedia
    )
{
    pMedia->Shutdown();

    // remove the media
    m_Medias.Remove(pMedia);
    pMedia->Release();

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////

Description:

    synchronize media with newly updated SDP blob

Return:

    S_OK - success

////*/

HRESULT
CRTCMediaController::SyncMedias()
{
    ENTER_FUNCTION("CRTCMediaController::SyncMedias");
    LOG((RTC_TRACE, "%s entered", __fxName));

#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    HRESULT hr;
    HRESULT hrTmp = S_OK;
    const DWORD dwDir = RTC_MD_CAPTURE | RTC_MD_RENDER;

    //
    // step [0]. sync remove streams before all other operations
    //           leave room for adding streams later on.
    //

    // TODO

    // for (int i=0; i<m_Medias.GetSize(); i++)

    // get sdp media list
    DWORD dwRTCNum, dwSDPNum = 0;

    if (FAILED(hr = m_pISDPSession->GetMedias(&dwSDPNum, NULL)))
    {
        LOG((RTC_ERROR, "%s get sdp media num. %x", __fxName, hr));

        return hr;
    }

    if (dwSDPNum == 0)
    {
        // no SDP media
        LOG((RTC_ERROR, "%s no sdp media. %x", __fxName, hr));

        return hr;
    }

    // sdp media # > rtc media #
    dwRTCNum = m_Medias.GetSize();

    if (dwRTCNum > dwSDPNum)
    {
        LOG((RTC_ERROR, "%s num of rtcmedia (%d) is greater than sdpmedia (%d).",
            __fxName, dwRTCNum, dwSDPNum));

        return E_FAIL;
    }

    //
    // step [1]. sync each old rtc media
    //

    for (DWORD i=0; i<dwRTCNum; i++)
    {
        if (FAILED(hr = m_Medias[i]->Synchronize(FALSE, dwDir)))
        {
            hrTmp |= hr;

            LOG((RTC_ERROR, "%s failed to sync media %p of index %d. %x",
                 __fxName, m_Medias[i], i, hr));
        }
    }

    // is there any new sdp medias?
    if (dwRTCNum == dwSDPNum)
    {
#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s SyncMedias %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

        // all sync-ed
        return S_OK;
    }

    // sync each new media description - create media object

    //
    // step 2: create new rtcmedia and sync
    //

    ISDPMedia **ppSDPMedia = NULL;

    ppSDPMedia = (ISDPMedia**)RtcAlloc(sizeof(ISDPMedia*)*dwSDPNum);

    if (ppSDPMedia == NULL)
    {
        // out of memory
        LOG((RTC_ERROR, "%s RtcAlloc sdp media array. %x", __fxName, hr));

        return hr;
    }

    // really get sdp media list
    if (FAILED(hr = m_pISDPSession->GetMedias(&dwSDPNum, ppSDPMedia)))
    {
        LOG((RTC_ERROR, "%s get sdp medias. %x", __fxName, hr));

        RtcFree(ppSDPMedia);

        return hr;
    }

    DWORD dw;

    for (dw=dwRTCNum; dw<dwSDPNum; dw++)
    {
        // sync each new sdp media
        CComPtr<IRTCMedia>      pMedia;

        // rtcmedia should match sdpmedia one by one        
        if (FAILED(hr = AddMedia(ppSDPMedia[dw], &pMedia)))
        {          
            LOG((RTC_ERROR, "%s failed to create rtc media. SERIOUS trouble. %x", __fxName, hr));

            // if we failed to add one sdpmedia, we are probably out of memory           
            hrTmp |= hr;
            break;
        }

        if (FAILED(hr = pMedia->Synchronize(FALSE, dwDir)))
        {
            hrTmp |= hr;

            LOG((RTC_ERROR, "%s failed to sync media %p of index %d",
                 __fxName, pMedia, dw));
        }
    }

    if (dw < dwSDPNum)
    {
        // failed to add rtcmedia, need to clean up sdpmedia
        while (dw < dwSDPNum)
        {
            ppSDPMedia[dw]->RemoveDirections(SDP_SOURCE_LOCAL, dwDir);
            dw ++;
        }
    }

    // release sdp media
    for (dw=0; dw<dwSDPNum; dw++)
    {
        ppSDPMedia[dw]->Release();
    }

    RtcFree(ppSDPMedia);

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s SyncMedias %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return hrTmp;
}

/*//////////////////////////////////////////////////////////////////////////////
    find in the media list the 1st media that matches the mediatype and does
    not have any stream
////*/

HRESULT
CRTCMediaController::FindEmptyMedia(
    IN RTC_MEDIA_TYPE MediaType,
    OUT IRTCMedia **ppMedia
    )
{
    ENTER_FUNCTION("CRTCMediaController::FindEmptyMedia");

    // only support dynamically add/remove video stream
    _ASSERT(MediaType == RTC_MT_VIDEO || MediaType == RTC_MT_DATA);

    HRESULT hr;
    RTC_MEDIA_TYPE mt;
    DWORD dir;

    for (int i=0; i<m_Medias.GetSize(); i++)
    {
        CComPtr<ISDPMedia> pISDPMedia;

        // get sdp media
        if (FAILED(hr = m_Medias[i]->GetSDPMedia(&pISDPMedia)))
        {
            LOG((RTC_ERROR, "%s get sdp media. %x", __fxName, hr));

            return hr;
        }

        // check media type
        if (FAILED(hr = pISDPMedia->GetMediaType(&mt)))
        {
            LOG((RTC_ERROR, "%s get media type. %x", __fxName, hr));

            return hr;
        }

        if (mt != MediaType)
            continue;

        // check directions
        if (FAILED(hr = pISDPMedia->GetDirections(SDP_SOURCE_LOCAL, &dir)))
        {
            LOG((RTC_ERROR, "%s get directions. %x", __fxName, hr));

            return hr;
        }

        if (dir != 0)
            continue;

        // got an empty media
        if (FAILED(hr = pISDPMedia->Reinitialize()))
        {
            LOG((RTC_ERROR, "%s reinit sdp media. %x", __fxName, hr));

            return hr;
        }

        if (FAILED(hr = m_Medias[i]->Reinitialize()))
        {
            LOG((RTC_ERROR, "%s reinit rtc media. %x", __fxName, hr));

            return hr;
        }

        *ppMedia = m_Medias[i];
        (*ppMedia)->AddRef();

        return S_OK;
    }

    *ppMedia = NULL;

    return S_OK;
}

HRESULT
CRTCMediaController::AdjustBitrateAlloc()
{
    ENTER_FUNCTION("CRTCMediaController::AdjustBitrateAlloc");

    //
    // step 1. compute total bitrate
    //

    // session bitrate setting to quality control
    DWORD dwBitrate = (DWORD)-1;

    if (m_pISDPSession == NULL)
    {
        LOG((RTC_WARN, "%s no sdp session", __fxName));

        return S_OK;
    }

    m_pISDPSession->GetRemoteBitrate(&dwBitrate);
    m_QualityControl.SetBitrateLimit(CQualityControl::REMOTE, dwBitrate);

    // current audio, video send bitrate
    DWORD dwAudSendBW = 0;
    DWORD dwVidSendBW = 0;

    // enable stream
    IRTCStream *pStream;

    // audio send
    if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_CAPTURE))
    {
        m_QualityControl.EnableStream(RTC_MT_AUDIO, RTC_MD_CAPTURE, TRUE);

        // get audio send bitrate
        pStream = m_MediaCache.GetStream(RTC_MT_AUDIO, RTC_MD_CAPTURE);
        pStream->GetCurrentBitrate(&dwAudSendBW, TRUE); // including header
        pStream->Release();
    }
    else
        m_QualityControl.EnableStream(RTC_MT_AUDIO, RTC_MD_CAPTURE, FALSE);

    // audio receive
    if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_RENDER))
        m_QualityControl.EnableStream(RTC_MT_AUDIO, RTC_MD_RENDER, TRUE);
    else
        m_QualityControl.EnableStream(RTC_MT_AUDIO, RTC_MD_RENDER, FALSE);

    // video send
    if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_CAPTURE))
    {
        m_QualityControl.EnableStream(RTC_MT_VIDEO, RTC_MD_CAPTURE, TRUE);

        // get video send bitrate
        pStream = m_MediaCache.GetStream(RTC_MT_VIDEO, RTC_MD_CAPTURE);
        pStream->GetCurrentBitrate(&dwVidSendBW, TRUE); // including header
        pStream->Release();
    }
    else
        m_QualityControl.EnableStream(RTC_MT_VIDEO, RTC_MD_CAPTURE, FALSE);

    // video render
    if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_RENDER))
        m_QualityControl.EnableStream(RTC_MT_VIDEO, RTC_MD_RENDER, TRUE);
    else
        m_QualityControl.EnableStream(RTC_MT_VIDEO, RTC_MD_RENDER, FALSE);

    if (!m_fBWSuggested)
    {
        // we are at the beginning of the call
        // treat LAN as 128k
        if (dwBitrate > CRTCCodecArray::HIGH_BANDWIDTH_THRESHOLD)
        {
            LOG((RTC_TRACE, "beginning of the call, downgrade LAN speed"));

            dwBitrate = CRTCCodecArray::LAN_INITIAL_BANDWIDTH;

            m_QualityControl.SuggestBandwidth(dwBitrate);
        }
    }

    // adjust total allocated bitrate
    m_QualityControl.AdjustBitrateAlloc(dwAudSendBW, dwVidSendBW);

    //
    // step 2. dynamically change audio codec
    //

    // get allocated bitrate
    dwBitrate = m_QualityControl.GetBitrateAlloc();
    DWORD dwLimit = m_QualityControl.GetEffectiveBitrateLimit();

    // change audio codec
    pStream = m_MediaCache.GetStream(RTC_MT_AUDIO, RTC_MD_CAPTURE);

    DWORD dwAudCode = (DWORD)-1;
    DWORD dwVidCode = (DWORD)-1;
    BOOL fFEC = FALSE;

    if (pStream != NULL)
    {
        static_cast<CRTCStreamAudSend*>(pStream)->AdjustBitrate(
                dwBitrate,
                dwLimit,
                m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_CAPTURE),
                &dwAudSendBW,    // new audio send bandwidth
                &fFEC
                );

        dwAudCode = static_cast<CRTCStreamAudSend*>(pStream)->GetCurrCode();

        pStream->Release();

        // check if audio is muted
        IRTCTerminal *pAudCapt = m_MediaCache.GetDefaultTerminal(
                RTC_MT_AUDIO, RTC_MD_CAPTURE);

        _ASSERT(pAudCapt != NULL);

        if (pAudCapt != NULL)
        {
            BOOL fMute = FALSE;

            (static_cast<CRTCTerminalAudCapt*>(pAudCapt))->GetMute(&fMute);

            if (fMute)
            {
                // audio stream muted
                dwAudSendBW = 0;
            }

            pAudCapt->Release();
        }
    }

    //
    // step 3. change video bitrate
    //

    pStream = m_MediaCache.GetStream(RTC_MT_VIDEO, RTC_MD_CAPTURE);

    FLOAT dFramerate = 0;
    DWORD dwRaw = 0;

    if (pStream != NULL)
    {       
        m_QualityControl.ComputeVideoSetting(
                dwAudSendBW,    // new audio bandwidth
                &dwVidSendBW,   // new video bandwidth
                &dFramerate // video framerate
                );

        dwRaw = static_cast<CRTCStreamVidSend*>(pStream)->AdjustBitrate(
                dwBitrate,
                dwVidSendBW,
                dFramerate
                );

        dwVidCode = static_cast<CRTCStreamVidSend*>(pStream)->GetCurrCode();

        pStream->Release();
    }

    // %f, %e and %g do not work with tracing printf?
    CHAR pstr[10];

    sprintf(pstr, "%2.1f", dFramerate);

    LOG((RTC_QUALITY, "Total(bps=%d) Limit(%d) Audio(%d:bps=%d fec=%d) Video(%d:bps=%d fps=%s)",
        dwBitrate, dwLimit, dwAudCode, dwAudSendBW, fFEC, dwVidCode, dwRaw, pstr));

    return S_OK;
}

HRESULT
CRTCMediaController::GetCurrentBitrate(
    IN DWORD dwMediaType,
    IN DWORD dwDirection,
    IN BOOL fHeader,
    OUT DWORD *pdwBitrate
    )
{
    ENTER_FUNCTION("CRTCMediaController::GetCurrentBitrate");

    DWORD dwTotal = 0;
    DWORD dwBitrate;

    HRESULT hr = S_OK;
    IRTCStream *pStream;

    if ((dwMediaType & RTC_MT_AUDIO) &&
        (dwDirection & RTC_MD_CAPTURE))
    {
        // audio capture
        if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_CAPTURE))
        {
            pStream = m_MediaCache.GetStream(RTC_MT_AUDIO, RTC_MD_CAPTURE);

            hr = pStream->GetCurrentBitrate(&dwBitrate, fHeader);
            pStream->Release();

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s get bitrate. %x", __fxName, hr));

                return hr;
            }

            dwTotal += dwBitrate;
        }
    }

    if ((dwMediaType & RTC_MT_AUDIO) &&
        (dwDirection & RTC_MD_RENDER))
    {
        // audio render
        if (m_MediaCache.HasStream(RTC_MT_AUDIO, RTC_MD_RENDER))
        {
            pStream = m_MediaCache.GetStream(RTC_MT_AUDIO, RTC_MD_RENDER);

            hr = pStream->GetCurrentBitrate(&dwBitrate, fHeader);
            pStream->Release();

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s get bitrate. %x", __fxName, hr));

                return hr;
            }

            dwTotal += dwBitrate;
        }
    }

    if ((dwMediaType & RTC_MT_VIDEO) &&
        (dwDirection & RTC_MD_CAPTURE))
    {
        // audio capture
        if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_CAPTURE))
        {
            pStream = m_MediaCache.GetStream(RTC_MT_VIDEO, RTC_MD_CAPTURE);

            hr = pStream->GetCurrentBitrate(&dwBitrate, fHeader);
            pStream->Release();

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s get bitrate. %x", __fxName, hr));

                return hr;
            }

            dwTotal += dwBitrate;
        }
    }

    if ((dwMediaType & RTC_MT_VIDEO) &&
        (dwDirection & RTC_MD_RENDER))
    {
        // audio render
        if (m_MediaCache.HasStream(RTC_MT_VIDEO, RTC_MD_RENDER))
        {
            pStream = m_MediaCache.GetStream(RTC_MT_VIDEO, RTC_MD_RENDER);

            hr = pStream->GetCurrentBitrate(&dwBitrate, fHeader);
            pStream->Release();

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s get bitrate. %x", __fxName, hr));

                return hr;
            }

            dwTotal += dwBitrate;
        }
    }

    *pdwBitrate = dwTotal;

    return hr;
}

HRESULT CRTCMediaController::EnsureNmRunning (
    BOOL            fNoMsgPump
    )
{
    HRESULT                             hr = S_OK;
    CComObject<CRTCAsyncNmManager>           *pManager = NULL;

    if (m_pNmManager == NULL)
    {
        //  Create Netmeeting object
        hr = ::CreateCComObjectInstance(&pManager);
        if (S_OK != hr)
        {
            goto ExitHere;
        }
        if (S_OK != (hr = pManager->_InternalQueryInterface(
            __uuidof(IRTCNmManagerControl),
            (void**)&m_pNmManager
            )))
        {
            delete pManager;
            goto ExitHere;
        }
    }

    if (S_OK != (hr = m_pNmManager->Initialize (fNoMsgPump, static_cast<IRTCMediaManagePriv*>(this))))
    {
        goto ExitHere;
    }

ExitHere:
    if (S_OK != hr)
    {
        if (m_pNmManager)
        {
            m_pNmManager.Release();
        }
    }
    return hr;
}

HRESULT CRTCMediaController::AddDataStream (
    IN DWORD        dwRemoteIp
    )
{
    ENTER_FUNCTION("AddDataStream");

    HRESULT             hr = S_OK;
    ISDPMedia           *pISDPMedia = NULL;
    DWORD               dwLocalIp;

    IRTCMedia           *pIRTCMedia = NULL;
    BOOL                fNewDataMedia = FALSE;
   
//    if (EnsureNmRunning())
//    {
//        goto ExitHere;
//    }
    m_dwRemoteIp = dwRemoteIp;
 
    if (m_pISDPSession == NULL)
    {
        // need to create a sdp session
        CComPtr<ISDPParser> pParser;
            
        // create parser
        if (S_OK != (hr = CSDPParser::CreateInstance(&pParser)))
        {
            LOG((RTC_ERROR, "create sdp parser. %x", hr));
            goto ExitHere;
        }

        // create sdp session
        if (S_OK != (hr = pParser->CreateSDP(SDP_SOURCE_LOCAL, &m_pISDPSession)))
        {
            LOG((RTC_ERROR, "create sdp session. %x", hr));
            goto ExitHere;
        }
    }

    // check if we already have a data media
    GetDataMedia(&pIRTCMedia);

    if (pIRTCMedia == NULL)
    {
        // need to create new sdp and rtc media
        if (S_OK != (hr = m_pISDPSession->AddMedia(SDP_SOURCE_LOCAL, RTC_MT_DATA, 0, &pISDPMedia)))
        {
            LOG((RTC_ERROR, "%s failed to add sdpmedia. %x", __fxName, hr));
            goto ExitHere;
        }

        fNewDataMedia = TRUE;
    }
    else
    {
        pIRTCMedia->GetSDPMedia(&pISDPMedia);

        fNewDataMedia = FALSE;
    }

    // setup remote ip
    if (FAILED(hr = pISDPMedia->SetConnAddr(SDP_SOURCE_REMOTE, dwRemoteIp)))
    {
        LOG((RTC_ERROR, "set remote ip. %x", hr));

        pISDPMedia->Release();  // this is a fake release on session

        if (fNewDataMedia)
        {
            m_pISDPSession->RemoveMedia(pISDPMedia);
        }
        else
        {
            pIRTCMedia->Release();
        }

        goto ExitHere;
    }

    pISDPMedia->AddDirections(SDP_SOURCE_LOCAL, RTC_MD_CAPTURE);

    if (fNewDataMedia)
    {
        // add media object
        if (FAILED(hr = AddMedia(pISDPMedia, &pIRTCMedia)))
        {
            LOG((RTC_ERROR, "%s failed to create rtcmedia. %x", __fxName, hr));

            pISDPMedia->Release();  // this is a fake release on session
            m_pISDPSession->RemoveMedia(pISDPMedia);
            goto ExitHere;
        }
    }

    if (FAILED(hr = pIRTCMedia->Synchronize(TRUE, (DWORD)RTC_MD_CAPTURE)))
    {
        LOG((RTC_ERROR, "%s failed to sync data media. %x", __fxName, hr));

        // remove both sdp and rtc media
        // rtcmedia keep a pointer to sdpmedia
        // we should remove rtcmedia before removing sdpmedia

        if (fNewDataMedia)
        {
            RemoveMedia(pIRTCMedia);
        }

        pIRTCMedia->Release();

        pISDPMedia->Release();  // this is a fake release on session

        if (fNewDataMedia)
        {
            m_pISDPSession->RemoveMedia(pISDPMedia);
        }

        goto ExitHere;
    }

    pISDPMedia->Release();
    pIRTCMedia->Release();

    m_uDataStreamState = RTC_DSS_ADDED;

    // add preference for data stream
    m_MediaCache.AddPreference((DWORD)RTC_MP_DATA_SENDRECV);

ExitHere:

    return hr;
}

HRESULT CRTCMediaController::GetDataMedia(
    OUT IRTCMedia **ppMedia
    )
{
    *ppMedia = NULL;

    HRESULT hr;
    ISDPMedia *pSDP = NULL;
    RTC_MEDIA_TYPE mt;

    for (int i=0; i<m_Medias.GetSize(); i++)
    {
        if (S_OK != (hr = m_Medias[i]->GetSDPMedia(&pSDP)))
        {
            return hr;
        }

        // get media type
        pSDP->GetMediaType(&mt);
        pSDP->Release();

        if (mt != RTC_MT_DATA)
            continue;

        // find data media
        *ppMedia = m_Medias[i];
        (*ppMedia)->AddRef();

        return S_OK;
    }

    return E_FAIL;
}

HRESULT CRTCMediaController::StartDataStream (
    )
{
    if (m_uDataStreamState == RTC_DSS_VOID)
    {
        return RTC_E_SIP_STREAM_NOT_PRESENT;
    }

    return S_OK;
}

HRESULT CRTCMediaController::StopDataStream (
    )
{
    if (m_pNmManager)
    {
        m_pNmManager->Shutdown ();
    }

    if (m_uDataStreamState == RTC_DSS_VOID)
    {
        return RTC_E_SIP_STREAM_NOT_PRESENT;
    }
    else
    {
        m_uDataStreamState = RTC_DSS_VOID;

        return S_OK;
    }    
}

HRESULT CRTCMediaController::RemoveDataStream (
    )
{
    if (m_pNmManager)
    {
        m_pNmManager->Shutdown ();
    }

    //m_pNmManager.Release();

    // reinitialize media object
    IRTCMedia *pMedia = NULL;

    GetDataMedia(&pMedia);

    if (pMedia != NULL)
    {
        // check sdp media object
        ISDPMedia *pSDP = NULL;

        pMedia->GetSDPMedia(&pSDP);

        if (pSDP != NULL)
        {
            DWORD md = 0;

            pSDP->GetDirections(SDP_SOURCE_LOCAL, &md);

            // if direction is not 0 then
            // the data stream was not removed
            if (md != 0)
            {
                pSDP->RemoveDirections(SDP_SOURCE_LOCAL, md);
            }

            pSDP->Release();
        }

        pMedia->Reinitialize();

        pMedia->Release();
    }

    m_uDataStreamState = RTC_DSS_VOID;

    return S_OK;
}

HRESULT CRTCMediaController::GetDataStreamState (
    OUT RTC_STREAM_STATE    * pState
    )
{
    if (m_uDataStreamState == RTC_DSS_STARTED)
    {
        *pState = RTC_SS_RUNNING;
    }
    else
    {
        *pState = RTC_SS_CREATED;
    }
    return S_OK;
}

HRESULT CRTCMediaController::SetDataStreamState (
    OUT RTC_STREAM_STATE    State
    )
{
    if (State == RTC_SS_CREATED)
    {
        m_uDataStreamState = RTC_DSS_ADDED;
    }
    else if (State == RTC_SS_RUNNING)
    {
        m_uDataStreamState = RTC_DSS_STARTED;
    }

    return S_OK;
}

IRTCNmManagerControl *
CRTCMediaController::GetNmManager()
{
    IRTCNmManagerControl *pControl = (IRTCNmManagerControl *)m_pNmManager;

    if (pControl != NULL)
    {
        pControl->AddRef();
    }

    return pControl;
}

// local ip in host order
BOOL
CRTCMediaController::IsFirewallEnabled(DWORD dwLocalIP)
{
    if (m_pSipStack == NULL)
    {
        return FALSE;
    }

    BOOL fEnabled = FALSE;

    HRESULT hr = m_pSipStack->IsFirewallEnabled(htonl(dwLocalIP), &fEnabled);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "Failed to query firewall on %d", dwLocalIP));

        return FALSE;
    }

    return fEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\nmcall.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    MediaController.h

Abstract:


Author(s):


--*/

#ifndef _NMCALL_H
#define _NMCALL_H

/********************************************************************
    class CRTCNMCall
 *******************************************************************/

class ATL_NO_VTABLE CRTCNmCall :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public INmCallNotify,
    public IRTCNmCallControl
{
public:


BEGIN_COM_MAP(CRTCNmCall)
    COM_INTERFACE_ENTRY(INmCallNotify)
    COM_INTERFACE_ENTRY(IRTCNmCallControl)
END_COM_MAP()

public:

    CRTCNmCall();

    ~CRTCNmCall();

    VOID SetMediaManage(
        IRTCMediaManagePriv *pIRTCMediaManagePriv
    );

    //
    // INmCallNotify methods
    //

    STDMETHOD (NmUI) (
        IN CONFN uNotify
        );

    STDMETHOD (Accepted) (
        IN INmConference *pConference
        );

    STDMETHOD (Failed) (
        IN ULONG uError
        );

    STDMETHOD (StateChanged) (
        IN NM_CALL_STATE uState
        );

    //
    //  IRTCNmCallControl methods
    //

    STDMETHOD (Initialize) (
        IN INmCall * pCall
        );
    
    STDMETHOD (Shutdown) (
        );

    STDMETHOD (AcceptCall) (
        );

    STDMETHOD (LaunchRemoteApplet) (
        IN NM_APPID uApplet
        );
        
private:
    CComPtr<INmCall>            m_pNmCall;
    BOOL                        m_fIncoming;
    BOOL                        m_fToAccept;
    CComPtr<IConnectionPoint>   m_pcp;
    DWORD                       m_dwCookie;
    NM_CALL_STATE               m_uState;

    // flag to remember if active or created events were fired
    BOOL                        m_fActive;
    BOOL                        m_fCreated;

    // media manage for posting message
    IRTCMediaManagePriv                 *m_pMediaManagePriv;
};

class ATL_NO_VTABLE CRTCNmManager :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public INmManagerNotify,
    public IRTCNmManagerControl
{
public:

BEGIN_COM_MAP(CRTCNmManager)
    COM_INTERFACE_ENTRY(INmManagerNotify)
    COM_INTERFACE_ENTRY(IRTCNmManagerControl)
END_COM_MAP()

    CRTCNmManager ();

    ~CRTCNmManager ();

    //
    //  INmManagerNotify methods
    //
    
    STDMETHOD (NmUI) (
        IN CONFN uNotify
        );

    STDMETHOD (ConferenceCreated) (
        IN INmConference * pConference
        );

    STDMETHOD (CallCreated) (
        IN INmCall * pCall
        );

    //
    //  IRTCNmManagerControl methods
    //

    STDMETHOD (Initialize) (
        BOOL            fNoMsgPump,
        IRTCMediaManagePriv *pIRTCMediaManagePriv
        );

    STDMETHOD (Shutdown) (
        );

    STDMETHOD (CreateT120OutgoingCall) (
        NM_ADDR_TYPE    addrType,
        BSTR bstrAddr
        );

    STDMETHOD (AllowIncomingCall) (
        );

    STDMETHOD (StartApplet) (
        IN NM_APPID uApplet
        );

    STDMETHOD (StopApplet) (
        IN NM_APPID uApplet
        );

private:
    CComPtr<INmManager>             m_pNmManager;
    CComPtr<INmConference>          m_pConference;
    BOOL                            m_fAllowIncoming;
    CComPtr<IConnectionPoint>       m_pcp;
    DWORD                           m_dwCookie;

    CComPtr<IRTCNmCallControl>      m_pOutgoingNmCall;
    CComBSTR                        m_OutgoingAddr;

    CComPtr<IRTCNmCallControl>      m_pIncomingNmCall;

    // media manage for posting message
    IRTCMediaManagePriv                 *m_pMediaManagePriv;
};

/********************************************************************
    class CRTCAsyncObjManager

        Along with CRTCAsyncObj, This class/object supports calling
    a group of calss functions asynchronously. This is necessary when
    moving a apartment threaded object (such as Netmeeting object) to
    another thread and wants callthe object from the original thread.
    
        CRTCAsyncObjManager maintains the lists of async work items
    for call back purpose. When the callback job is finished, it will
    signal the CRTCAsyncObj by setting the event handle. 
 *******************************************************************/

class CRTCAsyncObj;

typedef struct _ASYNC_OBJ_WORKITEM {
        LIST_ENTRY      ListEntry;
        HANDLE          hEvent;
        CRTCAsyncObj *  pObj;
        DWORD           dwWorkID;
        LPVOID          pParam1;
        LPVOID          pParam2;
        LPVOID          pParam3;
        LPVOID          pParam4;
        HRESULT         hrResult;
} ASYNC_OBJ_WORKITEM;

class CRTCAsyncObjManager
{
public:
    CRTCAsyncObjManager ();
    ~CRTCAsyncObjManager ();

    //  ThreadProc 
    static DWORD WINAPI RTCAsyncObjThreadProc (LPVOID lpParam);

    HRESULT Initialize ();

    HRESULT QueueWorkItem (ASYNC_OBJ_WORKITEM *pItem);

private:
    //  When signaled, there is one or more work item ready in the queue
    HANDLE                  m_hWorkItemReady;
    //  maintains the work item queue
    LIST_ENTRY              m_WorkItems;
    //  Critical section to serialize access to m_WorkItems;
    CRITICAL_SECTION        m_CritSec;
    //  To indicate to the worker thread to quit
    BOOL                    m_bExit;
    HANDLE                  m_hWorker;
};

/********************************************************************
    class CRTCAsyncObj

    This calls along with CRTCAsyncObjManager enables creating an
    apartment-threaded object on a working thread and calling the
    object from the original thread. 

    To Implement this, the following steps need to be followed:
        (1). Identify the lists of functions that needs to be called
        (2). Define a work item ID for each of the functions
        (3). Define a calls derived from CRTCAsyncObj
        (4). Define function prototypes for all the functions to be exposed,
             and call CallInBlockingMode or CallInNonBlockingMode from
             each of the defined function
        (5). Define function ProcessWorkItem and dispatch the function
             call to the object created in the worker thread
 *******************************************************************/
 
class CRTCAsyncObj
{
public:
    CRTCAsyncObj (CRTCAsyncObjManager * pManager)
    {
        _ASSERT (pManager != NULL);
        m_pManager = pManager;
    };

    CRTCAsyncObj ()
    {
        m_pManager = NULL;
    }
    
    ~CRTCAsyncObj ()
    {
    };

    //  Ask the worker thread to make object call asynchronously, the caller
    //  is blocked until the result returns
    HRESULT CallInBlockingMode (
        DWORD               dwID,
        LPVOID              pParam1,
        LPVOID              pParam2,
        LPVOID              pParam3,
        LPVOID              pParam4
        );

    //  Ask the worker thread to make asynchronous object call.
    //  This class dispatch any existing message while waiting for the result
    HRESULT CallInNonblockingMode (
        DWORD               dwID,
        LPVOID              pParam1,
        LPVOID              pParam2,
        LPVOID              pParam3,
        LPVOID              pParam4
        );

    virtual HRESULT ProcessWorkItem (
        DWORD           dwWorkID,
        LPVOID          pParam1,
        LPVOID          pParam2,
        LPVOID          pParam3,
        LPVOID          pParam4
        ) = 0;

    HRESULT SetAsyncObjManager (CRTCAsyncObjManager *pManager)
    {
        _ASSERT (pManager != NULL);
        m_pManager = pManager;
        return S_OK;
    }

protected:
    CRTCAsyncObjManager             * m_pManager;
};

/********************************************************************
    class CRTCAsyncNmManager
 *******************************************************************/

class ATL_NO_VTABLE CRTCAsyncNmManager :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IRTCNmManagerControl,
    public CRTCAsyncObj
{
public:

BEGIN_COM_MAP(CRTCAsyncNmManager)
    COM_INTERFACE_ENTRY(IRTCNmManagerControl)
END_COM_MAP()

    typedef enum {
        RTC_NULL,
        RTC_INTIALIZE_NM,
        RTC_SHUTDOWN_NM,
        RTC_CREATE_T120CALL,
        RTC_ALLOW_INCOMINGCALL,
        RTC_START_APPLET,
        RTC_STOP_APPLET,
        RTC_EXIT
    } RTC_WORKITEM_ID;

    CRTCAsyncNmManager ();

    ~CRTCAsyncNmManager ();

    //  Spawn another thread and create the CRTCNmManager object
    HRESULT FinalConstruct ();

    HRESULT ProcessWorkItem (
        DWORD           dwWorkID,
        LPVOID          pParam1,
        LPVOID          pParam2,
        LPVOID          pParam3,
        LPVOID          pParam4
        );

    //
    //  IRTCNmManagerControl methods
    //

    STDMETHOD (Initialize) (
        BOOL            fNoMsgPump,
        IRTCMediaManagePriv *pIRTCMediaManagePriv
        );

    STDMETHOD (Shutdown) (
        );

    STDMETHOD (CreateT120OutgoingCall) (
        NM_ADDR_TYPE    addrType,
        BSTR bstrAddr
        );

    STDMETHOD (AllowIncomingCall) (
        );

    STDMETHOD (StartApplet) (
        IN NM_APPID uApplet
        );

    STDMETHOD (StopApplet) (
        IN NM_APPID uApplet
        );

private:
    CComPtr<IRTCNmManagerControl>       m_pNmManager;
    CRTCAsyncObjManager                 *m_pAsyncMgr;

    // media manage for posting message
    IRTCMediaManagePriv                 *m_pMediaManagePriv;

private:
};


#endif // _NMCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\mediareg.cpp ===
/*++

Module Name:

    MediaReg.h

Abstract:
        
    Wrap operations in registry

--*/

#include "stdafx.h"

//
// create/open an hkey
//
HRESULT
CMediaReg::OpenKey(
    IN HKEY hKey,
    IN const WCHAR * const pwsPath,
    IN ULONG ulRight
    )
{
    if (hKey == NULL)
    {
        return E_UNEXPECTED;
    }

    if (m_hKey != NULL)
    {
        CloseKey();
    }

    ULONG right = 0;

    // prepare access right
    if (ulRight & MediaReg::READ)
    {
        right |= KEY_READ;
    }
    else if (ulRight & MediaReg::WRITE)
    {
        right |= KEY_WRITE;
    }
    else if (ulRight & MediaReg::CREATE)
    {
        right = KEY_ALL_ACCESS;
    }

    HRESULT hr = S_OK;
    DWORD dwDisp = 0;

    if (ulRight & MediaReg::CREATE)
    {
        // create key
        hr = (HRESULT)::RegCreateKeyExW(
            hKey,                       // hkey
            pwsPath,                    // sub key
            0,                          // reserved
            NULL,                       // class
            REG_OPTION_NON_VOLATILE,    // option
            right,                      // mask
            NULL,                       // security
            &m_hKey,                    // return key
            &dwDisp                     // disposition
            );
    }
    else
    {
        // open key
        hr = (HRESULT)RegOpenKeyExW(
            hKey,
            pwsPath,
            0,
            right,
            &m_hKey
            );
    }

    if (hr != S_OK && !FAILED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}

//
// create/open an hkey
//
HRESULT
CMediaReg::OpenKey(
    IN const CMediaReg& objMediaReg,
    IN const WCHAR * const pwsPath,
    IN ULONG ulRight
    )
{
    return OpenKey(
        objMediaReg.m_hKey,
        pwsPath,
        ulRight
        );
}

//
// close key
//
HRESULT
CMediaReg::CloseKey()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);

        m_hKey = NULL;
    }

    return S_OK;
}

//
// close key in destructor
//
CMediaReg::~CMediaReg()
{
    CloseKey();
}

// write/read value
HRESULT
CMediaReg::ReadDWORD(
    IN const WCHAR * const pwsName,
    OUT DWORD *pdwData
    )
{
    if (m_hKey == NULL)
    {
        return E_UNEXPECTED;
    }

    DWORD dwDataType;
    DWORD dwDataSize = sizeof(DWORD);

    HRESULT hr = (HRESULT)RegQueryValueExW(
        m_hKey,
        pwsName,
        0,
        &dwDataType,
        (BYTE*)pdwData,
        &dwDataSize
        );

    if (hr != S_OK && !FAILED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CMediaReg::ReadDWORD(
    IN const WCHAR * const pwsName,
    IN DWORD dwDefault,
    OUT DWORD *pdwData
    )
{
    HRESULT hr = ReadDWORD(pwsName, pdwData);

    if (hr != S_OK)
    {
        *pdwData = dwDefault;

        // write default
        hr = WriteDWORD(pwsName, dwDefault);
    }

    return hr;
}

HRESULT
CMediaReg::WriteDWORD(
    IN const WCHAR * const pwsName,
    IN DWORD dwData
    )
{
    if (m_hKey == NULL)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr = (HRESULT)RegSetValueExW(
        m_hKey,
        pwsName,
        0,
        REG_DWORD,
        (BYTE*)&dwData,
        sizeof(DWORD)
        );

    if (hr != S_OK && !FAILED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT
CMediaReg::ReadSZ(
    IN const WCHAR * const pwsName,
    OUT WCHAR *pwcsData,
    IN DWORD dwSize
    )
{
    if (m_hKey == NULL)
    {
        return E_UNEXPECTED;
    }

    DWORD dwDataType;
    DWORD dwDataSize = dwSize * sizeof(WCHAR)/sizeof(BYTE);

    HRESULT hr = (HRESULT)RegQueryValueExW(
        m_hKey,
        pwsName,
        0,
        &dwDataType,
        (BYTE*)pwcsData,
        &dwDataSize
        );

    if (hr != S_OK && !FAILED(hr))
    {
        hr = E_FAIL;
    }

    if (dwDataType != REG_SZ)
    {
        hr = E_FAIL;
    }

    pwcsData[dwSize-1] = L'\0';

    return hr;
}

HRESULT
CMediaReg::WriteSZ(
    IN const WCHAR * const pwsName,
    IN WCHAR *pwcsData,
    IN DWORD dwSize
    )
{
    if (m_hKey == NULL)
    {
        return E_UNEXPECTED;
    }

    DWORD dwDataSize = dwSize * sizeof(WCHAR)/sizeof(BYTE);

    HRESULT hr = (HRESULT)RegSetValueExW(
        m_hKey,
        pwsName,
        0,
        REG_SZ,
        (BYTE*)pwcsData,
        dwDataSize
        );

    if (hr != S_OK && !FAILED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}

//
// store reg setting
//
CRegSetting::CRegSetting()
    :m_dwMaxBitrate((DWORD)-1)
    ,m_dwBandwidthMargin((DWORD)-1)
    ,m_dwBWDelta((DWORD)-1)
    ,m_dwEnableSQCIF(0)
    ,m_dwFramerate((DWORD)-1)
    ,m_dwMaxPTime((DWORD)-1)
    ,m_dwUsePreferredCodec(0)
    ,m_dwPreferredAudioCodec((DWORD)-1)
    ,m_dwPreferredVideoCodec((DWORD)-1)
    ,m_dwDisabledAudioCodec((DWORD)-1)
    ,m_dwDisabledVideoCodec((DWORD)-1)
    ,m_dwPortMappingRetryCount(4)
{
}

VOID
CRegSetting::Initialize()
{
    CMediaReg objReg;

    // read max bitrate
    HRESULT hr = objReg.OpenKey(
            HKEY_CURRENT_USER,
            MediaReg::pwsPathQuality,
            MediaReg::READ
            );

    if (hr == S_OK)
    {
        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsMaxBitrate,
                &m_dwMaxBitrate
                )))
        {
            m_dwMaxBitrate = (DWORD)-1;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsBandwidthMargin,
                &m_dwBandwidthMargin
                )))
        {
            m_dwBandwidthMargin = (DWORD)-1;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsBWDelta,
                &m_dwBWDelta
                )))
        {
            m_dwBWDelta = (DWORD)-1;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsEnableSQCIF,
                &m_dwEnableSQCIF
                )))
        {
            m_dwEnableSQCIF = 0;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsFramerate,
                &m_dwFramerate
                )))
        {
            m_dwFramerate = (DWORD)-1;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsMaxPTime,
                &m_dwMaxPTime
                )))
        {
            m_dwMaxPTime = (DWORD)-1;
        }
        else
        {
            // ptime should >=30
            if (m_dwMaxPTime < 30)
            {
                m_dwMaxPTime = (DWORD)-1;
            }
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsPortMappingRetryCount,
                &m_dwPortMappingRetryCount
                )))
        {
            m_dwPortMappingRetryCount = 4;
        }
    }
    else
    {
        m_dwMaxBitrate = (DWORD)-1;
        m_dwBandwidthMargin = (DWORD)-1;
        m_dwBWDelta = (DWORD)-1;
        m_dwFramerate = (DWORD)-1;
        m_dwMaxPTime = (DWORD)-1;
        m_dwEnableSQCIF = 0;
        m_dwPortMappingRetryCount = 4;
    }

    objReg.CloseKey();

    // read preferred codec
    hr = objReg.OpenKey(
        HKEY_CURRENT_USER,
        MediaReg::pwsPathCodec,
        MediaReg::READ
        );

    if (hr == S_OK)
    {
        // use preferred codec?
        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsUsePreferredCodec,
                &m_dwUsePreferredCodec
                )))
        {
            m_dwUsePreferredCodec = 0;
        }

        // query preferred codec
        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsPreferredAudioCodec,
                &m_dwPreferredAudioCodec
                )))
        {
            m_dwPreferredAudioCodec = (DWORD)-1;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsPreferredVideoCodec,
                &m_dwPreferredVideoCodec
                )))
        {
            m_dwPreferredVideoCodec = (DWORD)-1;
        }

        // query disabled codec
        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsDisabledAudioCodec,
                &m_dwDisabledAudioCodec
                )))
        {
            m_dwDisabledAudioCodec = (DWORD)-1;
        }

        if (S_OK != (hr = objReg.ReadDWORD(
                MediaReg::pwsDisabledVideoCodec,
                &m_dwDisabledVideoCodec
                )))
        {
            m_dwDisabledVideoCodec = (DWORD)-1;
        }
    }
    else
    {
        m_dwUsePreferredCodec = 0;
        m_dwPreferredAudioCodec = (DWORD)-1;
        m_dwPreferredVideoCodec = (DWORD)-1;
        m_dwDisabledAudioCodec = (DWORD)-1;
        m_dwDisabledVideoCodec = (DWORD)-1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\nmcall.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    nmcall.cpp

Abstract:


Author(s):


--*/

#include "stdafx.h"

static TCHAR g_szRegNmConfPath[] = TEXT("Software\\Microsoft\\Conferencing");
static TCHAR g_szRegWizardUI[] = TEXT("WizardUI");
static ULONG g_ulNmWizardUIVersion = 0x4040d39;

//
//  HACK ALERT:
//
//      The following Netmeeting ssytem property is specifically defined to
//  improve the startup performance.
//
//      This value needs to be consistant with the same value defined in
//  %NETMEETING%\ui\msconf\Nmsysinfo.cpp
//
#define NM_SYSPROP_CALLERISRTC 300


CRTCNmCall::CRTCNmCall()
    :m_pNmCall(NULL)
    ,m_pcp(NULL)
    ,m_fIncoming(FALSE)
    ,m_fToAccept(FALSE)
    ,m_dwCookie(0)
    ,m_uState(NM_CALL_INVALID)
    ,m_pMediaManagePriv(NULL)
    ,m_fActive(FALSE)
    ,m_fCreated(FALSE)
{
}

CRTCNmCall::~CRTCNmCall()
{
    Shutdown ();

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->Release();

        m_pMediaManagePriv = NULL;
    }
}

//
// INmCallNotify methods
//

STDMETHODIMP
CRTCNmCall::NmUI (
    IN CONFN uNotify
    )
{
    LOG((RTC_TRACE, "CRTCNmCall::NmUI, uNotify=%d", uNotify));
    return S_OK;
}

STDMETHODIMP
CRTCNmCall::Accepted (
    IN INmConference *pConference
    )
{
    LOG((RTC_TRACE, "CRTCNmCall::Accepted, pConf=x%p", pConference));
    return S_OK;
}

STDMETHODIMP
CRTCNmCall::Failed (
    IN ULONG uError
    )
{
    ENTER_FUNCTION("CRTCNmCall::Failed");
    LOG((RTC_TRACE, "Entering %s, uError=x%x", __fxName, uError));
    Shutdown ();
    LOG((RTC_TRACE, "Exiting %s", __fxName));
    return S_OK;
}

// call state name
static const CHAR * const g_pszCallInvalid = "Call Invalid";
static const CHAR * const g_pszCallInit = "Call Init";
static const CHAR * const g_pszCallRing = "Call Ring";
static const CHAR * const g_pszCallSearch = "Call Search";
static const CHAR * const g_pszCallWait = "Call Wait";
static const CHAR * const g_pszCallAccepted = "Call Accepted";
static const CHAR * const g_pszCallRejected = "Call Rejected";
static const CHAR * const g_pszCallCanceled = "Call Canceled";
static const CHAR * const g_pszCallUnknown = "Call Unknown";

const CHAR * const NMCallStateName(
    NM_CALL_STATE uState
    )
{
    switch (uState)
    {
    case NM_CALL_INVALID:
        return g_pszCallInvalid;

    case NM_CALL_INIT:
        return g_pszCallInit;

    case NM_CALL_RING:
        return g_pszCallRing;

    case NM_CALL_SEARCH:
        return g_pszCallSearch;

    case NM_CALL_WAIT:
        return g_pszCallWait;

    case NM_CALL_ACCEPTED:
        return g_pszCallAccepted;

    case NM_CALL_REJECTED:
        return g_pszCallRejected;

    case NM_CALL_CANCELED:
        return g_pszCallCanceled;

    default:
        return g_pszCallUnknown;
    }
}

STDMETHODIMP
CRTCNmCall::StateChanged (
    IN NM_CALL_STATE uState
    )
{
    LOG((RTC_TRACE, "CRTCNmCall::StateChanged: %s", NMCallStateName(uState)));

    m_uState = uState;

    HRESULT hr = S_OK;

    if (m_fToAccept && m_uState == NM_CALL_RING)
    {
        if ((hr = m_pNmCall->Accept ()) == S_OK)
        {
            m_fToAccept = FALSE;
        }
    }

    // post active message
    if (m_pMediaManagePriv)
    {
        if (hr==S_OK && uState==NM_CALL_ACCEPTED)
        {
            m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_ACTIVE,
                m_fIncoming?RTC_ME_CAUSE_REMOTE_REQUEST:RTC_ME_CAUSE_LOCAL_REQUEST,
                RTC_MT_DATA,
                m_fIncoming?RTC_MD_RENDER:RTC_MD_CAPTURE,
                S_OK
                );

            m_fActive = TRUE;
        }
        else if (hr!=S_OK ||
                    uState==NM_CALL_INVALID ||
                    uState==NM_CALL_REJECTED ||
                    uState==NM_CALL_CANCELED)
        {
            m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_FAIL,
                RTC_ME_CAUSE_UNKNOWN,
                RTC_MT_DATA,
                m_fIncoming?RTC_MD_RENDER:RTC_MD_CAPTURE,
                S_OK
                );

            m_fActive = FALSE;
        }
    }

    return S_OK;
}

VOID
CRTCNmCall::SetMediaManage(
    IRTCMediaManagePriv *pIRTCMediaManagePriv
    )
{
    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->Release();
    }

    m_pMediaManagePriv = pIRTCMediaManagePriv;

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->AddRef();
    }

}

//
//  IRTCNmCallControl methods
//

STDMETHODIMP
CRTCNmCall::Initialize (
    IN INmCall * pCall
    )
{
    HRESULT                                 hr = S_OK;
    CComPtr<IConnectionPointContainer>      pContainer;

    ENTER_FUNCTION("CRTCNmCall::Initialize");
    LOG((RTC_TRACE, "Entering %s, pCall=x%p", __fxName, pCall));

    //  Release any current call object
    if (m_pNmCall)
    {
        Shutdown ();
    }
    if (pCall == NULL)
    {
        goto ExitHere;
    }

    m_pNmCall = pCall;
    
    if (S_OK != (hr = pCall->QueryInterface (
        IID_IConnectionPointContainer, 
        (void **)&pContainer
        )))
    {
        goto ExitHere;
    }

    if (S_OK != (hr = pContainer->FindConnectionPoint (
        IID_INmCallNotify,
        &m_pcp
        )))
    {
        goto ExitHere;
    }

    m_pNmCall->GetState (&m_uState);

    m_fIncoming = (m_pNmCall->IsIncoming () == S_OK);

    if (S_OK != (hr = m_pcp->Advise (
        (IUnknown *)(INmCallNotify *)this,
        &m_dwCookie
        )))
    {
        goto ExitHere;
    }

    if (m_pMediaManagePriv)
    {
        // post message
        m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_CREATED,
            m_fIncoming?RTC_ME_CAUSE_REMOTE_REQUEST:RTC_ME_CAUSE_LOCAL_REQUEST,
            RTC_MT_DATA,
            m_fIncoming?RTC_MD_RENDER:RTC_MD_CAPTURE,
            S_OK
            );

        m_fCreated = TRUE;
    }

ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}
    
STDMETHODIMP
CRTCNmCall::Shutdown (
    )
{
    ENTER_FUNCTION("CRTCNmCall::Shutdown");
    LOG((RTC_TRACE, "Entering %s, m_pNmCall=x%p", __fxName, m_pNmCall));
    if (m_pNmCall)
    {
        CComPtr<INmConference>      pConf;

        if (m_pNmCall->GetConference (&pConf) == S_OK)
        {
            pConf->Leave ();
        }
        if (m_pcp && m_dwCookie != 0)
        {
            m_pcp->Unadvise (m_dwCookie);
            m_dwCookie = 0;
        }
        if (!m_fIncoming)
        {
            m_pNmCall->Cancel ();
        }
        else
        {
            m_pNmCall->Reject ();
        }
        m_uState = NM_CALL_INVALID;
        m_fToAccept = FALSE;
        m_pcp.Release();
        m_pNmCall.Release();

        // post message
        if (m_fActive)
        {
            m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_INACTIVE,
                RTC_ME_CAUSE_LOCAL_REQUEST,
                RTC_MT_DATA,
                m_fIncoming?RTC_MD_RENDER:RTC_MD_CAPTURE,
                S_OK
                );

            m_fActive = FALSE;
        }
    }

    if (m_fCreated)
    {
        m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_REMOVED,
            RTC_ME_CAUSE_LOCAL_REQUEST,
            RTC_MT_DATA,
            m_fIncoming?RTC_MD_RENDER:RTC_MD_CAPTURE,
            S_OK
            );

        m_fCreated = FALSE;
    }

    LOG((RTC_TRACE, "Exiting %s", __fxName));
    return S_OK;
}

STDMETHODIMP
CRTCNmCall::AcceptCall (
    )
{
    HRESULT             hr = S_OK;

    ENTER_FUNCTION("CRTCNmCall::AcceptCall");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    if (m_pNmCall == NULL || !m_fIncoming)
    {
        goto ExitHere;
    }

    m_fToAccept = TRUE;
    if (m_uState == NM_CALL_RING)
    {
        if (m_pNmCall->Accept () == S_OK)
        {
            m_fToAccept = FALSE;
        }
   }

ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

STDMETHODIMP
CRTCNmCall::LaunchRemoteApplet (
    IN NM_APPID uApplet
    )
{
    return E_NOTIMPL;
}

CRTCNmManager::CRTCNmManager ()
    :m_fAllowIncoming(FALSE)
    ,m_dwCookie(0)
    ,m_pMediaManagePriv(NULL)
{
}

CRTCNmManager::~CRTCNmManager ()
{
    Shutdown ();

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->Release();
        m_pMediaManagePriv = NULL;
    }
}

//
//  INmManagerNotify methods
//
    
STDMETHODIMP
CRTCNmManager::NmUI (
    IN CONFN uNotify
    )
{
    LOG((RTC_TRACE, "CRTCNmManager::NmUI, uNotify=%d", uNotify));
    return S_OK;
}

STDMETHODIMP
CRTCNmManager::ConferenceCreated (
    IN INmConference * pConference
    )
{
    ENTER_FUNCTION("CRTCNmManager::ConferenceCreated");
    LOG((RTC_TRACE, "Entering %s, pConf=x%p", __fxName, pConference));

    if (pConference)
    {
        if (m_pConference)
        {
            m_pConference->Leave ();
        }
        m_pConference = pConference;
    }

    LOG((RTC_TRACE, "Exiting %s", __fxName));
    return S_OK;
}

STDMETHODIMP
CRTCNmManager::CallCreated (
    IN INmCall * pCall
    )
{
    HRESULT                 hr = S_OK;
    CComObject<CRTCNmCall>  *pRtcCall = NULL;

    ENTER_FUNCTION("CRTCNmManager::CallCreated");
    LOG((RTC_TRACE, "Entering %s, pCall=x%p, fAllowIncoming=%d", __fxName, pCall, m_fAllowIncoming));

    if (pCall == NULL || !m_fAllowIncoming)
    {
        goto ExitHere;
    }

    if (m_pIncomingNmCall)
    {
        m_pIncomingNmCall->Shutdown ();
    }
    m_pIncomingNmCall.Release();

    if (S_OK != (hr = ::CreateCComObjectInstance(&pRtcCall)))
    {
        goto ExitHere;
    }
    if (S_OK != (hr = pRtcCall->_InternalQueryInterface(
        __uuidof(IRTCNmCallControl),
        (void**)&m_pIncomingNmCall
        )))
    {
        delete pRtcCall;
        goto ExitHere;
    }

    pRtcCall->SetMediaManage(m_pMediaManagePriv);

    if (S_OK != (hr = m_pIncomingNmCall->Initialize (pCall)))
    {
        goto ExitHere;
    }

    if (S_OK != (hr = m_pIncomingNmCall->AcceptCall ()))
    {
        goto ExitHere;
    }

ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

//
//  IRTCNmManagerControl methods
//

STDMETHODIMP
CRTCNmManager::Initialize (
    BOOL            fNoMsgPump,
    IRTCMediaManagePriv *pIRTCMediaManagePriv
    )
{
    HRESULT                                 hr = S_OK;
    ULONG                                   ulOptions;
    CComPtr<IConnectionPointContainer>      pContainer;

    ENTER_FUNCTION("CRTCNmManager::Initialize");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    //  Create Netmeeting manager if not exists
    if (m_pNmManager == NULL)
    {
        CComPtr<INmSysInfo>                     pSysInfo;
        CComBSTR                                bstr;
        CComBSTR                                bstrFirstName;
        CComBSTR                                bstrLastName;
        CComBSTR                                bstrUserName;
        CComBSTR                                bstrEmailName;
        HKEY                                    hKeyConf;
        ULONG                                   ulVerWizardUI = (-1);
        BOOL                                    fValueExist = FALSE;
        DWORD                                   dwRegType;
        DWORD                                   dwDisposition;
        DWORD                                   cb;
        
        LOG((RTC_TRACE, "%s, first init", __fxName));
        
        if (S_OK != (hr = CoCreateInstance(
            CLSID_NmManager, 
            NULL, 
            CLSCTX_LOCAL_SERVER, 
            IID_INmManager, 
            (void**)&m_pNmManager
            )))
        {
            goto ExitHere;
        }

        //  Disable ILS logon during startup
        if (S_OK != (hr = m_pNmManager->GetSysInfo (&pSysInfo)))
        {
            goto ExitHere;
        }
        bstr = L"1";
        pSysInfo->SetProperty (
            NM_SYSPROP_DISABLE_INITIAL_ILS_LOGON,
            bstr
            );

        //  Disable the H323 call during startup
        pSysInfo->SetProperty (
            NM_SYSPROP_DISABLE_H323,
            bstr
            );

        //  Tell NM this is RTC
        pSysInfo->SetProperty (
            (NM_SYSPROP)NM_SYSPROP_CALLERISRTC,
            bstr
            );

        //
        //  If Netmeeting is running the first time, the Netmeeting Wizard
        //  will show up. To prevent this, we need to make sure four system
        //  properties are there: First Name, Last Name, User Name, Email Name
        //

        //  Check the user name
        if (S_OK != (hr = pSysInfo->GetProperty (NM_SYSPROP_USER_NAME, &bstrUserName)) ||
            bstrUserName.Length() == 0)
        {
            LPWSTR      pszUserName = RtcGetUserName ();
            if (pszUserName != NULL)
            {
                bstrUserName = pszUserName;
                RtcFree (pszUserName);
            }
            if (bstrUserName.Length () == 0)
            {
                hr = E_OUTOFMEMORY;
                goto ExitHere;
            }
            if (S_OK != (hr = pSysInfo->SetProperty (NM_SYSPROP_USER_NAME, bstrUserName)))
            {
                goto ExitHere;
            }
        }

        //  Check the first name
        if (S_OK != (hr = pSysInfo->GetProperty (NM_SYSPROP_FIRST_NAME, &bstrFirstName)) ||
            bstrFirstName.Length() == 0)
        {
            bstrFirstName = L" ";
            if (bstrFirstName.Length () == 0)
            {
                hr = E_OUTOFMEMORY;
                goto ExitHere;
            }
            if (S_OK != (hr = pSysInfo->SetProperty (NM_SYSPROP_FIRST_NAME, bstrFirstName)))
            {
                goto ExitHere;
            }
        }

        //  Check the last name
        if (S_OK != (hr = pSysInfo->GetProperty (NM_SYSPROP_LAST_NAME, &bstrLastName)) ||
            bstrLastName.Length () == 0)
        {
            bstrLastName = L" ";
            if (bstrLastName.Length () == 0)
            {
                hr = E_OUTOFMEMORY;
                goto ExitHere;
            }
            if (S_OK != (hr = pSysInfo->SetProperty (NM_SYSPROP_LAST_NAME, bstrLastName)))
            {
                goto ExitHere;
            }
        }

        //  Check the email name
        if (S_OK != (hr = pSysInfo->GetProperty (NM_SYSPROP_EMAIL_NAME, &bstrEmailName)) ||
            bstrEmailName.Length () == 0)
        {
            LPWSTR      pszMachineName = RtcGetComputerName ();
    
            bstrEmailName = bstrUserName;
            bstrEmailName.Append (L"@");
            if (pszMachineName != NULL)
            {
                bstrEmailName.Append (pszMachineName);
                RtcFree (pszMachineName);
            }
            if (bstrEmailName.Length () == 0)
            {
                hr = E_OUTOFMEMORY;
                goto ExitHere;
            }
            if (S_OK != (hr = pSysInfo->SetProperty (NM_SYSPROP_EMAIL_NAME, bstrEmailName)))
            {
                goto ExitHere;
            }
        }

        //
        //  HACK ALERT:
        //      NM brings up its wizard regardless the setting of email name, first/last name
        //  and user name even though they claim otherwise in their spec. We have to
        //  force HKCU\Software\Microsot\Conferencing\WizardUI=REG_BINARY(39 0d 04 04)
        //  to avoid the wizard on a clean install machine
        //
        if (RegCreateKeyEx (
            HKEY_CURRENT_USER,
            g_szRegNmConfPath,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &hKeyConf,
            &dwDisposition
            ) == ERROR_SUCCESS)
        {
            cb = sizeof(ulVerWizardUI);
            dwRegType = REG_BINARY;
            if (RegQueryValueEx (
                hKeyConf,
                g_szRegWizardUI,
                NULL,
                &dwRegType,
                (LPBYTE)&ulVerWizardUI,
                &cb
                ) == ERROR_SUCCESS)
            {
                fValueExist = TRUE;
            }
            RegSetValueEx (
                hKeyConf,
                g_szRegWizardUI,
                NULL,
                REG_BINARY,
                (LPBYTE)&g_ulNmWizardUIVersion,
                sizeof(g_ulNmWizardUIVersion)
                );
        }
        else
        {
            hKeyConf = NULL;
        }
        
        ulOptions = NM_INIT_CONTROL;
        hr = m_pNmManager->Initialize (
            &ulOptions,
            NULL);

        //  Restore HKCU\Software\Microsot\Conferencing\WizardUI
        if (hKeyConf)
        {
            if (fValueExist)
            {
                RegSetValueEx (
                    hKeyConf,
                    g_szRegWizardUI,
                    NULL,
                    REG_BINARY,
                    (LPBYTE)&ulVerWizardUI,
                    sizeof(ulVerWizardUI)
                    );
            }
            else
            {
                RegDeleteValue (
                    hKeyConf,
                    g_szRegWizardUI
                    );
            }
            RegCloseKey (hKeyConf);
        }
        
        if (S_OK != hr)
        {
            goto ExitHere;
        }
    }

    //  bail if already initialized
    if (m_dwCookie != 0 || m_pcp != NULL ||
        m_pOutgoingNmCall != NULL || m_pIncomingNmCall != NULL)
    {
        goto ExitHere;
    }

    //  Hookup the advise link
    if (S_OK != (hr = m_pNmManager->QueryInterface (
        IID_IConnectionPointContainer, 
        (void **)&pContainer
        )))
    {
        goto ExitHere;
    }

    if (S_OK != (hr = pContainer->FindConnectionPoint (
        IID_INmManagerNotify,
        &m_pcp
        )))
    {
        goto ExitHere;
    }

    if (S_OK != (hr = m_pcp->Advise (
        (IUnknown *)(INmManagerNotify *)this,
        &m_dwCookie
        )))
    {
        goto ExitHere;
    }

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->Release();
    }

    m_pMediaManagePriv = pIRTCMediaManagePriv;

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->AddRef();
    }

ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

STDMETHODIMP
CRTCNmManager::Shutdown (
    )
{
    ENTER_FUNCTION("CRTCNmManager::Shutdown");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    m_fAllowIncoming = FALSE;
    if (m_pIncomingNmCall)
    {
        m_pIncomingNmCall->Shutdown ();
    }
    if (m_pOutgoingNmCall)
    {
        m_pOutgoingNmCall->Shutdown ();
    }
    m_pOutgoingNmCall.Release();    
    m_OutgoingAddr.Empty();

    m_pIncomingNmCall.Release();
    if (m_dwCookie != 0)
    {
        if (m_pcp)
        {
            m_pcp->Unadvise (m_dwCookie);
        }
        m_dwCookie = 0;
    }
    m_pcp.Release();
    if (m_pConference)
    {
        m_pConference->Leave ();
    }
    m_pConference.Release ();

    LOG((RTC_TRACE, "Exiting %s", __fxName));
    return S_OK;
}

STDMETHODIMP
CRTCNmManager::CreateT120OutgoingCall (
    NM_ADDR_TYPE    addrType,
    BSTR bstrAddr
    )
{
    HRESULT                 hr = S_OK;
    CComPtr<INmCall>        pNmCall;
    CComObject<CRTCNmCall>  *pRtcCall = NULL;

    ENTER_FUNCTION("CreateT120OutgoingCall");
    LOG((RTC_TRACE, "Entering %s, addr=%ls", __fxName, bstrAddr));
    
    if (m_pNmManager == NULL)
    {
        goto ExitHere;
    }

    if (m_pOutgoingNmCall)
    {
        if (m_OutgoingAddr == bstrAddr)
        {
            // address and port are not changed
            return S_OK;
        }

        m_pOutgoingNmCall->Shutdown ();
        m_pOutgoingNmCall.Release();
    }
    
    if (S_OK != (hr = m_pNmManager->CreateCall (
        &pNmCall,
        NM_CALL_T120,
        addrType,
        bstrAddr,
        NULL
        )))
    {
        goto ExitHere;
    }

    if (S_OK != (hr = ::CreateCComObjectInstance(&pRtcCall)))
    {
        goto ExitHere;
    }
    if (S_OK != (hr = pRtcCall->_InternalQueryInterface(
        __uuidof(IRTCNmCallControl),
        (void**)&m_pOutgoingNmCall
        )))
    {
        delete pRtcCall;
        goto ExitHere;
    }

    pRtcCall->SetMediaManage(m_pMediaManagePriv);

    if (S_OK != (hr = m_pOutgoingNmCall->Initialize (pNmCall)))
    {
        goto ExitHere;
    }

    m_OutgoingAddr = bstrAddr;

ExitHere:

    if (FAILED(hr))
    {
        if (m_pOutgoingNmCall)
        {
            m_pOutgoingNmCall->Shutdown ();
            m_pOutgoingNmCall.Release();
        }

        m_OutgoingAddr.Empty();
    }

    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

STDMETHODIMP
CRTCNmManager::AllowIncomingCall (
    )
{
    ENTER_FUNCTION("CRTCNmManager::AllowIncomingCall");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    if (!m_fAllowIncoming)
    {
        m_pIncomingNmCall.Release();
        m_fAllowIncoming = TRUE;
    }

    LOG((RTC_TRACE, "Exiting %s", __fxName));
    
    return S_OK;
}

STDMETHODIMP
CRTCNmManager::StartApplet (
    IN NM_APPID uApplet
    )
{
    HRESULT                     hr = S_OK;
    CComPtr<INmObject>          pNmObject;

    ENTER_FUNCTION("CRTCNmManager::StartApplet");
    LOG((RTC_TRACE, "Entering %s, uApplet=%d", __fxName, uApplet));

    // we only support whiteboard and appsharing
    if(uApplet != NM_APPID_T126_WHITEBOARD &&
       uApplet != NM_APPID_APPSHARING)
    {
        return E_NOTIMPL;
    }

    if (m_pNmManager == NULL)
    {
        goto ExitHere;
    }

    if (S_OK != (hr = m_pNmManager->QueryInterface (
        IID_INmObject, 
        (void **)&pNmObject
        )))
    {
        goto ExitHere;
    }
    hr = pNmObject->ShowLocal (uApplet);
    if (m_pIncomingNmCall)
    {
        m_pIncomingNmCall->LaunchRemoteApplet (uApplet);
    }
    if (m_pOutgoingNmCall)
    {
        m_pOutgoingNmCall->LaunchRemoteApplet (uApplet);
    }

ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

STDMETHODIMP
CRTCNmManager::StopApplet (
    IN NM_APPID uApplet
    )
{
    return E_UNEXPECTED;
}


///////////////////////////////////////////////////////////
//
//  CRTCAsyncObjManager implementation
//  
///////////////////////////////////////////////////////////

//
//  Constructor & Destructor
//

CRTCAsyncObjManager::CRTCAsyncObjManager ()
{
    LOG((RTC_TRACE, "CRTCAsyncObjManager constructor"));
    
    m_bExit = FALSE;
    m_hWorkItemReady = NULL;
    m_hWorker = NULL;
}

HRESULT CRTCAsyncObjManager::Initialize (
    )
{
    HRESULT                     hr = S_OK;

    ENTER_FUNCTION("CRTCAsyncObjManager::Initialize");
    LOG((RTC_TRACE, "Entering %s", __fxName));
    
    InitializeListHead (&m_WorkItems);
    m_hWorkItemReady = CreateEvent (
        NULL,                   // lpEventAttributes
        FALSE,                  // bManualReset
        FALSE,                  // bInitialState
        NULL                    // lpName
        );
    if (m_hWorkItemReady == NULL)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }

    __try 
    {
        InitializeCriticalSectionAndSpinCount (&m_CritSec, 1000);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        CloseHandle (m_hWorkItemReady);
        m_hWorkItemReady = NULL;
        hr = E_OUTOFMEMORY;
        goto ExitHere;
    }

    m_hWorker= CreateThread (
        NULL,                   // lpThreadAttributes
        0,                      // dwStackSize
        RTCAsyncObjThreadProc,  // lpStartAddress
        (LPVOID)this,           // lpParameter
        0,                      // dwCreationFlags
        NULL                    // lpThreadId
        );
    if (m_hWorker == NULL)
    {
        CloseHandle (m_hWorkItemReady);
        m_hWorkItemReady = NULL;
        DeleteCriticalSection (&m_CritSec);
        m_hWorker = NULL;
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    
ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

CRTCAsyncObjManager::~CRTCAsyncObjManager ()
{
    LOG((RTC_TRACE, "CRTCAsyncObjManager destructor"));

    if (m_hWorkItemReady)
    {
        if (m_hWorker)
        {
            m_bExit = TRUE;
            SetEvent (m_hWorkItemReady);
            WaitForSingleObject (m_hWorker, INFINITE);
            CloseHandle (m_hWorker);
        }
        _ASSERT (IsListEmpty(&m_WorkItems));
        DeleteCriticalSection (&m_CritSec);
        CloseHandle (m_hWorkItemReady);
    }
}

//
//  The thread procedure
//

DWORD WINAPI CRTCAsyncObjManager::RTCAsyncObjThreadProc (
    LPVOID lpParam
    )
{
    CRTCAsyncObjManager         *pThis = (CRTCAsyncObjManager *)lpParam;
    LIST_ENTRY                  *pEntry;
    ASYNC_OBJ_WORKITEM          *pItem;
    CRTCAsyncObj                *pObj;
    MSG                         msg;
    BOOL                        bEmpty;

    ENTER_FUNCTION("CRTCAsyncObjManager::RTCAsyncObjThreadProc");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    _ASSERT (pThis != NULL);

    CoInitialize (NULL);
    
    while (!pThis->m_bExit)
    {
        while (MsgWaitForMultipleObjects (
            1,                  // nCount
            &pThis->m_hWorkItemReady,  // pHandles
            FALSE,              // fWaitAll
            INFINITE,           // dwMilliseconds
            QS_ALLINPUT         // dwWakeMask
            ) != WAIT_OBJECT_0)
        {
            while (PeekMessage (
                &msg,           // lpMsg
                NULL,           // hWnd
                0,              // wMsgFilterMin
                0,              // wMsgFilterMax
                PM_REMOVE       // wRemoveMsg
                ))
            {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            }
        }

        while (1)
        {
            EnterCriticalSection (&pThis->m_CritSec);
            bEmpty = IsListEmpty(&pThis->m_WorkItems);
            if (!bEmpty)
            {
                pEntry = RemoveHeadList (&pThis->m_WorkItems);
                pItem = CONTAINING_RECORD (pEntry, ASYNC_OBJ_WORKITEM, ListEntry);
                pObj = pItem->pObj;
            }
            LeaveCriticalSection (&pThis->m_CritSec);
            if (bEmpty)
            {
                break;
            }
            LOG((RTC_INFO, 
                "%s got workitem : pObj=x%x, ID=%d, p1=x%x, p2=x%x, p3=x%x, p4=x%x",
                __fxName,
                pObj,
                pItem->dwWorkID,
                pItem->pParam1,
                pItem->pParam2,
                pItem->pParam3,
                pItem->pParam4
                ));
            pItem->hrResult = pObj->ProcessWorkItem (
                pItem->dwWorkID,
                pItem->pParam1,
                pItem->pParam2,
                pItem->pParam3,
                pItem->pParam4
                );
            SetEvent (pItem->hEvent);
        }
    }

    CoUninitialize ();
    LOG((RTC_TRACE, "Exiting %s", __fxName));

    return 0;
}

//
//  Queue & Dequeue work items
//

HRESULT CRTCAsyncObjManager::QueueWorkItem (
    ASYNC_OBJ_WORKITEM *pItem
    )
{
    HRESULT                 hr = S_OK;

    if (m_hWorkItemReady == NULL)
    {
        hr = CO_E_NOTINITIALIZED;
        goto ExitHere;
    }

    EnterCriticalSection (&m_CritSec);
    InsertTailList (&m_WorkItems, &pItem->ListEntry);
    SetEvent (m_hWorkItemReady);
    LeaveCriticalSection (&m_CritSec);

ExitHere:
    return hr;
}

///////////////////////////////////////////////////////////
//
//  CRTCAsyncObj implementation
//  
///////////////////////////////////////////////////////////

HRESULT CRTCAsyncObj::CallInBlockingMode (
    DWORD               dwID,
    LPVOID              pParam1,
    LPVOID              pParam2,
    LPVOID              pParam3,
    LPVOID              pParam4
    )
{
    HRESULT                 hr = S_OK;
    ASYNC_OBJ_WORKITEM      *pItem;
    
    _ASSERT (m_pManager != NULL);

    pItem = (ASYNC_OBJ_WORKITEM *)RtcAlloc (sizeof(ASYNC_OBJ_WORKITEM));
    if (pItem == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ExitHere;
    }
    if ((pItem->hEvent = CreateEvent (
        NULL,                   // lpEventAttributes
        FALSE,                  // bManualReset
        FALSE,                  // bInitialState
        NULL                    // lpName
        )) == NULL)
    {
        RtcFree (pItem);
        pItem = NULL;
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    pItem->dwWorkID = dwID;
    pItem->pObj = this;
    pItem->pParam1 = pParam1;
    pItem->pParam2 = pParam2;
    pItem->pParam3 = pParam3;
    pItem->pParam4 = pParam4;
    hr = m_pManager->QueueWorkItem (pItem);
    if (S_OK != hr)
    {
        goto ExitHere;
    }
    if (WaitForSingleObject (pItem->hEvent, INFINITE) == WAIT_FAILED)
    {
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    hr = pItem->hrResult;

ExitHere:
    if (pItem)
    {
        CloseHandle (pItem->hEvent);
        RtcFree (pItem);
    }
    return hr;
}

HRESULT CRTCAsyncObj::CallInNonblockingMode (
    DWORD               dwID,
    LPVOID              pParam1,
    LPVOID              pParam2,
    LPVOID              pParam3,
    LPVOID              pParam4
    )
{
    HRESULT                 hr = S_OK;
    ASYNC_OBJ_WORKITEM      *pItem;
    DWORD                   dwWait;
    MSG                     msg;
    
    _ASSERT (m_pManager != NULL);

    pItem = (ASYNC_OBJ_WORKITEM *)RtcAlloc (sizeof(ASYNC_OBJ_WORKITEM));
    if (pItem == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ExitHere;
    }
    if ((pItem->hEvent = CreateEvent (
        NULL,                   // lpEventAttributes
        FALSE,                  // bManualReset
        FALSE,                  // bInitialState
        NULL                    // lpName
        )) == NULL)
    {
        RtcFree (pItem);
        pItem = NULL;
        hr = HRESULT_FROM_WIN32 (GetLastError ());
        goto ExitHere;
    }
    pItem->dwWorkID = dwID;
    pItem->pObj = this;
    pItem->pParam1 = pParam1;
    pItem->pParam2 = pParam2;
    pItem->pParam3 = pParam3;
    pItem->pParam4 = pParam4;
    if (S_OK != (hr = m_pManager->QueueWorkItem (pItem)))
    {
        goto ExitHere;
    }
    while (1)
    {
        dwWait = MsgWaitForMultipleObjects (
            1,                  // nCount
            &pItem->hEvent,     // pHandles
            FALSE,              // fWaitAll
            INFINITE,           // dwMilliseconds
            QS_ALLINPUT         // dwWakeMask
            );
        switch (dwWait)
        {
        case WAIT_OBJECT_0:
            hr = pItem->hrResult;
            goto ExitHere;
        case WAIT_FAILED:
            hr = HRESULT_FROM_WIN32 (GetLastError ());
            goto ExitHere;
        default:
            while (PeekMessage (
                &msg,           // lpMsg
                NULL,           // hWnd
                0,              // wMsgFilterMin
                0,              // wMsgFilterMax
                PM_REMOVE       // wRemoveMsg
                ))
            {
                TranslateMessage (&msg);
                DispatchMessage (&msg);
            }
                
            break;
        }
    }

ExitHere:
    if (pItem)
    {
        CloseHandle (pItem->hEvent);
        RtcFree (pItem);
    }
    return hr;
}

///////////////////////////////////////////////////////////
//  CRTCAsyncNmManager implementation
//  
//      This class wraps around CRTCNmManager. It spins 
//  another thread from which the CRTCNmManager is created.
//  It then marshals any INmManager interface function calls
//  to CRTCNmManager object
//
//      The purpose of this object is not to block caller
//  while CRTCNmManager::Initialize is called. The 
//  CRTCNmManager::Initialize was observed to take too long
//  to finish.
//
///////////////////////////////////////////////////////////

//
//  Constructor & Destructor
//

CRTCAsyncNmManager::CRTCAsyncNmManager ()
    :m_pAsyncMgr(NULL)
    ,m_pMediaManagePriv(NULL)
{
    LOG((RTC_TRACE, "CRTCAsyncNmManager constructor"));
}

CRTCAsyncNmManager::~CRTCAsyncNmManager()
{
    LOG((RTC_TRACE, "CRTCAsyncNmManager destructor"));
    if (m_pAsyncMgr)
    {
        delete m_pAsyncMgr;
    }

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->Release();
        m_pMediaManagePriv = NULL;
    }
}

//
//  Final Construct
//
//      Spawn the worker thread
//

HRESULT 
CRTCAsyncNmManager::FinalConstruct (
    )
{
    HRESULT                     hr = S_OK;
    CComObject<CRTCNmManager>   *pNmManager = NULL;

    ENTER_FUNCTION("CRTCAsyncNmManager::FinalConstruct");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    if (S_OK != (hr = ::CreateCComObjectInstance(&pNmManager)))
    {
        goto ExitHere;
    }

    if (S_OK != (hr = pNmManager->_InternalQueryInterface(
        __uuidof(IRTCNmManagerControl),
        (void**)&m_pNmManager
        )))
    {
        delete pNmManager;
        goto ExitHere;
    }

    m_pAsyncMgr = new CRTCAsyncObjManager ();
    if (m_pAsyncMgr == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ExitHere;
    }
    if (S_OK != (hr = m_pAsyncMgr->Initialize ()))
    {
        goto ExitHere;
    }
    SetAsyncObjManager (m_pAsyncMgr);

ExitHere:
    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

HRESULT CRTCAsyncNmManager::ProcessWorkItem (
    DWORD           dwWorkID,
    LPVOID          pParam1,
    LPVOID          pParam2,
    LPVOID          pParam3,
    LPVOID          pParam4
    )
{
    HRESULT                 hr = S_OK;

#ifdef PERFORMANCE

    LARGE_INTEGER liPrevCounter, liCounter;

    QueryPerformanceCounter(&liPrevCounter);

#endif

    _ASSERT (m_pNmManager != NULL);

    switch (dwWorkID)
    {
    case RTC_INTIALIZE_NM:
        hr = m_pNmManager->Initialize ((BOOL)PtrToUlong(pParam1), m_pMediaManagePriv);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "failed to init t120. %x", hr));

            if (m_pMediaManagePriv)
            {
                m_pMediaManagePriv->PostMediaEvent(
                    RTC_ME_T120_FAIL,
                    RTC_ME_CAUSE_T120_INITIALIZE,
                    RTC_MT_DATA,
                    RTC_MD_CAPTURE,
                    hr
                    );
            }
        }

#ifdef PERFORMANCE

    QueryPerformanceCounter(&liCounter);

    LOG((RTC_TRACE, "%s Initialize Netmeeting %d ms", g_strPerf, CounterDiffInMS(liCounter, liPrevCounter)));

#endif

        break;
    case RTC_SHUTDOWN_NM:
        hr = m_pNmManager->Shutdown ();

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "failed to shutdown t120. %x", hr));
        }

        break;
    case RTC_CREATE_T120CALL:
        hr = m_pNmManager->CreateT120OutgoingCall (
            (NM_ADDR_TYPE)PtrToUlong(pParam1),
            (BSTR)pParam2
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "failed to create t120 outgoing call. %x", hr));

            if (m_pMediaManagePriv)
            {
                m_pMediaManagePriv->PostMediaEvent(
                    RTC_ME_T120_FAIL,
                    RTC_ME_CAUSE_T120_OUTGOING_CALL,
                    RTC_MT_DATA,
                    RTC_MD_CAPTURE,
                    hr
                    );
            }
        }

        break;
    case RTC_ALLOW_INCOMINGCALL:
        hr = m_pNmManager->AllowIncomingCall (
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "failed to alloc t120 incoming call. %x", hr));

            if (m_pMediaManagePriv)
            {
                m_pMediaManagePriv->PostMediaEvent(
                    RTC_ME_T120_FAIL,
                    RTC_ME_CAUSE_T120_INCOMING_CALL,
                    RTC_MT_DATA,
                    RTC_MD_CAPTURE,
                    hr
                    );
            }
        }

        break;
    case RTC_START_APPLET:
        hr = m_pNmManager->StartApplet (
            (NM_APPID)PtrToUlong(pParam1)
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "failed to start t120 applet. %x", hr));

            if (m_pMediaManagePriv)
            {
                m_pMediaManagePriv->PostMediaEvent(
                    RTC_ME_T120_FAIL,
                    RTC_ME_CAUSE_T120_START_APPLET,
                    RTC_MT_DATA,
                    RTC_MD_CAPTURE,
                    hr
                    );
            }
        }

        break;
    case RTC_STOP_APPLET:
        hr = m_pNmManager->StopApplet (
            (NM_APPID)PtrToUlong(pParam1)
            );
        break;
    default:
        _ASSERT(FALSE);
        break;
    }

    return hr;
}

STDMETHODIMP
CRTCAsyncNmManager::Initialize (
    BOOL            fNoMsgPump,
    IRTCMediaManagePriv *pIRTCMediaManagePriv
    )
{
    // only support blocking mode
    _ASSERT(fNoMsgPump);

    if (!fNoMsgPump)
    {
        fNoMsgPump = TRUE;
    }

    HRESULT                                 hr;

    ENTER_FUNCTION("CRTCAsyncNmManager::Initialize");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    if (m_pMediaManagePriv)
        m_pMediaManagePriv->Release();

    m_pMediaManagePriv = pIRTCMediaManagePriv;

    if (m_pMediaManagePriv)
        m_pMediaManagePriv->AddRef();

    if (fNoMsgPump)
    {
        hr = CallInBlockingMode (
            RTC_INTIALIZE_NM,
            (LPVOID)fNoMsgPump, 0, 0, 0);
    }
    else
    {
        hr = CallInNonblockingMode (
            RTC_INTIALIZE_NM,
            (LPVOID)fNoMsgPump, 0, 0, 0);
    }

    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    
    return hr;
}

STDMETHODIMP
CRTCAsyncNmManager::Shutdown (
    )
{
    HRESULT                                 hr;

    ENTER_FUNCTION("CRTCAsyncNmManager::Shutdown");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    hr = CallInBlockingMode (
        RTC_SHUTDOWN_NM,
        0, 0, 0, 0);

    LOG((RTC_TRACE, "Exiting %s", __fxName));
    
    return hr;
}

STDMETHODIMP
CRTCAsyncNmManager::CreateT120OutgoingCall (
    NM_ADDR_TYPE    addrType,
    BSTR bstrAddr
    )
{
    HRESULT                                 hr;

    ENTER_FUNCTION("CRTCAsyncNmManager::CreateT120OutgoingCall");
    LOG((RTC_TRACE, "Entering %s, addr=%ls", __fxName, bstrAddr));

    hr = CallInBlockingMode (
        RTC_CREATE_T120CALL,
        (LPVOID)addrType , 
        (LPVOID)bstrAddr, 
        0, 0);

    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));

    return hr;
}

STDMETHODIMP
CRTCAsyncNmManager::AllowIncomingCall (
    )
{
    HRESULT                                 hr;

    ENTER_FUNCTION("CRTCAsyncNmManager::AllowIncomingCall");
    LOG((RTC_TRACE, "Entering %s", __fxName));

    hr = CallInBlockingMode (
        RTC_ALLOW_INCOMINGCALL,
        0, 0, 0, 0);

    LOG((RTC_TRACE, "Exiting %s", __fxName));
    
    return hr;
}

STDMETHODIMP
CRTCAsyncNmManager::StartApplet (
    IN NM_APPID uApplet
    )
{
    HRESULT                                 hr;

    ENTER_FUNCTION("CRTCAsyncNmManager::StartApplet");
    LOG((RTC_TRACE, "Entering %s, uApplet=%d", __fxName, uApplet));

    hr = CallInBlockingMode (
        RTC_START_APPLET,
        (LPVOID)uApplet, 
        0, 0, 0);

    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}

STDMETHODIMP
CRTCAsyncNmManager::StopApplet (
    IN NM_APPID uApplet
    )
{
    HRESULT                                 hr;

    ENTER_FUNCTION("CRTCAsyncNmManager::StopApplet");
    LOG((RTC_TRACE, "Entering %s, uApplet=%d", __fxName, uApplet));

    hr = CallInBlockingMode (
        RTC_STOP_APPLET,
        (LPVOID)uApplet, 
        0, 0, 0);

    LOG((RTC_TRACE, "Exiting %s, hr=x%x", __fxName, hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\mediareg.h ===
/*++

Module Name:

    MediaReg.h

Abstract:
        
    Wrap operations in registry

--*/

#ifndef _MEDIAREG_h
#define _MEDIAREG_H

namespace MediaReg
{

    // key path
    static const WCHAR * const pwsPathParser = L"Software\\Microsoft\\RTC\\Parser";
    // name
#if 0
    static const WCHAR * const pwsLooseEndCRLF = L"LooseEndCRLF";
    static const WCHAR * const pwsLooseKeepingM0 = L"LooseKeepingM0";
    static const WCHAR * const pwsLooseLineOrder = L"LooseLineOrder";
    static const WCHAR * const pwsLooseRTPMAP = L"LooseRTPMAP";
#endif
    // key path
    static const WCHAR * const pwsPathCodec = L"Software\\Microsoft\\RTC\\Codec";
    // name
    static const WCHAR * const pwsUsePreferredCodec = L"UsePreferredCodec";
    static const WCHAR * const pwsPreferredAudioCodec = L"PreferredAudioCodec";
    static const WCHAR * const pwsPreferredVideoCodec = L"PreferredVideoCodec";
    static const WCHAR * const pwsDisabledAudioCodec = L"DisabledAudioCodec";
    static const WCHAR * const pwsDisabledVideoCodec = L"DisabledVideoCodec";
//    static const WCHAR * const pwsDSoundWorkAround = L"CheckSessionType";

    // key path
    static const WCHAR * const pwsPathAudCapt = L"Software\\Microsoft\\RTC\\AudioCapture";
    static const WCHAR * const pwsPathAudRend = L"Software\\Microsoft\\RTC\\AudioRender";
    static const WCHAR * const pwsPathAEC = L"Software\\Microsoft\\RTC\\AEC";
    // name
    static const WCHAR * const pwsDefaultVolume = L"DefaultVolume";
    // static const WCHAR * const pwsEnableAEC = L"EnableAEC";

    // key path
    static const WCHAR * const pwsPathQuality = L"Software\\Microsoft\\RTC\\Quality";
    // name
    static const WCHAR * const pwsMaxBitrate = L"MaxBitrate(kb)";
    static const WCHAR * const pwsEnableSQCIF = L"EnableSQCIF";
    static const WCHAR * const pwsBandwidthMargin = L"BandwidthReserved(kb)";
    static const WCHAR * const pwsFramerate = L"VideoFramerate(0<n<25)";
    static const WCHAR * const pwsMaxPTime = L"MaxAudioPTime(30<=n)";
    static const WCHAR * const pwsBWDelta = L"BWDeltaForCodecSwitch(kb)";

    static const WCHAR * const pwsPortMappingRetryCount = L"PortMappingRetryCount(max=5)";

    // access right to a key
    const ULONG READ = 1;
    const ULONG WRITE = 2;
    const ULONG CREATE = 4;

};

// utility class
class CMediaReg
{
public:
    CMediaReg ():m_hKey(NULL) {};

    ~CMediaReg();

    HRESULT OpenKey(
        IN HKEY hKey,
        IN const WCHAR * const pwsPath,
        IN ULONG ulRight
        );

    HRESULT OpenKey(
        IN const CMediaReg& objMediaReg,
        IN const WCHAR * const pwsPath,
        IN ULONG ulRight
        );

    HRESULT CloseKey();

    // write/read value
    HRESULT ReadDWORD(
        IN const WCHAR * const pwsName,
        OUT DWORD *pdwData
        );

    HRESULT ReadDWORD(
        IN const WCHAR * const pwsName,
        IN DWORD dwDefault,
        OUT DWORD *pdwData
        );

    HRESULT WriteDWORD(
        IN const WCHAR * const pwsName,
        IN DWORD dwData
        );

    HRESULT ReadSZ(
        IN const WCHAR * const pwsName,
        OUT WCHAR *pwcsData,
        IN DWORD dwSize
        );

    HRESULT WriteSZ(
        IN const WCHAR * const pwsName,
        IN WCHAR *pwcsData,
        IN DWORD dwSize
        );

    HKEY m_hKey;
};
    

// store registry setting
class CRegSetting
{
public:

    // max bitrate for the call
    DWORD       m_dwMaxBitrate;
    DWORD       m_dwBandwidthMargin;
    DWORD       m_dwBWDelta;

    // enable sub QCIF for slow link
    DWORD       m_dwEnableSQCIF;

    // framerate
    DWORD       m_dwFramerate;

    // audio packet size
    DWORD       m_dwMaxPTime;

    // use preferred codec
    DWORD       m_dwUsePreferredCodec;

    DWORD       m_dwPreferredAudioCodec;
    DWORD       m_dwPreferredVideoCodec;

    DWORD       m_dwDisabledAudioCodec;
    DWORD       m_dwDisabledVideoCodec;

    DWORD       m_dwPortMappingRetryCount;

public:

    CRegSetting();

    ~CRegSetting() {};

    VOID Initialize();

    DWORD MaxBitrate() const
    { return m_dwMaxBitrate; }

    BOOL EnableSQCIF() const
    { return m_dwEnableSQCIF!=0; }

    BOOL UsePreferredCodec() const
    { return m_dwUsePreferredCodec!=0; }

    DWORD PreferredAudioCodec() const
    { return m_dwPreferredAudioCodec; }

    DWORD PreferredVideoCodec() const
    { return m_dwPreferredVideoCodec; }

    DWORD DisabledAudioCodec() const
    { return m_dwDisabledAudioCodec; }

    DWORD DisabledVideoCodec() const
    { return m_dwDisabledVideoCodec; }

    DWORD PortMappingRetryCount() const
    { return m_dwPortMappingRetryCount; }

    DWORD BandwidthMargin() const
    { return m_dwBandwidthMargin; }

    DWORD Framerate() const
    { return m_dwFramerate; }

    DWORD MaxPTime() const
    { return m_dwMaxPTime; }

    DWORD BandwidthDelta() const
    { return m_dwBWDelta; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\parser.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    Parser.h

Abstract:

    Parsing utility

Author(s):

    Qianbo Huai (qhuai) 27-Mar-2001

--*/

#ifndef _PARSER_H
#define _PARSER_H

// pasing methods
class CParser
{
public:

    typedef enum
    {
        PARSER_OK,
        END_OF_BUFFER,
        NUMBER_OVERFLOW

    } PARSER_ERROR;

    static const CHAR * const MAX_DWORD_STRING;
    static const DWORD MAX_DWORD_STRING_LEN = 10;

    static const CHAR * const MAX_UCHAR_STRING;
    static const DWORD MAX_UCHAR_STRING_LEN = 3;

public:

    static BOOL IsNumber(CHAR ch) { return ('0'<=ch && ch<='9'); }

    static BOOL IsMember(CHAR ch, const CHAR * const pStr);

    static CHAR LowerChar(CHAR ch);

    static int Compare(CHAR *pBuf, DWORD dwLen, const CHAR * const pstr, BOOL bIgnoreCase = FALSE);

public:

    CParser(CHAR *pBuf, DWORD dwLen, HRESULT *phr);

    ~CParser();

    // new a buffer
    CParser *CreateParser(DWORD dwStartPos, DWORD dwEndPos);

    BOOL SetBuffer(CHAR *pBuf, DWORD dwLen);

    // get property
    DWORD GetLength() const {  return m_dwLen; }

    DWORD GetPosition() const { return m_dwPos; }

    BOOL IsEnd() const { return m_dwPos >= m_dwLen; }

    PARSER_ERROR GetErrorCode() { return m_Error; }

    // read till white space or the end of the buffer
    BOOL ReadToken(CHAR **ppBuf, DWORD *pdwLen);

    // read token till delimit
    BOOL ReadToken(CHAR **ppBuf, DWORD *pdwLen, CHAR *pDelimit);

    // read number without sign
    BOOL ReadNumbers(CHAR **ppBuf, DWORD *pdwLen);

    BOOL ReadWhiteSpaces(DWORD *pdwLen);

    BOOL ReadChar(CHAR *pc);

    // read specific numbers
    BOOL ReadDWORD(DWORD *pdw);

    BOOL ReadUCHAR(UCHAR *puc);

    // read and compare
    BOOL CheckChar(CHAR ch);

    BOOL GetIgnoreLeadingWhiteSpace() const { return m_bIgnoreLeadingWhiteSpace; }

    VOID SetIgnoreLeadingWhiteSpace(BOOL bIgnore) { m_bIgnoreLeadingWhiteSpace = bIgnore; }

private:

    VOID Cleanup();

    // buffer, always copy the buffer
    CHAR *m_pBuf;

    // length of the buffer
    DWORD m_dwLen;

    // current position
    DWORD m_dwPos;

    BOOL m_bIgnoreLeadingWhiteSpace;

    // error code
    PARSER_ERROR m_Error;
};

//
// a very light weighted string class
//

class CString
{
private:

    // char list
	CHAR *m_p;

    // length
    DWORD m_dwLen;

    // size
    DWORD m_dwAlloc;

public:

    // constructor
    CString()
        :m_p(NULL)
        ,m_dwLen(0)
        ,m_dwAlloc(0)
	{
	}

    CString(DWORD dwAlloc);

    CString(const CHAR *p);

    CString(const CHAR *p, DWORD dwLen);

    CString(const CString& src);

    // destructor
    ~CString();

    BOOL IsNull() const
    {
        return m_p == NULL;
    }

    // operator =
    CString& operator=(const CString& src);

    CString& operator=(const CHAR *p);

    // operator +=
    CString& operator+=(const CString& src);

    CString& operator+=(const CHAR *p);

    CString& operator+=(DWORD dw);

    // operator ==

    // length
    DWORD Length() const
    {
        return m_dwLen;
    }

    // attach

    // detach
    CHAR *Detach();

    DWORD Resize(DWORD dwAlloc);

    // string print
    //int nprint(CHAR *pFormat, ...);

private:

    // append
    VOID Append(const CHAR *p, DWORD dwLen);

    VOID Append(DWORD dw);

    // replace
    VOID Replace(const CHAR *p, DWORD dwLen);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\portcache.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    PortCache.h

Abstract:

    PortCache:
        wraps port manager.
        maintains state for deciding which mapping method to use.
        manages port mapping obtained from the port manager.
        provides support for setting port mapping in registry. (debug version only)

Author(s):

    Qianbo Huai (qhuai) 08-Nov-2001

--*/

#ifndef _PORTCACHE_H
#define _PORTCACHE_H

// number of port cache
// #define PORT_CACHE_SIZE     4    // video
#define PORT_CACHE_SIZE     2

//////////////////////////////////////////////////////////////////////////////
//
// CPortCache:
//

class CPortCache
{
public:

    // ctor
    inline CPortCache();

    // dtor
    ~CPortCache();

    // initialize
    void Reinitialize();

    // change state
    void ChangeState();

    // add or remove port manager
    HRESULT SetPortManager(
        IN IRTCPortManager  *pIRTCPortManager
        );

    // check mapping method
    inline BOOL IsUpnpMapping() const;

    // get port mapping
    HRESULT GetPort(
        IN RTC_MEDIA_TYPE   MediaType,
        IN BOOL             fRTP,
        IN DWORD            dwRemoteAddr,
        OUT DWORD           *pdwLocalAddr,
        OUT USHORT          *pusLocalPort,
        OUT DWORD           *pdwMappedAddr,
        OUT USHORT          *pusMappedPort
        );

    // release port mapping
    HRESULT ReleasePort(
        IN RTC_MEDIA_TYPE   MediaType,
        IN BOOL             fRTP
        );

    // query port, do not request mapping
    HRESULT QueryPort(
        IN RTC_MEDIA_TYPE   MediaType,
        IN BOOL             fRTP,
        OUT DWORD           *pdwLocalAddr,
        OUT USHORT          *pusLocalPort,
        OUT DWORD           *pdwMappedAddr,
        OUT USHORT          *pusMappedPort
        );

protected:

    // index based on mediatype and rtp
    int GetIndex(
        IN RTC_MEDIA_TYPE   MediaType,
        IN BOOL             fRTP
        );

    // get port mapping
    HRESULT GetPort(
        IN int              iIndex,
        IN DWORD            dwRemoteAddr,
        OUT DWORD           *pdwLocalAddr,
        OUT USHORT          *pusLocalPort,
        OUT DWORD           *pdwMappedAddr,
        OUT USHORT          *pusMappedPort
        );

    // release port mapping
    HRESULT ReleasePort(
        IN int              iIndex
        );

protected:

    // -  port mapping method is needed to ensure that
    //    app can only add port manager in a certain state.
    //    i.e. when method is 'unknown'.
    // -  method transits away from 'unknown' when the call starts
    //    i.e. when stream is added or SDP accepted
    // -  port manager cannot be changed after the call starts
    // -  getport for data stream returns RTC_E_PORT_MAPPING_UNAVAILABLE.

    typedef enum PORT_MAPPING_METHOD
    {
        PMMETHOD_UNKNOWN,
        PMMETHOD_UPNP,
        PMMETHOD_APP

    } PORT_MAPPING_METHOD;

protected:

    // port manager
    IRTCPortManager             *m_pIRTCPortManager;

    // mapping method
    PORT_MAPPING_METHOD         m_PortMappingMethod;

    //
    // port cache data
    //

    // mapping cached
    BOOL                        m_fCached[PORT_CACHE_SIZE];

    RTC_PORT_TYPE               m_PortType[PORT_CACHE_SIZE];
    DWORD                       m_dwRemoteAddr[PORT_CACHE_SIZE];

    // local addr/port
    DWORD                       m_dwLocalAddr[PORT_CACHE_SIZE];
    USHORT                      m_usLocalPort[PORT_CACHE_SIZE];

    // mapped addr/port
    DWORD                       m_dwMappedAddr[PORT_CACHE_SIZE];
    USHORT                      m_usMappedPort[PORT_CACHE_SIZE];
};


//////////////////////////////////////////////////////////////////////////////
//
// inline methods
//

// ctor
inline
CPortCache::CPortCache()
    :m_pIRTCPortManager(NULL)
{
    Reinitialize();
}


// check mapping method
inline BOOL
CPortCache::IsUpnpMapping() const
{
    // the method is called to decide which mapping method to use
    // to this point, method should either be 'upnp' or 'app'
    _ASSERT(m_PortMappingMethod != PMMETHOD_UNKNOWN);

    return m_PortMappingMethod != PMMETHOD_APP;
}

//////////////////////////////////////////////////////////////////////////////
//
// convert ip to bstr, bstr to ip
//
// could move these methods to utility
//

BSTR IpToBstr(DWORD dwAddr);

DWORD BstrToIp(BSTR bstr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\qualitycontrol.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    QualityControl.cpp

Abstract:

    Implements class for controlling stream bitrate

Author(s):

    Qianbo Huai (qhuai) 7-1-2001

--*/

#include "stdafx.h"

#define GetMin(dwL, dwR) (dwL<dwR?dwL:dwR)

void CQualityControl::Initialize(
    IN CRTCMediaController *pController
    )
{
    ZeroMemory(this, sizeof(CQualityControl));

    // 
    // 1Mbs
    m_dwMaxBitrate = 1000000;

    // 50%
    m_dwTemporalSpatialTradeOff = DEFAULT_TEMPORAL_SPATIAL;

    // total limit is infinite
    m_dwLocalLimit = m_dwRemoteLimit = (DWORD)-1;
    
    m_dwSuggested = RTP_BANDWIDTH_UNDEFINED;

    m_dwAlloc = (DWORD)-1;

    // stream limit is infinite
    EnableStream(RTC_MT_AUDIO, RTC_MD_CAPTURE, FALSE);
    EnableStream(RTC_MT_AUDIO, RTC_MD_RENDER, FALSE);
    EnableStream(RTC_MT_VIDEO, RTC_MD_CAPTURE, FALSE);        
    EnableStream(RTC_MT_VIDEO, RTC_MD_RENDER, FALSE);

    m_fLossrateReported = FALSE;

    m_pMediaController = pController;
    m_pRegSetting = m_pMediaController->GetRegSetting();

}

void CQualityControl::Reinitialize()
{
    Initialize(m_pMediaController);
}


// total bitrate limit
void CQualityControl::SetBitrateLimit(
    IN DWORD dwSource,
    IN DWORD dwLimit
    )
{
    if (dwSource == LOCAL)
    {
        m_dwLocalLimit = AdjustLimitByMargin(dwLimit);

        // read max bw from registry
        DWORD dwReg = m_pRegSetting->MaxBitrate();

        if (m_dwLocalLimit/1000 > dwReg)
        {
            m_dwLocalLimit = dwReg * 1000;
        }
    }
    else
    {
        _ASSERT(dwSource == REMOTE);
        m_dwRemoteLimit = dwLimit;
    }
}

DWORD CQualityControl::GetBitrateLimit(
    IN DWORD dwSource
    )
{
    if (dwSource == LOCAL)
    {
        return m_dwLocalLimit;
    }
    else
    {
        return m_dwRemoteLimit;
    }
}

DWORD CQualityControl::GetBitrateAlloc()
{
    return m_dwAlloc;
}

#if 0
// stream bitrate
void CQualityControl::SetBitrateLimit(
    IN DWORD dwSource,
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN DWORD dwPktDuration,
    IN DWORD dwLimit
    )
{
    DWORD i = Index(MediaType, Direction);

    if (dwSource == LOCAL)
    {
        if (MediaType == RTC_MT_AUDIO)
        {
            if (dwPktDuration == 0)
                dwPktDuration = 20;

            // consider extra bandwidth from header
            m_StreamQuality[i].dwExtra = (1000/dwPktDuration) * PACKET_EXTRA_BITS;

            dwLimit += m_StreamQuality[i].dwExtra;
        }

        m_StreamQuality[i].dwLocalLimit = dwLimit;
    }
    else
    {
        _ASSERT(dwSource == REMOTE);
        m_StreamQuality[i].dwRemoteLimit = dwLimit;
    }
}

DWORD CQualityControl::GetBitrateAlloc(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    DWORD i = Index(MediaType, Direction);

    return m_StreamQuality[i].dwAlloc;
}

// return video send framerate based on bitrate
// allocated and temporalspatial tradeoff
DWORD CQualityControl::GetFramerateAlloc(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    _ASSERT(MediaType == RTC_MT_VIDEO &&
            Direction == RTC_MD_CAPTURE);

    DWORD dwFramerate = m_pRegSetting->Framerate();

    if (dwFramerate <= MAX_MAX_FRAMERATE &&
        dwFramerate >= 1)
    {
        // use registry setting
        return dwFramerate;
    }

    // allocated bitrate determines maximum framerate
    DWORD i = Index(MediaType, Direction);

    dwFramerate = m_StreamQuality[i].dwAlloc /
            BITRATE_TO_FRAMERATE_FACTOR;

    if (dwFramerate < MIN_MAX_FRAMERATE)
        dwFramerate = MIN_MAX_FRAMERATE;
    else if (dwFramerate > MAX_MAX_FRAMERATE)
        dwFramerate = MAX_MAX_FRAMERATE;

    // temporalspatial tradeoff determines desired framerate

    dwFramerate *= m_dwTemporalSpatialTradeOff;
    dwFramerate /= (MAX_TEMPORAL_SPATIAL-MIN_TEMPORAL_SPATIAL+1);

    if (dwFramerate == 0)
        dwFramerate = 1;

    return dwFramerate;
}

#endif

// bandwidth suggested from rtp
void CQualityControl::SuggestBandwidth(
    IN DWORD dwBandwidth
    )
{
    if (dwBandwidth != RTP_BANDWIDTH_UNDEFINED &&
        dwBandwidth != RTP_BANDWIDTH_NOTESTIMATED)
    {
        m_dwSuggested = AdjustSuggestionByMargin(dwBandwidth);
    }
    else
    {
        // the value might be wrong or
        // the link is really blocked
        m_dwSuggested = dwBandwidth;
    }
}

// stream in use
void CQualityControl::EnableStream(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    BOOL fInUse
    )
{
    DWORD i = Index(MediaType, Direction);

    if (!fInUse)
    {
        m_StreamQuality[i].fInUse = FALSE;

        //m_StreamQuality[i].dwLocalLimit = (DWORD)-1;
        //m_StreamQuality[i].dwRemoteLimit = (DWORD)-1;
        //m_StreamQuality[i].dwAlloc = 0;
        //m_StreamQuality[i].dwExtra = 0;
        m_StreamQuality[i].dw0LossCount = 0;
        m_StreamQuality[i].dwLossrate = 0;
    }
    else
    {
        m_StreamQuality[i].fInUse = TRUE;
    }
}

// loss rate from rtp filter
void CQualityControl::SetPacketLossRate(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    IN DWORD dwLossrate
    )
{
    //DWORD i = Index(MediaType, Direction);

    // if lossrate is too small, treat it as zero.
    // lossrate from filter is actually an average value
    if (dwLossrate <= LOSSRATE_THRESHOLD)
    {
        dwLossrate = 0;
    }

    // NOTES: update both audio send and video send

    //m_StreamQuality[i].dwLossrate = dwLossrate;
    
    //if (dwLossrate == 0)
        //m_StreamQuality[i].dw0LossCount ++;
    //else
        //m_StreamQuality[i].dw0LossCount = 0;

    //m_StreamQuality[i].dwLossrate = dwLossrate;
    
    if (m_StreamQuality[AUDSEND].fInUse)
    {
        m_StreamQuality[AUDSEND].dwLossrate = dwLossrate;

        if (dwLossrate == 0)
        {
            m_StreamQuality[AUDSEND].dw0LossCount ++;
        }
        else
        {
            m_StreamQuality[AUDSEND].dw0LossCount = 0;
        }
    }

    if (m_StreamQuality[VIDSEND].fInUse)
    {
        m_StreamQuality[VIDSEND].dwLossrate = dwLossrate;

        if (dwLossrate == 0)
        {
            m_StreamQuality[VIDSEND].dw0LossCount ++;
        }
        else
        {
            m_StreamQuality[VIDSEND].dw0LossCount = 0;
        }
    }

    m_fLossrateReported = TRUE;
}

// min of limit from local, remote, suggested, app
DWORD CQualityControl::GetEffectiveBitrateLimit()
{
    DWORD dwLimit = GetMin(m_dwLocalLimit, m_dwRemoteLimit);

    dwLimit = GetMin(dwLimit, m_dwSuggested);
    dwLimit = GetMin(dwLimit, m_dwMaxBitrate);

    return dwLimit;
}

#if 0
// adjust bitrate allocation
void CQualityControl::AdjustBitrateAlloc()
{
    DWORD dwLossrate = 0;

    HRESULT hr;

    // for modem, upload is slower than download
//#define MODEM_BW_LEAVEOUT 18000

    //DWORD dwRealLocal = m_dwLocalLimit;

    //if (dwRealLocal < CRTCCodec::LOW_BANDWIDTH_THRESHOLD)
    //{
        //if (dwRealLocal > MODEM_BW_LEAVEOUT)
        //{
            //dwRealLocal -= MODEM_BW_LEAVEOUT;
        //}
    //}

    // total limit
    DWORD dwLimit = GetEffectiveBitrateLimit();

    if (dwLimit < MIN_VIDEO_BITRATE)
        dwLimit = MIN_VIDEO_BITRATE;

    // adjust video send
    if (!m_fLossrateReported)
    {
        // stream limit

        // fix audio send limit
        if (m_StreamQuality[AUDSEND].fInUse)
        {
            m_StreamQuality[AUDSEND].dwAlloc =
                GetMin(m_StreamQuality[AUDSEND].dwLocalLimit, m_StreamQuality[AUDSEND].dwRemoteLimit);

            // should not be greater than 5M
            _ASSERT(m_StreamQuality[AUDSEND].dwAlloc < 5000000);
        }
        else
        {
            m_StreamQuality[AUDSEND].dwAlloc = 0;
        }

        // bandwidth left for video
        DWORD dwVideoBitrate = 0;

        if (m_StreamQuality[VIDSEND].fInUse)
        {
            if (dwLimit > m_StreamQuality[AUDSEND].dwAlloc)
            {
                dwVideoBitrate = dwLimit - m_StreamQuality[AUDSEND].dwAlloc;
            }

            // not enough bandwidth left for video
            if (dwVideoBitrate < MIN_VIDEO_BITRATE)
            {
                // default 16K to each video stream
                dwVideoBitrate = MIN_VIDEO_BITRATE;
            }
        }

        m_StreamQuality[VIDSEND].dwAlloc = dwVideoBitrate;

        m_dwAlloc = dwLimit;
    }
    else
    {
        // get average lossrate of send streams
        DWORD dw0LossCount = 0;
        DWORD dwCount = 0;

        if (m_StreamQuality[AUDSEND].fInUse)
        {
            dwCount ++;
            dwLossrate += m_StreamQuality[AUDSEND].dwLossrate;
            dw0LossCount += m_StreamQuality[AUDSEND].dw0LossCount;
        }

        if (m_StreamQuality[VIDSEND].fInUse)
        {
            dwCount ++;
            dwLossrate += m_StreamQuality[VIDSEND].dwLossrate;
            dw0LossCount += m_StreamQuality[VIDSEND].dw0LossCount;
        }

        if (dwCount > 1)
        {
            dwLossrate /= dwCount;
            dw0LossCount /= dwCount;
        }

        //if (dwLossrate <= LOSSRATE_THRESHOLD)
        //{
            //dwLossrate = 0;
            //dw0LossCount = 0;
        //}

        // get current total send bitrate
        DWORD dwTotalSend = 0;

        hr = m_pMediaController->GetCurrentBitrate(
            RTC_MT_AUDIO | RTC_MT_VIDEO,
            RTC_MD_CAPTURE,
            TRUE, // include header
            &dwTotalSend
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "AdjustBitrateAlloc, get bitrate. %x", hr));

            return;
        }

        // get audio send bitrate
        DWORD dwAudioSend = 0;

        hr = m_pMediaController->GetCurrentBitrate(
            RTC_MT_AUDIO,
            RTC_MD_CAPTURE,
            TRUE,
            &dwAudioSend
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "AdjustBitrateAlloc, get audio. %x", hr));

            return;
        }

        // compute lost bandwidth
        DWORD dwLost = 0;

        // compute the larger and smaller value of
        // m_dwAlloc (previous allocated bps) and dwTotalSend (current bps)
        DWORD dwLarger, dwSmaller;

        if (m_dwAlloc > dwTotalSend)
        {
            dwLarger = m_dwAlloc;
            dwSmaller = dwTotalSend;
        }
        else
        {
            dwLarger = dwTotalSend;
            dwSmaller = m_dwAlloc;
        }
        
        if (dwLossrate > 0)
        {
            // lost is positive
            dwLost = (dwLossrate * dwSmaller) / 
                     (100 * LOSS_RATE_PRECISSION);
        }
        else
        {
            if (dw0LossCount >= ZERO_LOSS_COUNT)
            {
                // should increase
                dwLost = dwLarger / BITRATE_INCREMENT_FACTOR;

                // revert zero loss count to be 0
                //m_StreamQuality[AUDSEND].dw0LossCount = 0;
                //m_StreamQuality[VIDSEND].dw0LossCount = 0;
            }
        }

        // adjust limit in m_dwAlloc
        if (dwLossrate > 0)
        {
            // must be more than 1 send streams
            _ASSERT(dwCount > 0);

            if (dwSmaller > dwLost)
            {
                // deduct lost bandwidth
                m_dwAlloc = dwSmaller-dwLost;

                if (m_dwAlloc < MIN_VIDEO_BITRATE+dwAudioSend)
                {
                    m_dwAlloc = MIN_VIDEO_BITRATE+dwAudioSend;
                }
            }
            else
            {
                m_dwAlloc = MIN_VIDEO_BITRATE+dwAudioSend;
            }
        }
        else
        {
            // increase bitrate
            m_dwAlloc = dwLarger + dwLost;

            if (m_dwAlloc < m_dwSuggested &&
                m_dwSuggested < (DWORD)-1)
            {
                // suggested value is higher, use limit value
                m_dwAlloc = dwLimit;

                // revert zero loss count to be 0
                m_StreamQuality[AUDSEND].dw0LossCount = 0;
                m_StreamQuality[VIDSEND].dw0LossCount = 0;
            }
        }

        if (m_dwAlloc > dwLimit)
            m_dwAlloc = dwLimit;

        //
        // m_dwAlloc contains total allocated bandwidth
        //

        // adjust video send = alloc - total recv - aud send
        if (m_StreamQuality[VIDSEND].fInUse)
        {
            DWORD dwVideoSend = 0;

            if (m_dwAlloc > dwAudioSend+MIN_VIDEO_BITRATE)
            {
                dwVideoSend = m_dwAlloc - dwAudioSend;
            }
            else
            {
                dwVideoSend = MIN_VIDEO_BITRATE;
            }

            m_StreamQuality[VIDSEND].dwAlloc = dwVideoSend;
        }

        // issue:
        // here is no need, right now, to update bitrate allocated for other streams
    }

    LOG((RTC_EVENT, "AdjustBitrateAlloc: Lossrate=(%d/1000)%%, Total=%u, VideoSend=%u",
        dwLossrate, m_dwAlloc, m_StreamQuality[VIDSEND].dwAlloc));
}

#endif

// Values from Core API
void CQualityControl::SetMaxBitrate(
    IN DWORD dwMaxBitrate
    )
{
    m_dwMaxBitrate = dwMaxBitrate;
}

DWORD CQualityControl::GetMaxBitrate()
{
    return m_dwMaxBitrate;
}


HRESULT CQualityControl::SetTemporalSpatialTradeOff(
    IN DWORD dwValue
    )
{
    if (dwValue > MAX_TEMPORAL_SPATIAL)
    {
        return E_INVALIDARG;
    }

    m_dwTemporalSpatialTradeOff = dwValue;

    return S_OK;
}


DWORD CQualityControl::GetTemporalSpatialTradeOff()
{
    return m_dwTemporalSpatialTradeOff;
}


// internal index for a specific stream
DWORD CQualityControl::Index(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction
)
{
    if (MediaType == RTC_MT_AUDIO)
    {
        if (Direction == RTC_MD_CAPTURE)
            return AUDSEND;
        else
            return AUDRECV;
    }
    else
    {
        if (Direction == RTC_MD_CAPTURE)
            return VIDSEND;
        else
            return VIDRECV;
    }
}

// compute total bitrate
void CQualityControl::AdjustBitrateAlloc(
    IN DWORD dwAudSendBW,
    IN DWORD dwVidSendBW
    )
{
    DWORD dwLossrate = 0;

    HRESULT hr;

    // total limit
    DWORD dwLimit = GetEffectiveBitrateLimit();

    if (dwLimit < MIN_VIDEO_BITRATE)
        dwLimit = MIN_VIDEO_BITRATE;

    // lossrate not reported
    if (!m_fLossrateReported)
    {
        m_dwAlloc = dwLimit;

        return;
    }

    // previously we use the average lossrate on send streams
    // then the problem was if the user keeps silence for a while
    // we won't receive any lossrate report on audio send stream.
    // right now, we only use the most recent lossrate reported.

    DWORD dw0LossCount = 0;
    DWORD dwCount = 0;

    if (m_StreamQuality[AUDSEND].fInUse)
    {
        dwCount ++;
        dwLossrate += m_StreamQuality[AUDSEND].dwLossrate;
        dw0LossCount += m_StreamQuality[AUDSEND].dw0LossCount;
    }
    else if (m_StreamQuality[VIDSEND].fInUse)
    {
        dwCount ++;
        dwLossrate += m_StreamQuality[VIDSEND].dwLossrate;
        dw0LossCount += m_StreamQuality[VIDSEND].dw0LossCount;
    }

    //if (dwCount > 1)
    //{
        //dwLossrate /= dwCount;
        //dw0LossCount /= dwCount;
    //}

    // compute bandwidth being lost
    DWORD dwTotalSend = dwAudSendBW+dwVidSendBW;

    DWORD dwChange = 0;

    // compute the larger and smaller value of
    // m_dwAlloc (previous allocated bps) and dwTotalSend (current bps)
    DWORD dwLarger, dwSmaller;

    if (m_dwAlloc > dwTotalSend)
    {
        dwLarger = m_dwAlloc;
        dwSmaller = dwTotalSend;
    }
    else
    {
        dwLarger = dwTotalSend;
        dwSmaller = m_dwAlloc;
    }
        
    if (dwLossrate > 0)
    {
        // lost is positive
        dwChange = (dwLossrate * dwSmaller) / 
                 (100 * LOSS_RATE_PRECISSION);
    }
    else
    {
        if (dw0LossCount >= ZERO_LOSS_COUNT)
        {
            // should increase
            dwChange = dwLarger / BITRATE_INCREMENT_FACTOR;
        }
    }

    // adjust limit in m_dwAlloc
    if (dwLossrate > 0)
    {
        // must be more than 1 send streams
        _ASSERT(dwCount > 0);

        if (dwSmaller > dwChange)
        {
            // deduct lost bandwidth
            m_dwAlloc = dwSmaller-dwChange;

            if (m_dwAlloc < MIN_VIDEO_BITRATE)
            {
                m_dwAlloc = MIN_VIDEO_BITRATE;
            }
        }
        else
        {
            m_dwAlloc = MIN_VIDEO_BITRATE;
        }
    }
    else
    {
        // increase bitrate
        m_dwAlloc = dwLarger + dwChange;

        if (dwChange > 0)
        {
            // revert zero loss count to be 0
            m_StreamQuality[AUDSEND].dw0LossCount = 0;
            m_StreamQuality[VIDSEND].dw0LossCount = 0;
        }

        if (m_dwAlloc > dwLimit)
        {
            m_dwAlloc = dwLimit;
        }
        else
        {
            if (m_dwSuggested != RTP_BANDWIDTH_NOTESTIMATED)
            {
                // bandwidth was suggested
                // increase bitrate aggressively
                dwLimit = dwLimit * 9 / 10;

                if (m_dwAlloc < dwLimit)
                {
                    m_dwAlloc = dwLimit;
                }
            }
        }
    }

    //LOG((RTC_QUALITY, "Local(bps=%d) Remote(bps=%d), App(bps=%d)",
        //m_dwLocalLimit, m_dwRemoteLimit, m_dwMaxBitrate));
}

void CQualityControl::ComputeVideoSetting(
    IN DWORD dwAudSendBW,
    IN DWORD *pdwVidSendBW,
    IN FLOAT *pdFramerate
    )
{
    // video bitrate
    if (m_dwAlloc > dwAudSendBW+MIN_VIDEO_BITRATE)
    {
        *pdwVidSendBW = m_dwAlloc-dwAudSendBW;
    }
    else
    {
        *pdwVidSendBW = MIN_VIDEO_BITRATE;
    }

    // video framerate
    FLOAT dFramerate = (FLOAT)m_pRegSetting->Framerate();

    if (dFramerate <= MAX_MAX_FRAMERATE &&
        dFramerate >= 1)
    {
        // use registry setting
        *pdFramerate = dFramerate;

        return;
    }

    dFramerate = (*pdwVidSendBW) / (FLOAT)BITRATE_TO_FRAMERATE_FACTOR;

    if (dFramerate < MIN_MAX_FRAMERATE)
        dFramerate = MIN_MAX_FRAMERATE;
    else if (dFramerate > MAX_MAX_FRAMERATE)
        dFramerate = MAX_MAX_FRAMERATE;

    // temporalspatial tradeoff determines desired framerate

    dFramerate *= m_dwTemporalSpatialTradeOff;
    dFramerate /= (MAX_TEMPORAL_SPATIAL-MIN_TEMPORAL_SPATIAL+1);

    if (dFramerate == 0)
        dFramerate = 1;

    *pdFramerate = dFramerate;
}

// adjust limit value by substracting margin
// margin bandwidth is left for other purpose, e.g. signaling
DWORD CQualityControl::AdjustLimitByMargin(
    IN DWORD dwLimit
    )
{
    _ASSERT(dwLimit != (DWORD)-1 || dwLimit != (DWORD)-2);

    // read max bw (kb) from registry
    DWORD dwMargin = m_pRegSetting->BandwidthMargin();

    if (dwMargin < dwLimit && dwMargin < dwLimit/1000)
    {
        // take registry setting
        return dwLimit - dwMargin*1000;
    }

    // bandwidth subtracted based on the factor
    dwMargin = (DWORD)(BANDWIDTH_MARGIN_FACTOR * dwLimit);

    if (dwMargin > TOTAL_BANDWIDTH_MARGIN)
    {
        dwMargin = TOTAL_BANDWIDTH_MARGIN;
    }

    dwLimit -= dwMargin;

    if (dwLimit < MIN_VIDEO_BITRATE)
    {
        dwLimit = MIN_VIDEO_BITRATE;
    }

    return dwLimit;
}

DWORD CQualityControl::AdjustSuggestionByMargin(
    IN DWORD dwLimit
    )
{
    _ASSERT(dwLimit != (DWORD)-1 || dwLimit != (DWORD)-2);

    // read max bw (kb) from registry
    DWORD dwMargin = m_pRegSetting->BandwidthMargin();

    if (dwMargin < dwLimit && dwMargin < dwLimit/1000)
    {
        // take registry setting
        return dwLimit - dwMargin*1000;
    }

    // bandwidth subtracted based on the factor
    dwMargin = (DWORD)(SUGGESTION_MARGIN_FACTOR * dwLimit);

    if (dwMargin > TOTAL_SUGGESTION_MARGIN)
    {
        dwMargin = TOTAL_SUGGESTION_MARGIN;
    }

    dwLimit -= dwMargin;

    if (dwLimit < MIN_VIDEO_BITRATE)
    {
        dwLimit = MIN_VIDEO_BITRATE;
    }

    return dwLimit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\qualitycontrol.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    QualityControl.h

Abstract:

    Defines class for controlling stream bitrate

Author(s):

    Qianbo Huai (qhuai) 7-1-2001

--*/

// assumption: there are maximum four streams, audio/video in/out

class CRTCMediaController;

class CQualityControl
{
public:

    // bitrate limit by local/remote
    static const DWORD LOCAL = 0;
    static const DWORD REMOTE = 1;

    // bitrate limit to total/stream
#define AUDSEND 0
#define AUDRECV 1
#define VIDSEND 2
#define VIDRECV 3
#define TOTAL   4

#define MIN_TEMPORAL_SPATIAL    0
#define MAX_TEMPORAL_SPATIAL    255
#define DEFAULT_TEMPORAL_SPATIAL 128

#define BITRATE_TO_FRAMERATE_FACTOR 4000.0
#define MIN_MAX_FRAMERATE 2
#define MAX_MAX_FRAMERATE 24

    static const DWORD DEFAULT_FRAMERATE = MAX_MAX_FRAMERATE/2;

#define MAX_STREAM_NUM 4
#define ZERO_LOSS_COUNT 5
#define MIN_VIDEO_BITRATE 6000      // 6k
#define MAX_VIDEO_BITRATE 125000    // 125k
#define BITRATE_INCREMENT_FACTOR 10

    // if lossrate <= 4, count as 0 loss
#define LOSSRATE_THRESHOLD 4000

    // leave 20k in total bps for other purpose
#define TOTAL_BANDWIDTH_MARGIN 20000
#define BANDWIDTH_MARGIN_FACTOR 0.4

    // leave 10k in suggested bps
#define TOTAL_SUGGESTION_MARGIN 10000
#define SUGGESTION_MARGIN_FACTOR 0.3

    // rtp 12, udp 8, ip 20
#define PACKET_EXTRA_BITS 320

    void Initialize(
        IN CRTCMediaController *pController
        );

    void Reinitialize();

    // total bitrate limit
    void SetBitrateLimit(
        IN DWORD dwSource,
        IN DWORD dwLimit
        );

    DWORD GetBitrateLimit(
        IN DWORD dwSource
        );

    DWORD GetBitrateAlloc();

    // stream bitrate
    //void SetBitrateLimit(
        //IN DWORD dwSource,
        //IN RTC_MEDIA_TYPE MediaType,
        //IN RTC_MEDIA_DIRECTION Direction,
        //IN DWORD dwPktDuration,
        //IN DWORD dwLimit
        //);

    //DWORD GetBitrateAlloc(
        //IN RTC_MEDIA_TYPE MediaType,
        //IN RTC_MEDIA_DIRECTION Direction
        //);

    //DWORD GetFramerateAlloc(
        //IN RTC_MEDIA_TYPE MediaType,
        //IN RTC_MEDIA_DIRECTION Direction
        //);

    // stream in use
    void EnableStream(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        BOOL fInUse
        );

    // loss rate from rtp filter
    void SetPacketLossRate(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        IN DWORD dwLossRate
        );

    // adjust bitrate allocation
    void AdjustBitrateAlloc(
        IN DWORD dwAudSendBW,
        IN DWORD dwVidSendBW
        );

    void ComputeVideoSetting(
        IN DWORD dwAudSendBW,
        IN DWORD *pdwVidSendBW,
        IN FLOAT *pdFramerate
        );

    // bandwidth suggested from RTP
    void SuggestBandwidth(
        IN DWORD dwSuggested
        );

    DWORD GetSuggestedBandwidth() const
    { return m_dwSuggested; }

    // Values from Core API
    void SetMaxBitrate(
        IN DWORD dwMaxBitrate
        );

    DWORD GetMaxBitrate();

    HRESULT SetTemporalSpatialTradeOff(
        IN DWORD dwValue
        );

    DWORD GetTemporalSpatialTradeOff();

    // min of limit from local, remote, suggested, app
    DWORD GetEffectiveBitrateLimit();

private:

    // internal index for a specific stream
    DWORD Index(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction
        );

    // adjust limit by subtracting margin
    DWORD AdjustLimitByMargin(
        IN DWORD dwLimit
        );

    DWORD AdjustSuggestionByMargin(
        IN DWORD dwLimit
        );

private:

    // set through Core API
    //

    // max bitrate
    DWORD   m_dwMaxBitrate;

    // frame rate / picture quality tradeoff
    DWORD   m_dwTemporalSpatialTradeOff;
        
    // local bps limit
    DWORD   m_dwLocalLimit;

    // remote bps limit
    DWORD   m_dwRemoteLimit;

    // suggest bandwidth
    DWORD   m_dwSuggested;

    // total limit
    DWORD   m_dwAlloc;

    typedef struct StreamQuality
    {
        BOOL    fInUse;
        //DWORD   dwLocalLimit;
        //DWORD   dwRemoteLimit;
        // DWORD   dwAlloc;
        DWORD   dwLossrate; // lossrate * 1000
        DWORD   dw0LossCount; // number of times when 0 lossrate
        //DWORD   dwExtra;     // extra bandwidth from header (audio only)

    } StreamQuality;

    StreamQuality m_StreamQuality[MAX_STREAM_NUM];

    // 1st loss rate reported
    BOOL    m_fLossrateReported;

    // media controller (no refcount)
    CRTCMediaController *m_pMediaController;

    CRegSetting         *m_pRegSetting;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\parser.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    Parser.cpp

Abstract:

    Parsing utility

Author(s):

    Qianbo Huai (qhuai) 27-Mar-2001

--*/

#include "stdafx.h"

//
// parsing helper
//

const CHAR * const CParser::MAX_DWORD_STRING = "4294967295";
const CHAR * const CParser::MAX_UCHAR_STRING = "255";

CParser::CParser(CHAR *pBuf, DWORD dwLen, HRESULT *phr)
    :m_pBuf(NULL)
    ,m_dwLen(0)
    ,m_dwPos(0)
    ,m_Error(PARSER_OK)
    ,m_bIgnoreLeadingWhiteSpace(TRUE)
{
    if (dwLen == 0 ||
        IsBadReadPtr(pBuf, dwLen))
        //IsBadWritePtr(phr, sizeof(HRESULT))
    {
        *phr = E_POINTER;

        return;
    }

    m_pBuf = (CHAR*)RtcAlloc(sizeof(CHAR) * dwLen);

    if (m_pBuf == NULL)
    {
        *phr = E_OUTOFMEMORY;

        return;
    }

    CopyMemory(m_pBuf, pBuf, dwLen);

    m_dwLen = dwLen;

    *phr = S_OK;
}


CParser::~CParser()
{
    Cleanup();
}

VOID
CParser::Cleanup()
{
    if (m_pBuf) RtcFree(m_pBuf);

    m_pBuf = NULL;
    m_dwLen = 0;
    m_dwPos = 0;

    m_bIgnoreLeadingWhiteSpace = TRUE;

    m_Error = PARSER_OK;
}

// read till white space or the end of the buffer
BOOL
CParser::ReadToken(CHAR **ppBuf, DWORD *pdwLen)
{
    return ReadToken(ppBuf, pdwLen, " ");
}

BOOL
CParser::ReadToken(CHAR **ppBuf, DWORD *pdwLen, CHAR *pDelimit)
{
    DWORD dwLen;

    if (m_bIgnoreLeadingWhiteSpace)
    {
        ReadWhiteSpaces(&dwLen);
    }

    DWORD dwPos = m_dwPos;

    while (!IsEnd() && !IsMember(m_pBuf[m_dwPos], pDelimit))
    {
        m_dwPos ++;
    }

    if (m_dwPos == dwPos)
    {
        return FALSE;
    }

    *ppBuf = m_pBuf + dwPos;
    *pdwLen = m_dwPos - dwPos;

    return TRUE;
}

// read number without sign
BOOL
CParser::ReadNumbers(CHAR **ppBuf, DWORD *pdwLen)
{
    DWORD dwLen;

    if (m_bIgnoreLeadingWhiteSpace)
    {
        ReadWhiteSpaces(&dwLen);
    }

    DWORD dwPos = m_dwPos;

    while (!IsEnd() && IsNumber(m_pBuf[m_dwPos]))
    {
        m_dwPos ++;
    }

    if (dwPos == m_dwPos)
    {
        return FALSE;
    }

    *ppBuf = m_pBuf + dwPos;
    *pdwLen = m_dwPos - dwPos;

    return TRUE;
}

BOOL
CParser::ReadWhiteSpaces(DWORD *pdwLen)
{
    DWORD dwPos = m_dwPos;

    while (!IsEnd() && m_pBuf[m_dwPos] == ' ')
    {
        m_dwPos ++;
    }

    *pdwLen = dwPos - m_dwPos;

    // ignore error code

    return (*pdwLen != 0);
}

BOOL
CParser::ReadChar(CHAR *pc)
{
    DWORD dwLen;

    if (m_bIgnoreLeadingWhiteSpace)
    {
        ReadWhiteSpaces(&dwLen);
    }

    if (IsEnd())
        return FALSE;

    *pc = m_pBuf[m_dwPos];

    m_dwPos ++;

    return TRUE;
}

BOOL
CParser::CheckChar(CHAR ch)
{
    CHAR x;

    if (!ReadChar(&x))
    {
        return FALSE;
    }

    return x == ch;
}

// read specific numbers
BOOL
CParser::ReadDWORD(DWORD *pdw)
{
    CHAR *pBuf = NULL;
    DWORD dwLen = 0;

    if (!ReadNumbers(&pBuf, &dwLen))
    {
        return FALSE;
    }

    _ASSERT(dwLen > 0);

    // number is too large
    if (dwLen > MAX_DWORD_STRING_LEN)
    {
        m_Error = NUMBER_OVERFLOW;
        return FALSE;
    }

    // read number
    if (Compare(pBuf, dwLen, MAX_DWORD_STRING) > 0)
    {
        m_Error = NUMBER_OVERFLOW;
        return FALSE;
    }

    DWORD dw = 0;

    for (DWORD i=0; i<dwLen; i++)
    {
        dw = dw*10 + (pBuf[i]-'0');
    }

    *pdw = dw;

    return TRUE;
}

BOOL
CParser::ReadUCHAR(UCHAR *puc)
{
    CHAR *pBuf = NULL;
    DWORD dwLen = 0;

    if (!ReadNumbers(&pBuf, &dwLen))
    {
        return FALSE;
    }

    _ASSERT(dwLen > 0);

    // number is too large
    if (dwLen > MAX_UCHAR_STRING_LEN)
    {
        m_Error = NUMBER_OVERFLOW;
        return FALSE;
    }

    // read number
    if (Compare(pBuf, dwLen, MAX_UCHAR_STRING) > 0)
    {
        m_Error = NUMBER_OVERFLOW;
        return FALSE;
    }

    UCHAR uc = 0;

    for (DWORD i=0; i<dwLen; i++)
    {
        uc = uc*10 + (pBuf[i]-'0');
    }

    *puc = uc;

    return TRUE;
}

int
CParser::Compare(CHAR *pBuf, DWORD dwLen, const CHAR * const pstr, BOOL bIgnoreCase)
{
    _ASSERT(pBuf!=NULL && pstr!=NULL);

    DWORD dw = lstrlenA(pstr);

    DWORD dwSmall = dw<dwLen?dw:dwLen;

    for (DWORD i=0; i<dwSmall; i++)
    {
        if (bIgnoreCase)
        {
            if (LowerChar(pBuf[i]) == LowerChar(pstr[i]))
            {
                continue;
            }
        }

        if (pBuf[i] < pstr[i])
        {
            return -1;
        }
        else if (pBuf[i] > pstr[i])
        {
            return 1;
        }
    }

    if (dwLen<dw)
    {
        return -1;
    }
    else if (dwLen==dw)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

CHAR
CParser::LowerChar(CHAR ch)
{
    if (ch >= 'A' && ch <= 'Z')
    {
        return ch-'A'+'a';
    }

    return ch;
}

BOOL
CParser::IsMember(CHAR ch, const CHAR * const pStr)
{
    if (pStr == NULL)
        return FALSE;

    DWORD dwLen = lstrlenA(pStr);

    for (DWORD i=0; i<dwLen; i++)
    {
        if (ch == pStr[i])
            return TRUE;
    }

    return FALSE;
}


//
// string class
//

// constructor

CString::CString(DWORD dwAlloc)
    :m_p(NULL)
    ,m_dwLen(0)
    ,m_dwAlloc(0)
{
    if (dwAlloc != 0)
    {
        m_p = (CHAR*)RtcAlloc(sizeof(CHAR)*dwAlloc);

        if (m_p != NULL)
        {
            m_dwAlloc = dwAlloc;
        }
    }
}

CString::CString(const CHAR *p)
    :m_p(NULL)
    ,m_dwLen(0)
    ,m_dwAlloc(0)
{
    if (p != NULL)
    {
        Replace(p, lstrlenA(p));
    }
}

CString::CString(const CHAR *p, DWORD dwLen)
    :m_p(NULL)
    ,m_dwLen(0)
    ,m_dwAlloc(0)
{
    if (p != NULL)
    {
        Replace(p, dwLen);
    }
}

CString::CString(const CString& src)
    :m_p(NULL)
    ,m_dwLen(0)
    ,m_dwAlloc(0)
{
    Replace(src.m_p, src.m_dwLen);
}

// destructor
CString::~CString()
{
    if (m_p != NULL)
    {
        RtcFree(m_p);
        m_p = NULL;
        m_dwLen = 0;
        m_dwAlloc = 0;
    }
}

CString&
CString::operator=(const CString& src)
{
    Replace(src.m_p, src.m_dwLen);

    return *this;
}

CString&
CString::operator=(const CHAR *p)
{
    if (p == NULL)
    {
        Replace(NULL, 0);
    }
    else
    {
        Replace(p, lstrlenA(p));
    }

    return *this;
}

// operator +=
CString&
CString::operator+=(const CString& src)
{
    Append(src.m_p, src.m_dwLen);

    return *this;
}

CString&
CString::operator+=(const CHAR *p)
{
    if (p != NULL)
    {
        Append(p, lstrlenA(p));
    }

    return *this;
}

CString&
CString::operator+=(DWORD dw)
{
    Append(dw);

    return *this;
}

// attach

// detach
CHAR *
CString::Detach()
{
    CHAR *p = m_p;

    m_p = NULL;
    m_dwLen = 0;
    m_dwAlloc = 0;

    return p;
}

DWORD
CString::Resize(DWORD dwAlloc)
{
    if (m_dwAlloc >= dwAlloc)
    {
        return m_dwAlloc;
    }

    // need to grow
    CHAR *x = (CHAR*)RtcAlloc(sizeof(CHAR)*(dwAlloc));

    if (x == NULL)
    {
        // exception?

        if (m_p)
        {
            RtcFree(m_p);
            m_p = NULL;
            m_dwLen = 0;
            m_dwAlloc = 0;
        }
        return 0;
    }

    if (m_dwLen > 0)
    {
        CopyMemory(x, m_p, m_dwLen);
        x[m_dwLen] = '\0';
    }

    if (m_p) RtcFree(m_p);

    m_p = x;
    m_dwAlloc = dwAlloc;

    return m_dwAlloc;
}

// append
VOID
CString::Append(const CHAR *p, DWORD dwLen)
{
    if (p == NULL)
        return;

    if (m_dwAlloc > m_dwLen+dwLen)
    {
        // no need to alloc
        CopyMemory(m_p+m_dwLen, p, dwLen);

        m_dwLen += dwLen;

        m_p[m_dwLen] = '\0';

        return;
    }

    // allocated space is not enough
    CHAR *x = (CHAR*)RtcAlloc(sizeof(CHAR)*(m_dwLen+dwLen+1));

    if (x == NULL)
    {
        // exception?

        if (m_p)
        {
            RtcFree(m_p);
            m_p = NULL;
            m_dwLen = 0;
            m_dwAlloc = 0;
        }
    }
    else
    {
        if (m_p != NULL)
        {
            CopyMemory(x, m_p, m_dwLen);

            RtcFree(m_p);
        }

        CopyMemory(x+m_dwLen, p, dwLen);

        m_p = x;
        m_dwLen = m_dwLen+dwLen;
        m_dwAlloc = m_dwLen+1;

        m_p[m_dwLen] = '\0';
    }
}

VOID
CString::Append(DWORD dw)
{
    if (m_dwAlloc > m_dwLen+CParser::MAX_DWORD_STRING_LEN)
    {
        // no need to alloc
        sprintf(m_p+m_dwLen, "%d", dw);

        m_dwLen = lstrlenA(m_p);

        return;
    }

    CHAR *x = (CHAR*)RtcAlloc(
                    sizeof(CHAR)*
                    (m_dwLen+CParser::MAX_DWORD_STRING_LEN+1));

    if (x == NULL)
    {
        // exception?

        if (m_p)
        {
            RtcFree(m_p);
            m_p = NULL;
            m_dwLen = 0;
            m_dwAlloc = 0;
        }
    }
    else
    {
        if (m_p != NULL)
        {
            CopyMemory(x, m_p, m_dwLen);

            RtcFree(m_p);
        }

        sprintf(x+m_dwLen, "%d", dw);

        m_p = x;
        m_dwLen = lstrlenA(m_p);
        m_dwAlloc = m_dwLen+1;
    }
}

// replace
VOID
CString::Replace(const CHAR *p, DWORD dwLen)
{
    if (m_p == p)
    {
        // what if m_dwLen != dwLen
        return;
    }

    // what if p is part of m_p

    m_dwLen = 0;
    //ZeroMemory(m_p, m_dwAlloc);

    if (p == NULL)
    {
        return;
    }

    if ((m_p != NULL && m_dwAlloc <= dwLen) ||
        m_p == NULL)
    {
        // space is not enough

        if (m_p != NULL)
        {
            RtcFree(m_p);
            m_p = NULL;
            m_dwAlloc = 0;
        }

        m_p = (CHAR*)RtcAlloc(sizeof(CHAR)*(dwLen+1));

        if (m_p == NULL)
        {
            // exception?
            return;
        }

        m_dwAlloc = dwLen+1;
    }        

    CopyMemory(m_p, p, dwLen);

    m_p[dwLen] = '\0';

    m_dwLen = dwLen;
}

// string print
/*
int
CString::nprint(CHAR *pFormat, ...)
{
    if (m_dwAlloc == 0)
    {
        return 0;
    }

    int i;

    // print
    va_list ap;
    va_start(ap, pFormat);

    i = _vsnprintf(m_p+m_dwLen, m_dwAlloc-m_dwLen-1, pFormat, ap);

    va_end(ap);

    if (i > 0)
    {
        m_dwLen = i;
    }
    else
    {
        m_dwLen = m_dwAlloc-1;

        m_p[m_dwLen] = '\0';
    }

    return i;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\portcache.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    PortCache.cpp

Abstract:

    Implement CPortCache. Refer to PortCache.h

Author(s):

    Qianbo Huai (qhuai) 08-Nov-2001

--*/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////
//
// CPortCache dtor
//

CPortCache::~CPortCache()
{
    if (m_pIRTCPortManager)
    {
        m_pIRTCPortManager->Release();
        m_pIRTCPortManager = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// Reinitialize: return to the state of just being constructed.
//

void
CPortCache::Reinitialize()
{
    ENTER_FUNCTION("CPortCache::Reinitialize");

    LOG((RTC_TRACE, "%s enter", __fxName));

    if (m_pIRTCPortManager)
    {
        HRESULT hr;

        // release mapped ports
        for (int i=0; i<PORT_CACHE_SIZE; i++)
        {
            ReleasePort(i);
        }

        m_pIRTCPortManager->Release();
    }

    ZeroMemory(this, sizeof(CPortCache));

    m_PortMappingMethod = PMMETHOD_UNKNOWN;

    // port type setting should be in-sync with GetIndex()

    m_PortType[0] = RTCPT_AUDIO_RTP;
    m_PortType[1] = RTCPT_AUDIO_RTCP;
    //m_PortType[2] = RTCPT_VIDEO_RTP;
    //m_PortType[3] = RTCPT_VIDEO_RTCP;
}


//////////////////////////////////////////////////////////////////////////////
//
// ChangeState: called when stream is added or sdp is accepted, which marks
// the beginning of a session/call. Reinitialize marks the end of a session/call
//

void
CPortCache::ChangeState()
{
    // update port mapping method 'state'
    if (m_PortMappingMethod == PMMETHOD_UNKNOWN)
    {
        if (m_pIRTCPortManager)
        {
            // use port manager in this call
            m_PortMappingMethod = PMMETHOD_APP;

            LOG((RTC_TRACE, "CPortCache method app"));
        }
        else
        {
            // use upnp mapping in this call
            m_PortMappingMethod = PMMETHOD_UPNP;

            LOG((RTC_TRACE, "CPortCache method upnp"));
        }
    }
    // else keep the current method until Reinitialize
}


//////////////////////////////////////////////////////////////////////////////
//
// SetPortManager: add or remove port manager
//

HRESULT
CPortCache::SetPortManager(
    IN IRTCPortManager  *pIRTCPortManager
    )
{
    ENTER_FUNCTION("CPortCache::SetPortManager");

    // port manager can be set only when method is unknown
    // i.e. call has not been started yet

    if (m_PortMappingMethod != PMMETHOD_UNKNOWN)
    {
        LOG((RTC_ERROR, "%s method decided %d",
            __fxName, m_PortMappingMethod));

        return RTC_E_MEDIA_CONTROLLER_STATE;
    }

    // override the previous port manager

    if (m_pIRTCPortManager != NULL)
    {
        m_pIRTCPortManager->Release();
    }

    m_pIRTCPortManager = pIRTCPortManager;

    if (m_pIRTCPortManager)
    {
        m_pIRTCPortManager->AddRef();
    }

    LOG((RTC_TRACE, "%s pm=0x%p", __fxName, pIRTCPortManager));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// GetIndex of list of cache ports
//

int
CPortCache::GetIndex(
    IN RTC_MEDIA_TYPE   MediaType,
    IN BOOL             fRTP
    )
{
    if (MediaType == RTC_MT_AUDIO)
    {
        if (fRTP)   { return 0; }
        else        { return 1; }
    }

    //if (MediaType == RTC_MT_VIDEO)
    //{
        //if (fRTP)   { return 2; }
        //else        { return 3; }
    //}

    return -1;
}


//////////////////////////////////////////////////////////////////////////////
//
// GetPort
//

HRESULT
CPortCache::GetPort(
    IN RTC_MEDIA_TYPE   MediaType,
    IN BOOL             fRTP,
    IN DWORD            dwRemoteAddr,
    OUT DWORD           *pdwLocalAddr,
    OUT USHORT          *pusLocalPort,
    OUT DWORD           *pdwMappedAddr,
    OUT USHORT          *pusMappedPort
    )
{
    ENTER_FUNCTION("CPortCache::GetPort");

    _ASSERT(m_pIRTCPortManager != NULL);

    if (m_pIRTCPortManager == NULL)
    {
        return E_UNEXPECTED;
    }

    int idx = GetIndex(MediaType, fRTP);

    if (idx == -1)
    {
        LOG((RTC_ERROR, "%s port unavailable", __fxName));

        return RTC_E_PORT_MAPPING_UNAVAILABLE;
    }

    return GetPort(
                idx,
                dwRemoteAddr,
                pdwLocalAddr,
                pusLocalPort,
                pdwMappedAddr,
                pusMappedPort
                );
}


//////////////////////////////////////////////////////////////////////////////
//
// release port mapping
//

HRESULT
CPortCache::ReleasePort(
    IN RTC_MEDIA_TYPE   MediaType,
    IN BOOL             fRTP
    )
{
    _ASSERT(m_pIRTCPortManager != NULL);

    if (m_pIRTCPortManager == NULL)
    {
        return E_UNEXPECTED;
    }

    int idx = GetIndex(MediaType, fRTP);

    if (idx == -1)
    {
        LOG((RTC_ERROR, "releaseport port unavailable"));

        return RTC_E_PORT_MAPPING_UNAVAILABLE;
    }

    return ReleasePort(idx);
}


//////////////////////////////////////////////////////////////////////////////
//
// ReleasePort
//

HRESULT
CPortCache::ReleasePort(
    IN int      i
    )
{
    ENTER_FUNCTION("CPortCache::ReleasePort");

    // make sure video support is removed
    _ASSERT(i < 2);

    if (!m_fCached[i])
    {
        return S_OK;
    }

    CComBSTR    bstrLocalAddr;
    CComBSTR    bstrMappedAddr;

    // prepare input
    bstrLocalAddr.Attach(IpToBstr(m_dwLocalAddr[i]));

    if (bstrLocalAddr.m_str == NULL)
    {
        LOG((RTC_ERROR, "%s construct local addr.", __fxName));
        return E_OUTOFMEMORY;
    }

    bstrMappedAddr.Attach(IpToBstr(m_dwMappedAddr[i]));

    if (bstrMappedAddr.m_str == NULL)
    {
        LOG((RTC_ERROR, "%s construct mapped addr.", __fxName));
        return E_OUTOFMEMORY;
    }

    // release
    HRESULT hr = m_pIRTCPortManager->ReleaseMapping(
            bstrLocalAddr,
            (long)(m_usLocalPort[i]),
            bstrMappedAddr,
            (long)(m_usMappedPort[i])
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s release mapping index=%d %x",
            __fxName, i, hr));
    }

    //
    // cleanup cache
    //

    m_fCached[i] = FALSE;
    m_dwRemoteAddr[i] = 0;
    m_dwLocalAddr[i] = 0;
    m_usLocalPort[i] = 0;
    m_dwMappedAddr[i] = 0;
    m_usMappedPort[i] = 0;

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// GetPort
//

HRESULT
CPortCache::GetPort(
    IN int              iIndex,
    IN DWORD            dwRemoteAddr,
    OUT DWORD           *pdwLocalAddr,
    OUT USHORT          *pusLocalPort,
    OUT DWORD           *pdwMappedAddr,
    OUT USHORT          *pusMappedPort
    )
{
    ENTER_FUNCTION("CPortCache::GetPort");

    // make sure video support is removed
    _ASSERT(iIndex < 2);

    CComBSTR    bstrRemoteAddr;
    CComBSTR    bstrLocalAddr;
    CComBSTR    bstrMappedAddr;

    DWORD       dwLocalAddr;
    DWORD       dwMappedAddr;
    USHORT      usLocalPort;
    long        localport;
    USHORT      usMappedPort;
    long        mappedport;

    HRESULT     hr;

    //
    // 1. check if mapping has been obtained
    // 2. check if remote addr needs to be updated
    //

    if (!m_fCached[iIndex])
    {
        //
        // get mapping
        //

        // prepare input
        bstrRemoteAddr.Attach(IpToBstr(dwRemoteAddr));

        if (bstrRemoteAddr.m_str == NULL)
        {
            LOG((RTC_ERROR, "%s construct remote addr.", __fxName));

            return E_OUTOFMEMORY;
        }

        hr = m_pIRTCPortManager->GetMapping(
                bstrRemoteAddr,         // remote
                m_PortType[iIndex],     // pt
                &bstrLocalAddr.m_str,   // local
                &localport,
                &bstrMappedAddr.m_str,  // mapped
                &mappedport
                );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s get mapping. %x", __fxName, hr));

            // we don't want to return 3rd party error code
            return RTC_E_PORT_MAPPING_FAILED;
        }

        if (localport <= 0 ||
            mappedport <= 0 ||
            localport > (long)((USHORT)-1) ||
            mappedport > (long)((USHORT)-1))
        {
            LOG((RTC_ERROR, "%s returned port local=%d mapped=%d",
                __fxName, localport, mappedport));

            return RTC_E_PORT_MAPPING_FAILED;
        }

        usLocalPort = (USHORT)localport;
        usMappedPort = (USHORT)mappedport;

        // convert returned addr, verify string ptr

        if (bstrLocalAddr.m_str == NULL ||
            bstrMappedAddr.m_str == NULL ||
            IsBadStringPtrW(bstrLocalAddr.m_str, -1) ||
            IsBadStringPtrW(bstrMappedAddr.m_str, -1))
        {
            LOG((RTC_ERROR, "%s bad ptr from getmapping", __fxName));

            return E_POINTER;
        }

        dwLocalAddr = BstrToIp(bstrLocalAddr);
        dwMappedAddr = BstrToIp(bstrMappedAddr);

        if (// dwLocalAddr == INADDR_ANY ||
            dwLocalAddr == INADDR_NONE ||
            dwMappedAddr == INADDR_ANY ||
            dwMappedAddr == INADDR_NONE)
        {
            // !!!??? should we reject local addr being 0?
            LOG((RTC_ERROR, "%s returned addr=any/none", __fxName));

            return RTC_E_PORT_MAPPING_FAILED;
        }

        //
        // mapping is good update cache
        //

        m_fCached[iIndex]       = TRUE;
        m_dwRemoteAddr[iIndex]  = dwRemoteAddr;

        m_dwLocalAddr[iIndex]   = dwLocalAddr;
        m_usLocalPort[iIndex]   = usLocalPort;

        m_dwMappedAddr[iIndex]  = dwMappedAddr;
        m_usMappedPort[iIndex]  = usMappedPort;

        // tracing

        LOG((RTC_TRACE, "%s remote=%s index=%d (NEW)",
            __fxName, CNetwork::GetIPAddrString(dwRemoteAddr), iIndex));

        LOG((RTC_TRACE, "%s  local=%s:%d",
            __fxName, CNetwork::GetIPAddrString(dwLocalAddr), usLocalPort));

        LOG((RTC_TRACE, "%s mapped=%s:%d",
            __fxName, CNetwork::GetIPAddrString(dwMappedAddr), usMappedPort));
    }
    else if (m_dwRemoteAddr[iIndex] != dwRemoteAddr)    
    {
        //
        // update remote addr
        //

        m_dwRemoteAddr[iIndex] = dwRemoteAddr;

        // prepare input
        bstrRemoteAddr.Attach(IpToBstr(dwRemoteAddr));

        if (bstrRemoteAddr.m_str == NULL)
        {
            LOG((RTC_ERROR, "%s construct remote addr.", __fxName));

            return E_OUTOFMEMORY;
        }

        bstrLocalAddr.Attach(IpToBstr(m_dwLocalAddr[iIndex]));

        if (bstrLocalAddr.m_str == NULL)
        {
            LOG((RTC_ERROR, "%s construct local addr.", __fxName));

            return E_OUTOFMEMORY;
        }

        bstrMappedAddr.Attach(IpToBstr(m_dwMappedAddr[iIndex]));

        if (bstrMappedAddr.m_str == NULL)
        {
            LOG((RTC_ERROR, "%s construct mapped addr.", __fxName));

            return E_OUTOFMEMORY;
        }

       // tracing

        LOG((RTC_TRACE, "%s remote=%s index=%d (UPDATE)", __fxName,
                CNetwork::GetIPAddrString(m_dwRemoteAddr[iIndex]),
                iIndex));

        LOG((RTC_TRACE, "%s  local=%s:%d", __fxName,
                CNetwork::GetIPAddrString(m_dwLocalAddr[iIndex]),
                m_usLocalPort[iIndex]));

        LOG((RTC_TRACE, "%s mapped=%s:%d", __fxName,
                CNetwork::GetIPAddrString(m_dwMappedAddr[iIndex]),
                m_usMappedPort[iIndex]));

        // update

        hr = m_pIRTCPortManager->UpdateRemoteAddress(
                bstrRemoteAddr,
                bstrLocalAddr,
                (long)m_usLocalPort[iIndex],
                bstrMappedAddr,
                (long)m_usMappedPort[iIndex]
                );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s update remote addr %x", __fxName, hr));

            // ignore the error
        }
    }

    // return

    if (pdwLocalAddr)   *pdwLocalAddr   = m_dwLocalAddr[iIndex];

    if (pusLocalPort)   *pusLocalPort   = m_usLocalPort[iIndex];

    if (pdwMappedAddr)  *pdwMappedAddr  = m_dwMappedAddr[iIndex];

    if (pusMappedPort)  *pusMappedPort  = m_usMappedPort[iIndex];

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// query port, do not request mapping
//

HRESULT
CPortCache::QueryPort(
    IN RTC_MEDIA_TYPE   MediaType,
    IN BOOL             fRTP,
    OUT DWORD           *pdwLocalAddr,
    OUT USHORT          *pusLocalPort,
    OUT DWORD           *pdwMappedAddr,
    OUT USHORT          *pusMappedPort
    )
{
    ENTER_FUNCTION("CPortCache::QueryPort");

    _ASSERT(m_pIRTCPortManager != NULL);

    if (m_pIRTCPortManager == NULL)
    {
        return E_UNEXPECTED;
    }

    int idx = GetIndex(MediaType, fRTP);

    if (idx == -1)
    {
        LOG((RTC_ERROR, "%s port unavailable", __fxName));

        return RTC_E_PORT_MAPPING_UNAVAILABLE;
    }

    if (!m_fCached[idx])
    {
        LOG((RTC_ERROR, "%s mt=%d rtp=%d unavailable",
            __fxName, MediaType, fRTP));

        return E_FAIL;
    }

    // return value

    if (pdwLocalAddr)   *pdwLocalAddr   = m_dwLocalAddr[idx];

    if (pusLocalPort)   *pusLocalPort   = m_usLocalPort[idx];

    if (pdwMappedAddr)  *pdwMappedAddr  = m_dwMappedAddr[idx];

    if (pusMappedPort)  *pusMappedPort  = m_usMappedPort[idx];

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
// convert ip to bstr
//

BSTR
IpToBstr(DWORD dwAddr)
{
    CComBSTR bstr = CNetwork::GetIPAddrString(dwAddr);

    return bstr.Detach();
}


//////////////////////////////////////////////////////////////////////////////
//
// convert bstr to ip
// WSAStringToAddress requires winsock 2. any means better than this?
//

DWORD
BstrToIp(BSTR bstr)
{
    // check input
    if (bstr == NULL)
    {
        return 0;
    }

    //
    // convert wchar to char
    //

    int isize = SysStringLen(bstr);

    if (isize == 0) { return 0; }

    char *pstr = (char*)RtcAlloc((isize+1) * sizeof(char));

    if (pstr == NULL)
    {
        LOG((RTC_ERROR, "BstrToIp outofmemory"));
        return 0;
    }

    WideCharToMultiByte(
        GetACP(),
        0,
        bstr,
        isize,
        pstr,
        isize+1,
        NULL,
        NULL
        );

    pstr[isize] = '\0';

    // convert address
    DWORD dwAddr = ntohl(inet_addr(pstr));

    RtcFree(pstr);

    return dwAddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\rtpformat.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    RTPFormat.h

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#ifndef _RTPFORMAT_H
#define _RTPFORMAT_H

class ATL_NO_VTABLE CRTPFormat :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IRTPFormat
{
    friend class CSDPParser;
    friend class CSDPSession;
    friend class CSDPMedia;

public:

BEGIN_COM_MAP(CRTPFormat)
    COM_INTERFACE_ENTRY(IRTPFormat)
END_COM_MAP()

public:

    CRTPFormat();
    ~CRTPFormat();

    // add ref on
    ULONG InternalAddRef();
    ULONG InternalRelease();

    //
    // IRTPFormat methods
    //

    STDMETHOD (GetMedia) (
        OUT ISDPMedia **ppMedia
        );

    STDMETHOD (GetParam) (
        OUT RTP_FORMAT_PARAM *pParam
        );

    STDMETHOD (IsParamMatch) (
        IN RTP_FORMAT_PARAM *pParam
        );

    STDMETHOD (Update) (
        IN RTP_FORMAT_PARAM *pParam
        );

    STDMETHOD (HasRtpmap) ();

    STDMETHOD (CompleteParse) (
        IN DWORD_PTR *pDTMF,
        OUT BOOL *pfDTMF
        );

    // will we support multiple fmtps in the future?
    VOID StoreFmtp(IN CHAR *psz);

    const static MAX_FMTP_LEN = 32;

protected:

    static HRESULT CreateInstance(
        IN CSDPMedia *pObjMedia,
        OUT CComObject<CRTPFormat> **ppComObjFormat
        );

    static HRESULT CreateInstance(
        IN CSDPMedia *pObjMedia,
        IN CRTPFormat *pObjFormat,
        OUT CComObject<CRTPFormat> **ppComObjFormat
        );

    ULONG RealAddRef();
    ULONG RealRelease();

protected:

    CSDPMedia                   *m_pObjMedia;

    BOOL                        m_fHasRtpmap;

    RTP_FORMAT_PARAM            m_Param;

    CHAR                        m_pszFmtp[MAX_FMTP_LEN+1];
};

#endif // _RTPFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdpmedia.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPMedia.h

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#ifndef _SDPMEDIA_H
#define _SDPMEDIA_H

class ATL_NO_VTABLE CSDPMedia :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public ISDPMedia
{
    friend class CSDPParser;
    friend class CSDPSession;

public:

BEGIN_COM_MAP(CSDPMedia)
    COM_INTERFACE_ENTRY(ISDPMedia)
END_COM_MAP()

public:

    CSDPMedia();
    ~CSDPMedia();

    // add ref on
    ULONG InternalAddRef();
    ULONG InternalRelease();

    //
    // ISDPMedia methods
    //

    STDMETHOD (GetSDPSource) (
        OUT SDP_SOURCE *pSource
        );

    STDMETHOD (GetSession) (
        OUT ISDPSession **ppSession
        );

    STDMETHOD (GetMediaType) (
        OUT RTC_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetDirections) (
        IN SDP_SOURCE Source,
        OUT DWORD *pdwDirections
        );

    STDMETHOD (AddDirections) (
        IN SDP_SOURCE Source,
        IN DWORD dwDirections
        );

    STDMETHOD (RemoveDirections) (
        IN SDP_SOURCE Source,
        IN DWORD dwDirections
        );

    STDMETHOD (GetConnAddr) (
        IN SDP_SOURCE Source,
        OUT DWORD *pdwAddr
        );

    STDMETHOD (SetConnAddr) (
        IN SDP_SOURCE Source,
        IN DWORD dwAddr
        );

    STDMETHOD (GetConnPort) (
        IN SDP_SOURCE Source,
        OUT USHORT *pusPort
        );

    STDMETHOD (SetConnPort) (
        IN SDP_SOURCE Source,
        IN USHORT usPort
        );

    STDMETHOD (GetConnRTCP) (
        IN SDP_SOURCE Source,
        OUT USHORT *pusPort
        );

    STDMETHOD (SetConnRTCP) (
        IN SDP_SOURCE Source,
        IN USHORT usPort
        );

    STDMETHOD (GetFormats) (
        IN OUT DWORD *pdwCount,
        OUT IRTPFormat **ppFormat
        );

    STDMETHOD (AddFormat) (
        IN RTP_FORMAT_PARAM *pParam,
        OUT IRTPFormat **ppFormat
        );

    STDMETHOD (RemoveFormat) (
        IN IRTPFormat *pFormat
        );

    STDMETHOD (IsConnChanged) ();
    STDMETHOD (ResetConnChanged) ();

    STDMETHOD (IsFmtChanged) (
        IN RTC_MEDIA_DIRECTION Direction
        );
    STDMETHOD (ResetFmtChanged) (
        IN RTC_MEDIA_DIRECTION Direction
        );

    STDMETHOD (Reinitialize) ();

    STDMETHOD (CompleteParse) (
        IN DWORD_PTR *pDTMF
        );

    VOID SetMappedLocalAddr(
        DWORD dwAddr
        )
    {
        m_dwMappedLocalAddr = dwAddr;
    }

    VOID SetMappedLocalRTP(
        USHORT usPort
        )
    {
        m_usMappedLocalRTP = usPort;
    }

    VOID SetMappedLocalRTCP(
        USHORT usPort
        )
    {
        m_usMappedLocalRTCP = usPort;
    }

    DWORD GetMappedLocalAddr()
    {
        return m_dwMappedLocalAddr;
    }

    USHORT GetMappedLocalRTP()
    {
        return m_usMappedLocalRTP;
    }

    USHORT GetMappedLocalRTCP()
    {
        return m_usMappedLocalRTCP;
    }

protected:

    static HRESULT CreateInstance(
        IN CSDPSession *pObjSession,
        IN SDP_SOURCE Source,
        IN RTC_MEDIA_TYPE MediaType,
        IN DWORD dwDirections,
        OUT CComObject<CSDPMedia> **ppComObjMedia
        );

    static HRESULT CreateInstance(
        IN CSDPSession *pObjSession,
        IN CSDPMedia *pObjMedia,
        OUT CComObject<CSDPMedia> **ppComObjMedia
        );

    ULONG RealAddRef();
    ULONG RealRelease();

    void Abandon();

protected:

    // sdp session
    CSDPSession                 *m_pObjSession;

    // source
    SDP_SOURCE                  m_Source;

    // m=
    RTC_MEDIA_TYPE              m_m_MediaType;

    USHORT                      m_m_usRemotePort;
    USHORT                      m_a_usRemoteRTCP;

    USHORT                      m_m_usLocalPort;

    CRTCArray<IRTPFormat*>      m_pFormats;

    // c=
    DWORD                       m_c_dwRemoteAddr;
    DWORD                       m_c_dwLocalAddr;

    // a=
    DWORD                       m_a_dwLocalDirs;
    DWORD                       m_a_dwRemoteDirs;

    // 
    BOOL                        m_fIsConnChanged;
    BOOL                        m_fIsSendFmtChanged;
    BOOL                        m_fIsRecvFmtChanged;

    // mapped address and ports
    DWORD                       m_dwMappedLocalAddr;
    USHORT                      m_usMappedLocalRTP;
    USHORT                      m_usMappedLocalRTCP;
};

#endif // _SDPMEDIA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\rtcmedia.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    rtcmedia.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "rtcmedia_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_RTCStreamController, CRTCStreamController)
END_OBJECT_MAP()


// DLL Entry Point
extern "C" BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
//        DBGRegister(_T("rtcmedia"));
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
//        DBGDeRegister();
    }
    return TRUE;    // ok
}

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

// get a class factory
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

// add entry to system reg
STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

// remove entry from system reg
STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdpmedia.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPMedia.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 29-Jul-2000

--*/

#include "stdafx.h"

static DWORD gdwTotalSDPMediaRefcountOnSession = 0;
static DWORD gdwTotalSDPMediaRealRefCount = 0;

/*//////////////////////////////////////////////////////////////////////////////
    create a media object, setup session, source, mediatype and directions
////*/

HRESULT
CSDPMedia::CreateInstance(
    IN CSDPSession *pObjSession,
    IN SDP_SOURCE Source,
    IN RTC_MEDIA_TYPE MediaType,
    IN DWORD dwDirections,
    OUT CComObject<CSDPMedia> **ppComObjMedia
    )
{
    ENTER_FUNCTION("CSDPMedia::CreateInstance 1");

    // check pointer
    if (IsBadWritePtr(ppComObjMedia, sizeof(CComObject<CSDPMedia>*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));
        return E_POINTER;
    }

    CComObject<CSDPMedia> *pObject;

    // create CSDPMedia object
    HRESULT hr = ::CreateCComObjectInstance(&pObject);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create sdp media. %x", __fxName, hr));
        return hr;
    }

    // setup
    pObject->m_pObjSession = pObjSession;

    pObject->m_Source = Source;
    pObject->m_m_MediaType = MediaType;

    if (Source == SDP_SOURCE_REMOTE)
    {
        pObject->m_a_dwRemoteDirs = dwDirections;
        pObject->m_a_dwLocalDirs = CSDPParser::ReverseDirections(dwDirections);
    }
    else
    {
        pObject->m_a_dwLocalDirs = dwDirections;
        pObject->m_a_dwRemoteDirs = CSDPParser::ReverseDirections(dwDirections);
    }

    *ppComObjMedia = pObject;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    create a media object, copy the setting from the input media object
////*/

HRESULT
CSDPMedia::CreateInstance(
    IN CSDPSession *pObjSession,
    IN CSDPMedia *pObjMedia,
    OUT CComObject<CSDPMedia> **ppComObjMedia
    )
{
    ENTER_FUNCTION("CSDPMedia::CreateInstance 2");

    // check pointer
    if (IsBadWritePtr(ppComObjMedia, sizeof(CComObject<CSDPMedia>*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));
        return E_POINTER;
    }

    CComObject<CSDPMedia> *pObject;

    // create CSDPMedia object
    HRESULT hr = ::CreateCComObjectInstance(&pObject);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create sdp media. %x", __fxName, hr));
        return hr;
    }

    // setup
    pObject->m_pObjSession = pObjSession;

    pObject->m_Source = pObjMedia->m_Source;

    // m=
    pObject->m_m_MediaType = pObjMedia->m_m_MediaType;
    pObject->m_m_usRemotePort = pObjMedia->m_m_usRemotePort;
    pObject->m_a_usRemoteRTCP = pObjMedia->m_a_usRemoteRTCP;
    pObject->m_m_usLocalPort = pObjMedia->m_m_usLocalPort;

    // c=
    pObject->m_c_dwRemoteAddr = pObjMedia->m_c_dwRemoteAddr;
    pObject->m_c_dwLocalAddr = pObjMedia->m_c_dwLocalAddr;

    // a=
    pObject->m_a_dwLocalDirs = pObjMedia->m_a_dwLocalDirs;
    pObject->m_a_dwRemoteDirs = pObjMedia->m_a_dwRemoteDirs;

    // 
    pObject->m_fIsConnChanged = pObjMedia->m_fIsConnChanged;
    pObject->m_fIsSendFmtChanged = pObjMedia->m_fIsSendFmtChanged;
    pObject->m_fIsRecvFmtChanged = pObjMedia->m_fIsRecvFmtChanged;

    // copy formats

    CRTPFormat *pTheirFormat;
    CComObject<CRTPFormat> *pComObjFormat;
    IRTPFormat *pIntfFormat;

    for (int i=0; i<pObjMedia->m_pFormats.GetSize(); i++)
    {
        // get their format object
        pTheirFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[i]);

        // new a format
        if (FAILED(hr = CRTPFormat::CreateInstance(
                (CSDPMedia*)pObject, pTheirFormat, &pComObjFormat
                )))
        {
            LOG((RTC_ERROR, "%s create format. %x", __fxName, hr));

            delete pObject;

            return hr;
        }

        // add format to the list
        pIntfFormat = static_cast<IRTPFormat*>((CRTPFormat*)pComObjFormat);

        if (!pObject->m_pFormats.Add(pIntfFormat))
        {
            LOG((RTC_ERROR, "%s add format", __fxName));

            delete pComObjFormat;
            delete pObject;

            return E_OUTOFMEMORY;
        }

        // keep the format
        pComObjFormat->RealAddRef();

        pTheirFormat = NULL;
        pComObjFormat = NULL;
        pIntfFormat = NULL;
    }

    *ppComObjMedia = pObject;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    constructor
////*/

CSDPMedia::CSDPMedia()
    :m_pObjSession(NULL)
    ,m_Source(SDP_SOURCE_REMOTE)
    ,m_m_MediaType(RTC_MT_AUDIO)
    ,m_m_usRemotePort(0)
    ,m_a_usRemoteRTCP(0)
    ,m_m_usLocalPort(0)
    ,m_c_dwRemoteAddr(INADDR_NONE)
    ,m_c_dwLocalAddr(INADDR_NONE)
    ,m_a_dwRemoteDirs(RTC_MD_CAPTURE | RTC_MD_RENDER)
    ,m_a_dwLocalDirs(RTC_MD_CAPTURE | RTC_MD_RENDER)
    ,m_fIsConnChanged(TRUE)
    ,m_fIsSendFmtChanged(TRUE)
    ,m_fIsRecvFmtChanged(TRUE)
{
}

CSDPMedia::~CSDPMedia()
{
    // abandon the media
    Abandon();

    m_pObjSession = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    add refcount on session object
////*/

ULONG
CSDPMedia::InternalAddRef()
{
    _ASSERT(m_pObjSession);

    ULONG lRef = (static_cast<ISDPSession*>(m_pObjSession))->AddRef();

    gdwTotalSDPMediaRefcountOnSession ++;

    LOG((RTC_REFCOUNT, "sdpmedia(%p) faked addref=%d on session",
        static_cast<ISDPMedia*>(this), gdwTotalSDPMediaRefcountOnSession));

    return lRef;
}

/*//////////////////////////////////////////////////////////////////////////////
    release refcount on session object
////*/

ULONG
CSDPMedia::InternalRelease()
{
    _ASSERT(m_pObjSession);

    ULONG lRef = (static_cast<ISDPSession*>(m_pObjSession))->Release();

    gdwTotalSDPMediaRefcountOnSession --;

    LOG((RTC_REFCOUNT, "sdpmedia(%p) faked release=%d on session",
        static_cast<ISDPMedia*>(this), gdwTotalSDPMediaRefcountOnSession));

    return lRef;
}

/*//////////////////////////////////////////////////////////////////////////////
    add refount on media itself
////*/

ULONG
CSDPMedia::RealAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    gdwTotalSDPMediaRealRefCount ++;

    LOG((RTC_REFCOUNT, "sdpmedia(%p) real addref=%d (total=%d)",
         static_cast<ISDPMedia*>(this), lRef, gdwTotalSDPMediaRealRefCount));

    return lRef;
}

/*//////////////////////////////////////////////////////////////////////////////
    release on media itself
////*/

ULONG
CSDPMedia::RealRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();
    
    gdwTotalSDPMediaRealRefCount --;

    LOG((RTC_REFCOUNT, "sdpmedia(%p) real release=%d (total=%d)",
         static_cast<ISDPMedia*>(this), lRef, gdwTotalSDPMediaRealRefCount));

    if (lRef == 0)
    {
        CComObject<CSDPMedia> *pComObjMedia = 
            static_cast<CComObject<CSDPMedia>*>(this);

        delete pComObjMedia;
    }

    return lRef;
}

STDMETHODIMP
CSDPMedia::GetSDPSource(
    OUT SDP_SOURCE *pSource
    )
{
    *pSource = m_Source;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::GetSession(
    OUT ISDPSession **ppSession
    )
{
    if (m_pObjSession == NULL)
        return NULL;

    ISDPSession *pSession = static_cast<ISDPSession*>(m_pObjSession);

    pSession->AddRef();

    *ppSession = pSession;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::GetMediaType(
    OUT RTC_MEDIA_TYPE *pMediaType
    )
{
    *pMediaType = m_m_MediaType;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    support querying local directions
////*/

STDMETHODIMP
CSDPMedia::GetDirections(
    IN SDP_SOURCE Source,
    OUT DWORD *pdwDirections
    )
{
    _ASSERT(Source == SDP_SOURCE_LOCAL);

    if (Source != SDP_SOURCE_LOCAL)
        return E_NOTIMPL;

    *pdwDirections = m_a_dwLocalDirs;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    add directions in sdp media. need to sync rtc media after calling this method
////*/

STDMETHODIMP
CSDPMedia::AddDirections(
    IN SDP_SOURCE Source,
    IN DWORD dwDirections
    )
{
    _ASSERT(Source == SDP_SOURCE_LOCAL);

    if (Source != SDP_SOURCE_LOCAL)
        return E_NOTIMPL;

    // check capture direction
    if (dwDirections & RTC_MD_CAPTURE)
    {
        // add capture
        if (m_a_dwLocalDirs & RTC_MD_CAPTURE)
        {
            // already have capture
        }
        else
        {
            m_a_dwLocalDirs |= RTC_MD_CAPTURE;

            if (m_a_dwLocalDirs == (DWORD)RTC_MD_CAPTURE)
                // only capture, need to update conn info
                m_fIsConnChanged = TRUE;

            m_fIsSendFmtChanged = TRUE;
        }
    }

    // check render direction
    if (dwDirections & RTC_MD_RENDER)
    {
        // add render
        if (m_a_dwLocalDirs & RTC_MD_RENDER)
        {
            // already have render
        }
        else
        {
            m_a_dwLocalDirs |= RTC_MD_RENDER;

            if (m_a_dwLocalDirs == (DWORD)RTC_MD_RENDER)
                // only render, need to update conn info
                m_fIsConnChanged = TRUE;

            m_fIsRecvFmtChanged = TRUE;
        }
    }

    m_a_dwRemoteDirs = CSDPParser::ReverseDirections(m_a_dwLocalDirs);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    remove directions from sdp media. need to sync rtc media after calling this method
////*/

STDMETHODIMP
CSDPMedia::RemoveDirections(
    IN SDP_SOURCE Source,
    IN DWORD dwDirections
    )
{
    _ASSERT(Source == SDP_SOURCE_LOCAL);

    if (Source != SDP_SOURCE_LOCAL)
        return E_NOTIMPL;

    // check capture direction
    if (dwDirections & RTC_MD_CAPTURE)
    {
        // remove capture
        if (m_a_dwLocalDirs & RTC_MD_CAPTURE)
        {
            m_a_dwLocalDirs &= RTC_MD_RENDER;
        }
        else
        {
            // no capture
        }
    }

    // check render direction
    if (dwDirections & RTC_MD_RENDER)
    {
        // remove render
        if (m_a_dwLocalDirs & RTC_MD_RENDER)
        {
            m_a_dwLocalDirs &= RTC_MD_CAPTURE;
        }
        else
        {
            // no render
        }
    }

    m_a_dwRemoteDirs = CSDPParser::ReverseDirections(m_a_dwLocalDirs);

    if (m_a_dwLocalDirs == 0)
    {
        Reinitialize();
    }

    return S_OK;
}

STDMETHODIMP
CSDPMedia::GetConnAddr(
    IN SDP_SOURCE Source,
    OUT DWORD *pdwAddr
    )
{
    if (Source == SDP_SOURCE_LOCAL)
        *pdwAddr = m_c_dwLocalAddr;
    else
        *pdwAddr = m_c_dwRemoteAddr;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::SetConnAddr(
    IN SDP_SOURCE Source,
    IN DWORD dwAddr
    )
{
    if (Source == SDP_SOURCE_LOCAL)
        m_c_dwLocalAddr = dwAddr;
    else
        m_c_dwRemoteAddr = dwAddr;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::GetConnPort(
    IN SDP_SOURCE Source,
    OUT USHORT *pusPort
    )
{
    if (Source == SDP_SOURCE_LOCAL)
        *pusPort = m_m_usLocalPort;
    else
        *pusPort = m_m_usRemotePort;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::SetConnPort(
    IN SDP_SOURCE Source,
    IN USHORT usPort
    )
{
    if (Source == SDP_SOURCE_LOCAL)
        m_m_usLocalPort = usPort;
    else
        m_m_usRemotePort = usPort;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::GetConnRTCP(
    IN SDP_SOURCE Source,
    OUT USHORT *pusPort
    )
{
    _ASSERT(Source == SDP_SOURCE_REMOTE);

    *pusPort = m_a_usRemoteRTCP;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::SetConnRTCP(
    IN SDP_SOURCE Source,
    IN USHORT usPort
    )
{
    _ASSERT(Source == SDP_SOURCE_REMOTE);

    m_a_usRemoteRTCP = usPort;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    return a list of formats. if ppFormat is NULL, return the number of formats
////*/

STDMETHODIMP
CSDPMedia::GetFormats(
    IN OUT DWORD *pdwCount,
    OUT IRTPFormat **ppFormat
    )
{
    ENTER_FUNCTION("CSDPMedia::GetFormats");

    // check pointers
    if (IsBadWritePtr(pdwCount, sizeof(DWORD)))
    {
        LOG((RTC_ERROR, "%s bad count pointer", __fxName));

        return E_POINTER;
    }

    if (ppFormat == NULL)
    {
        // caller needs the number of medias
        *pdwCount = m_pFormats.GetSize();

        return S_OK;
    }

    // how many are needed?
    if (*pdwCount == 0)
        return E_INVALIDARG;

    if (IsBadWritePtr(ppFormat, sizeof(IRTPFormat)*(*pdwCount)))
    {
        LOG((RTC_ERROR, "%s bad format pointer", __fxName));

        return E_POINTER;
    }

    // store interfaces
    DWORD dwNum = m_pFormats.GetSize();

    if (dwNum > *pdwCount)
        dwNum = *pdwCount;

    for (DWORD i=0; i<dwNum; i++)
    {
        ppFormat[i] = m_pFormats[i];

        ppFormat[i]->AddRef();
    }

    *pdwCount = dwNum;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    create a new format and add it into the list
////*/

STDMETHODIMP
CSDPMedia::AddFormat(
    IN RTP_FORMAT_PARAM *pParam,
    OUT IRTPFormat **ppFormat
    )
{
    ENTER_FUNCTION("CSDPMedia::AddFormat");

    HRESULT hr;

    // create format object
    CComObject<CRTPFormat> *pComObjFormat = NULL;

    if (FAILED(hr = CRTPFormat::CreateInstance(
            this, &pComObjFormat
            )))
    {
        LOG((RTC_ERROR, "%s create format. %x", __fxName, hr));

        return hr;
    }

    // add format to the list
    IRTPFormat *pIntfFormat = static_cast<IRTPFormat*>((CRTPFormat*)pComObjFormat);

    if (!m_pFormats.Add(pIntfFormat))
    {
        LOG((RTC_ERROR, "%s add format.", __fxName));

        delete pComObjFormat;

        return E_OUTOFMEMORY;
    }
    else
    {
        // save parameter
        pComObjFormat->Update(pParam);

        // really keep the format
        pComObjFormat->RealAddRef();
    }

    pIntfFormat->AddRef();
    *ppFormat = pIntfFormat;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    remove a format object from the list
////*/

STDMETHODIMP
CSDPMedia::RemoveFormat(
    IN IRTPFormat *pFormat
    )
{
    if (m_pFormats.Remove(pFormat))
    {
        CRTPFormat *pObjFormat = static_cast<CRTPFormat*>(pFormat);

        pObjFormat->RealRelease();

        return S_OK;
    }
    else
    {
        LOG((RTC_ERROR, "CSDPMedia::RemoveFormat %p failed.", pFormat));

        return E_FAIL;
    }
}

STDMETHODIMP
CSDPMedia::IsConnChanged()
{
    return m_fIsConnChanged?S_OK:S_FALSE;
}

STDMETHODIMP
CSDPMedia::ResetConnChanged()
{
    m_fIsConnChanged = FALSE;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::IsFmtChanged(
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    if (Direction == RTC_MD_CAPTURE)
    {
        return m_fIsSendFmtChanged?S_OK:S_FALSE;
    }
    else
    {
        return m_fIsRecvFmtChanged?S_OK:S_FALSE;
    }
}

STDMETHODIMP
CSDPMedia::ResetFmtChanged(
    IN RTC_MEDIA_DIRECTION Direction
    )
{
    if (Direction == RTC_MD_CAPTURE)
    {
        m_fIsSendFmtChanged = FALSE;
    }
    else
    {
        m_fIsRecvFmtChanged = FALSE;
    }

    return S_OK;
}

STDMETHODIMP
CSDPMedia::Reinitialize()
{
    ENTER_FUNCTION("CSDPMedia::Reinitialize");

    if (m_a_dwLocalDirs != 0)
    {
        LOG((RTC_ERROR, "%s called while stream exists. l dir=%d, r dir=%d",
            __fxName, m_a_dwLocalDirs, m_a_dwRemoteDirs));

        return E_FAIL;
    }

    Abandon();

    m_Source = SDP_SOURCE_LOCAL;

    return S_OK;
}

STDMETHODIMP
CSDPMedia::CompleteParse(
    IN DWORD_PTR *pDTMF
    )
{
    int i=0;
    BOOL fDTMF;

    while (i<m_pFormats.GetSize())
    {
        if (S_OK != m_pFormats[i]->CompleteParse(pDTMF, &fDTMF))
        {
            (static_cast<CRTPFormat*>(m_pFormats[i]))->RealRelease();
            m_pFormats.RemoveAt(i);
        }
        else
        {
            // dtmf?
            if (fDTMF)
            {
                (static_cast<CRTPFormat*>(m_pFormats[i]))->RealRelease();
                m_pFormats.RemoveAt(i);
            }
            else
            {
                // normal payload code
                i++;
            }
        }
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    the m= is not needed any more. clear direction, address, port and formats
////*/

void
CSDPMedia::Abandon()
{
    // clear connection addr and port
    m_m_usRemotePort = 0;
    m_a_usRemoteRTCP = 0;
    m_m_usLocalPort = 0;

    m_c_dwRemoteAddr = INADDR_NONE;
    m_c_dwLocalAddr = INADDR_NONE;

    // clear directions
    m_a_dwLocalDirs = 0;
    m_a_dwRemoteDirs = 0;

    // reset flags
    m_fIsConnChanged = TRUE;
    m_fIsSendFmtChanged = TRUE;
    m_fIsRecvFmtChanged = TRUE;

    // clear formats
    CRTPFormat *pObjFormat;

    for (int i=0; i<m_pFormats.GetSize(); i++)
    {
        pObjFormat = static_cast<CRTPFormat*>(m_pFormats[i]);

        pObjFormat->RealRelease();
    }

    m_pFormats.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdpparser.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPParser.h

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#ifndef _SDPPARSER_H
#define _SDPPARSER_H

//
// class CSDPParser
//
class CPortCache;

class ATL_NO_VTABLE CSDPParser :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public ISDPParser
{
public:

BEGIN_COM_MAP(CSDPParser)
    COM_INTERFACE_ENTRY(ISDPParser)
END_COM_MAP()

public:

    static HRESULT CreateInstance(
        OUT ISDPParser **ppParser
        );

    static DWORD ReverseDirections(
        IN DWORD dwDirections
        );

    CSDPParser();
    ~CSDPParser();

    //
    // ISDPParser methods
    //

    STDMETHOD (CreateSDP) (
        IN SDP_SOURCE Source,
        OUT ISDPSession **ppSession
        );

    STDMETHOD (ParseSDPBlob) (
        IN CHAR *pszText,
        IN SDP_SOURCE Source,
        // IN DWORD dwLooseMask,
        IN DWORD_PTR *pDTMF,
        OUT ISDPSession **ppSession
        );

    STDMETHOD (BuildSDPBlob) (
        IN ISDPSession *pSession,
        IN SDP_SOURCE Source,
        IN DWORD_PTR *pNetwork,
        IN DWORD_PTR *pPortCache,
        IN DWORD_PTR *pDTMF,
        OUT CHAR **ppszText
        );

    STDMETHOD (BuildSDPOption) (
        IN ISDPSession *pSession,
        IN DWORD dwLocalIP,
        IN DWORD dwBandwidth,
        IN DWORD dwAudioDir,
        IN DWORD dwVideoDir,
        OUT CHAR **ppszText
        );

    STDMETHOD (FreeSDPBlob) (
        IN CHAR *pszText
        );

    STDMETHOD (GetParsingError) (
        OUT CHAR **ppszError
        );

    STDMETHOD (FreeParsingError) (
        IN CHAR *pszError
        );

protected:

    HRESULT PrepareAddress();

    DWORD GetLooseMask();
    HRESULT IsMaskEnabled(
        IN const CHAR * const pszName
        );

    HRESULT Parse();

    HRESULT Parse_v();
    HRESULT Build_v(
        OUT CString& Str
        );

    HRESULT Parse_o();
    HRESULT Build_o(
        OUT CString& Str
        );

    HRESULT Parse_s();
    HRESULT Build_s(
        OUT CString& Str
        );

    HRESULT Parse_c(
        IN BOOL fSession
        );
    HRESULT Build_c(
        IN BOOL fSession,
        IN ISDPMedia *pISDPMedia,
        OUT CString& Str
        );

    HRESULT Parse_b();

    HRESULT Build_b(
        OUT CString& Str
        );

    HRESULT Build_t(
        OUT CString& Str
        );

    HRESULT Parse_a();
    HRESULT Build_a(
        OUT CString& Str
        );

    HRESULT Parse_m();
    HRESULT Build_m(
        IN ISDPMedia *pISDPMedia,
        OUT CString& Str
        );

    HRESULT Parse_ma(
        //IN DWORD *pdwRTPMapNum
        );

    HRESULT Build_ma_dir(
        IN ISDPMedia *pISDPMedia,
        OUT CString& Str
        );

    HRESULT Build_ma_rtpmap(
        IN ISDPMedia *pISDPMedia,
        OUT CString& Str
        );

protected:

    // parser in use
    BOOL                            m_fInUse;

    // reg key
    HKEY                            m_hRegKey;

    // token cache
    CSDPTokenCache                  *m_pTokenCache;

    // sdp session
    ISDPSession                     *m_pSession;

    CSDPSession                     *m_pObjSess;

    // network for NAT traversal
    CNetwork                        *m_pNetwork;

    // DTMF for out-of-band dtmf
    CRTCDTMF                        *m_pDTMF;

    // port manager
    CPortCache                      *m_pPortCache;
};

#endif // _SDPPARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\rtpformat.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    RTPFormat.cpp

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#include "stdafx.h"

static DWORD gdwTotalRTPFormatRefcountOnSession = 0;
static DWORD gdwTotalRTPFormatRealRefCount = 0;

/*//////////////////////////////////////////////////////////////////////////////
    create a format object
////*/

HRESULT
CRTPFormat::CreateInstance(
    IN CSDPMedia *pObjMedia,
    OUT CComObject<CRTPFormat> **ppComObjFormat
    )
{
    ENTER_FUNCTION("CRTPFormat::CreateInstance 1");

    // check pointer
    if (IsBadWritePtr(ppComObjFormat, sizeof(CComObject<CRTPFormat>*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    CComObject<CRTPFormat> *pObject;

    // create format object
    HRESULT hr = ::CreateCComObjectInstance(&pObject);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create format. %x", __fxName, hr));

        return hr;
    }

    // setup
    pObject->m_pObjMedia = pObjMedia;

    *ppComObjFormat = pObject;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    create a format object, copy settings from input format object
////*/

HRESULT
CRTPFormat::CreateInstance(
    IN CSDPMedia *pObjMedia,
    IN CRTPFormat *pObjFormat,
    OUT CComObject<CRTPFormat> **ppComObjFormat
    )
{
    ENTER_FUNCTION("CRTPFormat::CreateInstance 1");

    // check pointer
    if (IsBadWritePtr(ppComObjFormat, sizeof(CComObject<CRTPFormat>*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    // check media type
    RTC_MEDIA_TYPE MediaType;

    pObjMedia->GetMediaType(&MediaType);

    if (MediaType != pObjFormat->m_Param.MediaType)
    {
        LOG((RTC_ERROR, "%s media type not match", __fxName));

        return E_UNEXPECTED;
    }

    CComObject<CRTPFormat> *pObject;

    // create format object
    HRESULT hr = ::CreateCComObjectInstance(&pObject);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create format. %x", __fxName, hr));

        return hr;
    }

    // setup
    pObject->m_pObjMedia = pObjMedia;

    pObject->m_Param.MediaType = MediaType;
    pObject->m_Param.dwCode = pObjFormat->m_Param.dwCode;

    pObject->Update(&pObjFormat->m_Param);

    *ppComObjFormat = pObject;

    return S_OK;
}

CRTPFormat::CRTPFormat()
:m_pObjMedia(NULL)
,m_fHasRtpmap(FALSE)
{
    ZeroMemory(&m_Param, sizeof(RTP_FORMAT_PARAM));

    m_Param.dwCode = (DWORD)(-1);

    // init video and audio default setting
    m_Param.dwVidWidth = SDP_DEFAULT_VIDEO_WIDTH;
    m_Param.dwVidHeight = SDP_DEFAULT_VIDEO_HEIGHT;
    m_Param.dwAudPktSize = SDP_DEFAULT_AUDIO_PACKET_SIZE;

    m_Param.dwChannelNum = 1;

    m_pszFmtp[0] = '\0';
}

CRTPFormat::~CRTPFormat()
{
    m_pObjMedia = NULL;
}

/*//////////////////////////////////////////////////////////////////////////////
    add refcount on session object
////*/

ULONG
CRTPFormat::InternalAddRef()
{
    _ASSERT(m_pObjMedia);

    ULONG lRef = (static_cast<ISDPMedia*>(m_pObjMedia))->AddRef();

    gdwTotalRTPFormatRefcountOnSession ++;

    LOG((RTC_REFCOUNT, "rtpformat(%p) faked addref=%d on session",
        static_cast<IRTPFormat*>(this), gdwTotalRTPFormatRefcountOnSession));

    return lRef;
}

/*//////////////////////////////////////////////////////////////////////////////
    release refcount on session object
////*/

ULONG
CRTPFormat::InternalRelease()
{
    _ASSERT(m_pObjMedia);

    ULONG lRef = (static_cast<ISDPMedia*>(m_pObjMedia))->Release();

    gdwTotalRTPFormatRefcountOnSession --;

    LOG((RTC_REFCOUNT, "rtpformat(%p) faked release=%d on session",
        static_cast<IRTPFormat*>(this), gdwTotalRTPFormatRefcountOnSession));

    return lRef;
}

/*//////////////////////////////////////////////////////////////////////////////
    add refount on format itself
////*/

ULONG
CRTPFormat::RealAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    gdwTotalRTPFormatRealRefCount ++;

    LOG((RTC_REFCOUNT, "rtpformat(%p) real addref=%d (total=%d)",
         static_cast<IRTPFormat*>(this), lRef, gdwTotalRTPFormatRealRefCount));

    return lRef;
}

/*//////////////////////////////////////////////////////////////////////////////
    release on format itself
////*/

ULONG
CRTPFormat::RealRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();
    
    gdwTotalRTPFormatRealRefCount --;

    LOG((RTC_REFCOUNT, "rtpformat(%p) real release=%d (total=%d)",
         static_cast<IRTPFormat*>(this), lRef, gdwTotalRTPFormatRealRefCount));

    if (lRef == 0)
    {
        CComObject<CRTPFormat> *pComObjFormat = 
            static_cast<CComObject<CRTPFormat>*>(this);

        delete pComObjFormat;
    }

    return lRef;
}

//
// IRTPFormat methods
//

STDMETHODIMP
CRTPFormat::GetMedia(
    OUT ISDPMedia **ppMedia
    )
{
    if (m_pObjMedia == NULL)
        return NULL;

    ISDPMedia *pMedia = static_cast<ISDPMedia*>(m_pObjMedia);

    pMedia->AddRef();

    *ppMedia = pMedia;

    return S_OK;
}

STDMETHODIMP
CRTPFormat::GetParam(
    OUT RTP_FORMAT_PARAM *pParam
    )
{
    *pParam = m_Param;

    return S_OK;
}

STDMETHODIMP
CRTPFormat::IsParamMatch(
    IN RTP_FORMAT_PARAM *pParam
    )
{
    // format not set yet
    if (m_Param.dwCode == (DWORD)(-1))
        return S_OK;

    // check format code and media type
    if (m_Param.dwCode != pParam->dwCode)
        return S_FALSE;

    if (m_Param.MediaType != pParam->MediaType)
        return S_FALSE;

    // check if having rtpmap
    if (!m_fHasRtpmap)
    {
        return S_OK;
    }

    // check if other parameters match
    if (m_Param.dwSampleRate != pParam->dwSampleRate ||
        m_Param.dwChannelNum != pParam->dwChannelNum)
        return S_FALSE;

    if (m_Param.MediaType == RTC_MT_VIDEO)
    {
        /*
        if (m_Param.dwVidWidth != pParam->dwVidWidth ||
            m_Param.dwVidHeight != pParam->dwVidHeight)
            return S_FALSE;
            */
    }
    else
    {
        if (m_Param.dwAudPktSize != pParam->dwAudPktSize)
        {
            // change packet size

            LOG((RTC_WARN, "packet size %d & %d does not match",
                m_Param.dwAudPktSize, pParam->dwAudPktSize
                ));

            return S_OK;
        }
    }

    return S_OK;
}

STDMETHODIMP
CRTPFormat::Update(
    IN RTP_FORMAT_PARAM *pParam
    )
{
    CHAR pszName[SDP_MAX_RTP_FORMAT_NAME_LEN+1];

    // if format not match, should not update
    if (IsParamMatch(pParam) != S_OK)
    {
        LOG((RTC_ERROR, "CRTPFormat::Update format not match"));

        return E_FAIL;
    }

    // save previous name
    lstrcpyA(pszName, m_Param.pszName);

    m_Param = *pParam;

    if (lstrlenA(m_Param.pszName) == 0)
    {
        if (lstrlenA(pszName) != 0)
        {
            // restore previous name
            lstrcpyA(m_Param.pszName, pszName);
        }
        else
        {
            // both formats do not have a name
            // try to find one
            lstrcpyA(m_Param.pszName, GetFormatName(m_Param.dwCode));
        }
    }

    // do we have rtpmap?
    if (m_Param.dwSampleRate > 0)
        m_fHasRtpmap = TRUE;
    else
        m_fHasRtpmap = FALSE;

    return S_OK;
}

STDMETHODIMP
CRTPFormat::HasRtpmap()
{
    return m_fHasRtpmap?S_OK:S_FALSE;
}

STDMETHODIMP
CRTPFormat::CompleteParse(
    IN DWORD_PTR *pDTMF,
    OUT BOOL *pfDTMF
    )
{
    // parse a=fmtp:xxx name=xxxxx

    // check format map

    HRESULT hr = S_OK;
    *pfDTMF = FALSE;

    if (m_pszFmtp[0] == '\0')
    {
        return S_OK;
    }

    CParser Parser(m_pszFmtp, lstrlenA(m_pszFmtp), &hr);

    DWORD dwLen;
    CHAR *pBuf;
    UCHAR uc;
    DWORD dw;

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "CompleteParse, %x", hr));

        goto Cleanup;
    }

    // read fmtp
    if (!Parser.ReadToken(&pBuf, &dwLen, " :"))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (Parser.Compare(pBuf, dwLen, "fmtp", TRUE) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // check :
    if (!Parser.CheckChar(':'))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // read code
    if (!Parser.ReadUCHAR(&uc))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if ((DWORD)uc != m_Param.dwCode)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // check if telephone-event
    if (pDTMF != NULL)
    {
        if (m_Param.MediaType == RTC_MT_AUDIO &&
            m_Param.dwSampleRate == 8000 &&
            lstrcmpiA(m_Param.pszName, "telephone-event") == 0)
        {
            CRTCDTMF *pObject = (CRTCDTMF*)pDTMF;

            // set dtmf support
            pObject->SetDTMFSupport(CRTCDTMF::DTMF_ENABLED);
            pObject->SetRTPCode(m_Param.dwCode);

            *pfDTMF = TRUE;

            goto Cleanup;
        }
    }

    if (!Parser.ReadWhiteSpaces(&dwLen) || dwLen == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // read bitrate string
    if (!Parser.ReadToken(&pBuf, &dwLen, " ="))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (Parser.Compare(pBuf, dwLen, "bitrate", TRUE) != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // read =
    if (!Parser.CheckChar('='))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // read bitrate value
    if (!Parser.ReadDWORD(&dw))
    {
        hr = E_FAIL;

        LOG((RTC_ERROR, "RTPFormat cannot accept bitrate=%d",dw));
        return hr;
    }

    // we really need to design one class for each type of codec
    // it's just too risky to change now.

    if (Parser.Compare(m_Param.pszName, lstrlenA(m_Param.pszName), "SIREN", TRUE) == 0)
    {
        // only accept 16k for siren
        if (dw != 16000)
        {
            LOG((RTC_ERROR, "RTPFormat cannot accept bitrate=%d",dw));
            return E_FAIL;
        }
    }
    else if(Parser.Compare(m_Param.pszName, lstrlenA(m_Param.pszName), "G7221", TRUE) == 0)
    {
        // only accept 24k for g7221
        if (dw != 24000)
        {
            LOG((RTC_ERROR, "RTPFormat cannot accept bitrate=%d",dw));
            return E_FAIL;
        }
    }
    else
    {
        LOG((RTC_ERROR, "RTPFormat cannot accept bitrate for %s", m_Param.pszName));
        return E_FAIL;
    }

Cleanup:

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "RTPFormat doesn't recognize %s", m_pszFmtp));
    }

    m_pszFmtp[0] = '\0';

    return S_OK;
}

VOID
CRTPFormat::StoreFmtp(IN CHAR *psz)
{
    if (psz == NULL || lstrlenA(psz) > MAX_FMTP_LEN)
    {
        // fmtp too long
        return;
    }

    // save
    lstrcpyA(m_pszFmtp, psz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdpparser.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPParser.cpp

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#include "stdafx.h"

static const CHAR * CRLF = "\r\n";

/*//////////////////////////////////////////////////////////////////////////////
    Create a CSDPParser object. return interface pointer
////*/

HRESULT
CSDPParser::CreateInstance(
    OUT ISDPParser **ppParser
    )
{
    ENTER_FUNCTION("CSDPParser::CreateInstance");

    // check pointer
    if (IsBadWritePtr(ppParser, sizeof(ISDPParser*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));
        return E_POINTER;
    }

    CComObject<CSDPParser> *pObject;
    ISDPParser *pParser = NULL;

    // create CSDPParser object
    HRESULT hr = ::CreateCComObjectInstance(&pObject);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create sdp parser. %x", __fxName, hr));
        return hr;
    }

    // QI ISDPParser interface
    if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(ISDPParser), (void**)&pParser)))
    {
        LOG((RTC_ERROR, "%s QI parser. %x", __fxName, hr));

        delete pObject;
        return hr;
    }

    *ppParser = pParser;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    given media directions at one end point, return the media directions
    base the view of the other end point
////*/

DWORD
CSDPParser::ReverseDirections(
    IN DWORD dwDirections
    )
{
    DWORD dw = 0;

    if (dwDirections & RTC_MD_RENDER)
        dw |= RTC_MD_CAPTURE;

    if (dwDirections & RTC_MD_CAPTURE)
        dw |= RTC_MD_RENDER;

    return dw;
}

CSDPParser::CSDPParser()
    :m_fInUse(FALSE)
    ,m_hRegKey(NULL)
    ,m_pTokenCache(NULL)
    ,m_pSession(NULL)
    ,m_pObjSess(NULL)
    ,m_pNetwork(NULL)
    ,m_pDTMF(NULL)
    ,m_pPortCache(NULL)
{
    LOG((RTC_TRACE, "CSDPParser::CSDPParser entered"));
}

CSDPParser::~CSDPParser()
{
    LOG((RTC_TRACE, "CSDPParser::~CSDPParser entered"));

    if (m_pTokenCache)
        delete m_pTokenCache;

    if (m_pSession)
        m_pSession->Release();

    if (m_hRegKey)
        RegCloseKey(m_hRegKey);
}

//
// ISDPParser methods
//

/*//////////////////////////////////////////////////////////////////////////////
    Create a CSDPSession object and return an interface
////*/

STDMETHODIMP
CSDPParser::CreateSDP(
    IN SDP_SOURCE Source,
    OUT ISDPSession **ppSession
    )
{
    ENTER_FUNCTION("CSDPParser::CreateSDP");

    // only create local sdp session
    if (Source != SDP_SOURCE_LOCAL)
        return E_NOTIMPL;

    // check pointer
    if (IsBadWritePtr(ppSession, sizeof(ISDPSession*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    // create session
    ISDPSession *pSession = NULL;

    DWORD dwLooseMask = GetLooseMask();

    HRESULT hr = CSDPSession::CreateInstance(Source, dwLooseMask, &pSession);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create sdp session. %x", __fxName, hr));

        return hr;
    }

    *ppSession = pSession;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    Parse the sdp blob, store data in sdp session object
////*/

STDMETHODIMP
CSDPParser::ParseSDPBlob(
    IN CHAR *pszText,
    IN SDP_SOURCE Source,
//    IN DWORD dwLooseMask,
    IN DWORD_PTR *pDTMF,
    OUT ISDPSession **ppSession
    )
{
    ENTER_FUNCTION("CSDPParser::ParseSDPBlob");

    // check state
    if (m_fInUse)
    {
        LOG((RTC_ERROR, "%s in use", __fxName));

        return E_UNEXPECTED;
    }

    // only parser remote sdp blob
    if (Source != SDP_SOURCE_REMOTE)
        return E_NOTIMPL;

    // check pointer
    if (IsBadStringPtrA(pszText, (UINT_PTR)-1) ||
        IsBadWritePtr(ppSession, sizeof(ISDPSession*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    // print out sdp blob
    LOG((RTC_TRACE, "%s SDP to parse:\n%s\n", __fxName, pszText));

    // get loose mask from registry
    DWORD dwLooseMask = GetLooseMask();

    // create sdp session
    HRESULT hr = CSDPSession::CreateInstance(Source, dwLooseMask, &m_pSession);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create sdp session. %x", __fxName, hr));

        return hr;
    }

    // save an object copy
    m_pObjSess = static_cast<CSDPSession*>(m_pSession);
    if (m_pObjSess == NULL)
    {
        LOG((RTC_ERROR, "%s cast ISDPSession to CSDPSession", __fxName));

        m_pSession->Release();
        m_pSession = NULL;

        return E_UNEXPECTED;
    }

    // create token cache
    m_pTokenCache = new CSDPTokenCache(pszText, dwLooseMask, &hr);

    if (m_pTokenCache == NULL)
    {
        LOG((RTC_ERROR, "%s out of memory", __fxName));

        m_pSession->Release();
        m_pSession = NULL;
        m_pObjSess = NULL;

        return E_OUTOFMEMORY;
    }

    // both session and token cache are created.
    // consider all error beyond this pointer as parsing error

    m_fInUse = TRUE;

    // failed to break the sdp blob into lines?
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s new token cache. %x", __fxName, hr));

        m_pSession->Release();
        m_pSession = NULL;
        m_pObjSess = NULL;

        return hr;
    }

    m_pDTMF = (CRTCDTMF*)pDTMF;

    // really parse the sdp
    if (FAILED(hr = Parse()))
    {
        LOG((RTC_ERROR, "%s parse sdp blob. %x", __fxName, hr));

        return hr;
    }

    *ppSession = m_pSession;
    (*ppSession)->AddRef();

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    generate sdp blob
////*/

STDMETHODIMP
CSDPParser::BuildSDPBlob(
    IN ISDPSession *pSession,
    IN SDP_SOURCE Source,
    IN DWORD_PTR *pNetwork,
    IN DWORD_PTR *pPortCache,
    IN DWORD_PTR *pDTMF,
    OUT CHAR **ppszText
    )
{
    ENTER_FUNCTION("CSDPParser::BuildSDPBlob");

    if (m_fInUse)
    {
        LOG((RTC_ERROR, "%s in use", __fxName));

        return E_UNEXPECTED;
    }

    // get session object
    if (IsBadReadPtr(pSession, sizeof(ISDPSession)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    m_pNetwork = (CNetwork*)(pNetwork);
    m_pPortCache = (CPortCache*)(pPortCache);
    m_pDTMF = (CRTCDTMF*)pDTMF;
    m_pSession = pSession;
    m_pSession->AddRef();

    m_pObjSess = static_cast<CSDPSession*>(pSession);

    if (m_pObjSess == NULL)
    {
        LOG((RTC_ERROR, "%s static_cast", __fxName));

        return E_FAIL;
    }

    // TODO implement methods to build sdp string on session, media, format
    HRESULT hr = S_OK;

    CSDPMedia *pObjMedia;

    CString psz(80);

    CString pszSDP(600);

    // prepare session and media address
    if (FAILED(hr = PrepareAddress()))
    {
        return hr;
    }

    // build session information
    if (FAILED(hr = Build_v(psz)))
    {
        return hr;
    }
    pszSDP = psz; pszSDP += CRLF;

    if (FAILED(hr = Build_o(psz)))
    {
        return hr;
    }
    pszSDP += psz; pszSDP += CRLF;

    if (FAILED(hr = Build_s(psz)))
    {
        return hr;
    }
    pszSDP += psz; pszSDP += CRLF;

    if (FAILED(hr = Build_c(TRUE, NULL, psz)))
    {
        return hr;
    }
    if (psz.Length()>0)
    {
        pszSDP += psz; pszSDP += CRLF;
    }

    // build b=
    if (FAILED(hr = Build_b(psz)))
    {
        return hr;
    }
    if (psz.Length()>0)
    {
        pszSDP += psz; pszSDP += CRLF;
    }

    if (FAILED(hr = Build_t(psz)))
    {
        return hr;
    }
    pszSDP += psz; pszSDP += CRLF;

    if (FAILED(hr = Build_a(psz)))
    {
        return hr;
    }
    if (psz.Length()>0)
    {
        pszSDP += psz; pszSDP += CRLF;
    }

    // build media information
    DWORD dwMediaNum = m_pObjSess->m_pMedias.GetSize();

    // gather media info
    for (DWORD i=0; i<dwMediaNum; i++)
    {
        RTC_MEDIA_TYPE          mt;
    
        // for each media
        if (FAILED(hr = Build_m(m_pObjSess->m_pMedias[i], psz)))
        {
            return hr;
        }

        pszSDP += psz; pszSDP += CRLF;

        pObjMedia = static_cast<CSDPMedia*>(m_pObjSess->m_pMedias[i]);

        // no need to build c=, a= if port is zero
        if (pObjMedia->m_m_usLocalPort == 0)
        {
            continue;
        }

        if (FAILED(hr = Build_c(FALSE, m_pObjSess->m_pMedias[i], psz)))
        {
            return hr;
        }
        if (psz.Length()>0)
        {
            pszSDP += psz; pszSDP += CRLF;
        }

        if (FAILED(hr = Build_ma_dir(m_pObjSess->m_pMedias[i], psz)))
        {
            return hr;
        }
        if (psz.Length()>0)
        {
            pszSDP += psz; pszSDP += CRLF;
        }

        if (m_pObjSess->m_pMedias[i]->GetMediaType (&mt) == S_OK &&
            mt != RTC_MT_DATA)
        {
            if (FAILED(hr = Build_ma_rtpmap(m_pObjSess->m_pMedias[i], psz)))
            {
                return hr;
            }
            if (psz.Length()>0)
            {
                pszSDP += psz; pszSDP += CRLF;
            }
        }
    }

    // copy data
    if (pszSDP.IsNull())
    {
        return E_OUTOFMEMORY;
    }

    *ppszText = pszSDP.Detach();

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    generate sdp option
////*/

STDMETHODIMP
CSDPParser::BuildSDPOption(
    IN ISDPSession *pSession,
    IN DWORD dwLocalIP,
    IN DWORD dwBandwidth,
    IN DWORD dwAudioDir,
    IN DWORD dwVideoDir,
    OUT CHAR **ppszText
    )
{
    ENTER_FUNCTION("CSDPParser::BuildSDPOption");

    // get session object
    if (IsBadReadPtr(pSession, sizeof(ISDPSession)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    m_pSession = pSession;
    m_pSession->AddRef();

    m_pObjSess = static_cast<CSDPSession*>(pSession);
    m_pObjSess->m_c_dwLocalAddr = dwLocalIP;
    m_pObjSess->m_o_dwLocalAddr = dwLocalIP;
    m_pObjSess->m_b_dwLocalBitrate = dwBandwidth;

    if (m_pObjSess == NULL)
    {
        LOG((RTC_ERROR, "%s static_cast", __fxName));

        return E_FAIL;
    }

    // TODO implement methods to build sdp string on session, media, format
    HRESULT hr = S_OK;

    DWORD dwSDPLen;

    CString psz(50);
    CString pszSDP(300);

    // build session information
    if (FAILED(hr = Build_v(psz)))
    {
        return hr;
    }
    pszSDP = psz;     pszSDP += CRLF;

    if (FAILED(hr = Build_o(psz)))
    {
        return hr;
    }
    pszSDP += psz;     pszSDP += CRLF;

    if (FAILED(hr = Build_s(psz)))
    {
        return hr;
    }
    pszSDP += psz;     pszSDP += CRLF;

    if (FAILED(hr = Build_c(TRUE, NULL, psz)))
    {
        return hr;
    }
    if (psz.Length()>0)
    {
        pszSDP += psz;     pszSDP += CRLF;
    }

    // b= line
    if (FAILED(hr = Build_b(psz)))
    {
        return hr;
    }
    if (psz.Length()>0)
    {
        pszSDP += psz;     pszSDP += CRLF;
    }

    if (FAILED(hr = Build_t(psz)))
    {
        return hr;
    }
    pszSDP += psz;     pszSDP += CRLF;

    // build media information
    // right now, video filter cann't provide its capabilities unless it's been connected
    // we hardcode the options in sdptable.cpp where we also keep mapping from payload to name

    // build the whole sdp

    if (dwAudioDir != 0)
    {
        // build m=audio
        pszSDP += g_pszAudioM;

        if ((dwAudioDir & RTC_MD_CAPTURE) && !(dwAudioDir & RTC_MD_RENDER))
        {
            // send only
            pszSDP += "a=sendonly\r\n";
        }
        else if (!(dwAudioDir & RTC_MD_CAPTURE) && (dwAudioDir & RTC_MD_RENDER))
        {
            // recv only
            pszSDP += "a=recvonly\r\n";
        }

        pszSDP += g_pszAudioRTPMAP;
    }

    if (dwVideoDir != 0)
    {
        // build m=video
        pszSDP += g_pszVideoM;

        if ((dwVideoDir & RTC_MD_CAPTURE) && !(dwVideoDir & RTC_MD_RENDER))
        {
            // send only
            pszSDP += "a=sendonly\r\n";
        }
        else if (!(dwVideoDir & RTC_MD_CAPTURE) && (dwVideoDir & RTC_MD_RENDER))
        {
            // recv only
            pszSDP += "a=recvonly\r\n";
        }

        pszSDP += g_pszVideoRTPMAP;
    }

    pszSDP += g_pszDataM;

    if (pszSDP.IsNull())
        return E_OUTOFMEMORY;

    *ppszText = pszSDP.Detach();

    return S_OK;
}

STDMETHODIMP
CSDPParser::FreeSDPBlob(
    IN CHAR *pszText
    )
{
    if (IsBadStringPtrA(pszText, (UINT_PTR)-1))
    {
        LOG((RTC_ERROR, "CSDPParser::FreeSDPBlob bad pointer"));
        return E_POINTER;
    }

    RtcFree(pszText);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    get description of parsing error
////*/

STDMETHODIMP
CSDPParser::GetParsingError(
    OUT CHAR **ppszError
    )
{
    ENTER_FUNCTION("CSDPParser::GetParsingError");

    // check state
    if (!m_fInUse)
    {
        LOG((RTC_ERROR, "%s not in use", __fxName));

        return E_UNEXPECTED;
    }

    if (IsBadWritePtr(ppszError, sizeof(CHAR*)))
    {
        LOG((RTC_ERROR, "CSDPParser::GetParsingError bad pointer"));
        return E_POINTER;
    }

    if (!m_pTokenCache)
    {
        // no token, this function shouldn't be called
        return E_UNEXPECTED;
    }

    CHAR *pConst, *pStr;

    // get error
    pConst = m_pTokenCache->GetErrorDesp();

    pStr = (CHAR*)RtcAlloc(sizeof(CHAR) * (lstrlenA(pConst)+1));

    if (pStr == NULL)
    {
        LOG((RTC_ERROR, "CSDPParser::GetParsingError out of memory"));

        return E_OUTOFMEMORY;
    }

    lstrcpyA(pStr, pConst);

    *ppszError = pStr;

    return S_OK;
}

STDMETHODIMP
CSDPParser::FreeParsingError(
    IN CHAR *pszError
    )
{
    if (IsBadStringPtrA(pszError, (UINT_PTR)-1))
    {
        LOG((RTC_ERROR, "CSDPParser::FreeParsingError bad pointer"));
        return E_POINTER;
    }

    RtcFree(pszError);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    get loose mask from registry
////*/

DWORD
CSDPParser::GetLooseMask()
{
    ENTER_FUNCTION("CSDPParser::GetLooseMask");

    // initial mask is 0
    HRESULT hr;

    DWORD dwLooseMask = (DWORD)(-1);

#if 0
    // check line order
    if (S_OK == (hr = IsMaskEnabled("LooseLineOrder")))
        dwLooseMask &= ~SDP_LOOSE_LINEORDER;
    else if (FAILED(hr))
        return dwLooseMask;

    // check end crlf
    if (S_OK == (hr = IsMaskEnabled("LooseEndCRLF")))
        dwLooseMask &= ~SDP_LOOSE_ENDCRLF;
    else if (FAILED(hr))
        return dwLooseMask;

    // check keep m0
    if (S_OK == (hr = IsMaskEnabled("LooseKeepingM0")))
        dwLooseMask &= ~SDP_LOOSE_KEEPINGM0;
    else if (FAILED(hr))
        return dwLooseMask;

    // check rtpmap
    if (S_OK == (hr = IsMaskEnabled("LooseRTPMAP")))
        dwLooseMask &= ~SDP_LOOSE_RTPMAP;
    else if (FAILED(hr))
        return dwLooseMask;
#endif

    return dwLooseMask;
}

#if 0
HRESULT
CSDPParser::IsMaskEnabled(
    IN const CHAR * const pszName
    )
{
    ENTER_FUNCTION("CSDPParser::IsMaskEnabled");

    DWORD dwDisposition;

    HRESULT hr;

    if (m_hRegKey == NULL)
    {
        // open the main key
        hr = (HRESULT)::RegCreateKeyExA(
            HKEY_CURRENT_USER,
            g_pszParserRegPath,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,    // option
            KEY_ALL_ACCESS,             // mask
            NULL,                       // security
            &m_hRegKey,                 // result handle
            &dwDisposition              // created or opened
            );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s open reg key. %x", __fxName, hr));

            return E_FAIL;
        }
    }

    // query the value
    DWORD dwData, dwDataType, dwDataSize;

    dwDataSize = sizeof(DWORD);

    hr = (HRESULT)::RegQueryValueExA(
        m_hRegKey,
        pszName,
        0,
        &dwDataType,
        (BYTE*)&dwData,
        &dwDataSize
        );

    if (hr == S_OK && dwDataType == REG_DWORD)
    {
        return dwData!=0;
    }

    // no value yet
    LOG((RTC_WARN, "%s query %s. return %d", __fxName, pszName, hr));

    dwData = 1;

    // set the value
    hr = (HRESULT)::RegSetValueExA(
        m_hRegKey,          // key
        pszName,            // name
        0,                  // reserved
        REG_DWORD,          // data type
        (BYTE*)&dwData,         // data
        sizeof(DWORD)       // data size
        );
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s set default value for %s. %d", __fxName, pszName, hr));

        return hr;
    }

    return S_FALSE;
}
#endif

/*//////////////////////////////////////////////////////////////////////////////
    get tokens from token cache and call static line parsing functions
////*/

HRESULT
CSDPParser::Parse()
{
    ENTER_FUNCTION("CSDPParser::Parse");

    if (m_pSession == NULL || m_pTokenCache == NULL)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;

    // check each line
    BOOL fParsingMedia = FALSE;
    CHAR ucLineType;

    // count of media attribute: rtpmap
    //DWORD dw_ma_rtpmap_num = 0;

    BOOL fSkipMedia = FALSE;

    BOOL fSessionCLine = FALSE;

#define MAX_MEDIA_LINE 16

    BOOL fMediaCLine[MAX_MEDIA_LINE];
    int iMediaCLineCount = 0;
    int iMediaCount = 0;


    while (S_OK == (hr = m_pTokenCache->NextLine()))
    {
        // get line type
        ucLineType = m_pTokenCache->GetLineType();

        // if previous media type is unknown
        // continue until the next media line
        if (fSkipMedia)
        {
            if (ucLineType != 'm')
                continue;
            else
                fSkipMedia = FALSE;
        }

        if (!fParsingMedia)
        {
            // parse session
            switch (ucLineType)
            {
            case 'v':
                hr = Parse_v();
                break;

            case 'o':
                hr = Parse_o();
                break;

            case 's':
                hr = Parse_s();
                break;

            case 'c':

                hr = Parse_c(TRUE); // session c=

                if (FAILED(hr))
                    return hr;

                fSessionCLine = TRUE;

                break;

            case 'b':
                hr = Parse_b();
                break;

            case 'a':
                hr = Parse_a();
                break;

            case 'm':
                hr = Parse_m();

                if (FAILED(hr))
                {
                    fSkipMedia = TRUE;

                    hr = S_OK;
                }
                else
                {
                    fParsingMedia = TRUE;

                    // initially: c line is not present
                    if (iMediaCount < MAX_MEDIA_LINE)
                    {
                        fMediaCLine[iMediaCount] = FALSE;
                        iMediaCLineCount ++;
                    }

                    iMediaCount ++;
                }

                break;

            default:
                // ignore other lines
                LOG((RTC_TRACE, "%s ignore line: %s", __fxName, m_pTokenCache->GetLine()));
            }
        }
        else
        {
            // parse media
            switch (ucLineType)
            {
            case 'm':
                hr = Parse_m();

                // reset starting pos of matching rtpmap and format code
                //dw_ma_rtpmap_num = 0;

                if (FAILED(hr))
                {
                    fSkipMedia = TRUE;

                    hr = S_OK;
                }
                else
                {
                    fParsingMedia = TRUE;

                    // initially: c line is not present
                    if (iMediaCount < MAX_MEDIA_LINE)
                    {
                        fMediaCLine[iMediaCount] = FALSE;
                        iMediaCLineCount ++;
                    }

                    iMediaCount ++;
                }

                break;

            case 'c':
                hr = Parse_c(FALSE); // media c=

                if (FAILED(hr))
                    return hr;

                // check c line
                if (iMediaCount == 0)
                {
                    LOG((RTC_ERROR, "%s parsing media c= but not in parsing media stage"));
                    return E_FAIL;
                }

                // set c= line presents
                if (iMediaCount <= MAX_MEDIA_LINE)
                {
                    fMediaCLine[iMediaCount-1] = TRUE;
                }

                break;

            case 'a':
                hr = Parse_ma(); //&dw_ma_rtpmap_num);
                break;

            default:
                // ignore other lines
                LOG((RTC_TRACE, "%s ignore line: %s", __fxName, m_pTokenCache->GetLine()));
            }
        }

        // did we succeed in parsing the line?
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s parse line: %s", __fxName, m_pTokenCache->GetLine()));

            break;
        }
    }

    if (S_FALSE == hr)
    {
        // end of lines
        hr = S_OK;
    }

    // check c line
    for (int i=0; i<iMediaCLineCount; i++)
    {
        if (!fSessionCLine && !fMediaCLine[i])
        {
            // check if port is 0
            CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(m_pObjSess->m_pMedias[i]);

            USHORT usPort;

            pObjMedia->GetConnPort(SDP_SOURCE_REMOTE, &usPort);

            if (usPort == 0)
                continue;

            // no c= line on this media
            LOG((RTC_ERROR, "%s no c= line at %d th media", __fxName, i));

            return RTC_E_SDP_CONNECTION_ADDR;
        }
    }

    // remove redundent codec
    for (int i=0; i<m_pObjSess->m_pMedias.GetSize(); i++)
    {
        CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(m_pObjSess->m_pMedias[i]);

        int k=1;

        while (k<pObjMedia->m_pFormats.GetSize())
        {
            CRTPFormat *pObjFormat, *pObjCurrent;

            pObjCurrent = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[k]);

            for (int j=0; j<k; j++)
            {
                // check if current format is a dup
                pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[j]);

                if (0 == memcmp(&pObjFormat->m_Param, &pObjCurrent->m_Param, sizeof(RTP_FORMAT_PARAM)))
                {
                    pObjMedia->RemoveFormat(static_cast<IRTPFormat*>(pObjCurrent));

                    k --;
                    break;
                }
            }

            // move to next
            k++;
        }
    }

    // validate the session
    if (S_OK == hr)
    {
        if (FAILED(hr = m_pObjSess->Validate()))
        {
            m_pTokenCache->SetErrorDesp("validate the SDP blob");

            return hr;
        }
    }

    m_pObjSess->CompleteParse((DWORD_PTR*)m_pDTMF);

    _ASSERT(m_pDTMF!=NULL);

    if (m_pDTMF->GetDTMFSupport() != CRTCDTMF::DTMF_ENABLED)
    {
        // disable out-of-band dtmf
        m_pDTMF->SetDTMFSupport(CRTCDTMF::DTMF_DISABLED);
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    parse v=
////*/

HRESULT
CSDPParser::Parse_v()
{
    ENTER_FUNCTION("CSDPParser::Parse_v");

    HRESULT hr;

    // read token
    USHORT us;
    if (S_OK != (hr = m_pTokenCache->NextToken(&us)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading proto-version in line v=");
            
            hr = E_UNEXPECTED;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // check 0
    if (us != 0)
    {
        m_pTokenCache->SetErrorDesp("expecting a zero in line v=");

        hr = E_UNEXPECTED;
    }

    return hr;
}


/*//////////////////////////////////////////////////////////////////////////////
    parse o=
////*/

HRESULT
CSDPParser::Parse_o()
{
    ENTER_FUNCTION("CSDPParser::Parse_o");

    HRESULT hr;

    // read token
    CHAR *pszToken;
    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading line o=");
            
            hr = E_UNEXPECTED;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // skip checking

    // do not save token
    //hr = ::AllocAndCopy(&m_pObjSess->m_o_pszLine, pszToken);

    //if (FAILED(hr))
    //{
    //    LOG((RTC_ERROR, "%s copy line o=. %x", __fxName, hr));

    //    return hr;
    //}

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    parse s=
////*/

HRESULT
CSDPParser::Parse_s()
{
    ENTER_FUNCTION("CSDPParser::Parse_s");

    HRESULT hr;

    // read token
    CHAR *pszToken;
    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            // accept an empty session name
            pszToken = " ";
        }
        else
        {
            m_pTokenCache->SetErrorDesp("reading line s=");

            LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));
            return hr;
        }
    }

    // skip checking

    // save token
    hr = ::AllocAndCopy(&m_pObjSess->m_s_pszLine, pszToken);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s copy line s=. %x", __fxName, hr));

        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    parse c=
////*/

HRESULT
CSDPParser::Parse_c(
    IN BOOL fSession
    )
{
    ENTER_FUNCTION("CSDPParser::Parse_c");

    HRESULT hr;

    // get token nettype
    CHAR *pszToken;

    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading nettype in %s line c=",
                fSession?"session":"media");

            hr = E_UNEXPECTED;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // check if nettype is "IN"
    if (lstrcmpiA(pszToken, "IN") != 0)
    {
        m_pTokenCache->SetErrorDesp("nettype (%s) invalid in %s line c=",
            pszToken, fSession?"session":"media");

        hr = E_UNEXPECTED;

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // get token addrtype
    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading addrtype in %s line c=",
                fSession?"session":"media");

            hr = E_UNEXPECTED;

            LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

            return hr;
        }
    }

    // check if addrtype is "IP4"
    if (lstrcmpiA(pszToken, "IP4") != 0)
    {
        m_pTokenCache->SetErrorDesp("addrtype (%s) invalid in %s line c=",
            pszToken, fSession?"session":"media");

        hr = E_UNEXPECTED;

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // get token addr, we don't support multicast-address
    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading address in %s line c=",
                fSession?"session":"media");

            hr = E_UNEXPECTED;

            LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

            return hr;
        }
    }

    // check address: 1st attempt
    DWORD dwAddr = ntohl(inet_addr(pszToken));

    if (dwAddr == INADDR_NONE)
    {
        // check address: 2nd attempt
        // assume WSAStartup was called. it is a valid assumption in this app.

        struct hostent *pHost;

        pHost = gethostbyname(pszToken);

        if (pHost == NULL ||
            pHost->h_addr_list[0] == NULL ||
            INADDR_NONE == (dwAddr = ntohl(*(ULONG*)pHost->h_addr_list[0])))
        {
            m_pTokenCache->SetErrorDesp("address (%s) invalid in %s line c=",
                pszToken, fSession?"session":"media");

            hr = E_UNEXPECTED;

            LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

            return hr;
        }
    }

    if (IN_MULTICAST(dwAddr))
    {
        return RTC_E_SDP_MULTICAST;
    }

    // save address

    // the sdp should be a remote one
    _ASSERT(m_pObjSess->m_Source == SDP_SOURCE_REMOTE);

    if (fSession)
    {
        m_pObjSess->m_c_dwRemoteAddr = dwAddr;
    }
    else
    {
        // get the last media object
        int i = m_pObjSess->m_pMedias.GetSize();

        if (i<=0)
        {
            LOG((RTC_ERROR, "%s parsing media c= but no medias in session", __fxName));

            return E_FAIL;
        }

        CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(m_pObjSess->m_pMedias[i-1]);

        if (pObjMedia == NULL)
        {
            LOG((RTC_ERROR, "%s dynamic cast media object", __fxName));

            return E_FAIL;
        }

        pObjMedia->m_c_dwRemoteAddr = dwAddr;
    }

    return S_OK;
}

//
// parse b=
//

HRESULT
CSDPParser::Parse_b()
{
    ENTER_FUNCTION("CSDPParser::Parse_b");

    HRESULT hr;

    // read modifier
    CHAR *pszToken;

    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading modifier in session line b=");

            hr = S_OK;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));
        
        return hr;
    }

    // check modifier
    if (lstrcmpiA(pszToken, "CT") != 0)
    {
        // return if not CT
        return S_OK;
    }

    // read value
    DWORD dw;
    if (S_OK != (hr = m_pTokenCache->NextToken(&dw)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading value in session line b=");

            hr = S_OK;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));
        
        return hr;
    }

    // bps to kbps
    dw *= 1000;

    // save value
    m_pObjSess->m_b_dwRemoteBitrate = dw;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    parse a=
////*/
    
HRESULT
CSDPParser::Parse_a()
{
    ENTER_FUNCTION("CSDPParser::Parse_a");

    HRESULT hr;

    // read token
    CHAR *pszToken;

    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading in session line a=");

            hr = S_OK;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // check the token

    // if there are multiple a=sendonly/recvonly, the last
    // will overwrite prious ones.

    // only support parsing sdp from remote party
    _ASSERT(m_pObjSess->m_Source == SDP_SOURCE_REMOTE);

    if (lstrcmpiA(pszToken, "sendonly") == 0)
    {
        // send only
        m_pObjSess->m_a_dwRemoteDirs = (DWORD)RTC_MD_CAPTURE;
    }
    else if (lstrcmpiA(pszToken, "recvonly") == 0)
    {
        // recv only
        m_pObjSess->m_a_dwRemoteDirs = (DWORD)RTC_MD_RENDER;
    }
    else
    {
        LOG((RTC_WARN, "%s a=%s not supported", __fxName, pszToken));
    }

    m_pObjSess->m_a_dwLocalDirs = CSDPParser::ReverseDirections(
        m_pObjSess->m_a_dwRemoteDirs);
    
    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    parse m=
////*/

HRESULT
CSDPParser::Parse_m()
{
    ENTER_FUNCTION("CSDPParser::Parse_m");

    LOG((RTC_TRACE, "entered %s", __fxName));

    HRESULT hr;

    // read token
    CHAR *pszToken;

    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading media in line m=");

            hr = E_UNEXPECTED;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // check the token
    RTC_MEDIA_TYPE MediaType;

    if (lstrcmpiA(pszToken, "audio") == 0)
    {
        MediaType = RTC_MT_AUDIO;
    }
    else if (lstrcmpiA(pszToken, "video") == 0)
    {
        MediaType = RTC_MT_VIDEO;
    }
    else if (lstrcmpiA (pszToken, "application") == 0)
    {
        // This is T120 data media type subject to further verification
        MediaType = RTC_MT_DATA;
    }
    else
    {
        m_pTokenCache->SetErrorDesp("unknown media %s", pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return E_UNEXPECTED;
    }

    // get token: port
    USHORT usPort;

    if (S_OK != (hr = m_pTokenCache->NextToken(&usPort)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading port in line m=");

            hr = E_UNEXPECTED;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // read token: proto
    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading proto in line m=");

            hr = E_UNEXPECTED;
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return hr;
    }

    // check proto
    if (lstrcmpiA(pszToken, "RTP/AVP") != 0 && MediaType != RTC_MT_DATA)
    {
        m_pTokenCache->SetErrorDesp("unknown protocol in media %s", pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        return E_UNEXPECTED;
    }

    // check Netmeeting is the the m line if started with application
    if (MediaType == RTC_MT_DATA)
    {
        if ((S_OK != (hr = m_pTokenCache->NextToken (&pszToken))) ||
            (lstrcmpiA(pszToken, "msdata") != 0))
        {
            LOG((RTC_ERROR, "%s expected tokean Netmeeting is not found", __fxName));
            
            return E_UNEXPECTED;
        }
    }

    // get formats
    DWORD dwCodes[SDP_MAX_RTP_FORMAT_NUM];
    DWORD dwNum = 0;
    //  Read RTP format only if media type is not Netmeeting
    if (MediaType != RTC_MT_DATA)
    {

        while (dwNum < SDP_MAX_RTP_FORMAT_NUM)
        {
            if (S_OK != (hr = m_pTokenCache->NextToken(&dwCodes[dwNum])))
            {
                if (S_FALSE == hr)
                {
                    // end of format
                    break;
                }
    
                LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

                return hr;
            }

            // check the value
            if (dwCodes[dwNum] > 127)
            {
                m_pTokenCache->SetErrorDesp("format code %d in line m= out of range", dwCodes[dwNum]);

                LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

                //return E_UNEXPECTED;

                // ignore others' error
                continue;
            }

            dwNum ++;
        }

        // read rest of the formats
        if (S_OK == hr)
        {
            DWORD dwTemp;

            while (S_OK == (hr = m_pTokenCache->NextToken(&dwTemp)))
            {
                // read a valid number, check the value
                if (dwTemp > 127)
                {
                    m_pTokenCache->SetErrorDesp("format code %d in line m= out of range", dwTemp);
    
                    LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

                    return E_UNEXPECTED;
                }
            }

            if (FAILED(hr))
            {
                // we may encounter a none valid number
                LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

                return hr;
            }
        }

        // check the port
        if (usPort == 0)
        {
            // if port is 0, number of formats should be zero as well
            if (dwNum != 0)
            {
                LOG((RTC_WARN, "%s reading m=, mt=%d, port 0, formats are at least %d",
                    __fxName, MediaType, dwNum));

                dwNum = 0; // recover
            }
        }
        else
        {
            if (usPort < 1024)
            {
                m_pTokenCache->SetErrorDesp("port %d not in range 1024 to 65535", usPort);

                LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

                return E_UNEXPECTED;
            }
        }
    }
    //else
    //{
        //  check the port, if zero, NM is not supported at the remote side
        //if (usPort == 0)
        //{
            //return S_OK;
        //}
    //}

    // create media object
    CComObject<CSDPMedia> *pComObjMedia;

    // the sdp should be a remote one
    _ASSERT(m_pObjSess->m_Source == SDP_SOURCE_REMOTE);

    if (FAILED(hr = CSDPMedia::CreateInstance(
            m_pObjSess,
            SDP_SOURCE_REMOTE,
            MediaType,
            m_pObjSess->m_a_dwRemoteDirs,
            &pComObjMedia
            )))
    {
        LOG((RTC_ERROR, "%s create media. %x", __fxName, hr));

        return hr;
    }

    // save conn addr, port and format codes
    pComObjMedia->m_c_dwRemoteAddr = m_pObjSess->m_c_dwRemoteAddr;

    pComObjMedia->m_m_usRemotePort = usPort;
    pComObjMedia->m_a_usRemoteRTCP = usPort+1; // default rtcp

    if (MediaType != RTC_MT_DATA)
    {
        CComObject<CRTPFormat> *pComObjFormat;

        for (DWORD dw=0; dw<dwNum; dw++)
        {
            // create format
            if (FAILED(hr = CRTPFormat::CreateInstance((CSDPMedia*)pComObjMedia, &pComObjFormat)))
            {
                LOG((RTC_ERROR, "%s create rtp format. %x", __fxName, hr));

                // delete media
                delete (pComObjMedia);

                return hr;
            }

            // media type was saved

            // save format code
            pComObjFormat->m_Param.MediaType = MediaType;
            pComObjFormat->m_Param.dwCode = dwCodes[dw];

            // put format obj into media
            IRTPFormat *pIntfFormat = static_cast<IRTPFormat*>((CRTPFormat*)pComObjFormat);

            if (!pComObjMedia->m_pFormats.Add(pIntfFormat))
            {
                LOG((RTC_ERROR, "%s add ISDPFormat into media", __fxName));

                delete (pComObjFormat);
                delete (pComObjMedia);

                return E_OUTOFMEMORY;
            }
            else
            {
                // important: whenever we expose a media/format interface
                // we addref on session. here we really addref on the object
                pComObjFormat->RealAddRef();
            }
        }
    }


    // put media obj into session
    ISDPMedia *pIntfMedia = static_cast<ISDPMedia*>((CSDPMedia*)pComObjMedia);

    if (!m_pObjSess->m_pMedias.Add(pIntfMedia))
    {
        LOG((RTC_ERROR, "%s add ISDPMedia into session", __fxName));

        delete pComObjMedia;
        return E_OUTOFMEMORY;
    }
    else
    {
        // important: whenever we expose a media/format interface
        // we addref on session. here we really addref on the object
        pComObjMedia->RealAddRef();
    }

    LOG((RTC_TRACE, "exiting %s", __fxName));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    parse a= for media
////*/

HRESULT
CSDPParser::Parse_ma(
    //IN DWORD *pdwRTPMapNum
    )
{
    ENTER_FUNCTION("CSDPParser::Parse_ma");

    HRESULT hr;

    // read token
    CHAR *pszToken;

    if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
    {
        if (S_FALSE == hr)
        {
            m_pTokenCache->SetErrorDesp("reading first token in media line a=");
        }

        LOG((RTC_ERROR, "%s %s", __fxName, m_pTokenCache->GetErrorDesp()));

        // ignore the error
        return S_OK;
    }

    // get the last media object
    int i = m_pObjSess->m_pMedias.GetSize();

    if (i<=0)
    {
        LOG((RTC_ERROR, "%s parsing media a= but no medias in session", __fxName));

        return E_FAIL;
    }

    CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(m_pObjSess->m_pMedias[i-1]);

    if (pObjMedia == NULL)
    {
        LOG((RTC_ERROR, "%s dynamic cast media object", __fxName));

        return E_FAIL;
    }

    // check the token
    if (lstrcmpiA(pszToken, "sendonly") == 0)
    {
        pObjMedia->m_a_dwRemoteDirs = (DWORD)RTC_MD_CAPTURE;
        pObjMedia->m_a_dwLocalDirs = (DWORD)RTC_MD_RENDER;
    }
    else if (lstrcmpiA(pszToken, "recvonly") == 0)
    {
        pObjMedia->m_a_dwRemoteDirs = (DWORD)RTC_MD_RENDER;
        pObjMedia->m_a_dwLocalDirs = (DWORD)RTC_MD_CAPTURE;
    }
    else if (lstrcmpiA(pszToken, "rtpmap") == 0)
    {
        // get token: format code
        DWORD dwCode;

        if (S_OK != (hr = m_pTokenCache->NextToken(&dwCode)))
        {
            LOG((RTC_WARN, "%s no format code after rtpmap", __fxName));

            // ignore error in a=
            return S_OK;
        }

        // got rtpmap
        CRTPFormat *pObjFormat;
        RTP_FORMAT_PARAM Param;

        for (i=0; i<pObjMedia->m_pFormats.GetSize(); i++)
        {
            pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[i]);

            pObjFormat->GetParam(&Param);

            if (Param.dwCode != dwCode)
                continue;

            // got a match

            // read token: format name
            if (S_OK != (hr = m_pTokenCache->NextToken(&pszToken)))
            {
                LOG((RTC_WARN, "%s no format name with rtpmap:%d", __fxName, dwCode));

                // ignore
                return S_OK;
            }

            if (lstrlenA(pszToken) > SDP_MAX_RTP_FORMAT_NAME_LEN)
            {
                LOG((RTC_WARN, "%s rtp format name %s too long", __fxName, pszToken));

                return S_OK;
            }

            // read token: sample rate
            DWORD dwSampleRate;

            if (S_OK != (hr = m_pTokenCache->NextToken(&dwSampleRate)))
            {
                LOG((RTC_WARN, "%s rtpmap:%d %s no sample rate", __fxName, dwCode, pszToken));

                return S_OK;
            }

            // ignore other parameters

            // copy name
            lstrcpynA(pObjFormat->m_Param.pszName, pszToken, lstrlenA(pszToken)+1);

            // save sample rate
            pObjFormat->m_Param.dwSampleRate = dwSampleRate;

            pObjFormat->m_fHasRtpmap = TRUE;
        }
    }
    else if (lstrcmpiA(pszToken, "fmtp") == 0)
    {
        UCHAR uc;

        if (S_OK != (hr = m_pTokenCache->NextToken(&uc)))
        {
            LOG((RTC_WARN, "%s fmtp no next token", __fxName));

            return S_OK;
        }

        CRTPFormat *pObjFormat;
        RTP_FORMAT_PARAM Param;

        for (i=0; i<pObjMedia->m_pFormats.GetSize(); i++)
        {
            pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[i]);

            pObjFormat->GetParam(&Param);

            if (Param.dwCode == (DWORD)uc)
            {
                // record the whole token
                pszToken = m_pTokenCache->GetLine();
                if (pszToken == NULL)
                {
                    LOG((RTC_WARN, "%s no fmtp value", __fxName));

                    return S_OK;
                }

                pObjFormat->StoreFmtp(pszToken);

                pszToken = NULL;

                break;
            }
        }
    }
    else if (lstrcmpiA(pszToken, "rtcp") == 0)
    {
        USHORT us;

        if (S_OK != (hr = m_pTokenCache->NextToken(&us)))
        {
            LOG((RTC_WARN, "%s rtcp no next token", __fxName));

            return S_OK;
        }

        if (us <= IPPORT_RESERVED || us == pObjMedia->m_m_usRemotePort)
        {
            LOG((RTC_ERROR, "%s invalid rtcp port %d", __fxName, us));

            return E_FAIL;
        }

        pObjMedia->m_a_usRemoteRTCP = us;
    }

    return S_OK;
}

//
// methods to build up sdp blob
//

HRESULT
CSDPParser::Build_v(
    OUT CString& Str
    )
{
    Str = "v=0";

    if (Str.IsNull())
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CSDPParser::Build_o(
    OUT CString& Str
    )
{
    int iSize;

    // ip address may change
    // rebuild o line
    if (m_pObjSess->m_o_pszLine)
    {
        RtcFree(m_pObjSess->m_o_pszLine);
        m_pObjSess->m_o_pszLine = NULL;
    }

    if (!m_pObjSess->m_o_pszUser)
    {
        CHAR hostname[80];

        // use host name as user name
        if (0 != gethostname(hostname, 80))
        {
            if (FAILED(::AllocAndCopy(&m_pObjSess->m_o_pszUser, "user")))
                return E_OUTOFMEMORY;
        }
        else
        {
            if (FAILED(::AllocAndCopy(&m_pObjSess->m_o_pszUser, hostname)))
                return E_OUTOFMEMORY;
        }
    }

    // alloc sess to hold c=name 0 0 IN IP4 ipaddr

    // convert dwAddr to string
    const CHAR * const psz_constAddr = CNetwork::GetIPAddrString(m_pObjSess->m_o_dwLocalAddr);

    iSize = lstrlenA(m_pObjSess->m_o_pszUser) + 12 + lstrlenA(psz_constAddr) + 1;
    m_pObjSess->m_o_pszLine = (CHAR*)RtcAlloc(sizeof(CHAR)* iSize);

    if (m_pObjSess->m_o_pszLine == NULL)
        return E_OUTOFMEMORY;

    // copy data
    _snprintf(m_pObjSess->m_o_pszLine, iSize, "%s 0 0 IN IP4 %s", m_pObjSess->m_o_pszUser, psz_constAddr);

    // got name
    Str = "o=";

    Str += m_pObjSess->m_o_pszLine;

    if (Str.IsNull())
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CSDPParser::Build_s(
    OUT CString& Str
    )
{
    if (!m_pObjSess->m_s_pszLine)
    {
        if (FAILED(::AllocAndCopy(&m_pObjSess->m_s_pszLine, "session")))
            return E_OUTOFMEMORY;
    }

    Str = "s=";

    Str += m_pObjSess->m_s_pszLine;

    if (Str.IsNull())
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CSDPParser::Build_t(
    OUT CString& Str
    )
{
    Str = "t=0 0";

    if (Str.IsNull())
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT
CSDPParser::Build_c(
    IN BOOL fSession,
    IN ISDPMedia *pISDPMedia,
    OUT CString& Str
    )
{
    if (!fSession)
        _ASSERT(pISDPMedia);

    DWORD dwAddr;

    // get connection address
    if (fSession)
    {
        dwAddr = m_pObjSess->m_c_dwLocalAddr;
    }
    else
    {
        CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(pISDPMedia);

        dwAddr = pObjMedia->GetMappedLocalAddr();
    }

    if (!fSession && dwAddr == m_pObjSess->m_c_dwLocalAddr)
    {
        // no need to build c= for media
        Str = "";

        if (Str.IsNull())
            return E_OUTOFMEMORY;

        return S_OK;
    }

    Str = "c=IN IP4 ";

    Str += CNetwork::GetIPAddrString(dwAddr);

    if (Str.IsNull())
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CSDPParser::Build_b(
    OUT CString& Str
)
{
    if (m_pObjSess->m_b_dwLocalBitrate == (DWORD)-1)
    {
        // do not include b= if bandwidth is unlimited
        Str = "";
    }
    else
    {
        // b=CT:<DWORD>\0
        DWORD dw = m_pObjSess->m_b_dwLocalBitrate / 1000;

        if (dw == 0)
            dw = 1;

        Str = "b=CT:";

        Str += dw;
    }

    if (Str.IsNull())
        return E_OUTOFMEMORY;

    return S_OK;
}


HRESULT
CSDPParser::Build_a(
    OUT CString& Str
)
{
    Str = "";

    if (Str.IsNull())
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CSDPParser::Build_m(
    IN ISDPMedia *pISDPMedia,
    OUT CString& Str
    )
{
    CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(pISDPMedia);

    // m=media port RTP/AVP payload list

                        // GetSize()+1 because sdp doesn't allow m= not to have format code
                        // prepare some space in case we don't have format
                        // space for \r\na=rtcp:xxxx

    // find possible mapped port
    DWORD dwMappedAddr;
    USHORT usMappedPort = pObjMedia->m_m_usLocalPort;
    USHORT usMappedRTCP = pObjMedia->m_m_usLocalPort+1;

    HRESULT hr;

    if (!m_pPortCache->IsUpnpMapping())
    {
        //
        // port manager is present
        //
        dwMappedAddr = pObjMedia->m_dwMappedLocalAddr;
        usMappedPort = pObjMedia->m_usMappedLocalRTP;
        usMappedRTCP = pObjMedia->m_usMappedLocalRTCP;
    }
    else if (m_pNetwork != NULL)
    {
        if (FAILED(hr = m_pNetwork->GetMappedAddrFromReal2(
                    pObjMedia->m_c_dwLocalAddr,
                    pObjMedia->m_m_usLocalPort,
                    pObjMedia->m_m_MediaType==RTC_MT_DATA?
                            0:(pObjMedia->m_m_usLocalPort+1),
                    &dwMappedAddr,
                    &usMappedPort,
                    &usMappedRTCP
                    )))
        {
            LOG((RTC_ERROR, "Build_m GetMappedAddrFromReal. %s %d",
                CNetwork::GetIPAddrString(pObjMedia->m_c_dwLocalAddr),
                pObjMedia->m_m_usLocalPort));

            return hr;
        }
    }

    if (pObjMedia->m_m_MediaType == RTC_MT_DATA)
    {
        //  For T120 data channel
        //  m=Netmeeting 0 udp
        //  port and transport parameter are currently ignored

        Str = "m=application ";
        Str += usMappedPort;
        Str += " tcp msdata";

        if (Str.IsNull())
        {
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }

    Str = "m=";
    Str += pObjMedia->m_m_MediaType==RTC_MT_AUDIO?"audio ":"video ";
    Str += usMappedPort;
    Str += " RTP/AVP";

    if (pObjMedia->m_m_usLocalPort != 0)
    {
        // put format codes if port is not 0
        for (int i=0; i<pObjMedia->m_pFormats.GetSize(); i++)
        {
            CRTPFormat *pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[i]);

            Str += " ";
            Str += pObjFormat->m_Param.dwCode;
        }

        // out-of-band dtmf
        if (pObjMedia->m_m_MediaType==RTC_MT_AUDIO &&
            m_pDTMF != NULL)
        {
            if (m_pDTMF->GetDTMFSupport() != CRTCDTMF::DTMF_DISABLED)
            {
                // either the other party support OOB or we don't know yet
                Str += " ";
                Str += m_pDTMF->GetRTPCode();
            }
        }

        if (usMappedRTCP != usMappedPort+1)
        {
            // a=rtcp:xxx
            Str += "\r\na=rtcp:";
            Str += usMappedRTCP;
        }
    }
    else
    {
        // fake one format code
        if (pObjMedia->m_m_MediaType == RTC_MT_AUDIO)
            Str += " 0";
        else
            Str += " 34";
    }

    if (Str.IsNull())
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CSDPParser::Build_ma_dir(
    IN ISDPMedia *pISDPMedia,
    OUT CString& Str
    )
{
    // a=sendonly or recvonly

    CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(pISDPMedia);
    HRESULT hr;

    if ( pObjMedia->m_a_dwLocalDirs & RTC_MD_CAPTURE &&
       !(pObjMedia->m_a_dwLocalDirs & RTC_MD_RENDER))
    {
        Str = "a=sendonly";
    }
    else if ( pObjMedia->m_a_dwLocalDirs & RTC_MD_RENDER &&
            !(pObjMedia->m_a_dwLocalDirs & RTC_MD_CAPTURE))
    {
        Str = "a=recvonly";
    }
    else
        Str = "";

    if (Str.IsNull())
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
CSDPParser::Build_ma_rtpmap(
    IN ISDPMedia *pISDPMedia,
    OUT CString& Str
    )
{
    // a=rtpmap:code name/samplerate
    const CHAR * const psz_rtpmap = "a=rtpmap:";
    const DWORD dwRtpmap = 9;

    CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(pISDPMedia);
    CRTPFormat *pObjFormat;
    
    // is there any rtpmap?
    DWORD dwFmtNum;

    if (0 == (dwFmtNum = pObjMedia->m_pFormats.GetSize()))
    {
        Str = "";

        if (Str.IsNull())
            return E_OUTOFMEMORY;

        return S_OK;
    }

    // copy formats
    CHAR **ppszFormat = (CHAR**)RtcAlloc(sizeof(CHAR*)*dwFmtNum);

    if (ppszFormat == NULL)
        return E_OUTOFMEMORY;

    ZeroMemory(ppszFormat, sizeof(CHAR*)*dwFmtNum);

    HRESULT hr = S_OK;
    DWORD dwStrSize = 0;

    // build each rtpmap
    for (DWORD dw=0; dw<dwFmtNum; dw++)
    {
        pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[dw]);

        if (!pObjFormat->m_fHasRtpmap)
        {
            // no rtpmap
            if (FAILED(::AllocAndCopy(&ppszFormat[dw], "")))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else
        {
            // create rtpmap
            int iSize = dwRtpmap+10+lstrlenA(pObjFormat->m_Param.pszName)+1+11 +
                40; // fmtp
            ppszFormat[dw] = (CHAR*)RtcAlloc(sizeof(CHAR)*iSize);

            if (ppszFormat[dw] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            _snprintf(ppszFormat[dw], iSize, "%s%d %s/%d",
                psz_rtpmap,
                pObjFormat->m_Param.dwCode,
                pObjFormat->m_Param.pszName,
                pObjFormat->m_Param.dwSampleRate
                );

            // check siren
            if (lstrcmpiA(pObjFormat->m_Param.pszName, "SIREN") == 0)
            {
                _snprintf(ppszFormat[dw]+lstrlenA(ppszFormat[dw]),
                          iSize-lstrlenA(ppszFormat[dw]),
                          "\r\na=fmtp:%d bitrate=16000",
                          pObjFormat->m_Param.dwCode);
            }
            // check g7221
            // i should have designed one class for each codec
            // sigh
            else if (lstrcmpiA(pObjFormat->m_Param.pszName, "G7221") == 0)
            {
                _snprintf(ppszFormat[dw]+lstrlenA(ppszFormat[dw]),
                          iSize-lstrlenA(ppszFormat[dw]),
                          "\r\na=fmtp:%d bitrate=24000",
                          pObjFormat->m_Param.dwCode);
            }
        }

        dwStrSize += lstrlenA(ppszFormat[dw]);
    }

    if (dwStrSize == 0)
    {
        // no rtpmap
        Str = "";
    }
    else
    {
        // copy data
        Str = ppszFormat[0];

        for (DWORD dw=1; dw<dwFmtNum; dw++)
        {
            if (lstrlenA(ppszFormat[dw])>2)
            {
                Str += CRLF;
                Str += ppszFormat[dw];
            }
        }

        hr = S_OK;
    }

    // out-of-band dtmf
    if (pObjMedia->m_m_MediaType==RTC_MT_AUDIO &&
        m_pDTMF != NULL)
    {
        if (m_pDTMF->GetDTMFSupport() != CRTCDTMF::DTMF_DISABLED)
        {
            // either the other party support OOB or we don't know yet
            Str += CRLF;
            Str += psz_rtpmap;
            Str += m_pDTMF->GetRTPCode();
            Str += " telephone-event/8000\r\na=fmtp:";
            Str += m_pDTMF->GetRTPCode();
            Str += " 0-16";
        }
    }

Cleanup:

    if (ppszFormat != NULL)
    {
        for (DWORD dw=0; dw<dwFmtNum; dw++)
        {
            if (ppszFormat[dw] != NULL)
                RtcFree(ppszFormat[dw]);
        }

        RtcFree(ppszFormat);
    }

    return hr;
}

HRESULT
CSDPParser::PrepareAddress()
{
    HRESULT hr;

    CSDPMedia *pObjMedia;

    DWORD dwMappedAddr;
    USHORT usMappedPort, usMappedRTCP;

    m_pObjSess->m_c_dwLocalAddr = 0;
    m_pObjSess->m_o_dwLocalAddr = 0;

    // convert local addr to mapped addr
    for (int i=0; i<m_pObjSess->m_pMedias.GetSize(); i++)
    {
        pObjMedia = static_cast<CSDPMedia*>(m_pObjSess->m_pMedias[i]);

        dwMappedAddr = 0;
        usMappedPort = 0;
        usMappedRTCP = 0;
        hr = S_OK;


        if (pObjMedia->m_c_dwLocalAddr == INADDR_NONE ||
            pObjMedia->m_c_dwLocalAddr == INADDR_ANY)
        {
            // use 0.0.0.0
        }
        else if (!m_pPortCache->IsUpnpMapping())
        {
            // using port manager
            _ASSERT(pObjMedia->m_m_MediaType != RTC_MT_DATA);

            // retrieve mapped ports
            hr = m_pPortCache->QueryPort(
                    pObjMedia->m_m_MediaType,
                    TRUE,       // RTP
                    NULL,       // local
                    NULL,
                    &dwMappedAddr,
                    &usMappedPort
                    );

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "PrepareAddress query rtp %x", hr));
                // use real local addr
            }
            else
            {
                hr = m_pPortCache->QueryPort(
                        pObjMedia->m_m_MediaType,
                        FALSE,       // RTCP
                        NULL,       // local
                        NULL,
                        &dwMappedAddr,
                        &usMappedRTCP
                        );

                if (FAILED(hr))
                {
                    LOG((RTC_ERROR, "PrepareAddress query rtcp %x", hr));
                    // use real local addr
                }
            }
        }
        else if (m_pNetwork != NULL &&
                 SUCCEEDED(m_pNetwork->GetMappedAddrFromReal2(
                    pObjMedia->m_c_dwLocalAddr,
                    pObjMedia->m_m_usLocalPort,
                    pObjMedia->m_m_MediaType==RTC_MT_DATA?
                            0:(pObjMedia->m_m_usLocalPort+1),
                    &dwMappedAddr,
                    &usMappedPort,
                    &usMappedRTCP
                    )))
        {
            // set mapped addr
        }
        else
        {
            // use real local addr
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            // use real local addr
            pObjMedia->SetMappedLocalAddr(pObjMedia->m_c_dwLocalAddr);
            pObjMedia->SetMappedLocalRTP(pObjMedia->m_m_usLocalPort);
            pObjMedia->SetMappedLocalRTCP(pObjMedia->m_m_usLocalPort+1);
        }
        else
        {
            // use real local addr
            pObjMedia->SetMappedLocalAddr(dwMappedAddr);
            pObjMedia->SetMappedLocalRTP(usMappedPort);
            pObjMedia->SetMappedLocalRTCP(usMappedRTCP);
        }

        // save addr for o=
        if (m_pObjSess->m_o_dwLocalAddr == 0 &&
            pObjMedia->GetMappedLocalAddr() != 0)
        {
            m_pObjSess->m_o_dwLocalAddr = pObjMedia->GetMappedLocalAddr();
        }

        // check if hold
        if (pObjMedia->m_c_dwRemoteAddr == INADDR_ANY)
        {
            // to hold
            pObjMedia->SetMappedLocalAddr(0);
        }

        if (m_pObjSess->m_c_dwLocalAddr == 0 &&
            pObjMedia->GetMappedLocalAddr() != 0)
        {
            m_pObjSess->m_c_dwLocalAddr = pObjMedia->GetMappedLocalAddr();
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdpsession.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPSession.cpp

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#include "stdafx.h"

static DWORD gdwTotalSDPSessionRefcount = 0;

/*//////////////////////////////////////////////////////////////////////////////
    create a session object
    return the interface pointer
////*/

HRESULT
CSDPSession::CreateInstance(
    IN SDP_SOURCE Source,
    IN DWORD dwLooseMask,
    OUT ISDPSession **ppSession
    )
{
    ENTER_FUNCTION("CSDPSession::CreateInstance");

    // check pointer
    if (IsBadWritePtr(ppSession, sizeof(ISDPSession*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));
        return E_POINTER;
    }

    CComObject<CSDPSession> *pObject;
    ISDPSession *pSession = NULL;

    // create CSDPSession object
    HRESULT hr = ::CreateCComObjectInstance(&pObject);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create sdp Session. %x", __fxName, hr));
        return hr;
    }

    // QI ISDPSession interface
    if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(ISDPSession), (void**)&pSession)))
    {
        LOG((RTC_ERROR, "%s QI Session. %x", __fxName, hr));

        delete pObject;
        return hr;
    }

    // save source and mask
    pObject->m_Source = Source;
    pObject->m_dwLooseMask = dwLooseMask;

    *ppSession = pSession;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    constructor
    session is initiated as bidirectional.
////*/

CSDPSession::CSDPSession()
    :m_dwLooseMask(0)
    ,m_Source(SDP_SOURCE_REMOTE)
    ,m_o_pszLine(NULL)
    ,m_o_pszUser(NULL)
    ,m_s_pszLine(NULL)
    ,m_c_dwRemoteAddr(INADDR_NONE)
    ,m_c_dwLocalAddr(INADDR_NONE)
    ,m_b_dwLocalBitrate((DWORD)-1)
    ,m_b_dwRemoteBitrate((DWORD)-1)
    ,m_a_dwRemoteDirs(RTC_MD_CAPTURE | RTC_MD_RENDER)
    ,m_a_dwLocalDirs(RTC_MD_CAPTURE | RTC_MD_RENDER)
{
}

CSDPSession::~CSDPSession()
{
    if (m_o_pszLine)
        RtcFree(m_o_pszLine);

    if (m_o_pszUser)
        RtcFree(m_o_pszUser);

    if (m_s_pszLine)
        RtcFree(m_s_pszLine);

    // real release each media object

    CSDPMedia *pObjMedia;

    for (int i=0; i<m_pMedias.GetSize(); i++)
    {
        pObjMedia = static_cast<CSDPMedia*>(m_pMedias[i]);

        pObjMedia->RealRelease();
    }

    m_pMedias.RemoveAll();
}

ULONG
CSDPSession::InternalAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    gdwTotalSDPSessionRefcount ++;

    LOG((RTC_REFCOUNT, "sdpsession(%p) real addref=%d (total=%d)",
         static_cast<ISDPSession*>(this), lRef, gdwTotalSDPSessionRefcount));

    return lRef;
}

ULONG
CSDPSession::InternalRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();
    
    gdwTotalSDPSessionRefcount --;

    LOG((RTC_REFCOUNT, "sdpsession(%p) real release=%d (total=%d)",
         static_cast<ISDPSession*>(this), lRef, gdwTotalSDPSessionRefcount));

    return lRef;
}


//
// ISDPSession methods
//

/*//////////////////////////////////////////////////////////////////////////////
    update current sdp session with a new one
////*/

STDMETHODIMP
CSDPSession::Update(
    IN ISDPSession *pSession
    )
{
    ENTER_FUNCTION("CSDPSession::Update");

    CSDPSession *pOther = static_cast<CSDPSession*>(pSession);

    HRESULT hr = pOther->Validate();

    if (S_OK != hr)
    {
        LOG((RTC_ERROR, "%s validate the new session", __fxName));

        return E_FAIL;
    }

    // only support merging with a remote sdp
    if (pOther->m_Source != SDP_SOURCE_REMOTE)
        return E_NOTIMPL;

    // try to update medias first
    // if failed, current session should not change
    if (FAILED(hr = UpdateMedias(pOther->m_dwLooseMask, pOther->m_pMedias)))
    {
        LOG((RTC_ERROR, "%s update medias. %x", __fxName, hr));

        return hr;
    }

    // copy loose mask
    m_dwLooseMask = pOther->m_dwLooseMask;

    // merge sources
    if (m_Source != pOther->m_Source)
    {
        m_Source = SDP_SOURCE_MERGED;
    }

    // copy o=
    if (m_o_pszLine)
    {
        if (pOther->m_o_pszLine)
        {
            RtcFree(m_o_pszLine);
            m_o_pszLine = NULL;

            if (FAILED(hr = ::AllocAndCopy(&m_o_pszLine, pOther->m_o_pszLine)))
            {
                LOG((RTC_ERROR, "%s copy o= line", __fxName));

                return E_OUTOFMEMORY;
            }
        }
    }

    // remove user name since we have o=
    if (m_o_pszUser)
    {
        RtcFree(m_o_pszUser);
        m_o_pszUser = NULL;
    }

    // copy s=
    if (m_s_pszLine)
    {
        if (pOther->m_s_pszLine)
        {
            RtcFree(m_s_pszLine);
            m_s_pszLine = NULL;

            if (FAILED(hr = ::AllocAndCopy(&m_s_pszLine, pOther->m_s_pszLine)))
            {
                LOG((RTC_ERROR, "%s copy s= line", __fxName));

                return E_OUTOFMEMORY;
            }
        }
    }

    // copy remote addr
    m_c_dwRemoteAddr = pOther->m_c_dwRemoteAddr;

    // copy directions
    m_a_dwRemoteDirs = pOther->m_a_dwRemoteDirs;
    m_a_dwLocalDirs = pOther->m_a_dwLocalDirs;

    // copy bitrate limit
    m_b_dwLocalBitrate = pOther->m_b_dwLocalBitrate;
    m_b_dwRemoteBitrate = pOther->m_b_dwRemoteBitrate;

    return S_OK;
}

STDMETHODIMP
CSDPSession::GetSDPSource(
    OUT SDP_SOURCE *pSource
    )
{
    if (IsBadWritePtr(pSource, sizeof(SDP_SOURCE)))
        return E_POINTER;

    *pSource = m_Source;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    set session name
////*/

STDMETHODIMP
CSDPSession::SetSessName(
    IN CHAR *pszName
    )
{
    // skip check string pointer

    if (pszName == NULL)
        return E_POINTER;

    HRESULT hr = ::AllocAndCopy(&m_s_pszLine, pszName);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "CSDPSession::SetSessName copy session name"));

        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    set user name
////*/

STDMETHODIMP
CSDPSession::SetUserName(
    IN CHAR *pszName
    )
{
    // skip check string pointer

    if (pszName == NULL)
        return E_POINTER;

    HRESULT hr = ::AllocAndCopy(&m_o_pszUser, pszName);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "CSDPSession::SetUserName copy user name"));

        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    retrieve a list of sdp medias
    media refcount will be added on session
////*/

STDMETHODIMP
CSDPSession::GetMedias(
    IN OUT DWORD *pdwCount,
    OUT ISDPMedia **ppMedia
    )
{
    ENTER_FUNCTION("CSDPSession::GetMedias");

    // check pointers
    if (IsBadWritePtr(pdwCount, sizeof(DWORD)))
    {
        LOG((RTC_ERROR, "%s bad count pointer", __fxName));

        return E_POINTER;
    }

    if (ppMedia == NULL)
    {
        // caller needs the number of medias
        *pdwCount = m_pMedias.GetSize();

        return S_OK;
    }

    // caller needs real medias
    
    // how many are needed?
    if (*pdwCount == 0)
        return E_INVALIDARG;

    if (IsBadWritePtr(ppMedia, sizeof(ISDPMedia)*(*pdwCount)))
    {
        LOG((RTC_ERROR, "%s bad media pointer", __fxName));

        return E_POINTER;
    }

    // store interfaces
    DWORD dwNum = m_pMedias.GetSize();

    if (dwNum > *pdwCount)
        dwNum = *pdwCount;

    for (DWORD i=0; i<dwNum; i++)
    {
        ppMedia[i] = m_pMedias[i];

        ppMedia[i]->AddRef();
    }

    *pdwCount = dwNum;

    return S_OK;
}

STDMETHODIMP
CSDPSession::GetMediaType(
	IN DWORD dwIndex,
	OUT RTC_MEDIA_TYPE *pMediaType
	)
{   
    // validate index
    if (dwIndex >= (DWORD)(m_pMedias.GetSize()))
    {
        return E_INVALIDARG;
    }

    return m_pMedias[dwIndex]->GetMediaType(pMediaType);
}

/*//////////////////////////////////////////////////////////////////////////////
    add a new media object in session
////*/

STDMETHODIMP
CSDPSession::AddMedia(
    IN SDP_SOURCE Source,
    IN RTC_MEDIA_TYPE MediaType,
    IN DWORD dwDirections,
    OUT ISDPMedia **ppMedia
    )
{
    ENTER_FUNCTION("CSDPSession::AddMedia");

    HRESULT hr;

    // create media object
    CComObject<CSDPMedia> *pComObjMedia = NULL;

    if (FAILED(hr = CSDPMedia::CreateInstance(
            this,
            Source,
            MediaType,
            dwDirections,
            &pComObjMedia
            )))
    {
        LOG((RTC_ERROR, "%s create media. %x", __fxName, hr));

        return hr;
    }

    // add the media to list
    ISDPMedia *pIntfMedia = static_cast<ISDPMedia*>((CSDPMedia*)pComObjMedia);

    if (!m_pMedias.Add(pIntfMedia))
    {
        LOG((RTC_ERROR, "%s add media.", __fxName));

        delete pComObjMedia;

        return E_OUTOFMEMORY;
    }
    else
    {
        // really keep the media interface
        pComObjMedia->RealAddRef();
    }

    pIntfMedia->AddRef();
    *ppMedia = pIntfMedia;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    remove a media object from our list
////*/

STDMETHODIMP
CSDPSession::RemoveMedia(
    IN ISDPMedia *pMedia
    )
{
    if (m_pMedias.Remove(pMedia))
    {
        CSDPMedia *pObjMedia = static_cast<CSDPMedia*>(pMedia);

        pObjMedia->RealRelease();

        return S_OK;
    }
    else
    {
        LOG((RTC_ERROR, "CSDPSession::RemoveMedia %p failed.", pMedia));

        return E_FAIL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    check if the session is valid
////*/

HRESULT
CSDPSession::Validate()
{
    ENTER_FUNCTION("CSDPSession::Validate");

    // s=, m= are must-have
    
    //if (m_o_pszLine == NULL || m_o_pszLine[0] == '\0')
    //{
    //    if (m_o_pszUser == NULL || m_o_pszUser[0] == '\0')
    //    {
    //        LOG((RTC_ERROR, "%s no o= line", __fxName));

    //        return S_FALSE;
    //    }
    //}

    if (m_s_pszLine == NULL || m_s_pszLine[0] == '\0')
    {
        LOG((RTC_ERROR, "%s no s= line", __fxName));

        return S_FALSE;
    }

    int iCount;

    if (0 == (iCount=m_pMedias.GetSize()))
    {
        LOG((RTC_ERROR, "%s no m= line", __fxName));

        return S_FALSE;
    }

    // check media part: port and formats

    CSDPMedia *pObjMedia;
    CRTPFormat *pObjFormat;

    int iFormat;

    for (int i=0; i<iCount; i++)
    {
        pObjMedia = static_cast<CSDPMedia*>(m_pMedias[i]);

        // port = 0?
        if (pObjMedia->m_m_usLocalPort == 0)
            continue;

        // number of formats
        if (0 == (iFormat=pObjMedia->m_pFormats.GetSize()))
        {
            LOG((RTC_ERROR, "%s no format for %dth media", __fxName, i));

            return S_FALSE;
        }

        // check if format has rtpmap
        for (int j=0; j<iFormat; j++)
        {
            pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[j]);

            if (!pObjFormat->m_fHasRtpmap)
            {
                // format not set

                if (m_dwLooseMask & SDP_LOOSE_RTPMAP)
                    // hmm.. we accept the format without rtpmap
                    continue;

                // else reject it
                LOG((RTC_ERROR, "%s %dth format of %dth media does not have rtpmap",
                    __fxName, j, i));

                return S_FALSE;
            }
        }
    }

    // if we go this far
    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    update medias, check if new medias match the current
    apply the constraints: only one stream for 
////*/

HRESULT
CSDPSession::UpdateMedias(
    IN DWORD dwLooseMask,
    IN CRTCArray<ISDPMedia*>& ArrMedias
    )
{
    ENTER_FUNCTION("CSDPSession::UpdateMedias");

    HRESULT hr;

    CSDPMedia *pOurMedia, *pTheirMedia;

    CComObject<CSDPMedia> *pComObjMedia;
    ISDPMedia *pIntfMedia;

    // check if each media matches
    int iOur = m_pMedias.GetSize();
    int iTheir = ArrMedias.GetSize();

    int iOurFormats;
    int iTheirFormats;

    CRTPFormat *pOurFormat, *pTheirFormat;
    CComObject<CRTPFormat> *pComObjFormat;
    IRTPFormat *pIntfFormat;

    if (iOur > iTheir)
    {
        if (!(dwLooseMask & SDP_LOOSE_KEEPINGM0))
        {
            // have to keep m= lines with port 0
            LOG((RTC_ERROR, "%s keeping m0, current m= count %d, new %d",
                __fxName, iOur, iTheir));

            return E_FAIL;
        }
    }

    // check if each m= matches
    int iMin = iOur<iTheir?iOur:iTheir;

    for (int i=0; i<iMin; i++)
    {
        pOurMedia = static_cast<CSDPMedia*>(m_pMedias[i]);
        pTheirMedia = static_cast<CSDPMedia*>(ArrMedias[i]);

        // check media type
        if (pOurMedia->m_m_MediaType != pTheirMedia->m_m_MediaType)
        {
            LOG((RTC_ERROR, "%s our %dth media type not match",
                __fxName, i));

            return E_FAIL;
        }
    }

    // really update medias
    for (int i=0; i<iMin; i++)
    {
        RTC_MEDIA_TYPE              mt;
    
        pOurMedia = static_cast<CSDPMedia*>(m_pMedias[i]);
        pTheirMedia = static_cast<CSDPMedia*>(ArrMedias[i]);

        //
        // check conn address
        //

        if (pTheirMedia->m_c_dwRemoteAddr == INADDR_NONE)
        {
            // not a valid remote addr
            pOurMedia->Abandon();
            pOurMedia = pTheirMedia = NULL;
            continue;
        }

        if (pOurMedia->m_c_dwRemoteAddr != pTheirMedia->m_c_dwRemoteAddr)
        {
            // get a new remote addr
            // do we need to clear local address ? ToDo
            pOurMedia->m_c_dwRemoteAddr = pTheirMedia->m_c_dwRemoteAddr;
            pOurMedia->m_fIsConnChanged = TRUE;
        }
        else
        {
            pOurMedia->m_fIsConnChanged = FALSE;
        }

        //
        // check port
        //

        if (pTheirMedia->m_m_usRemotePort == 0)
        {
            // no port
            pOurMedia->Abandon();
            pOurMedia = pTheirMedia = NULL;
            continue;
        }

        if (pOurMedia->m_m_usRemotePort != pTheirMedia->m_m_usRemotePort)
        {
            pOurMedia->m_fIsConnChanged = TRUE;

            // change ports
            // do we need to clear local port ? ToDo
            pOurMedia->m_m_usRemotePort = pTheirMedia->m_m_usRemotePort;
            pOurMedia->m_a_usRemoteRTCP = pTheirMedia->m_a_usRemoteRTCP;
        }

        //
        // check media directions
        //

        if (pTheirMedia->m_a_dwLocalDirs == 0)
        {
            // no directions
            pOurMedia->Abandon();
            pOurMedia = pTheirMedia = NULL;
            continue;
        }

        pOurMedia->m_a_dwLocalDirs = pTheirMedia->m_a_dwLocalDirs;
        pOurMedia->m_a_dwRemoteDirs = pTheirMedia->m_a_dwRemoteDirs;

        //
        //  Update completes for data media
        //
        if (pOurMedia->GetMediaType (&mt) == S_OK &&
            mt == RTC_MT_DATA
            )
        {
            continue;
        }

        //
        // check formats
        //

        iTheirFormats = pTheirMedia->m_pFormats.GetSize();

        if (iTheirFormats == 0)
        {
            // no format
            pOurMedia->Abandon();
            pOurMedia = pTheirMedia = NULL;
            continue;
        }

        iOurFormats = pOurMedia->m_pFormats.GetSize();

        // where to begin copy
        int iBegin;

        if (iOurFormats == 0)
        {
            // we got new format
            pOurMedia->m_fIsRecvFmtChanged = TRUE;
            pOurMedia->m_fIsSendFmtChanged = TRUE;

            iBegin = 0;
        }
        else
        {
            // is the first format changed?
            RTP_FORMAT_PARAM Param;

            if (FAILED(pOurMedia->m_pFormats[0]->GetParam(&Param)))
            {
                // ignore the error, assume we don't have format
                pOurMedia->m_fIsRecvFmtChanged = TRUE;
                pOurMedia->m_fIsSendFmtChanged = TRUE;

                iBegin = 0;
            }
            else
            {
                if (S_OK != pTheirMedia->m_pFormats[0]->IsParamMatch(&Param))
                {
                    // 1st format not match
                    pOurMedia->m_fIsRecvFmtChanged = TRUE;
                    pOurMedia->m_fIsSendFmtChanged = TRUE;

                    iBegin = 0;
                }
                else
                {
                    // require format mapping for dynamic payload
                    if (Param.dwCode<=96)
                    {
                        // do not copy the 1st format

                        // @@@@@ this might cause problem.
                        // if we don't update format mapping, we may not be
                        // able to process the other party's new proposed formats.
                        pOurMedia->m_fIsRecvFmtChanged = FALSE;
                        pOurMedia->m_fIsSendFmtChanged = FALSE;

                        iBegin = 1;
                    }
                    else
                        iBegin = 0;
                }
            }
        }

        // clear previous formats
        while (iBegin < pOurMedia->m_pFormats.GetSize())
        {
            pOurFormat = static_cast<CRTPFormat*>(pOurMedia->m_pFormats[iBegin]);

            // release the format
            pOurFormat->RealRelease();
            pOurFormat = NULL;

            // release the format
            pOurMedia->m_pFormats.RemoveAt(iBegin);
        }

        // copy formats
        for (int k=iBegin; k<iTheirFormats; k++)
        {
            pTheirFormat = static_cast<CRTPFormat*>(pTheirMedia->m_pFormats[k]);

            // new one format
            if (FAILED(hr = CRTPFormat::CreateInstance(
                    pOurMedia, pTheirFormat, &pComObjFormat
                    )))
            {
                LOG((RTC_ERROR, "%s create format. %x", __fxName));

                pOurMedia = pTheirMedia = NULL;
                continue;
            }

            // add format to the list
            pIntfFormat = static_cast<IRTPFormat*>((CRTPFormat*)pComObjFormat);

            if (!pOurMedia->m_pFormats.Add(pIntfFormat))
            {
                LOG((RTC_ERROR, "%s add format", __fxName));

                delete pComObjFormat;
                
                // no other way to retain the consistency of session
                continue;
            }
            else
            {
                pComObjFormat->RealAddRef();
            }

            pComObjFormat = NULL;
            pIntfFormat = NULL;
        }

        // final check if we copied any format
        if (pOurMedia->m_pFormats.GetSize() == 0)
        {
            LOG((RTC_ERROR, "%s no formats after copy", __fxName));

            // we must have problems during copy

            pOurMedia->Abandon();
            pOurMedia = pTheirMedia = NULL;

            continue;
        }

        //
        // check source
        //

        if (pOurMedia->m_Source != pTheirMedia->m_Source)
        {
            pOurMedia->m_Source = SDP_SOURCE_MERGED;
        }

    } // end of update a media

    // shall we add or abandon more medias

    if (iOur > iTheir)
    {
        // abandon medias
        for (int i=iTheir; i<iOur; i++)
        {
            pOurMedia = static_cast<CSDPMedia*>(m_pMedias[i]);

            pOurMedia->Abandon();
        }
    }
    else if (iOur < iTheir)
    {
        // add medias
        for (int i=iOur; i<iTheir; i++)
        {
            pTheirMedia = static_cast<CSDPMedia*>(ArrMedias[i]);

            // new one media
            if (FAILED(hr = CSDPMedia::CreateInstance(
                    this, pTheirMedia, &pComObjMedia
                    )))
            {
                LOG((RTC_ERROR, "%s create media. %x", __fxName));

                continue;
            }

            // add media to the list
            pIntfMedia = static_cast<ISDPMedia*>((CSDPMedia*)pComObjMedia);

            if (!m_pMedias.Add(pIntfMedia))
            {
                LOG((RTC_ERROR, "%s add media", __fxName));

                delete pComObjMedia;
                
                // no other way to retain the consistency of session
                continue;
            }
            else
            {
                pComObjMedia->RealAddRef();
            }
        }
    }
    // else iOur == iTheir

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    check the input session, return failure if input session is not valid
    if valid, pdwHasMedia returns the OR of preference of media that will be 
    created if the session to be update
////*/

STDMETHODIMP
CSDPSession::TryUpdate(
    IN ISDPSession *pSession,
    OUT DWORD *pdwHasMedia
    )
{
    ENTER_FUNCTION("CSDPSession::TryUpdate");

    CSDPSession *pObjSession = static_cast<CSDPSession*>(pSession);

    HRESULT hr;

    // validate the session
    if (S_OK != pObjSession->Validate())
    {
        LOG((RTC_ERROR, "%s validate", __fxName));

        return E_FAIL;
    }

    // check if media size correct
    int iOur = m_pMedias.GetSize();
    int iTheir = pObjSession->m_pMedias.GetSize();

    if (iOur > iTheir)
    {
        if (!(pObjSession->m_dwLooseMask & SDP_LOOSE_KEEPINGM0))
        {
            // have to keep m= lines with port 0
            LOG((RTC_ERROR, "%s keeping m0, current m= count %d, new %d",
                __fxName, iOur, iTheir));

            return E_FAIL;
        }
    }

    // check if each media type matches
    int iMin = iOur<iTheir?iOur:iTheir;

    CSDPMedia *pOurMedia, *pTheirMedia;

    for (int i=0; i<iMin; i++)
    {
        pOurMedia = static_cast<CSDPMedia*>(m_pMedias[i]);
        pTheirMedia = static_cast<CSDPMedia*>(pObjSession->m_pMedias[i]);

        // check media type
        if (pOurMedia->m_m_MediaType != pTheirMedia->m_m_MediaType)
        {
            LOG((RTC_ERROR, "%s our %dth media type not match",
                __fxName, i));

            return E_FAIL;
        }
    }

    // check if there is common format
    DWORD dwHasMedia = 0;
    CRTPFormat *pObjFormat;

    for (int i=0; i<iTheir; i++)
    {
        pTheirMedia = static_cast<CSDPMedia*>(pObjSession->m_pMedias[i]);

        //
        // check conn address
        //

        if (pTheirMedia->m_c_dwRemoteAddr == INADDR_NONE)
        {
            // not a valid remote addr
            continue;
        }

        //
        // check port
        //

        if (pTheirMedia->m_m_usRemotePort == 0)
        {
            // no port
            continue;
        }

        //
        // check media directions
        //

        if (pTheirMedia->m_a_dwLocalDirs == 0)
        {
            // no directions
            continue;
        }

        //
        // check formats
        //

        if (pTheirMedia->m_m_MediaType == RTC_MT_DATA)
        {
            // data media
            dwHasMedia |= RTC_MP_DATA_SENDRECV;
            continue;
        }

        int iTheirFormats = pTheirMedia->m_pFormats.GetSize();

        // check if there is format we support
        for (int j=0; j<iTheirFormats; j++)
        {
            pObjFormat = static_cast<CRTPFormat*>(pTheirMedia->m_pFormats[j]);

            if (CRTCCodec::IsSupported(
                    pObjFormat->m_Param.MediaType,
                    pObjFormat->m_Param.dwCode,
                    pObjFormat->m_Param.dwSampleRate,
                    pObjFormat->m_Param.pszName
                    ))
            {
                // support this format
                if (pTheirMedia->m_m_MediaType == RTC_MT_AUDIO)
                {
                    if (pTheirMedia->m_a_dwLocalDirs & RTC_MD_CAPTURE)
                        dwHasMedia |= RTC_MP_AUDIO_CAPTURE;
                    if (pTheirMedia->m_a_dwLocalDirs & RTC_MD_RENDER)
                        dwHasMedia |= RTC_MP_AUDIO_RENDER;
                }
                else if (pTheirMedia->m_m_MediaType == RTC_MT_VIDEO)            
                {
                    if (pTheirMedia->m_a_dwLocalDirs & RTC_MD_CAPTURE)
                        dwHasMedia |= RTC_MP_VIDEO_CAPTURE;
                    if (pTheirMedia->m_a_dwLocalDirs & RTC_MD_RENDER)
                        dwHasMedia |= RTC_MP_VIDEO_RENDER;
                }

                // no need to check other format
                break;
            }
        }
    } // for each media from the input session

    *pdwHasMedia = dwHasMedia;

    return S_OK;
}

STDMETHODIMP
CSDPSession::TryCopy(
    OUT DWORD *pdwHasMedia
    )
{
    ENTER_FUNCTION("CSDPSession::TryCopy");

    // validate the session
    if (S_OK != Validate())
    {
        LOG((RTC_ERROR, "%s validate", __fxName));

        return E_FAIL;
    }

    // check if there is common format
    DWORD dwHasMedia = 0;

    CSDPMedia *pObjMedia;
    CRTPFormat *pObjFormat;

    for (int i=0; i<m_pMedias.GetSize(); i++)
    {
        pObjMedia = static_cast<CSDPMedia*>(m_pMedias[i]);

        //
        // check conn address
        //

        if (pObjMedia->m_c_dwRemoteAddr == INADDR_NONE)
        {
            // not a valid remote addr
            continue;
        }

        //
        // check port
        //

        if (pObjMedia->m_m_usRemotePort == 0)
        {
            // no port
            continue;
        }

        //
        // check media directions
        //

        if (pObjMedia->m_a_dwLocalDirs == 0)
        {
            // no directions
            continue;
        }

        //
        // check formats
        //

        if (pObjMedia->m_m_MediaType == RTC_MT_DATA)
        {
            // data media
            dwHasMedia |= RTC_MP_DATA_SENDRECV;
            continue;
        }

        int iObjFormats = pObjMedia->m_pFormats.GetSize();

        // check if there is format we support
        for (int j=0; j<iObjFormats; j++)
        {
            pObjFormat = static_cast<CRTPFormat*>(pObjMedia->m_pFormats[j]);

            if (CRTCCodec::IsSupported(
                    pObjFormat->m_Param.MediaType,
                    pObjFormat->m_Param.dwCode,
                    pObjFormat->m_Param.dwSampleRate,
                    pObjFormat->m_Param.pszName
                    ))
            {
                // support this format
                if (pObjMedia->m_m_MediaType == RTC_MT_AUDIO)
                {
                    if (pObjMedia->m_a_dwLocalDirs & RTC_MD_CAPTURE)
                        dwHasMedia |= RTC_MP_AUDIO_CAPTURE;
                    if (pObjMedia->m_a_dwLocalDirs & RTC_MD_RENDER)
                        dwHasMedia |= RTC_MP_AUDIO_RENDER;
                }
                else if (pObjMedia->m_m_MediaType == RTC_MT_VIDEO)
                {
                    if (pObjMedia->m_a_dwLocalDirs & RTC_MD_CAPTURE)
                        dwHasMedia |= RTC_MP_VIDEO_CAPTURE;
                    if (pObjMedia->m_a_dwLocalDirs & RTC_MD_RENDER)
                        dwHasMedia |= RTC_MP_VIDEO_RENDER;
                }
            }
        }
    } // for each media

    *pdwHasMedia = dwHasMedia;

    return S_OK;
}

STDMETHODIMP
CSDPSession::SetLocalBitrate(
    IN DWORD dwBitrate
    )
{
    m_b_dwLocalBitrate = dwBitrate;

    return S_OK;
}

STDMETHODIMP
CSDPSession::GetRemoteBitrate(
    OUT DWORD *pdwBitrate
    )
{
    *pdwBitrate = m_b_dwRemoteBitrate;

    return S_OK;
}

//
// called when parsing is completed
//
VOID
CSDPSession::CompleteParse(
    IN DWORD_PTR *pDTMF
    )
{
    // analyze fmtp

    for (int i=0; i<m_pMedias.GetSize(); i++)
    {
        m_pMedias[i]->CompleteParse(pDTMF);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdptokencache.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPTokenCache.h

Abstract:


Author:

    Qianbo Huai (qhuai) 6-Sep-2000

--*/

#ifndef _SDPTOKENCACHE_H
#define _SDPTOKENCACHE_H

// list item for lines
typedef struct SDPLineItem
{
    LIST_ENTRY          Link;
    DWORD               dwIndex;    // of g_SDPLineStates[]
    CHAR                *pszLine;

} SDPLineItem;

// list item for tokens
typedef struct SDPTokenItem
{
    LIST_ENTRY          Link;
    CHAR                *pszToken;

} SDPTokenItem;

class CSDPTokenCache
{
public:

    CSDPTokenCache(
        IN CHAR *pszString,
        IN DWORD dwLooseMask,
        OUT HRESULT *pHr
        );

    ~CSDPTokenCache();

    // set back error code
    HRESULT SetErrorDesp(
        IN const CHAR * const pszError,
        ...
        );

    // get error description
    CHAR * const GetErrorDesp();

    // move to next line
    HRESULT NextLine();

    UCHAR GetLineType();

    // get current line (may not be the complete line)
    CHAR * const GetLine();

    // get current token
    HRESULT NextToken(
        OUT CHAR **ppszToken
        );

    HRESULT NextToken(
        OUT USHORT *pusToken
        );

    HRESULT NextToken(
        OUT UCHAR *pucToken
        );

    HRESULT NextToken(
        OUT ULONG *pulToken
        );

protected:

    // break a string into lines
    HRESULT StringToLines(
        IN CHAR *pszString
        );

    // put a line string into the list
    HRESULT LineIntoList(
        IN CHAR *pszString,
        IN DWORD dwFirst,
        IN DWORD dwLast
        );

    // break a line into tokens
    HRESULT LineToTokens(
        IN SDPLineItem *pItem
        );

    HRESULT TokenIntoList(
        IN CHAR *pszString,
        IN DWORD dwFirst,
        IN DWORD dwLast
        );

    // free the line list
    void FreeLineItem(
        IN SDPLineItem *pItem
        );

    void FreeLines();

    // free the token list
    void FreeTokenItem(
        IN SDPTokenItem *pItem
        );

    void FreeTokens();

    void ClearErrorDesp();

protected:

    // loose mask
    DWORD                           m_dwLooseMask;

    // break sdp blob into a list of lines
    LIST_ENTRY                      m_LineEntry;

    // break current line into a list of tokens
    LIST_ENTRY                      m_TokenEntry;

#define SDP_MAX_ERROR_DESP_LEN  128

    CHAR                            m_pszErrorDesp[SDP_MAX_ERROR_DESP_LEN+1];

#define SDP_MAX_LINE_LEN        128

    CHAR                            m_pszCurrentLine[SDP_MAX_LINE_LEN+1];
    DWORD                           m_dwCurrentLineIdx;

#define SDP_MAX_TOKEN_LEN       128

    CHAR                            m_pszCurrentToken[SDP_MAX_TOKEN_LEN+1];
};

#endif // _SDPTOKENCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\stream.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Stream.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

static DWORD gTotalStreamRefcount = 0;

/*//////////////////////////////////////////////////////////////////////////////
    create a stream object based on media type and direciton
////*/

HRESULT
CRTCStream::CreateInstance(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    OUT IRTCStream **ppIStream
    )
{
    ENTER_FUNCTION("CRTCStream::CreateInstance");

    HRESULT hr;
    IRTCStream *pIStream = NULL;

    if (MediaType == RTC_MT_AUDIO && Direction == RTC_MD_CAPTURE)
    {
        // audio send
        CComObject<CRTCStreamAudSend> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create audio capture. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCStream), (void**)&pIStream)))
        {
            LOG((RTC_ERROR, "%s query intf on audio capture. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else if (MediaType == RTC_MT_AUDIO && Direction == RTC_MD_RENDER)
    {
        // audio receive
        CComObject<CRTCStreamAudRecv> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create audio receive. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCStream), (void**)&pIStream)))
        {
            LOG((RTC_ERROR, "%s query intf on audio receive. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else if (MediaType == RTC_MT_VIDEO && Direction == RTC_MD_CAPTURE)
    {
        // audio send
        CComObject<CRTCStreamVidSend> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create video capture. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCStream), (void**)&pIStream)))
        {
            LOG((RTC_ERROR, "%s query intf on video capture. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else if (MediaType == RTC_MT_VIDEO && Direction == RTC_MD_RENDER)
    {
        // audio receive
        CComObject<CRTCStreamVidRecv> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create video receive. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCStream), (void**)&pIStream)))
        {
            LOG((RTC_ERROR, "%s query intf on video receive. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else
        return E_NOTIMPL;

    *ppIStream = pIStream;

    return S_OK;

}

/*//////////////////////////////////////////////////////////////////////////////
    static filter graph event callback method
////*/
VOID NTAPI
CRTCStream::GraphEventCallback(
    IN PVOID pStream,
    IN BOOLEAN fTimerOrWaitFired
    )
{
//    LOG((RTC_GRAPHEVENT, "GraphEventCallback: stream=%p, flag=%d", pStream, fTimerOrWaitFired));

    HRESULT hr = ((IRTCStream*)pStream)->ProcessGraphEvent();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "GraphEventCallback failed to process. %x", hr));
    }
}

CRTCStream::CRTCStream()
    :m_State(RTC_SS_CREATED)
    // media
    ,m_pMedia(NULL)
    ,m_pISDPMedia(NULL)
    // media manage
    ,m_pMediaManagePriv(NULL)
    ,m_pTerminalManage(NULL)
    // terminal
    ,m_pTerminal(NULL)
    ,m_pTerminalPriv(NULL)
    // filter graph
    ,m_pIGraphBuilder(NULL)
    ,m_pIMediaEvent(NULL)
    ,m_pIMediaControl(NULL)
    // stream timeout?
    ,m_fMediaTimeout(FALSE)
    // rtp filter
    ,m_rtpf_pIBaseFilter(NULL)
    ,m_rtpf_pIRtpSession(NULL)
    ,m_rtpf_pIRtpMediaControl(NULL)
    ,m_fRTPSessionSet(FALSE)
    // edge filter
    ,m_edgf_pIBaseFilter(NULL)
    ,m_edgp_pIStreamConfig(NULL)
    ,m_edgp_pIBitrateControl(NULL)
{
}

CRTCStream::~CRTCStream()
{
    if (m_State != RTC_SS_SHUTDOWN)
    {
        LOG((RTC_ERROR, "CRTCStream::~CRTCStream called w/o shutdown"));

        Shutdown();
    }
}

#ifdef DEBUG_REFCOUNT

ULONG
CRTCStream::InternalAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    gTotalStreamRefcount ++;

    LOG((RTC_REFCOUNT, "stream(%p) addref=%d (total=%d)",
         static_cast<IRTCStream*>(this), lRef, gTotalStreamRefcount));

    return lRef;
}

ULONG
CRTCStream::InternalRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();
    
    gTotalStreamRefcount --;

    LOG((RTC_REFCOUNT, "stream(%p) release=%d (total=%d)",
         static_cast<IRTCStream*>(this), lRef, gTotalStreamRefcount));

    return lRef;
}

#endif

//
// IRTCStream methods
//

/*//////////////////////////////////////////////////////////////////////////////
    remember media pointer
////*/
STDMETHODIMP
CRTCStream::Initialize(
    IN IRTCMedia *pMedia,
    IN IRTCMediaManagePriv *pMediaManagePriv
    )
{
    ENTER_FUNCTION("CRTCStream::Initialize");

    if (m_State != RTC_SS_CREATED)
    {
        LOG((RTC_ERROR, "init stream in wrong state %d", m_State));
        return E_UNEXPECTED;
    }

    // create filter graph object
    HRESULT hr = CoCreateInstance(
            CLSID_FilterGraph,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IGraphBuilder,
            (void **)&m_pIGraphBuilder
            );
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s failed to create graph. %x", __fxName, hr));
        return hr;
    }

    if (FAILED(hr = SetGraphClock()))
    {
        LOG((RTC_ERROR, "%s set graph clock. %x", __fxName, hr));
    }

    if (FAILED(hr = m_pIGraphBuilder->QueryInterface(
            __uuidof(IMediaEvent), (void **)&m_pIMediaEvent
            )))
    {
        LOG((RTC_ERROR, "%s failed to query media event. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = m_pIGraphBuilder->QueryInterface(
            __uuidof(IMediaControl), (void **)&m_pIMediaControl
            )))
    {
        LOG((RTC_ERROR, "%s failed to query media control. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = pMedia->GetSDPMedia(&m_pISDPMedia)))
    {
        LOG((RTC_ERROR, "%s get sdp media. %x", __fxName, hr));

        goto Error;
    }

    m_pMedia = pMedia;
    m_pMedia->AddRef();

    m_pMediaManagePriv = pMediaManagePriv;
    m_pMediaManagePriv->AddRef();

    // get quality control and reg setting
    m_pQualityControl =
    (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetQualityControl();

    _ASSERT(m_pQualityControl != NULL);

    m_pRegSetting =
    (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetRegSetting();

    _ASSERT(m_pRegSetting != NULL);

    // since all interfaces are internal, i am taking a shortcut here
    // to get the other interface
    m_pTerminalManage = static_cast<IRTCTerminalManage*>(
        static_cast<CRTCMediaController*>(pMediaManagePriv)
        );
    m_pTerminalManage->AddRef();

    m_State = RTC_SS_INITIATED;

    return S_OK;

Error:

    if (m_pIGraphBuilder)
    {
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;
    }

    if (m_pIMediaEvent)
    {
        m_pIMediaEvent->Release();
        m_pIMediaEvent = NULL;
    }

    if (m_pIMediaControl)
    {
        m_pIMediaControl->Release();
        m_pIMediaControl = NULL;
    }

    return hr;
}

STDMETHODIMP
CRTCStream::Shutdown()
{
    ENTER_FUNCTION("CRTCStream::Shutdown");
    LOG((RTC_TRACE, "%s entered", __fxName));

    if (m_State == RTC_SS_SHUTDOWN)
    {
        LOG((RTC_WARN, "stream shut was already called"));
        return E_UNEXPECTED;
    }
    
    CleanupGraph();

    // filter graph
    if (m_pIGraphBuilder)
    {
        m_pIGraphBuilder->Release();
        m_pIGraphBuilder = NULL;
    }

    if (m_pIMediaEvent)
    {
        m_pIMediaEvent->Release();
        m_pIMediaEvent = NULL;
    }

    if (m_pIMediaControl)
    {
        m_pIMediaControl->Release();
        m_pIMediaControl = NULL;
    }

    // media
    if (m_pISDPMedia)
    {
        m_pISDPMedia->Release();
        m_pISDPMedia = NULL;
    }

    if (m_pMedia)
    {
        m_pMedia->Release();
        m_pMedia = NULL;
    }

    // terminal
    if (m_pTerminal)
    {
        m_pTerminal->Release();
        m_pTerminal = NULL;
    }

    if (m_pTerminalPriv)
    {
        m_pTerminalPriv->ReinitializeEx();
        m_pTerminalPriv->Release();
        m_pTerminalPriv = NULL;
    }

    // rtp filter
    if (m_rtpf_pIBaseFilter)
    {
        m_rtpf_pIBaseFilter->Release();
        m_rtpf_pIBaseFilter = NULL;
    }

    if (m_rtpf_pIRtpSession)
    {
        DWORD dwLocalIP, dwRemoteIP;
        USHORT usLocalRTP, usLocalRTCP, usRemoteRTP, usRemoteRTCP;

        // release lease on NAT
        if ((S_OK == m_rtpf_pIRtpSession->GetAddress(&dwLocalIP, &dwRemoteIP)) &&
            (S_OK == m_rtpf_pIRtpSession->GetPorts(
                    &usLocalRTP,
                    &usRemoteRTP,
                    &usLocalRTCP,
                    &usRemoteRTCP)))
        {
            // convert back to our order
            dwLocalIP = ntohl(dwLocalIP);

            usLocalRTP = ntohs(usLocalRTP);
            usLocalRTCP = ntohs(usLocalRTCP);

            // get network pointer
            CNetwork *pNetwork =
            (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetNetwork();

            pNetwork->ReleaseMappedAddr2(dwLocalIP, usLocalRTP, usLocalRTCP, m_Direction);
        }

        m_rtpf_pIRtpSession->Release();
        m_rtpf_pIRtpSession = NULL;
    }

    if (m_rtpf_pIRtpMediaControl)
    {
        m_rtpf_pIRtpMediaControl->Release();
        m_rtpf_pIRtpMediaControl = NULL;
    }

    // media manage
    m_pQualityControl = NULL;
    m_pRegSetting = NULL;

    if (m_pMediaManagePriv)
    {
        m_pMediaManagePriv->Release();
        m_pMediaManagePriv = NULL;
    }

    if (m_pTerminalManage)
    {
        m_pTerminalManage->Release();
        m_pTerminalManage = NULL;
    }

    // adjust state
    m_State = RTC_SS_SHUTDOWN;

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    revise: now start stream does more than what the method name states.
    if a stream shouldn't in start state, it will be stopped.
////*/
STDMETHODIMP
CRTCStream::StartStream()
{
    ENTER_FUNCTION("CRTCStream::StartStream");

    LOG((RTC_TRACE, "%s stream=%p, md=%d, mt=%d",
         __fxName, static_cast<IRTCStream*>(this), m_MediaType, m_Direction));

    if (m_pIMediaControl == NULL)
    {
        LOG((RTC_ERROR, "%s no media control", __fxName));
        return E_UNEXPECTED;
    }

    // get filter state
    HRESULT hr;
    OAFilterState FilterState;

    if (FAILED(hr = m_pIMediaControl->GetState(0, &FilterState)))
    {
        LOG((RTC_ERROR, "% get filter state. %x", __fxName, hr));

        return hr;
    }

    // no need to run if no remote ports
    USHORT usPort = 0;
    DWORD dwAddr = 0;

    m_pISDPMedia->GetConnPort(SDP_SOURCE_REMOTE, &usPort);
    m_pISDPMedia->GetConnAddr(SDP_SOURCE_REMOTE, &dwAddr);

    // check if we need actually stop
    BOOL fShouldStop = FALSE;

    if (dwAddr == INADDR_ANY || dwAddr == INADDR_NONE)
    {
        // remote addr invalid
        fShouldStop = TRUE;
    }
    else
    {
        // remote addr is valid
        if (usPort == 0 || usPort == SDP_INVALID_USHORT_PORT)
        {
            if (m_Direction == RTC_MD_CAPTURE)
            {
                fShouldStop = TRUE;
            }
        }
    }
    
    if (fShouldStop)
    {
        // stream should be in stopped state

        m_State = RTC_SS_STOPPED;

        if (FilterState == State_Running)
        {
            // need to stop the stream

            LOG((RTC_TRACE, "%s is runing, need to stop it. port=%d, addr=%d",
                __fxName, usPort, dwAddr));

            if (FAILED(hr = m_pIMediaControl->Stop()))
            {
                LOG((RTC_ERROR, "%s failed to stop stream. %x", __fxName, hr));

                return hr;
            }
            else
            {
                if (dwAddr == INADDR_ANY)
                {
                    // on hold
                    m_pMediaManagePriv->PostMediaEvent(
                        RTC_ME_STREAM_INACTIVE,
                        RTC_ME_CAUSE_REMOTE_HOLD,
                        m_MediaType,
                        m_Direction,
                        S_OK
                        );
                }
                else
                {
                    // normal stop
                    m_pMediaManagePriv->PostMediaEvent(
                        RTC_ME_STREAM_INACTIVE,
                        RTC_ME_CAUSE_REMOTE_REQUEST,
                        m_MediaType,
                        m_Direction,
                        S_OK
                        );
                }
            }
        }

        return S_OK;
    }

    m_State = RTC_SS_STARTED;

    // no need to run if it was runing
    if (FilterState == State_Running)
    {
        return S_OK;
    }

    // enable AEC
    if (IsAECNeeded())
    {
        CRTCMedia *pObjMedia = static_cast<CRTCMedia*>(m_pMedia);

        if (pObjMedia->m_pIAudioDuplexController)
        {
            // release wave buffer
            hr = m_pMediaManagePriv->SendMediaEvent(RTC_ME_REQUEST_RELEASE_WAVEBUF);

            if (hr == S_OK)
            {
                ::EnableAEC(pObjMedia->m_pIAudioDuplexController);
            }
            else
            {
                LOG((RTC_ERROR, "%s failed to request releasing wave buffer. %x", __fxName, hr));
            }
        }
    }

    hr = m_pIMediaControl->Run();

    if (SUCCEEDED(hr))
    {
        m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_ACTIVE,
            RTC_ME_CAUSE_LOCAL_REQUEST,
            m_MediaType,
            m_Direction,
            S_OK
            );
    }
    else
    {
        LOG((RTC_ERROR, "%s: failed. %x", __fxName, hr));
    }

    return hr;
}

STDMETHODIMP
CRTCStream::StopStream()
{
    ENTER_FUNCTION("CRTCStream::StopStream");

    if (m_pIMediaControl == NULL)
    {
        LOG((RTC_ERROR, "%s no media control", __fxName));
        return E_UNEXPECTED;
    }

    m_State = RTC_SS_STOPPED;

    // check if we need to stop the stream
    HRESULT hr;
    OAFilterState FilterState;

    if (FAILED(hr = m_pIMediaControl->GetState(0, &FilterState)))
    {
        LOG((RTC_ERROR, "%s get graph state. %x", __fxName, hr));

        // stop it anyway
        if (FAILED(hr = m_pIMediaControl->Stop()))
        {
            LOG((RTC_ERROR, "%s stop stream. %x", __fxName, hr));
        }
    }
    else
    {
        if (FilterState != State_Stopped)
        {
            if (FAILED(hr = m_pIMediaControl->Stop()))
            {
                LOG((RTC_ERROR, "%s stop stream. %x", __fxName, hr));
            }
            else
            {
                // post stop stream event
                m_pMediaManagePriv->PostMediaEvent(
                    RTC_ME_STREAM_INACTIVE,
                    RTC_ME_CAUSE_LOCAL_REQUEST,
                    m_MediaType,
                    m_Direction,
                    S_OK
                    );
            }
        }
    }

    return hr;
}


STDMETHODIMP
CRTCStream::GetMediaType(
    OUT RTC_MEDIA_TYPE *pMediaType
    )
{
    *pMediaType = m_MediaType;
    return S_OK;
}

STDMETHODIMP
CRTCStream::GetDirection(
    OUT RTC_MEDIA_DIRECTION *pDirection
    )
{
    *pDirection = m_Direction;
    return S_OK;
}

STDMETHODIMP
CRTCStream::GetState(
    OUT RTC_STREAM_STATE *pState
    )
{
    ENTER_FUNCTION("CRTCStream::GetState");

    HRESULT hr;
    OAFilterState FilterState;

    *pState = m_State;

    // need to check whether the graph is really running
    if (m_pIMediaControl)
    {
        if (FAILED(hr = m_pIMediaControl->GetState(0, &FilterState)))
        {
            LOG((RTC_ERROR, "%s get graph state. %x", __fxName, hr));

            return hr;
        }

        if (FilterState == State_Running)
        {
            _ASSERT(m_State == RTC_SS_STARTED);

            if (m_State != RTC_SS_STARTED)
            {
                LOG((RTC_ERROR, "%s fatal inconsistent stream state. graph running. m_State=%x",
                     __fxName, m_State));

                // stop the stream
                m_pIMediaControl->Stop();

                return E_FAIL;
            }

            *pState = RTC_SS_RUNNING;
        }
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    return media pointer
////*/
STDMETHODIMP
CRTCStream::GetMedia(
    OUT IRTCMedia **ppMedia
    )
{
    *ppMedia = m_pMedia;

    if (m_pMedia != NULL)
    {
        m_pMedia->AddRef();
    }

    return S_OK;
}

STDMETHODIMP
CRTCStream::GetIMediaEvent(
    OUT LONG_PTR **ppIMediaEvent
    )
{
    *ppIMediaEvent = (LONG_PTR*)m_pIMediaEvent;

    if (m_pIMediaEvent != NULL)
    {
        m_pIMediaEvent->AddRef();
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    process graph event. the method executes in the context of thread pool
    thread context.
////*/

STDMETHODIMP
CRTCStream::ProcessGraphEvent()
{
    ENTER_FUNCTION("CRTCStream::ProcessGraphEvent");

    _ASSERT(m_State != RTC_SS_CREATED &&
            m_State != RTC_SS_SHUTDOWN);

    // get event
    LONG lEventCode;
    LONG_PTR lParam1, lParam2;

    HRESULT hr = m_pIMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);

    if (FAILED(hr))
    {
        LOG((RTC_GRAPHEVENT, "%s failed to get event. %x", __fxName, hr));
        return hr;
    }

    LOG((RTC_GRAPHEVENT, "%s: stream=%p, mt=%x, md=%x, event=%x, param1=%x, param2=%x",
         __fxName, static_cast<IRTCStream*>(this), m_MediaType, m_Direction,
         lEventCode, lParam1, lParam2));

    // process the event, no need to have a worker thread
    // do we need lock here? @@@
    hr = S_OK;

    switch(lEventCode)
    {
    case RTPRTP_EVENT_SEND_LOSSRATE:

        hr = m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_LOSSRATE,
            RTC_ME_CAUSE_LOSSRATE,
            m_MediaType,
            m_Direction,
            (HRESULT)lParam2
            );

        break;

    case RTPRTP_EVENT_BANDESTIMATION:

        hr = m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_BANDWIDTH,
            RTC_ME_CAUSE_BANDWIDTH,
            m_MediaType,
            m_Direction,
            (HRESULT)lParam2
            );

        break;

    case RTPPARINFO_EVENT_NETWORKCONDITION:

        hr = m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_NETWORK_QUALITY,
            RTC_ME_CAUSE_NETWORK_QUALITY,
            m_MediaType,
            m_Direction,
            RTPNET_GET_dwGLOBALMETRIC(lParam2)  // network quality metric
            );

        break;
    //case RTPRTP_EVENT_RECV_LOSSRATE:
        //hr = m_pMediaManagePriv->PostMediaEvent(
            //RTC_ME_LOSSRATE,
            //RTC_ME_CAUSE_LOSSRATE,
            //m_MediaType,
            //m_Direction,
            //(HRESULT)lParam2
            //);

        //break;

    case EC_COMPLETE:
    case EC_USERABORT:

        hr = m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_INACTIVE,
            RTC_ME_CAUSE_UNKNOWN,
            m_MediaType,
            m_Direction,
            S_OK
            );

        break;

    case EC_ERRORABORT:
    case EC_STREAM_ERROR_STOPPED:
    case EC_STREAM_ERROR_STILLPLAYING:
    case EC_ERROR_STILLPLAYING:

        hr = m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_FAIL,
            RTC_ME_CAUSE_UNKNOWN,
            m_MediaType,
            m_Direction,
            (HRESULT)lParam1
            );
        break;

    case RTPPARINFO_EVENT_TALKING:

        if (m_fMediaTimeout)
        {
            hr = m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_ACTIVE,
                RTC_ME_CAUSE_RECOVERED,
                m_MediaType,
                m_Direction,
                S_OK
                );

            m_fMediaTimeout = FALSE;
        }

        break;

    case RTPPARINFO_EVENT_STALL:

        if (!m_fMediaTimeout)
        {
            hr = m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_INACTIVE,
                RTC_ME_CAUSE_TIMEOUT,
                m_MediaType,
                m_Direction,
                S_OK
                );

            m_fMediaTimeout = TRUE;
        }

        break;

    case RTPRTP_EVENT_CRYPT_RECV_ERROR:
    case RTPRTP_EVENT_CRYPT_SEND_ERROR:

        if (lParam1 == 0)
        {
            // RTP failure
            hr = m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_FAIL,
                RTC_ME_CAUSE_CRYPTO,
                m_MediaType,
                m_Direction,
                (HRESULT)lParam2
                );
        }
        // else lParam1 == 1 // RTCP failure

        break;        

    default:

        LOG((RTC_GRAPHEVENT, "%s: event %x not processed", __fxName, lEventCode));
    }

    if (FAILED(hr))
    {
        LOG((RTC_GRAPHEVENT, "%s: failed to process event %x. hr=%x", __fxName, lEventCode, hr));
    }

    // RtcFree resources allocated in event
    HRESULT hr2 = m_pIMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);

    if (FAILED(hr2))
    {
        LOG((RTC_GRAPHEVENT, "%s failed to RtcFree event params. %x", __fxName));
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    DTMF
////*/

STDMETHODIMP
CRTCStream::SendDTMFEvent(
    IN BOOL fOutOfBand,
    IN DWORD dwCode,
    IN DWORD dwId,
    IN DWORD dwEvent,
    IN DWORD dwVolume,
    IN DWORD dwDuration,
    IN BOOL fEnd
    )
{
    return E_NOTIMPL;
}

/*//////////////////////////////////////////////////////////////////////////////
    select terminal, build graph, setup rtp filter, setup format
////*/
STDMETHODIMP
CRTCStream::Synchronize()
{
    ENTER_FUNCTION("CRTCStream::Synchronize");
    LOG((RTC_TRACE, "%s entered. mt=%x, md=%x", __fxName, m_MediaType, m_Direction));

    HRESULT hr;

    // check the state
    if (m_State == RTC_SS_CREATED ||
        m_State == RTC_SS_SHUTDOWN)
    {
        LOG((RTC_ERROR, "%s in wrong state.", __fxName));
        return E_UNEXPECTED;
    }

    if (m_pTerminal)
    {
        // when terminal presents,
        // graph was built and interfaces were cached.
    }
    else
    {
        // select a terminal
        if (FAILED(hr = SelectTerminal()))
        {
            LOG((RTC_ERROR, "%s failed to select a terminal. %x", __fxName));

            return hr;
        }

        // build the filter graph and cache interfaces
        if (FAILED(hr = BuildGraph()))
        {
            LOG((RTC_ERROR, "%s failed to build graph. %x", __fxName, hr));

            // do not keep terminal selected
            UnselectTerminal();

            // post message
            m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_FAIL,
                RTC_ME_CAUSE_BAD_DEVICE,
                m_MediaType,
                m_Direction,
                hr
                );

            return hr;
        }
    }

    // configure rtp
    CPortCache &PortCache =
        (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetPortCache();

    if (PortCache.IsUpnpMapping())
    {
        // upnp mapping
        hr = SetupRTPFilter();
    }
    else
    {
        // port manager mapping
        hr = SetupRTPFilterUsingPortManager();
    }

    if (FAILED(hr))
    {
        // failed to setup rtp
        LOG((RTC_ERROR, "%s failed to setup rtp. %x", __fxName, hr));

        CleanupGraph();
        UnselectTerminal();

        // post message
        m_pMediaManagePriv->PostMediaEvent(
            RTC_ME_STREAM_FAIL,
            RTC_ME_CAUSE_UNKNOWN,
            m_MediaType,
            m_Direction,
            hr
            );

        return hr;
    }

    m_pISDPMedia->ResetConnChanged();

    // configure format and update sdp media
    // if (S_OK == m_pISDPMedia->IsFmtChanged(m_Direction))

    // always update format
    {
        if (FAILED(hr = SetupFormat()))
        {
            LOG((RTC_ERROR, "%s failed to setup format. %x", __fxName, hr));

            CleanupGraph();
            UnselectTerminal();

            // post message
            m_pMediaManagePriv->PostMediaEvent(
                RTC_ME_STREAM_FAIL,
                RTC_ME_CAUSE_UNKNOWN,
                m_MediaType,
                m_Direction,
                hr
                );

            return hr;
        }
        else
        {
            // clean up format changed flag
            m_pISDPMedia->ResetFmtChanged(m_Direction);
        }

        // enable participant events
        if (FAILED(hr = EnableParticipantEvents()))
        {
            LOG((RTC_ERROR, "%s failed to enable participant info. %x", __fxName, hr));
        }

        // format changed, setup qos as well
        if (FAILED(hr = SetupQoS()))
        {
            LOG((RTC_WARN, "%s failed to SetupQos. %x", __fxName, hr));
        }
    }

    // set redundant
    // SetupRedundancy();

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}

STDMETHODIMP
CRTCStream::ChangeTerminal(
    IN IRTCTerminal *pTerminal
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRTCStream::GetCurrentBitrate(
    IN DWORD *pdwBitrate,
    IN BOOL fHeader
    )
{
    if (m_edgp_pIBitrateControl == NULL)
    {
        return E_NOTIMPL;
    }

    TAPIControlFlags lFlags;

    HRESULT hr = m_edgp_pIBitrateControl->Get(
        BitrateControl_Current, (LONG*)pdwBitrate, &lFlags, 0);

    if (FAILED(hr))
    {
        return hr;
    }

    if (fHeader)
    {
        // include header
        if (m_MediaType == RTC_MT_AUDIO)
        {
            // get packet duration
            if (m_edgp_pIStreamConfig)
            {
                AM_MEDIA_TYPE *pmt;
                DWORD dwCode;

                // get stream caps
                hr = m_edgp_pIStreamConfig->GetFormat(
                    &dwCode, &pmt
                    );

                if (FAILED(hr))
                {
                    LOG((RTC_ERROR, "getcurrentbitrate getstreamcaps. %x", hr));

                    return hr;
                }

                // duration
                DWORD dwDuration = 0;

                dwDuration = CRTCCodec::GetPacketDuration(pmt);

                ::RTCDeleteMediaType(pmt);

                if (dwDuration == 0)
                {
                    dwDuration = SDP_DEFAULT_AUDIO_PACKET_SIZE;
                }

                *pdwBitrate += PACKET_EXTRA_BITS * (1000/dwDuration);
            }
        }
        else // video
        {
            _ASSERT(m_MediaType == RTC_MT_VIDEO);

            // get framerate
            DWORD dwFrameRate = 0;

            if (m_Direction == RTC_MD_CAPTURE)
            {
                (static_cast<CRTCStreamVidSend*>(this))->GetFramerate(&dwFrameRate);
            }
            else
            {
                (static_cast<CRTCStreamVidRecv*>(this))->GetFramerate(&dwFrameRate);
            }

            if (dwFrameRate == 0)
                dwFrameRate = 5; // default to 5

            //LOG((RTC_TRACE, "FRAMERATE %d", dwFrameRate));

            *pdwBitrate += PACKET_EXTRA_BITS * dwFrameRate;
        }
    }

    return S_OK;
}

STDMETHODIMP
CRTCStream::SetEncryptionKey(
    IN BSTR Key
    )
{
    ENTER_FUNCTION("CRTCStream::SetEncryptionKey");

    if (m_rtpf_pIRtpSession == NULL)
    {
        LOG((RTC_ERROR, "%s rtpsession null", __fxName));
        return E_UNEXPECTED;
    }

    // we do not support null key yet
    if (Key == NULL)
    {
        LOG((RTC_ERROR, "%s null key", __fxName));
        return E_INVALIDARG;
    }

    HRESULT hr;

    // set mode
    if (FAILED(hr = m_rtpf_pIRtpSession->SetEncryptionMode(
            RTPCRYPTMODE_RTP,
            RTPCRYPT_SAMEKEY
            )))
    {
        LOG((RTC_ERROR, "%s SetEncryptionMode %x", __fxName, hr));
        return hr;
    }

    // set key
    if (FAILED(hr = m_rtpf_pIRtpSession->SetEncryptionKey(
            Key,
            NULL,   // MD5 hash algorithm
            NULL,   // DES encrypt algorithm
            FALSE   // no RTCP encryption
            )))
    {
        LOG((RTC_ERROR, "%s SetEncryptionKey %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

// network quality: [0, 100].
// higher value better quality
STDMETHODIMP
CRTCStream::GetNetworkQuality(
    OUT DWORD *pdwValue,
    OUT DWORD *pdwAge
    )
{
    if (m_rtpf_pIRtpSession == NULL)
    {
        // no rtp session yet
        *pdwValue = 0;

        return S_FALSE;
    }

    RtpNetInfo_t info;

    HRESULT hr = m_rtpf_pIRtpSession->GetNetworkInfo(-1, &info);

    if (FAILED(hr))
    {
        return hr;
    }

    *pdwValue = info.dwNetMetrics;
    *pdwAge = (DWORD)(info.dMetricAge);

    return S_OK;
}

#if 0
//
// IRTCStreamQualityControl methods
//

STDMETHODIMP
CRTCStream::GetRange(
    IN RTC_STREAM_QUALITY_PROPERTY Property,
    OUT LONG *plMin,
    OUT LONG *plMax,
    OUT RTC_QUALITY_CONTROL_MODE *pMode
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRTCStream::Get(
    IN RTC_STREAM_QUALITY_PROPERTY Property,
    OUT LONG *plValue,
    OUT RTC_QUALITY_CONTROL_MODE *pMode
    )
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRTCStream::Set(
    IN RTC_STREAM_QUALITY_PROPERTY Property,
    IN LONG lValue,
    IN RTC_QUALITY_CONTROL_MODE Mode
    )
{
    return E_NOTIMPL;
}

#endif

//
// protected methods
//

HRESULT
CRTCStream::SetGraphClock()
{
    HRESULT hr;

    // create the clock object first.
    CComObject<CRTCStreamClock> *pClock = NULL;

    hr = ::CreateCComObjectInstance(&pClock);

    if (pClock == NULL)
    {
        LOG((RTC_ERROR, "SetGraphClock Could not create clock object, %x", hr));

        return hr;
    }

    IReferenceClock* pIReferenceClock = NULL;

    hr = pClock->_InternalQueryInterface(
        __uuidof(IReferenceClock), 
        (void**)&pIReferenceClock
        );
    
    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "SetGraphClock query pIReferenceClock interface failed, %x", hr));

        delete pClock;
        return hr;
    }

    // Get the graph builder interface on the graph.
    IMediaFilter *pFilter;
    hr = m_pIGraphBuilder->QueryInterface(IID_IMediaFilter, (void **) &pFilter);

    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "get IFilter interface, %x", hr));
        pIReferenceClock->Release();
        return hr;
    }

    hr = pFilter->SetSyncSource(pIReferenceClock);

    pIReferenceClock->Release();
    pFilter->Release();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "SetGraphClock: SetSyncSource. %x", hr));
        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    cleanup filters in graph and release all filters except rtp
    because two streams in the same media share rtp session.
////*/

void
CRTCStream::CleanupGraph()
{
    ENTER_FUNCTION("CRTCStream::CleanupGraph");

    LOG((RTC_TRACE, "%s mt=%d, md=%d, this=%p", __fxName, m_MediaType, m_Direction, this));

    // stop stream if necessary
    HRESULT hr;
    
    if (m_pIMediaControl)
    {
        if (FAILED(hr = StopStream()))
        {
            LOG((RTC_ERROR, "%s stop stream. %x", __fxName, hr));
        }
    }

    // disconnect terminal with graph
    if (m_pTerminalPriv)
        m_pTerminalPriv->DisconnectTerminal();

    // release other (than terminal) filters in the graph
    for(;m_pIGraphBuilder;)
    {
        // Because the enumerator is invalid after removing a filter from
        // the graph, we have to try to get all the filters in one shot.
        // If there are still more, we loop again.

        // Enumerate the filters in the graph.
        CComPtr<IEnumFilters>pEnum;
        hr = m_pIGraphBuilder->EnumFilters(&pEnum);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "cleanup filters, enumfilters failed: %x", hr));
            break;
        }

        const DWORD MAXFILTERS = 40;
        IBaseFilter * Filters[MAXFILTERS];
        DWORD dwFetched;
    
        hr = pEnum->Next(MAXFILTERS, Filters, &dwFetched);
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "get next filter failed: %x", hr));
            break;
        }

        for (DWORD i = 0; i< dwFetched; i ++)
        {
            m_pIGraphBuilder->RemoveFilter(Filters[i]);
            Filters[i]->Release();
        }

        if (hr != S_OK)
            break;
    }

    // edge filter
    if (m_edgf_pIBaseFilter)
    {
        m_edgf_pIBaseFilter->Release();
        m_edgf_pIBaseFilter = NULL;
    }

    if (m_edgp_pIStreamConfig)
    {
        m_edgp_pIStreamConfig->Release();
        m_edgp_pIStreamConfig = NULL;
    }

    if (m_edgp_pIBitrateControl)
    {
        m_edgp_pIBitrateControl->Release();
        m_edgp_pIBitrateControl = NULL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    select the default terminal for this stream
////*/

HRESULT
CRTCStream::SelectTerminal()
{
    ENTER_FUNCTION("CRTCStream::SelectTerminal");

    if (m_pTerminal)
    {
        // already got a terminal
        _ASSERT(m_pTerminalPriv != NULL);
        return S_OK;
    }
    else
    {
        _ASSERT(m_pTerminalPriv == NULL);
    }

    // get the default terminal
    HRESULT hr;

    hr = m_pTerminalManage->GetDefaultTerminal(m_MediaType, m_Direction, &m_pTerminal);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get default terminal. %x", __fxName, hr));
        return hr;
    }

    if (m_pTerminal == NULL)
    {
        LOG((RTC_ERROR, "%s no default terminal.", __fxName));

        return RTCMEDIA_E_DEFAULTTERMINAL;
    }

    // get private interface
    // this is not public API. take a shortcut

    m_pTerminalPriv = static_cast<IRTCTerminalPriv*>(
        static_cast<CRTCTerminal*>(m_pTerminal));

    m_pTerminalPriv->AddRef();

    // reinitialize terminal

    //
    // this is needed to cleanup duplex controller for audio device
    //

    m_pTerminalPriv->ReinitializeEx();

    return S_OK;
}

HRESULT
CRTCStream::UnselectTerminal()
{
    ENTER_FUNCTION("CRTCStream::UnselectTerminal");

    _ASSERT(m_pTerminal != NULL);
    _ASSERT(m_pTerminalPriv != NULL);

    m_pTerminal->Release();
    m_pTerminalPriv->Release();

    m_pTerminal = NULL;
    m_pTerminalPriv = NULL;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    configure format

    step 1. get two list of formats
            sdp media contains a list of rtp formats: X
            the edge filter provides a list of formats: Y

    step 2. check if formats are not set: sdpmedia is local and there is no format
            if not set, copy Y to sdp media
            return

    step 3. remove those formats from X if they are not in Y.
            if no format left, return failure

////*/
void
AdjustFormatOrder(
    IN CRegSetting *pRegSetting,
    IN RTP_FORMAT_PARAM *Params,
    IN DWORD dwNum
    )
{
    if (dwNum == 0)
    {
        return;
    }

    if (!pRegSetting->UsePreferredCodec())
    {
        // no need to adjust
        return;
    }

    DWORD dwValue;

    // query preferred codec
    if (Params[0].MediaType == RTC_MT_AUDIO)
    {
        dwValue = pRegSetting->PreferredAudioCodec();
    }
    else
    {
        dwValue = pRegSetting->PreferredVideoCodec();
    }

    // check if we support preferred codec
    for (DWORD i=0; i<dwNum; i++)
    {
        if (Params[i].dwCode == dwValue)
        {
            if (i==0) break;

            // switch: make preferred codec the 1st
            RTP_FORMAT_PARAM param;

            param = Params[0];
            Params[0] = Params[i];
            Params[i] = param;

            break;
        }
    }
}

HRESULT
CRTCStream::SetupFormat()
{
    ENTER_FUNCTION("CRTCStream::SetupFormat");

    LOG((RTC_TRACE, "%s entered. stream=%p",
         __fxName, static_cast<IRTCStream*>(this)));

    HRESULT hr;

    // list of formats from edge filter
    RTP_FORMAT_PARAM Params[SDP_MAX_RTP_FORMAT_NUM];
    DWORD dwParamNum = 0;

    // remove format not allowed by link speed
    DWORD dwLocalIP = INADDR_NONE;
    m_pISDPMedia->GetConnAddr(SDP_SOURCE_LOCAL, &dwLocalIP);

    DWORD dwSpeed;
    if (FAILED(hr = ::GetLinkSpeed(dwLocalIP, &dwSpeed)))
    {
        LOG((RTC_ERROR, "%s get link speed. %x", __fxName, hr));
        dwSpeed = (DWORD)(-1);
    }

    // record local link speed
    m_pQualityControl->SetBitrateLimit(CQualityControl::LOCAL, dwSpeed);

    // retrieve formats from the edge filter
    hr = GetFormatListOnEdgeFilter(
        dwSpeed,
        Params,
        SDP_MAX_RTP_FORMAT_NUM,
        &dwParamNum
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get supported format. %x", __fxName, hr));
        return hr;
    }

    if (dwParamNum == 0)
    {
        LOG((RTC_ERROR, "%s no format on edge filter.", __fxName));

        return E_FAIL;
    }

    AdjustFormatOrder(m_pRegSetting, Params, dwParamNum);

    // get num of format from sdpmedia
    DWORD dwFormatNum = 0;

    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwFormatNum, NULL)))
    {
        LOG((RTC_ERROR, "%s get rtp formats num. %x", __fxName, hr));

        return hr;
    }

    if (dwFormatNum == 0)
    {
        // check media source,
        // if local and format num is zero, then format has not been set yet
        SDP_SOURCE Source = SDP_SOURCE_REMOTE;

        m_pISDPMedia->GetSDPSource(&Source);

        if (Source == SDP_SOURCE_LOCAL)
        {
            // copy format
            IRTPFormat *pFormat = NULL;

            for(DWORD i=0; i<dwParamNum; i++)
            {
                if (FAILED(hr = m_pISDPMedia->AddFormat(&Params[i], &pFormat)))
                {
                    LOG((RTC_ERROR, "%s add format. %x", __fxName, hr));

                    return hr;
                }
                else
                {
                    pFormat->Release();
                    pFormat = NULL;
                }

            } // end of copying format
        }
        else
        {
            LOG((RTC_ERROR, "%s no format on sdpmedia", __fxName));

            return E_FAIL;
        }
    }
    else
    {
        // check and remove unsupported format from sdpmedia

        if (dwFormatNum > SDP_MAX_RTP_FORMAT_NUM)
        {
            // can't take all rtp formats
            dwFormatNum = SDP_MAX_RTP_FORMAT_NUM;
        }

        // really get formats
        IRTPFormat *Formats[SDP_MAX_RTP_FORMAT_NUM];

        if (FAILED(hr = m_pISDPMedia->GetFormats(&dwFormatNum, Formats)))
        {
            LOG((RTC_ERROR, "%s get sdp formats. %x", __fxName, hr));

            return hr;
        }

        BOOL fSupported;
        for (DWORD i=0; i<dwFormatNum; i++)
        {
            fSupported = FALSE;

            // check if the sdpmedia format is supported
            for (DWORD j=0; j<dwParamNum; j++)
            {
                if (S_OK == Formats[i]->IsParamMatch(&Params[j]))
                {
                    // require dynamic payload has rtpmap
                    if (Params[j].dwCode<96 || Formats[i]->HasRtpmap()==S_OK)
                    {
                        // got a match
                        fSupported = TRUE;
                        Formats[i]->Update(&Params[j]);

                        break;
                    }
                }
            }

            if (!fSupported)
            {
                // release the count on session
                Formats[i]->Release();

                // really release the format
                m_pISDPMedia->RemoveFormat(Formats[i]);

                Formats[i] = NULL;
            }
            else
            {
                Formats[i]->Release();
                Formats[i] = NULL;
            }
        }
    }

    // set default format mapping
    if (FAILED(hr = SetFormatOnRTPFilter()))
    {
        LOG((RTC_ERROR, "%s set format mapping. %x", __fxName, hr));

        return hr;
    }

    LOG((RTC_TRACE, "%s exiting", __fxName));

    return S_OK;
}


/*//////////////////////////////////////////////////////////////////////////////
    configure rtp filter
////*/

HRESULT
CRTCStream::SetupRTPFilter()
{
    ENTER_FUNCTION("CRTCStream::SetupRTPFilter");

    LOG((RTC_TRACE, "%s stream=%p, mt=%d, md=%d", __fxName, this, m_MediaType, m_Direction));

    HRESULT hr;

    // setup session
    CRTCMedia *pCMedia = static_cast<CRTCMedia*>(m_pMedia);

    // get connection address and port
    DWORD dwRemoteIP, dwLocalIP;
    USHORT usRemoteRTP, usLocalRTP, usRemoteRTCP, usLocalRTCP;

    m_pISDPMedia->GetConnAddr(SDP_SOURCE_REMOTE, &dwRemoteIP);
    m_pISDPMedia->GetConnAddr(SDP_SOURCE_LOCAL, &dwLocalIP);
    m_pISDPMedia->GetConnPort(SDP_SOURCE_REMOTE, &usRemoteRTP);
    m_pISDPMedia->GetConnPort(SDP_SOURCE_LOCAL, &usLocalRTP);
    m_pISDPMedia->GetConnRTCP(SDP_SOURCE_REMOTE, &usRemoteRTCP);

    // setup address
    if (dwRemoteIP == INADDR_NONE)
    {
        LOG((RTC_WARN, "%s: remote ip not valid", __fxName));

        return S_FALSE;
    }

    if (dwRemoteIP == INADDR_ANY)
    {
        LOG((RTC_TRACE, "%s: to hold. skip setup rtp filter", __fxName));

        return S_OK;
    }

    CNetwork *pNetwork = NULL;
    BOOL bInternal = TRUE;

    // check if remote ip, port and rtcp are actually internally addr
    DWORD dwRealIP = dwRemoteIP;
    USHORT usRealPort = usRemoteRTP;
    USHORT usRealRTCP = usRemoteRTCP;

    pNetwork =
    (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetNetwork();

    // check remote rtp
    if (FAILED(hr = pNetwork->GetRealAddrFromMapped(
                dwRemoteIP,
                usRemoteRTP,
                &dwRealIP,
                &usRealPort,
                &bInternal     // internal address
                )))
    {
        LOG((RTC_ERROR, "%s get real addr. %x", __fxName, hr));

        return hr;
    }

    if (usRemoteRTP == 0)
    {
        // revert to port 0
        usRealPort = 0;
    }

    // check remote rtcp
    if (FAILED(hr = pNetwork->GetRealAddrFromMapped(
            dwRemoteIP,
            usRemoteRTCP,
            &dwRealIP,
            &usRealRTCP,
            &bInternal
            )))
    {
        LOG((RTC_ERROR, "%s get real rtcp. %x", __fxName, hr));

        return hr;
    }

    if (usRemoteRTCP == 0)
    {
        // revert to port 0
        usRealRTCP = 0;
    }

    // save address back
    dwRemoteIP = dwRealIP;
    usRemoteRTP = usRealPort;
    usRemoteRTCP= usRealRTCP;

    // do we need to select local interface?
    if (dwLocalIP == INADDR_NONE)
    {
        if (FAILED(hr = m_pMediaManagePriv->SelectLocalInterface(
                dwRemoteIP, &dwLocalIP)))
        {
            LOG((RTC_ERROR, "%s select local intf on remote %x. %x",
                 __fxName, dwRemoteIP, hr));

            return hr;
        }

        usLocalRTP = SDP_INVALID_USHORT_PORT;
    }
    else
    {
        if (usLocalRTP == SDP_INVALID_USHORT_PORT)
        {
            LOG((RTC_ERROR, "%s local ip=%x, port=%d", __fxName, dwLocalIP, usLocalRTP));

            return E_UNEXPECTED;
        }
    }

    // if port is 0 then set it to USHORT(-1) which is invalid to rtp filter

    if (usRemoteRTP == 0)
        usRemoteRTP = SDP_INVALID_USHORT_PORT;

    if (usLocalRTP == 0)
        usLocalRTP = SDP_INVALID_USHORT_PORT;

    // set ports
    if (usLocalRTP == SDP_INVALID_USHORT_PORT)
    {
        // no local port
        usLocalRTCP = SDP_INVALID_USHORT_PORT;
    }
    else
    {
        usLocalRTCP = usLocalRTP+1;
    }

    if (usRemoteRTP == SDP_INVALID_USHORT_PORT)
    {
        // no local port
        usRemoteRTCP = SDP_INVALID_USHORT_PORT;
    }
    else
    {
        // usRemoteRTCP = usRemoteRTP+1;
    }

    BOOL bFirewall = (static_cast<CRTCMediaController*>
            (m_pMediaManagePriv))->IsFirewallEnabled(dwLocalIP);

    // remember session cookie status
    BOOL fCookieWasNULL = pCMedia->m_hRTPSession==NULL?TRUE:FALSE;
    int iRetryCount = m_pRegSetting->PortMappingRetryCount();

    // store the value here for retry.
    // if i have chance, i will rewrite this piece.
    USHORT saveRemoteRTP = usRemoteRTP;
    USHORT saveRemoteRTCP = usRemoteRTCP;
    USHORT saveLocalRTP = usLocalRTP;
    USHORT saveLocalRTCP = usLocalRTCP;

    for (int i=0; i<iRetryCount; i++)
    {
        if (!m_fRTPSessionSet)
        {
            DWORD dwFlags = RTPINIT_ENABLE_QOS;

            switch(m_MediaType)
            {
            case RTC_MT_AUDIO:

                dwFlags |= RTPINIT_CLASS_AUDIO;
                break;

            case RTC_MT_VIDEO:

                dwFlags |= RTPINIT_CLASS_VIDEO;
                break;

            default:

                return E_NOTIMPL;
            }

            // init session cookie

            if (FAILED(hr = m_rtpf_pIRtpSession->Init(&pCMedia->m_hRTPSession, dwFlags)))
            {
                LOG((RTC_ERROR, "%s failed to init rtp session. %x", __fxName, hr));
                return hr;
            }

            m_fRTPSessionSet = TRUE;
        }

        //
        // now we have copy of remote addr/port, local addr. and possibly local port
        //

        // address
        if (FAILED(hr = m_rtpf_pIRtpSession->SetAddress(
                htonl(dwLocalIP),
                htonl(dwRemoteIP))))
        {
            LOG((RTC_ERROR, "%s failed to set addr. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = m_rtpf_pIRtpSession->SetPorts(
                htons(usLocalRTP),      // local rtp
                htons(usRemoteRTP),     // remote rtp
                htons(usLocalRTCP),     // local rtcp
                htons(usRemoteRTCP)     // remote rtcp
                )))
        {
            LOG((RTC_ERROR, "%s failed to set ports. %x", __fxName, hr));
            return hr;
        }

        // force rtp to bind the socket
        if (FAILED(hr = m_rtpf_pIRtpSession->GetPorts(
                &usLocalRTP,
                &usRemoteRTP,
                &usLocalRTCP,
                &usRemoteRTCP
                )))
        {
            LOG((RTC_ERROR, "%s get back ports. %x", __fxName, hr));
            return hr;
        }

        // convert back to our order
        usLocalRTP = ntohs(usLocalRTP);
        usLocalRTCP = ntohs(usLocalRTCP);
        usRemoteRTP = ntohs(usRemoteRTP);
        usRemoteRTCP = ntohs(usRemoteRTCP);

        // lease
        if (!bInternal || bFirewall)
        {
            LOG((RTC_TRACE, "To lease mapping from NAT. internal=%d. firewall=%d",
                bInternal, bFirewall));

            DWORD dw;

            USHORT usMappedRTP = 0;
            USHORT usMappedRTCP = 0;

            hr = pNetwork->LeaseMappedAddr2(
                    dwLocalIP,
                    usLocalRTP,
                    usLocalRTCP,
                    m_Direction,
                    bInternal,
                    bFirewall,
                    &dw,
                    &usMappedRTP,
                    &usMappedRTCP);

            // retry when it was not the last iteration and
            // cookie was not set

            if (i<iRetryCount-1 &&
                fCookieWasNULL &&
                    (hr == DPNHERR_PORTUNAVAILABLE ||
                     (usMappedRTCP!=0 && usMappedRTCP!=usMappedRTP+1) ||
                     usMappedRTP%2 != 0))
            {
                LOG((RTC_WARN, "%s discard mapped (rtp,rtcp)=(%d,%d)",
                    __fxName, usMappedRTP, usMappedRTCP));

                // cleanup rtp session
                m_rtpf_pIRtpSession->Deinit();

                m_fRTPSessionSet = FALSE;

                // cleanup cookie
                pCMedia->m_hRTPSession = NULL;

                // release mapped address
                pNetwork->ReleaseMappedAddr2(dwLocalIP, usLocalRTP, usLocalRTCP, m_Direction);

                // restore ports
                usRemoteRTP = saveRemoteRTP;
                usRemoteRTCP = saveRemoteRTCP;
                usLocalRTP = saveLocalRTP;
                usLocalRTCP = saveLocalRTCP;

                continue;
            }

            if (FAILED(hr))
            {
                // other failure, we give up

                // release mapped address
                pNetwork->ReleaseMappedAddr2(dwLocalIP, usLocalRTP, usLocalRTCP, m_Direction);

                return hr;
            }
        }
        else
        {
            // no mapping needed

            // remote IP internal, release local map
            pNetwork->ReleaseMappedAddr2(dwLocalIP, usLocalRTP, usLocalRTCP, m_Direction);
        }

        break;        
    }

    //
    // save the addr back to media
    //

    m_pISDPMedia->SetConnAddr(SDP_SOURCE_LOCAL, dwLocalIP);
    m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, usLocalRTP);

    // tracing

    LOG((RTC_TRACE, " local %s:%d, %d",
        CNetwork::GetIPAddrString(dwLocalIP), usLocalRTP, usLocalRTCP));
    LOG((RTC_TRACE, "remote %s:%d",
        CNetwork::GetIPAddrString(dwRemoteIP), usRemoteRTP, usRemoteRTCP));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// Configure RTP filter. Query ports from port manager
//

HRESULT
CRTCStream::SetupRTPFilterUsingPortManager()
{
    ENTER_FUNCTION("CRTCStream::SetupRTPFilter-PM");

    LOG((RTC_TRACE, "%s stream=%p, mt=%d, md=%d", __fxName, this, m_MediaType, m_Direction));

    HRESULT hr;

    DWORD   dwRemoteIP,   dwLocalIP,    dwMappedIP;
    USHORT  usRemoteRTP,  usLocalRTP;
    USHORT  usRemoteRTCP, usLocalRTCP;

    // get remote addr
    m_pISDPMedia->GetConnAddr(SDP_SOURCE_REMOTE, &dwRemoteIP);
    m_pISDPMedia->GetConnPort(SDP_SOURCE_REMOTE, &usRemoteRTP);
    m_pISDPMedia->GetConnRTCP(SDP_SOURCE_REMOTE, &usRemoteRTCP);
    
    //
    // get addr and ports
    //

    CPortCache &PortCache =
        (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetPortCache();

    hr = PortCache.GetPort(
            m_MediaType,
            TRUE,           // rtp
            dwRemoteIP,     // remote
            &dwLocalIP,     // local
            &usLocalRTP,
            &dwMappedIP,    // mapped
            NULL
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get rtp port. %x", __fxName, hr));

        return hr;
    }

    DWORD dwLocal, dwMapped;

    hr = PortCache.GetPort(
            m_MediaType,
            FALSE,           // rtp
            dwRemoteIP,      // remote
            &dwLocal,        // local
            &usLocalRTCP,
            &dwMapped,       // mapped
            NULL
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get rtcp port. %x", __fxName, hr));

        // !!!??? release rtp port.
        PortCache.ReleasePort(m_MediaType, TRUE);
        return hr;
    }

    if (dwLocal != dwLocalIP || dwMapped != dwMappedIP)
    {
        // we are given different local ip for RTP and RTCP. bail out
        PortCache.ReleasePort(m_MediaType, TRUE);
        PortCache.ReleasePort(m_MediaType, FALSE);

        LOG((RTC_ERROR, "%s different local/mapped ip for rtp/rtcp", __fxName));

        return RTC_E_PORT_MAPPING_FAILED;
    }

    //
    // init rtp session
    //

    if (!m_fRTPSessionSet)
    {
        DWORD dwFlags = RTPINIT_ENABLE_QOS;

        switch(m_MediaType)
        {
        case RTC_MT_AUDIO:

            dwFlags |= RTPINIT_CLASS_AUDIO;
            break;

        case RTC_MT_VIDEO:

            dwFlags |= RTPINIT_CLASS_VIDEO;
            break;

        default:

            return E_NOTIMPL;
        }

        // init session cookie

        CRTCMedia *pCMedia = static_cast<CRTCMedia*>(m_pMedia);

        hr = m_rtpf_pIRtpSession->Init(&pCMedia->m_hRTPSession, dwFlags);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s failed to init rtp session. %x", __fxName, hr));

            PortCache.ReleasePort(m_MediaType, TRUE);
            PortCache.ReleasePort(m_MediaType, FALSE);

            return hr;
        }

        m_fRTPSessionSet = TRUE;
    }

    //
    // setup rtp filter
    //

    // set address
    hr = m_rtpf_pIRtpSession->SetAddress(
            htonl(dwLocalIP),
            htonl(dwRemoteIP)
            );

    if (FAILED(hr))
    {
        // leave the port mapping. the other stream might be using it
        LOG((RTC_ERROR, "%s failed to set addr. %x", __fxName, hr));
        return hr;
    }

    // set ports
    hr = m_rtpf_pIRtpSession->SetPorts(
            htons(usLocalRTP),
            htons(usRemoteRTP),
            htons(usLocalRTCP),
            htons(usRemoteRTCP)
            );

    if (FAILED(hr))
    {
        // leave the port mapping. the other stream might be using it
        LOG((RTC_ERROR, "%s failed to set ports. %x", __fxName, hr));
        return hr;
    }

    // force binding
    hr = m_rtpf_pIRtpSession->GetPorts(
            &usLocalRTP,
            &usRemoteRTP,
            &usLocalRTCP,
            &usRemoteRTCP
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get back ports. %x", __fxName, hr));
        return hr;
    }

    // back to host order
    usLocalRTP = ntohs(usLocalRTP);
    usLocalRTCP = ntohs(usLocalRTCP);
    usRemoteRTP = ntohs(usRemoteRTP);
    usRemoteRTCP = ntohs(usRemoteRTCP);

    //
    // save the addr back to media
    //

    m_pISDPMedia->SetConnAddr(SDP_SOURCE_LOCAL, dwLocalIP);
    m_pISDPMedia->SetConnPort(SDP_SOURCE_LOCAL, usLocalRTP);

    // tracing

    LOG((RTC_TRACE, " local %s:%d, %d",
        CNetwork::GetIPAddrString(dwLocalIP), usLocalRTP, usLocalRTCP));
    LOG((RTC_TRACE, "remote %s:%d",
        CNetwork::GetIPAddrString(dwRemoteIP), usRemoteRTP, usRemoteRTCP));

    return S_OK;
}


/*//////////////////////////////////////////////////////////////////////////////
    get a list of format from edge filter. when success
    pdwList will hold a list of payload type valid in sdp
    piAMList will hold a list of AM_MEDIA_TYPE index in edge filter
////*/
HRESULT
CRTCStream::GetFormatListOnEdgeFilter(
    IN DWORD dwLinkSpeed,
    IN RTP_FORMAT_PARAM *pParam,
    IN DWORD dwSize,
    OUT DWORD *pdwNum
    )
{
#define DEFAULT_LINKSPEED_THRESHOLD         64000   // 64k bps
#define DEFAULT_AUDIOBITRATE_THRESHOLD      20000   // 20k bps

    ENTER_FUNCTION("GetFormatListOnEdgeFilter");

    // get number of capabilities
    DWORD dwNum;

    HRESULT hr = m_edgp_pIStreamConfig->GetNumberOfCapabilities(&dwNum);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get num of caps. %x", __fxName, hr));
        return hr;
    }

    // need to support redundant coding
    // code is getting ugly, sigh
    if (dwNum > dwSize-1)
    {
        LOG((RTC_WARN, "%s too many caps %d, only support %d", __fxName, dwNum, dwSize));
        dwNum = dwSize-1;
    }

    // get a list of payload type
    AM_MEDIA_TYPE *pAMMediaType;

    // for video
    // BITMAPINFOHEADER *pVideoHeader;

    // number of accepted format
    DWORD dwAccept = 0;

    // get disabled format
    DWORD dwDisabled;

    if (m_MediaType==RTC_MT_AUDIO)
    {
        dwDisabled = m_pRegSetting->DisabledAudioCodec();
    }
    else
    {
        dwDisabled = m_pRegSetting->DisabledVideoCodec();
    }

    for (DWORD dw=0; dw<dwNum; dw++)
    {
        // init param
        ZeroMemory(&pParam[dwAccept], sizeof(RTP_FORMAT_PARAM));

        hr = m_edgp_pIStreamConfig->GetStreamCaps(
            dw, &pAMMediaType, NULL, &(pParam[dwAccept].dwCode)
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s getstreamcaps. %x", __fxName, hr));
            return hr;
        }

        // skip audio L16
        if (pParam[dwAccept].dwCode == 11)
        {
            ::RTCDeleteMediaType(pAMMediaType);
            pAMMediaType = NULL;
            continue;
        }

        //
        // temporary working around for a dsound bug.
        // dsound does not support dynamic sampling rate change
        // while AEC is enabled.
        //
        if (pParam[dwAccept].dwCode == dwDisabled)
        {
            ::RTCDeleteMediaType(pAMMediaType);
            continue;
        }

        // remove audio format if it exceeds the link speed
        if (m_MediaType == RTC_MT_AUDIO)
        {
            if (dwLinkSpeed <= DEFAULT_LINKSPEED_THRESHOLD)
            {
                // find audio bitrate
                WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pAMMediaType->pbFormat;

                if (pWaveFormatEx->nAvgBytesPerSec * 8 > DEFAULT_AUDIOBITRATE_THRESHOLD)
                {
                    ::RTCDeleteMediaType(pAMMediaType);
                    pAMMediaType = NULL;
                    continue;
                }
            }
        }

        // remove dup formats
        for (DWORD i=0; i<dwAccept; i++)
        {
            if (pParam[i].dwCode == pParam[dwAccept].dwCode)
            {
                ::RTCDeleteMediaType(pAMMediaType);
                pAMMediaType = NULL;
                break;
            }
        }

        if (pAMMediaType == NULL)
            continue; // deleted

        // record this format
        pParam[dwAccept].MediaType = m_MediaType;
        pParam[dwAccept].dwSampleRate = ::FindSampleRate(pAMMediaType);
        pParam[dwAccept].dwChannelNum = 1; // ToDo: support 2 channels
        pParam[dwAccept].dwExternalID = dw;

        if (m_MediaType == RTC_MT_VIDEO)
        {
            /*
            // check image size
            pVideoHeader = HEADER(pAMMediaType->pbFormat);

            // default is QCIF
            CQualityControl *pQualityControl =
                            (static_cast<CRTCMediaController*>(m_pMediaManagePriv))->GetQualityControl();

            DWORD dwLocal = pQualityControl->GetBitrateLimit(CQualityControl::LOCAL);
            DWORD dwRemote = pQualityControl->GetBitrateLimit(CQualityControl::REMOTE);

            if (dwLocal <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD ||
                dwRemote <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)
            {
                // SQCIF
                pParam[dwAccept].dwVidWidth = SDP_SMALL_VIDEO_WIDTH;
                pParam[dwAccept].dwVidHeight = SDP_SMALL_VIDEO_HEIGHT;
            }
            else
            {
                if (pVideoHeader != NULL)
                {
                    pParam[dwAccept].dwVidWidth = pVideoHeader->biWidth;
                    pParam[dwAccept].dwVidHeight = pVideoHeader->biHeight;
                }
                else
                {
                    // QCIF
                    pParam[dwAccept].dwVidWidth = SDP_DEFAULT_VIDEO_WIDTH;
                    pParam[dwAccept].dwVidHeight = SDP_DEFAULT_VIDEO_HEIGHT;
                }
            }
            */
        }
        else
        {
            // audio, just set to default
            pParam[dwAccept].dwAudPktSize = SDP_DEFAULT_AUDIO_PACKET_SIZE;
        }

        ::RTCDeleteMediaType(pAMMediaType);
        dwAccept ++;
    }

    // reorder audio codecs
    // we want to have g711, ahead of g723

    // order codec
    // issue: RTPFormat should be replaced by RTCCodec gradually

    if (m_MediaType == RTC_MT_AUDIO && dwAccept>1)
    {
        RTP_FORMAT_PARAM temp;

        BOOL fSwapped;

        for (int i=dwAccept-2; i>=0; i--)
        {
            fSwapped = FALSE;

            for (int j=0; j<=i; j++)
            {
                if (CRTCCodec::GetRank(pParam[j].dwCode) >
                    CRTCCodec::GetRank(pParam[j+1].dwCode))
                {
                    fSwapped = TRUE;

                    // swap
                    temp = pParam[j];
                    pParam[j] = pParam[j+1];
                    pParam[j+1] = temp;
                }
            }

            if (!fSwapped)
                break;
        }
    }

    // to support redundant coding
    *pdwNum = dwAccept;

    if (dwDisabled != 97)
    {
        if (m_MediaType == RTC_MT_AUDIO)
        {
            for (DWORD i=dwAccept; i>0; i--)
            {
                pParam[i] = pParam[i-1];
            }

            ZeroMemory(pParam, sizeof(RTP_FORMAT_PARAM));
            pParam[0].dwCode = 97;
            lstrcpyA(pParam[0].pszName, "red");
            pParam[0].MediaType = m_MediaType;
            pParam[0].dwSampleRate = 8000;
            pParam[0].dwChannelNum = 1;
            pParam[0].dwAudPktSize = 30;

            *pdwNum = dwAccept+1;
        }
    }

    return S_OK;
}

HRESULT
CRTCStream::SetFormatOnRTPFilter()
{
    ENTER_FUNCTION("SetFormatOnRTPFilter");

    HRESULT hr;

    IRTPFormat **ppFormat;
    DWORD dwNum;

    // cleanup stored format list
    m_Codecs.RemoveAll();

    // get the number of formats
    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwNum, NULL)))
    {
        LOG((RTC_ERROR, "%s get rtp format num. %x", __fxName, hr));

        return hr;
    }

    if (dwNum == 0)
    {
        LOG((RTC_ERROR, "%s no format.", __fxName));

        return E_FAIL;
    }

    // allocate format list
    ppFormat = (IRTPFormat**)RtcAlloc(sizeof(IRTPFormat*)*dwNum);

    if (ppFormat == NULL)
    {
        LOG((RTC_ERROR, "%s RtcAlloc format list", __fxName));

        return E_OUTOFMEMORY;
    }

    // get formats
    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwNum, ppFormat)))
    {
        LOG((RTC_ERROR, "%s really get formats. %x", __fxName, hr));

        RtcFree(ppFormat);

        return hr;
    }

    // set mapping on rtp
    AM_MEDIA_TYPE *pmt;
    DWORD dwCode;
    RTP_FORMAT_PARAM param;

    hr = S_OK;

    BOOL fFormatSet = FALSE;

    for (DWORD i=0; i<dwNum; i++)
    {
        // get param
        if (FAILED(hr = ppFormat[i]->GetParam(&param)))
        {
            LOG((RTC_ERROR, "%s get param on %dth format. %x", __fxName, i, hr));
            break;
        }

        // check redundant, sigh
        if (lstrcmpA(param.pszName, "red") == 0)
        {
            continue;
        }

        // get the am-media-type
        hr = m_edgp_pIStreamConfig->GetStreamCaps(
            param.dwExternalID,
            &pmt,
            NULL,
            &dwCode
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s get stream caps. %x", __fxName, hr));
            break;
        }

        // validate code and sample rate
        if (param.dwCode != dwCode ||
            param.dwSampleRate != ::FindSampleRate(pmt))
        {
            LOG((RTC_ERROR, "%s recorded format in sdp does not match the one from codec\
                             code (%d vs %d), samplerate (%d vs %d)", __fxName,
                             param.dwCode, dwCode, param.dwSampleRate, ::FindSampleRate(pmt)));

            ::RTCDeleteMediaType(pmt);
            hr = E_FAIL;

            break;
        }

        // set format mapping
        hr = m_rtpf_pIRtpMediaControl->SetFormatMapping(dwCode, param.dwSampleRate, pmt);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s set format mapping. %x", __fxName, hr));

            ::RTCDeleteMediaType(pmt);
            break;
        }

        // store codec
        CRTCCodec *pCodec = new CRTCCodec(dwCode, pmt);

        if (pCodec == NULL)
        {
            LOG((RTC_ERROR, "%s new codec. out of memory", __fxName));

            ::RTCDeleteMediaType(pmt);
            break;
        }

        if (i==0)
        {
            // boost the rank of 1st codec
            // which might be set by registry
            pCodec->Set(CRTCCodec::RANK, 0);
        }

        if (!m_Codecs.AddCodec(pCodec))
        {
            LOG((RTC_ERROR, "%s add codec. out of memory", __fxName));

            ::RTCDeleteMediaType(pmt);
            delete pCodec;
            break;
        }

        // set default format on send stream
        if (m_Direction == RTC_MD_CAPTURE && !fFormatSet)
        {
            /*
            // if audio adjust packet size
            if (m_MediaType == RTC_MT_AUDIO)
            {
                CRTCCodec::SetPacketDuration(pmt, param.dwAudPktSize);
            }
            else if (m_MediaType == RTC_MT_VIDEO)
            {
                if (m_pRegSetting->EnableSQCIF())
                {
                    BITMAPINFOHEADER *pVideoHeader = HEADER(pmt->pbFormat);

                    if (pVideoHeader != NULL)
                    {
                        // default is QCIF                        

//                        DWORD dwLocal = m_pQualityControl->GetBitrateLimit(CQualityControl::LOCAL);
//                        DWORD dwRemote = m_pQualityControl->GetBitrateLimit(CQualityControl::REMOTE);
//                        DWORD dwApp = m_pQualityControl->GetMaxBitrate();

//                        if (dwLocal <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD ||
//                            dwRemote <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)
//                            dwApp <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)

                        if (m_pQualityControl->GetEffectiveBitrateLimit() <=
                            CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)
                        {
                            pVideoHeader->biWidth = SDP_SMALL_VIDEO_WIDTH;
                            pVideoHeader->biHeight = SDP_SMALL_VIDEO_HEIGHT;
                        }
                    }
                }
            }
            */

            if (IsNewFormat(dwCode, pmt))
            {
                hr = m_edgp_pIStreamConfig->SetFormat(dwCode, pmt);

                SaveFormat(dwCode, pmt);

                LOG((RTC_TRACE, "SetFormat %d (%p, mt=%d, md=%d)",
                    dwCode, this, m_MediaType, m_Direction));
            }

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s set format. %x", __fxName, hr));

                ::RTCDeleteMediaType(pmt);
                break;
            }

            /*
            // if audio save bitrate
            if (m_MediaType == RTC_MT_AUDIO)
            {
                WAVEFORMATEX *pformat = (WAVEFORMATEX*)pmt->pbFormat;

                // get packet duration
                DWORD dwDuration = CRTCCodec::GetPacketDuration(pmt);

                if (dwDuration == 0) dwDuration = 20; // default 20 ms

                m_pQualityControl->SetBitrateLimit(
                    CQualityControl::LOCAL,
                    m_MediaType,
                    m_Direction,
                    dwDuration,
                    pformat->nAvgBytesPerSec * 8
                    );
            }
            */

            // update stored AM_MEDIA_TYPE
            pCodec->SetAMMediaType(pmt);

            m_Codecs.Set(CRTCCodecArray::CODE_INUSE, dwCode);

            fFormatSet = TRUE;
        }

        RTCDeleteMediaType(pmt);
    } // end of for

    // release formats
    for (DWORD i=0; i<dwNum; i++)
    {
        ppFormat[i]->Release();
    }

    RtcFree(ppFormat);

    // return hr from the loop
    return hr;
}

HRESULT
CRTCStream::SetupQoS()
{
    ENTER_FUNCTION("CRTCStream::SetupQoS");

    // get the format in use
    DWORD dwCode;
    AM_MEDIA_TYPE *pmt;

    HRESULT hr = m_edgp_pIStreamConfig->GetFormat(&dwCode, &pmt);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get format. %x", __fxName, hr));

        return hr;
    }

    // get packet duration
    DWORD dwDuration = 0;

    if (m_MediaType == RTC_MT_AUDIO &&
        m_Direction == RTC_MD_CAPTURE)
    {
        dwDuration = CRTCCodec::GetPacketDuration(pmt);
    }

    ::RTCDeleteMediaType(pmt);

    // set qos name
    WCHAR *pwszName;

    if (!CRTCCodec::GetQoSName(dwCode, &pwszName))
    {
        LOG((RTC_WARN, "Don't know the QOS name for payload type: %d", dwCode));

        return E_FAIL;
    }

    hr = m_rtpf_pIRtpSession->SetQosByName(
        pwszName,
        RTPQOS_STYLE_DEFAULT,
        1,
        RTPQOSSENDMODE_REDUCED_RATE,
        dwDuration? dwDuration:~0
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s, SetQosByName failed. %x", __fxName, hr));

        return hr;
    }

    // enable qos events.
    DWORD dwQOSEventMask = 
        RTPQOS_MASK_ADMISSION_FAILURE |
        RTPQOS_MASK_POLICY_FAILURE |
        RTPQOS_MASK_BAD_STYLE |
        RTPQOS_MASK_BAD_OBJECT |
        RTPQOS_MASK_TRAFFIC_CTRL_ERROR |
        RTPQOS_MASK_GENERIC_ERROR |
        RTPQOS_MASK_NOT_ALLOWEDTOSEND |
        RTPQOS_MASK_ALLOWEDTOSEND;

    DWORD dwEnabledMask;   
    hr = m_rtpf_pIRtpSession->ModifySessionMask(
        (m_Direction == RTC_MD_RENDER) ? RTPMASK_QOSRECV_EVENTS : RTPMASK_QOSSEND_EVENTS,
        dwQOSEventMask,
        1,
        &dwEnabledMask
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s, modify qos event mask failed. %x", __fxName, hr));
        return hr;
    }

    return S_OK;
}

HRESULT
CRTCStream::EnableParticipantEvents()
{
    ENTER_FUNCTION("EnableParticipantEvents");

    HRESULT hr = S_OK;

    // no need to have recv lossrate
    // if we do not send re-invite when loss is observed
    DWORD dwMask = RTPPARINFO_MASK_TALKING |
                   RTPPARINFO_MASK_STALL;

    DWORD dwEnabledMask;

    LOG((RTC_TRACE, "%s Enable TALKING/STALL. mt=%d, md=%d",
         __fxName, m_MediaType, m_Direction));

    hr = m_rtpf_pIRtpSession->ModifySessionMask(
        m_Direction==RTC_MD_CAPTURE?RTPMASK_PINFOS_EVENTS:RTPMASK_PINFOR_EVENTS,
        dwMask,
        1,
        &dwEnabledMask
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s modify participant events. %x", __fxName, hr));
    }

    if (m_Direction == RTC_MD_CAPTURE)
    {
        hr = m_rtpf_pIRtpSession->ModifySessionMask(
            RTPMASK_SEND_EVENTS,
            RTPRTP_MASK_SEND_LOSSRATE | RTPRTP_MASK_CRYPT_SEND_ERROR,
            1,
            NULL
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s modify participant events. %x", __fxName, hr));
        }

        // enable feature
        hr = m_rtpf_pIRtpSession->ModifySessionMask(
            RTPMASK_FEATURES_MASK,
            RTPFEAT_MASK_BANDESTIMATION,
            1,
            NULL
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s enable band estimation. %x", __fxName, hr));
        }

        // enable event
        hr = m_rtpf_pIRtpSession->ModifySessionMask(
            RTPMASK_SEND_EVENTS,
            RTPRTP_MASK_BANDESTIMATIONSEND,
            1,
            NULL
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s modify participant events. %x", __fxName, hr));
        }

        // enable network quality event
        hr = m_rtpf_pIRtpSession->ModifySessionMask(
            RTPMASK_PINFOS_EVENTS,
            RTPPARINFO_MASK_NETWORKCONDITION,
            1,
            NULL
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s networkcondition. %x", __fxName, hr));
        }

        hr = m_rtpf_pIRtpSession->SetNetMetricsState(0, TRUE);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s net metrics. %x", __fxName, hr));
        }
    }
    else    // receive stream
    {
        hr = m_rtpf_pIRtpSession->ModifySessionMask(
            RTPMASK_RECV_EVENTS,
            RTPRTP_MASK_CRYPT_RECV_ERROR,
            1,
            NULL
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s modify participant events. %x", __fxName, hr));
        }
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    AEC is needed only both audio terminals require AEC
////*/
BOOL
CRTCStream::IsAECNeeded()
{
    ENTER_FUNCTION("CRTCStream::IsAECNeeded");

    HRESULT hr;

    // hack: check if the media might have only one stream
    CRTCMedia *pMedia = static_cast<CRTCMedia*>(m_pMedia);

    if (pMedia->IsPossibleSingleStream())
    {
        return FALSE;
    }

    CRTCMediaController *pMediaController = static_cast<CRTCMediaController*>(
                m_pMediaManagePriv);

    CComPtr<IRTCTerminal> pCapture, pRender;

    // get audio capture and render terminal
    if (FAILED(hr = pMediaController->GetDefaultTerminal(
            RTC_MT_AUDIO,
            RTC_MD_CAPTURE,
            &pCapture
            )))
    {
        LOG((RTC_ERROR, "%s failed to get audio capture terminal. %x", __fxName, hr));

        return FALSE;
    }

    if (pCapture == NULL)
    {
        return FALSE;
    }

    if (FAILED(hr = pMediaController->GetDefaultTerminal(
            RTC_MT_AUDIO,
            RTC_MD_RENDER,
            &pRender
            )))
    {
        LOG((RTC_ERROR, "%s failed to get audio render terminal. %x", __fxName, hr));

        return FALSE;
    }

    if (pRender == NULL)
    {
        return FALSE;
    }

    // check is aec enabled
    BOOL fEnabled = FALSE;

    if (FAILED(hr = pMediaController->IsAECEnabled(pCapture, pRender, &fEnabled)))
    {
        LOG((RTC_ERROR, "%s get aec enabled on capture. %x", __fxName, hr));

        return FALSE;
    }

    return fEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdpsession.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPSession.h

Abstract:


Author:

    Qianbo Huai (qhuai) 4-Sep-2000

--*/

#ifndef _SDPSESSION_H
#define _SDPSESSION_H

class ATL_NO_VTABLE CSDPSession :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public ISDPSession
{
    friend class CSDPParser;

public:

BEGIN_COM_MAP(CSDPSession)
    COM_INTERFACE_ENTRY(ISDPSession)
END_COM_MAP()

public:

    CSDPSession();
    ~CSDPSession();

    ULONG InternalAddRef();
    ULONG InternalRelease();

    //
    // ISDPSession methods
    //

    STDMETHOD (Update) (
        IN ISDPSession *pSession
        );

    STDMETHOD (TryUpdate) (
        IN ISDPSession *pSession,
        OUT DWORD *pdwHasMedia
        );

    STDMETHOD (TryCopy) (
        OUT DWORD *pdwHasMedia
        );

    STDMETHOD (GetSDPSource) (
        OUT SDP_SOURCE *pSource
        );

    STDMETHOD (SetSessName) (
        IN CHAR *pszName
        );

    STDMETHOD (SetUserName) (
        IN CHAR *pszName
        );

    STDMETHOD (GetMedias) (
        IN OUT DWORD *pdwCount,
        OUT ISDPMedia **ppMedia
        );

    STDMETHOD (AddMedia) (
        IN SDP_SOURCE Source,
        IN RTC_MEDIA_TYPE MediaType,
        IN DWORD dwDirections,
        OUT ISDPMedia **ppMedia
        );

    STDMETHOD (RemoveMedia) (
        IN ISDPMedia *pMedia
        );

    STDMETHOD (SetLocalBitrate) (
        IN DWORD dwBitrate
        );

    STDMETHOD (GetRemoteBitrate) (
        OUT DWORD *pdwBitrate
        );

    STDMETHOD (GetMediaType) (
        IN DWORD dwIndex,
        OUT RTC_MEDIA_TYPE *pMediaType
        );

    VOID CompleteParse(
        IN DWORD_PTR *pDTMF
        );

protected:

    static HRESULT CreateInstance(
        IN SDP_SOURCE Source,
        IN DWORD dwLooseMask,
        OUT ISDPSession **ppSession
        );

    HRESULT Validate();

    HRESULT UpdateMedias(
        IN DWORD dwLooseMask,
        IN CRTCArray<ISDPMedia*>& ArrMedias
        );

protected:

    // loose mask
    DWORD                   m_dwLooseMask;

    // source
    SDP_SOURCE              m_Source;

    // o=
    CHAR                    *m_o_pszLine;
    CHAR                    *m_o_pszUser;

    // s=
    CHAR                    *m_s_pszLine;

    // c=
    DWORD                   m_c_dwRemoteAddr;
    DWORD                   m_c_dwLocalAddr;

    // b=
    DWORD                   m_b_dwLocalBitrate;
    DWORD                   m_b_dwRemoteBitrate;

    // a=
    DWORD                   m_a_dwRemoteDirs;
    DWORD                   m_a_dwLocalDirs;

    // m=
    CRTCArray<ISDPMedia*>   m_pMedias;

    // connection addr in o=
    DWORD                   m_o_dwLocalAddr;
};

#endif // _SDPSESSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdptable.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPTable.h

Abstract:


Author:

    Qianbo Huai (qhuai) 6-Sep-2000

--*/

#ifndef _SDPTABLE_H
#define _SDPTABLE_H

// parser begins with none, goes to session and then media
typedef enum SDP_PARSING_STAGE
{
    SDP_STAGE_NONE,
    SDP_STAGE_SESSION,
    SDP_STAGE_MEDIA

} SDP_PARSING_STAGE;

// delimit used as boundary of tokens
typedef enum SDP_DELIMIT_TYPE
{
    SDP_DELIMIT_NONE,           // no delimit, match until the end of line
    SDP_DELIMIT_EXACT_STRING,   // exact matching a string
    SDP_DELIMIT_CHAR_BOUNDARY,  // each char in the string is a delimit

} SDP_DELIMIT_TYPE;

// TODO refine pszInvalidNext in the lookup table
// state entry for each line
typedef struct SDPLineState
{
    // state = stage + line type
    SDP_PARSING_STAGE   Stage;
    UCHAR               ucLineType;

    // next possible state
    SDP_PARSING_STAGE   NextStage[8];
    UCHAR               ucNextLineType[8];  // '\0' mark the end
    CHAR                *pszRejectLineType;

    // can this line be a stop state
    BOOL                fCanStop;

    // delimit type for breaking the line
    SDP_DELIMIT_TYPE    DelimitType[8];
    // delimit
    CHAR                *pszDelimit[8];     // NULL mark the end

} SDPLineState;


extern const SDPLineState g_LineStates[];
extern const DWORD g_dwLineStatesNum;

extern const CHAR * const g_pszAudioM;
extern const CHAR * const g_pszAudioRTPMAP;
extern const CHAR * const g_pszVideoM;
extern const CHAR * const g_pszVideoRTPMAP;
extern const CHAR * const g_pszDataM;

// get index in the table
extern DWORD Index(
    IN SDP_PARSING_STAGE Stage,
    IN UCHAR ucLineType
    );

// check if accept (TRUE)
extern BOOL Accept(
    IN DWORD dwCurrentIndex,
    IN UCHAR ucLineType,
    OUT DWORD *pdwNextIndex
    );

// check if reject (TRUE)
extern BOOL Reject(
    IN DWORD dwCurrentIndex,
    IN UCHAR ucLineType
    );

extern const CHAR *GetFormatName(
    IN DWORD dwCode
    );

#endif // _SDPTABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\stream.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Stream.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#ifndef _STREAM_H
#define _STREAM_H

class ATL_NO_VTABLE CRTCStream :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IRTCStream
    //public IRTCStreamQualityControl
{
public:

BEGIN_COM_MAP(CRTCStream)
    COM_INTERFACE_ENTRY(IRTCStream)
//    COM_INTERFACE_ENTRY(IRTCStreamQualityControl)
END_COM_MAP()

public:

    static HRESULT CreateInstance(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        OUT IRTCStream **ppIStream
        );

    static VOID NTAPI GraphEventCallback(
        IN PVOID pStream,
        IN BOOLEAN fTimerOrWaitFired
        );

    CRTCStream();
    ~CRTCStream();

#ifdef DEBUG_REFCOUNT

    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    //
    // IRTCStream methods
    //

    STDMETHOD (Initialize) (
        IN IRTCMedia *pMedia,
        IN IRTCMediaManagePriv *pMediaManagePriv
        );

    STDMETHOD (Shutdown) ();

    STDMETHOD (Synchronize) ();

    STDMETHOD (ChangeTerminal) (
        IN IRTCTerminal *pTerminal
        );

    STDMETHOD (StartStream) ();

    STDMETHOD (StopStream) ();

    STDMETHOD (GetMediaType) (
        OUT RTC_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetDirection) (
        OUT RTC_MEDIA_DIRECTION *pDirection
        );

    STDMETHOD (GetState) (
        OUT RTC_STREAM_STATE *pState
        );

    STDMETHOD (GetIMediaEvent) (
        OUT LONG_PTR **ppIMediaEvent
        );

    STDMETHOD (GetMedia) (
        OUT IRTCMedia **ppMedia
        );

    STDMETHOD (ProcessGraphEvent) ();

    STDMETHOD (SendDTMFEvent) (
        IN BOOL fOutOfBand,
        IN DWORD dwCode,
        IN DWORD dwId,
        IN DWORD dwEvent,
        IN DWORD dwVolume,
        IN DWORD dwDuration,
        IN BOOL fEnd
        );

    STDMETHOD (GetCurrentBitrate) (
        IN DWORD *pdwBitrate,
        IN BOOL fHeader
        );

    STDMETHOD (SetEncryptionKey) (
        IN BSTR Key
        );

    // network quality: [0, 100].
    // higher value better quality
    STDMETHOD (GetNetworkQuality) (
        OUT DWORD *pdwValue,
        OUT DWORD *pdwAge
        );

#if 0
    //
    // IRTCStreamQualityControl methods
    //

    STDMETHOD (GetRange) (
        IN RTC_STREAM_QUALITY_PROPERTY Property,
        OUT LONG *plMin,
        OUT LONG *plMax,
        OUT RTC_QUALITY_CONTROL_MODE *pMode
        );

    STDMETHOD (Get) (
        IN RTC_STREAM_QUALITY_PROPERTY Property,
        OUT LONG *plValue,
        OUT RTC_QUALITY_CONTROL_MODE *pMode
        );

    STDMETHOD (Set) (
        IN RTC_STREAM_QUALITY_PROPERTY Property,
        IN LONG lValue,
        IN RTC_QUALITY_CONTROL_MODE Mode
        );
#endif

protected:

    HRESULT SetGraphClock();

    virtual HRESULT SelectTerminal();
    virtual HRESULT UnselectTerminal();

    virtual HRESULT BuildGraph() = 0;

    virtual void CleanupGraph(); // except rtp filter

    virtual BOOL IsNewFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt)
    { return TRUE; }

    virtual void SaveFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt) {}

    HRESULT SetupRTPFilter();

    // setup rtp filter, use port manager to get ports
    HRESULT SetupRTPFilterUsingPortManager();

    HRESULT SetupFormat();

    HRESULT SetupQoS();

    HRESULT EnableParticipantEvents();

    HRESULT GetFormatListOnEdgeFilter(
        IN DWORD dwLinkSpeed,
        IN RTP_FORMAT_PARAM *pParam,
        IN DWORD dwSize,
        OUT DWORD *pdwNum
        );

    HRESULT SetFormatOnRTPFilter();

    BOOL IsAECNeeded();

protected:

    // state
    RTC_STREAM_STATE                m_State;

    // sdp media
    ISDPMedia                       *m_pISDPMedia;

    // pointer to media
    IRTCMedia                       *m_pMedia;

    // media manage
    IRTCMediaManagePriv             *m_pMediaManagePriv;
    IRTCTerminalManage              *m_pTerminalManage;

    // media type and direction
    RTC_MEDIA_TYPE                  m_MediaType;
    RTC_MEDIA_DIRECTION             m_Direction;

    // terminals
    // except on video recv, we allow only one terminal
    IRTCTerminal                    *m_pTerminal;
    IRTCTerminalPriv                *m_pTerminalPriv;
  
    // graph object
    IGraphBuilder                   *m_pIGraphBuilder;
    IMediaEvent                     *m_pIMediaEvent;
    IMediaControl                   *m_pIMediaControl;

    // stream timeout?
    BOOL                            m_fMediaTimeout;

    // rtp filter and cached interfaces
    IBaseFilter                     *m_rtpf_pIBaseFilter;
    IRtpSession                     *m_rtpf_pIRtpSession;
    IRtpMediaControl                *m_rtpf_pIRtpMediaControl;

    BOOL                            m_fRTPSessionSet;

    // the filter connected to rtp filter
    IBaseFilter                     *m_edgf_pIBaseFilter;
    IStreamConfig                   *m_edgp_pIStreamConfig;
    IBitrateControl                 *m_edgp_pIBitrateControl;

    // list of codec in use
    CRTCCodecArray                  m_Codecs;

    // quality control
    CQualityControl                 *m_pQualityControl;

    // reg setting
    CRegSetting                     *m_pRegSetting;
};


class ATL_NO_VTABLE CRTCStreamAudSend :
    public CRTCStream
{
public:

BEGIN_COM_MAP(CRTCStreamAudSend)
    COM_INTERFACE_ENTRY_CHAIN(CRTCStream)
END_COM_MAP()

public:

    CRTCStreamAudSend();
    // ~CRTCStreamAudSend();

    VOID AdjustBitrate(
        IN DWORD dwBandwidth,
        IN DWORD dwLimit,
        IN BOOL fHasVideo,
        OUT DWORD *pdwNewBW,
        OUT BOOL *pfFEC
        );

    // IRTCStream methods

    STDMETHOD (Synchronize) ();

    STDMETHOD (SendDTMFEvent) (
        IN BOOL fOutOfBand,
        IN DWORD dwCode,
        IN DWORD dwId,
        IN DWORD dwEvent,
        IN DWORD dwVolume,
        IN DWORD dwDuration,
        IN BOOL fEnd
        );

    DWORD GetCurrCode() const { return m_dwCurrCode; }

protected:

    HRESULT PrepareRedundancy();

    HRESULT BuildGraph();
    void CleanupGraph();

    // HRESULT SetupFormat();

    BOOL IsNewFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt);

    void SaveFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt);

protected:

    // redundancy
    BOOL                            m_fRedEnabled;

    DWORD                           m_dwRedCode;
    IRtpRedundancy                  *m_rtpf_pIRtpRedundancy;

    IRtpDtmf                        *m_rtpf_pIRtpDtmf;

    IAMAudioInputMixer              *m_edgf_pIAudioInputMixer;
    IAudioDeviceControl             *m_edgf_pIAudioDeviceControl;
    ISilenceControl                 *m_edgp_pISilenceControl;

    // current format
    DWORD                           m_dwCurrCode;
    DWORD                           m_dwCurrDuration;
};


class ATL_NO_VTABLE CRTCStreamAudRecv :
    public CRTCStream
{
public:

BEGIN_COM_MAP(CRTCStreamAudRecv)
    COM_INTERFACE_ENTRY_CHAIN(CRTCStream)
END_COM_MAP()

public:

    // IRTCStream method

    STDMETHOD (Synchronize) ();

    CRTCStreamAudRecv();
    // ~CRTCStreamAudRecv();

protected:

    HRESULT PrepareRedundancy();

    HRESULT BuildGraph();
    // void CleanupGraph();

    // HRESULT SetupFormat();
};


class ATL_NO_VTABLE CRTCStreamVidSend :
    public CRTCStream
{
public:

BEGIN_COM_MAP(CRTCStreamVidSend)
    COM_INTERFACE_ENTRY_CHAIN(CRTCStream)
END_COM_MAP()

public:

    CRTCStreamVidSend();
    // ~CRTCStreamVidSend();

    DWORD AdjustBitrate(
        IN DWORD dwTotalBW,
        IN DWORD dwVideoBW,
        IN FLOAT dFramerate
        );

    HRESULT GetFramerate(
        OUT DWORD *pdwFramerate
        );

    DWORD GetCurrCode() const { return m_dwCurrCode; }

protected:

    // preview terminal
    IRTCTerminal                    *m_pPreview;
    IRTCTerminalPriv                *m_pPreviewPriv;

    // pins on the capture filter
    IPin                            *m_edgp_pCapturePin;
    IPin                            *m_edgp_pPreviewPin;
    IPin                            *m_edgp_pRTPPin;

    // IBitrateControl and IFrameRateControl
    IFrameRateControl               *m_edgp_pIFrameRateControl;

    // current format
    DWORD                           m_dwCurrCode;
    LONG                            m_lCurrWidth;
    LONG                            m_lCurrHeight;

protected:

    HRESULT SelectTerminal();
    HRESULT UnselectTerminal();

    HRESULT BuildGraph();
    void CleanupGraph();
        
        // HRESULT SetupFormat();
    BOOL IsNewFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt);

    void SaveFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt);
};


class ATL_NO_VTABLE CRTCStreamVidRecv :
    public CRTCStream
{
public:

BEGIN_COM_MAP(CRTCStreamVidRecv)
    COM_INTERFACE_ENTRY_CHAIN(CRTCStream)
END_COM_MAP()

public:

    CRTCStreamVidRecv();
    // ~CRTCStreamVidRecv();

    HRESULT GetFramerate(
        OUT DWORD *pdwFramerate
        );

protected:

    HRESULT BuildGraph();
    void CleanupGraph();

    IFrameRateControl               *m_edgp_pIFrameRateControl;

    // HRESULT SetupFormat();

};

#endif // _STREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdptokencache.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPTable.cpp

Abstract:


Author:

    Qianbo Huai (qhuai) 6-Sep-2000

--*/

#include "stdafx.h"

/*//////////////////////////////////////////////////////////////////////////////
    CSDPTokenCache methods
////*/

CSDPTokenCache::CSDPTokenCache(
    IN CHAR *pszString,
    IN DWORD dwLooseMask,
    OUT HRESULT *pHr
    )
    :m_dwLooseMask(dwLooseMask)
    ,m_dwCurrentLineIdx(0)
{
    InitializeListHead(&m_LineEntry);
    InitializeListHead(&m_TokenEntry);

    m_pszErrorDesp[0] = '\0';
    m_pszCurrentLine[0] = '\0';
    m_pszCurrentToken[0] = '\0';

    // break string into lines
    HRESULT hr = StringToLines(pszString);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "CSDPTokenCache constructor %s", GetErrorDesp()));
    }

    *pHr = hr;

    return;
}

CSDPTokenCache::~CSDPTokenCache()
{
    FreeTokens();
    FreeLines();
}

// set back error code
HRESULT
CSDPTokenCache::SetErrorDesp(
    IN const CHAR * const pszError,
    ...
    )
{
    va_list arglist;

    va_start(arglist, pszError);

    _vsnprintf(m_pszErrorDesp, SDP_MAX_ERROR_DESP_LEN, pszError, arglist);
    m_pszErrorDesp[SDP_MAX_ERROR_DESP_LEN] = '\0';

    return S_OK;
}

// get error description
CHAR * const
CSDPTokenCache::GetErrorDesp()
{
    return m_pszErrorDesp;
}

// move to next line
HRESULT
CSDPTokenCache::NextLine()
{
    ClearErrorDesp();
    m_pszCurrentLine[0] = '\0';
    m_dwCurrentLineIdx = 0;
    m_pszCurrentToken[0] = '\0';
    FreeTokens();

    // get first entry
    if (IsListEmpty(&m_LineEntry))
        return S_FALSE;

    LIST_ENTRY *pEntry = RemoveHeadList(&m_LineEntry);
    SDPLineItem *pItem = CONTAINING_RECORD(pEntry, SDPLineItem, Link);

    // save line index
    m_dwCurrentLineIdx = pItem->dwIndex;

    // check line length
    int iLen = lstrlenA(pItem->pszLine);

    if (iLen > SDP_MAX_LINE_LEN)
    {
        LOG((RTC_WARN, "CSDPTokenCache::NextLine line %s\nlength %d exceeds %d",
            pItem->pszLine, iLen, SDP_MAX_LINE_LEN));

        iLen = SDP_MAX_LINE_LEN;
    }

    // copy line
    lstrcpynA(m_pszCurrentLine, pItem->pszLine, iLen+1);
    m_pszCurrentLine[SDP_MAX_TOKEN_LEN] = '\0';

    // break the line into tokens
    HRESULT hr;

    if (FAILED(hr = LineToTokens(pItem)))
    {
        LOG((RTC_ERROR, "CSDPTokenCache::NextLine failed in %c=%s",
            g_LineStates[pItem->dwIndex].ucLineType, pItem->pszLine));

        FreeLineItem(pItem);
        return hr;
    }

    FreeLineItem(pItem);
    return S_OK;
}

UCHAR
CSDPTokenCache::GetLineType()
{
    return g_LineStates[m_dwCurrentLineIdx].ucLineType;
}

// get current line (may not be the complete line)
CHAR * const
CSDPTokenCache::GetLine()
{
    return m_pszCurrentLine;
}

// get current token
HRESULT
CSDPTokenCache::NextToken(
    OUT CHAR **ppszToken
    )
{
    ENTER_FUNCTION("CSDPTokenCache::NextToken(CHAR*)");

    ClearErrorDesp();

    m_pszCurrentToken[0] = '\0';

    if (IsListEmpty(&m_TokenEntry))
    {
        // no token left
        return S_FALSE;
    }

    // get first entry
    LIST_ENTRY *pEntry = RemoveHeadList(&m_TokenEntry);
    SDPTokenItem *pItem = CONTAINING_RECORD(pEntry, SDPTokenItem, Link);

    // check token length
    int iLen = lstrlenA(pItem->pszToken);

    if (iLen > SDP_MAX_TOKEN_LEN)
    {
        LOG((RTC_ERROR, "%s token %s\nlength %d exceeds %d",
            __fxName, pItem->pszToken, iLen, SDP_MAX_TOKEN_LEN));

        iLen = SDP_MAX_TOKEN_LEN;
    }

    // copy token
    lstrcpynA(m_pszCurrentToken, pItem->pszToken, iLen+1);
    m_pszCurrentToken[SDP_MAX_TOKEN_LEN] = '\0';

    *ppszToken = m_pszCurrentToken;

    // RtcFree item
    FreeTokenItem(pItem);
    return S_OK;
}

HRESULT
CSDPTokenCache::NextToken(
    OUT USHORT *pusToken
    )
{
    ENTER_FUNCTION("CSDPTokenCache::NextToken(USHORT)");

    ClearErrorDesp();

    if (IsListEmpty(&m_TokenEntry))
    {
        // no token left
        *pusToken = 0;
        return S_FALSE;
    }

    // get first entry
    LIST_ENTRY *pEntry = RemoveHeadList(&m_TokenEntry);
    SDPTokenItem *pItem = CONTAINING_RECORD(pEntry, SDPTokenItem, Link);

    // ulong max
    const CHAR * const pszMaxUSHORT = "65535";
    const DWORD dwUSHORTSize = 5;

    // check the token length
    if (lstrlenA(pItem->pszToken) > dwUSHORTSize)
    {
        SetErrorDesp("invalid USHORT %s", pItem->pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeTokenItem(pItem);
        return E_FAIL;
    }

    // is every char valid
    CHAR c;
    for (int i=0; i<lstrlenA(pItem->pszToken); i++)
    {
        c = pItem->pszToken[i];

        if (c<'0' || c>'9')
        {
            SetErrorDesp("invalid USHORT %s", pItem->pszToken);

            LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
            
            FreeTokenItem(pItem);
            return E_FAIL;
        }
    }

    // check the value
    if (lstrlenA(pItem->pszToken) == dwUSHORTSize &&
        lstrcmpA(pItem->pszToken, pszMaxUSHORT) > 0)
    {
        SetErrorDesp("number %s out of USHORT range", pItem->pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeTokenItem(pItem);
        return E_FAIL;
    }

    // convert the string to ulong
    USHORT us = 0;

    for (int i=0; i<lstrlenA(pItem->pszToken); i++)
    {
        us = us*10 + (pItem->pszToken[i]-'0');
    }

    *pusToken = us;

    FreeTokenItem(pItem);
    return S_OK;
}

HRESULT
CSDPTokenCache::NextToken(
    OUT UCHAR *pucToken
    )
{
    ENTER_FUNCTION("CSDPTokenCache::NextToken(UCHAR)");

    ClearErrorDesp();

    if (IsListEmpty(&m_TokenEntry))
    {
        // no token left
        *pucToken = 0;
        return S_FALSE;
    }

    // get first entry
    LIST_ENTRY *pEntry = RemoveHeadList(&m_TokenEntry);
    SDPTokenItem *pItem = CONTAINING_RECORD(pEntry, SDPTokenItem, Link);

    // ulong max
    const CHAR * const pszMaxUCHAR = "255";
    const DWORD dwUCHARSize = 3;

    // check the token length
    if (lstrlenA(pItem->pszToken) > dwUCHARSize)
    {
        SetErrorDesp("invalid UCHAR %s", pItem->pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeTokenItem(pItem);
        return E_FAIL;
    }

    // is every char valid
    CHAR c;
    for (int i=0; i<lstrlenA(pItem->pszToken); i++)
    {
        c = pItem->pszToken[i];

        if (c<'0' || c>'9')
        {
            SetErrorDesp("invalid UCHAR %s", pItem->pszToken);

            LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
            
            FreeTokenItem(pItem);
            return E_FAIL;
        }
    }

    // check the value
    if (lstrlenA(pItem->pszToken) == dwUCHARSize &&
        lstrcmpA(pItem->pszToken, pszMaxUCHAR) > 0)
    {
        SetErrorDesp("number %s out of UCHAR range", pItem->pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeTokenItem(pItem);
        return E_FAIL;
    }

    // convert the string to ulong
    UCHAR uc = 0;

    for (int i=0; i<lstrlenA(pItem->pszToken); i++)
    {
        uc = uc*10 + (pItem->pszToken[i]-'0');
    }

    *pucToken = uc;

    FreeTokenItem(pItem);
    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    next token should be a ULONG
////*/
HRESULT
CSDPTokenCache::NextToken(
    OUT ULONG *pulToken
    )
{
    ENTER_FUNCTION("CSDPTokenCache::NextToken(ULONG)");

    ClearErrorDesp();

    *pulToken = 0;

    if (IsListEmpty(&m_TokenEntry))
    {
        // no token left
        return S_FALSE;
    }

    // get first entry
    LIST_ENTRY *pEntry = RemoveHeadList(&m_TokenEntry);
    SDPTokenItem *pItem = CONTAINING_RECORD(pEntry, SDPTokenItem, Link);

    // ulong max
    const CHAR * const pszMaxULONG = "4294967295";
    const DWORD dwULONGSize = 10;

    // check the token length
    if (lstrlenA(pItem->pszToken) > dwULONGSize)
    {
        SetErrorDesp("invalid ULONG %s", pItem->pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeTokenItem(pItem);
        return E_FAIL;
    }

    // is every char valid
    CHAR c;
    for (int i=0; i<lstrlenA(pItem->pszToken); i++)
    {
        c = pItem->pszToken[i];

        if (c<'0' || c>'9')
        {
            SetErrorDesp("invalid ULONG %s", pItem->pszToken);

            LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
            
            FreeTokenItem(pItem);
            return E_FAIL;
        }
    }

    // check the value
    if (lstrlenA(pItem->pszToken) == dwULONGSize &&
        lstrcmpA(pItem->pszToken, pszMaxULONG) > 0)
    {
        SetErrorDesp("number %s out of ULONG range", pItem->pszToken);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeTokenItem(pItem);
        return E_FAIL;
    }

    // convert the string to ulong
    ULONG ul = 0;

    for (int i=0; i<lstrlenA(pItem->pszToken); i++)
    {
        ul = ul*10 + (pItem->pszToken[i]-'0');
    }

    *pulToken = ul;

    FreeTokenItem(pItem);
    return S_OK;
}

//
// protected methods
//

#define ENDOFLINE \
    ((pszString[dwEnd]=='\0')       || \
     (pszString[dwEnd-1]=='\r' && pszString[dwEnd]=='\n') || \
     ((m_dwLooseMask & SDP_LOOSE_CRLF) && pszString[dwEnd]=='\n'))

// break a string into lines
HRESULT
CSDPTokenCache::StringToLines(
    IN CHAR *pszString
    )
{
    ENTER_FUNCTION("CSDPTokenCache::StringToLines");

    HRESULT hr;

    if (pszString == NULL ||
        pszString[0] == '\0' ||
        pszString[0] == '\r' ||
        pszString[0] == '\n')
    {
        LOG((RTC_ERROR, "%s input string null or invalid 1st char", __fxName));

        SetErrorDesp("first char invalid");

        return E_FAIL;
    }

    // begin position
    DWORD dwBegin = 0;
    
    // position of the char to be read
    DWORD dwEnd = 1;

    // read lines
    while (TRUE)
    {
        // read a line
        while (!ENDOFLINE)
        {
            // read the char
            dwEnd ++;                   // move dwEnd
        }

        // is the line valid?
        // and need to find out the end of the line
        DWORD dwStrEnd;

        if (pszString[dwEnd] == '\0')
        {
            if (!(m_dwLooseMask & SDP_LOOSE_ENDCRLF))
            {
                SetErrorDesp("no CRLF at the end of the SDP blob");

                LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
                FreeLines();
                return E_FAIL;
            }

            dwStrEnd = dwEnd-1;
        }
        else
        {
            // pszString[dwEnd] must be '\n'
            if (pszString[dwEnd-1] == '\r')
            {
                // ....\r\n
                dwStrEnd = dwEnd-2;
            }
            else
            {
                // ....\n
                dwStrEnd = dwEnd-1;
            }
        }

        // put the line into the line list
        if (FAILED(hr = LineIntoList(pszString, dwBegin, dwStrEnd)))
        {
            LOG((RTC_ERROR, "%s line into list.", __fxName));

            // ignore unknown lines

            // FreeLines();
            // return hr;
        }

        // prepare the beginning of the next line
        dwBegin = dwEnd+1;

        if (pszString[dwBegin] == '\0')
            break;

        if (pszString[dwBegin] == '\r' ||
            pszString[dwBegin] == '\n')
        {
            LOG((RTC_ERROR, "%s null line", __fxName));

            SetErrorDesp("null line in SDP blob");

            FreeLines();
            return E_FAIL;
        }

        dwEnd = dwBegin+1;
    }

    // finished parsing, check we can stop after the last line
    if (IsListEmpty(&m_LineEntry))
    {
        SetErrorDesp("no line accepted");

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
        return E_FAIL;
    }

    SDPLineItem *pItem = CONTAINING_RECORD(m_LineEntry.Blink, SDPLineItem, Link);

    if (g_LineStates[pItem->dwIndex].fCanStop)
        return S_OK;
    else
    {
        SetErrorDesp("SDP blob ended at line %c=...", g_LineStates[pItem->dwIndex].ucLineType);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));

        FreeLines();
        return E_FAIL;
    }
}

/*//////////////////////////////////////////////////////////////////////////////
    insert a new line into the line list
////*/

HRESULT
CSDPTokenCache::LineIntoList(
    IN CHAR *pszInputString,
    IN DWORD dwFirst,
    IN DWORD dwLast
    )
{
    ENTER_FUNCTION("CSDPTokenCache::LineIntoList");

    CHAR pszInternalString[4];

    CHAR *pszString;

    // is the line string valid? size should > 2
    if (dwLast-dwFirst+1 < 2)
    {
        SetErrorDesp("empty line in the SDP blob");

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
        return E_FAIL;
    }

    // others may not follow the SIP RFC and feed us an empty line
    // so we need to be flexible.
    if (dwLast-dwFirst+1 == 2)
    {
        LOG((RTC_WARN, "%s we got an empty line %c%c",
            __fxName, pszInputString[dwFirst], pszInputString[dwLast]));

        pszInternalString[0] = pszInputString[dwFirst];
        pszInternalString[1] = pszInputString[dwLast];
        pszInternalString[2] = ' '; // fake a blank
        pszInternalString[3] = '\0'; // play safe

        dwFirst = 0;
        dwLast = 1;
        pszString = pszInternalString;
    }
    else
    {
        pszString = pszInputString;
    }

    // are first two chars valid?
    CHAR chLineType = pszString[dwFirst];

    if (chLineType >= 'A' && chLineType <= 'Z')
    {
        chLineType -= 'A';
        chLineType += 'a';
    }

    if (chLineType < 'a' || chLineType > 'z')
    {
        SetErrorDesp("invalid line %c", chLineType);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
        return E_FAIL;
    }

    if (pszString[dwFirst+1] != '=')
    {
        SetErrorDesp("line begin with %c%c", chLineType, pszString[dwFirst+1]);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
        return E_FAIL;
    }

    // get current line index
    // NOTE: m_dwCurrentLineIdx is only used in parsing lines
    DWORD dwIndex;
    SDPLineItem *pItem = NULL;

    if (IsListEmpty(&m_LineEntry))
    {
        // no line yet
        dwIndex = 0;
    }
    else
    {
        pItem = CONTAINING_RECORD(m_LineEntry.Blink, SDPLineItem, Link);

        dwIndex = pItem->dwIndex;

        pItem = NULL;
    }

    // check if we shall accept it
    DWORD dwNext;

    if (::Accept(dwIndex, chLineType, &dwNext))
    {
        // new line item
        pItem = (SDPLineItem*)RtcAlloc(sizeof(SDPLineItem));

        if (pItem == NULL)
        {
            LOG((RTC_ERROR, "%s new sdplineitem", __fxName));
            return E_OUTOFMEMORY;
        }

        // setup the line: size - 2[skip 1st 2 char] + 1[\0]
        pItem->pszLine = (CHAR*)RtcAlloc(sizeof(CHAR)*(dwLast-dwFirst));

        if (pItem->pszLine == NULL)
        {
            LOG((RTC_ERROR, "%s RtcAlloc line", __fxName));
            
            RtcFree(pItem);
        }

        // skip first two char "x="
        for (DWORD i=dwFirst+2; i<=dwLast; i++)
        {
            // copy the line
            pItem->pszLine[i-dwFirst-2] = pszString[i];
        }

        pItem->pszLine[dwLast-dwFirst-1] = '\0';

        // setup index
        pItem->dwIndex = dwNext;

        // put it in the list
        InsertTailList(&m_LineEntry, &pItem->Link);
    }
    else if (::Reject(dwIndex, chLineType))
    {
        SetErrorDesp("invalid line %c=...", chLineType);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
        return E_FAIL;
    }
    // else ignore the line

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    insert a new token into the token list
////*/

HRESULT
CSDPTokenCache::TokenIntoList(
    IN CHAR *pszString,
    IN DWORD dwFirst,
    IN DWORD dwLast
    )
{
    ENTER_FUNCTION("CSDPTokenCache::TokenIntoList");

    // get current line state
    const SDPLineState *pState = &g_LineStates[m_dwCurrentLineIdx];

    // is the token valid? size should > 0
    if (dwLast-dwFirst+1 < 1)
    {
        SetErrorDesp("empty token in line %c=", pState->ucLineType);

        LOG((RTC_ERROR, "%s %s", __fxName, GetErrorDesp()));
        return E_FAIL;
    }

        // new token item
    SDPTokenItem *pItem = (SDPTokenItem*)RtcAlloc(sizeof(SDPTokenItem));

    if (pItem == NULL)
    {
        LOG((RTC_ERROR, "%s new sdptokenitem", __fxName));
        return E_OUTOFMEMORY;
    }

    // setup the token
    pItem->pszToken = (CHAR*)RtcAlloc(sizeof(CHAR)*(dwLast-dwFirst+2));

    if (pItem->pszToken == NULL)
    {
        LOG((RTC_ERROR, "%s RtcAlloc token", __fxName));
        
        RtcFree(pItem);

        return E_OUTOFMEMORY;
    }

    for (DWORD i=dwFirst; i<=dwLast; i++)
    {
        // copy the token
        pItem->pszToken[i-dwFirst] = pszString[i];
    }

    pItem->pszToken[dwLast-dwFirst+1] = '\0';

    // put it in the list
    InsertTailList(&m_TokenEntry, &pItem->Link);

    return S_OK;
}

// break a line into tokens
HRESULT
CSDPTokenCache::LineToTokens(
    IN SDPLineItem *pItem
    )
{
    ENTER_FUNCTION("CSDPTokenCache::LineToTokens");

    HRESULT hr;

    FreeTokens();

    const SDPLineState *pState = &g_LineStates[pItem->dwIndex];

    const SDP_DELIMIT_TYPE *DelimitType = pState->DelimitType;
    const CHAR * const *pszDelimit = (CHAR**)pState->pszDelimit;

    // dwBegin: the first char of the token
    // dwEnd: the last char

    DWORD dwBegin = 0;
    DWORD dwEnd;

    // shall we skip any ' ' space?
    if (m_dwLooseMask & SDP_LOOSE_SPACE)
        while (pItem->pszLine[dwBegin] == ' ') dwBegin ++;

    dwEnd = dwBegin;

    // reach end of string
    if (pItem->pszLine[dwBegin] == '\0')
        return S_OK;

    // which type of token we are to read

    for (int i=0; pszDelimit[i]!=NULL; i++)
    {
        /*//////////////////////////////*/

        if (DelimitType[i] == SDP_DELIMIT_EXACT_STRING)
        {
            // match the exact string
            if (lstrcmpA(&pItem->pszLine[dwBegin], pszDelimit[i]) != 0)
            {
                // not match, try next type
                continue;
            }

            // match, read the token
            dwEnd = lstrlenA(pItem->pszLine)-1;

            if (FAILED(hr = TokenIntoList(pItem->pszLine, dwBegin, dwEnd)))
            {
                LOG((RTC_ERROR, "%s tokenintolist. %x", __fxName, hr));

                FreeTokens();
                return hr;
            }

            // finishing
            break;
        }

        /*//////////////////////////////*/

        else if (DelimitType[i] == SDP_DELIMIT_CHAR_BOUNDARY)
        {
            // use delimit string

            int k=0;

            while (k<lstrlenA(pszDelimit[i]))
            {
                // read until the delimit
                while (pItem->pszLine[dwEnd] != pszDelimit[i][k] &&    // not delimit
                       pItem->pszLine[dwEnd] != '\0')               // not end of string
                    dwEnd ++;

                // token into list
                if (FAILED(hr = TokenIntoList(pItem->pszLine, dwBegin, dwEnd-1)))
                {
                    LOG((RTC_ERROR, "%s tokenintolist. %x", __fxName, hr));

                    FreeTokens();
                    return hr;
                }

                // end of string?
                if (pItem->pszLine[dwEnd] == '\0')
                    return S_OK;

                // we must got the delimit
                // move token begin forward

                dwBegin = dwEnd+1;

                // skip any space?
                if (m_dwLooseMask & SDP_LOOSE_SPACE)
                    while (pItem->pszLine[dwBegin] == ' ') dwBegin ++;

                if (pItem->pszLine[dwBegin] == '\0')
                    // no more token left
                    return S_OK;

                dwEnd = dwBegin;
                
                // move the delimit forward
                k++;

                if (pszDelimit[i][k] == '\r')
                {
                    // should repeat the previous delimit
                    k --;
                }
                else if (pszDelimit[i][k] == '\0')
                {
                    // no delimit left, just take the rest of the line
                    dwEnd = lstrlenA(pItem->pszLine)-1;

                    if (FAILED(hr = TokenIntoList(pItem->pszLine, dwBegin, dwEnd)))
                    {
                        LOG((RTC_ERROR, "%s tokenintolist. %x", __fxName, hr));

                        FreeTokens();
                        return hr;
                    }
                } // if (delimit char)
            } // for each delimit char
        } // if delimit type is char boundary

        /*//////////////////////////////*/

        else // take the whole string
        {
            dwEnd = lstrlenA(pItem->pszLine)-1;

            if (FAILED(hr = TokenIntoList(pItem->pszLine, dwBegin, dwEnd)))
            {
                LOG((RTC_ERROR, "%s tokenintolist. %x", __fxName, hr));

                FreeTokens();
                return hr;
            }
        }
    }
    
    return S_OK;
}

// RtcFree the line list
void
CSDPTokenCache::FreeLineItem(
    IN SDPLineItem *pItem
    )
{
    if (pItem)
    {
        if (pItem->pszLine)
            RtcFree(pItem->pszLine);

        RtcFree(pItem);
    }
}

void
CSDPTokenCache::FreeLines()
{
    LIST_ENTRY *pEntry;
    SDPLineItem *pItem;

    while (!IsListEmpty(&m_LineEntry))
    {
        // get first entry
        pEntry = RemoveHeadList(&m_LineEntry);
    
        // get item
        pItem = CONTAINING_RECORD(pEntry, SDPLineItem, Link);

        FreeLineItem(pItem);
    }

    m_pszCurrentLine[0] = '\0';
    m_dwCurrentLineIdx = 0;
}

// RtcFree the token list

void
CSDPTokenCache::FreeTokenItem(
    IN SDPTokenItem *pItem
    )
{
    if (pItem)
    {
        if (pItem->pszToken)
            RtcFree(pItem->pszToken);

        RtcFree(pItem);
    }
}

void
CSDPTokenCache::FreeTokens()
{
    LIST_ENTRY *pEntry;
    SDPTokenItem *pItem;

    while (!IsListEmpty(&m_TokenEntry))
    {
        // get first entry
        pEntry = RemoveHeadList(&m_TokenEntry);
    
        // get item
        pItem = CONTAINING_RECORD(pEntry, SDPTokenItem, Link);

        FreeTokenItem(pItem);
    }
}

void
CSDPTokenCache::ClearErrorDesp()
{
    m_pszErrorDesp[0] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\stdafx.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    stdafx.h

Abstract:

    Includes files that are used frequently, but are changed infrequently.

Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>

#ifdef STRICT
#undef STRICT
#endif

// atl, com
#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>

// amovie
#include <streams.h>

// mixer
#include <mmsystem.h>

// WAVEFORMATEX
#include <mmreg.h>

// socket
#include <winsock2.h>

// ras/routing
#include <iphlpapi.h>

#include <stdio.h>

#include <dpnathlp.h>

// direct show
#include <strmif.h>
#include <control.h>
#include <uuids.h>

// terminal manager, IVideoWindow
#include <tapi3if.h>
#include <termmgr.h>

// rtp
#include <tapirtp.h>

// IStreamConfig
#include <h245if.h>

// dxmrtp
// IAudioDeviceControl and ISilenceControl
#include <tapiaud.h>
#include <tapivid.h>

// Netmeeting
#include <imsconf3.h>
#include <sdkinternal.h>

#include "rtcmem.h"

#ifdef RTCMEDIA_DLL
#include "dllres.h"
#endif

#include "rtcerr.h"
#include "rtcsip.h"
#include "rtccore.h"

// rtc streaming
#define RTC_MAX_NAME_LEN 32

// sdp.idl
// #include "sdp.h"

// rtcmedia.idl
// #include "rtcmedia.h"

// private.idl
#include "private.h"

#include "Parser.h"

#include "MediaReg.h"

// array, auto lock, log stuff
#include "utility.h"
#include "debug.h"

// quality control
#include "QualityControl.h"

// look up table used in parsing sdp
#include "SDPTable.h"

// null render for audio capt tuning
#include "Filter.h"

#include "Network.h"
#include "DTMF.h"

// sdp classes
class CSDPTokenCache;
class CSDPParser;
class CSDPSession;
class CSDPMedia;
class CRTPFormat;

#include "SDPTokenCache.h"
#include "SDPParser.h"
#include "SDPSession.h"
#include "SDPMedia.h"
#include "RTPFormat.h"

// streaming classes
class CRTCMediaCache;
class CRTCMediaController;
class CRTCMedia;
class CRTCStream;
class CRTCTerminal;

#include "Codec.h"
#include "Terminal.h"
#include "AudioTuner.h"
#include "VideoTuner.h"
#include "MediaCache.h"
#include "PortCache.h"
#include "MediaController.h"
#include "Stream.h"
#include "Media.h"
#include "nmcall.h"

// debug/assert

#ifdef ENABLE_TRACING
#define ENTER_FUNCTION(s) \
    static const CHAR * const __fxName = s
#else
#define ENTER_FUNCTION(s)
#endif

#ifdef BREAK_ASSERT   // checked build
#undef _ASSERT
#undef _ASSERTE
#define _ASSERT(expr)  { if (!(expr)) DebugBreak(); }
#define _ASSERTE(expr)  { if (!(expr)) DebugBreak(); }
#endif

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\sdptable.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SDPTable.cpp

Abstract:


Author:

    Qianbo Huai (qhuai) 6-Sep-2000

--*/

#include "stdafx.h"

// format code and name pair
typedef struct RTPFormatCodeName
{
    DWORD  dwCode;
    CHAR * pszName;

} RTPFormatCodeName;


/*//////////////////////////////////////////////////////////////////////////////
    global line states
////*/

const SDPLineState g_LineStates[] =
{
    // initial state
    {
        SDP_STAGE_NONE,
        (UCHAR)0,

        {SDP_STAGE_SESSION, SDP_STAGE_NONE},
        {'v', '\0'},
        "abcdefghijklmnopqrstuwxyz",

        FALSE,

        {SDP_DELIMIT_NONE},
        {NULL},
    },

    // v=
    {
        SDP_STAGE_SESSION,
        'v',

        {SDP_STAGE_SESSION, SDP_STAGE_NONE},
        {'o', '\0'},
        "abcdefghijklmnpqrstuvwxyz",

        FALSE,

        {SDP_DELIMIT_NONE, SDP_DELIMIT_NONE},
        {"", NULL}
    },

    // o=
    {
        SDP_STAGE_SESSION,
        'o',

        {SDP_STAGE_SESSION, SDP_STAGE_NONE},
        {'s', '\0'},
        "abcdefghijklmnopqrtuvwxyz",

        FALSE,

        {SDP_DELIMIT_NONE, SDP_DELIMIT_NONE},
        {"", NULL}
    },

    // s=
    {
        SDP_STAGE_SESSION,
        's',

        {SDP_STAGE_SESSION, SDP_STAGE_SESSION, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'c', 'a', 'm', '\0'},
        "osv",

        FALSE,

        {SDP_DELIMIT_NONE, SDP_DELIMIT_NONE},
        {"", NULL}
    },

    // c=
    {
        SDP_STAGE_SESSION,
        'c',

        {SDP_STAGE_SESSION, SDP_STAGE_SESSION, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'b', 'a', 'm', '\0'},
        "vosiuepc",

        FALSE,

        {SDP_DELIMIT_CHAR_BOUNDARY, SDP_DELIMIT_NONE},
        {"  ", NULL}  // nettype space addrtype space conn-addr
    },

    // b=
    {
        SDP_STAGE_SESSION,
        'b',

        {SDP_STAGE_SESSION, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'a', 'm', '\0'},
        "vosiuepcb",

        FALSE,

        {SDP_DELIMIT_CHAR_BOUNDARY, SDP_DELIMIT_NONE},
        {":", NULL}  // modifier <:> value
    },

    // a=
    {
        SDP_STAGE_SESSION,
        'a',

        {SDP_STAGE_SESSION, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'a', 'm', '\0'},
        "vosiuepcbk",

        FALSE,

        {SDP_DELIMIT_EXACT_STRING, SDP_DELIMIT_EXACT_STRING, SDP_DELIMIT_NONE},
        {"sendonly", "recvonly", NULL}
    },

    // m=
    {
        SDP_STAGE_MEDIA,
        'm',

        {SDP_STAGE_MEDIA, SDP_STAGE_MEDIA, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'c', 'a', 'm', '\0'},
        "vosiuepcbkt",

        TRUE,

        {SDP_DELIMIT_CHAR_BOUNDARY, SDP_DELIMIT_NONE},
        {" \r", NULL}, // media space port space proto space 1*(space fmt)
    },

    // c= in media
    {
        SDP_STAGE_MEDIA,
        'c',

        {SDP_STAGE_MEDIA, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'a', 'm', '\0'},
        "vosiuepc",

        TRUE,

        {SDP_DELIMIT_CHAR_BOUNDARY, SDP_DELIMIT_NONE},
        {"  ", NULL}, // nettype space addrtype space conn-addr
    },

    // a= in media
    {
        SDP_STAGE_MEDIA,
        'a',

        {SDP_STAGE_MEDIA, SDP_STAGE_MEDIA, SDP_STAGE_NONE},
        {'a', 'm', '\0'},
        "vosiuepc",

        TRUE,

        {SDP_DELIMIT_EXACT_STRING,
         SDP_DELIMIT_EXACT_STRING,
         SDP_DELIMIT_CHAR_BOUNDARY,
         SDP_DELIMIT_NONE},

        {"sendonly",
         "recvonly",
         ": / /",   // rtpmap:formatcode name/samplerate/channel
         NULL}
    }
};

const DWORD g_dwLineStatesNum = sizeof(g_LineStates) /
                                sizeof(SDPLineState);

/*//////////////////////////////////////////////////////////////////////////////
    list of rtp format code and name pair
////*/

const RTPFormatCodeName g_FormatCodeNames[] =
{
    {0,     "PCMU"},
    {3,     "GSM"},
    {4,     "G723"},
    {5,     "DVI4"},
    {6,     "DVI4"},
    {8,     "PCMA"},
    {11,    "L16"},
    {111,   "SIREN"},
    {112,   "G7221"},
    {113,   "MSAUDIO"},
    {31,    "H261"},
    {34,    "H263"}
};

const DWORD g_dwFormatCodeNamesNum = sizeof(g_FormatCodeNames) /
                                     sizeof(RTPFormatCodeName);

const CHAR * const g_pszAudioM = "\
m=audio 0 RTP/AVP 97 111 112 6 0 8 4 5 3 101\r\n\
";

const CHAR * const g_pszAudioRTPMAP = "\
a=rtpmap:97 red/8000\r\n\
a=rtpmap:111 SIREN/16000\r\n\
a=fmtp:111 bitrate=16000\r\n\
a=rtpmap:112 G7221/16000\r\n\
a=fmtp:112 bitrate=24000\r\n\
a=rtpmap:6 DVI4/16000\r\n\
a=rtpmap:0 PCMU/8000\r\n\
a=rtpmap:8 PCMA/8000\r\n\
a=rtpmap:4 G723/8000\r\n\
a=rtpmap:5 DVI4/8000\r\n\
a=rtpmap:3 GSM/8000\r\n\
a=rtpmap:101 telephone-event/8000\r\n\
a=fmtp:101 0-16\r\n\
";

const CHAR * const g_pszVideoM = "\
m=video 0 RTP/AVP 34 31\r\n\
";

const CHAR * const g_pszVideoRTPMAP = "\
a=rtpmap:34 H263/90000\r\n\
a=rtpmap:31 H261/90000\r\n\
";

const CHAR * const g_pszDataM = "\
m=application 1503 tcp msdata\r\n\
";

/*//////////////////////////////////////////////////////////////////////////////
    helper functions
////*/

// get index in the table
DWORD
Index(
    IN SDP_PARSING_STAGE Stage,
    IN UCHAR ucLineType
    )
{
    for (int i=0; i<g_dwLineStatesNum; i++)
    {
        if (g_LineStates[i].Stage == Stage &&
            g_LineStates[i].ucLineType == ucLineType)
            return i;
    }

    // return initial state
    return 0;
}

// check if accept (TRUE)
BOOL
Accept(
    IN DWORD dwCurrentIndex,
    IN UCHAR ucLineType,
    OUT DWORD *pdwNextIndex
    )
{
    _ASSERT(dwCurrentIndex < g_dwLineStatesNum);

    const SDPLineState *pState = &g_LineStates[dwCurrentIndex];

    for (int i=0; pState->ucNextLineType[i]!='\0'; i++)
    {
        // match the line type?
        if (ucLineType == pState->ucNextLineType[i])
        {
            *pdwNextIndex = Index(pState->NextStage[i], ucLineType);

            return TRUE;
        }
    }

    return FALSE;
}

// check if reject (TRUE)
BOOL
Reject(
    IN DWORD dwCurrentIndex,
    IN UCHAR ucLineType
    )
{
    _ASSERT(dwCurrentIndex < g_dwLineStatesNum);

    const SDPLineState *pState = &g_LineStates[dwCurrentIndex];

    // check if we need to reject it
    CHAR *pszReject = pState->pszRejectLineType;

    for (int i=0; i<lstrlenA(pszReject); i++)
    {
        if (ucLineType == pszReject[i])
            return TRUE;
    }

    return FALSE;
}

// get format name
const CHAR * const g_pszDefaultFormatName = "dynamic";

const CHAR *
GetFormatName(
    IN DWORD dwCode
    )
{
    for (int i=0; i<g_dwFormatCodeNamesNum; i++)
    {
        if (dwCode == g_FormatCodeNames[i].dwCode)
        {
            return g_FormatCodeNames[i].pszName;
        }
    }

    return g_pszDefaultFormatName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\streamaudsend.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    StreamAudSend.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

CRTCStreamAudSend::CRTCStreamAudSend()
    :CRTCStream()
    ,m_rtpf_pIRtpDtmf(NULL)
    ,m_edgf_pIAudioInputMixer(NULL)
    ,m_edgf_pIAudioDeviceControl(NULL)
    ,m_edgp_pISilenceControl(NULL)
    ,m_rtpf_pIRtpRedundancy(NULL)
    ,m_fRedEnabled(FALSE)
    ,m_dwRedCode((DWORD)-1)
    ,m_dwCurrCode((DWORD)-1)
    ,m_dwCurrDuration((DWORD)-1)
{
    m_MediaType = RTC_MT_AUDIO;
    m_Direction = RTC_MD_CAPTURE;
}

/*
CRTCStreamAudSend::~CRTCStreamAudSend()
{
}
*/

HRESULT
CRTCStreamAudSend::BuildGraph()
{
    ENTER_FUNCTION("CRTCStreamAudSend::BuildGraph");

    LOG((RTC_TRACE, "%s entered. stream=%p", __fxName, static_cast<IRTCStream*>(this)));

    HRESULT hr;

    DWORD dwPinNum;
    CComPtr<IPin> pTermPin;
    CComPtr<IBaseFilter> pTermFilter;
    CComPtr<IAudioDeviceConfig> pAudioDeviceConfig;
    CComPtr<IAudioEffectControl> pAudioEffectControl;

    CRTCMedia *pCMedia;

    BOOL fAECNeeded;

    // connect terminal
    if (FAILED(hr = m_pTerminalPriv->ConnectTerminal(
        m_pMedia,
        m_pIGraphBuilder
        )))
    {
        LOG((RTC_ERROR, "%s connect terminal. %x", __fxName, hr));
        goto Error;
    }

    // get terminal pin
    dwPinNum = 1;
    hr = m_pTerminalPriv->GetPins(&dwPinNum, &pTermPin);

    if (FAILED(hr) || dwPinNum != 1)
    {
        LOG((RTC_ERROR, "%s get pins %d on terminal. %x", __fxName, dwPinNum, hr));

        if (!FAILED(hr))
        {
            hr = E_FAIL;
        }

        goto Error;
    }

    // try to get stream config
    // if success, we don't need encoder filter
    hr = pTermPin->QueryInterface(&m_edgp_pIStreamConfig);

    if (S_OK == hr)
    {
    }
    else if (E_NOINTERFACE == hr)
    {
        LOG((RTC_ERROR, "%s are we using our own terminal?", __fxName));

        goto Error;
    }
    else
    {
        LOG((RTC_ERROR, "%s get stream config on terminal. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = pTermPin->QueryInterface(&m_edgp_pIBitrateControl)))
    {
        LOG((RTC_ERROR, "%s get ibitratecontrol. %x", __fxName, hr));

        goto Error;
    }

    // get terminal filter
    if (FAILED(hr = ::FindFilter(pTermPin, &pTermFilter)))
    {
        LOG((RTC_ERROR, "%s get terminal filter. %x", __fxName));

        goto Error;
    }

    // put audio duplex
    pCMedia = static_cast<CRTCMedia*>(m_pMedia);

    if (pCMedia->m_pIAudioDuplexController == NULL)
    {
        LOG((RTC_WARN, "%s audio duplex not supported", __fxName));
    }
    else
    {
        if (FAILED(hr = pTermFilter->QueryInterface(&pAudioDeviceConfig)))
        {
            LOG((RTC_ERROR, "%s QI audio device config. %x", __fxName, hr));
        }
        else
        {
            if (FAILED(hr = pAudioDeviceConfig->SetDuplexController(
                    pCMedia->m_pIAudioDuplexController
                    )))
            {
                LOG((RTC_ERROR, "%s set audio duplex controller. %x", __fxName, hr));
            }
        }
    }

    // create rtp filter
    if (m_rtpf_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CoCreateInstance(
                __uuidof(MSRTPRenderFilter),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &m_rtpf_pIBaseFilter
                )))
        {
            LOG((RTC_ERROR, "%s, create RTP filter %x", __fxName, hr));

            goto Error;
        }

        // cache interface
        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpMediaControl
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp media control. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpSession
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp session. %x", __fxName, hr));

            goto Error;
        }
    }

    // add rtp filter
    if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            m_rtpf_pIBaseFilter,
            L"AudSendRtp"
            )))
    {
        LOG((RTC_ERROR, "%s add rtp filter. %x", __fxName, hr));

        goto Error;
    }

    // hack: rtp need default format mapping
    if (FAILED(hr = ::PrepareRTPFilter(
            m_rtpf_pIRtpMediaControl,
            m_edgp_pIStreamConfig
            )))
    {
        LOG((RTC_ERROR, "%s prepare rtp format mapping. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = pTermFilter->QueryInterface(&pAudioEffectControl)))
    {
        LOG((RTC_ERROR, "%s QI IAudioEffectControl", __fxName, hr));

        goto Error;
    }

    fAECNeeded = IsAECNeeded();

    LOG((RTC_TRACE, "Enable AEC:%d on AudSend stream %p", fAECNeeded, this));

    if (fAECNeeded)
    {
        // must set before connect filters
        pAudioEffectControl->SetDsoundAGC(TRUE);
    }

    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            pTermPin,
            m_rtpf_pIBaseFilter
            )))
    {
        LOG((RTC_ERROR, "%s connect terminal & rtp. %x", __fxName, hr));

        goto Error;
    }

    // cache additional interfaces
    if (m_edgf_pIAudioInputMixer == NULL)
    {
        if (FAILED(hr = pTermFilter->QueryInterface(&m_edgf_pIAudioInputMixer)))
        {
            LOG((RTC_WARN, "%s QI IAudioInputMixer. %x", __fxName, hr));
        }
    }

    if (m_edgf_pIAudioDeviceControl == NULL)
    {
        if (FAILED(hr = pTermFilter->QueryInterface(&m_edgf_pIAudioDeviceControl)))
        {
            LOG((RTC_WARN, "%s QI IAudioDeviceControl. %x", __fxName, hr));
        }
    }

    // AEC will be enabled later
    // this step is needed to let AGC know not to increase gain with AEC enabled
    if (fAECNeeded)
    {
        if (FAILED(hr = m_edgf_pIAudioDeviceControl->Set(
                AudioDevice_AcousticEchoCancellation,
                1,
                TAPIControl_Flags_None
                )))
        {
            LOG((RTC_ERROR, "%s set AEC via IAudioDeviceControl. %x", __fxName, hr));
        }
    }
    //else
    //{

        // set gain inc revert effect
        pAudioEffectControl->SetGainIncRevert(TRUE);
    //}

    if (m_edgp_pISilenceControl == NULL)
    {
        if (FAILED(hr = pTermPin->QueryInterface(&m_edgp_pISilenceControl)))
        {
            LOG((RTC_WARN, "%s QI ISilenceControl. %x", __fxName, hr));
        }
    }

    // complete connect terminal
    if (FAILED(hr = m_pTerminalPriv->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect term. %x", __fxName, hr));
    }

    LOG((RTC_TRACE, "%s exiting.", __fxName));

    return S_OK;

Error:

    CleanupGraph();

    return hr;
}

void
CRTCStreamAudSend::CleanupGraph()
{
    if (m_rtpf_pIRtpDtmf)
    {
        m_rtpf_pIRtpDtmf->Release();
        m_rtpf_pIRtpDtmf = NULL;
    }

    if (m_edgf_pIAudioInputMixer)
    {
        m_edgf_pIAudioInputMixer->Release();
        m_edgf_pIAudioInputMixer = NULL;
    }

    if (m_edgf_pIAudioDeviceControl)
    {
        m_edgf_pIAudioDeviceControl->Release();
        m_edgf_pIAudioDeviceControl = NULL;
    }

    if (m_edgp_pISilenceControl)
    {
        m_edgp_pISilenceControl->Release();
        m_edgp_pISilenceControl = NULL;
    }

    if (m_rtpf_pIRtpRedundancy)
    {
        m_rtpf_pIRtpRedundancy->Release();
        m_rtpf_pIRtpRedundancy = NULL;
    }

    CRTCStream::CleanupGraph();
}

/*
HRESULT
CRTCStreamAudSend::SetupFormat()
{
    return E_NOTIMPL;
}
*/

VOID
CRTCStreamAudSend::AdjustBitrate(
    IN DWORD dwBandwidth,
    IN DWORD dwLimit,
    IN BOOL fHasVideo,
    OUT DWORD *pdwNewBW,
    OUT BOOL *pfFEC
    )
{
    ENTER_FUNCTION("CRTCStreamAudSend::AdjustBitrate");

    *pdwNewBW = 0;
    *pfFEC = FALSE;

    if (m_edgp_pIStreamConfig == NULL)
    {
        LOG((RTC_WARN, "%s IStreamConfig not ready", __fxName));
        return;
    }

    DWORD dwSuggested = m_pQualityControl->GetSuggestedBandwidth();

    // order codec list based on bandwidth

    // dynamic change codec based on limit if the bandwidth is not estimated
    // the difference between allocated bandwidth and limit is that
    // the former takes into consideration of lossrate
    m_Codecs.Set(
        CRTCCodecArray::BANDWIDTH,
        dwSuggested==RTP_BANDWIDTH_NOTESTIMATED?dwBandwidth:dwLimit
        );

    m_Codecs.OrderCodecs(fHasVideo, m_pRegSetting);

    // get the code in use
    DWORD dwCode = m_Codecs.Get(CRTCCodecArray::CODE_INUSE);

    if (dwCode == (DWORD)-1)
    {
        LOG((RTC_ERROR, "%s no code in use stored", __fxName));
        return;
    }

    // get the 1st code
    CRTCCodec *pCodec = NULL;

    if (!m_Codecs.GetCodec(0, &pCodec))
    {
        LOG((RTC_ERROR, "%s no codec stored", __fxName));
        return;
    }

    // check if both codec is same
    if (!pCodec->IsMatch(dwCode))
    {
        dwCode = pCodec->Get(CRTCCodec::CODE);

        m_Codecs.TraceLogCodecs();
    }

    // codec duration might be changed

    // get code and am media type
    // for setting new format    

    AM_MEDIA_TYPE *pmt = pCodec->GetAMMediaType();

    HRESULT hr = S_OK;
    
    if (IsNewFormat(dwCode, pmt))
    {
        hr = m_edgp_pIStreamConfig->SetFormat(dwCode, pmt);

        SaveFormat(dwCode, pmt);
    }

    //
    // record new bandwidth
    //

    *pdwNewBW = CRTCCodec::GetBitrate(pmt);

    // plus header
    DWORD dwDuration = 0;

    dwDuration = CRTCCodec::GetPacketDuration(pmt);

    if (dwDuration == 0)
    {
        dwDuration = SDP_DEFAULT_AUDIO_PACKET_SIZE;
    }

    *pdwNewBW += PACKET_EXTRA_BITS * (1000/dwDuration);

    pCodec->DeleteAMMediaType(pmt);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s set format %d. %x", __fxName, dwCode, hr));
    }
    else
    {
        // store codec in use
        m_Codecs.Set(CRTCCodecArray::CODE_INUSE, dwCode);

        // setup qos
        hr = SetupQoS();

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s setup QOS. %x", __fxName, hr));
        }

        if (m_fRedEnabled && m_rtpf_pIRtpRedundancy != NULL)
        {
            // enable and disable redundancy based on bandwidth limit

            if (dwLimit <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)
            {
                hr = m_rtpf_pIRtpRedundancy->SetRedParameters(m_dwRedCode, 0, 0);

                //LOG((RTC_QUALITY, "Disable redundancy"));
            }
            else
            {
                hr = m_rtpf_pIRtpRedundancy->SetRedParameters(m_dwRedCode, -1, -1);

                *pfFEC = TRUE;
                //LOG((RTC_QUALITY, "Enable redundancy %d", m_dwRedCode));
            }
        }
    }

    return;
}

HRESULT
CRTCStreamAudSend::PrepareRedundancy()
{
    ENTER_FUNCTION("CRTCStreamAudSend::PrepareRedundancy");

    HRESULT hr = S_OK;

    m_fRedEnabled = FALSE;

    IRTPFormat **ppFormat;
    DWORD dwNum;

    // get the number of formats
    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwNum, NULL)))
    {
        LOG((RTC_ERROR, "%s get rtp format num. %x", __fxName, hr));

        return hr;
    }

    if (dwNum == 0)
    {
        LOG((RTC_ERROR, "%s no format.", __fxName));

        return E_FAIL;
    }

    // allocate format list
    ppFormat = (IRTPFormat**)RtcAlloc(sizeof(IRTPFormat*)*dwNum);

    if (ppFormat == NULL)
    {
        LOG((RTC_ERROR, "%s RtcAlloc format list", __fxName));

        return E_OUTOFMEMORY;
    }

    // get formats
    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwNum, ppFormat)))
    {
        LOG((RTC_ERROR, "%s really get formats. %x", __fxName, hr));

        RtcFree(ppFormat);

        return hr;
    }

    // set mapping on rtp
    RTP_FORMAT_PARAM param;

    BOOL fRedundant = FALSE;

    for (DWORD i=0; i<dwNum; i++)
    {
        // get param
        if (FAILED(hr = ppFormat[i]->GetParam(&param)))
        {
            LOG((RTC_ERROR, "%s get param on %dth format. %x", __fxName, i, hr));
            break;
        }

        // check redundant, sigh
        if (lstrcmpA(param.pszName, "red") == 0)
        {
            fRedundant = TRUE;
            m_dwRedCode = param.dwCode;
            break;
        }
    }

    // release formats
    for (DWORD i=0; i<dwNum; i++)
    {
        ppFormat[i]->Release();
    }

    RtcFree(ppFormat);

    // setup redundancy
    if (fRedundant)
    {
        // send side
        CComPtr<ISDPSession> pSession;
        m_pISDPMedia->GetSession(&pSession);

        SDP_SOURCE src;
        pSession->GetSDPSource(&src);

        // we can configure redundancy on sender only when we get back
        // the sdp from the remote party
        m_fRedEnabled = (src != SDP_SOURCE_LOCAL);

        if (m_fRedEnabled)
        {
            if (m_rtpf_pIRtpRedundancy == NULL)
            {
                hr = m_rtpf_pIRtpMediaControl->QueryInterface(&m_rtpf_pIRtpRedundancy);

                if (FAILED(hr))
                {
                    LOG((RTC_ERROR, "%s QI rtp redundancy. %x", __fxName, hr));

                    return hr;
                }
            }

            //if (m_pQualityControl->GetBitrateAlloc() <=
                    //CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)
            //{
                //hr = m_rtpf_pIRtpRedundancy->SetRedParameters(m_dwRedCode, 0, 0);

                //LOG((RTC_QUALITY, "Disable redundancy"));
            //}
            //else
            //{
                //hr = m_rtpf_pIRtpRedundancy->SetRedParameters(m_dwRedCode, -1, -1);

                //LOG((RTC_QUALITY, "Enable redundancy %d", m_dwRedCode));
            //}

            //if (FAILED(hr))
            //{
                //LOG((RTC_ERROR, "%s set red param. %x", __fxName, hr));
            //}
        }
    }

    return hr;
}

STDMETHODIMP
CRTCStreamAudSend::Synchronize()
{
    HRESULT hr = CRTCStream::Synchronize();

    if (S_OK == hr)
    {
        PrepareRedundancy();
    }

    return hr;
}

STDMETHODIMP
CRTCStreamAudSend::SendDTMFEvent(
    IN BOOL fOutOfBand,
    IN DWORD dwCode,
    IN DWORD dwId,
    IN DWORD dwEvent,
    IN DWORD dwVolume,
    IN DWORD dwDuration,
    IN BOOL fEnd
    )
{
    ENTER_FUNCTION("CRTCStreamAudSend::SendDTMFEvent");

    LOG((RTC_TRACE, "SendDTMFEvent: event=%d, vol=%d, dur=%d, end=%d",
        dwEvent, dwVolume, dwDuration, fEnd));

    HRESULT hr;

    // inband DTMF
    if (!fOutOfBand)
    {
        if (m_edgf_pIAudioDeviceControl)
        {
            CComPtr<IAudioDTMFControl> pDTMFControl;

            if (FAILED(hr = m_edgf_pIAudioDeviceControl->QueryInterface(&pDTMFControl)))
            {
                LOG((RTC_ERROR, "%s QI DTMF control", __fxName));

                return hr;
            }

            if (FAILED(hr = pDTMFControl->SendDTMFEvent(dwEvent)))
            {
                LOG((RTC_ERROR, "%s send dtmf event", __fxName));

                return hr;
            }
        }
        else
        {
            LOG((RTC_ERROR, "%s no audio device control", __fxName));

            return RTC_E_SIP_NO_STREAM;
        }

        return S_OK;
    }

    // out-of-band DTMF
    if (!m_rtpf_pIBaseFilter)
    {
        LOG((RTC_ERROR, "%s no base filter", __fxName));

        return RTC_E_SIP_NO_STREAM;
    }

    if (!m_rtpf_pIRtpDtmf)
    {
        // first time to QI the dtmf interface
        hr = m_rtpf_pIBaseFilter->QueryInterface(
            __uuidof(IRtpDtmf),
            (void**)&m_rtpf_pIRtpDtmf
            );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI IRtpDtmf. %x", __fxName, hr));

            return hr;
        }
    }

    // setup format
    hr = m_rtpf_pIRtpDtmf->SetDtmfParameters(dwCode);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s set dtmf code. %x", __fxName, hr));

        return hr;
    }

    hr = m_rtpf_pIRtpDtmf->SendDtmfEvent(dwId, dwEvent, dwVolume, dwDuration, fEnd);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s send dtmf event. %x", __fxName, hr));
    }

    return hr;
}

BOOL
CRTCStreamAudSend::IsNewFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt)
{
    DWORD dwDuration = CRTCCodec::GetPacketDuration(pmt);

    if (dwCode == m_dwCurrCode && dwDuration == m_dwCurrDuration)
    {
        // do not change format if both code and duration remain unchanged
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void
CRTCStreamAudSend::SaveFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt)
{
    m_dwCurrCode = dwCode;
    m_dwCurrDuration = CRTCCodec::GetPacketDuration(pmt);

    LOG((RTC_QUALITY, "SaveFormat(AudSend) %d %dms", m_dwCurrCode, m_dwCurrDuration));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\streamvidrecv.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    StreamVidRecv.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

CRTCStreamVidRecv::CRTCStreamVidRecv()
    :CRTCStream()
    ,m_edgp_pIFrameRateControl(NULL)
{
    m_MediaType = RTC_MT_VIDEO;
    m_Direction = RTC_MD_RENDER;
}

/*
CRTCStreamVidRecv::~CRTCStreamVidRecv()
{
}
*/

HRESULT
CRTCStreamVidRecv::BuildGraph()
{
    ENTER_FUNCTION("CRTCStreamVidRecv::BuildGraph");

    LOG((RTC_TRACE, "%s entered. stream=%p", __fxName, static_cast<IRTCStream*>(this)));

    HRESULT hr = S_OK;

    CComPtr<IPin> pEdgePin;

    CComPtr<IPin> pTermPin;
    DWORD dwPinNum;

    // create rtp filter
    if (m_rtpf_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CoCreateInstance(
                __uuidof(MSRTPSourceFilter),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &m_rtpf_pIBaseFilter
                )))
        {
            LOG((RTC_ERROR, "%s, create RTP filter %x", __fxName, hr));

            goto Error;
        }

        // cache interface
        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpMediaControl
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp media control. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpSession
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp session. %x", __fxName, hr));

            goto Error;
        }
    }

    // add rtp filter
    if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            m_rtpf_pIBaseFilter,
            L"VidRecvRtp"
            )))
    {
        LOG((RTC_ERROR, "%s add rtp filter. %x", __fxName, hr));

        goto Error;
    }

    // create decoder filter
    if (m_edgf_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CoCreateInstance(
                __uuidof(TAPIVideoDecoder),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &m_edgf_pIBaseFilter
                )))
        {
            LOG((RTC_ERROR, "%s create decoder. %x", __fxName, hr));

            goto Error;
        }

        // cache interface
        if (FAILED(hr = ::FindPin(
                m_edgf_pIBaseFilter,
                &pEdgePin,
                PINDIR_INPUT
                )))
        {
            LOG((RTC_ERROR, "%s get input pin on decoder. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = pEdgePin->QueryInterface(&m_edgp_pIStreamConfig)))
        {
            LOG((RTC_ERROR, "%s get istreamconfig. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = pEdgePin->QueryInterface(&m_edgp_pIBitrateControl)))
        {
            LOG((RTC_ERROR, "%s get ibitratecontrol. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = pEdgePin->QueryInterface(&m_edgp_pIFrameRateControl)))
        {
            LOG((RTC_ERROR, "%s get iframeratecontrol. %x", __fxName, hr));

            goto Error;
        }
    }

    // add decoder(edge filter)
    if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            m_edgf_pIBaseFilter,
            L"VidRecvDec"
            )))
    {
        LOG((RTC_ERROR, "%s add rtp filter. %x", __fxName, hr));

        goto Error;
    }

    // hack: rtp need default format mapping
    if (FAILED(hr = ::PrepareRTPFilter(
            m_rtpf_pIRtpMediaControl,
            m_edgp_pIStreamConfig
            )))
    {
        LOG((RTC_ERROR, "%s prepare rtp format mapping. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            m_rtpf_pIBaseFilter,
            pEdgePin
            )))
    {
        LOG((RTC_ERROR, "%s connect rtp and decoder. %x", __fxName, hr));

        goto Error;
    }

    // connect terminal
    if (FAILED(hr = m_pTerminalPriv->ConnectTerminal(
        m_pMedia,
        m_pIGraphBuilder
        )))
    {
        LOG((RTC_ERROR, "%s connect terminal. %x", __fxName, hr));
        goto Error;
    }

    // get terminal pin
    dwPinNum = 1;
    hr = m_pTerminalPriv->GetPins(&dwPinNum, &pTermPin);

    if (FAILED(hr) || dwPinNum != 1)
    {
        LOG((RTC_ERROR, "%s get pins on terminal. %x", __fxName, hr));
        goto Error;
    }

    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            m_edgf_pIBaseFilter,
            pTermPin
            )))
    {
        LOG((RTC_ERROR, "%s connect decoder and terminal. %x", __fxName, hr));

        goto Error;
    }

    // at this pointer, the graph has been built up.
    // we should return success.

    // complete connect terminal
    if (FAILED(hr = m_pTerminalPriv->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect term. %x", __fxName, hr));
    }

    LOG((RTC_TRACE, "%s exiting.", __fxName));

    return S_OK;

Error:

    CleanupGraph();

    return hr;
}

void
CRTCStreamVidRecv::CleanupGraph()
{
	// hide IVideoWindow
	CComPtr<IRTCVideoConfigure> pVideoConfigure;
	IVideoWindow *pVideoWindow;

	if (m_pTerminal)
	{
		if (SUCCEEDED(m_pTerminal->QueryInterface(
				__uuidof(IRTCVideoConfigure),
				(void**)&pVideoConfigure
				)))
		{
			if (SUCCEEDED(pVideoConfigure->GetIVideoWindow((LONG_PTR**)&pVideoWindow)))
			{
				pVideoWindow->put_Visible(OAFALSE);
				pVideoWindow->Release();
			}
		}
	}

    if (m_edgp_pIFrameRateControl)
    {
        m_edgp_pIFrameRateControl->Release();
        m_edgp_pIFrameRateControl = NULL;
    }

	CRTCStream::CleanupGraph();
}

HRESULT
CRTCStreamVidRecv::GetFramerate(
    OUT DWORD *pdwFramerate
    )
{
    HRESULT hr = S_OK;
    *pdwFramerate = 0;

    if (m_edgp_pIFrameRateControl != NULL)
    {
        TAPIControlFlags Flags;
        LONG lFrameInterval = 0;

        hr = m_edgp_pIFrameRateControl->Get(
                FrameRateControl_Current, &lFrameInterval, &Flags
                );

        if (lFrameInterval > 0)
        {
            *pdwFramerate = (DWORD)(10000000 / lFrameInterval);
        }
    }

    return hr;
}

/*
HRESULT
CRTCStreamVidRecv::SetupFormat()
{
    return E_NOTIMPL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\terminal.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Terminal.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#ifndef _TERMINAL_H
#define _TERMINAL_H

// the volume range of the IAMInputMixer
const double MIXER_MIN_VOLUME = 0.0;
const double MIXER_MAX_VOLUME = 1.0;

class CRTCMediaController;

class ATL_NO_VTABLE CRTCTerminal :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IRTCTerminal,
    public IRTCTerminalPriv
{
public:

BEGIN_COM_MAP(CRTCTerminal)
    COM_INTERFACE_ENTRY(IRTCTerminal)
    COM_INTERFACE_ENTRY(IRTCTerminalPriv)
END_COM_MAP()

public:

    static HRESULT CreateInstance(
        IN RTC_MEDIA_TYPE MediaType,
        IN RTC_MEDIA_DIRECTION Direction,
        OUT IRTCTerminal **ppTerminal
        );

    static BOOL IsDSoundGUIDMatch(
        IN IRTCTerminal *p1stTerm,
        IN IRTCTerminal *p2ndTerm
        );

    CRTCTerminal();
    ~CRTCTerminal();

#ifdef DEBUG_REFCOUNT

    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    //
    // IRTCTerminal methods
    //

    STDMETHOD (GetTerminalType) (
        OUT RTC_TERMINAL_TYPE *pType
        );

    STDMETHOD (GetMediaType) (
        OUT RTC_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetDirection) (
        OUT RTC_MEDIA_DIRECTION *pDirection
        );

    STDMETHOD (GetDescription) (
        OUT WCHAR **ppDescription
        );

    STDMETHOD (FreeDescription) (
        IN WCHAR *pDescription
        );

    STDMETHOD (GetState) (
        OUT RTC_TERMINAL_STATE *pState
        );

    //
    // IRTCTerminalPriv methods
    //

    STDMETHOD (Initialize) (
        IN RTCDeviceInfo *pDeviceInfo,
        IN IRTCTerminalManage *pTerminalManage
        );

    STDMETHOD (Initialize) (
        IN ITTerminal *pITTerminal,
        IN IRTCTerminalManage *pTerminalManage
        );

    STDMETHOD (Reinitialize) ();

    STDMETHOD (Shutdown) ();
        
    // this is a hack method for tuning purpose
    // the only way to cleanup a previous AEC setting
    // is really re-cocreate the filter.

    STDMETHOD (ReinitializeEx) ();

    STDMETHOD (GetFilter) (
        OUT IBaseFilter **ppIBaseFilter
        );

    STDMETHOD (GetPins) (
        IN OUT DWORD *pdwCount,
        OUT IPin **ppPin
        );

    STDMETHOD (ConnectTerminal) (
        IN IRTCMedia *pMedia,
        IN IGraphBuilder *pGraph
        );

    STDMETHOD (CompleteConnectTerminal) ();

    STDMETHOD (DisconnectTerminal) ();

    STDMETHOD (GetMedia) (
        OUT IRTCMedia **ppMedia
        );

    STDMETHOD (HasDevice) (
        IN RTCDeviceInfo *pDeviceInfo
        );

    STDMETHOD (UpdateDeviceInfo) (
        IN RTCDeviceInfo *pDeviceInfo
        );

    STDMETHOD (GetDeviceInfo) (
        OUT RTCDeviceInfo **ppDeviceInfo
        );

protected:

    virtual HRESULT CreateFilter() = 0;

    virtual HRESULT DeleteFilter() = 0;

    HRESULT SetupFilter();

protected:

    RTC_TERMINAL_STATE          m_State;

    // media controller
    IRTCTerminalManage          *m_pTerminalManage;

    // media pointer when terminal is selected
    IRTCMedia                   *m_pMedia;

    // device info
    RTCDeviceInfo               m_DeviceInfo;

    // dynamic terminal
    ITTerminal                  *m_pTapiTerminal;

    // filter and graph
    IGraphBuilder               *m_pIGraphBuilder;
    IBaseFilter                 *m_pIBaseFilter;

#define RTC_MAX_TERMINAL_PIN_NUM 4

    IPin                        *m_Pins[RTC_MAX_TERMINAL_PIN_NUM];
    DWORD                       m_dwPinNum;
};

/*//////////////////////////////////////////////////////////////////////////////
    audio capture
////*/

class ATL_NO_VTABLE CRTCTerminalAudCapt :
    public CRTCTerminal,
    public IRTCAudioConfigure
{
public:

BEGIN_COM_MAP(CRTCTerminalAudCapt)
    COM_INTERFACE_ENTRY(IRTCAudioConfigure)
    COM_INTERFACE_ENTRY_CHAIN(CRTCTerminal)
END_COM_MAP()

public:

    CRTCTerminalAudCapt();
    // ~CRTCTerminalAudCapt();

    //
    // IRTCAudioConfigure methods
    //

    STDMETHOD (GetVolume) (
        OUT UINT *puiVolume
        );

    STDMETHOD (SetVolume) (
        IN UINT uiVolume
        );

    STDMETHOD (SetMute) (
        IN BOOL fMute
        );

    STDMETHOD (GetMute) (
        OUT BOOL *pfMute
        );

    STDMETHOD (GetWaveID) (
        OUT UINT *puiWaveID
        );

    STDMETHOD (GetAudioLevel) (
        OUT UINT *puiLevel
        );

    STDMETHOD (GetAudioLevelRange) (
        OUT UINT *puiMin,
        OUT UINT *puiMax
        );

protected:

    HRESULT CreateFilter();

    HRESULT DeleteFilter();

protected:

    IAMAudioInputMixer          *m_pIAMAudioInputMixer;
    ISilenceControl             *m_pISilenceControl;

    // when UI 1st calls GetVolume, we need to set the volume back
    // we need a volume set by the user 'manully'
    BOOL                        m_fInitFixedMixLevel;
};

/*//////////////////////////////////////////////////////////////////////////////
    audio render
////*/

class ATL_NO_VTABLE CRTCTerminalAudRend :
    public CRTCTerminal,
    public IRTCAudioConfigure
{
public:

BEGIN_COM_MAP(CRTCTerminalAudRend)
    COM_INTERFACE_ENTRY(IRTCAudioConfigure)
    COM_INTERFACE_ENTRY_CHAIN(CRTCTerminal)
END_COM_MAP()

public:

    CRTCTerminalAudRend();
    // ~CRTCTerminalAudRend();

    //
    // IRTCAudioConfigure methods
    //

    STDMETHOD (GetVolume) (
        OUT UINT *puiVolume
        );

    STDMETHOD (SetVolume) (
        IN UINT uiVolume
        );

    STDMETHOD (SetMute) (
        IN BOOL fMute
        );

    STDMETHOD (GetMute) (
        OUT BOOL *pfMute
        );

    STDMETHOD (GetWaveID) (
        OUT UINT *puiWaveID
        );

    STDMETHOD (GetAudioLevel) (
        OUT UINT *puiLevel
        );

    STDMETHOD (GetAudioLevelRange) (
        OUT UINT *puiMin,
        OUT UINT *puiMax
        );

protected:

    HRESULT CreateFilter();

    HRESULT DeleteFilter();

protected:

    IBasicAudio                 *m_pIBasicAudio;
    IAudioStatistics            *m_pIAudioStatistics;
};

/*//////////////////////////////////////////////////////////////////////////////
    video capture
////*/

class ATL_NO_VTABLE CRTCTerminalVidCapt :
    public CRTCTerminal
{
public:

BEGIN_COM_MAP(CRTCTerminalVidCapt)
    COM_INTERFACE_ENTRY_CHAIN(CRTCTerminal)
END_COM_MAP()

public:

    CRTCTerminalVidCapt();
    // ~CRTCTerminalVidCapt();

protected:

    HRESULT CreateFilter();

    HRESULT DeleteFilter();
};

/*//////////////////////////////////////////////////////////////////////////////
    video render
////*/

class ATL_NO_VTABLE CRTCTerminalVidRend :
    public CRTCTerminal,
    public IRTCVideoConfigure
{
public:

BEGIN_COM_MAP(CRTCTerminalVidRend)
    COM_INTERFACE_ENTRY(IRTCVideoConfigure)
    COM_INTERFACE_ENTRY_CHAIN(CRTCTerminal)
END_COM_MAP()

public:

    CRTCTerminalVidRend();
    ~CRTCTerminalVidRend();

    //
    // IRTCTerminalPriv methods
    //

    STDMETHOD (GetPins) (
        IN OUT DWORD *pdwCount,
        OUT IPin **ppPin
        );

    STDMETHOD (ConnectTerminal) (
        IN IRTCMedia *pMedia,
        IN IGraphBuilder *pGraph
        );

    STDMETHOD (CompleteConnectTerminal) ();

    STDMETHOD (DisconnectTerminal) ();

    //
    // IRTCVideoConfigure methods
    //

    STDMETHOD (GetIVideoWindow) (
        OUT LONG_PTR **ppIVideoWindow
        );

protected:

    HRESULT CreateFilter();

    HRESULT DeleteFilter();

protected:

    IVideoWindow                    *m_pIVideoWindow;
};

#endif // _TERMINAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\streamvidsend.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    StreamVidSend.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

CRTCStreamVidSend::CRTCStreamVidSend()
    :CRTCStream()
    ,m_pPreview(NULL)
    ,m_pPreviewPriv(NULL)
    ,m_edgp_pCapturePin(NULL)
    ,m_edgp_pPreviewPin(NULL)
    ,m_edgp_pRTPPin(NULL)
    ,m_edgp_pIFrameRateControl(NULL)
    ,m_dwCurrCode((DWORD)-1)
    ,m_lCurrWidth((DWORD)-1)
    ,m_lCurrHeight((DWORD)-1)
{
    m_MediaType = RTC_MT_VIDEO;
    m_Direction = RTC_MD_CAPTURE;
}

/*
CRTCStreamVidSend::~CRTCStreamVidSend()
{
}
*/

HRESULT
CRTCStreamVidSend::SelectTerminal()
{
    ENTER_FUNCTION("CRTCStreamVidSend::SelectTerminal");

    HRESULT hr = CRTCStream::SelectTerminal();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s select cap terminal. %x", __fxName, hr));

        return hr;
    }

    if (m_pPreview)
    {
        // already got one
        _ASSERT(m_pPreviewPriv != NULL);
        return S_OK;
    }
    else
    {
        _ASSERT(m_pPreviewPriv == NULL);
    }


    // select preview terminal

    if (FAILED(hr = m_pTerminalManage->GetVideoPreviewTerminal(
            &m_pPreview
            )))
    {
        LOG((RTC_ERROR, "%s select preview terminal. %x", __fxName, hr));

        CRTCStream::UnselectTerminal();

        return hr;
    }

    // get preview priv
    m_pPreviewPriv = static_cast<IRTCTerminalPriv*>(
        static_cast<CRTCTerminal*>(m_pPreview));

    m_pPreviewPriv->AddRef();

    return S_OK;
}

HRESULT
CRTCStreamVidSend::UnselectTerminal()
{
    CRTCStream::UnselectTerminal();

    if (m_pPreviewPriv)
    {
        m_pPreviewPriv->Release();
        m_pPreviewPriv = NULL;
    }

    if (m_pPreview)
    {
        m_pPreview->Release();
        m_pPreview = NULL;
    }

    return S_OK;
}

#define MAX_PIN_NUM 4

HRESULT
CRTCStreamVidSend::BuildGraph()
{
    ENTER_FUNCTION("CRTCStreamVidSend::BuildGraph");

    HRESULT hr;

    DWORD dwPinNum;
    IPin *Pins[MAX_PIN_NUM];
    PIN_INFO PinInfo;

    CComPtr<IPin> pRTPCapturePin;
    CComPtr<IPin> pRTPRTPPin;

    CComPtr<IPin> pPreviewTermPin;

    CComPtr<IFrameRateControl> pPreviewFrameRateControl;

    // connect terminal
    if (FAILED(hr = m_pTerminalPriv->ConnectTerminal(
        m_pMedia,
        m_pIGraphBuilder
        )))
    {
        LOG((RTC_ERROR, "%s connect terminal. %x", __fxName, hr));
        goto Error;
    }

    // get terminal pin
    dwPinNum = MAX_PIN_NUM;
    hr = m_pTerminalPriv->GetPins(&dwPinNum, Pins);

    if (FAILED(hr) || dwPinNum < 1)
    {
        LOG((RTC_ERROR, "%s get pins on terminal. %x", __fxName, hr));
        goto Error;
    }

    _ASSERT(m_edgp_pCapturePin == NULL);
    _ASSERT(m_edgp_pPreviewPin == NULL);
    _ASSERT(m_edgp_pRTPPin == NULL);
    
    // get pins: capture, preview, rtp
    for (int i=0; (DWORD)i<dwPinNum; i++)
    {
        if (FAILED(hr = Pins[i]->QueryPinInfo(&PinInfo)))
        {
            LOG((RTC_ERROR, "%s get pin info. %x", __fxName, hr));
        }
        else
        {
            // check pin name
            if (lstrcmpW(PinInfo.achName, PNAME_CAPTURE) == 0)
            {
                m_edgp_pCapturePin = Pins[i];
                m_edgp_pCapturePin->AddRef();

                m_edgf_pIBaseFilter = PinInfo.pFilter;
                m_edgf_pIBaseFilter->AddRef();
            }
            else if (lstrcmpW(PinInfo.achName, PNAME_PREVIEW) == 0)
            {
                m_edgp_pPreviewPin = Pins[i];
                m_edgp_pPreviewPin->AddRef();
            }
            else if (lstrcmpW(PinInfo.achName, PNAME_RTPPD) == 0)
            {
                m_edgp_pRTPPin = Pins[i];
                m_edgp_pRTPPin->AddRef();
            }

            PinInfo.pFilter->Release();
        }

        Pins[i]->Release();
    }

    if (m_edgp_pCapturePin == NULL ||
        m_edgp_pPreviewPin == NULL ||
        m_edgp_pRTPPin == NULL)
    {
        LOG((RTC_ERROR, "%s can't find all pins. %x", __fxName, hr));

        goto Error;
    }

    // cache interface
    if (FAILED(hr = m_edgp_pCapturePin->QueryInterface(&m_edgp_pIStreamConfig)))
    {
        LOG((RTC_ERROR, "%s QI stream config. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = m_edgp_pCapturePin->QueryInterface(&m_edgp_pIBitrateControl)))
    {
        LOG((RTC_ERROR, "%s QI bitratecontrol. %x", __fxName, hr));

        goto Error;
    }

    // create rtp filter
    if (m_rtpf_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CoCreateInstance(
                __uuidof(MSRTPRenderFilter),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &m_rtpf_pIBaseFilter
                )))
        {
            LOG((RTC_ERROR, "%s, create RTP filter %x", __fxName, hr));

            goto Error;
        }

        // cache interface
        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpMediaControl
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp media control. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpSession
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp session. %x", __fxName, hr));

            goto Error;
        }
    }

    // add rtp filter
    if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            m_rtpf_pIBaseFilter,
            L"VidSendRtp"
            )))
    {
        LOG((RTC_ERROR, "%s add rtp filter. %x", __fxName, hr));

        goto Error;
    }

    //
    // connect rtp filter
    //

    // hack: rtp need default format mapping
    if (FAILED(hr = ::PrepareRTPFilter(
            m_rtpf_pIRtpMediaControl,
            m_edgp_pIStreamConfig
            )))
    {
        LOG((RTC_ERROR, "%s prepare rtp format mapping. %x", __fxName, hr));

        goto Error;
    }

    // connect capture pin
    if (FAILED(hr = m_rtpf_pIBaseFilter->FindPin(PNAME_CAPTURE, &pRTPCapturePin)))
    {
        LOG((RTC_ERROR, "%s find rtp capt pin. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = m_pIGraphBuilder->ConnectDirect(
            m_edgp_pCapturePin,
            pRTPCapturePin,
            NULL
            )))
    {
        LOG((RTC_ERROR, "%s connect terminal and rtp capt pin. %x", __fxName, hr));

        goto Error;
    }

    // connect rtp pin
    if (FAILED(hr = m_rtpf_pIBaseFilter->FindPin(PNAME_RTPPD, &pRTPRTPPin)))
    {
        LOG((RTC_ERROR, "%s find rtp rtp pin. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = m_pIGraphBuilder->ConnectDirect(
            m_edgp_pRTPPin,
            pRTPRTPPin,
            NULL
            )))
    {
        LOG((RTC_ERROR, "%s connect terminal and rtp rtp pin. %x", __fxName, hr));

        goto Error;
    }

    //
    // connect preview terminal
    //

    if (FAILED(hr = m_pPreviewPriv->ConnectTerminal(
        m_pMedia,
        m_pIGraphBuilder
        )))
    {
        LOG((RTC_ERROR, "%s connect preview terminal. %x", __fxName, hr));
        goto Error;
    }

    // get terminal pin
    dwPinNum = 1;
    hr = m_pPreviewPriv->GetPins(&dwPinNum, &pPreviewTermPin);

    if (FAILED(hr) || dwPinNum < 1)
    {
        LOG((RTC_ERROR, "%s get pins on preview terminal. %x", __fxName, hr));
        goto Error;
    }
    
    if (FAILED(hr = m_pIGraphBuilder->Connect(
            m_edgp_pPreviewPin, pPreviewTermPin)))
    {
        LOG((RTC_ERROR, "%s connect preview pin. %x", __fxName, hr));

        goto Error;
    }

    // complete connect terminal
    if (FAILED(hr = m_pTerminalPriv->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect term. %x", __fxName, hr));
    }

    if (FAILED(hr = m_pPreviewPriv->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect privew. %x", __fxName, hr));
    }

    // configure capture frame rate
    LONG lMin, lMax, lDelta, lDefault;
    TAPIControlFlags lFlags;
    LONG lTarget;

    if (FAILED(hr = m_edgp_pCapturePin->QueryInterface(&m_edgp_pIFrameRateControl)))
    {
        LOG((RTC_ERROR, "%s QI capture framerate control. %x", __fxName, hr));
    }
    else
    {
        if (FAILED(hr = m_edgp_pIFrameRateControl->GetRange(
                FrameRateControl_Current,
                &lMin, &lMax, &lDelta, &lDefault, &lFlags
                )))
        {
            LOG((RTC_ERROR, "%s get framerate range. %x", __fxName, hr));
        }
        else
        {
            lTarget = (LONG)(10000000/CQualityControl::DEFAULT_FRAMERATE);

            if (lTarget < lMin)
            {
                lTarget = lMin;
            }
            else if (lTarget > lMax)
            {
                lTarget = lMax;
            }
                
            if (FAILED(hr = m_edgp_pIFrameRateControl->Set(
                    FrameRateControl_Maximum, lTarget, TAPIControl_Flags_None)))
            {
                LOG((RTC_ERROR, "%s set capture framerate. %x", __fxName, hr));
            }
        }
    }

    // configure preview frame rate
    
    if (FAILED(hr = m_edgp_pPreviewPin->QueryInterface(&pPreviewFrameRateControl)))
    {
        LOG((RTC_ERROR, "%s QI preview framerate control. %x", __fxName, hr));
    }
    else
    {
        if (FAILED(hr = pPreviewFrameRateControl->GetRange(
                FrameRateControl_Current,
                &lMin, &lMax, &lDelta, &lDefault, &lFlags
                )))
        {
            LOG((RTC_ERROR, "%s get framerate range. %x", __fxName, hr));
        }
        else
        {
            lTarget = (LONG)(10000000/CQualityControl::DEFAULT_FRAMERATE);

            if (lTarget < lMin)
            {
                lTarget = lMin;
            }
            else if (lTarget > lMax)
            {
                lTarget = lMax;
            }
                
            if (FAILED(hr = pPreviewFrameRateControl->Set(
                    FrameRateControl_Maximum, lTarget, TAPIControl_Flags_None)))
            {
                LOG((RTC_ERROR, "%s set capture framerate. %x", __fxName, hr));
            }
        }
    }

    LOG((RTC_TRACE, "%s exiting.", __fxName));

    return S_OK;

Error:

    CleanupGraph();

    return hr;

}

void
CRTCStreamVidSend::CleanupGraph()
{
        HRESULT hr;

        // hide IVideoWindow
        CComPtr<IRTCVideoConfigure> pVideoConfigure;
        IVideoWindow *pVideoWindow;

        if (m_pPreview)
        {
                if (SUCCEEDED(m_pPreview->QueryInterface(
                                __uuidof(IRTCVideoConfigure),
                                (void**)&pVideoConfigure
                                )))
                {
                        if (SUCCEEDED(pVideoConfigure->GetIVideoWindow((LONG_PTR**)&pVideoWindow)))
                        {
                                pVideoWindow->put_Visible(OAFALSE);
                                pVideoWindow->Release();
                        }
                }
        }

    // !!! MUST STOP graph before disconnect
    // otherwise ITTerminal(IVideoWindow) will fail and leave
    // us a useless IVideoWindow.

    hr = StopStream();

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "CRTCStreamVidSend::CleanupGraph. stop stream. %x", hr));
    }

    if (m_pPreviewPriv)
    {
        m_pPreviewPriv->DisconnectTerminal();
        m_pPreviewPriv->Release();
        m_pPreviewPriv = NULL;
    }

    if (m_pPreview)
    {
        m_pPreview->Release();
        m_pPreview = NULL;
    }

    if (m_edgp_pCapturePin)
    {
        m_edgp_pCapturePin->Release();
        m_edgp_pCapturePin = NULL;
    }

    if (m_edgp_pPreviewPin)
    {
        m_edgp_pPreviewPin->Release();
        m_edgp_pPreviewPin = NULL;
    }

    if (m_edgp_pRTPPin)
    {
        m_edgp_pRTPPin->Release();
        m_edgp_pRTPPin = NULL;
    }

    if (m_edgp_pIFrameRateControl)
    {
        m_edgp_pIFrameRateControl->Release();
        m_edgp_pIFrameRateControl = NULL;
    }

    CRTCStream::CleanupGraph();
}

// set bitrate on the stream
DWORD
CRTCStreamVidSend::AdjustBitrate(
    IN DWORD dwTotalBW,
    IN DWORD dwVideoBW,
    IN FLOAT dFramerate
    )
{
    ENTER_FUNCTION("CRTCStreamVidSend::AdjustBitrate");

    if (m_edgp_pIBitrateControl == NULL)
    {
        return 0;
    }

    // set up QCIF or SQCIF
    HRESULT hr = S_OK;
    CRTCCodec *pCodec;

    if (m_pRegSetting->EnableSQCIF() &&
        m_Codecs.GetCodec(0, &pCodec))
    {
        // first codec contains the current format

        AM_MEDIA_TYPE *pmt = pCodec->GetAMMediaType();
        DWORD dwCode = pCodec->Get(CRTCCodec::CODE);

        BITMAPINFOHEADER *pVideoHeader = NULL;

        if (pmt != NULL &&
            (pVideoHeader = HEADER(pmt->pbFormat)) != NULL)
        {
            if (dwTotalBW <= CRTCCodecArray::LOW_BANDWIDTH_THRESHOLD)
            {
                // SQCIF
                pVideoHeader->biWidth = SDP_SMALL_VIDEO_WIDTH;
                pVideoHeader->biHeight = SDP_SMALL_VIDEO_HEIGHT;

                LOG((RTC_QUALITY, "Use SQCIF pt=%d", dwCode));
            }
            else
            {
                // QCIF
                pVideoHeader->biWidth = SDP_DEFAULT_VIDEO_WIDTH;
                pVideoHeader->biHeight = SDP_DEFAULT_VIDEO_HEIGHT;

                LOG((RTC_QUALITY, "Use QCIF pt=%d", dwCode));
            }

            if (IsNewFormat(dwCode, pmt))
            {
                hr = m_edgp_pIStreamConfig->SetFormat(dwCode, pmt);

                SaveFormat(dwCode, pmt);
            }

            if (FAILED(hr))
            {
                LOG((RTC_ERROR, "%s set format. %x", __fxName, hr));
            }
        }

        pCodec->DeleteAMMediaType(pmt);
    }

    LONG lMin, lMax, lDelta, lDefault;
    TAPIControlFlags lFlags;

    hr = m_edgp_pIBitrateControl->GetRange(
        BitrateControl_Current,
        &lMin, &lMax, &lDelta, &lDefault, &lFlags, 0
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s getrange. %x", __fxName));

        return 0;
    }

    // compute raw bitrate
    DWORD dwHeader = (DWORD)(dFramerate * PACKET_EXTRA_BITS);

    DWORD dwRaw = 0;

    if (dwVideoBW > dwHeader)
    {
        dwRaw = dwVideoBW - dwHeader;

        if (dwRaw < MIN_VIDEO_BITRATE)
        {
            dwRaw = MIN_VIDEO_BITRATE;
        }
    }
    else
    {
        dwRaw = MIN_VIDEO_BITRATE;
    }

    // put an upper cap on video bitrate
    if (dwRaw > MAX_VIDEO_BITRATE)
    {
        dwRaw = MAX_VIDEO_BITRATE;
    }

    // validate range
    if (dwRaw < (DWORD)lMin)
        dwRaw = (DWORD)lMin;
    else if (dwRaw > (DWORD)lMax)
        dwRaw = (DWORD)lMax;

    hr = m_edgp_pIBitrateControl->Set(
        BitrateControl_Maximum, (LONG)dwRaw, lFlags, 0);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s set bitrate. %x", __fxName, hr));
    }

    // adjust framerate
    LONG lTarget;
    if (m_edgp_pIFrameRateControl != NULL)
    {
        if (FAILED(hr = m_edgp_pIFrameRateControl->GetRange(
                FrameRateControl_Current,
                &lMin, &lMax, &lDelta, &lDefault, &lFlags
                )))
        {
            LOG((RTC_ERROR, "%s get framerate range. %x", __fxName, hr));
        }
        else
        {
            lTarget = (LONG)(10000000/dFramerate);

            if (lTarget < lMin)
            {
                lTarget = lMin;
            }
            else if (lTarget > lMax)
            {
                lTarget = lMax;
            }
                
            if (FAILED(hr = m_edgp_pIFrameRateControl->Set(
                    FrameRateControl_Maximum, lTarget, TAPIControl_Flags_None)))
            {
                LOG((RTC_ERROR, "%s set capture framerate. %x", __fxName, hr));
            }
        }
    }

    // set bandwidth on rtp stream for QoS
    if (m_rtpf_pIRtpSession)
    {
        m_rtpf_pIRtpSession->SetBandwidth(
            -1,
            dwRaw+(DWORD)(dFramerate*PACKET_EXTRA_BITS),    // overall outgoing bandwidth
            -1, -1);
    }

    //LOG((RTC_QUALITY, "Video bps=%d, frame interval=%d", dwRaw, lTarget));

    return dwRaw;
}

HRESULT
CRTCStreamVidSend::GetFramerate(
    OUT DWORD *pdwFramerate
    )
{
    HRESULT hr = S_OK;
    *pdwFramerate = 0;

    if (m_edgp_pIFrameRateControl != NULL)
    {
        TAPIControlFlags Flags;
        LONG lFrameInterval = 0;

        hr = m_edgp_pIFrameRateControl->Get(
                FrameRateControl_Current, &lFrameInterval, &Flags
                );

        if (lFrameInterval > 0)
        {
            *pdwFramerate = (DWORD)(10000000 / lFrameInterval);
        }
    }

    return hr;
}

/*
HRESULT
CRTCStreamVidSend::SetupFormat()
{
    return E_NOTIMPL;
}
*/

BOOL
CRTCStreamVidSend::IsNewFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt)
{
    BITMAPINFOHEADER *pVideoHeader = NULL;

    pVideoHeader = HEADER(pmt->pbFormat);

    if (m_dwCurrCode == dwCode &&
        m_lCurrWidth == pVideoHeader->biWidth &&
        m_lCurrHeight == pVideoHeader->biHeight)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void
CRTCStreamVidSend::SaveFormat(DWORD dwCode, AM_MEDIA_TYPE *pmt)
{
    BITMAPINFOHEADER *pVideoHeader = NULL;

    pVideoHeader = HEADER(pmt->pbFormat);

    m_dwCurrCode = dwCode;
    m_lCurrWidth = pVideoHeader->biWidth;
    m_lCurrHeight = pVideoHeader->biHeight;

    LOG((RTC_QUALITY, "SaveFormat(VidSend) %d w=%d h=%d",
        m_dwCurrCode, m_lCurrWidth, m_lCurrHeight));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\terminal.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    Terminal.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

static DWORD gTotalTerminalRefcount = 0;

HRESULT
CRTCTerminal::CreateInstance(
    IN RTC_MEDIA_TYPE MediaType,
    IN RTC_MEDIA_DIRECTION Direction,
    OUT IRTCTerminal **ppTerminal
    )
{
    ENTER_FUNCTION("CRTCTerminal::CreateInstance");

    HRESULT hr;
    IRTCTerminal *pITerminal = NULL;

    if (MediaType == RTC_MT_AUDIO && Direction == RTC_MD_CAPTURE)
    {
        // audio send
        CComObject<CRTCTerminalAudCapt> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create audio capture. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCTerminal), (void**)&pITerminal)))
        {
            LOG((RTC_ERROR, "%s query intf on audio capture. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else if (MediaType == RTC_MT_AUDIO && Direction == RTC_MD_RENDER)
    {
        // audio receive
        CComObject<CRTCTerminalAudRend> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create audio receive. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCTerminal), (void**)&pITerminal)))
        {
            LOG((RTC_ERROR, "%s query intf on audio receive. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else if (MediaType == RTC_MT_VIDEO && Direction == RTC_MD_CAPTURE)
    {
        // audio send
        CComObject<CRTCTerminalVidCapt> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create video capture. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCTerminal), (void**)&pITerminal)))
        {
            LOG((RTC_ERROR, "%s query intf on video capture. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else if (MediaType == RTC_MT_VIDEO && Direction == RTC_MD_RENDER)
    {
        // audio receive
        CComObject<CRTCTerminalVidRend> *pObject;

        if (FAILED(hr = ::CreateCComObjectInstance(&pObject)))
        {
            LOG((RTC_ERROR, "%s create video receive. %x", __fxName, hr));
            return hr;
        }

        if (FAILED(hr = pObject->_InternalQueryInterface(
            __uuidof(IRTCTerminal), (void**)&pITerminal)))
        {
            LOG((RTC_ERROR, "%s query intf on video receive. %x", __fxName, hr));

            delete pObject;
            return hr;
        }
    }
    else
        return E_NOTIMPL;

    *ppTerminal = pITerminal;

    return S_OK;

}

// check if dsound guid match
BOOL
CRTCTerminal::IsDSoundGUIDMatch(
    IN IRTCTerminal *p1stTerm,
    IN IRTCTerminal *p2ndTerm
    )
{
    if (p1stTerm == NULL || p2ndTerm == NULL)
        return FALSE;

    CRTCTerminal *p1stObj = static_cast<CRTCTerminal*>(p1stTerm);
    CRTCTerminal *p2ndObj = static_cast<CRTCTerminal*>(p2ndTerm);

    return IsEqualGUID(p1stObj->m_DeviceInfo.Guid, p2ndObj->m_DeviceInfo.Guid);
}

CRTCTerminal::CRTCTerminal()
    :m_State(RTC_TS_CREATED)
    ,m_pTerminalManage(NULL)
    ,m_pMedia(NULL)
    ,m_pTapiTerminal(NULL)
    ,m_pIGraphBuilder(NULL)
    ,m_pIBaseFilter(NULL)
    ,m_dwPinNum(0)
{
    m_DeviceInfo.szDescription[0] = '\0';
}

CRTCTerminal::~CRTCTerminal()
{
    if (m_State != RTC_TS_SHUTDOWN)
    {
        LOG((RTC_ERROR, "~CRTCTerminal(%p, mt=%d, md=%d) called without shutdown",
             static_cast<IRTCTerminal*>(this),
             m_DeviceInfo.MediaType, m_DeviceInfo.Direction));

        Shutdown();
    }
}

#ifdef DEBUG_REFCOUNT

ULONG
CRTCTerminal::InternalAddRef()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalAddRef();
    
    gTotalTerminalRefcount ++;

    LOG((RTC_REFCOUNT, "terminal(%p) addref=%d  (total=%d)",
         static_cast<IRTCTerminal*>(this), lRef, gTotalTerminalRefcount));

    return lRef;
}

ULONG
CRTCTerminal::InternalRelease()
{
    ULONG lRef = ((CComObjectRootEx<CComMultiThreadModelNoCS> *)
                   this)->InternalRelease();

    gTotalTerminalRefcount --;

    LOG((RTC_REFCOUNT, "terminal(%p) release=%d  (total=%d)",
         static_cast<IRTCTerminal*>(this), lRef, gTotalTerminalRefcount));

    return lRef;
}

#endif

//
// IRTCTerminal methods
//

STDMETHODIMP
CRTCTerminal::GetTerminalType(
    OUT RTC_TERMINAL_TYPE *pType
    )
{
    if (m_pTapiTerminal)
    {
        _ASSERT(m_DeviceInfo.MediaType == RTC_MT_VIDEO);
        _ASSERT(m_DeviceInfo.Direction == RTC_MD_RENDER);

        *pType = RTC_TT_DYNAMIC;
    }
    else
    {
        _ASSERT(m_DeviceInfo.MediaType != RTC_MT_VIDEO ||
                m_DeviceInfo.Direction != RTC_MD_RENDER);

        *pType = RTC_TT_STATIC;
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::GetMediaType(
    OUT RTC_MEDIA_TYPE *pMediaType
    )
{
    *pMediaType = m_DeviceInfo.MediaType;
    return S_OK;
}

STDMETHODIMP
CRTCTerminal::GetDirection(
    OUT RTC_MEDIA_DIRECTION *pDirection
    )
{
    *pDirection = m_DeviceInfo.Direction;
    return S_OK;
}

STDMETHODIMP
CRTCTerminal::GetDescription(
    OUT WCHAR **ppDescription
    )
{    
    return ::AllocAndCopy(ppDescription, m_DeviceInfo.szDescription);
}

STDMETHODIMP
CRTCTerminal::FreeDescription(
    OUT WCHAR *pDescription
    )
{
    RtcFree(pDescription);

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::GetState(
    OUT RTC_TERMINAL_STATE *pState
    )
{
    *pState = m_State;
    return S_OK;
}

//
// IRTCTerminalPriv methods
//

STDMETHODIMP
CRTCTerminal::Initialize(
    IN RTCDeviceInfo *pDeviceInfo,
    IN IRTCTerminalManage *pTerminalManage
    )
{
    ENTER_FUNCTION("CRTCTerminal::Initialize");

    // check state
    if (m_State != RTC_TS_CREATED)
        return E_UNEXPECTED;

    // check device info
    if (pDeviceInfo->MediaType != m_DeviceInfo.MediaType ||
        pDeviceInfo->Direction != m_DeviceInfo.Direction)
    {
        LOG((RTC_ERROR, "%s mt or md not match", __fxName));

        return E_INVALIDARG;
    }

    // copy date
    m_DeviceInfo.uiDeviceID = pDeviceInfo->uiDeviceID;
    m_DeviceInfo.Guid = pDeviceInfo->Guid;
    lstrcpyW(m_DeviceInfo.szDescription, pDeviceInfo->szDescription);

    m_DeviceInfo.uiMark = 0;

    // terminal manage
    m_pTerminalManage = pTerminalManage;
    m_pTerminalManage->AddRef();

    m_State = RTC_TS_INITIATED;

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::Initialize(
    IN ITTerminal *pITTerminal,
    IN IRTCTerminalManage *pTerminalManage
    )
{
    ENTER_FUNCTION("CRTCTerminal::Initialize");

    // check state
    if (m_State != RTC_TS_CREATED)
        return E_UNEXPECTED;

    // check device info
    if (m_DeviceInfo.MediaType != RTC_MT_VIDEO ||
        m_DeviceInfo.Direction != RTC_MD_RENDER)
    {
        LOG((RTC_ERROR, "%s mt or md not match vid rend", __fxName));

        return E_INVALIDARG;
    }

    m_pTapiTerminal = pITTerminal;
    m_pTapiTerminal->AddRef();

    m_pTerminalManage = pTerminalManage;
    m_pTerminalManage->AddRef();

    m_State = RTC_TS_INITIATED;

    return S_OK;    
}

STDMETHODIMP
CRTCTerminal::Reinitialize()
{
    if (m_State != RTC_TS_INITIATED &&
        m_State != RTC_TS_CONNECTED)
    {
        LOG((RTC_ERROR, "terminal reinit in wrong state. %x", m_State));

        return E_UNEXPECTED;
    }

    if (m_State == RTC_TS_CONNECTED)
    {
        DisconnectTerminal();
        _ASSERT(m_State == RTC_TS_INITIATED);
    }

    // after disconnect
    _ASSERT(m_pMedia == NULL);
    _ASSERT(m_pIGraphBuilder == NULL);

    // do not delete filters
    // _ASSERT(m_pIBaseFilter == NULL);
    // _ASSERT(m_dwPinNum == 0);

    m_State = RTC_TS_INITIATED;

    return S_OK;
}

// this is a hack method for tuning purpose
// the only way to cleanup a previous AEC setting
// is really re-cocreate the filter.
STDMETHODIMP
CRTCTerminal::ReinitializeEx()
{
    HRESULT hr;

    hr = Reinitialize();

    if (FAILED(hr))
        return hr;

    DeleteFilter();

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::Shutdown()
{
    ENTER_FUNCTION("CRTCTerminal::Shutdown");

    LOG((RTC_TRACE, "%s entered. terminal=%p",
         __fxName, static_cast<IRTCTerminal*>(this)));

    if (m_State == RTC_TS_SHUTDOWN)
    {
        LOG((RTC_WARN, "%s already shutdown", __fxName));
        return S_OK;
    }

    if (m_State == RTC_TS_CREATED)
    {
        // we have nothing yet
        return S_OK;
    }

    Reinitialize();
    DeleteFilter();

    if (m_pTerminalManage)
    {
        m_pTerminalManage->Release();
        m_pTerminalManage = NULL;
    }

    if (m_pTapiTerminal)
    {
        m_pTapiTerminal->Release();
        m_pTapiTerminal = NULL;
    }

    m_State = RTC_TS_SHUTDOWN;

    LOG((RTC_TRACE, "%s exiting.", __fxName));

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    get pins exposed by the terminal. if ppPin is null, the number of pin
    is returned in pdwCount.
////*/

STDMETHODIMP
CRTCTerminal::GetPins(
    IN OUT DWORD *pdwCount,
    OUT IPin **ppPin
    )
{
    ENTER_FUNCTION("CRTCTerminal::GetPins");

    if (IsBadWritePtr(pdwCount, sizeof(DWORD)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    if (m_pIBaseFilter == NULL)
    {
        HRESULT hr = CreateFilter();

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s create filter. %x", __fxName, hr));

            return hr;
        }
    }

    // if ppPin is null, just return the number of pins
    if (ppPin == NULL)
    {
        *pdwCount = m_dwPinNum;
        return S_OK;
    }

    // check pointer again
    if (IsBadWritePtr(ppPin, sizeof(IPin*)*(*pdwCount)))
    {
        LOG((RTC_ERROR, "%s bad bin buffer.", __fxName));

        return E_POINTER;
    }

    if (*pdwCount > m_dwPinNum)
    {
        // input buffer is too big
        *pdwCount = m_dwPinNum;
    }

    for (int i=0; (DWORD)i<*pdwCount; i++)
    {
        ppPin[i] = m_Pins[i];
        ppPin[i]->AddRef();
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    get filter
////*/

STDMETHODIMP
CRTCTerminal::GetFilter(
    OUT IBaseFilter **ppIBaseFilter
    )
{
    ENTER_FUNCTION("CRTCTerminal::GetFilter");

    // make sure we are in the right state
    if (m_State != RTC_TS_INITIATED)
    {
        LOG((RTC_ERROR, "%s wrong state", __fxName));

        return E_UNEXPECTED;
    }

    if (IsBadWritePtr(ppIBaseFilter, sizeof(IBaseFilter*)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    if (m_pIBaseFilter == NULL)
    {
        HRESULT hr = CreateFilter();

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s create filter. %x", __fxName, hr));

            return hr;
        }
    }

    m_pIBaseFilter->AddRef();
    *ppIBaseFilter = m_pIBaseFilter;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    create filter, cahce additional interface, add filter into graph
    and setup filter
////*/
STDMETHODIMP
CRTCTerminal::ConnectTerminal(
    IN IRTCMedia *pMedia,
    IN IGraphBuilder *pGraph
    )
{
    ENTER_FUNCTION("CRTCTerminal::ConnectTerminal");

    HRESULT hr;

    if (m_State == RTC_TS_CONNECTED &&
        pMedia == m_pMedia &&
        pGraph == m_pIGraphBuilder)
    {
        return S_OK;
    }

    if (m_State != RTC_TS_INITIATED)
    {
        LOG((RTC_ERROR, "%s called in wrong state. %x", __fxName, m_State));

        return E_UNEXPECTED;
    }

    _ASSERT(m_pMedia == NULL);
    _ASSERT(m_pIGraphBuilder == NULL);

    m_pMedia = pMedia;

    if (m_pMedia != NULL)
    {
        m_pMedia->AddRef();
    }

    m_pIGraphBuilder = pGraph;
    m_pIGraphBuilder->AddRef();

    // create filter
    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s create filter. %x", __fxName, hr));

            goto Error;
        }
    }
    else
    {
        if (FAILED(hr = m_pIGraphBuilder->AddFilter(m_pIBaseFilter, NULL)))
        {
            LOG((RTC_ERROR, "%s add filter. %x", __fxName, hr));

            goto Error;
        }
    }

    m_State = RTC_TS_CONNECTED;

    return S_OK;

Error:

    if (m_pMedia != NULL)
    {
        m_pMedia->Release();
    }

    m_pMedia = NULL;

    m_pIGraphBuilder->Release();
    m_pIGraphBuilder = NULL;

    DeleteFilter();

    return hr;
}

STDMETHODIMP
CRTCTerminal::CompleteConnectTerminal()
{
    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    release all cached filter/pin interface, release graph
    release media
////*/

STDMETHODIMP
CRTCTerminal::DisconnectTerminal()
{
    ENTER_FUNCTION("CRTCTerminal::DisconnectTerminal");

    if (m_State != RTC_TS_CONNECTED)
    {
        LOG((RTC_WARN, "%s not connected. state=%x", __fxName, m_State));

        return S_OK;
    }

    //_ASSERT(m_pMedia != NULL);
    _ASSERT(m_pIGraphBuilder != NULL);

    if (m_pIBaseFilter)
    {
        m_pIGraphBuilder->RemoveFilter(m_pIBaseFilter);
    }
    else
    {
        LOG((RTC_WARN, "%s filter null.", __fxName));
    }

    if (m_pMedia != NULL)
    {
        m_pMedia->Release();
    }

    m_pMedia = NULL;


    m_pIGraphBuilder->Release();
    m_pIGraphBuilder = NULL;

    m_State = RTC_TS_INITIATED;

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::GetMedia(
    OUT IRTCMedia **ppMedia
    )
{
    *ppMedia = m_pMedia;

    if (m_pMedia)
        m_pMedia->AddRef();

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::HasDevice(
    IN RTCDeviceInfo *pDeviceInfo
    )
{
    // check if the device matches
    if (m_DeviceInfo.MediaType != pDeviceInfo->MediaType ||
        m_DeviceInfo.Direction != pDeviceInfo->Direction)
    {
        // @@@ skip checking Guid
        return S_FALSE;
    }

    if (m_DeviceInfo.MediaType == RTC_MT_AUDIO)
    {
        // audio: check guid
        if (!IsEqualGUID(m_DeviceInfo.Guid, pDeviceInfo->Guid))
            return S_FALSE;
        else
            return S_OK;
    }
    else
    {
        // video render: we shouldn't check it
        if (m_DeviceInfo.Direction == RTC_MD_RENDER)
            return S_FALSE;
        
        // video capture: check device name
        if (0 == lstrcmpW(m_DeviceInfo.szDescription, pDeviceInfo->szDescription))
            return S_OK;
        else
            return S_FALSE;
    }
}

STDMETHODIMP
CRTCTerminal::UpdateDeviceInfo(
    IN RTCDeviceInfo *pDeviceInfo
    )
{
    ENTER_FUNCTION("CRTCTerminal::UpdateDeviceInfo");

    // do we have the device
    if (S_FALSE == HasDevice(pDeviceInfo))
    {
        LOG((RTC_ERROR, "%s device not match. old=%ws. new=%ws.",
             __fxName, m_DeviceInfo.szDescription, pDeviceInfo->szDescription));

        return E_INVALIDARG;
    }

    HRESULT hr;

    // only video need to be updated
    if (m_DeviceInfo.MediaType == RTC_MT_VIDEO)
        //m_pMedia != NULL)
    {
        // only when device id has been changed
        if (m_DeviceInfo.uiDeviceID != pDeviceInfo->uiDeviceID)
        {
            // update
            m_DeviceInfo.uiDeviceID = pDeviceInfo->uiDeviceID;

            // is the terminal connected?
            if (m_State == RTC_TS_CONNECTED && m_pMedia!=NULL)
            {
                // need to update stream
                CComPtr<IRTCStream> pStream;

                if (FAILED(hr = m_pMedia->GetStream(
                        m_DeviceInfo.Direction,
                        &pStream
                        )))
                {
                    LOG((RTC_ERROR, "%s get stream. %x", __fxName, hr));

                    return hr;
                }

                if (pStream)
                {
                    RTC_STREAM_STATE StreamState;

                    if (FAILED(hr = pStream->GetState(&StreamState)))
                    {
                        LOG((RTC_ERROR, "%s get stream state. %x", __fxName, hr));

                        return hr;
                    }

                    // stop stream
                    pStream->StopStream();

                    // upate filter
                    if (FAILED(hr = SetupFilter()))
                    {
                        LOG((RTC_ERROR, "%s setup filter. %x", __fxName, hr));

                        return hr;
                    }

                    // restart stream if necessary
                    if (StreamState == RTC_SS_STARTED ||
                        StreamState == RTC_SS_RUNNING)
                    {
                        if (FAILED(hr = pStream->StartStream()))
                        {
                            LOG((RTC_ERROR, "%s start stream. %x", __fxName, hr));

                            return hr;
                        }
                    }
                }
            }
            else if (m_State == RTC_TS_CONNECTED && m_pMedia==NULL)
            {
                // in tuning
                if (m_pIGraphBuilder)
                {
                    CComPtr<IMediaControl> pIMediaControl;

                    hr = m_pIGraphBuilder->QueryInterface(
                            __uuidof(IMediaControl),
                            (void**)&pIMediaControl
                            );

                    if (FAILED(hr))
                    {
                        LOG((RTC_ERROR, "%s QI mediacontrol. %x", __fxName, hr));
                        return hr;
                    }

                    // stop
                    pIMediaControl->Stop();

                    if (FAILED(hr = SetupFilter()))
                    {
                        LOG((RTC_ERROR, "%s setup filter. %x", __fxName, hr));

                        return hr;
                    }

                    pIMediaControl->Run();
                }
            }
            else if (m_pIBaseFilter)
            {
                // not connected but we do have filter created
                if (FAILED(hr = SetupFilter()))
                {
                    LOG((RTC_ERROR, "%s setup filter. %x", __fxName, hr));

                    return hr;
                }
            }
        }
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminal::GetDeviceInfo(
    IN RTCDeviceInfo **ppDeviceInfo
    )
{
    *ppDeviceInfo = &m_DeviceInfo;
    return S_OK;
}

//
// protected methods
//
HRESULT
CRTCTerminal::SetupFilter()
{
    ENTER_FUNCTION("CRTCTerminal::SetupFilter");

    _ASSERT(m_pIBaseFilter);

    HRESULT hr;

    if (m_DeviceInfo.MediaType == RTC_MT_AUDIO)
    {
        // for audio
        CComPtr<IAudioDeviceConfig> pIAudioDeviceConfig;

        if (FAILED(hr = m_pIBaseFilter->QueryInterface(
                __uuidof(IAudioDeviceConfig),
                (void**)&pIAudioDeviceConfig
                )))
        {
            LOG((RTC_ERROR, "%s QI audio device config. %x", __fxName, hr));

            return hr;
        }

        if (FAILED(hr = pIAudioDeviceConfig->SetDeviceID(
                m_DeviceInfo.Guid,          // dsound guid
                m_DeviceInfo.uiDeviceID     // wave id
                )))
        {
            LOG((RTC_ERROR, "%s set device id. %x", __fxName, hr));

            return hr;
        }
    }
    else
    {
        // for video
        CComPtr<IVideoDeviceControl> pIVideoDeviceControl;

        if (FAILED(hr = m_pIBaseFilter->QueryInterface(
                __uuidof(IVideoDeviceControl),
                (void**)&pIVideoDeviceControl
                )))
        {
            LOG((RTC_ERROR, "%s QI video device control. %x", __fxName, hr));

            return hr;
        }

        if (FAILED(hr = pIVideoDeviceControl->SetCurrentDevice(
                m_DeviceInfo.uiDeviceID     // index of video capt device
                )))
        {
            LOG((RTC_ERROR, "%s set current device %d. %x",
                 __fxName, m_DeviceInfo.uiDeviceID, hr));

            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\terminalaud.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    TerminalAud.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

CRTCTerminalAudCapt::CRTCTerminalAudCapt()
    :CRTCTerminal()
    ,m_pIAMAudioInputMixer(NULL)
    ,m_pISilenceControl(NULL)
    ,m_fInitFixedMixLevel(FALSE)
{
    m_DeviceInfo.MediaType = RTC_MT_AUDIO;
    m_DeviceInfo.Direction = RTC_MD_CAPTURE;
}

/*
CRTCTerminalAudCapt::~CRTCTerminalAudCapt()
{
}
*/

//
// IRTCAudioConfigure methods
//

/*//////////////////////////////////////////////////////////////////////////////
    get volume: get mix level
////*/

STDMETHODIMP
CRTCTerminalAudCapt::GetVolume(
    OUT UINT *puiVolume
    )
{
    ENTER_FUNCTION("CRTCTerminalAudCapt::GetVolume");

    HRESULT hr;

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        return E_NOINTERFACE;
    }

    double dVolume;

    //if (FAILED(hr = ::DirectGetCaptVolume(m_DeviceInfo.uiDeviceID, &dVolume)))
    if (FAILED(hr = m_pIAMAudioInputMixer->get_MixLevel(&dVolume)))
    {
        LOG((RTC_ERROR, "%s get mix level. %x", __fxName, hr));

        return hr;
    }

    _ASSERT(MIXER_MIN_VOLUME == 0);
    _ASSERT(MIXER_MAX_VOLUME == 1);
    _ASSERT(dVolume >= MIXER_MIN_VOLUME);
    _ASSERT(dVolume <= MIXER_MAX_VOLUME);

    // Convert the volume from whatever range of doubles the filter uses
    // to the range 0 - 1.
    // dVolume = (dVolume - MIXER_MIN_VOLUME) /
    //          (MIXER_MAX_VOLUME - MIXER_MIN_VOLUME);

    // Convert the volume from the range 0 - 1 to the API's range.
    dVolume = RTC_MIN_AUDIO_VOLUME +
        ((RTC_MAX_AUDIO_VOLUME-RTC_MIN_AUDIO_VOLUME) * dVolume);

    UINT uiVolume = (UINT)dVolume;

    if (dVolume-(double)(uiVolume) > 0.5)
        uiVolume ++;

    if (uiVolume > RTC_MAX_AUDIO_VOLUME)
    {
        *puiVolume = RTC_MAX_AUDIO_VOLUME;
    }
    else
    {
        *puiVolume = uiVolume;
    }

    // we need to set mixed level for reverting back
    if (!m_fInitFixedMixLevel)
    {
        SetVolume(*puiVolume);

        m_fInitFixedMixLevel = TRUE;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    set volume: set mix level
////*/

STDMETHODIMP
CRTCTerminalAudCapt::SetVolume(
    IN UINT uiVolume
    )
{
    ENTER_FUNCTION("CRTCTerminalAudCapt::SetVolume");

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    if ((INT)uiVolume > RTC_MAX_AUDIO_VOLUME ||
        (INT)uiVolume < RTC_MIN_AUDIO_VOLUME)
    {
        LOG((RTC_ERROR, "%s volume out of range. vol=%d", __fxName, uiVolume));

        return E_INVALIDARG;
    }

    HRESULT hr;

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    //if (m_pIAMAudioInputMixer == NULL)
    //{
    //    return E_NOINTERFACE;
    //}

    CComPtr<IAudioEffectControl> pAudioEffectControl;

    if (FAILED(hr = m_pIBaseFilter->QueryInterface(&pAudioEffectControl)))
    {
        LOG((RTC_ERROR, "%s QI audio effect control. %x", __fxName, hr));

        return hr;
    }

    double dVolume;

    // convert input vol in 0-1 range
    dVolume = (double)(uiVolume - RTC_MIN_AUDIO_VOLUME) /
              (RTC_MAX_AUDIO_VOLUME - RTC_MIN_AUDIO_VOLUME);

    // convert into mixer range
    _ASSERT(MIXER_MIN_VOLUME == 0);
    _ASSERT(MIXER_MAX_VOLUME == 1);

    // dVolume = MIXER_MIN_VOLUME +
    //         (MIXER_MAX_VOLUME-MIXER_MIN_VOLUME) *dVolume;

    //if (FAILED(hr = ::DirectSetCaptVolume(m_DeviceInfo.uiDeviceID, dVolume)))
    //if (FAILED(hr = m_pIAMAudioInputMixer->put_MixLevel(dVolume)))

    if (FAILED(hr = pAudioEffectControl->SetFixedMixLevel(dVolume)))
    {
        LOG((RTC_ERROR, "%s put mix level %f", __fxName, dVolume));

        return hr;
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudCapt::SetMute(
    IN BOOL fMute
    )
{
    ENTER_FUNCTION("CRTCTerminalAudCapt::SetMute");

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    HRESULT hr;

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        return E_NOINTERFACE;
    }

    if (FAILED(hr = m_pIAMAudioInputMixer->put_Enable(!fMute)))
    {
        LOG((RTC_ERROR, "%s mute. %d", __fxName, fMute));

        return hr;
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudCapt::GetMute(
    OUT BOOL *pfMute
    )
{
    ENTER_FUNCTION("CRTCTerminalAudCapt::GetMute");

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    HRESULT hr;
    BOOL fEnable;

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIAMAudioInputMixer == NULL)
    {
        return E_NOINTERFACE;
    }

    if (FAILED(hr = m_pIAMAudioInputMixer->get_Enable(&fEnable)))
    {
        LOG((RTC_ERROR, "%s enable.", __fxName));

        return hr;
    }

    *pfMute = !fEnable;

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudCapt::GetWaveID(
    OUT UINT *puiWaveID
    )
{
    // skip checking bad pointer.
    // this is internal api anyway

    *puiWaveID = m_DeviceInfo.uiDeviceID;

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudCapt::GetAudioLevel(
    OUT UINT *puiLevel
    )
{
    if (m_pISilenceControl == NULL)
    {
        return E_NOINTERFACE;
    }

    LONG lAudioLevel = 0;

    HRESULT hr = m_pISilenceControl->GetAudioLevel(&lAudioLevel);

    *puiLevel = (UINT)lAudioLevel;

    return hr;
}

STDMETHODIMP
CRTCTerminalAudCapt::GetAudioLevelRange(
    OUT UINT *puiMin,
    OUT UINT *puiMax
    )
{
    if (m_pISilenceControl == NULL)
    {
        return E_NOINTERFACE;
    }

    LONG lMin = 0, lMax = 0, lDelta;

    HRESULT hr = m_pISilenceControl->GetAudioLevelRange(
        &lMin, &lMax, &lDelta
        );

    *puiMin = (UINT)lMin;
    *puiMax = (UINT)lMax;

    return hr;
}

//
// protected methods
//

/*//////////////////////////////////////////////////////////////////////////////
    create filter, cache pin the other interfaces
////*/

HRESULT
CRTCTerminalAudCapt::CreateFilter()
{
    ENTER_FUNCTION("CRTCTerminalAudCapt::CreateFilter");

    _ASSERT(m_pIBaseFilter == NULL);
    _ASSERT(m_pIAMAudioInputMixer == NULL);
    _ASSERT(m_pISilenceControl == NULL);

    if (m_State == RTC_TS_SHUTDOWN)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIAudioCapture),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&m_pIBaseFilter
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s cocreate failed. %x", __fxName, hr));

        return hr;
    }

    if (FAILED(hr = SetupFilter()))
    {
        LOG((RTC_ERROR, "%s setup filter. %x", __fxName, hr));

        DeleteFilter();

        return hr;
    }

    // get mixer input intf
    if (FAILED(hr = m_pIBaseFilter->QueryInterface(
            __uuidof(IAMAudioInputMixer),
            (void**)&m_pIAMAudioInputMixer
            )))
    {
        LOG((RTC_WARN, "%s QI mixer intf. %x", __fxName, hr));
    }

    // cache pins
    CComPtr<IEnumPins> pEnum;

    if (FAILED(hr = m_pIBaseFilter->EnumPins(&pEnum)))
    {
        LOG((RTC_ERROR, "%s enum pins. %x", __fxName, hr));

        DeleteFilter();

        return hr;
    }

    // our own terminal, skip checking pin direction
    hr = pEnum->Next(
        RTC_MAX_TERMINAL_PIN_NUM,
        m_Pins,
        &m_dwPinNum
        );

    if (FAILED(hr) || m_dwPinNum == 0)
    {
        LOG((RTC_ERROR, "%s get next pins. %x", __fxName, hr));

        if (hr == S_FALSE)
            hr = E_FAIL;

        DeleteFilter();

        return hr;
    }

    // cache silence contorl
    hr = m_Pins[0]->QueryInterface(__uuidof(ISilenceControl), (void**)&m_pISilenceControl);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s QI silence control. %x", __fxName, hr));

        DeleteFilter();

        return hr;
    }

    // join the graph
    if (m_pIGraphBuilder)
    {
        if (FAILED(hr = m_pIGraphBuilder->AddFilter(m_pIBaseFilter, NULL)))
        {
            LOG((RTC_ERROR, "%s add filter. %x", __fxName, hr));

            DeleteFilter();

            return RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE;
        }
    }

    m_fInitFixedMixLevel = FALSE;

    return S_OK;
}

HRESULT
CRTCTerminalAudCapt::DeleteFilter()
{
    if (m_pIBaseFilter)
    {
        m_pIBaseFilter->Release();
        m_pIBaseFilter = NULL;
    }

    if (m_pIAMAudioInputMixer)
    {
        m_pIAMAudioInputMixer->Release();
        m_pIAMAudioInputMixer = NULL;
    }

    if (m_pISilenceControl)
    {
        m_pISilenceControl->Release();
        m_pISilenceControl = NULL;
    }

    for (int i=0; (DWORD)i<m_dwPinNum; i++)
    {
        m_Pins[i]->Release();
        m_Pins[i] = NULL;
    }

    m_dwPinNum = 0;

    return S_OK;
}


/******************************************************************************/
/******************************************************************************/


CRTCTerminalAudRend::CRTCTerminalAudRend()
    :CRTCTerminal()
    ,m_pIBasicAudio(NULL)
    ,m_pIAudioStatistics(NULL)
{
    m_DeviceInfo.MediaType = RTC_MT_AUDIO;
    m_DeviceInfo.Direction = RTC_MD_RENDER;
}

/*
CRTCTerminalAudRend::~CRTCTerminalAudRend()
{
}
*/

//
// IRTCAudioConfigure methods
//

STDMETHODIMP
CRTCTerminalAudRend::GetVolume(
    OUT UINT *puiVolume
    )
{
    ENTER_FUNCTION("CRTCTerminalAudRend::GetVolume");

    HRESULT hr;

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        return E_NOINTERFACE;
    }

    LONG lVolume;

    if (FAILED(hr = m_pIBasicAudio->get_Volume(&lVolume)))
    {
        LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

        return hr;
    }

    // validate the value
    if (lVolume > RTC_MAX_AUDIO_VOLUME ||
        lVolume < RTC_MIN_AUDIO_VOLUME)
    {
        // implementation of audio filter must have been changed
        LOG((RTC_ERROR, "%s volume %d out of range (%d, %d)",
             __fxName, lVolume, RTC_MIN_AUDIO_VOLUME, RTC_MAX_AUDIO_VOLUME));

        // should recover from this failure
        if (lVolume > RTC_MAX_AUDIO_VOLUME) lVolume = RTC_MAX_AUDIO_VOLUME;
        if (lVolume < RTC_MIN_AUDIO_VOLUME) lVolume = RTC_MIN_AUDIO_VOLUME;
    }

    *puiVolume = (UINT)lVolume;

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudRend::SetVolume(
    IN UINT uiVolume
    )
{
    ENTER_FUNCTION("CRTCTerminalAudRend::SetVolume");

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    if ((INT)uiVolume > RTC_MAX_AUDIO_VOLUME ||
        (INT)uiVolume < RTC_MIN_AUDIO_VOLUME)
    {
        LOG((RTC_ERROR, "%s volume out of range. vol=%d", __fxName, uiVolume));

        return E_INVALIDARG;
    }

    HRESULT hr;

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        return E_NOINTERFACE;
    }

    if (FAILED(hr = m_pIBasicAudio->put_Volume((LONG)uiVolume)))
    {
        LOG((RTC_ERROR, "%s put mix level %d", __fxName, uiVolume));

        return hr;
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudRend::SetMute(
    IN BOOL fMute
    )
{
#if 0 // mute implemented by volume control
    static UINT uiVolume = 0;
#endif

    ENTER_FUNCTION("CRTCTerminalAudRend::SetMute");

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    HRESULT hr;

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        return E_NOINTERFACE;
    }

    CComPtr<IBasicAudioEx> pIBasicAudioEx;

    if (FAILED(hr = m_pIBasicAudio->QueryInterface(&pIBasicAudioEx)))
    {
        LOG((RTC_ERROR, "%s QI basic audio Ex. %x", __fxName, hr));

        return hr;
    }

    return pIBasicAudioEx->SetMute(fMute);

#if 0 // mute implemented by volume control
    if (fMute)
    {
        // remember current value
        if (FAILED(hr = GetVolume(&uiVolume)))
        {
            LOG((RTC_ERROR, "%s get current volume. %x", __fxName, hr));

            return hr;
        }

        if (FAILED(hr == SetVolume(0)))
        {
            LOG((RTC_ERROR, "%s set 0 volume. %x", __fxName, hr));

            return hr;
        }
    }
    else
    {
        // enable sound
        if (uiVolume > 0)
        {
            if (FAILED(hr = SetVolume(uiVolume)))
            {
                LOG((RTC_ERROR, "%s set volume %d. %x", __fxName, uiVolume, hr));

                return hr;
            }
        }
    }

    return S_OK;
#endif
}

STDMETHODIMP
CRTCTerminalAudRend::GetMute(
    IN BOOL *pfMute
    )
{
#if 0 // mute implemented by volume control
    UINT uiVolume = 0;
#endif

    ENTER_FUNCTION("CRTCTerminalAudRend::GetMute");

    //_ASSERT(m_State == RTC_TS_INITIATED || m_State == RTC_TS_CONNECTED);

    HRESULT hr;

    if (m_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CreateFilter()))
        {
            LOG((RTC_ERROR, "%s get volume. %x", __fxName, hr));

            return hr;
        }
    }

    if (m_pIBasicAudio == NULL)
    {
        return E_NOINTERFACE;
    }

    CComPtr<IBasicAudioEx> pIBasicAudioEx;

    if (FAILED(hr = m_pIBasicAudio->QueryInterface(&pIBasicAudioEx)))
    {
        LOG((RTC_ERROR, "%s QI basic audio Ex. %x", __fxName, hr));

        return hr;
    }

    return pIBasicAudioEx->GetMute(pfMute);

#if 0 // mute implemented by volume control
    // remember current value
    if (FAILED(hr = GetVolume(&uiVolume)))
    {
        LOG((RTC_ERROR, "%s get current volume. %x", __fxName, hr));

        return hr;
    }

    if (uiVolume == 0)
        *pfMute = TRUE;
    else
        *pfMute = FALSE;

    return S_OK;
#endif
}

STDMETHODIMP
CRTCTerminalAudRend::GetWaveID(
    OUT UINT *puiWaveID
    )
{
    // skip checking bad pointer.
    // this is internal api anyway

    *puiWaveID = m_DeviceInfo.uiDeviceID;

    return S_OK;
}

STDMETHODIMP
CRTCTerminalAudRend::GetAudioLevel(
    OUT UINT *puiLevel
    )
{
    if (m_pIAudioStatistics == NULL)
    {
        return E_NOINTERFACE;
    }

    LONG lAudioLevel = 0;

    HRESULT hr = m_pIAudioStatistics->GetAudioLevel(&lAudioLevel);

    *puiLevel = (UINT)lAudioLevel;

    return hr;
}

STDMETHODIMP
CRTCTerminalAudRend::GetAudioLevelRange(
    OUT UINT *puiMin,
    OUT UINT *puiMax
    )
{
    if (m_pIAudioStatistics == NULL)
    {
        return E_NOINTERFACE;
    }

    LONG lMin = 0, lMax = 0;

    HRESULT hr = m_pIAudioStatistics->GetAudioLevelRange(
        &lMin, &lMax
        );

    *puiMin = (UINT)lMin;
    *puiMax = (UINT)lMax;

    return hr;
}

//
// protected methods
//

HRESULT
CRTCTerminalAudRend::CreateFilter()
{
    ENTER_FUNCTION("CRTCTerminalAudRend::CreateFilter");

    _ASSERT(m_pIBaseFilter == NULL);
    _ASSERT(m_pIBasicAudio == NULL);
    _ASSERT(m_pIAudioStatistics == NULL);

    if (m_State == RTC_TS_SHUTDOWN)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIAudioRender),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&m_pIBaseFilter
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s cocreate failed. %x", __fxName, hr));

        return hr;
    }

    if (FAILED(hr = SetupFilter()))
    {
        LOG((RTC_ERROR, "%s setup filter. %x", __fxName, hr));

        DeleteFilter();

        return hr;
    }

    // get mixer input intf
    if (FAILED(hr = m_pIBaseFilter->QueryInterface(
            __uuidof(IBasicAudio),
            (void**)&m_pIBasicAudio
            )))
    {
        LOG((RTC_WARN, "%s QI basic audio. %x", __fxName, hr));
    }

    // cache pins
    CComPtr<IEnumPins> pEnum;

    if (FAILED(hr = m_pIBaseFilter->EnumPins(&pEnum)))
    {
        LOG((RTC_ERROR, "%s enum pins. %x", __fxName, hr));

        DeleteFilter();

        return hr;
    }

    // our own terminal, skip checking pin direction
    hr = pEnum->Next(
        RTC_MAX_TERMINAL_PIN_NUM,
        m_Pins,
        &m_dwPinNum
        );

    if (FAILED(hr) || m_dwPinNum == 0)
    {
        LOG((RTC_ERROR, "%s get next pins. %x", __fxName, hr));

        if (hr == S_FALSE)
            hr = E_FAIL;

        DeleteFilter();

        return hr;
    }

    // cache silence contorl
    hr = m_Pins[0]->QueryInterface(__uuidof(IAudioStatistics), (void**)&m_pIAudioStatistics);

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s QI audio statistics. %x", __fxName, hr));

        DeleteFilter();

        return hr;
    }

    // join the graph
    if (m_pIGraphBuilder)
    {
        if (FAILED(hr = m_pIGraphBuilder->AddFilter(m_pIBaseFilter, NULL)))
        {
            LOG((RTC_ERROR, "%s add filter. %x", __fxName, hr));

            DeleteFilter();

            return RTC_E_MEDIA_AUDIO_DEVICE_NOT_AVAILABLE;
        }
    }

    return S_OK;
}

HRESULT
CRTCTerminalAudRend::DeleteFilter()
{
    if (m_pIBaseFilter)
    {
        m_pIBaseFilter->Release();
        m_pIBaseFilter = NULL;
    }

    if (m_pIBasicAudio)
    {
        m_pIBasicAudio->Release();
        m_pIBasicAudio = NULL;
    }

    if (m_pIAudioStatistics)
    {
        m_pIAudioStatistics->Release();
        m_pIAudioStatistics = NULL;
    }

    for (int i=0; (DWORD)i<m_dwPinNum; i++)
    {
        m_Pins[i]->Release();
        m_Pins[i] = NULL;
    }

    m_dwPinNum = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\streamaudrecv.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    StreamAudRecv.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

CRTCStreamAudRecv::CRTCStreamAudRecv()
    :CRTCStream()
{
    m_MediaType = RTC_MT_AUDIO;
    m_Direction = RTC_MD_RENDER;
}

/*
CRTCStreamAudRecv::~CRTCStreamAudRecv()
{
}
*/

STDMETHODIMP
CRTCStreamAudRecv::Synchronize()
{
    HRESULT hr = CRTCStream::Synchronize();

    if (S_OK == hr)
    {
        PrepareRedundancy();
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    create and add filters into the graph
    cache interfaces
////*/

HRESULT
CRTCStreamAudRecv::BuildGraph()
{
    ENTER_FUNCTION("CRTCStreamAudRecv::BuildGraph");

    LOG((RTC_TRACE, "%s entered. stream=%p", __fxName, static_cast<IRTCStream*>(this)));

    HRESULT hr = S_OK;

    CComPtr<IPin> pEdgePin;

    CComPtr<IBaseFilter> pTermFilter;
    CComPtr<IPin> pTermPin;
    DWORD dwPinNum;

    CRTCMedia *pCMedia;
    CComPtr<IAudioDeviceConfig> pAudioDeviceConfig;

    // create rtp filter
    if (m_rtpf_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CoCreateInstance(
                __uuidof(MSRTPSourceFilter),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &m_rtpf_pIBaseFilter
                )))
        {
            LOG((RTC_ERROR, "%s, create RTP filter %x", __fxName, hr));

            goto Error;
        }

        // cache interface
        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpMediaControl
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp media control. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = m_rtpf_pIBaseFilter->QueryInterface(
                &m_rtpf_pIRtpSession
                )))
        {
            LOG((RTC_ERROR, "%s, QI rtp session. %x", __fxName, hr));

            goto Error;
        }
    }

    // add rtp filter
    if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            m_rtpf_pIBaseFilter,
            L"AudRecvRtp"
            )))
    {
        LOG((RTC_ERROR, "%s add rtp filter. %x", __fxName, hr));

        goto Error;
    }

    // create decoder filter
    if (m_edgf_pIBaseFilter == NULL)
    {
        if (FAILED(hr = CoCreateInstance(
                __uuidof(TAPIAudioDecoder),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                __uuidof(IBaseFilter),
                (void **) &m_edgf_pIBaseFilter
                )))
        {
            LOG((RTC_ERROR, "%s create decoder. %x", __fxName, hr));

            goto Error;
        }

        // cache interface
        if (FAILED(hr = ::FindPin(
                m_edgf_pIBaseFilter,
                &pEdgePin,
                PINDIR_INPUT
                )))
        {
            LOG((RTC_ERROR, "%s get input pin on decoder. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = pEdgePin->QueryInterface(&m_edgp_pIStreamConfig)))
        {
            LOG((RTC_ERROR, "%s get istreamconfig. %x", __fxName, hr));

            goto Error;
        }

        if (FAILED(hr = pEdgePin->QueryInterface(&m_edgp_pIBitrateControl)))
        {
            LOG((RTC_ERROR, "%s get ibitratecontrol. %x", __fxName, hr));

            goto Error;
        }
    }

    // add decoder(edge filter)
    if (FAILED(hr = m_pIGraphBuilder->AddFilter(
            m_edgf_pIBaseFilter,
            L"AudRecvDec"
            )))
    {
        LOG((RTC_ERROR, "%s add rtp filter. %x", __fxName, hr));

        goto Error;
    }

    // hack: rtp need default format mapping
    if (FAILED(hr = ::PrepareRTPFilter(
            m_rtpf_pIRtpMediaControl,
            m_edgp_pIStreamConfig
            )))
    {
        LOG((RTC_ERROR, "%s prepare rtp format mapping. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            m_rtpf_pIBaseFilter,
            pEdgePin
            )))
    {
        LOG((RTC_ERROR, "%s connect rtp and decoder. %x", __fxName, hr));

        goto Error;
    }

    // connect terminal
    if (FAILED(hr = m_pTerminalPriv->ConnectTerminal(
        m_pMedia,
        m_pIGraphBuilder
        )))
    {
        LOG((RTC_ERROR, "%s connect terminal. %x", __fxName, hr));
        goto Error;
    }

    // get terminal pin
    dwPinNum = 1;
    hr = m_pTerminalPriv->GetPins(&dwPinNum, &pTermPin);

    if (FAILED(hr) || dwPinNum != 1)
    {
        LOG((RTC_ERROR, "%s get pins on terminal. %x", __fxName, hr));
        goto Error;
    }

    // get duplex controller
    pCMedia = static_cast<CRTCMedia*>(m_pMedia);

    if (pCMedia->m_pIAudioDuplexController == NULL)
    {
        LOG((RTC_WARN, "%s audio duplex not supported.", __fxName));

        goto Return;
    }

    // set audio full duplex
    if (FAILED(hr = ::FindFilter(pTermPin, &pTermFilter)))
    {
        LOG((RTC_ERROR, "%s terminal filter. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = pTermFilter->QueryInterface(&pAudioDeviceConfig)))
    {
        LOG((RTC_ERROR, "%s QI audio device config. %x", __fxName, hr));

        goto Return;
    }

    if (FAILED(hr = pAudioDeviceConfig->SetDuplexController(
            pCMedia->m_pIAudioDuplexController
            )))
    {
        LOG((RTC_ERROR, "%s set audio duplex controller. %x", __fxName, hr));

        goto Return;
    }

    if (FAILED(hr = ::ConnectFilters(
            m_pIGraphBuilder,
            m_edgf_pIBaseFilter,
            pTermPin
            )))
    {
        LOG((RTC_ERROR, "%s connect decoder and terminal. %x", __fxName, hr));

        goto Error;
    }

    // at this pointer, the graph has been built up.
    // we should return success.

    // complete connect terminal
    if (FAILED(hr = m_pTerminalPriv->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect term. %x", __fxName, hr));
    }

Return:

    LOG((RTC_TRACE, "%s exiting.", __fxName));

    return S_OK;

Error:

    CleanupGraph();

    return hr;
}

/*
void
CRTCStreamAudRecv::CleanupGraph()
{
    CRTCStream::CleanupGraph();
}
*/

/*
HRESULT
CRTCStreamAudRecv::SetupFormat()
{
    return E_NOTIMPL;
}
*/

HRESULT
CRTCStreamAudRecv::PrepareRedundancy()
{
    ENTER_FUNCTION("CRTCStreamAudRecv::PrepareRedundancy");

    HRESULT hr = S_OK;

    IRTPFormat **ppFormat;
    DWORD dwNum;

    // get the number of formats
    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwNum, NULL)))
    {
        LOG((RTC_ERROR, "%s get rtp format num. %x", __fxName, hr));

        return hr;
    }

    if (dwNum == 0)
    {
        LOG((RTC_ERROR, "%s no format.", __fxName));

        return E_FAIL;
    }

    // allocate format list
    ppFormat = (IRTPFormat**)RtcAlloc(sizeof(IRTPFormat*)*dwNum);

    if (ppFormat == NULL)
    {
        LOG((RTC_ERROR, "%s RtcAlloc format list", __fxName));

        return E_OUTOFMEMORY;
    }

    // get formats
    if (FAILED(hr = m_pISDPMedia->GetFormats(&dwNum, ppFormat)))
    {
        LOG((RTC_ERROR, "%s really get formats. %x", __fxName, hr));

        RtcFree(ppFormat);

        return hr;
    }

    // set mapping on rtp
    RTP_FORMAT_PARAM param;

    BOOL fRedundant = FALSE;
    DWORD dwRedCode = 97;   // default

    for (DWORD i=0; i<dwNum; i++)
    {
        // get param
        if (FAILED(hr = ppFormat[i]->GetParam(&param)))
        {
            LOG((RTC_ERROR, "%s get param on %dth format. %x", __fxName, i, hr));
            break;
        }

        // check redundant, sigh
        if (lstrcmpA(param.pszName, "red") == 0)
        {
            fRedundant = TRUE;
            dwRedCode = param.dwCode;
            break;
        }
    }

    // release formats
    for (DWORD i=0; i<dwNum; i++)
    {
        ppFormat[i]->Release();
    }

    RtcFree(ppFormat);

    // setup redundancy
    if (fRedundant)
    {
        CComPtr<IRtpRedundancy> pIRtpRedundancy;

        hr = m_rtpf_pIRtpMediaControl->QueryInterface(&pIRtpRedundancy);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI rtp redundancy. %x", __fxName, hr));

            return hr;
        }

        hr = pIRtpRedundancy->SetRedParameters(dwRedCode, -1, -1);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\terminalvid.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    TerminalVid.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

CRTCTerminalVidCapt::CRTCTerminalVidCapt()
    :CRTCTerminal()
{
    m_DeviceInfo.MediaType = RTC_MT_VIDEO;
    m_DeviceInfo.Direction = RTC_MD_CAPTURE;
}

/*
CRTCTerminalVidCapt::~CRTCTerminalVidCapt()
{
}
*/

//
//protected methods
//

HRESULT
CRTCTerminalVidCapt::CreateFilter()
{
    ENTER_FUNCTION("CRTCTerminalVidCapt::CreateFilter");

    _ASSERT(m_pIBaseFilter == NULL);

    // for video, we have to have graph
    _ASSERT(m_pIGraphBuilder != NULL);

    if (m_State == RTC_TS_SHUTDOWN)
    {
        return E_UNEXPECTED;
    }

    HRESULT hr = CoCreateInstance(
        __uuidof(TAPIVideoCapture),
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        __uuidof(IBaseFilter),
        (void **)&m_pIBaseFilter
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s cocreate failed. %x", __fxName, hr));

        return hr;
    }

    // instruct the video filter to use rtp payload header
    // that conforms RFC2190. by default, draft payload header
    // will be used
    CComPtr<IRTPPayloadHeaderMode> pMode;

    if (SUCCEEDED(m_pIBaseFilter->QueryInterface(&pMode)))
    {
        pMode->SetMode(RTPPayloadHeaderMode_RFC2190);
    }

    // setup filter before joining the graph
    if (FAILED(hr = SetupFilter()))
    {
        LOG((RTC_ERROR, "%s setup filter. %x", __fxName, hr));

        m_pIGraphBuilder->RemoveFilter(m_pIBaseFilter);
        DeleteFilter();

        return hr;
    }

    if (FAILED(hr = m_pIGraphBuilder->AddFilter(m_pIBaseFilter, NULL)))
    {
        LOG((RTC_ERROR, "%s add filter. %x", __fxName, hr));

        DeleteFilter();

        return RTC_E_MEDIA_VIDEO_DEVICE_NOT_AVAILABLE;
    }

    // cache pins
    CComPtr<IEnumPins> pEnum;

    if (FAILED(hr = m_pIBaseFilter->EnumPins(&pEnum)))
    {
        LOG((RTC_ERROR, "%s enum pins. %x", __fxName, hr));

        m_pIGraphBuilder->RemoveFilter(m_pIBaseFilter);
        DeleteFilter();

        return hr;
    }

    // our own terminal, skip checking pin direction
    hr = pEnum->Next(
        RTC_MAX_TERMINAL_PIN_NUM,
        m_Pins,
        &m_dwPinNum
        );

    if (FAILED(hr) || m_dwPinNum == 0)
    {
        LOG((RTC_ERROR, "%s get next pins. %x", __fxName, hr));

        if (hr == S_FALSE)
            hr = E_FAIL;

        m_pIGraphBuilder->RemoveFilter(m_pIBaseFilter);
        DeleteFilter();

        return hr;
    }

    return S_OK;
}

HRESULT
CRTCTerminalVidCapt::DeleteFilter()
{
    for (int i=0; (DWORD)i<m_dwPinNum; i++)
    {
        m_Pins[i]->Release();
        m_Pins[i] = NULL;
    }

    if (m_pIBaseFilter)
    {
        m_pIBaseFilter->Release();
        m_pIBaseFilter = NULL;
    }

    m_dwPinNum = 0;

    return S_OK;
}


/******************************************************************************/
/******************************************************************************/


CRTCTerminalVidRend::CRTCTerminalVidRend()
    :CRTCTerminal()
    ,m_pIVideoWindow(NULL)
{
    m_DeviceInfo.MediaType = RTC_MT_VIDEO;
    m_DeviceInfo.Direction = RTC_MD_RENDER;

    lstrcpyW(m_DeviceInfo.szDescription, L"IVideoWindow Warp Terminal");
}

CRTCTerminalVidRend::~CRTCTerminalVidRend()
{
    if (m_pIVideoWindow)
    {
        m_pIVideoWindow->Release();
        m_pIVideoWindow = NULL;
    }
}


//
// IRTCTerminalPriv methods
//

STDMETHODIMP
CRTCTerminalVidRend::GetPins(
    IN OUT DWORD *pdwCount,
    OUT IPin **ppPin
    )
{
    ENTER_FUNCTION("CRTCTerminal::GetPins");

    if (IsBadWritePtr(pdwCount, sizeof(DWORD)))
    {
        LOG((RTC_ERROR, "%s bad pointer", __fxName));

        return E_POINTER;
    }

    if (m_State != RTC_TS_CONNECTED)
    {
        LOG((RTC_ERROR, "%s called in wrong state. %x", __fxName, m_State));

        return E_UNEXPECTED;
    }

    // if ppPin is null, just return the number of pins
    if (ppPin == NULL)
    {
        *pdwCount = m_dwPinNum;
        return S_OK;
    }

    // check pointer again
    if (IsBadWritePtr(ppPin, sizeof(IPin*)*(*pdwCount)))
    {
        LOG((RTC_ERROR, "%s bad bin buffer.", __fxName));

        return E_POINTER;
    }

    if (*pdwCount > m_dwPinNum)
    {
        // input buffer is too big
        *pdwCount = m_dwPinNum;
    }

    for (int i=0; (DWORD)i<*pdwCount; i++)
    {
        ppPin[i] = m_Pins[i];
        ppPin[i]->AddRef();
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminalVidRend::ConnectTerminal(
    IN IRTCMedia *pMedia,
    IN IGraphBuilder *pGraph
    )
{
    ENTER_FUNCTION("CRTCTerminalVidRend::ConnectTerminal");

    if (m_State == RTC_TS_CONNECTED &&
        pMedia == m_pMedia &&
        pGraph == m_pIGraphBuilder)
    {
        return S_OK;
    }

    if (m_State != RTC_TS_INITIATED)
    {
        LOG((RTC_ERROR, "%s called in wrong state. %x", __fxName, m_State));

        return E_UNEXPECTED;
    }

    if (m_pTapiTerminal == NULL)
    {
        LOG((RTC_ERROR, "%s no ITTerminal.", __fxName));

        return E_UNEXPECTED;
    }

    _ASSERT(m_pMedia == NULL);
    _ASSERT(m_pIGraphBuilder == NULL);

    HRESULT hr;

    // connect itterminal
    CComPtr<ITTerminalControl> pTerminalControl;

    if (FAILED(hr = m_pTapiTerminal->QueryInterface(&pTerminalControl)))
    {
        LOG((RTC_ERROR, "%s QI ITTerminalControl. %x", __fxName, hr));

        return hr;
    }

    m_dwPinNum = 1;
    hr = pTerminalControl->ConnectTerminal(
        pGraph, TD_RENDER, &m_dwPinNum, m_Pins
        );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s connectterminal. %x", __fxName, hr));

        return hr;
    }

    if (m_dwPinNum == 0)
    {
        LOG((RTC_ERROR, "%s pin number 0", __fxName));

        pTerminalControl->DisconnectTerminal(pGraph, 0);

        return E_UNEXPECTED;
    }
            
    // save media and graph interface
    m_pMedia = pMedia;

    if (m_pMedia != NULL)
    {
        m_pMedia->AddRef();
    }

    m_pIGraphBuilder = pGraph;
    m_pIGraphBuilder->AddRef();

    m_State = RTC_TS_CONNECTED;

    return S_OK;
}

STDMETHODIMP
CRTCTerminalVidRend::CompleteConnectTerminal()
{
    if (m_pTapiTerminal == NULL)
    {
        LOG((RTC_ERROR, "VidRend::CompleteConnectTerminal, no terminal."));

        return E_FAIL;
    }

    HRESULT hr;
    CComPtr<ITTerminalControl> pTermControl;

    if (FAILED(hr = m_pTapiTerminal->QueryInterface(&pTermControl)))
    {
        LOG((RTC_ERROR, "VidRend::CompleteConnectTerminal QI ITTerminalControl. %x", hr));

        return hr;
    }
    else
    {
        if (FAILED(hr = pTermControl->CompleteConnectTerminal()))
        {
            LOG((RTC_ERROR, "VidRend::CompleteConnectTerminal failed %x", hr));

            return hr;
        }
    }

    return S_OK;
}

STDMETHODIMP
CRTCTerminalVidRend::DisconnectTerminal()
{
    ENTER_FUNCTION("CRTCTerminalVidRend::DisconnectTerminal");

    if (m_State != RTC_TS_CONNECTED)
    {
        LOG((RTC_WARN, "%s not connected. state=%x", __fxName, m_State));

        return S_OK;
    }

    //_ASSERT(m_pMedia != NULL);
    _ASSERT(m_pIGraphBuilder != NULL);
    _ASSERT(m_pTapiTerminal != NULL);

    // disconnect itterminal
    HRESULT hr;
    CComPtr<ITTerminalControl> pTerminalControl;

    if (FAILED(hr = m_pTapiTerminal->QueryInterface(&pTerminalControl)))
    {
        LOG((RTC_ERROR, "%s QI ITTerminalControl. %x", __fxName, hr));
    }
    else
    {
        hr = pTerminalControl->DisconnectTerminal(m_pIGraphBuilder, 0);

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s disconnectterminal. %x", __fxName, hr));
        }
    }

    for (int i=0; (DWORD)i<m_dwPinNum; i++)
    {
        m_Pins[i]->Release();
        m_Pins[i] = NULL;
    }

    m_dwPinNum = 0;
            
    // release media and graph interface
    if (m_pMedia != NULL)
    {
        m_pMedia->Release();
    }

    m_pMedia = NULL;

    m_pIGraphBuilder->Release();
    m_pIGraphBuilder = NULL;

    m_State = RTC_TS_INITIATED;

    return S_OK;

}

//
// IRTCVideoConfigure methods
//

STDMETHODIMP
CRTCTerminalVidRend::GetIVideoWindow(
    OUT LONG_PTR **ppIVideoWindow
    )
{
    ENTER_FUNCTION("CRTCTerminalVidRend::GetIVideoWindow");

    if (m_pTapiTerminal == NULL)
    {
        LOG((RTC_ERROR, "%s not ITTerminal.", __fxName));
        return E_FAIL;
    }

    if (m_pIVideoWindow == NULL)
    {
        HRESULT hr = m_pTapiTerminal->QueryInterface(
                __uuidof(IVideoWindow),
                (void**)&m_pIVideoWindow
                );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s QI IVideoWindow. %x", __fxName, hr));

            return hr;
        }
    }

    m_pIVideoWindow->AddRef();
    *ppIVideoWindow = (LONG_PTR*)m_pIVideoWindow;

    return S_OK;
}

//
//protected methods
//

HRESULT
CRTCTerminalVidRend::CreateFilter()
{
    return E_NOTIMPL;
}

HRESULT
CRTCTerminalVidRend::DeleteFilter()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\videotuner.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    CRTCVideoTuner.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 16-Feb-2001

--*/

#include "stdafx.h"

CRTCVideoTuner::CRTCVideoTuner()
    :m_fInTuning(FALSE)
{
}

CRTCVideoTuner::~CRTCVideoTuner()
{
    if (m_fInTuning)
    {
        LOG((RTC_ERROR, "Video dtor in-tuning"));

        // stop tuning
        StopVideo();
    }
    else
    {
        Cleanup();
    }
}

// video tuning
HRESULT
CRTCVideoTuner::StartVideo(
    IN IRTCTerminal *pVidCaptTerminal,
    IN IRTCTerminal *pVidRendTerminal
    )
{
    ENTER_FUNCTION("CRTCVideoTuner::StartVideo");

    // check state
    if (m_fInTuning)
        return E_UNEXPECTED;

    RTC_MEDIA_TYPE mt;
    RTC_MEDIA_DIRECTION md;

    // check terminal type
    pVidCaptTerminal->GetMediaType(&mt);
    pVidCaptTerminal->GetDirection(&md);

    if (mt!=RTC_MT_VIDEO || md!=RTC_MD_CAPTURE)
    {
        return E_INVALIDARG;
    }

    pVidRendTerminal->GetMediaType(&mt);
    pVidRendTerminal->GetDirection(&md);

    if (mt!=RTC_MT_VIDEO || md!=RTC_MD_RENDER)
    {
        return E_INVALIDARG;
    }

    CRTCTerminalVidCapt *pCapture =
            static_cast<CRTCTerminalVidCapt*>(pVidCaptTerminal);
    CRTCTerminalVidRend *pRender =
            static_cast<CRTCTerminalVidRend*>(pVidRendTerminal);

    m_pVidCaptTerminal = pVidCaptTerminal;
    m_pVidRendTerminal = pVidRendTerminal;

    //
    // build graph
    //

#define MAX_PIN_NUM 4

    HRESULT hr = S_OK;

    CComPtr<IGraphBuilder> pIGraphBuilder;
    CComPtr<IMediaControl> pIMediaControl;

    // pin
    DWORD dwPinNum;
    IPin *Pins[MAX_PIN_NUM];
    PIN_INFO PinInfo;

    CComPtr<IPin> pIPinCapt;
    CComPtr<IPin> pIPinPrev;
    CComPtr<IPin> pIPinRend;

    // create graph
    hr = CoCreateInstance(
            CLSID_FilterGraph,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IGraphBuilder,
            (void**)&pIGraphBuilder
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s create graph", __fxName));

        goto Error;
    }

    m_pIGraphBuilder = pIGraphBuilder;

    // QI media control interace
    hr = pIGraphBuilder->QueryInterface(
            __uuidof(IMediaControl),
            (void**)&pIMediaControl
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s QI mediacontrol", __fxName));

        goto Error;
    }

    // do we need to set graph clock?
    // ......

    // connect both terminals
    hr = pCapture->ConnectTerminal(
            NULL,
            pIGraphBuilder
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s connect capt video. %x", __fxName, hr));

        goto Error;
    }

    hr = pRender->ConnectTerminal(
            NULL,
            pIGraphBuilder
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s connect capt video. %x", __fxName, hr));

        goto Error;
    }

    // get pin on capture
    dwPinNum = MAX_PIN_NUM;
    if (FAILED(hr = pCapture->GetPins(&dwPinNum, Pins)) ||
        dwPinNum < 1)
    {
        LOG((RTC_ERROR, "%s get pins on terminal. %x", __fxName, hr));

        goto Error;
    }

    for (DWORD i=0; i<dwPinNum; i++)
    {
        if (FAILED(hr = Pins[i]->QueryPinInfo(&PinInfo)))
        {
            LOG((RTC_ERROR, "%s get pin info. %x", __fxName, hr));
        }
        else
        {
            // check pin name
            if (lstrcmpW(PinInfo.achName, PNAME_PREVIEW) == 0)
            {
                pIPinPrev = Pins[i];
            }
            else if (lstrcmpW(PinInfo.achName, PNAME_CAPTURE) == 0)
            {
                pIPinCapt = Pins[i];
            }

            PinInfo.pFilter->Release();
        }

        Pins[i]->Release();
    }

    if (pIPinPrev == NULL || pIPinCapt == NULL)
    {
        LOG((RTC_ERROR, "%s no preview pin on capt", __fxName));

        goto Error;
    }

    // get pin on render
    dwPinNum = 1;

    if (FAILED(hr = pRender->GetPins(&dwPinNum, &pIPinRend)))
    {
        LOG((RTC_ERROR, "%s get pin on preview. %x", __fxName, hr));

        goto Error;
    }

    // connect pins
    if (FAILED(hr = pIGraphBuilder->Connect(
            pIPinPrev, pIPinRend)))
    {
        LOG((RTC_ERROR, "%s connect pins. %x", __fxName, hr));

        goto Error;
    }

    // create null render
    if (FAILED(hr = CNRFilter::CreateInstance(&m_pNRFilter)))
    {
        LOG((RTC_ERROR, "%s create null rend filter. %x", __fxName, hr));

        goto Error;
    }

    // add null render
    if (FAILED(hr = pIGraphBuilder->AddFilter(m_pNRFilter, L"NullRender")))
    {
        LOG((RTC_ERROR, "%s add null render. %x", __fxName, hr));

        goto Error;
    }

    // connect capt pin and null render
    if (FAILED(hr = ::ConnectFilters(pIGraphBuilder, pIPinCapt, m_pNRFilter)))
    {
        LOG((RTC_ERROR, "%s connect null render. %x", __fxName, hr));

        goto Error;
    }

    // complete connect terminal
    if (FAILED(hr = pCapture->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect for capt. %x", __fxName, hr));

        goto Error;
    }

    if (FAILED(hr = pRender->CompleteConnectTerminal()))
    {
        LOG((RTC_ERROR, "%s complete connect for rend. %x", __fxName, hr));

        goto Error;
    }

    // do we need to change framerate?
    // ......

    // start graph
    if (FAILED(hr = pIMediaControl->Run()))
    {
        LOG((RTC_ERROR, "%s start graph. %x", __fxName, hr));

        goto Error;
    }

    m_fInTuning = TRUE;

    return S_OK;

Error:

    Cleanup();

    return hr;
}

HRESULT
CRTCVideoTuner::StopVideo()
{
    if (!m_fInTuning)
        return E_UNEXPECTED;

    Cleanup();

    m_fInTuning = FALSE;

    return S_OK;
}

VOID
CRTCVideoTuner::Cleanup()
{
    HRESULT hr;

    // hide IVideoWindow
    CComPtr<IRTCVideoConfigure> pVideoConfigure;
    IVideoWindow *pVideoWindow;

    if (m_pVidRendTerminal)
    {
        if (SUCCEEDED(m_pVidRendTerminal->QueryInterface(
                        __uuidof(IRTCVideoConfigure),
                        (void**)&pVideoConfigure
                        )))
        {
            if (SUCCEEDED(pVideoConfigure->GetIVideoWindow((LONG_PTR**)&pVideoWindow)))
            {
                pVideoWindow->put_Visible(OAFALSE);
                pVideoWindow->Release();
            }
        }
    }

    // stop graph
    CComPtr<IMediaControl> pIMediaControl;

    if (m_pIGraphBuilder)
    {
        hr = m_pIGraphBuilder->QueryInterface(
                __uuidof(IMediaControl),
                (void**)&pIMediaControl
                );

        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "Cleanup QI mediacontrol. %x", hr));

            return;
        }

        // stop
        pIMediaControl->Stop();

        if (m_pNRFilter)
        {
            m_pIGraphBuilder->RemoveFilter(m_pNRFilter);
        }
    }

    // disconnect terminals
    if (m_pVidCaptTerminal)
    {
        CRTCTerminalVidCapt *pCapture =
                static_cast<CRTCTerminalVidCapt*>((IRTCTerminal*)m_pVidCaptTerminal);

        pCapture->DisconnectTerminal();
        pCapture->Reinitialize();
    }

    if (m_pVidRendTerminal)
    {
        CRTCTerminalVidRend *pRender =
                static_cast<CRTCTerminalVidRend*>((IRTCTerminal*)m_pVidRendTerminal);

        pRender->DisconnectTerminal();
        pRender->Reinitialize();
    }

    // there are no filters other than terminal filter in graph

    // cleanup cached interfaces
    m_pIGraphBuilder = NULL;
    m_pVidCaptTerminal = NULL;
    m_pVidRendTerminal = NULL;
    m_pNRFilter = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\test\join.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    join.cpp

Abstract:

    A test application to join a conference

Author:

    Qianbo Huai (qhuai) 19-Jul-2000

--*/

#include "stdafx.h"

#include "rtcmedia_i.c"

CComModule _Module;

/*
CHAR *gszSDP = "\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=G711-H263\n\
c=IN IP4 239.9.20.26/15\n\
b=CT:300\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
b=AS:120\n\
a=rtpmap:34 H263/90000\n\
a=rtpmap:31 H261/90000\n\
m=audio 20040 RTP/AVP 0 4\n\
k=clear:secret\n\
a=rtpmap:0 PCMU/8000\n\
a=rtpmap:4 G723/8000\n\
a=ptime:40\n\
";
*/

CHAR *gszSDP1 = "\
v=0\n\
o=qhuai 0 0 IN IP4 172.31.76.160\n\
s=MSAUDIO-H263\n\
c=IN IP4 \
";

CHAR *gszSDP2 = "\
/15\n\
t=0 0\n\
m=video 12300 RTP/AVP 34 31\n\
a=rtpmap:34 H263/90000\n\
a=rtpmap:31 H261/90000\n\
m=audio 12340 RTP/AVP 6 96 0 4\n\
a=rtpmap:6 DVI4/16000\n\
a=rtpmap:96 MSAUDIO/16000\n\
a=rtpmap:0 PCMU/8000\n\
a=rtpmap:4 G723/8000\n\
";

CHAR gszSDP[512];

//
// sdp blob for testing add stream, get sdp, and set back
//

CHAR *gszRemoteSDP = "\
v=0\n\
o=qhuai 0 0 IN IP4 157.55.89.115\n\
s=G711-H263\n\
c=IN IP4 239.9.20.26/15\n\
t=0 0\n\
m=video 20000 RTP/AVP 34 31\n\
a=rtpmap:34 H263/90000\n\
a=rtpmap:31 H261/90000\n\
m=audio 20040 RTP/AVP 0 4\n\
a=rtpmap:0 PCMU/8000\n\
a=rtpmap:4 G723/8000\n\
";

//
// global var
//

HINSTANCE               ghInst;
HWND                    ghDlg;
IRTCMediaManage         *gpIMediaManage;
IRTCTerminalManage      *gpITerminalManage;

#define PRIV_EVENTID (WM_USER+123)

//
// prototypes
//

// main dialog procedure
INT_PTR CALLBACK
MainDialogProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

// print message
void
Print(LPSTR pMessage, HRESULT hr);

// enable/disable button
void
ShowButton(
    HWND hDlg,
    int iID,
    BOOL fShow
    );

// streaming
HRESULT Join();
HRESULT Leave();
HRESULT ProcessMediaEvent(
    WPARAM wParam,
    LPARAM lParam
    );

// select terminals
HRESULT SelectTerminals();

// tune audio terminals
HRESULT TuneTerminals();

//
// WinMain
//

int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    ghInst = hInst;

    if (FAILED(CoInitialize(NULL)))
        return 0;

    // a lazy way
    if (lstrlen(lpCmdLine) < 8)
    {
        printf("Usage: join [local IP]");
        return 0;
    }

    // construct SDP
    lstrcpyn(gszSDP, gszSDP1, lstrlen(gszSDP1)+1);
    lstrcpyn(gszSDP+lstrlen(gszSDP1), lpCmdLine, lstrlen(lpCmdLine)+1);
    lstrcpyn(gszSDP+lstrlen(gszSDP1)+lstrlen(lpCmdLine), gszSDP2, lstrlen(gszSDP2)+1);

    // create media controller
    if (FAILED(CreateMediaController(&gpIMediaManage)))
        return 0;

    if (gpIMediaManage == NULL)
        return 0;

    if (FAILED(gpIMediaManage->QueryInterface(
            __uuidof(IRTCTerminalManage), (void**)&gpITerminalManage)))
    {
        gpIMediaManage->Shutdown();
        gpIMediaManage->Release();
        return 0;
    }

    // start dialog
    DialogBox(
        ghInst,
        MAKEINTRESOURCE(IDD_DIALOG),
        NULL,
        MainDialogProc
        );

    gpITerminalManage->Release();
    gpIMediaManage->Shutdown();

    gpIMediaManage->Release();

    CoUninitialize();

    return 1;
}

//
// MainDialogProc
//

INT_PTR CALLBACK
MainDialogProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HRESULT hr;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        // initiate media manage
        if (FAILED(gpIMediaManage->Initialize(hDlg, PRIV_EVENTID)))
        {
            EndDialog(hDlg, 0);
            return 1;
        }

        // set default devices
        if (FAILED(SelectTerminals()))
        {
            EndDialog(hDlg, 0);
            return 1;
        }

        // initiate dialog
        ShowButton(hDlg, IDJOIN, TRUE);
        ShowButton(hDlg, IDLEAVE, FALSE);
        ShowButton(hDlg, IDCLOSE, TRUE);

        SetFocus(GetDlgItem(hDlg, IDJOIN));

        ghDlg = hDlg;

        return 0;

    case WM_COMMAND:

        // check command
        switch (LOWORD(wParam))
        {
        case IDCLOSE:

            EndDialog(hDlg, 0);
            return 1;

        case IDTUNE:

            // tune terminals
            TuneTerminals();

            return 1;

        case IDJOIN:

            if (FAILED(hr = Join()))
            {
                Print("Failed to join", hr);
            }
            else
            {
                ShowButton(hDlg, IDJOIN, FALSE);
                ShowButton(hDlg, IDLEAVE, TRUE);

                SetFocus(GetDlgItem(hDlg, IDLEAVE));

                // test sdp
                /*
                CHAR *pSDP = NULL;

                hr = gpIMediaManage->GetSDPBlob(0, &pSDP);

                hr = gpIMediaManage->Reinitialize();

                hr = gpIMediaManage->SetSDPBlob(pSDP);

                free(pSDP);
                */

                // test set remote sdp
                hr = gpIMediaManage->SetSDPBlob(gszRemoteSDP);

            }
            return 1;

        case IDLEAVE:

            if (FAILED(hr = Leave()))
            {
                Print("Failed to Leave", hr);
            }
            else
            {
                ShowButton(hDlg, IDJOIN, TRUE);
                ShowButton(hDlg, IDLEAVE, FALSE);

                SetFocus(GetDlgItem(hDlg, IDJOIN));
            }
            return 1;

        default:
            return 0;
        } // end of checking command

        case PRIV_EVENTID:

            if (FAILED(hr = ProcessMediaEvent(wParam, lParam)))
                Print("Failed to process event", hr);

            return 1;


    default:
        return 0;
    } // end of processing message
}

//
// ShowButton
//
void
ShowButton(
    HWND hDlg,
    int iID,
    BOOL fShow
    )
{
    LPARAM style;

    if (fShow)
        style = BS_DEFPUSHBUTTON;
    else
        style = BS_PUSHBUTTON;

    SendDlgItemMessage(hDlg, iID, BM_SETSTYLE, style, 0);
    EnableWindow(GetDlgItem(hDlg, iID), fShow);
}

//
// Print
//
void
Print(
    CHAR *pMessage,
    HRESULT hr
    )
{
    CHAR str[64+12+1];

    if (hr == NOERROR)
    {
        MessageBox(ghDlg, pMessage, "RTC Streaming Test", MB_OK);
    }
    else
    {
        if (strlen(pMessage) > 64)
            sprintf(str, "WARNING! Message too long");
        else
            sprintf(str, "%s  0x%x", pMessage, hr);

        MessageBox(ghDlg, str, "RTC Streaming Test Error", MB_OK);
    }
}

//
// join
//

HRESULT
Join()
{
    HRESULT hr;

    // set sdp blob
    //hr = gpIMediaManage->SetSDPBlob(gszSDP);

    hr = gpIMediaManage->AddStream(RTC_MT_AUDIO, RTC_MD_CAPTURE, 0xac1f4c1f);
    hr = gpIMediaManage->AddStream(RTC_MT_AUDIO, RTC_MD_RENDER, 0xac1f4c1f);

    hr = gpIMediaManage->AddStream(RTC_MT_VIDEO, RTC_MD_CAPTURE, 0xac1f4c1f);
    hr = gpIMediaManage->AddStream(RTC_MT_VIDEO, RTC_MD_RENDER, 0xac1f4c1f);

    hr = gpIMediaManage->StartStream(RTC_MT_AUDIO, RTC_MD_CAPTURE);
    hr = gpIMediaManage->StartStream(RTC_MT_AUDIO, RTC_MD_RENDER);
    hr = gpIMediaManage->StartStream(RTC_MT_VIDEO, RTC_MD_CAPTURE);
    hr = gpIMediaManage->StartStream(RTC_MT_VIDEO, RTC_MD_RENDER);    

    return hr;
}

//
// process event
//

HRESULT
ProcessMediaEvent(
    WPARAM wParam,
    LPARAM lParam
    )
{
    RTC_MEDIA_EVENT event = (RTC_MEDIA_EVENT)wParam;
    RTCMediaEventItem *pitem = (RTCMediaEventItem *)lParam;

    CHAR msg[64];
    CHAR *ptitle;

    switch (event)
    {
    case RTC_ME_STREAM_CREATED:
        ptitle = "Stream created";
        break;

    case RTC_ME_STREAM_REMOVED:
        ptitle = "Stream removed";
        break;

    case RTC_ME_STREAM_ACTIVE:
        ptitle = "Stream active";
        break;

    case RTC_ME_STREAM_INACTIVE:
        ptitle = "Stream inactive";
        break;

    case RTC_ME_STREAM_FAIL:
        ptitle = "Stream fail";
        break;

    default:

        ptitle = "Unknown event";
    }

    sprintf(msg, "%s. mt=%d, md=%d\n\ncause=%d, hr=%x, no=%d",
           ptitle, pitem->MediaType, pitem->Direction,
           pitem->Cause, pitem->hrError, pitem->uiDebugInfo);

    Print(msg, NOERROR);

    gpIMediaManage->FreeMediaEvent(pitem);

    return NOERROR;
}

//
// leave
//
HRESULT
Leave()
{
    return gpIMediaManage->Reinitialize();
}

//
// select default terminals
//
HRESULT
SelectTerminals()
{
    IRTCTerminal *Terminals[10];
    DWORD dwNum = 10, i;

    HRESULT hr;

    // preference
    DWORD pref = 0;

    // terminal info
    RTC_MEDIA_TYPE MediaType;
    RTC_MEDIA_DIRECTION Direction;
    WCHAR *pDesp = NULL;

    if (FAILED(hr = gpITerminalManage->GetStaticTerminals(
            &dwNum,
            Terminals
            )))
    {
        return hr;
    }

    const WCHAR * const MODEM = L"Modem";
    const WCHAR * const WAVE = L"Wave";

    int AudCapt1st = -1;
    int AudCapt2nd = -1;

    int AudRend1st = -1;
    int AudRend2nd = -1;

    for (i=0; i<dwNum; i++)
    {
        // get terminal info
        if (FAILED(hr = Terminals[i]->GetMediaType(&MediaType)))
            goto Cleanup;

        if (FAILED(hr = Terminals[i]->GetDirection(&Direction)))
            goto Cleanup;

        if (FAILED(hr = Terminals[i]->GetDescription(&pDesp)))
            goto Cleanup;

        // check media type
        if (MediaType == RTC_MT_AUDIO && Direction == RTC_MD_CAPTURE)
        {
            if (!(pref & RTC_MP_AUDIO_CAPTURE) &&
                _wcsnicmp(pDesp, MODEM, lstrlenW(MODEM))!= 0)
            {                
                // don't have audio cap yet plus this isn't a modem
                if (wcsstr(pDesp, WAVE) != NULL)
                {
                    // hack, this is a WAVE device
                    AudCapt1st = i;
                }
                else
                {
                    AudCapt2nd = i;
                }
            }
        }
        else if (MediaType == RTC_MT_AUDIO && Direction == RTC_MD_RENDER)
        {
            if (!(pref & RTC_MP_AUDIO_RENDER) &&
                _wcsnicmp(pDesp, MODEM, lstrlenW(MODEM))!= 0)
            {                
                // don't have audio rend yet plus this isn't a modem
                // don't have audio cap yet plus this isn't a modem
                if (wcsstr(pDesp, WAVE) != NULL)
                {
                    // hack, this is a WAVE device
                    AudRend1st = i;
                }
                else
                {
                    AudRend2nd = i;
                }
            }
        }
        else if (MediaType == RTC_MT_VIDEO && Direction == RTC_MD_CAPTURE)
        {
            if (!(pref & RTC_MP_VIDEO_CAPTURE))
            {
                // don't have video cap yet
                if (FAILED(hr = gpITerminalManage->SetDefaultStaticTerminal(
                            MediaType,
                            Direction,
                            Terminals[i]
                            )))
                    {
                        goto Cleanup;
                    }

                    pref |= RTC_MP_VIDEO_CAPTURE;
            }
        }

        // release desp
        Terminals[i]->FreeDescription(pDesp);
        pDesp = NULL;
    }

    // set audio capture device
    if (AudCapt1st != -1 || AudCapt2nd != -1)
    {
        if (AudCapt1st == -1) AudCapt1st = AudCapt2nd;

        // set device
        if (FAILED(hr = gpITerminalManage->SetDefaultStaticTerminal(
                    RTC_MT_AUDIO,
                    RTC_MD_CAPTURE,
                    Terminals[AudCapt1st]
                    )))
        {
            goto Cleanup;
        }

        pref |= RTC_MP_AUDIO_CAPTURE;
    }

    // set audio render device
    if (AudRend1st != -1 || AudRend2nd != -1)
    {
        if (AudRend1st == -1) AudRend1st = AudRend2nd;

        // set device
        if (FAILED(hr = gpITerminalManage->SetDefaultStaticTerminal(
                    RTC_MT_AUDIO,
                    RTC_MD_RENDER,
                    Terminals[AudRend1st]
                    )))
        {
            goto Cleanup;
        }

        pref |= RTC_MP_AUDIO_RENDER;
    }

    if (pref == 0)
    {
        // oops, we got no static terminal, do something?
        hr = E_FAIL;

        goto Cleanup;
    }
    else
    {
        // add video render
        pref |= RTC_MP_VIDEO_RENDER;
    }

    // set preference
    if (FAILED(hr = gpIMediaManage->SetPreference(pref)))
    {
        goto Cleanup;
    }

Cleanup:

    if (pDesp) Terminals[0]->FreeDescription(pDesp);

    for (i=0; i<dwNum; i++)
    {
        Terminals[i]->Release();
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    test tuning audio terminal
////*/

HRESULT
TuneTerminals()
{
    HRESULT hr;

    // get default audio terminals
    CComPtr<IRTCTerminal> pAudCapt, pAudRend;

    if (FAILED(hr = gpITerminalManage->GetDefaultTerminal(
            RTC_MT_AUDIO,
            RTC_MD_CAPTURE,
            &pAudCapt
            )))
    {
        Print("No audio capture terminal", hr);

        return hr;
    }

    if (FAILED(hr = gpITerminalManage->GetDefaultTerminal(
            RTC_MT_AUDIO,
            RTC_MD_RENDER,
            &pAudRend
            )))
    {
        Print("No audio rend terminal", hr);

        return hr;
    }

    // QI tuning interface
    CComPtr<IRTCTuningManage> pTuning;

    if (FAILED(hr = gpITerminalManage->QueryInterface(
            __uuidof(IRTCTuningManage),
            (void**)&pTuning
            )))
    {
        Print("No tuning interface", hr);

        return hr;
    }

    // initiate tuning without AEC
    if (FAILED(hr = pTuning->InitializeTuning(pAudCapt, pAudRend, FALSE)))
    {
        Print("Failed to initialize tuning", hr);

        return hr;
    }

    // tuning audio capture
    if (FAILED(hr = pTuning->StartTuning(RTC_MD_RENDER)))
    {
        Print("Failed to start tune audio capture terminal", hr);

        pTuning->ShutdownTuning();

        return hr;
    }
    else
    {/*
        UINT ui;

        for (int i=0; i<20; i++)
        {
            Sleep(200);
            pTuning->GetVolume(RTC_MD_CAPTURE, &ui);
            pTuning->GetAudioLevel(RTC_MD_CAPTURE, &ui);
        }*/
    }

    Sleep(4000);

    // shutdown tuning and save result to reg
    pTuning->StopTuning(TRUE);

    // shutdown tuning
    hr = pTuning->ShutdownTuning();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\videotuner.h ===
/*++

Copyright (C) Microsoft Corporation, 2001

Module Name:

    VideoTuner.h

Abstract:


Author(s):

    Qianbo Huai (qhuai) 16-Feb-2001

--*/

#ifndef _VIDEOTUNER_H
#define _VIDEOTUNER_H

class CRTCVideoTuner
{
public:

    CRTCVideoTuner();

    ~CRTCVideoTuner();

    // video tuning
    HRESULT StartVideo(
        IN IRTCTerminal *pVidCaptTerminal,
        IN IRTCTerminal *pVidRendTerminal
        );

    HRESULT StopVideo();

private:

    VOID Cleanup();

private:

    BOOL m_fInTuning;

    // terminals
    CComPtr<IRTCTerminal> m_pVidCaptTerminal;
    CComPtr<IRTCTerminal> m_pVidRendTerminal;

    // graph builder
    CComPtr<IGraphBuilder> m_pIGraphBuilder;

    CComPtr<IBaseFilter> m_pNRFilter;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\test\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by join.rc
//
#define IDD_DIALOG                      101
#define IDJOIN                          1000
#define IDLEAVE                         1001
#define IDTUNE                          1002
#define IDEVENT                         2000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\test\stdafx.h ===
#ifndef _STDAFX_H
#define _STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include "rtcmedia.h"

#include "resource.h"
#include <stdio.h>

#include <atlimpl.cpp>

#include <stdio.h>

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\utility.cpp ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    utility.cpp

Abstract:


Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000

--*/

#include "stdafx.h"

#ifdef PERFORMANCE

LARGE_INTEGER    g_liFrequency;
LARGE_INTEGER    g_liCounter;
LARGE_INTEGER    g_liPrevCounter;

#endif

/*//////////////////////////////////////////////////////////////////////////////
    helper methods
////*/

HRESULT
AllocAndCopy(
    OUT WCHAR **ppDest,
    IN const WCHAR * const pSrc
    )
{
    if (pSrc == NULL)
    {
        *ppDest = NULL;
        return S_OK;
    }

    INT iStrLen = lstrlenW(pSrc);

    *ppDest = (WCHAR*)RtcAlloc((iStrLen+1) * sizeof(WCHAR));

    if (*ppDest == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpyW(*ppDest, pSrc);

    return S_OK;
}

HRESULT
AllocAndCopy(
    OUT CHAR **ppDest,
    IN const CHAR * const pSrc
    )
{
    if (pSrc == NULL)
    {
        *ppDest = NULL;
        return S_OK;
    }

    INT iStrLen = lstrlenA(pSrc);

    *ppDest = (CHAR*)RtcAlloc((iStrLen+1) * sizeof(CHAR));

    if (*ppDest == NULL)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpyA(*ppDest, pSrc);

    return S_OK;
}

HRESULT
AllocAndCopy(
    OUT CHAR **ppDest,
    IN const WCHAR * const pSrc
    )
{
    if (pSrc == NULL)
    {
        *ppDest = NULL;
        return S_OK;
    }

    INT iStrLen = lstrlenW(pSrc);

    *ppDest = (CHAR*)RtcAlloc((iStrLen+1) * sizeof(CHAR));

    if (*ppDest == NULL)
    {
        return E_OUTOFMEMORY;
    }

    WideCharToMultiByte(GetACP(), 0, pSrc, iStrLen+1, *ppDest, iStrLen+1, NULL, NULL);

    return S_OK;
}

HRESULT
AllocAndCopy(
    OUT WCHAR **ppDest,
    IN const CHAR * const pSrc
    )
{
    if (pSrc == NULL)
    {
        *ppDest = NULL;
        return S_OK;
    }

    INT iStrLen = lstrlenA(pSrc);

    *ppDest = (WCHAR*)RtcAlloc((iStrLen+1) * sizeof(WCHAR));

    if (*ppDest == NULL)
    {
        return E_OUTOFMEMORY;
    }

    MultiByteToWideChar(GetACP(), 0, pSrc, iStrLen+1, *ppDest, iStrLen+1);

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    Delete an AM media type returned by the filters
////*/
void
RTCDeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);

        // Strictly unnecessary but tidier
        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    CoTaskMemFree((PVOID)pmt);
}

/*//////////////////////////////////////////////////////////////////////////////
    find a pin on the filter
////*/

HRESULT
FindPin(
    IN  IBaseFilter     *pIBaseFilter, 
    OUT IPin            **ppIPin, 
    IN  PIN_DIRECTION   Direction,
    IN  BOOL            fFree
    )
{
    _ASSERT(ppIPin != NULL);

    HRESULT hr;
    DWORD dwFeched;

    // Get the enumerator of pins on the filter.
    CComPtr<IEnumPins> pIEnumPins;

    if (FAILED(hr = pIBaseFilter->EnumPins(&pIEnumPins)))
    {
        LOG((RTC_ERROR, "enumerate pins on the filter %x", hr));
        return hr;
    }

    IPin * pIPin;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &dwFeched) != S_OK)
        {
            LOG((RTC_ERROR, "find pin on filter."));
            return E_FAIL;
        }
        if (0 == dwFeched)
        {
            LOG((RTC_ERROR, "get 0 pin from filter."));
            return E_FAIL;
        }

        PIN_DIRECTION dir;

        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((RTC_ERROR, "query pin direction. %x", hr));

            pIPin->Release();
            return hr;
        }

        if (Direction == dir)
        {
            if (!fFree)
            {
                break;
            }

            // Check to see if the pin is RtcFree.
            CComPtr<IPin> pIPinConnected;

            hr = pIPin->ConnectedTo(&pIPinConnected);

            if (pIPinConnected == NULL)
            {
                break;
            }
        }

        pIPin->Release();
    }

    *ppIPin = pIPin;

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    find the filter behind the pin
////*/

HRESULT
FindFilter(
    IN  IPin            *pIPin,
    OUT IBaseFilter     **ppIBaseFilter
    )
{
    _ASSERT(ppIBaseFilter != NULL);

    HRESULT hr;
    PIN_INFO PinInfo;

    if (FAILED(hr = pIPin->QueryPinInfo(&PinInfo)))
    {
        LOG((RTC_ERROR, "FindFilter query pin info. %x", hr));

        return hr;
    }

    *ppIBaseFilter = PinInfo.pFilter;

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder    *pIGraph,
    IN IBaseFilter      *pIBaseFilter1,
    IN IBaseFilter      *pIBaseFilter2
    )
{
    HRESULT hr;

    CComPtr<IPin> pIPin1;
    if (FAILED(hr = ::FindPin(pIBaseFilter1, &pIPin1, PINDIR_OUTPUT)))
    {
        LOG((RTC_ERROR, "find output pin on filter1. %x", hr));
        return hr;
    }

    CComPtr<IPin> pIPin2;
    if (FAILED(hr = ::FindPin(pIBaseFilter2, &pIPin2, PINDIR_INPUT)))
    {
        LOG((RTC_ERROR, "find input pin on filter2. %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->ConnectDirect(pIPin1, pIPin2, NULL))) 
    {
        LOG((RTC_ERROR, "connect pins direct failed: %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder    *pIGraph,
    IN IPin             *pIPin1, 
    IN IBaseFilter      *pIBaseFilter2
    )
{
    HRESULT hr;

    CComPtr<IPin> pIPin2;
    if (FAILED(hr = ::FindPin(pIBaseFilter2, &pIPin2, PINDIR_INPUT)))
    {
        LOG((RTC_ERROR, "find input pin on filter2. %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->ConnectDirect(pIPin1, pIPin2, NULL))) 
    {
        LOG((RTC_ERROR, "connect pins direct failed: %x", hr));
        return hr;
    }

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder    *pIGraph,
    IN IBaseFilter      *pIBaseFilter1,
    IN IPin             *pIPin2
    )
{
    HRESULT hr;

    CComPtr<IPin> pIPin1;
    if (FAILED(hr = ::FindPin(pIBaseFilter1, &pIPin1, PINDIR_OUTPUT)))
    {
        LOG((RTC_ERROR, "find output pin on filter1. %x", hr));
        return hr;
    }

    if (FAILED(hr = pIGraph->ConnectDirect(pIPin1, pIPin2, NULL))) 
    {
        LOG((RTC_ERROR, "connect pins direct failed: %x", hr));
        return hr;
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    set a default mapping for rtp filter. o.w. we will fail to connect
    rtp and edge filter
////*/

HRESULT
PrepareRTPFilter(
    IN IRtpMediaControl *pIRtpMediaControl,
    IN IStreamConfig    *pIStreamConfig
    )
{
    ENTER_FUNCTION("PrepareRTPFilter");

    DWORD dwFormat;
    AM_MEDIA_TYPE *pmt;

    HRESULT hr = pIStreamConfig->GetFormat(
            &dwFormat,
            &pmt
            );

    if (FAILED(hr))
    {
        LOG((RTC_ERROR, "%s get format. %x", __fxName, hr));

        return hr;
    }

    if (FAILED(hr = pIRtpMediaControl->SetFormatMapping(
            dwFormat,
            ::FindSampleRate(pmt),
            pmt
            )))
    {
        LOG((RTC_ERROR, "%s set format mapping. %x", __fxName, hr));
    }

    ::RTCDeleteMediaType(pmt);

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    get link speed based on the local interface
////*/

HRESULT
GetLinkSpeed(
    IN DWORD dwLocalIP,
    OUT DWORD *pdwSpeed
    )
{
#define UNINITIALIZED_IF_INDEX  ((DWORD)-1)
#define DEFAULT_IPADDRROW 10

    DWORD dwSize;
    DWORD dwIndex;
    DWORD dwStatus;
    DWORD dwIfIndex = UNINITIALIZED_IF_INDEX;
    PMIB_IPADDRTABLE pIPAddrTable = NULL;
    MIB_IFROW IfRow;
    IN_ADDR addr;
    HRESULT hr = S_OK;

    ENTER_FUNCTION("GetLinkSpeed");
    
    // convert to network order
    DWORD dwNetIP = htonl(dwLocalIP);

    addr.s_addr = dwNetIP;

    // default to reasonable size
    dwSize = sizeof(MIB_IPADDRTABLE);

    do {
        // release buffer if already allocated
        if(pIPAddrTable)
        {
            RtcFree(pIPAddrTable);
        }

        dwSize += sizeof(MIB_IPADDRROW) * DEFAULT_IPADDRROW;

        // allocate default table
        pIPAddrTable = (PMIB_IPADDRTABLE)RtcAlloc(dwSize);

        // validate allocation
        if (pIPAddrTable == NULL) {

            LOG((RTC_ERROR, "%s: Could not allocate IP address table.", __fxName));

            hr = E_OUTOFMEMORY;
            
            goto function_exit;
        }

        // attempt to get table
        dwStatus = GetIpAddrTable(
                        pIPAddrTable,
                        &dwSize,
                        FALSE       // sort table
                        );

    } while (dwStatus == ERROR_INSUFFICIENT_BUFFER);

    // validate status
    if (dwStatus != S_OK) {

        LOG((RTC_ERROR, "%s: Error %x calling GetIpAddrTable.", __fxName, dwStatus));

        // failure
        hr = E_FAIL;

        goto function_exit;
    }

    // find the correct row in the table
    for (dwIndex = 0; dwIndex < pIPAddrTable->dwNumEntries; dwIndex++) {

        // compare given address to interface address
        if (dwNetIP == pIPAddrTable->table[dwIndex].dwAddr) {

            // save index into interface table
            dwIfIndex = pIPAddrTable->table[dwIndex].dwIndex;
            
            // done
            break;
        }
    }

    // validate row pointer
    if (dwIfIndex == UNINITIALIZED_IF_INDEX) {

        LOG((RTC_ERROR, "%s: Could not locate address %s in IP address table.",
            __fxName, inet_ntoa(addr)));

        hr = E_FAIL;

        goto function_exit;
    }

    // initialize structure
    ZeroMemory(&IfRow, sizeof(IfRow));

    // set interface index
    IfRow.dwIndex = dwIfIndex;

    // retrieve interface info
    dwStatus = GetIfEntry(&IfRow);

    // validate status
    if (dwStatus != S_OK)
    {
        LOG((RTC_ERROR, "%s: Error %x calling GetIfEntry(%d).",
            __fxName, dwStatus, dwIfIndex));

        hr = E_FAIL;

        goto function_exit;
    }

    // return link speed
    LOG((RTC_TRACE, "%s: ip %s, link speed %d", __fxName, inet_ntoa(addr), IfRow.dwSpeed));

    *pdwSpeed = IfRow.dwSpeed;

function_exit:

    if(pIPAddrTable)
    {
        RtcFree(pIPAddrTable);
    }

    return hr;
}

HRESULT
EnableAEC(
    IN IAudioDuplexController *pControl
    )
{
    EFFECTS Effect = EFFECTS_AEC;
    BOOL fEnableAEC = TRUE;

    return pControl->EnableEffects(1, &Effect, &fEnableAEC);
}

/*//////////////////////////////////////////////////////////////////////////////
    get audio capture volume using mixer api
////*/

HRESULT
DirectGetCaptVolume(
    UINT uiWaveID,
    UINT *puiVolume
    )
{
    ENTER_FUNCTION("DirectGetCaptVolume");

    MMRESULT result;

    BOOL foundMicrophone = FALSE;
    DWORD i;

    // Open the mixer device
    HMIXER hmx = NULL;

    result = mixerOpen(&hmx, uiWaveID, 0, 0, MIXER_OBJECTF_WAVEIN);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s mixer open. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    // Get the line info for the wave in destination line
    MIXERLINE mxl;

    mxl.cbStruct = sizeof(mxl);
    mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get compoent types. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // save dwLineID of wave_in dest
    DWORD dwLineID = mxl.dwLineID;

    // Now find the microphone source line connected to this wave in
    // destination
    DWORD cConnections = mxl.cConnections;

    // try microphone
    for(i=0; i<cConnections; i++)
    {
        mxl.dwSource = i;

        result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

        if (result != MMSYSERR_NOERROR)
        {
            LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

            mixerClose(hmx);

            return HRESULT_FROM_WIN32(result);
        }

        if (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mxl.dwComponentType)
        {
          foundMicrophone = TRUE;
          break;
        }
    }

    // get volume control on microphone
    MIXERCONTROL mxctrl;

    MIXERLINECONTROLS mxlctrl = {
       sizeof(mxlctrl), mxl.dwLineID, MIXERCONTROL_CONTROLTYPE_VOLUME, 
       1, sizeof(MIXERCONTROL), &mxctrl 
    };

    if (foundMicrophone)
    {
        result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE);

        if (result != MMSYSERR_NOERROR)
        {
            LOG((RTC_ERROR, "%s Unable to get volume control on mic", __fxName));

            // we need to try wave-in destination
            foundMicrophone = FALSE;
        }
    }

    if( !foundMicrophone )
    {
        // try wave-in dest
        mxlctrl.cbStruct = sizeof(MIXERLINECONTROLS);
        mxlctrl.dwLineID = dwLineID;
        mxlctrl.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mxlctrl.cControls = 1;
        mxlctrl.cbmxctrl = sizeof(MIXERCONTROL);
        mxlctrl.pamxctrl = &mxctrl;

        result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE);

        if (result != MMSYSERR_NOERROR)
        {
            LOG((RTC_ERROR, "%s Unable to get volume control on wave_in dest", __fxName));

            mixerClose(hmx);

            return HRESULT_FROM_WIN32(result);
        }
    }

    // Found!
    DWORD cChannels = mxl.cChannels;

    if (MIXERCONTROL_CONTROLF_UNIFORM & mxctrl.fdwControl)
        cChannels = 1;

    if (cChannels > 1)
        cChannels = 2;

    MIXERCONTROLDETAILS_UNSIGNED pUnsigned[2];

    MIXERCONTROLDETAILS mxcd = {
        sizeof(mxcd), mxctrl.dwControlID, 
        cChannels, (HWND)0, sizeof(MIXERCONTROLDETAILS_UNSIGNED), 
        (LPVOID) pUnsigned
    };

    result = mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get control details. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // Get the volume
    result = mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    mixerClose(hmx);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get control details. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    // get the volume
    DOUBLE dVolume = (DOUBLE)pUnsigned[0].dwValue * RTC_MAX_AUDIO_VOLUME / mxctrl.Bounds.dwMaximum;

    UINT uiVolume = (UINT)(dVolume);

    if (dVolume-(DOUBLE)uiVolume > 0.5)
        uiVolume ++;

    if (uiVolume > RTC_MAX_AUDIO_VOLUME)
    {
        *puiVolume = RTC_MAX_AUDIO_VOLUME;
    }
    else
    {
        *puiVolume = uiVolume;
    }

    return S_OK;
}

HRESULT
GetMixerControlForRend(
    UINT uiWaveID,
    IN  DWORD dwControlType,
    OUT HMIXEROBJ *pID1,
    OUT MIXERCONTROL *pmc1,
    OUT BOOL *pfFound1st,
    OUT HMIXEROBJ *pID2,
    OUT MIXERCONTROL *pmc2,
    OUT BOOL *pfFound2nd
    )
{
    ENTER_FUNCTION("GetMixerControlForRend");

    *pfFound1st = FALSE;
    *pfFound2nd = FALSE;

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    HMIXEROBJ MixerID = NULL;
    MMRESULT mmr = mixerGetID(
        (HMIXEROBJ)IntToPtr(uiWaveID), (UINT *)&MixerID, MIXER_OBJECTF_WAVEOUT
        );

    if (mmr != MMSYSERR_NOERROR) 
    {
        LOG((RTC_ERROR, "%s, mixerGetID failed, mmr=%d", __fxName, mmr));

        return HRESULT_FROM_WIN32(mmr);
    }

    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mxlcontrols;
    MIXERCONTROL mxcontrol;

    //
    // 1st - try src waveout
    //

    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT;
    mmr = mixerGetLineInfo(MixerID, &mixerinfo,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (mmr == 0)
    {
        // check control type
        if (mixerinfo.cControls > 0)
        {
            mxlcontrols.cbStruct = sizeof(MIXERLINECONTROLS);
            mxlcontrols.dwLineID = mixerinfo.dwLineID;
            mxlcontrols.cControls = 1;
            mxlcontrols.cbmxctrl = sizeof(MIXERCONTROL);
            mxlcontrols.pamxctrl = &mxcontrol;
            mxlcontrols.dwControlType = dwControlType;

            mmr = mixerGetLineControls(MixerID, &mxlcontrols,
                MIXER_GETLINECONTROLSF_ONEBYTYPE);

            if (mmr == 0)
            {
                *pfFound1st = TRUE;

                *pID1 = MixerID;
                *pmc1 = mxcontrol;
            }
        }
    }

    //
    // 2nd - try dst speaker
    //

    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
    mmr = mixerGetLineInfo(MixerID, &mixerinfo,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (mmr == 0)
    {
        // check control type
        if (mixerinfo.cControls > 0)
        {
            mxlcontrols.cbStruct = sizeof(MIXERLINECONTROLS);
            mxlcontrols.dwLineID = mixerinfo.dwLineID;
            mxlcontrols.cControls = 1;
            mxlcontrols.cbmxctrl = sizeof(MIXERCONTROL);
            mxlcontrols.pamxctrl = &mxcontrol;
            mxlcontrols.dwControlType = dwControlType;

            mmr = mixerGetLineControls(MixerID, &mxlcontrols,
                MIXER_GETLINECONTROLSF_ONEBYTYPE);

            if (mmr == 0)
            {
                *pfFound2nd = TRUE;

                *pID2 = MixerID;
                *pmc2 = mxcontrol;
            }
        }
    }

    if (!(*pfFound1st || *pfFound2nd ))
    {
       LOG((RTC_ERROR, "%s, can't find the control needed", __fxName));
        return E_FAIL;
    }

    return S_OK;
}

// get volume for render device
HRESULT
DirectGetRendVolume(
    UINT uiWaveID,
    UINT *puiVolume
    )
{
    ENTER_FUNCTION("DirectGetRendVolume");

    // Get the volume control
    HMIXEROBJ MixerID1 = NULL, MixerID2 = NULL;
    MIXERCONTROL mc1, mc2;

    BOOL fFound1st = FALSE, fFound2nd = FALSE;

    HRESULT hr = GetMixerControlForRend(
        uiWaveID,
        MIXERCONTROL_CONTROLTYPE_VOLUME,
        &MixerID1, &mc1, &fFound1st,
        &MixerID2, &mc2, &fFound2nd
        );
    
    if (hr != S_OK) 
    {
        LOG((RTC_ERROR, "%s, Error %x getting volume control", __fxName, hr));
        return hr;
    }

    if (!fFound1st)
    {
        MixerID1 = MixerID2;
        mc1 = mc2;
    }

    MIXERCONTROLDETAILS_UNSIGNED Volume;

    // get the current volume levels
    MIXERCONTROLDETAILS mixerdetails;
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc1.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
    mixerdetails.paDetails = &Volume;
    
    MMRESULT mmr = mixerGetControlDetails(MixerID1, &mixerdetails, 0);
    if (mmr != MMSYSERR_NOERROR) 
    {
        LOG((RTC_ERROR, "%s, Error %d getting volume", __fxName, mmr));
        return HRESULT_FROM_WIN32(mmr);
    }

    DOUBLE dVolume = (DOUBLE)Volume.dwValue * RTC_MAX_AUDIO_VOLUME / mc1.Bounds.dwMaximum;

    UINT uiVolume = (UINT)(dVolume);

    if (dVolume-(DOUBLE)uiVolume > 0.5)
        uiVolume ++;

    if (uiVolume > RTC_MAX_AUDIO_VOLUME)
    {
        *puiVolume = RTC_MAX_AUDIO_VOLUME;
    }
    else
    {
        *puiVolume = uiVolume;
    }

    return S_OK;
}

#if 0

/*//////////////////////////////////////////////////////////////////////////////
    set audio capture volume using mixer api
////*/

HRESULT
DirectSetCaptVolume(    
    UINT uiWaveID,
    DOUBLE dVolume
    )
{
    ENTER_FUNCTION("DirectSetCaptVolume");

    MMRESULT result;

    BOOL foundMicrophone = FALSE;
    DWORD i;

    // Open the mixer device
    HMIXER hmx = NULL;

    result = mixerOpen(&hmx, uiWaveID, 0, 0, MIXER_OBJECTF_WAVEIN);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s mixer open. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    // Get the line info for the wave in destination line
    MIXERLINE mxl;

    mxl.cbStruct = sizeof(mxl);
    mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get compoent types. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // Now find the microphone source line connected to this wave in
    // destination
    DWORD cConnections = mxl.cConnections;

    // try microphone
    for(i=0; i<cConnections; i++)
    {
        mxl.dwSource = i;

        result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

        if (result != MMSYSERR_NOERROR)
        {
            LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

            mixerClose(hmx);

            return HRESULT_FROM_WIN32(result);
        }

        if (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mxl.dwComponentType)
        {
          foundMicrophone = TRUE;
          break;
        }
    }

    // try line in
    if( !foundMicrophone )
    {
        for(i=0; i<cConnections; i++)
        {
            mxl.dwSource = i;

            result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

            if (result != MMSYSERR_NOERROR)
            {
                LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

                mixerClose(hmx);

                return HRESULT_FROM_WIN32(result);
            }

            if (MIXERLINE_COMPONENTTYPE_SRC_LINE == mxl.dwComponentType)
            {
                foundMicrophone = TRUE;
                break;
            }
        }   
    }

    // try auxiliary
    if( !foundMicrophone )
    {
        for(i=0; i<cConnections; i++)
        {
            mxl.dwSource = i;

            result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

            if (result != MMSYSERR_NOERROR)
            {
                LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

                mixerClose(hmx);

                return HRESULT_FROM_WIN32(result);
            }

            if (MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY == mxl.dwComponentType)
            {
                foundMicrophone = TRUE;
                break;
            }
        }   
    }

    if( !foundMicrophone )
    {
        LOG((RTC_ERROR, "%s Unable to find microphone source", __fxName));

        mixerClose(hmx);
        return E_FAIL;
    }

    // Find a volume control, if any, of the microphone line
    MIXERCONTROL mxctrl;

    MIXERLINECONTROLS mxlctrl = {
       sizeof(mxlctrl), mxl.dwLineID, MIXERCONTROL_CONTROLTYPE_VOLUME, 
       1, sizeof(MIXERCONTROL), &mxctrl 
    };

    result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s Unable to get onebytype", __fxName));

        mixerClose(hmx);
        return HRESULT_FROM_WIN32(result);
    }

    // Found!
    DWORD cChannels = mxl.cChannels;

    if (MIXERCONTROL_CONTROLF_UNIFORM & mxctrl.fdwControl)
        cChannels = 1;

    if (cChannels > 1)
        cChannels = 2;

    MIXERCONTROLDETAILS_UNSIGNED pUnsigned[2];

    MIXERCONTROLDETAILS mxcd = {
        sizeof(mxcd), mxctrl.dwControlID, 
        cChannels, (HWND)0, sizeof(MIXERCONTROLDETAILS_UNSIGNED), 
        (LPVOID) pUnsigned
    };

    result = mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get control details. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // Set the volume
    pUnsigned[0].dwValue = pUnsigned[cChannels-1].dwValue = (DWORD)(dVolume*mxctrl.Bounds.dwMaximum);

    result = mixerSetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    mixerClose(hmx);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s set control details. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    mute or unmute audio capture
////*/

HRESULT
DirectSetCaptMute(
    UINT uiWaveID,
    BOOL fMute
    )
{
    ENTER_FUNCTION("DirectSetCaptMute");

    MMRESULT result;

    // Open the mixer device
    HMIXER hmx = NULL;

    result = mixerOpen(&hmx, uiWaveID, 0, 0, MIXER_OBJECTF_WAVEIN);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s mixer open. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    // Get the line info for the wave in destination line
    MIXERLINE mxl;

    mxl.cbStruct = sizeof(mxl);
    mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get compoent types. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // get mute control
    MIXERCONTROL mxctrl;

    mxctrl.cbStruct = sizeof(MIXERCONTROL);
    mxctrl.dwControlType = 0;

    MIXERLINECONTROLS mxlctrl = {
       sizeof(mxlctrl), mxl.dwLineID, MIXERCONTROL_CONTROLTYPE_MUTE, 
       0, sizeof(MIXERCONTROL), &mxctrl 
    };

    result = mixerGetLineControls((HMIXEROBJ) hmx, &mxlctrl, MIXER_GETLINECONTROLSF_ONEBYTYPE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s Unable to get onebytype. %d", __fxName, result));

        mixerClose(hmx);
        return HRESULT_FROM_WIN32(result);
    }

    // get control detail
    MIXERCONTROLDETAILS_BOOLEAN muteDetail;

    MIXERCONTROLDETAILS mxcd = {
        sizeof(mxcd), mxctrl.dwControlID, 
        mxl.cChannels, (HWND)0, sizeof(MIXERCONTROLDETAILS_BOOLEAN), 
        (LPVOID)&muteDetail
    };

    result = mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get control details. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // set mute
    muteDetail.fValue = fMute?0:1;

    result = mixerSetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    mixerClose(hmx);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s set mute detail. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    return S_OK;
}

/*//////////////////////////////////////////////////////////////////////////////
    check mute state of audio capture
////*/

HRESULT
DirectGetCaptMute(
    UINT uiWaveID,
    BOOL *pfMute
    )
{
    ENTER_FUNCTION("DirectGetCaptMute");

    MMRESULT result;

    BOOL foundMicrophone = FALSE;
    DWORD i;

    // Open the mixer device
    HMIXER hmx = NULL;

    result = mixerOpen(&hmx, uiWaveID, 0, 0, MIXER_OBJECTF_WAVEIN);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s mixer open. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    // Get the line info for the wave in destination line
    MIXERLINE mxl;

    mxl.cbStruct = sizeof(mxl);
    mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

    result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get compoent types. %d", __fxName, result));

        mixerClose(hmx);

        return HRESULT_FROM_WIN32(result);
    }

    // Now find the microphone source line connected to this wave in
    // destination
    DWORD cConnections = mxl.cConnections;

    // try microphone
    for(i=0; i<cConnections; i++)
    {
        mxl.dwSource = i;

        result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

        if (result != MMSYSERR_NOERROR)
        {
            LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

            mixerClose(hmx);

            return HRESULT_FROM_WIN32(result);
        }

        if (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mxl.dwComponentType)
        {
          foundMicrophone = TRUE;
          break;
        }
    }

    // try line in
    if( !foundMicrophone )
    {
        for(i=0; i<cConnections; i++)
        {
            mxl.dwSource = i;

            result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

            if (result != MMSYSERR_NOERROR)
            {
                LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

                mixerClose(hmx);

                return HRESULT_FROM_WIN32(result);
            }

            if (MIXERLINE_COMPONENTTYPE_SRC_LINE == mxl.dwComponentType)
            {
                foundMicrophone = TRUE;
                break;
            }
        }   
    }

    // try auxiliary
    if( !foundMicrophone )
    {
        for(i=0; i<cConnections; i++)
        {
            mxl.dwSource = i;

            result = mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_SOURCE);

            if (result != MMSYSERR_NOERROR)
            {
                LOG((RTC_ERROR, "%s get line source. %d", __fxName, result));

                mixerClose(hmx);

                return HRESULT_FROM_WIN32(result);
            }

            if (MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY == mxl.dwComponentType)
            {
                foundMicrophone = TRUE;
                break;
            }
        }   
    }

    if( !foundMicrophone )
    {
        LOG((RTC_ERROR, "%s Unable to find microphone source", __fxName));

        mixerClose(hmx);
        return E_FAIL;
    }

    // get mute control
    MIXERLINECONTROLS mxlctrl;
    MIXERCONTROL mxctrl;

    ZeroMemory(&mxlctrl, sizeof(MIXERLINECONTROLS));
    ZeroMemory(&mxctrl, sizeof(MIXERCONTROL));

    mxlctrl.cbStruct = sizeof(MIXERLINECONTROLS);
    mxlctrl.dwLineID = mxl.dwLineID;
    mxlctrl.dwControlType = MIXERCONTROL_CONTROLTYPE_MUTE;
    mxlctrl.cControls = 1;
    mxlctrl.cbmxctrl = sizeof(MIXERCONTROL);
    mxlctrl.pamxctrl = &mxctrl;

    result = mixerGetLineControls(
        (HMIXEROBJ)hmx, &mxlctrl,
        MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s Unable to get onebytype. %d", __fxName, result));

        mixerClose(hmx);
        return HRESULT_FROM_WIN32(result);
    }

    // get control detail
    MIXERCONTROLDETAILS_BOOLEAN muteDetail;

    MIXERCONTROLDETAILS mxcd;
    ZeroMemory(&mxcd, sizeof(MIXERCONTROLDETAILS));

    mxcd.cbStruct = sizeof(MIXERCONTROLDETAILS);
    mxcd.dwControlID = mxctrl.dwControlID;
    mxcd.cChannels = mxl.cChannels;
    mxcd.cMultipleItems = 0;

    muteDetail.fValue = 0;
    mxcd.paDetails = &muteDetail;
    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

    result = mixerGetControlDetails((HMIXEROBJ)hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE);

    mixerClose(hmx);

    if (result != MMSYSERR_NOERROR)
    {
        LOG((RTC_ERROR, "%s get control details. %d", __fxName, result));

        return HRESULT_FROM_WIN32(result);
    }

    // get mute
    *pfMute = muteDetail.fValue==0?TRUE:FALSE;

    return S_OK;
}
#endif // 0

/* Init reference time */
void CRTCStreamClock::InitReferenceTime(void)
{
    m_lPerfFrequency = 0;

    /* NOTE The fact that having multiprocessor makes the
     * performance counter to be unreliable (in some machines)
     * unless I set the processor affinity, which I can not
     * because any thread can request the time, so use it only on
     * uniprocessor machines */
    /* MAYDO Would be nice to enable this also in multiprocessor
     * machines, if I could specify what procesor's performance
     * counter to read or if I had a processor independent
     * performance counter */

    /* Actually the error should be quite smaller than 1ms, making
     * this bug irrelevant for my porpuses, so alway use performance
     * counter if available */
    QueryPerformanceFrequency((LARGE_INTEGER *)&m_lPerfFrequency);

    if (m_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&m_lRtpRefTime);
        /* Arbitrarily start time not at zero but at 100ms */
        m_lRtpRefTime -= m_lPerfFrequency/10;
    }
    else
    {
        m_dwRtpRefTime = timeGetTime();
        /* Arbitrarily start time not at zero but at 100ms */
        m_dwRtpRefTime -= 100;
    }
}

/* Return time in 100's of nanoseconds since the object was
 * initialized */
HRESULT CRTCStreamClock::GetTimeOfDay(OUT REFERENCE_TIME *pTime)
{
    union {
        DWORD            dwCurTime;
        LONGLONG         lCurTime;
    };
    LONGLONG         lTime;

    if (m_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime = lTime - m_lRtpRefTime;

        *pTime = (REFERENCE_TIME)(lCurTime * 10000000 / m_lPerfFrequency);
    }
    else
    {
        dwCurTime = timeGetTime() - m_dwRtpRefTime;
        
        *pTime = (REFERENCE_TIME)(dwCurTime * 10000);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\utility.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    utility.h

Abstract:

    Implements array, auto lock, clock classes, etc

Author(s):

    Qianbo Huai (qhuai) 18-Jul-2000
    original sources: msputils.h and confutil.h

--*/

#ifndef _UTILITY_H
#define _UTILITY_H

// performance counter
#ifdef PERFORMANCE

extern LARGE_INTEGER    g_liFrequency;

static const CHAR* const g_strPerf = "Performance:";

inline DWORD CounterDiffInMS(
    LARGE_INTEGER &liNewTick,
    LARGE_INTEGER &liOldTick
    )
{
    return (DWORD)((liNewTick.QuadPart - liOldTick.QuadPart)
        * 1000.0 / g_liFrequency.QuadPart);
}

#endif

#define RTC_HANDLE ULONG_PTR

/*//////////////////////////////////////////////////////////////////////////////
    Create a new CComObject instance. Use try/except to catch exception.
////*/

template <class T>
HRESULT CreateCComObjectInstance (
    CComObject<T> **ppObject
    )
{
    HRESULT hr;

    __try
    {
        hr = CComObject<T>::CreateInstance(ppObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *ppObject = NULL;
        return E_OUTOFMEMORY;
    }

    return hr;
}

/*//////////////////////////////////////////////////////////////////////////////
    Define CRTCArray class
////*/

const DWORD INITIAL = 8;
const DWORD DELTA   = 8;

template <class T, DWORD dwInitial = INITIAL, DWORD dwDelta = DELTA>
class CRTCArray
{

protected:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

public:
// Construction/destruction
    CRTCArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CRTCArray()
    {
        RemoveAll();
    }

// Operations
    int GetSize() const
    {
        return m_nSize;
    }

    BOOL Grow()
    {
        T* aT;
        int nNewAllocSize = 
            (m_nAllocSize == 0) ? dwInitial : (m_nSize + DELTA);

        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
        if(aT == NULL)
            return FALSE;
        m_nAllocSize = nNewAllocSize;
        m_aT = aT;
        return TRUE;
    }

    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            if (!Grow()) return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }

    BOOL Remove(T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }

    BOOL RemoveAt(int nIndex)
    {
        if(nIndex != (m_nSize - 1))
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], 
                (m_nSize - (nIndex + 1)) * sizeof(T));
        m_nSize--;
        return TRUE;
    }

    void RemoveAll()
    {
        if(m_nAllocSize > 0)
        {
            free(m_aT);
            m_aT = NULL;
            m_nSize = 0;
            m_nAllocSize = 0;
        }
    }

    T& operator[] (int nIndex) const
    {
        _ASSERT(nIndex >= 0 && nIndex < m_nSize);

        return m_aT[nIndex];
    }

    T* GetData() const
    {
        return m_aT;
    }

// Implementation
    void SetAtIndex(int nIndex, T& t)
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nSize);
        m_aT[nIndex] = t;
    }
    int Find(T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
};

/*//////////////////////////////////////////////////////////////////////////////
    Definitions for a auto initialize critical section.
////*/
class CRTCCritSection
{
private:
    CRITICAL_SECTION m_CritSec;

public:
    CRTCCritSection()
    {
        InitializeCriticalSection(&m_CritSec);
    }

    ~CRTCCritSection()
    {
        DeleteCriticalSection(&m_CritSec);
    }

    void Lock() 
    {
        EnterCriticalSection(&m_CritSec);
    }

    BOOL TryLock() 
    {
        return TryEnterCriticalSection(&m_CritSec);
    }

    void Unlock() 
    {
        LeaveCriticalSection(&m_CritSec);
    }
};

/*++

CRTCCritSection Description:

    Definitions for a auto lock that unlocks when the variable is out
    of scope.

--*/
class CLock
{
private:
    CRTCCritSection &m_CriticalSection;

public:
    CLock(CRTCCritSection &CriticalSection)
        : m_CriticalSection(CriticalSection)
    {
        m_CriticalSection.Lock();
    }

    ~CLock()
    {
        m_CriticalSection.Unlock();
    }
};

class ATL_NO_VTABLE CRTCStreamClock : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IReferenceClock
{
private:
    LONGLONG         m_lPerfFrequency;
    union {
        LONGLONG         m_lRtpRefTime;
        DWORD            m_dwRtpRefTime;
    };
public:
BEGIN_COM_MAP(CRTCStreamClock)
    COM_INTERFACE_ENTRY(IReferenceClock)
END_COM_MAP()

    void InitReferenceTime(void);

    HRESULT GetTimeOfDay(OUT REFERENCE_TIME *pTime);
    
    CRTCStreamClock()
    {
        InitReferenceTime();
    }

    STDMETHOD (GetTime) (
        OUT REFERENCE_TIME *pTime
        )
    {
        return(GetTimeOfDay(pTime));
    }   

    STDMETHOD (AdviseTime) (
        IN REFERENCE_TIME baseTime,        // base reference time
        IN REFERENCE_TIME streamTime,      // stream offset time
        IN HEVENT hEvent,                  // advise via this event
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdviseTime is called");
        return E_NOTIMPL;
    }

    STDMETHOD (AdvisePeriodic) (
        IN REFERENCE_TIME StartTime,       // starting at this time
        IN REFERENCE_TIME PeriodTime,      // time between notifications
        IN HSEMAPHORE hSemaphore,          // advise via a semaphore
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdvisePeriodic is called");
        return E_NOTIMPL;
    }

    STDMETHOD (Unadvise) (
        IN DWORD_PTR dwAdviseCookie
        )
    {
        _ASSERT(!"Unadvise is called");
        return E_NOTIMPL;
    }
};

/*//////////////////////////////////////////////////////////////////////////////
    helper methods
////*/

HRESULT AllocAndCopy(
    OUT WCHAR **ppDest,
    IN const WCHAR * const pSrc
    );

HRESULT AllocAndCopy(
    OUT CHAR **ppDest,
    IN const WCHAR * const pSrc
    );

HRESULT AllocAndCopy(
    OUT WCHAR **ppDest,
    IN const CHAR * const pSrc
    );

HRESULT AllocAndCopy(
    OUT CHAR **ppDest,
    IN const CHAR * const pSrc
    );

inline void NullBSTR(
    BSTR *pBstr
    )
{
    SysFreeString(*pBstr);
    *pBstr = NULL;
}

inline DWORD FindSampleRate(AM_MEDIA_TYPE *pMediaType)
{
    _ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (pMediaType->majortype  == MEDIATYPE_Audio &&
        pMediaType->formattype == FORMAT_WaveFormatEx &&
        pMediaType->pbFormat   != NULL &&
        pMediaType->cbFormat   != 0
       )
    {
        WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
        return pWaveFormatEx->nSamplesPerSec;
    }

    return 90000;      // default media clock rate, including video.
}

void RTCDeleteMediaType(AM_MEDIA_TYPE *pmt);

HRESULT
FindPin(
    IN  IBaseFilter     *pIBaseFilter, 
    OUT IPin            **ppIPin, 
    IN  PIN_DIRECTION   Direction,
    IN  BOOL            fFree = TRUE
    );

HRESULT
FindFilter(
    IN  IPin            *pIPin,
    OUT IBaseFilter     **ppIBaseFilter
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder    *pIGraph,
    IN IBaseFilter      *pIBaseFilter1,
    IN IBaseFilter      *pIBaseFilter2
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder    *pIGraph,
    IN IPin             *pIPin1, 
    IN IBaseFilter      *pIBaseFilter2
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder    *pIGraph,
    IN IBaseFilter      *pIBaseFilter1,
    IN IPin             *pIPin2
    );

HRESULT
PrepareRTPFilter(
    IN IRtpMediaControl *pIRtpMediaControl,
    IN IStreamConfig    *pIStreamConfig
    );

HRESULT
GetLinkSpeed(
    IN DWORD dwLocalIP,
    OUT DWORD *pdwSpeed
    );

HRESULT
EnableAEC(
    IN IAudioDuplexController *pControl
    );

/*//////////////////////////////////////////////////////////////////////////////
    bypass dxmrtp audio filter and deal with audio device setting
    directly using mixer api
////*/

HRESULT
DirectGetCaptVolume(
    UINT uiWaveID,
    UINT *puiVolume
    );

HRESULT
DirectGetRendVolume(
    UINT uiWaveID,
    UINT *puiVolume    
    );

#if 0

HRESULT
DirectSetCaptVolume(    
    UINT uiWaveID,
    DOUBLE dVolume
    );

HRESULT
DirectSetCaptMute(
    UINT uiWaveID,
    BOOL fMute
    );

HRESULT
DirectGetCaptMute(
    UINT uiWaveID,
    BOOL *pfMute
    );
#endif // 0

#endif // _UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\testmix\walkmix.cpp ===
/*++

File:

    walkmix.cpp

Abstract:

    Implements class for walking through mixer api.

--*/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "walkmix.h"

char * GetCompTypeName(DWORD dwCompType);
char * GetControlTypeName(DWORD dwControlType);
char * GetControlClassName(DWORD dwControlID);

HRESULT
CWalkMix::Initialize()
{
    ZeroMemory(this, sizeof(CWalkMix));

    return NOERROR;
}

VOID
CWalkMix::Shutdown()
{
    if (m_hMixer != NULL)
    {
        mixerClose(m_hMixer);
    }

    ZeroMemory(this, sizeof(CWalkMix));
}

//
// manipulate device
//

HRESULT
CWalkMix::GetDeviceList()
{
    //Assert(m_hMixer == 0);

    // get device number
    m_uiDeviceNum = mixerGetNumDevs();

    if (m_uiDeviceNum == 0)
    {
        puts("No Device available");

        return E_FAIL;
    }

    // get device caps
    MMRESULT mmr;

    for (UINT i=0; i<m_uiDeviceNum; i++)
    {
        mmr = mixerGetDevCaps(i, &m_MixerCaps[i], sizeof(MIXERCAPS));

        if (mmr != MMSYSERR_NOERROR)
        {
            m_uiDeviceNum = 0;

            return (HRESULT)mmr;
        }
    }   

    return NOERROR;
}

HRESULT
CWalkMix::PrintDeviceList()
{
    for (UINT i=0; i<m_uiDeviceNum; i++)
    {
        printf("%d - %s\n", i, m_MixerCaps[i].szPname);
        printf("ManufacturerID %u", m_MixerCaps[i].wMid);
        printf(", ProductID %u", m_MixerCaps[i].wPid);
        printf(", DriverVersion %u\n", m_MixerCaps[i].vDriverVersion);

        printf("Destinations# %d\n", m_MixerCaps[i].cDestinations);

        puts("");
    }

    return NOERROR;
}

BOOL
CWalkMix::SetCurrentDevice(UINT ui)
{
    // is index within the range?
    if (ui>=m_uiDeviceNum)
    {
        return FALSE;
    }

    // open device
    if (m_hMixer != NULL)
    {
        mixerClose(m_hMixer);
        m_hMixer = NULL;
    }

    MMRESULT mmr;

    mmr = mixerOpen(&m_hMixer, ui, 0, 0, MIXER_OBJECTF_MIXER);

    if (mmr != MMSYSERR_NOERROR)
    {
        printf("Error: mixerOpen(%d) %x", ui, mmr);

        return FALSE;
    }

    // remember current device
    m_uiDeviceCurrent = ui;

    // clean line structure
    m_uiLineNum = 0;
    m_uiLineCurrent = 0;

    return TRUE;
}

// manipulate line
HRESULT
CWalkMix::GetLineList()
{
    if (m_uiDeviceCurrent>=m_uiDeviceNum || m_hMixer==NULL)
    {
        return E_UNEXPECTED;
    }

    MMRESULT mmr;

    // for each destination
    for (UINT i=0; i<m_MixerCaps[m_uiDeviceCurrent].cDestinations; i++)
    {
        // get line info
        m_MixerLine[i].dwDestination = i;
        m_MixerLine[i].cbStruct = sizeof(MIXERLINE);

        mmr = mixerGetLineInfo((HMIXEROBJ)m_hMixer, &m_MixerLine[i],
            MIXER_GETLINEINFOF_DESTINATION
            );

        if (mmr != MMSYSERR_NOERROR)
        {
            printf("Error: mixerGetLineInfo(%d) %x", i, mmr);

            return (HRESULT)mmr;
        }

        // get line controls
        m_MixerLineControls[i].dwLineID = m_MixerLine[i].dwLineID;
        m_MixerLineControls[i].cbStruct = sizeof(MIXERLINECONTROLS);
        m_MixerLineControls[i].cControls = m_MixerLine[i].cControls;
        m_MixerLineControls[i].cbmxctrl = sizeof(MIXERCONTROL);
        m_MixerLineControls[i].pamxctrl = m_MixerControl[i];

        mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &m_MixerLineControls[i],
            MIXER_GETLINECONTROLSF_ALL
            );

        if (mmr != MMSYSERR_NOERROR)
        {
            printf("Error: mixerGetLineControls(%d) %x\n", i, mmr);

            ZeroMemory(&m_MixerLineControls[i], sizeof(MIXERLINECONTROLS));
            //return (HRESULT)mmr;
        }

        // ignore control detail for now
    }

    m_uiLineNum = m_MixerCaps[m_uiDeviceCurrent].cDestinations;
    m_uiLineCurrent = 0;


    return NOERROR;
}

HRESULT
CWalkMix::PrintLineList()
{
    for (UINT i=0; i<m_uiLineNum; i++)
    {
        printf("    %d Line - %s (%s)\n",
                i,
                m_MixerLine[i].szShortName, m_MixerLine[i].szName);

        printf("    Src %d - Dest %d, LineID %u, CompType %s (%d)\n",
                m_MixerLine[i].dwSource, m_MixerLine[i].dwDestination,
                m_MixerLine[i].dwLineID,
                GetCompTypeName(m_MixerLine[i].dwComponentType),
                m_MixerLine[i].dwComponentType);

        printf("    Channels # %d, Connections# %d, Controls# %d\n",
                m_MixerLine[i].cChannels, m_MixerLine[i].cConnections,
                m_MixerLine[i].cControls);

        puts("");

        // print control
        for (UINT j=0; j<m_MixerLineControls[i].cControls; j++)
        {
            printf("        Control - %s (%s)\n",
                    m_MixerControl[i][j].szShortName, m_MixerControl[i][j].szName);

            printf ("        Multiple %d, Control Class %s (%d) Type %s (%d)\n",
                    m_MixerControl[i][j].cMultipleItems,
                    GetControlClassName(m_MixerControl[i][j].dwControlID),
                    m_MixerControl[i][j].dwControlID,
                    GetControlTypeName(m_MixerControl[i][j].dwControlType),
                    m_MixerControl[i][j].dwControlType);

            puts("");
        }
    }

    return NOERROR;
}

BOOL
CWalkMix::SetCurrentLine(UINT ui)
{
    // is index within the range?
    if (m_uiDeviceCurrent>=m_uiDeviceNum)
    {
        return FALSE;
    }

    if (ui>=m_uiLineNum)
    {
        return FALSE;
    }

    m_uiLineCurrent = ui;

    return TRUE;
}

int _cdecl main()
{
    HRESULT hr;
    CWalkMix obj;

    obj.Initialize();

    hr = obj.GetDeviceList();

    if (FAILED(hr))
    {
        printf("Error: GetDeviceList %x\n", hr);

        return 0;
    }

    // user input
    char cDevice, cLine, c;

    while (TRUE)
    {
        // display device list
        hr = obj.PrintDeviceList();

        if (FAILED(hr))
        {
            printf("Error: PrintDeviceList %x\n", hr);

            return 0;
        }

        // ask user selection
        puts("");
        puts("<0-9:Select device. r:Return. e:Exit. others:Ignore>");

        printf("Option:");
        scanf("%c", &cDevice);
        scanf("%c", &c);

        // check selection
        if (cDevice == 'e')
        {
            obj.Shutdown();

            return 1;
        }

        if (cDevice == 'r')
            break;

        if (cDevice<'0' || cDevice>'9')
            continue;

        if (!obj.SetCurrentDevice((UINT)(cDevice-'0')))
        {
            // invalid device number
            continue;
        }

        // get line info
        hr = obj.GetLineList();

        if (FAILED(hr))
        {
            printf("Error: GetLineList %x\n", hr);

            continue;
        }

        while (TRUE)
        {
            // display line list
            printf("\n\n");
            hr = obj.PrintLineList();

            if (FAILED(hr))
            {
                printf("Error: printLineList %x\n", hr);

                break;
            }

            // ask user selection
            puts("");
            puts("<0-9:Select line. r:Return. e:Exit. others:Ignore>");
            printf("Option:");
            scanf("%c", &cLine);
            scanf("%c", &c);

            // check selection
            if (cLine == 'e')
            {
                obj.Shutdown();

                return 1;
            }

            if (cLine == 'r')
                break;

            if (cLine<'0' || cLine>'9')
                continue;

            if (!obj.SetCurrentLine((UINT)(cLine-'0')))
            {
                // invalid line number
                continue;
            }

            // get source line
            printf("\n\n");
            hr = obj.GetSrcLineList();

            if (FAILED(hr))
            {
                printf("Error: GetSrcLineList %x\n", hr);

                continue;
            }

            // display src line list
            hr = obj.PrintSrcLineList();

            if (FAILED(hr))
            {
                printf("Error: PrintSrcLineList %x\n", hr);
            }

            printf("Return");
            scanf("%c", &c);
        } // of while
    } // of while

    obj.Shutdown();

    return 1;
}

HRESULT
CWalkMix::GetSrcLineList()
{
    if (m_uiDeviceCurrent>=m_uiDeviceNum ||
        m_hMixer==NULL ||
        m_uiLineCurrent>=m_uiLineNum)
    {
        return E_UNEXPECTED;
    }

    MMRESULT mmr;

    // for each connection
    for (UINT i=0; i<m_MixerLine[m_uiLineCurrent].cConnections; i++)
    {
        // get line info
        m_SrcMixerLine[i].dwDestination = m_MixerLine[m_uiLineCurrent].dwDestination;
        m_SrcMixerLine[i].dwSource = i;
        m_SrcMixerLine[i].cbStruct = sizeof(MIXERLINE);

        mmr = mixerGetLineInfo((HMIXEROBJ)m_hMixer, &m_SrcMixerLine[i],
            MIXER_GETLINEINFOF_SOURCE
            );

        if (mmr != MMSYSERR_NOERROR)
        {
            printf("Error: mixerGetLineInfo(%d) %x", i, mmr);

            return (HRESULT)mmr;
        }

        // get line controls
        m_SrcMixerLineControls[i].dwLineID = m_SrcMixerLine[i].dwLineID;
        m_SrcMixerLineControls[i].cbStruct = sizeof(MIXERLINECONTROLS);
        m_SrcMixerLineControls[i].cControls = m_SrcMixerLine[i].cControls;
        m_SrcMixerLineControls[i].cbmxctrl = sizeof(MIXERCONTROL);
        m_SrcMixerLineControls[i].pamxctrl = m_SrcMixerControl[i];

        mmr = mixerGetLineControls((HMIXEROBJ)m_hMixer, &m_SrcMixerLineControls[i],
            MIXER_GETLINECONTROLSF_ALL
            );

        if (mmr != MMSYSERR_NOERROR)
        {
            printf("Error: mixerGetLineControls(%d) %x\n", i, mmr);

            ZeroMemory(&m_SrcMixerLineControls[i], sizeof(MIXERLINECONTROLS));
        }

        // ignore control detail for now
    }

    m_uiSrcLineNum = m_MixerLine[m_uiLineCurrent].cConnections;

    return NOERROR;
}

HRESULT
CWalkMix::PrintSrcLineList()
{
    for (UINT i=0; i<m_uiSrcLineNum; i++)
    {
        printf("++    %d Line - %s (%s)\n",
                i,
                m_SrcMixerLine[i].szShortName, m_SrcMixerLine[i].szName);

        printf("++    Src %d - Dest %d, LineID %u, CompType %s (%d)\n",
                m_SrcMixerLine[i].dwSource, m_SrcMixerLine[i].dwDestination,
                m_SrcMixerLine[i].dwLineID,
                GetCompTypeName(m_SrcMixerLine[i].dwComponentType),
                m_SrcMixerLine[i].dwComponentType);

        printf("++    Channels # %d, Connections# %d, Controls# %d\n",
                m_SrcMixerLine[i].cChannels, m_SrcMixerLine[i].cConnections,
                m_SrcMixerLine[i].cControls);

        puts("");

        // print control
        for (UINT j=0; j<m_SrcMixerLineControls[i].cControls; j++)
        {
            printf("++        Control - %s (%s)\n",
                    m_SrcMixerControl[i][j].szShortName, m_SrcMixerControl[i][j].szName);

            printf ("++        Multiple %d, Control Class %s (%d) Type %s (%d)\n",
                    m_SrcMixerControl[i][j].cMultipleItems,
                    GetControlClassName(m_SrcMixerControl[i][j].dwControlID),
                    m_SrcMixerControl[i][j].dwControlID,
                    GetControlTypeName(m_SrcMixerControl[i][j].dwControlType),
                    m_SrcMixerControl[i][j].dwControlType);

            puts("");
        }
    }

    return NOERROR;
}

char *
GetCompTypeName(DWORD dwCompType)
{
    switch (dwCompType)
    {
    case MIXERLINE_COMPONENTTYPE_DST_UNDEFINED:
        return "DST_UNDEFINED";
    case MIXERLINE_COMPONENTTYPE_DST_DIGITAL:
        return "DST_DIGITAL";
    case MIXERLINE_COMPONENTTYPE_DST_LINE:
        return "DST_LINE";
    case MIXERLINE_COMPONENTTYPE_DST_MONITOR:
        return "DST_MONITOR";
    case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
        return "DST_SPEAKERS";
    case MIXERLINE_COMPONENTTYPE_DST_HEADPHONES:
        return "DST_HEADPHONES";
    case MIXERLINE_COMPONENTTYPE_DST_TELEPHONE:
        return "DST_TELEPHONE";
    case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
        return "DST_WAVEIN";
    case MIXERLINE_COMPONENTTYPE_DST_VOICEIN:
        return "DST_VOICEIN";

    case MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED:
        return "SRC_UNDEFINED";
    case MIXERLINE_COMPONENTTYPE_SRC_DIGITAL:
        return "SRC_DIGITAL";
    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
        return "SRC_LINE";
    case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
        return "SRC_MICROPHONE";
    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
        return "SRC_SYNTHESIZER";
    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
        return "SRC_COMPACTDISC";
    case MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE:
        return "SRC_TELEPHONE";
    case MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER:
        return "SRC_PCSPEAKER";
    case MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT:
        return "SRC_WAVEOUT";
    case MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY:
        return "SRC_AUXILIARY";
    case MIXERLINE_COMPONENTTYPE_SRC_ANALOG:
        return "SRC_ANALOG";

    default:
        return "Unknown";
    }
}

char *
GetControlClassName(DWORD dwControlID)
{
    switch (dwControlID)
    {
    case MIXERCONTROL_CT_CLASS_MASK:
        return "MASK";
    case MIXERCONTROL_CT_CLASS_CUSTOM:
        return "CUSTOM";
    case MIXERCONTROL_CT_CLASS_METER:
        return "METER";
    case MIXERCONTROL_CT_CLASS_SWITCH:
        return "SWITCH";
    case MIXERCONTROL_CT_CLASS_NUMBER:
        return "NUMBER";
    case MIXERCONTROL_CT_CLASS_SLIDER:
        return "SLIDER";
    case MIXERCONTROL_CT_CLASS_FADER:
        return "FADER";
    case MIXERCONTROL_CT_CLASS_TIME:
        return "TIME";
    case MIXERCONTROL_CT_CLASS_LIST:
        return "LIST";

    default:
        return "Unknown";
    }
}

char *
GetControlTypeName(DWORD dwControlType)
{
    switch (dwControlType)
    {
    case MIXERCONTROL_CONTROLTYPE_CUSTOM:
        return "CUSTOM";
    case MIXERCONTROL_CONTROLTYPE_BOOLEANMETER:
        return "BOOLEANMETER";
    case MIXERCONTROL_CONTROLTYPE_SIGNEDMETER:
        return "SIGNEDMETER";
    case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
        return "PEAKMETER";
    case MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER:
        return "UNSIGNEDMETER";
    case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
        return "BOOLEAN";
    case MIXERCONTROL_CONTROLTYPE_ONOFF:
        return "ONOFF";
    case MIXERCONTROL_CONTROLTYPE_MUTE:
        return "MUTE";
    case MIXERCONTROL_CONTROLTYPE_MONO:
        return "MONO";
    case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
        return "LOUDNESS";
    case MIXERCONTROL_CONTROLTYPE_STEREOENH:
        return "STEREOENH";
    case MIXERCONTROL_CONTROLTYPE_BASS_BOOST:
        return "BASS_BOOST";
    case MIXERCONTROL_CONTROLTYPE_BUTTON:
        return "BUTTON";
    case MIXERCONTROL_CONTROLTYPE_DECIBELS:
        return "DECIBELS";
    case MIXERCONTROL_CONTROLTYPE_SIGNED:
        return "SIGNED";
    case MIXERCONTROL_CONTROLTYPE_UNSIGNED:
        return "UNSIGNED";
    case MIXERCONTROL_CONTROLTYPE_PERCENT:
        return "PERCENT";
    case MIXERCONTROL_CONTROLTYPE_SLIDER:
        return "SLIDER";
    case MIXERCONTROL_CONTROLTYPE_PAN:
        return "PAN";
    case MIXERCONTROL_CONTROLTYPE_QSOUNDPAN:
        return "QSOUNDPAN";
    case MIXERCONTROL_CONTROLTYPE_FADER:
        return "FADER";
    case MIXERCONTROL_CONTROLTYPE_VOLUME:
        return "VOLUME";
    case MIXERCONTROL_CONTROLTYPE_BASS:
        return "BASS";
    case MIXERCONTROL_CONTROLTYPE_TREBLE:
        return "TREBLE";
    case MIXERCONTROL_CONTROLTYPE_EQUALIZER:
        return "EQUALIZER";
    case MIXERCONTROL_CONTROLTYPE_SINGLESELECT:
        return "SINGLESELECT";
    case MIXERCONTROL_CONTROLTYPE_MUX:
        return "MUX";
    case MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT:
        return "MULTIPLESELECT";
    case MIXERCONTROL_CONTROLTYPE_MIXER:
        return "MIXER";
    case MIXERCONTROL_CONTROLTYPE_MICROTIME:
        return "MICROTIME";
    case MIXERCONTROL_CONTROLTYPE_MILLITIME:
        return "MILLITIME";

    default:
        return "Unknown";

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\coresink.h ===
// coresink.h : header file for the COM object implementing
//  the IRTCEventNotification interface

#pragma once

#include "stdafx.h"

class ATL_NO_VTABLE CRTCCoreNotifySink :
	public CComObjectRootEx<CComSingleThreadModel>,
    public IRTCEventNotification

{
public:
    CRTCCoreNotifySink()
    {
        m_dwCookie = 0;
        m_bConnected = FALSE;
    }

    ~CRTCCoreNotifySink()
    {
        ATLASSERT(!m_bConnected);
    }


DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCCoreNotifySink)
	COM_INTERFACE_ENTRY(IRTCEventNotification)
END_COM_MAP()

    // IRTCEventNotification
    STDMETHOD(Event)(RTC_EVENT enEvent, IDispatch * pEvent);

    HRESULT   AdviseControl(IUnknown *, CWindow *);
    HRESULT   UnadviseControl(void);

private:

    DWORD       m_dwCookie;
    BOOL        m_bConnected;
    CComPtr<IUnknown>
                m_pSource;
    CWindow     m_hTargetWindow;

};

extern CComObjectGlobal<CRTCCoreNotifySink> g_CoreNotifySink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\err.h ===
// err.h : Declaration of the CErrorMessageLiteDlg

#ifndef __ERR_H_
#define __ERR_H_

struct CShareErrorInfo
{
	LPWSTR		Message1;
	LPWSTR		Message2;
	LPWSTR		Message3;

	HICON		ResIcon;

    CShareErrorInfo()
    {
        Message1= NULL;
        Message2= NULL;
        Message3= NULL;
        ResIcon = NULL;
    }
    
    virtual ~CShareErrorInfo()
    {

#define RTC_FREE_NULLIFY(p) if(p) { RtcFree(p); p = NULL; }

        RTC_FREE_NULLIFY( Message1 );
        RTC_FREE_NULLIFY( Message2 );
        RTC_FREE_NULLIFY( Message3 );

#undef RTC_FREE_NULLIFY

    }
};

/////////////////////////////////////////////////////////////////////////////
// CErrorMessageLiteDlg

class CErrorMessageLiteDlg : 
    public CAxDialogImpl<CErrorMessageLiteDlg>
{

public:
    CErrorMessageLiteDlg();

    ~CErrorMessageLiteDlg();
    
    enum { IDD = IDD_DIALOG_ERROR_MESSAGE_LITE };

BEGIN_MSG_MAP(CErrorMessageLiteDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDOK, OnOk)
END_MSG_MAP()


    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

};

#endif //__ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\coresink.cpp ===
// Ctlsink.cpp : Implementation of CRTCCoreNotifySink
#include "stdafx.h"
#include "coresink.h"

CComObjectGlobal<CRTCCoreNotifySink> g_CoreNotifySink;

/////////////////////////////////////////////////////////////////////////////
//
//

STDMETHODIMP CRTCCoreNotifySink::Event(RTC_EVENT enEvent, IDispatch * pEvent)
{
    //LOG((RTC_TRACE, "CRTCCoreNotifySink::Event - enter"));

    m_hTargetWindow.SendMessage(WM_CORE_EVENT, (WPARAM)enEvent, (LPARAM)pEvent);
    
    //LOG((RTC_TRACE, "CRTCCoreNotifySink::Event - exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CRTCCoreNotifySink::AdviseControl(IUnknown *pCoreIntf, CWindow *pTarget)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCCoreNotifySink::AdviseControl - enter"));

    ATLASSERT(!m_bConnected);
    ATLASSERT(pCoreIntf);

    hr = AtlAdvise(pCoreIntf, this, IID_IRTCEventNotification, &m_dwCookie);

    if(SUCCEEDED(hr))
    {
        m_bConnected = TRUE;
        m_pSource = pCoreIntf;
        m_hTargetWindow = *pTarget;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCCoreNotifySink::AdviseControl - AtlAdvise failed 0x%lx", hr));
    }

    LOG((RTC_TRACE, "CRTCCoreNotifySink::AdviseControl - exit"));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT  CRTCCoreNotifySink::UnadviseControl(void)
{
    HRESULT hr;

    LOG((RTC_TRACE, "CRTCCoreNotifySink::UnadviseControl - enter"));

    if(m_bConnected)
    {
        hr = AtlUnadvise(m_pSource, IID_IRTCEventNotification, m_dwCookie);
        if(SUCCEEDED(hr))
        {
            m_bConnected = FALSE;
            m_pSource.Release();
        }
    }
    else
    {
        hr = S_OK;
    }

    LOG((RTC_TRACE, "CRTCCoreNotifySink::UnadviseControl - exit"));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\err.cpp ===
//
// err.cpp : Implementation of CErrorMessageLiteDlg
//

#include "stdafx.h"
#include "err.h"

////////////////////////////////////////
//

CErrorMessageLiteDlg::CErrorMessageLiteDlg()
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::CErrorMessageLiteDlg"));
}


////////////////////////////////////////
//

CErrorMessageLiteDlg::~CErrorMessageLiteDlg()
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::~CErrorMessageLiteDlg"));
}


////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnInitDialog - enter"));

    // LPARAM contains a pointer to an CShareErrorInfo structure
    CShareErrorInfo    *pInfo = (CShareErrorInfo *)lParam;

    ATLASSERT(pInfo);

    SetDlgItemText(IDC_EDIT_MSG1, pInfo->Message1 ? pInfo->Message1 : _T(""));
    SetDlgItemText(IDC_EDIT_MSG2, pInfo->Message2 ? pInfo->Message2 : _T(""));
    SetDlgItemText(IDC_EDIT_MSG3, pInfo->Message3 ? pInfo->Message3 : _T(""));

    SendDlgItemMessage(IDC_STATIC_MSG_ICON,
                       STM_SETIMAGE,
                       IMAGE_ICON,
                       (LPARAM)pInfo->ResIcon);

    // Title
    TCHAR   szTitle[0x80];

    szTitle[0] = _T('\0');
    LoadString(
        _Module.GetResourceInstance(),
        IDS_APPNAME,
        szTitle,
        sizeof(szTitle)/sizeof(szTitle[0]));

    SetWindowText(szTitle);

    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnInitDialog - exit"));
    
    return 1;
}
    

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnDestroy - enter"));

    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnDestroy - exit"));
    
    return 0;
}
    

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnCancel - enter"));
    
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnCancel - exiting"));
   
    EndDialog(wID);
    return 0;
}

////////////////////////////////////////
//

LRESULT CErrorMessageLiteDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnOk - enter"));
    
    LOG((RTC_TRACE, "CErrorMessageLiteDlg::OnOk - exiting"));
    
    EndDialog(wID);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\msgrsink.cpp ===
// msgrsink.cpp : Implementation of CRTCMsgrSessionNotifySink
//  and Implementation of CRTCMsgrSessionMgrNotifySink

#include "stdafx.h"
#include "msgrsink.h"
#include "mdispid.h"

CComObjectGlobal<CRTCMsgrSessionNotifySink> g_MsgrSessionNotifySink;

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CRTCMsgrSessionNotifySink::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
                                          DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, PUINT puArgErr)
{
    switch (dispIdMember)
    {
    case DISPID_ONSTATECHANGED:
        ATLASSERT(1 == pDispParams->cArgs);
        ATLASSERT(VT_I4 == pDispParams->rgvarg[0].vt);
        
        OnStateChanged((SESSION_STATE)pDispParams->rgvarg[0].lVal);
        break;
        
    case DISPID_ONAPPNOTPRESENT:
        ATLASSERT(2 == pDispParams->cArgs);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[0].vt);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[1].vt);
        
        OnAppNotPresent(pDispParams->rgvarg[0].bstrVal, pDispParams->rgvarg[1].bstrVal);
        break;
        
    case DISPID_ONACCEPTED:
        ATLASSERT(1 == pDispParams->cArgs);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[0].vt);
        
        OnAccepted(pDispParams->rgvarg[0].bstrVal);
        break;
        
    case DISPID_ONDECLINED:
        ATLASSERT(1 == pDispParams->cArgs);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[0].vt);
        
        OnDeclined(pDispParams->rgvarg[0].bstrVal);
        break;
        
    case DISPID_ONCANCELLED:
        ATLASSERT(1 == pDispParams->cArgs);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[0].vt);
        
        OnCancelled(pDispParams->rgvarg[0].bstrVal);
        break;
        
    case DISPID_ONTERMINATION:
        ATLASSERT(2 == pDispParams->cArgs);
        ATLASSERT(VT_I4 == pDispParams->rgvarg[0].vt);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[1].vt);
        
        OnTermination(pDispParams->rgvarg[0].lVal, pDispParams->rgvarg[1].bstrVal);
        break;
        
    case DISPID_ONREADYTOLAUNCH:
        ATLASSERT(0 == pDispParams->cArgs);
        
        OnReadyToLaunch();
        break;
        
    case DISPID_ONCONTEXTDATA:
        ATLASSERT(1 == pDispParams->cArgs);
        ATLASSERT(VT_BSTR == pDispParams->rgvarg[0].vt);
        
        OnContextData(pDispParams->rgvarg[0].bstrVal);
        break;
        
    case DISPID_ONSENDERROR:
        ATLASSERT(1 == pDispParams->cArgs);
        ATLASSERT(VT_I4 == pDispParams->rgvarg[0].vt);
        
        OnSendError(pDispParams->rgvarg[0].vt);
        break;
        
    default:
        LOG((RTC_WARN, "CRTCMsgrSessionNotifySink::Invoke - unknown dispid: %d", dispIdMember));
        break;
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnStateChanged(SESSION_STATE prevState)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnStateChanged"));
    
    LOG((RTC_INFO, "    prevState = %d", prevState));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnAppNotPresent(BSTR bstrAppName, BSTR bstrAppURL)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnAppNotPresent"));
    
    LOG((RTC_INFO, "    bstrAppName = %ws", bstrAppName));
    LOG((RTC_INFO, "    bstrAppURL = %ws", bstrAppURL));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnAccepted(BSTR bstrAppData)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnAccepted"));
    
    LOG((RTC_INFO, "    bstrAppData = %ws", bstrAppData));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnDeclined(BSTR bstrAppData)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnDeclined"));
    
    LOG((RTC_INFO, "   bstrAppData = %ws", bstrAppData));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnCancelled(BSTR bstrAppData)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnCancelled"));
    
    LOG((RTC_INFO, "   bstrAppData = %ws", bstrAppData));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnTermination(long hr, BSTR bstrAppData)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnTermination"));
    
    LOG((RTC_INFO, "    hr = 0x%lx", hr));
    LOG((RTC_INFO, "    bstrAppData = %ws", bstrAppData));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnReadyToLaunch()
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnReadyToLaunch"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnContextData(BSTR bstrContextData)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnContextData"));
    
    LOG((RTC_INFO, "    bstrContextData = %ws", bstrContextData));
    
    PostMessage(m_hTargetWindow, WM_CONTEXTDATA, NULL, NULL);
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionNotifySink::OnSendError(long hr)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnSendError"));
    
    LOG((RTC_INFO, "    hr = 0x%lx", hr));
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CRTCMsgrSessionNotifySink::AdviseControl(IMsgrSession *pMsgrSessionIntf, CWindow *pTarget)
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::AdviseControl - enter"));
    
    ATLASSERT(!m_bConnected);
    ATLASSERT(pMsgrSessionIntf);
    
    hr = AtlAdvise(pMsgrSessionIntf, this, DIID_DMsgrSessionEvents, &m_dwCookie);
    
    if(SUCCEEDED(hr))
    {
        m_bConnected = TRUE;
        m_pSource = pMsgrSessionIntf;
        m_hTargetWindow = *pTarget;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCMsgrSessionNotifySink::AdviseControl - AtlAdvise failed 0x%lx", hr));
    }
    
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::AdviseControl - exit"));
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT  CRTCMsgrSessionNotifySink::UnadviseControl(void)
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::UnadviseControl - enter"));
    
    if(m_bConnected)
    {
        hr = AtlUnadvise(m_pSource, DIID_DMsgrSessionEvents, m_dwCookie);
        if(SUCCEEDED(hr))
        {
            m_bConnected = FALSE;
            m_pSource.Release();
        }
    }
    else
    {
        hr = S_OK;
    }
    
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::UnadviseControl - exit"));
    
    return hr;
}


/*******************************************************************
*
* Implementation of CRTCMsgrSessionMgrNotifySink
*
******************************************************************/

CComObjectGlobal<CRTCMsgrSessionMgrNotifySink> g_MsgrSessionMgrNotifySink;

HRESULT PWSTR_to_PST(PSTR *ppsz, LPWSTR pwstr);

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CRTCMsgrSessionMgrNotifySink::Invoke(   
                                             DISPID dispidMember,
                                             const IID& iid,
                                             LCID ,          // Localization is not supported.
                                             WORD wFlags,
                                             DISPPARAMS* pDispParams,
                                             VARIANT* pvarResult,
                                             EXCEPINFO* pExcepInfo,
                                             UINT* pArgErr)
{
    HRESULT		hr=E_FAIL;
    HRESULT     hrRet=E_FAIL;
    
    _ASSERTE(iid == IID_NULL);
    
    switch (dispidMember) 
    {
    case DISPID_ONINVITATION:
        _ASSERTE(pDispParams->cArgs == 3);
        _ASSERTE(pDispParams->rgvarg[2].vt == VT_DISPATCH);	// pSession
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_BSTR);		// bstrAppData
        _ASSERTE(pDispParams->rgvarg[0].vt == (VT_BOOL | VT_BYREF));// pfHandled
        
        OnInvitation( pDispParams->rgvarg[2].pdispVal,
            pDispParams->rgvarg[1].bstrVal,
            &(pDispParams->rgvarg[0].boolVal) );
        break;
        
    case DISPID_ONAPPREGISTERED:
        _ASSERTE(pDispParams->cArgs == 1);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_BSTR);		// bstrAppGUID
        
        OnAppRegistered(pDispParams->rgvarg[0].bstrVal);
        break;
        
    case DISPID_ONAPPUNREGISTERED:
        _ASSERTE(pDispParams->cArgs == 1);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_BSTR);		// bstrAppGUID
        
        OnAppUnRegistered(pDispParams->rgvarg[0].bstrVal);
        break;
        
    case DISPID_ONLOCKCHALLENGE:
        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_BSTR);		// bstrChallenge
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);		// lCookie
        
        OnLockChallenge( pDispParams->rgvarg[0].bstrVal,pDispParams->rgvarg[1].lVal);
        break;
        
    case DISPID_ONLOCKRESULT:
        _ASSERTE(pDispParams->cArgs == 2);
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_BOOL);		// fSucceed
        _ASSERTE(pDispParams->rgvarg[1].vt == VT_I4);		// lCookie
        
        OnLockResult(pDispParams->rgvarg[0].boolVal,pDispParams->rgvarg[1].lVal);
        break;
        
    case DISPID_ONLOCKENABLE:
        _ASSERTE(pDispParams->cArgs == 1);	
        _ASSERTE(pDispParams->rgvarg[0].vt == VT_BOOL);		// fEnable
        
        OnLockEnable(pDispParams->rgvarg[0].boolVal);
        break;
        
    case DISPID_ONAPPSHUTDOWN:
        _ASSERTE(pDispParams->cArgs == 0);
        
        OnAppShutdown();
        break;
        
    default:
        LOG((RTC_WARN,"CRTCMsgrSessionMgrNotifySink::Invoke- "
            "got unknown Event from COM object: %d\r\n", dispidMember));
        break;		
    }
    
    return NOERROR;
}




/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CRTCMsgrSessionMgrNotifySink::AdviseControl(
                                                    IMsgrSessionManager *pMsgrSessionManagerIntf, 
                                                    CWindow *pTarget)
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::AdviseControl - enter"));
    
    ATLASSERT(!m_bConnected);
    ATLASSERT(pMsgrSessionManagerIntf);
    
    hr = AtlAdvise(pMsgrSessionManagerIntf, this, DIID_DMsgrSessionManagerEvents, &m_dwCookie);
    
    if(SUCCEEDED(hr))
    {
        m_bConnected = TRUE;
        m_pSource = pMsgrSessionManagerIntf;
        m_hTargetWindow = *pTarget;
    }
    else
    {
        LOG((RTC_ERROR, "CRTCMsgrSessionMgrNotifySink::AdviseControl - AtlAdvise failed 0x%lx", hr));
    }
    
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::AdviseControl - exit"));
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT  CRTCMsgrSessionMgrNotifySink::UnadviseControl(void)
{
    HRESULT hr=E_FAIL;
    
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::UnadviseControl - enter"));
    
    if(m_bConnected)
    {
        hr = AtlUnadvise(m_pSource, DIID_DMsgrSessionManagerEvents, m_dwCookie);
        if(SUCCEEDED(hr))
        {
            m_bConnected = FALSE;
            m_pSource.Release();
        }
    }
    else
    {
        hr = S_OK;
    }
    
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::UnadviseControl - exit"));
    
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnInvitation(IDispatch *pSession,
                                                BSTR bstrAppData,
                                                VARIANT_BOOL *pfHandled)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionNotifySink::OnInvitation"));
    
    LOG((RTC_INFO, "CRTCMsgrSessionNotifySink::OnInvitation -"
        "pSession=%x,bstrAppData=%S,*pfHandled=%d", pSession,bstrAppData,*pfHandled));        
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnAppRegistered(BSTR bstrAppGUID)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::OnAppRegistered"));
    
    LOG((RTC_INFO, "CRTCMsgrSessionMgrNotifySink::OnAppRegistered -"
        "bstrAppGUID =%S ", bstrAppGUID));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnAppUnRegistered(BSTR bstrAppGUID)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::OnAppUnRegistered"));
    
    LOG((RTC_INFO, "CRTCMsgrSessionMgrNotifySink::OnAppUnRegistered, bstrAppGUID= %S", bstrAppGUID));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnLockChallenge(BSTR bstrChallenge,long lCookie)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::OnLockChallenge"));
    
    if( lCookie !=0 )
    {
        LOG((RTC_ERROR, "CRTCMsgrSessionMgrNotifySink::OnLockChallenge-"
            " does not look like my cookie, it is=%d", lCookie));
    }
    
    ATLASSERT(g_pShareWin);
    ATLASSERT(!g_pShareWin->m_pszChallenge);
    HRESULT hr = PWSTR_to_PST(&g_pShareWin->m_pszChallenge, bstrChallenge);
    if(FAILED(hr))
    {
        LOG((RTC_ERROR,"CRTCMsgrSessionMgrNotifySink::OnLockChallenge"
            "failed in PWSTR_to_PST"));

        g_pShareWin->showRetryDlg();
        return;
    }
    
    LOG((RTC_INFO,"CRTCMsgrSessionMgrNotifySink::OnLockChallenge-"
        "challenge =%s",g_pShareWin->m_pszChallenge));
    
    g_pShareWin->PostMessage( WM_GETCHALLENGE );
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnLockResult(VARIANT_BOOL fSucceed,long lCookie)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::OnLockResult"));
    
    if( fSucceed == VARIANT_TRUE )
    {
        LOG((RTC_INFO, "CRTCMsgrSessionMgrNotifySink::OnLockResult -"
            "lock&key succeeded, %x", lCookie));
        
        g_pShareWin->PostMessage( WM_MESSENGER_UNLOCKED );
    }
    else
    {
        g_pShareWin->showRetryDlg();

        LOG((RTC_ERROR, "CRTCMsgrSessionMgrNotifySink::OnLockResult -"
            "lock&key failed,cookie=%x", lCookie));
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnLockEnable(VARIANT_BOOL fEnable)
{
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::OnLockEnable"));
    
    LOG((RTC_INFO, "CRTCMsgrSessionMgrNotifySink::OnLockEnable -fEnable = 0x%lx", fEnable));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CRTCMsgrSessionMgrNotifySink::OnAppShutdown()	
{
    LOG((RTC_TRACE, "CRTCMsgrSessionMgrNotifySink::OnAppShutdown"));
    
}


/////////////////////////////////////////////////////////////////////////////
//
// helper function,  change a WPSTR to a PSTR, 
//  since we encrypt the challenge as PSTR.

HRESULT PWSTR_to_PST(PSTR *ppsz, LPWSTR pwstr)
{
    LPSTR psz = NULL;
    int i = 0;
    HRESULT hr;
    
    //check arguments
    if( IsBadStringPtr(pwstr,(UINT_PTR)-1) )
    {
        LOG((RTC_ERROR,"PWSTR_to_PST -bad pointer: pwstr=%x",pwstr));
        return E_POINTER;
    }
    
    if( IsBadWritePtr(ppsz, sizeof(PSTR) ) )
    {
        LOG((RTC_ERROR,"PWSTR_to_PST -bad pointer: ppsz=%x",ppsz));
        return E_POINTER;
    }
    
    // compute the length of the required PWSTR
    //
    i =  WideCharToMultiByte(CP_ACP, 0, pwstr, -1, NULL, 0, NULL, NULL);
    if (i <= 0)
    {
        LOG((RTC_ERROR,"PWSTR_to_PST -length<0!!, length=%d",i));
        return E_UNEXPECTED;
    };
    
    // allocate the Ansi str, +1 for terminating null
    //
    psz = (LPSTR) RtcAlloc(i+1);
    
    if (psz != NULL)
    {
        int length;
        length =WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pwstr, -1, psz, i, NULL, NULL);
        ATLASSERT(length==i);
        psz[i]='\0';
        *ppsz = psz;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    };
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\msgrsink.h ===
// msgrsink.h : header file for the COM object implementing
//  the DMsgrSessionEvents interface
// and the DMsgrSessionManagerEvents interface

#pragma once

#include "stdafx.h"

class ATL_NO_VTABLE CRTCMsgrSessionNotifySink :
	public CComObjectRootEx<CComSingleThreadModel>,
    //public IDispatchImpl<DMsgrSessionEvents, &DIID_DMsgrSessionEvents, &LIBID_MsgrSessionManager>
    public IDispatch
{
public:
    CRTCMsgrSessionNotifySink()
    {
        m_dwCookie = 0;
        m_bConnected = FALSE;
    }

    ~CRTCMsgrSessionNotifySink()
    {
        ATLASSERT(!m_bConnected);
    }


DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCMsgrSessionNotifySink)
    //COM_INTERFACE_ENTRY(DMsgrSessionEvents)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	//
	// IDispatch Methods
	//
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
		LCID lcid, DISPID* rgDispId) { return E_NOTIMPL; }
	STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) {return E_NOTIMPL; }
	STDMETHODIMP GetTypeInfoCount(PUINT pctinfo) {return E_NOTIMPL; }
	STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
		DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, PUINT puArgErr);

    //
    // DMsgrSessionEvents
    //
    void OnStateChanged(SESSION_STATE prevState);
    void OnAppNotPresent(BSTR bstrAppName, BSTR bstrAppURL);
    void OnAccepted(BSTR bstrAppData);
    void OnDeclined(BSTR bstrAppData);
    void OnCancelled(BSTR bstrAppData);
    void OnTermination(long hr, BSTR bstrAppData);
    void OnReadyToLaunch();
    void OnContextData(BSTR bstrContextData);
    void OnSendError(long hr);

    HRESULT   AdviseControl(IMsgrSession *, CWindow *);
    HRESULT   UnadviseControl(void);

private:

    DWORD       m_dwCookie;
    BOOL        m_bConnected;
    CComPtr<IUnknown>
                m_pSource;
    CWindow     m_hTargetWindow;

};

extern CComObjectGlobal<CRTCMsgrSessionNotifySink> g_MsgrSessionNotifySink;




////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CRTCMsgrSessionMgrNotifySink :
	public CComObjectRootEx<CComSingleThreadModel>,
    //public IDispatchImpl<DMsgrSessionManagerEvents, &DIID_DMsgrSessionManagerEvents, &LIBID_MsgrSessionManager>
    public IDispatch
{
public:
    CRTCMsgrSessionMgrNotifySink()
    {
        m_dwCookie = 0;
        m_bConnected = FALSE;
    }

    ~CRTCMsgrSessionMgrNotifySink()
    {
        ATLASSERT(!m_bConnected);
    }


DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCMsgrSessionMgrNotifySink)
    //COM_INTERFACE_ENTRY(DMsgrSessionManagerEvents)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	//
	// IDispatch Methods
	//
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
		LCID lcid, DISPID* rgDispId) { return E_NOTIMPL; }
	STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) {return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfoCount(PUINT pctinfo) {return E_NOTIMPL; }
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, PUINT puArgErr);
    
    //
    // DMsgrSessionManagerEvents
    //
    void OnInvitation(IDispatch *pSession,BSTR bstrAppData,VARIANT_BOOL *pfHandled);
    void OnAppRegistered(BSTR bstrAppGUID);
    void OnAppUnRegistered(BSTR bstrAppGUID);       
    void OnLockChallenge(BSTR bstrChallenge,long lCookie);
    void OnLockResult(VARIANT_BOOL fSucceed,long lCookie);
    void OnLockEnable(VARIANT_BOOL fEnable);
    void OnAppShutdown();	


    HRESULT   AdviseControl(IMsgrSessionManager *, CWindow *);
    HRESULT   UnadviseControl(void);

private:

    DWORD       m_dwCookie;
    BOOL        m_bConnected;
    CComPtr<IUnknown>
                m_pSource;
    CWindow     m_hTargetWindow;

};

extern CComObjectGlobal<CRTCMsgrSessionMgrNotifySink> g_MsgrSessionMgrNotifySink;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\media\testmix\walkmix.h ===
/*++

File:

    walkmix.h

Abstract:

    Defines class for walking through mixer api.

--*/

class CWalkMix
{
public:

    HRESULT Initialize();

    VOID Shutdown();

    // manipulate device
    HRESULT GetDeviceList();

    HRESULT PrintDeviceList();

    BOOL SetCurrentDevice(UINT ui);

    // manipulate line
    HRESULT GetLineList();

    HRESULT PrintLineList();

    BOOL SetCurrentLine(UINT ui);

    HRESULT GetSrcLineList();

    HRESULT PrintSrcLineList();

private:

    //
    // devices
    //
    static const UINT MAX_DEVICE_NUM = 16;

    UINT m_uiDeviceNum;

    // device info list
    MIXERCAPS m_MixerCaps[MAX_DEVICE_NUM];

    UINT m_uiDeviceCurrent;

    HMIXER m_hMixer;

    //
    // lines
    //
    static const UINT MAX_LINE_NUM = 16;

    // line info list
    MIXERLINE m_MixerLine[MAX_LINE_NUM];

    UINT m_uiLineNum;
    UINT m_uiLineCurrent;

    // controls
    static const UINT MAX_CONTROL_NUM = 16;

    MIXERLINECONTROLS m_MixerLineControls[MAX_LINE_NUM];

    MIXERCONTROL m_MixerControl[MAX_LINE_NUM][MAX_CONTROL_NUM];

    MIXERCONTROLDETAILS m_MixerControlDetails[MAX_LINE_NUM][MAX_CONTROL_NUM];

    // source lines

    MIXERLINE m_SrcMixerLine[MAX_LINE_NUM];

    UINT m_uiSrcLineNum;

    // controls
    MIXERLINECONTROLS m_SrcMixerLineControls[MAX_LINE_NUM];

    MIXERCONTROL m_SrcMixerControl[MAX_LINE_NUM][MAX_CONTROL_NUM];

    MIXERCONTROLDETAILS m_SrcMixerControlDetails[MAX_LINE_NUM][MAX_CONTROL_NUM];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\md5hash.cpp ===
//
// md5hash.cpp : Implementation get MD5 hash result
//

#include "stdafx.h"
#include <wincrypt.h>

#define KEY_CONTAINER   L"Microsoft.RTCContainer"

PWSTR base16encode(PBYTE pbBufInput, long nBytes);
BYTE* GetMD5Key(char* pszChallengeInfo, char* pszPassword);

/////////////////////////////////////////////////////////////////////////////
//
//GetMD5Result:
//  compute MD5 hash of szChallenge+szKey, put result in ppszResponse
//  with base16 encoding, and in WSTR
//

HRESULT  GetMD5Result(char * szChallenge, char * szKey, LPWSTR * ppszResponse)
{
#define CHECKBOOL(b,str)  \
    if(!(b))\
    {\
    dwError = GetLastError();\
    LOG((RTC_ERROR,"GetMD5Result-%s: err=%s",str,dwError));\
    hrRet = E_FAIL;\
    goto CLEANUP;\
    }

    //-------------------------------------------------------------
    // Declare and initialize variables.
    
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash=NULL;
    HRESULT    hrRet = E_FAIL;
    BYTE     * pbBuffer=NULL;
    DWORD   dwBufferLen = 0;
    BOOL    bResult = FALSE;
    
    DWORD   dwHashLen=0, dwCount=0;
    BYTE   *pbData=NULL;
    DWORD   dwError=0;
    PWSTR   pszStringValue = NULL;
    
    //check arguments
    CHECKBOOL(!IsBadStringPtrA(szChallenge,1000), "invalid szChallenge");
    CHECKBOOL(!IsBadStringPtrA(szKey,1000), "invalid szKey");
    CHECKBOOL(!IsBadWritePtr(ppszResponse, sizeof(LPWSTR)),"invalid ppszResponse");
    
    //concatenate szChallenge and szKey, save it into pbBuffer
    pbBuffer= GetMD5Key(szChallenge, szKey);
    CHECKBOOL( NULL != pbBuffer, "GetMD5Key returned null");
    
    dwBufferLen = lstrlenA((char *)pbBuffer);
    
    // delete any existing container
    CryptAcquireContext(
        &hProv,
        KEY_CONTAINER,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_DELETEKEYSET);
    
    //
    //--------------------------------------------------------------------
    // Acquire a CSP. 
    
    bResult = CryptAcquireContext(
        &hProv, 
        KEY_CONTAINER,
        MS_DEF_PROV,
        PROV_RSA_FULL,
        CRYPT_NEWKEYSET | CRYPT_SILENT);
    
    CHECKBOOL(bResult,"Error during CryptAcquireContext.");
    
    //--------------------------------------------------------------------
    // Create the hash object.
    
    bResult = CryptCreateHash(
        hProv, 
        CALG_MD5, 
        0, 
        0, 
        &hHash);
    
    CHECKBOOL(bResult,"Error during CryptCreateHash.");
    
    //--------------------------------------------------------------------
    // Compute the cryptographic hash of the buffer.
    
    bResult = CryptHashData(
        hHash, 
        pbBuffer, 
        dwBufferLen, 
        0);
    
    CHECKBOOL(bResult,"Error during CryptHashData.");
    
    //
    //Get the the hash value size
    //
    dwCount = sizeof(DWORD);
    bResult = CryptGetHashParam(hHash, HP_HASHSIZE,(BYTE*)&dwHashLen, &dwCount, NULL);
    
    CHECKBOOL(bResult,"CryptGetHashParam for size");    
    
    //
    //Allocate the memory
    //
    pbData = (BYTE*)RtcAlloc( dwHashLen);
    CHECKBOOL( (NULL != pbData) ,"Out of memory when allocate pbData");
    
    //
    //Get the the real hash value
    //    
    bResult = CryptGetHashParam(hHash, HP_HASHVAL , pbData,&dwHashLen, NULL);
    CHECKBOOL(bResult,"CryptGetHashParam for hash value");
    
    //Now we have the hash result in pbData, we still need to
    //Change it into base 16, unicode format
    pszStringValue = base16encode(pbData, dwHashLen);
    CHECKBOOL( NULL != pszStringValue, "NULL returned from base16encode");
    
    //Now everything ok, return S_OK
    *ppszResponse =  pszStringValue;    
    hrRet = S_OK;
    
CLEANUP:
    //
    // Destroy the hash object.
    //
    if(hHash) 
    {
        CryptDestroyHash(hHash);
    }
    
    if(hProv) 
    {
        CryptReleaseContext(hProv, 0);
    }
    
    if( pbData )
    {
        RtcFree( pbData );
    }
    
    if( pbBuffer )
    {
        RtcFree(pbBuffer);
    }
    return hrRet;
    
#undef CHECKBOOL
    
} //  End of GetMD5Result



/////////////////////////////////////////////////////////////////////////////
//base16encode - helper function for GetMD5Result
//



PWSTR base16encode(PBYTE pbBufInput, long nBytes)
{
    PBYTE pbHash = pbBufInput;
    PWSTR pbHexHash = NULL;

    const WCHAR rgchHexNumMap[] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };
    
    pbHexHash = (PWSTR) RtcAlloc( sizeof(WCHAR) * (nBytes * 2 + 1) );
    
    if (pbHexHash)
    {
        PWSTR pCurrent = pbHexHash;
        
        // Convert the hash data to hex string.
        for (int i = 0; i < nBytes; i++)
        {
            *pCurrent++ = rgchHexNumMap[pbHash[i]/16];
            *pCurrent++ = rgchHexNumMap[pbHash[i]%16];
        }
        
        *pCurrent = '\0';
    }
    else
    {
        LOG((RTC_ERROR, "base16encode - Out of memory"));
    }
    
    return pbHexHash;
}


/////////////////////////////////////////////////////////////////////////////
//  GetMD5Key: concatenate the two Ansi string into one Ansi String
//      - helper function for GetMD5Result

BYTE* GetMD5Key(char* pszChallengeInfo, char* pszPassword)
{
    HRESULT hr = E_FAIL;
    PBYTE pbData = NULL;
    
    //no check arguments since it is only used internally
    /*
    if(IsBadStringPtrA(pszChallengeInfo,(UINT_PTR)-1))
    {
        LOG((RTC_ERROR,"GetMD5Key-bad pointer pszChallengeInfo" ));
        return NULL;
    }
    
    if(IsBadStringPtrA(pszPassword,(UINT_PTR)-1))
    {
        LOG((RTC_ERROR,"GetMD5Key-bad pointer pszPassword" ));
        return NULL;
    }
    */
    
    int cbChallengeInfo = lstrlenA(pszChallengeInfo);
    int cbPassword = lstrlenA(pszPassword);
    
    pbData = (BYTE*) RtcAlloc(cbChallengeInfo + cbPassword + 1);
    if( NULL == pbData )
    {
        LOG((RTC_ERROR,"GetMD5Key-out of memory" ));
        return NULL;
    }
    
    PBYTE pCurrent = pbData;
    
    ::CopyMemory(pCurrent, pszChallengeInfo, cbChallengeInfo);
    pCurrent += cbChallengeInfo;
    ::CopyMemory(pCurrent, pszPassword, cbPassword);
    pCurrent += cbPassword;
    *pCurrent = '\0';
    
    return pbData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\shareimpl.h ===
// shareimpl.h : Declaration of the CRTCShare

#ifndef __RTCSHARE_H_
#define __RTCSHARE_H_

/////////////////////////////////////////////////////////////////////////////
// CRTCShare
//

class ATL_NO_VTABLE CRTCShare : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CRTCShare, &CLSID_RTCShare>,
    public IDispatchImpl<IRTCShare, &IID_IRTCShare, &LIBID_RTCSHARELib>
{
public:
    CRTCShare()
    {
    }

DECLARE_NO_REGISTRY()
DECLARE_CLASSFACTORY_SINGLETON(CRTCShare)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRTCShare)
    COM_INTERFACE_ENTRY(IRTCShare)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRTCShare
public:
    STDMETHOD(Launch)(long lPID);
    STDMETHOD(PlaceCall)(BSTR bstrURI);
    STDMETHOD(Listen)();
    STDMETHOD(OnTop)();    
};

#endif //__RTCSHARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\shareimpl.cpp ===
// shareimpl.cpp : Implementation of CRTCShare
#include "stdafx.h"

extern CShareWin * g_pShareWin;

/////////////////////////////////////////////////////////////////////////////
//
//

STDMETHODIMP CRTCShare::Launch(long lPID)
{
    LOG((RTC_TRACE, "CRTCShare::Launch - enter - lPID[%d]", lPID));

    PostMessage(g_pShareWin->m_hWnd, WM_LAUNCH, NULL, (LPARAM)lPID);

    LOG((RTC_TRACE, "CRTCShare::Launch - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

STDMETHODIMP CRTCShare::PlaceCall(BSTR bstrURI)
{
    LOG((RTC_TRACE, "CRTCShare::PlaceCall - enter - bstrURI[%ws]", bstrURI));

    BSTR bstrURICopy = SysAllocString(bstrURI);

    if ( bstrURICopy == NULL )
    {
        LOG((RTC_ERROR, "CRTCShare::PlaceCall - out of memory"));

        return E_OUTOFMEMORY;
    }

    PostMessage(g_pShareWin->m_hWnd, WM_PLACECALL, NULL, (LPARAM)bstrURICopy);

    LOG((RTC_TRACE, "CRTCShare::PlaceCall - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

STDMETHODIMP CRTCShare::Listen()
{
    LOG((RTC_TRACE, "CRTCShare::Listen - enter"));

    PostMessage(g_pShareWin->m_hWnd, WM_LISTEN, NULL, NULL);

    LOG((RTC_TRACE, "CRTCShare::Listen - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

STDMETHODIMP CRTCShare::OnTop()
{
    LOG((RTC_TRACE, "CRTCShare::OnTop - enter"));

    g_pShareWin->ShowWindow(SW_SHOW);
    g_pShareWin->ShowWindow(SW_RESTORE);
    
    LOG((RTC_TRACE, "CRTCShare::OnTop - exit"));
    
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\shareres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rtcshare.rc
//
#define IDS_APPNAME                     101
#define IDI_APPICON                     102
#define IDS_WAITING                     103
#define IDS_CONNECTING                  104
#define IDS_CONNECTED                   105
#define IDS_DISCONNECTED                106
#define IDS_SHUTDOWN                    107
#define IDS_WHITEBOARD                  108
#define IDS_APPSHARE                    109
#define IDS_APPURL                      110
#define IDS_INUSE_TEXT                  111
#define IDS_INUSE_CAPTION               112
#define ID_TOOLBAR                      113
#define IDM_SHARE                       114
#define IDM_WB                          115
#define IDM_CLOSE                       116
#define IDS_SHARE                       117
#define IDS_WB                          118
#define IDS_CLOSE                       119
#define IDB_TOOLBAR_HOT                 120
#define IDB_TOOLBAR_DISABLED            121
#define IDB_TOOLBAR_NORMAL              122
#define IDS_MB_SIPERROR_GENERIC_1       123
#define IDS_MB_SIPERROR_GENERIC_2       124
#define IDS_MB_HRERROR_APPS_DONT_MATCH_1 125
#define IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2 126
#define IDS_MB_SIPERROR_NOTFOUND_1      127
#define IDS_MB_SIPERROR_NOTFOUND_2      128
#define IDS_MB_SIPERROR_AUTH_FAILED_1   129
#define IDS_MB_SIPERROR_AUTH_FAILED_2   130
#define IDS_MB_SIPERROR_NOTANSWERING_1  131
#define IDS_MB_SIPERROR_NOTANSWERING_2  132
#define IDS_MB_SIPERROR_NOTAVAIL_1      133
#define IDS_MB_SIPERROR_NOTAVAIL_2      134
#define IDS_MB_SIPERROR_BUSY_1          135
#define IDS_MB_SIPERROR_BUSY_2          136
#define IDS_MB_SIPERROR_SERVER_PROBLEM_1 137
#define IDS_MB_SIPERROR_SERVER_PROBLEM_2 138
#define IDS_MB_SIPERROR_DECLINE_1       139
#define IDS_MB_SIPERROR_DECLINE_2       140
#define IDS_MB_DETAIL_SIP               141
#define IDS_MB_HRERROR_NOTFOUND_1       142
#define IDS_MB_HRERROR_NOTFOUND_2       143
#define IDS_MB_HRERROR_CLIENT_NOTRUNNING_1 144
#define IDS_MB_HRERROR_CLIENT_NOTRUNNING_2 145
#define IDS_MB_HRERROR_INVALIDADDRESS_1 146
#define IDS_MB_HRERROR_INVALIDADDRESS_2 147
#define IDS_MB_HRERROR_LOCAL_MACHINE_1  148
#define IDS_MB_HRERROR_LOCAL_MACHINE_2  149
#define IDS_MB_HRERROR_SIP_TIMEOUT_OUT_1 150
#define IDS_MB_HRERROR_SIP_TIMEOUT_OUT_2 151
#define IDS_MB_HRERROR_GENERIC_OUT_1    152
#define IDS_MB_HRERROR_GENERIC_OUT_2    153
#define IDS_MB_HRERROR_SIP_TIMEOUT_IN_1 154
#define IDS_MB_HRERROR_SIP_TIMEOUT_IN_2 155
#define IDS_MB_HRERROR_APPS_DONT_MATCH_IN_2 156
#define IDS_MB_HRERROR_GENERIC_IN_1     157
#define IDS_MB_HRERROR_GENERIC_IN_2     158
#define IDS_MB_DETAIL_HR                159
#define IDS_MB_DETAIL_HR_UNKNOWN        160
#define IDR_EXEOLDSTUFF                 161
#define IDS_MESSENGER_UNAVAILABLE_1     162
#define IDS_MESSENGER_UNAVAILABLE_2     163
#define IDS_NETMEETING_IN_USE           164

#define IDC_STATUS                      200
#define IDC_STATIC_MSG_ICON             201
#define IDD_DIALOG_ERROR_MESSAGE_LITE   202
#define IDC_EDIT_MSG3                   203
#define IDC_EDIT_MSG2                   204
#define IDC_EDIT_MSG1                   205

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\rtcshare.cpp ===
//
// rtcshare.cpp : Implementation of WinMain
//

//
// Messenger licenses
//
// id:  appshare@msnmsgr.com
// key: W5N2C9D7A6P3K4J8
//
// id:  whiteboard@msnmsgr.com
// key: P2R5E9S3N4X7L8V6
//

#include "stdafx.h"

#include "rtcshare_i.c"
#include "sessions_i.c"
#include "msgrua_i.c"
#include "lock_i.c"

CComModule    _Module;

//
// String constants. These should NOT be localized!
//

const WCHAR g_cszAppShareGUID[] = L"{F1B1920C-6A3C-4ce7-B18C-AFAB305FD03D}";
const WCHAR g_cszWhiteboardGUID[] = L"{1DF57D09-637A-4ca5-91B9-2C3EDAAF62FE}";
const WCHAR g_cszName[] = L"Name";
const WCHAR g_cszPath[] = L"Path";
const WCHAR g_cszURL[] = L"URL";

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RTCShare, CRTCShare)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT PlaceOnTop(IRTCShare * pRTCShare)
{
    LOG((RTC_TRACE, "PlaceOnTop - enter"));

    HWND hWnd;
    HRESULT hr;

    hr = pRTCShare->OnTop();
    
    if ( FAILED( hr ) )
    {
        LOG((RTC_ERROR, "PlaceOnTop - OnTop failed 0x%lx", hr));

        return hr;
    }

    // Now find the window, given its class. 

    hWnd = FindWindow(g_szWindowClassName, NULL);

    if (hWnd == NULL)
    {
        LOG((RTC_ERROR, "PlaceOnTop - FindWindow failed %d", GetLastError())); 

        return E_FAIL;
    }
    else
    {
        LOG((RTC_INFO, "PlaceOnTop - found window - handle[0x%lx]", hWnd));
    }

    // Now set this window to foreground

    SetForegroundWindow(hWnd);

    // Window should be in the foreground now.

    LOG((RTC_TRACE, "PlaceOnTop - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT AdjustWindowPosition(LPRECT rc)
{
    LOG((RTC_TRACE, "AdjustWindowPosition - enter"));

    //
    // Get the monitor that has the largest area of intersecion with the
    // window rectangle. If the window rectangle intersects with no monitors
    // then we will use the nearest monitor.
    //

    HMONITOR hMonitor = NULL;
    RECT rectWorkArea;
    BOOL fResult;
    int diffCord;

    hMonitor = MonitorFromRect( rc, MONITOR_DEFAULTTONEAREST );

    LOG((RTC_INFO, "AdjustWindowPosition - hMonitor [%p]", hMonitor));

    //
    // Get the visible work area on the monitor
    //

    if ( (hMonitor != NULL) && (hMonitor != INVALID_HANDLE_VALUE) )
    {      
        MONITORINFO monitorInfo;
        monitorInfo.cbSize = sizeof(MONITORINFO);

        fResult = GetMonitorInfo( hMonitor, &monitorInfo );

        rectWorkArea = monitorInfo.rcWork;

        DeleteObject( hMonitor );

        if ( !fResult)
        {
            LOG((RTC_ERROR, "AdjustWindowPosition - GetMonitorInfo failed %d", 
                        GetLastError() ));

            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        //
        // We can always fall back to non-multimon APIs if
        // MonitorFromRect failed.
        //

        fResult = SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);

        if (!fResult)
        {
            LOG((RTC_ERROR, "AdjustWindowPosition - SystemParametersInfo failed %d", 
                        GetLastError() ));

            return HRESULT_FROM_WIN32(GetLastError());
        }
    }   
      
    LOG((RTC_INFO, "AdjustWindowPosition - monitor work area is "
                "%d, %d %d %d ",
                rectWorkArea.left, rectWorkArea.top, 
                rectWorkArea.right, rectWorkArea.bottom));

    //
    // Update x and y coordinates.
    //
    // If top left is not visible, move it to the edge of the visible
    // area.
    //

    if (rc->left < rectWorkArea.left) 
    {
        rc->left = rectWorkArea.left;
    }

    if (rc->top < rectWorkArea.top)
    {
        rc->top = rectWorkArea.top;
    }

    //
    // If bottom right corner is outside work area, we move the 
    // top left cornet back so that it becomes visible. Here the 
    // assumption is that the actual size is smaller than the 
    // visible work area.
    //

    diffCord = rc->left + UI_WIDTH - rectWorkArea.right;

    if (diffCord > 0) 
    {
        rc->left -= diffCord;
    }

    diffCord = rc->top + UI_HEIGHT - rectWorkArea.bottom;

    if (diffCord > 0) 
    {
        rc->top -= diffCord;
    }

    rc->right = rc->left + UI_WIDTH;
    rc->bottom = rc->top + UI_HEIGHT;

    LOG((RTC_INFO, "AdjustWindowPosition - new coords are "
                    "%d, %d %d %d ",
                    rc->left, rc->top, 
                    rc->right, rc->bottom));

    LOG((RTC_TRACE, "AdjustWindowPosition - enter"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT MyRegisterApplication(BSTR bstrAppGUID, BSTR bstrAppName, BSTR bstrAppURL, BSTR bstrPath)
{
    HRESULT hr;

    LOG((RTC_TRACE, "MyRegisterApplication - enter"));

    //
    // Open the Messenger key
    //

    LONG lResult;
    HKEY hkeyMessenger;
    HKEY hkeyApp;

    lResult = RegCreateKeyEx(
                             HKEY_LOCAL_MACHINE,
                             _T("Software\\Microsoft\\MessengerService\\SessionManager\\Apps"),
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyMessenger,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyRegisterApplication - "
                            "RegCreateKeyEx(Apps) failed %d", lResult));
    
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Create the GUID key
    //    

    lResult = RegCreateKeyExW(
                             hkeyMessenger,
                             bstrAppGUID,
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyApp,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyRegisterApplication - "
                            "RegCreateKeyEx(GUID) failed %d", lResult));
    
        RegCloseKey(hkeyMessenger);

        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                             hkeyApp,
                             g_cszName,
                             0,
                             REG_SZ,
                             (LPBYTE)bstrAppName,
                             sizeof(WCHAR) * (lstrlenW(bstrAppName) + 1)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyRegisterApplication - "
                            "RegSetValueExW(Name) failed %d", lResult));
    
        RegCloseKey(hkeyApp);
        RegCloseKey(hkeyMessenger);

        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                             hkeyApp,
                             g_cszPath,
                             0,
                             REG_SZ,
                             (LPBYTE)bstrPath,
                             sizeof(WCHAR) * (lstrlenW(bstrPath) + 1)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyRegisterApplication - "
                            "RegSetValueExW(Path) failed %d", lResult));
    
        RegCloseKey(hkeyApp);
        RegCloseKey(hkeyMessenger);

        return HRESULT_FROM_WIN32(lResult);
    }

    lResult = RegSetValueExW(
                             hkeyApp,
                             g_cszURL,
                             0,
                             REG_SZ,
                             (LPBYTE)bstrAppURL,
                             sizeof(WCHAR) * (lstrlenW(bstrAppURL) + 1)
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyRegisterApplication - "
                            "RegSetValueExW(URL) failed %d", lResult));
    
        RegCloseKey(hkeyApp);
        RegCloseKey(hkeyMessenger);

        return HRESULT_FROM_WIN32(lResult);
    }

    RegCloseKey(hkeyApp);
    RegCloseKey(hkeyMessenger);

    LOG((RTC_TRACE, "MyRegisterApplication - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT MyUnRegisterApplication(BSTR bstrAppGUID)
{
    HRESULT hr;

    LOG((RTC_TRACE, "MyUnRegisterApplication - enter"));

    //
    // Open the Messenger key
    //

    LONG lResult;
    HKEY hkeyMessenger;
    HKEY hkeyApp;

    lResult = RegCreateKeyEx(
                             HKEY_LOCAL_MACHINE,
                             _T("Software\\Microsoft\\MessengerService\\SessionManager\\Apps"),
                             0,
                             NULL,
                             0,
                             KEY_WRITE,
                             NULL,
                             &hkeyMessenger,
                             NULL
                            );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyUnRegisterApplication - "
                            "RegCreateKeyEx(Apps) failed %d", lResult));
    
        return HRESULT_FROM_WIN32(lResult);
    }

    //
    // Delete the GUID key
    //    

    lResult = RegDeleteKeyW(
                            hkeyMessenger,
                            bstrAppGUID
                           );

    if ( lResult != ERROR_SUCCESS )
    {
        LOG((RTC_ERROR, "MyUnRegisterApplication - "
                            "RegDeleteKeyW(GUID) failed %d", lResult));
    
        RegCloseKey(hkeyMessenger);

        return HRESULT_FROM_WIN32(lResult);
    }

    RegCloseKey(hkeyMessenger);

    LOG((RTC_TRACE, "MyUnRegisterApplication - exit S_OK"));

    return S_OK;    
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT DoRegister()
{
    HRESULT hr;

    LOG((RTC_TRACE, "DoRegister - enter"));

    // try to unregister old XP Beta2 components
    _Module.UpdateRegistryFromResource(IDR_EXEOLDSTUFF, FALSE, NULL);

    hr = _Module.RegisterServer(TRUE);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "RegisterServer failed 0x%lx", hr));

        return hr;
    }

    WCHAR szFileName[MAX_PATH+2];

    wcscpy ( szFileName , L"\"" );

    DWORD dwResult = GetModuleFileNameW(
        _Module.GetModuleInstance(),
        &szFileName[1],
        MAX_PATH );

    if ( !dwResult )
    {
        LOG((RTC_ERROR, "DoRegister - "
            "GetModuleFileNameW failed %d", GetLastError()));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    wcscat( szFileName, L"\"" );

#ifdef USE_SESSMGR_TO_REGISTER
    //
    // Create session manager object
    //

    CComPtr<IMsgrSessionManager> pMSessionManager;

    hr = pMSessionManager.CoCreateInstance(
            CLSID_MsgrSessionManager,
            NULL,
            CLSCTX_LOCAL_SERVER
            );

    if ( SUCCEEDED(hr) )
    {
        //
        // Register with session manager
        //

        CComBSTR bstrAppGUID;
        CComBSTR bstrAppName;
        CComBSTR bstrAppURL;
        CComBSTR bstrPath;

        bstrAppGUID = g_cszWhiteboardGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrAppName.LoadString( _Module.GetResourceInstance(), IDS_WHITEBOARD );
        if(!bstrAppName  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString IDS_WHITEBOARD"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrAppURL.LoadString( _Module.GetResourceInstance(), IDS_APPURL );
        if(!bstrAppURL  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString IDS_APPURL"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrPath = szFileName;
        if(!bstrPath  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString bstrPath"));

            return HRESULT_FROM_WIN32(GetLastError());
        }



        hr = pMSessionManager->RegisterApplication(bstrAppGUID, bstrAppName, bstrAppURL, bstrPath);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "RegisterApplication(Whiteboard) failed 0x%lx", hr));

            return hr;
        }

        bstrAppGUID = g_cszAppShareGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrAppName.LoadString( _Module.GetResourceInstance(), IDS_APPSHARE );
        if(!bstrAppName  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString IDS_APPSHARE"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = pMSessionManager->RegisterApplication(bstrAppGUID, bstrAppName, bstrAppURL, bstrPath);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "RegisterApplication(AppShare) failed 0x%lx", hr));

            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "DoRegister - "
            "CoCreateInstance(CLSID_MsgrSessionManager) failed 0x%lx", hr));

#endif // USE_SESSMGR_TO_REGISTER
        //
        // Perhaps Messenger isn't installed. Go ahead and register manually.
        //

        CComBSTR bstrAppGUID;
        CComBSTR bstrAppName;
        CComBSTR bstrAppURL;
        CComBSTR bstrPath;

        bstrAppGUID = g_cszWhiteboardGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrAppName.LoadString( _Module.GetResourceInstance(), IDS_WHITEBOARD );
        if(!bstrAppName  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString IDS_WHITEBOARD"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrAppURL.LoadString( _Module.GetResourceInstance(), IDS_APPURL );
        if(!bstrAppURL  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString IDS_APPURL"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrPath = szFileName;
        if(!bstrPath  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "bstrPath"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = MyRegisterApplication(bstrAppGUID, bstrAppName, bstrAppURL, bstrPath);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "MyRegisterApplication(Whiteboard) failed 0x%lx", hr));

            return hr;
        }

        bstrAppGUID = g_cszAppShareGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "g_cszAppShareGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        bstrAppName.LoadString( _Module.GetResourceInstance(), IDS_APPSHARE );
        if(!bstrAppName  )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "LoadString IDS_APPSHARE"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = MyRegisterApplication(bstrAppGUID, bstrAppName, bstrAppURL, bstrPath);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoRegister - "
                "MyRegisterApplication(AppShare) failed 0x%lx", hr));

            return hr;
        }

#ifdef USE_SESSMGR_TO_REGISTER
    }
#endif // USE_SESSMGR_TO_REGISTER
 
    LOG((RTC_TRACE, "DoRegister - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT DoUnregister()
{
    HRESULT hr;

    LOG((RTC_TRACE, "DoUnregister - enter"));

    hr = _Module.UnregisterServer(TRUE);

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "DoUnregister - "
            "UnregisterServer failed 0x%lx", hr));

        return hr;
    }

#ifdef USE_SESSMGR_TO_REGISTER
    //
    // Create session manager object
    //

    CComPtr<IMsgrSessionManager> pMSessionManager;

    hr = pMSessionManager.CoCreateInstance(
            CLSID_MsgrSessionManager,
            NULL,
            CLSCTX_LOCAL_SERVER
            );

    if ( SUCCEEDED(hr) )
    {
        //
        // Register with session manager
        //

        CComBSTR bstrAppGUID;
    
        bstrAppGUID = g_cszWhiteboardGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoUnRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = pMSessionManager->UnRegisterApplication(bstrAppGUID);   

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoUnregister - "
                "UnRegisterApplication(Whiteboard) failed 0x%lx", hr));

            return hr;
        }

        bstrAppGUID = g_cszAppShareGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoUnRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = pMSessionManager->UnRegisterApplication(bstrAppGUID); 

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoUnregister - "
                "UnRegisterApplication(AppShare) failed 0x%lx", hr));

            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "DoUnregister - "
            "CoCreateInstance(CLSID_MsgrSessionManager) failed 0x%lx", hr));

        //
        // Perhaps Messenger isn't installed. Go ahead and unregister manually.
        //
#endif  // USE_SESSMGR_TO_REGISTER


        CComBSTR bstrAppGUID;
    
        bstrAppGUID = g_cszWhiteboardGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoUnRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = MyUnRegisterApplication(bstrAppGUID);   

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoUnregister - "
                "MyUnRegisterApplication(Whiteboard) failed 0x%lx", hr));

            return hr;
        }

        bstrAppGUID = g_cszAppShareGUID;
        if(!bstrAppGUID  )
        {
            LOG((RTC_ERROR, "DoUnRegister - "
                "bstrAppGUID"));

            return HRESULT_FROM_WIN32(GetLastError());
        }

        hr = MyUnRegisterApplication(bstrAppGUID); 

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "DoUnregister - "
                "MyUnRegisterApplication(AppShare) failed 0x%lx", hr));

            return hr;
        }

#ifdef USE_SESSMGR_TO_REGISTER
    }
#endif // USE_SESSMGR_TO_REGISTER

    LOG((RTC_TRACE, "DoUnregister - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR /*lpCmdLine*/, int /*nShowCmd*/)
{
    HRESULT       hr;
    LPWSTR      * argv;
    int           argc;
    BOOL          bRun = TRUE;
    BOOL          bPlaceCall = FALSE;
    BOOL          bListen = FALSE;
    LPWSTR        szParam = NULL;
    HANDLE        hMutex = NULL;
    const WCHAR * szRTCShareMutexName = L"RTCShare.GlobalMutex.1";

    LOGREGISTERTRACING(_T("RTCSHARE"));
    LOGREGISTERDEBUGGER(_T("RTCSHARE"));

    LOG((RTC_INFO, "_tWinMain - enter"));

    //
    // Create a heap for memory allocation
    //

    if ( RtcHeapCreate() == FALSE )
    {
        LOG((RTC_ERROR, "_tWinMain - RtcHeapCreate failed"));

        return 0;
    }

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    hr = CoInitialize(NULL);
#endif

    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "_tWinMain - CoInitialize failed 0x%lx", hr));

        return 0;
    }

    _Module.Init(ObjectMap, hInstance, &LIBID_RTCSHARELib);

    //
    // Parse command line
    //

    argv = CommandLineToArgvW(GetCommandLineW(), &argc); 

    if ( argv == NULL )
    {
        LOG((RTC_ERROR, "_tWinMain - CommandLineToArgvW failed"));

        return 0;
    }

    for ( int i = 0; i < argc; i++ )
    {
        LOG((RTC_INFO, "_tWinMain - argv[%d] = %ws", i, argv[i]));
    }

    if ( argc > 1 )
    {
        szParam = argv[1];

        if ( (*szParam == L'/') || (*szParam == L'-') )
	    {
            szParam = CharNext(szParam);

            if ( lstrcmpi(szParam, _T("unregserver")) == 0 )           
		    {
			    bRun = FALSE;

                hr = DoUnregister();

                if ( FAILED( hr ) )
                {
                    LOG((RTC_ERROR, "_tWinMain - DoUnregister failed 0x%lx", hr));
                }
		    }
		    else if ( lstrcmpi(szParam, _T("regserver")) == 0 )
		    {			    
			    bRun = FALSE;

                hr = DoRegister();

                if ( hr == SR_APP_ALREADY_REGISTERED )
                {
                    //
                    // We are already registered. Let's unregister and try again.
                    //

                    LOG((RTC_ERROR, "_tWinMain - already registered"));

                    DoUnregister();

                    hr = DoRegister();
                }

                if ( FAILED( hr ) )
                {
                    LOG((RTC_ERROR, "_tWinMain - DoRegister failed 0x%lx", hr));
                }
		    }
            else if ( lstrcmpi(szParam, _T("listen")) == 0 )
            {
                bListen = TRUE;
            }
        }
        else
        {
            bPlaceCall = TRUE;
        }
    }

    if (bRun)
    {
        //
        // Create a named mutex
        //

        hMutex = CreateMutex(NULL,
                             FALSE,
                             szRTCShareMutexName
                             );

        DWORD dwErrorCode = GetLastError();

        if (hMutex == NULL)
        {
            LOG((RTC_ERROR, "_tWinMain - CreateMutex failed %d", dwErrorCode));

            return 0;
        }

        //
        // Check if this is the first instance or the second
        //

        if (dwErrorCode == ERROR_ALREADY_EXISTS)
        {
            //
            // Another instance is running
            //

            LOG((RTC_INFO, "_tWinMain - another instance is running"));

            //
            // Close our handle to the mutex
            //

            CloseHandle(hMutex);
            hMutex = NULL;

            //
            // CoCreate on the other instance object
            //

            CComPtr<IRTCShare> pRTCShare;

            hr = pRTCShare.CoCreateInstance(
                CLSID_RTCShare,
                NULL,
                CLSCTX_LOCAL_SERVER
                );

            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "_tWinMain - CoCreateInstance(CLSID_RTCShare) failed 0x%lx", hr));

                return 0;   
            }                             

            //
            // Bring the other instance on top
            //

            hr = PlaceOnTop(pRTCShare);
            
            if ( FAILED( hr ) )
            {
                LOG((RTC_ERROR, "_tWinMain - PlaceOnTop failed 0x%lx", hr));

                return 0;
            }

            //
            // Pass the action off to the other instance
            //

            if ( bPlaceCall )
            {              
                BSTR bstrURI = SysAllocString(szParam);

                if ( bstrURI == NULL )
                {
                    LOG((RTC_ERROR, "_tWinMain - out of memory"));
                }
                else
                {               
                    hr = pRTCShare->PlaceCall(bstrURI);

                    SysFreeString(bstrURI);
                    bstrURI = NULL;
                }

                if ( FAILED( hr ) )
                {            
                    LOG((RTC_ERROR, "_tWinMain - PlaceCall failed 0x%lx", hr));
                }
            }
            else if ( bListen )
            {
                hr = pRTCShare->Listen();

                if ( FAILED( hr ) )
                {            
                    LOG((RTC_ERROR, "_tWinMain - Listen failed 0x%lx", hr));
                }
            }
            else
            {
                hr = pRTCShare->Launch((long)GetCurrentProcessId());

                if ( FAILED( hr ) )
                {            
                    LOG((RTC_ERROR, "_tWinMain - Launch failed 0x%lx", hr));
                }
            }

            LOG((RTC_TRACE, "_tWinMain - exit"));
                
            return 0;
        }

        //
        // This is the first instance.        
        // Register the class in class store.
        //

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "_tWinMain - RegisterClassObjects failed 0x%lx", hr));
                   
            CloseHandle(hMutex);
            hMutex = NULL;

            return 0;
        }

        hr = CoResumeClassObjects();

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "_tWinMain - CoResumeClassObjects failed 0x%lx", hr));
                 
            CloseHandle(hMutex);
            hMutex = NULL;

            return 0;
        }
#else
        hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "_tWinMain - RegisterClassObjects failed 0x%lx", hr));
                   
            CloseHandle(hMutex);
            hMutex = NULL;

            return 0;
        }
#endif

        InitCommonControls();

        //
        // Create the CShareWin object.
        //
        
        LOG((RTC_TRACE, "_tWinMain - creating CShareWin"));

        g_pShareWin = new CShareWin;

        if ( g_pShareWin )
        {        
            //
            // Create the window
            //

            HWND    hWnd = NULL;
            RECT    rcPos = {
                            0, 0,
                            UI_WIDTH,
                            UI_HEIGHT
                            };

            AdjustWindowPosition( &rcPos );

            TCHAR   szWindowTitle[64];

            szWindowTitle[0] = _T('\0');
            LoadString( _Module.GetResourceInstance(), IDS_APPNAME, szWindowTitle, 64 );
            
            hWnd = g_pShareWin->Create(  NULL, rcPos, szWindowTitle,
                WS_POPUP | WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_VISIBLE, 0);

            if ( hWnd )
            {
                if ( bPlaceCall )
                {
                    BSTR bstrURICopy = SysAllocString(szParam);

                    if ( bstrURICopy == NULL )
                    {
                        LOG((RTC_ERROR, "_tWinMain - out of memory"));
                    }
                    else
                    {
                        PostMessage(hWnd, WM_PLACECALL, NULL, (LPARAM)bstrURICopy);
                    }
                }
                else if ( bListen )
                {
                    PostMessage(hWnd, WM_LISTEN, NULL, NULL);
                }
                else
                {
                    PostMessage(hWnd, WM_LAUNCH, NULL, (LPARAM)GetCurrentProcessId());
                }

                LOG((RTC_TRACE, "_tWinMain - entering message loop"));

                MSG msg;

                while ( 0 < GetMessage( &msg, 0, 0, 0 ) )
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);                    
                }
      
                LOG((RTC_TRACE, "_tWinMain - exiting message loop"));
            }
            else
            {
                LOG((RTC_ERROR, "_tWinMain - Create failed"));
            }

        }

        CloseHandle(hMutex);
        hMutex = NULL;
    }

    _Module.RevokeClassObjects();
    _Module.Term();
    CoUninitialize();
        
#if DBG
    //
    // Make sure we didn't leak anything
    //
             
    RtcDumpMemoryList();
#endif

    //
    // Destroy the heap
    //
        
    RtcHeapDestroy();        

    //
    // Unregister for debug tracing
    //
   
    LOG((RTC_INFO, "_tWinMain - exit"));

    LOGDEREGISTERDEBUGGER() ;
    LOGDEREGISTERTRACING();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\sharewin.cpp ===
//
// sharewin.cpp : Implementation of CShareWin
//

#include "stdafx.h"
#include "coresink.h"
#include "msgrsink.h"

#define MAX_STRING_LEN 100
#define BMP_COLOR_MASK RGB(0,0,0)

CShareWin   * g_pShareWin = NULL;
const TCHAR * g_szWindowClassName = _T("RTCShareWin");
extern HRESULT  GetMD5Result(char* szChallenge, char* szKey, LPWSTR * ppszResponse);

/////////////////////////////////////////////////////////////////////////////
//
//

CShareWin::CShareWin()
{
    LOG((RTC_TRACE, "CShareWin::CShareWin"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

CShareWin::~CShareWin()
{
    LOG((RTC_TRACE, "CShareWin::~CShareWin"));
}


/////////////////////////////////////////////////////////////////////////////
//
//

CWndClassInfo& CShareWin::GetWndClassInfo() 
{ 
    LOG((RTC_TRACE, "CShareWin::GetWndClassInfo"));
    
    static CWndClassInfo wc = 
    { 
        { sizeof(WNDCLASSEX), 0, StartWindowProc, 
            0, 0, NULL, NULL, NULL, (HBRUSH)GetSysColorBrush(COLOR_3DFACE), NULL, g_szWindowClassName, NULL }, 
            NULL, NULL, IDC_ARROW, TRUE, 0, _T("") 
    }; 
    
    return wc;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CShareWin::SetStatusText(UINT uID)
{
    LOG((RTC_TRACE, "CShareWin::SetStatusText - enter"));
    
    TCHAR szStatus[64];
    int nRes = LoadString( _Module.GetResourceInstance(), uID, szStatus, 64 );
    
    if ( nRes )
    {
        m_Status.SetWindowText( szStatus );
    }
    
    LOG((RTC_TRACE, "CShareWin::SetStatusText - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CShareWin::UpdateVisual()
{
    LOG((RTC_TRACE, "CShareWin::UpdateVisual - enter"));
    
    if ( m_enAppState != AS_CONNECTED )
    {
        //
        // Disable AppSharing and Whiteboard buttons
        //
        SendMessage(m_hWndToolbar,TB_SETSTATE,(WPARAM)IDM_WB,
            (LPARAM)MAKELONG(TBSTATE_INDETERMINATE,0));
        SendMessage(m_hWndToolbar,TB_SETSTATE,(WPARAM)IDM_SHARE,
            (LPARAM)MAKELONG(TBSTATE_INDETERMINATE,0));
    }
    else
    {
        //
        // Enable AppSharing and Whiteboard buttons
        //
        SendMessage(m_hWndToolbar,TB_SETSTATE,(WPARAM)IDM_WB,
            (LPARAM)MAKELONG(TBSTATE_ENABLED,0));
        SendMessage(m_hWndToolbar,TB_SETSTATE,(WPARAM)IDM_SHARE,
            (LPARAM)MAKELONG(TBSTATE_ENABLED,0));
    }
    
    LOG((RTC_TRACE, "CShareWin::UpdateVisual - exit"));
}


/////////////////////////////////////////////////////////////////////////////
//
//

void CShareWin::Resize()
{
    LOG((RTC_TRACE, "CShareWin::Resize - enter"));
    
    RECT rcStatus;
    RECT rcWnd;
    
    SendMessage(m_hWndToolbar, TB_AUTOSIZE,(WPARAM) 0, (LPARAM) 0); 
    
    ::GetClientRect(m_hWndToolbar, &rcWnd);
    m_Status.GetClientRect(&rcStatus);
    
    rcWnd.bottom += rcStatus.bottom - rcStatus.top;
    rcWnd.bottom += GetSystemMetrics(SM_CYCAPTION);
    rcWnd.bottom += 2*GetSystemMetrics(SM_CYFIXEDFRAME);
    rcWnd.right += 2*GetSystemMetrics(SM_CYFIXEDFRAME);
    
    LOG((RTC_INFO, "CShareWin::Resize - %d, %d",
        rcWnd.right-rcWnd.left, rcWnd.bottom-rcWnd.top ));
    
    SetWindowPos(HWND_TOP, &rcWnd, SWP_NOMOVE | SWP_NOZORDER);
    
    LOG((RTC_TRACE, "CShareWin::Resize - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

int CShareWin::ShowMessageBox(UINT uTextID, UINT uCaptionID, UINT uType)
{
    LOG((RTC_TRACE, "CShareWin::ShowMessageBox - enter"));
    
    const int MAXLEN = 1000;
    int iRet = 0;
    
    TCHAR szText[MAXLEN];
    TCHAR szCaption[MAXLEN];
    
    LoadString(
        _Module.GetResourceInstance(),
        uTextID,
        szText,
        MAXLEN
        );  
    
    LoadString(
        _Module.GetResourceInstance(),
        uCaptionID,
        szCaption,
        MAXLEN
        );
    
    iRet = MessageBox(
        szText,
        szCaption,
        uType
        );
    
    LOG((RTC_TRACE, "CShareWin::ShowMessageBox - exit"));
    
    return iRet;
}

/////////////////////////////////////////////////////////////////////////////
// 
//

HRESULT CShareWin::StartListen(BOOL fStatic)
{
    LOG((RTC_TRACE, "CShareWin::StartListen - enter"));
    
    HRESULT hr;
    
    if (m_pRTCClient == NULL)
    {
        LOG((RTC_ERROR, "CShareWin::StartListen - "
            "no client"));
        
        return E_UNEXPECTED;
    }
    
    m_fOutgoingCall = FALSE;
    
    //
    // Listen for incoming sessions
    //
    
    hr = m_pRTCClient->put_ListenForIncomingSessions( fStatic ? RTCLM_BOTH : RTCLM_DYNAMIC ); 
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::StartListen - "
            "put_ListenForIncomingSessions failed 0x%lx", hr));
        
        return hr;
    }
    
    LOG((RTC_TRACE, "CShareWin::StartListen - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// 
//

HRESULT CShareWin::StartCall(BSTR bstrURI)
{
    LOG((RTC_TRACE, "CShareWin::StartCall - enter"));
    
    HRESULT hr;
    
    if (m_pRTCClient == NULL)
    {
        LOG((RTC_ERROR, "CShareWin::StartCall - "
            "no client"));
        
        return E_UNEXPECTED;
    }
    
    //
    // Release any existing session
    //
    
    if ( m_pRTCSession != NULL )
    {
        m_pRTCSession->Terminate( RTCTR_NORMAL );
        
        m_pRTCSession.Release();
    }
    
    m_fOutgoingCall = TRUE;
    
    //
    // Create a session
    //
    
    hr = m_pRTCClient->CreateSession(
        RTCST_PC_TO_PC,
        NULL,
        NULL,
        0,
        &(m_pRTCSession.p)
        );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::StartCall - "
            "CreateSession failed 0x%lx", hr));
        
        showErrMessage(hr);
        
        return hr;
    }
    
    hr = m_pRTCSession->AddParticipant(bstrURI, NULL, NULL);
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::StartCall - "
            "AddParticipant failed 0x%lx", hr));
        
        m_pRTCSession.Release();
        
        showErrMessage(hr);
        
        return hr;
    }
    
    LOG((RTC_TRACE, "CShareWin::StartCall - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CShareWin::GetNetworkAddress(BSTR bstrPreferredAddress, BSTR * pbstrURI)
{
    LOG((RTC_TRACE, "CShareWin::GetNetworkAddress - enter"));
    
    HRESULT     hr;
    CComVariant var;

    *pbstrURI = NULL;
    
    if (m_pRTCClient == NULL)
    {
        LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
            "no client"));
        
        return E_UNEXPECTED;
    }
    
    //
    // First, try external addresses
    //
    
    hr = m_pRTCClient->get_NetworkAddresses( 
        VARIANT_FALSE, // TCP
        VARIANT_TRUE, // External
        &var
        );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
            "get_NetworkAddresses failed 0x%lx", hr));
        
        return hr;
    }
    
    if ( var.parray->rgsabound->cElements == 0 )
    {
        LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
            "external address array is empty"));
        
        //
        // Then, try internal addresses
        //
        
        hr = m_pRTCClient->get_NetworkAddresses( 
            VARIANT_FALSE, // TCP
            VARIANT_FALSE, // External
            &var
            );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
                "get_NetworkAddresses failed 0x%lx", hr));
            
            return hr;
        }
        
        if ( var.parray->rgsabound->cElements == 0 )
        {
            LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
                "internal address array is empty"));
            
            return E_FAIL;
        }
    }
    
    //
    // Try and find a match for the preferred address
    //
    
    long lIndex;
    BSTR bstrAddr = NULL;
    
    for ( lIndex = 0; lIndex < (long)(var.parray->rgsabound->cElements); lIndex++ )
    {
        hr = SafeArrayGetElement( var.parray, &lIndex, (void *)&bstrAddr );
    
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
                "SafeArrayGetElement failed 0x%lx, lIndex=%d, cEnlements=%d, bstr=0x%lx", 
                hr, lIndex, (long)(var.parray->rgsabound->cElements, bstrAddr)));
        
            return hr;
        }

        LOG((RTC_INFO, "CShareWin::GetNetworkAddress - "
            "searching [%ws]", bstrAddr));

        if (_wcsnicmp(bstrAddr, bstrPreferredAddress, wcslen(bstrPreferredAddress)) == 0)
        {                   
            break;
        }

        SysFreeString(bstrAddr);
        bstrAddr = NULL;
    }

    if ( bstrAddr != NULL )
    {
        //
        // Found a match, use this address
        //

        LOG((RTC_INFO, "CShareWin::GetNetworkAddress - "
            "found a match for preferred address"));

        *pbstrURI = bstrAddr;
    }
    else
    {
        //
        // Else, use the first address
        //

        lIndex = 0;
        hr = SafeArrayGetElement( var.parray, &lIndex, (void *)pbstrURI );
    
        if ( FAILED(hr) )
        {
        
            LOG((RTC_ERROR, "CShareWin::GetNetworkAddress - "
                "SafeArrayGetElement failed 0x%lx, lIndex=%d, bstr=0x%lx", 
                hr, lIndex, *pbstrURI));

            return hr;

        }
    }
    
    LOG((RTC_TRACE, "CShareWin::GetNetworkAddress - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CShareWin::SendNetworkAddress()
{
    LOG((RTC_TRACE, "CShareWin::SendNetworkAddress - enter"));
    
    HRESULT     hr;
    
    if ( m_pMSession != NULL )
    {
        //
        // Start to listen on the dynamic port
        //
        
        hr = StartListen( FALSE );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::SendNetworkAddress - "
                "StartListen failed 0x%lx", hr));
            
            return -1;
        }

        //
        // Get the local address from Messengre
        //

        CComBSTR bstrMsgrLocalAddr;

        hr = m_pMSession->get_LocalAddress( &(bstrMsgrLocalAddr.m_str) );

        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::SendNetworkAddress - "
                "get_LocalAddress failed 0x%lx", hr));
            
            return -1;
        }

        LOG((RTC_INFO, "CShareWin::SendNetworkAddress - "
            "get_LocalAddress [%ws]", bstrMsgrLocalAddr ));
        
        //
        // Get the local address and dynamic port from SIP
        //
        
        CComBSTR bstrURI;
        
        hr = GetNetworkAddress( bstrMsgrLocalAddr, &(bstrURI.m_str) );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::SendNetworkAddress - "
                "GetNetworkAddress failed 0x%lx", hr));
            
            return -1;
        }
        
        LOG((RTC_INFO, "CShareWin::SendNetworkAddress - "
            "GetNetworkAddress [%ws]", bstrURI ));
        
        //
        // Send the local address to the remote side through
        // context data
        //
        
        hr = m_pMSession->SendContextData( bstrURI );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::SendNetworkAddress - "
                "SendContextData failed 0x%lx", hr));
            
            return -1;
        }
    }
    
    LOG((RTC_TRACE, "CShareWin::SendNetworkAddress - exit"));
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT   hr = S_OK;
    
    LOG((RTC_TRACE, "CShareWin::OnCreate - enter"));
    
    //
    // Check if Netmeeting is running
    //
    
    //if (FindWindow(_T("MPWClass"), NULL))
    //{
    //    LOG((RTC_ERROR, "CShareWin::OnCreate - Netmeeting is running"));
    //
    //    ShowMessageBox( IDS_NETMEETING_IN_USE, IDS_APPNAME, MB_OK );
    //
    //    return -1;
    //}

    //
    // Load and set icons (both small and big)
    //
    
    //m_hIcon = LoadIcon(
    //    _Module.GetResourceInstance(),
    //    MAKEINTRESOURCE(IDI_APPICON)
    //    );

    m_hIcon = (HICON)LoadImage(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDI_APPICON),
        IMAGE_ICON,
        GetSystemMetrics(SM_CXSMICON),
        GetSystemMetrics(SM_CYSMICON),
        LR_DEFAULTCOLOR
        );

    
    SetIcon(m_hIcon, FALSE);
    SetIcon(m_hIcon, TRUE);
    
    //
    // Create a status control
    //
    
    HWND hStatus = CreateStatusWindow(
        WS_CHILD | WS_VISIBLE,
        NULL,
        m_hWnd,
        IDC_STATUS);
    
    m_Status.Attach(hStatus);
    
    SetStatusText(IDS_WAITING);
    
    //
    // Create a toolbar control
    //
    if( ! CreateTBar() )
    {
        LOG((RTC_ERROR, "CShareWin::OnCreate - CreateTBar failed."));
        
        return -1;
    };
    
    //
    // Resize window
    //
    
    Resize();
    
    //
    // Create the Core object
    //
    
    hr = m_pRTCClient.CoCreateInstance(CLSID_RTCClient);
    
    if ( hr != S_OK )
    {
        LOG((RTC_ERROR, "CShareWin::OnCreate - CoCreateInstance failed 0x%lx", hr));
        
        return -1;
    }
    
    //
    // Advise for Core events
    //
    
    hr = m_pRTCClient->put_EventFilter( 
        RTCEF_CLIENT |
        RTCEF_SESSION_STATE_CHANGE
        );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnCreate - "
            "put_EventFilter failed 0x%lx", hr));
        
        m_pRTCClient.Release();
        
        return -1;
    }
    
    hr = g_CoreNotifySink.AdviseControl(m_pRTCClient, this);
    
    if(FAILED(hr))
    {
        LOG((RTC_ERROR, "CShareWin::OnCreate - "
            "AdviseControl failed 0x%lx", hr));
        
        m_pRTCClient.Release();
        
        return -1;
    }
    
    //
    // Initialize the Core
    //
    
    hr = m_pRTCClient->Initialize();
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnCreate - "
            "Initialize failed 0x%lx", hr));
        
        g_CoreNotifySink.UnadviseControl();
        
        m_pRTCClient->Shutdown();
        m_pRTCClient.Release();
        
        return -1;
    }
    
    //
    // Preferred media types
    //
    
    hr = m_pRTCClient->SetPreferredMediaTypes( RTCMT_T120_SENDRECV, VARIANT_FALSE );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnCreate - "
            "SetPreferredMediaTypes failed 0x%lx", hr));
        
        g_CoreNotifySink.UnadviseControl();
        
        m_pRTCClient->Shutdown();
        m_pRTCClient.Release();
        
        return -1;
    }
    
    //
    // Register for terminal services notifications
    //
    
    m_hWtsLib = LoadLibrary( _T("wtsapi32.dll") );
    
    if (m_hWtsLib)
    {
        WTSREGISTERSESSIONNOTIFICATION   fnWtsRegisterSessionNotification;
        
        fnWtsRegisterSessionNotification = 
            (WTSREGISTERSESSIONNOTIFICATION)GetProcAddress( m_hWtsLib, "WTSRegisterSessionNotification" );
        
        if (fnWtsRegisterSessionNotification)
        {
            fnWtsRegisterSessionNotification( m_hWnd, NOTIFY_FOR_THIS_SESSION );
        }
    }
    
    m_fWhiteboardRequested = FALSE;
    m_fAppShareRequested = FALSE;
    m_fAcceptContextData = FALSE;
    
    m_enAppState = AS_IDLE;
    UpdateVisual();
    
    //lock & key
    m_bUnlocked = FALSE;
    m_lPID_Lock = 0;
    m_pszChallenge = NULL;
    m_pMsgrLockKey = NULL;

    LOG((RTC_TRACE, "CShareWin::OnCreate - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CShareWin::OnDestroy - enter"));
    
    //
    // Unregister for terminal services notifications
    //
    
    if (m_hWtsLib)
    {
        WTSUNREGISTERSESSIONNOTIFICATION fnWtsUnRegisterSessionNotification;
        
        fnWtsUnRegisterSessionNotification = 
            (WTSUNREGISTERSESSIONNOTIFICATION)GetProcAddress( m_hWtsLib, "WTSUnRegisterSessionNotification" );
        
        if (fnWtsUnRegisterSessionNotification)
        {
            fnWtsUnRegisterSessionNotification( m_hWnd );
        }
        
        FreeLibrary( m_hWtsLib );
        m_hWtsLib = NULL;
    }
    
    //
    // Release any Messenger objects
    //
    
    g_MsgrSessionNotifySink.UnadviseControl();
    g_MsgrSessionMgrNotifySink.UnadviseControl();
    if (m_pMSession != NULL)
    {
        m_pMSession.Release();
    }
    
    if (m_pMSessionManager != NULL)
    {
        m_pMSessionManager.Release();
    }
    
    if ( NULL != m_pMsgrLockKey) 
    {
        m_pMsgrLockKey->Release(); 
        m_pMsgrLockKey = NULL;
    }
    //
    // Shutdown and release the Core object
    //
    
    g_CoreNotifySink.UnadviseControl();
    
    if (m_pRTCClient != NULL)
    {
        m_pRTCClient->Shutdown();
        m_pRTCClient.Release();
    }
    
    //
    // Free GDI resources
    //
    
    if ( m_hIcon != NULL )
    {
        DeleteObject( m_hIcon );
        m_hIcon = NULL;
    }
    
    PostQuitMessage(0); 
    
    LOG((RTC_TRACE, "CShareWin::OnDestroy - exiting"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CShareWin::OnClose - enter"));
    
    HRESULT hr = S_OK;
    
    if (m_pRTCSession != NULL)
    {
        hr = m_pRTCSession->Terminate(RTCTR_SHUTDOWN);
        
        m_pRTCSession.Release();
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnClose - "
                "Terminate failed 0x%lx", hr));
        }
    }
    
    SetStatusText(IDS_SHUTDOWN);
    
    if (m_pRTCClient != NULL)
    {
        hr = m_pRTCClient->PrepareForShutdown();
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnClose - "
                "PrepareForShutdown failed 0x%lx", hr));
        }
    }
    
    if ( (m_pRTCClient == NULL) || FAILED(hr) )
    {
        //
        // Destroy the window now if there was a problem with the
        // graceful shutdown
        //
        
        LOG((RTC_INFO, "CShareWin::OnClose - "
            "DestroyWindow"));
        
        DestroyWindow();
    }
    
    LOG((RTC_TRACE, "CShareWin::OnClose - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnCoreEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr;
    
    //LOG((RTC_TRACE, "CShareWin::OnCoreEvent - enter"));
    
    RTC_EVENT enEvent = (RTC_EVENT)wParam;
    IDispatch * pEvent = (IDispatch *)lParam;
    
    CComQIPtr<IRTCClientEvent, &IID_IRTCClientEvent>
        pRTCRTCClientEvent;
    CComQIPtr<IRTCSessionStateChangeEvent, &IID_IRTCSessionStateChangeEvent>
        pRTCRTCSessionStateChangeEvent;
    
    switch(enEvent)
    {
    case RTCE_CLIENT:
        pRTCRTCClientEvent = pEvent;
        
        hr = OnClientEvent(pRTCRTCClientEvent);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnCoreEvent - "
                "OnClientEvent failed 0x%lx", hr));
        }
        break;
        
    case RTCE_SESSION_STATE_CHANGE:
        pRTCRTCSessionStateChangeEvent = pEvent;
        
        hr = OnSessionStateChangeEvent(pRTCRTCSessionStateChangeEvent);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnCoreEvent - "
                "OnSessionStateChangeEvent failed 0x%lx", hr));
        }
        break;   
    }
    
    //LOG((RTC_TRACE, "CShareWin::OnCoreEvent - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// 
//

HRESULT CShareWin::OnClientEvent(IRTCClientEvent * pEvent)
{
    HRESULT hr;
    RTC_CLIENT_EVENT_TYPE enEventType;
    
    hr = pEvent->get_EventType( &enEventType );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnClientEvent - "
            "get_EventType failed 0x%lx", hr));
        
        return hr;
    }
    
    switch (enEventType)
    {
    case RTCCET_ASYNC_CLEANUP_DONE:
        {
            LOG((RTC_INFO, "CShareWin::OnClientEvent - "
                "RTCCET_ASYNC_CLEANUP_DONE"));
            
            //
            // Destroy the window
            //
            
            LOG((RTC_INFO, "CShareWin::OnClientEvent - "
                "DestroyWindow"));
            
            DestroyWindow();
        }
        break;
        
    default:
        {
            LOG((RTC_INFO, "CShareWin::OnClientEvent - "
                "unhandled event %d", enEventType));
        }
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// 
//

HRESULT CShareWin::OnSessionStateChangeEvent(IRTCSessionStateChangeEvent * pEvent)
{
    HRESULT hr;
    RTC_SESSION_STATE enState;
    long lStatusCode;
    CComPtr<IRTCSession> pSession;
    
    hr = pEvent->get_State( &enState );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
            "get_State failed 0x%lx", hr));
        
        return hr;
    }
    
    hr = pEvent->get_Session( &(pSession.p) );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
            "get_Session failed 0x%lx", hr));
        
        return hr;
    }
    
    hr = pEvent->get_StatusCode( &lStatusCode );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
            "get_StatusCode failed 0x%lx", hr));
        
        return hr;
    }
    
    if ( enState == RTCSS_INCOMING )
    {
        LOG((RTC_INFO, "CShareWin::OnSessionStateChangeEvent - "
            "RTCSS_INCOMING [%p]", pSession));
        
        if ( m_pRTCSession != NULL )
        {
            LOG((RTC_WARN, "CShareWin::OnSessionStateChangeEvent - "
                "already in a session [%p]", m_pRTCSession));
            
            hr = pSession->Terminate(RTCTR_BUSY);
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
                    "Terminate failed 0x%lx", hr));
                
                return hr;
            }
            
            return S_OK;
        }
        
        m_pRTCSession = pSession;
        
        hr = m_pRTCSession->Answer();
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
                "Answer failed 0x%lx", hr));
            
            m_pRTCSession = NULL;
            
            return hr;
        }
        
        return S_OK;
    }
    
    if ( m_pRTCSession == pSession )
    {
        switch (enState)
        {
        case RTCSS_ANSWERING:
            LOG((RTC_INFO, "CShareWin::OnSessionStateChangeEvent - "
                "RTCSS_ANSWERING"));
            
            m_enAppState = AS_CONNECTING;
            UpdateVisual();
            
            SetStatusText(IDS_CONNECTING);
            
            break;
            
        case RTCSS_INPROGRESS:
            LOG((RTC_INFO, "CShareWin::OnSessionStateChangeEvent - "
                "RTCSS_INPROGRESS"));
            
            m_enAppState = AS_CONNECTING;
            UpdateVisual();
            
            SetStatusText(IDS_CONNECTING);
            
            break;
            
        case RTCSS_CONNECTED:
            LOG((RTC_INFO, "CShareWin::OnSessionStateChangeEvent - "
                "RTCSS_CONNECTED"));
            
            m_enAppState = AS_CONNECTED;
            UpdateVisual();
            
            SetStatusText(IDS_CONNECTED);
            
            if ( m_pRTCClient != NULL )
            {
                if ( m_fWhiteboardRequested )
                {
                    m_fWhiteboardRequested = FALSE;
                    
                    hr = m_pRTCClient->StartT120Applet( RTCTA_WHITEBOARD );
                    
                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
                            "StartT120Applet(Whiteboard) failed 0x%lx", hr));
                    }
                }
                
                if ( m_fAppShareRequested )
                {
                    m_fAppShareRequested = FALSE;
                    
                    hr = m_pRTCClient->StartT120Applet( RTCTA_APPSHARING );
                    
                    if ( FAILED(hr) )
                    {
                        LOG((RTC_ERROR, "CShareWin::OnSessionStateChangeEvent - "
                            "StartT120Applet(AppShare) failed 0x%lx", hr));
                    }
                }
            }
            
            break;
            
        case RTCSS_DISCONNECTED:
            LOG((RTC_INFO, "CShareWin::OnSessionStateChangeEvent - "
                "RTCSS_DISCONNECTED"));
            
            m_fWhiteboardRequested = FALSE;
            m_fAppShareRequested = FALSE;
            
            m_enAppState = AS_IDLE;
            UpdateVisual();
            
            SetStatusText(IDS_DISCONNECTED);
            
            m_pRTCSession = NULL;
            
            if ( FAILED(lStatusCode) )
            {
                showErrMessage(lStatusCode);
            }
            
            break;
        }
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CShareWin::startLockKeyTimer( )
{
    LOG((RTC_TRACE, "CShareWin::startLockKeyTimer - enter"));

    // Kill any existing timer
    KillTimer(TID_LOCKKEY_TIMEOUT);
    
    // Try to start the timer
    DWORD dwID = (DWORD)SetTimer(TID_LOCKKEY_TIMEOUT, 
                                LOCKKEY_TIMEOUT_DELAY);
    if (dwID==0)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        
        LOG((RTC_ERROR, "CShareWin::startLockKeyTimer - "
                        "SetTimer failed 0x%lx", hr));
        
        return hr;
    }

    LOG((RTC_TRACE, "CShareWin::startLockKeyTimer - exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnLaunch(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    long lPID;
    HRESULT hr;
    
    lPID = (long)lParam;
    m_lPID_Lock = lPID;//save it so that it can be used when unlocked
    
    LOG((RTC_TRACE, "CShareWin::OnLaunch - enter - lPID[%d]", lPID));
    
    //
    // Create the Messenger session manager object
    //
    
    if ( m_pMSessionManager == NULL )
    {
        hr = m_pMSessionManager.CoCreateInstance(
            CLSID_MsgrSessionManager,
            NULL,
            CLSCTX_LOCAL_SERVER
            );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnLaunch - "
                "CoCreateInstance(CLSID_MsgrSessionManager) failed 0x%lx", hr));
            
            return -1;
        }
        
        //
        // Advise for Messenger session manager events
        //
        
        hr = g_MsgrSessionMgrNotifySink.AdviseControl(m_pMSessionManager, this);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnLaunch - "
                "AdviseControl failed 0x%lx", hr));
            
            return -1;
        }
    }
    
    if ( !m_bUnlocked )
    {
        // call messenger lock & key stuff
        // First QI Lock & Key interface using a Session Manager object
        ATLASSERT(!m_pMsgrLockKey);
        hr = m_pMSessionManager->QueryInterface(IID_IMsgrLock,(void**)&m_pMsgrLockKey);
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnLaunch - "
                "QueryInterface(IID_IMsgrLock) failed 0x%lx", hr));
            
            return -1;
        }
        
        // Then, request a challenge from the server
        int lCookie =0;

        hr = m_pMsgrLockKey->RequestChallenge(lCookie);

        if( (MSGR_E_API_DISABLED == hr) ||
            (MSGR_E_API_ALREADY_UNLOCKED == hr) )
        {
            LOG((RTC_WARN, "CShareWin::OnLaunch - "
                "We are bypassing lock&key feature, hr=0x%lx", hr));
            PostMessage( WM_MESSENGER_UNLOCKED );
            return 0;
        }
        else if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnLaunch - "
                "RequestChallenge(lCookie) failed 0x%lx", hr));
            
            return -1;
        }
        // on receiving the challenge, we should post WM_MESSENGER_GETCHALLENGE
        startLockKeyTimer();
    }
    else
    {
        LOG((RTC_INFO, "CShareWin::OnLaunch - already unlocked"));

        PostMessage( WM_MESSENGER_UNLOCKED );
    }
    
    LOG((RTC_TRACE, "CShareWin::OnLaunch - exit"));

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnGetChallenge( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{     
    //
    // Listen for OnLockChallenge event in DMsgrSessionManagerEvents 
    //     and grab the challenge from there
    // Encrypt the key (MD5 hashing) with the challenge received from OnLockChallenge event
    // Notice you have to implement your own MD5 hashing method
    //
    
    // Send the response and your ID to the server for authentication 				
    HRESULT hr=E_FAIL;
    LPWSTR  szID = L"appshare@msnmsgr.com";
    LPSTR  szKey= "W5N2C9D7A6P3K4J8";
    LPWSTR    pszResponse=NULL;
    
    // Encrypt the key with the challenge received from OnLockChallenge event
    
    if(NULL==m_pszChallenge)
    {
        LOG((RTC_ERROR,"CShareWin::OnGetChallenge-no challenge"));
        return E_FAIL;
    }

    //got the challenge, so that we can kill the timer for challenge
    KillTimer(TID_LOCKKEY_TIMEOUT);    
    
    LOG((RTC_INFO,"CShareWin::OnGetChallenge -Get MD5 result with challenge=%s, key=%s", 
        m_pszChallenge, szKey));
    
    hr = GetMD5Result(m_pszChallenge, szKey, &pszResponse);    
    
    //we don't need m_pszChallenge anymore, free it ASAP
    RtcFree( m_pszChallenge );
    m_pszChallenge = NULL;
    
    if( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnGetChallenge - GetMD5Result fail. hr=0x%x",hr));
        return -1;
    };
    
    
    long lCookie=0;
    LOG((RTC_INFO,"CShareWin::OnGetChallenge -"
        "Send a response: ID=%ws, Key=%s, Response=%ws, Cookie=%d",
        szID, szKey, pszResponse, lCookie));
    
    hr = m_pMsgrLockKey->SendResponse(CComBSTR(szID), 
        CComBSTR(pszResponse), 
        lCookie);
    
    //We don't need pszResponse any more, free it ASAP
    RtcFree(pszResponse);
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnGetChallenge - "
            "SendResponse failed 0x%lx", hr));
        
        return -1;
    }
    
    // Listen for OnLockResult event for the result of your authentication
    // The API is unlocked if the result is successful and then you can get context data and 
    // receive OnInvitation and OnContextData events.
    startLockKeyTimer();
    
    return 0;
}


LRESULT CShareWin::OnMessengerUnlocked( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    
    HRESULT hr=E_FAIL;
    long lPID;
    
    lPID = m_lPID_Lock;
    
    LOG((RTC_TRACE, "CShareWin::OnMessengerUnlocked - enter - lPID[%d]", lPID));

    m_bUnlocked = TRUE;

    //got the lockResult, so that we can kill the timer for lockResult
    KillTimer(TID_LOCKKEY_TIMEOUT);    
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    
    /////////////////////////////////////////////////////////////////////////////////////    
    //
    // Release any existing Messenger session
    //
    
    g_MsgrSessionNotifySink.UnadviseControl();
    
    if ( m_pMSession != NULL )
    {
        m_pMSession.Release();
    }
    
    //
    // Get the Messenger session
    //
    
    IDispatch *pDisp = NULL;
    
    hr = m_pMSessionManager->GetLaunchingSession(lPID, &pDisp);
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "GetLaunchingSession failed 0x%lx", hr));
        
        return -1;
    }
    
    hr = pDisp->QueryInterface(IID_IMsgrSession, (void **)&(m_pMSession.p));
    
    pDisp->Release();
    pDisp = NULL;
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "QueryInterface(IID_IMsgrSession) failed 0x%lx", hr));
        
        return -1;
    }
    
    //
    // Advise for Messenger session events
    //
    
    hr = g_MsgrSessionNotifySink.AdviseControl(m_pMSession, this);
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "AdviseControl failed 0x%lx", hr));
        
        return -1;
    }
    
    //
    // Get the user
    //
    
    CComPtr<IMessengerContact> pMContact;
    
    hr = m_pMSession->get_User( &pDisp );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "get_User failed 0x%lx", hr));
        
        return -1;
    }
    
    hr = pDisp->QueryInterface(IID_IMessengerContact, (void **)&(pMContact.p));
    
    pDisp->Release();
    pDisp = NULL;
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "QueryInterface(IID_IMessengerContact) failed 0x%lx", hr));
        
        return -1;
    }
    
    CComBSTR bstrSigninName;
    
    hr = pMContact->get_SigninName( &(bstrSigninName.m_str) );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "get_SigninName failed 0x%lx", hr));
        
        return -1;
    }
    
    LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - SigninName [%ws]", bstrSigninName ));
    
    //
    // Do we have a current call?
    //
    
    BOOL fAlreadyConnected = FALSE;
    
    if ( m_enAppState != AS_IDLE )
    {
        //
        // Already in a call
        //
        
        LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - already in a call"));
        
        if ( (m_bstrSigninName.m_str == NULL) || wcscmp( m_bstrSigninName, bstrSigninName) )
        {
            LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - this is a new user"));
            
            //
            // We have been ask to call a different user. Show a message box
            // to alert the user.
            //
            
            int iRes = ShowMessageBox(IDS_INUSE_TEXT, IDS_INUSE_CAPTION, MB_YESNO);
            
            if ( iRes != IDYES )
            {
                LOG((RTC_INFO, "CShareWin::OnLaunch - don't drop the call"));

                return 0;
            }
            
            //
            // The user has requested to place the new call. We must terminate
            // the current call.
            //
            
            if ( m_pRTCSession != NULL )
            {
                m_pRTCSession->Terminate( RTCTR_NORMAL );
                
                m_pRTCSession.Release();
            }
        }
        else
        {
            LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - this is the same user"));
            
            //
            // We are already connected to the appropriate user. All we will need
            // to do is launch the applet.
            //
            
            fAlreadyConnected = TRUE;
        }
    }
    
    m_bstrSigninName = bstrSigninName;
    
    //
    // Get the flags
    //
    
    long lFlags;
    
    hr = m_pMSession->get_Flags( &lFlags );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "get_Flags failed 0x%lx", hr));
        
        return -1;
    }
    
    if ( lFlags & SF_INVITER )
    {
        LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - INVITER" ));
        
        //
        // Try getting context data in case we were slow in
        // launching and we missed the event
        //
        
        if ( !fAlreadyConnected )
        {
            m_fAcceptContextData = TRUE;
            
            PostMessage( WM_CONTEXTDATA, NULL, NULL );
        }
    }
    else if ( lFlags & SF_INVITEE )
    {
        LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - INVITEE" ));
        
        //
        // If we aren't already connected, send our local
        // address to the remote side to get it to call us
        //
        
        if ( !fAlreadyConnected )
        {
            hr = SendNetworkAddress();
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
                    "SendNetworkAddress failed 0x%lx", hr));
                
                return -1;
            }
        }
    }
    else
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "invalid flags 0x%lx", lFlags));
        
        return -1;
    }
    
    //
    // Get the application
    //
    
    CComBSTR bstrAppGUID;
    
    hr = m_pMSession->get_Application( &(bstrAppGUID.m_str) );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "get_Application failed 0x%lx", hr));
        
        return -1;
    }
    
    if ( _wcsicmp( bstrAppGUID, g_cszWhiteboardGUID ) == 0 )
    {
        LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - WHITEBOARD" ));
        
        if ( (lFlags & SF_INVITER) || fAlreadyConnected )
        {
            m_fWhiteboardRequested = TRUE;
        }
    }
    else if ( _wcsicmp( bstrAppGUID, g_cszAppShareGUID ) == 0 )
    {
        LOG((RTC_INFO, "CShareWin::OnMessengerUnlocked - APPSHARE" ));
        
        if ( lFlags & SF_INVITER )
        {
            m_fAppShareRequested = TRUE;
        }
    }
    else
    {
        LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
            "invalid AppGUID %ws", bstrAppGUID));
        
        return -1;
    }
    
    //
    // If already connected, start the applet
    //
    
    if ( fAlreadyConnected )
    {
        if ( m_pRTCClient != NULL )
        {
            if ( m_fWhiteboardRequested )
            {
                m_fWhiteboardRequested = FALSE;
                
                hr = m_pRTCClient->StartT120Applet( RTCTA_WHITEBOARD );
                
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
                        "StartT120Applet(Whiteboard) failed 0x%lx", hr));
                }
            }
            
            if ( m_fAppShareRequested )
            {
                m_fAppShareRequested = FALSE;
                
                hr = m_pRTCClient->StartT120Applet( RTCTA_APPSHARING );
                
                if ( FAILED(hr) )
                {
                    LOG((RTC_ERROR, "CShareWin::OnMessengerUnlocked - "
                        "StartT120Applet(AppShare) failed 0x%lx", hr));
                }
            }
        }
    }
    
    LOG((RTC_TRACE, "CShareWin::OnMessengerUnlocked - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CShareWin::showRetryDlg(){
    HRESULT hr;
    KillTimer(TID_LOCKKEY_TIMEOUT);    
    hr = (HRESULT)RTC_E_MESSENGER_UNAVAILABLE;

    showErrMessage(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    long wTimerID = (long)wParam;
    HRESULT hr;
        
    LOG((RTC_TRACE, "CShareWin::OnTimer - enter "));

    if( wTimerID == TID_LOCKKEY_TIMEOUT)
    {
        showRetryDlg();
    }
    else
    {
        LOG((RTC_WARN, "CShareWin::OnTimer - unknown timer id=%x ",wTimerID));
    }

    LOG((RTC_TRACE, "CShareWin::OnTimer - exit "));
    return 0;
}


/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnPlaceCall(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CComBSTR bstrURI;
    HRESULT hr;
    
    bstrURI.m_str = (BSTR)lParam;
    
    LOG((RTC_TRACE, "CShareWin::OnPlaceCall - enter - bstrURI[%ws]", bstrURI));
    
    //
    // Place a call
    //
    
    hr = StartCall( bstrURI );
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnPlaceCall - "
            "StartCall failed 0x%lx", hr));
        
        return -1;
    }
    
    LOG((RTC_TRACE, "CShareWin::OnPlaceCall - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnListen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;
    
    LOG((RTC_TRACE, "CShareWin::OnListen - enter"));
    
    //
    // Listen for incoming calls
    //
    
    hr = StartListen( TRUE ); 
    
    if ( FAILED(hr) )
    {
        LOG((RTC_ERROR, "CShareWin::OnListen - "
            "StartListen failed 0x%lx", hr));
        
        return -1;
    }
    
    LOG((RTC_TRACE, "CShareWin::OnListen - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnContextData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CComBSTR bstrContextData;
    HRESULT  hr;
    
    LOG((RTC_TRACE, "CShareWin::OnContextData - enter"));
    
    if ( m_fAcceptContextData == FALSE )
    {
        LOG((RTC_WARN, "CShareWin::OnContextData - "
            "not accepting context data now"));
        
        return -1;
    }
    
    if ( m_pMSession != NULL )
    {
        //
        // Get the context data
        //
        
        hr = m_pMSession->get_ContextData( &bstrContextData );
        
        if ( FAILED(hr) )
        {
            LOG((RTC_ERROR, "CShareWin::OnContextData - "
                "get_ContextData failed 0x%lx", hr));
            
            return -1;
        }
        
        if ( bstrContextData.m_str == NULL )
        {
            LOG((RTC_INFO, "CShareWin::OnContextData - "
                "no context data" ));
        }
        else
        {
            LOG((RTC_INFO, "CShareWin::OnContextData - "
                "get_ContextData [%ws]", bstrContextData ));
            
            m_fAcceptContextData = FALSE;
            
            //
            // Place a call
            //
            
            hr = StartCall( bstrContextData );
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CShareWin::OnContextData - "
                    "StartCall failed 0x%lx", hr));
                
                return -1;
            }
        }
    }
    
    LOG((RTC_TRACE, "CShareWin::OnContextData - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPTOOLTIPTEXT   lpToolTipText;
    static TCHAR     szBuffer[100];
    
    //bHandled is always TRUE when we are called
    bHandled=FALSE;
    
    lpToolTipText = (LPTOOLTIPTEXT)lParam;
    
    if (lpToolTipText->hdr.code == TTN_NEEDTEXT)
    {
        LoadString(_Module.GetResourceInstance(),
            lpToolTipText->hdr.idFrom,   // string ID == command ID
            szBuffer,
            sizeof(szBuffer)/sizeof(TCHAR));
        
        //        lpToolTipText->lpszText = szBuffer;
        // Depending on what is entered into the hinst of TOOLTIPTEXT
        // structure, the lpszText member can be a buffer or an INTEGER VALUE
        // obtained from MAKEINTRESOURCE()...
        
        lpToolTipText->hinst = _Module.GetResourceInstance();
        lpToolTipText->lpszText = MAKEINTRESOURCE(lpToolTipText->hdr.idFrom);
        
        bHandled=TRUE;
    }
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{  
    HRESULT hr = S_OK;
    
    switch( LOWORD( wParam ))
    {
    case IDM_SHARE:
        if ( m_pRTCClient != NULL )
        {
            hr = m_pRTCClient->StartT120Applet( RTCTA_APPSHARING );
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CShareWin::OnCommand - "
                    "StartT120Applet(Whiteboard) failed 0x%lx", hr));
            }
        }
        break;
        
    case IDM_WB:
        if ( m_pRTCClient != NULL )
        {
            hr = m_pRTCClient->StartT120Applet( RTCTA_WHITEBOARD );
            
            if ( FAILED(hr) )
            {
                LOG((RTC_ERROR, "CShareWin::OnCommand - "
                    "StartT120Applet(Whiteboard) failed 0x%lx", hr));
            }
        }
        break;
        
    case IDM_CLOSE:
        PostMessage( WM_CLOSE, NULL, NULL );        
        break;        
        
    default:
        bHandled=FALSE;
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SendMessage(m_hWndToolbar, uMsg, wParam, lParam);
    m_Status.SendMessage(uMsg, wParam, lParam);
    
    bHandled=FALSE;
    
    return S_OK ;
}

/////////////////////////////////////////////////////////////////////////////
//
//

HIMAGELIST CreateImgList(int idb)
{
    HIMAGELIST hRet;
    HBITMAP     hBitmap = NULL;
    /*ILC_MASK  Use a mask. The image list contains two bitmaps,
    one of which is a monochrome bitmap used as a mask. If this 
    value is not included, the image list contains only one bitmap. 
    */
    hRet = ImageList_Create(UI_ICON_SIZE, UI_ICON_SIZE, ILC_COLOR24 | ILC_MASK , 3, 3);
    if(hRet)
    {
        // Open a bitmap
        hBitmap = LoadBitmap(_Module.GetResourceInstance(),MAKEINTRESOURCE(idb));
        if(hBitmap)
        {
            // Add the bitmap to the image list
            ImageList_AddMasked(hRet, hBitmap, BMP_COLOR_MASK);
            
            DeleteObject(hBitmap);
            hBitmap = NULL;
        }
    }
    return hRet;
}

/////////////////////////////////////////////////////////////////////////////
//
//

BOOL CShareWin::CreateTBar()
{
    LOG((RTC_TRACE, "CShareWin::CreateTBar - enter"));
    
    int         iShare, iClose, iWB;
    TCHAR       szBuffer[MAX_STRING_LEN];
    
    // Image lists for the toolbar control
    HIMAGELIST              hNormalimgList;
    HIMAGELIST              hHotImgList;
    HIMAGELIST              hDisableImgList;
    
    hNormalimgList  =CreateImgList(IDB_TOOLBAR_NORMAL);
    hDisableImgList =CreateImgList(IDB_TOOLBAR_DISABLED);
    hHotImgList     =CreateImgList(IDB_TOOLBAR_HOT);
    
    // Create the toolbar
    m_hWndToolbar = CreateWindowEx(
        0, 
        TOOLBARCLASSNAME, 
        (LPTSTR) NULL,
        WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS, 
        0, // horizontal position of window
        0, // vertical position of window
        0, // window width
        0, // window height
        m_hWnd, // handle to parent or owner window
        (HMENU) ID_TOOLBAR, 
        _Module.GetResourceInstance(), 
        NULL); 
    
    if(m_hWndToolbar!=NULL)
    {                
        // backward compatibility
        SendMessage(m_hWndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM) sizeof(TBBUTTON), 0);
        
        // Set the image lists
        SendMessage(m_hWndToolbar, TB_SETIMAGELIST, 0, (LPARAM)hNormalimgList); 
        SendMessage(m_hWndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)hHotImgList); 
        SendMessage(m_hWndToolbar, TB_SETDISABLEDIMAGELIST, 0, (LPARAM)hDisableImgList); 
        
        //Add the button strings to the toolbar's internal string list
        LoadString(_Module.GetResourceInstance(),
            IDS_WB,
            szBuffer,
            MAX_STRING_LEN-2 // //Save room for second null terminator.
            );
        
        szBuffer[lstrlen(szBuffer) + 1] = 0;  //Double-null terminate. 
        iWB = (int)SendMessage(m_hWndToolbar, TB_ADDSTRING,(WPARAM) 0, (LPARAM)szBuffer ); 

        LoadString(_Module.GetResourceInstance(),
            IDS_CLOSE,
            szBuffer,
            MAX_STRING_LEN-2 // //Save room for second null terminator.
            );
        
        szBuffer[lstrlen(szBuffer) + 1] = 0;  //Double-null terminate. 
        iClose = (int)SendMessage(m_hWndToolbar, TB_ADDSTRING,(WPARAM) 0, (LPARAM)szBuffer ); 


        LoadString(_Module.GetResourceInstance(),
            IDS_SHARE,
            szBuffer,
            MAX_STRING_LEN-2 // //Save room for second null terminator.
            );
        
        szBuffer[lstrlen(szBuffer) + 1] = 0;  //Double-null terminate. 
        iShare = (int)SendMessage(m_hWndToolbar, TB_ADDSTRING,(WPARAM) 0, (LPARAM)szBuffer ); 

        TBBUTTON tbButtons[3];

        // Fill the TBBUTTON array with button information, and add the 
        // buttons to the toolbar. The buttons on this toolbar have text 
        // but do not have bitmap images. 
        tbButtons[0].iBitmap = 0; 
        tbButtons[0].idCommand = IDM_SHARE; 
        tbButtons[0].fsState = TBSTATE_INDETERMINATE; 
        tbButtons[0].fsStyle = BTNS_BUTTON; 
        tbButtons[0].dwData = 0; 
        tbButtons[0].iString = iShare; 
        
        tbButtons[1].iBitmap = 1; 
        tbButtons[1].idCommand = IDM_WB; 
        tbButtons[1].fsState = TBSTATE_INDETERMINATE; 
        tbButtons[1].fsStyle = BTNS_BUTTON; 
        tbButtons[1].dwData = 0; 
        tbButtons[1].iString = iWB; 
        
        tbButtons[2].iBitmap = 2; 
        tbButtons[2].idCommand = IDM_CLOSE; 
        tbButtons[2].fsState = TBSTATE_ENABLED; 
        tbButtons[2].fsStyle = BTNS_BUTTON; 
        tbButtons[2].dwData = 0; 
        tbButtons[2].iString = iClose; 
        
        // Add the buttons to the toolbar
        SendMessage(m_hWndToolbar, TB_ADDBUTTONS, sizeof(tbButtons)/sizeof(TBBUTTON), 
            (LPARAM) tbButtons); 
        
        // Size the buttons
        SendMessage(m_hWndToolbar, TB_SETBUTTONWIDTH,0,MAKELPARAM(UI_TOOLBAR_CX,UI_TOOLBAR_CX));
    }
    else
    {
        LOG((RTC_ERROR, "CShareWin::CreateTBar - error (%x) when trying to create the toolbar", GetLastError()));
        
#define DESTROY_NULLIFY(h) if(h){ ImageList_Destroy(h); h=NULL;}
        
        DESTROY_NULLIFY( hNormalimgList );
        DESTROY_NULLIFY( hHotImgList );
        DESTROY_NULLIFY( hDisableImgList );
        
#undef DESTROY_NULLIFY
        
    }
    
    LOG((RTC_TRACE, "CShareWin::CreateTBar - exit"));
    
    return (m_hWndToolbar != NULL);
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnWtsSessionChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CShareWin::OnWtsSessionChange - enter"));
    
    HRESULT hr;
    
    switch( wParam )
    {
    case WTS_CONSOLE_CONNECT:
        LOG((RTC_INFO, "CShareWin::OnWtsSessionChange - WTS_CONSOLE_CONNECT (%d)",
            lParam));
        
        break;
        
    case WTS_CONSOLE_DISCONNECT:
        LOG((RTC_INFO, "CShareWin::OnWtsSessionChange - WTS_CONSOLE_DISCONNECT (%d)",
            lParam));
        
        //
        // Is a call active?
        //
        
        if ( m_enAppState != AS_IDLE )
        {
            LOG((RTC_INFO, "CShareWin::OnWtsSessionChange - dropping active call"));
            
            if ( m_pRTCSession != NULL )
            {
                m_pRTCSession->Terminate( RTCTR_NORMAL );
                
                m_pRTCSession.Release();
            }                        
        }

        if ( m_pRTCClient != NULL )
        {
            m_pRTCClient->StopT120Applets();
        }
        
        break;
    }
    
    LOG((RTC_TRACE, "CShareWin::OnWtsSessionChange - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

LRESULT CShareWin::OnSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LOG((RTC_TRACE, "CShareWin::OnSettingChange - enter"));
    
    SendMessage(m_hWndToolbar, uMsg, wParam, lParam);
    m_Status.SendMessage(uMsg, wParam, lParam);
    
    if (wParam == SPI_SETNONCLIENTMETRICS)
    {
        Resize();
    }
    
    LOG((RTC_TRACE, "CShareWin::OnSettingChange - exit"));
    
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
//
//

void CShareWin::showErrMessage(HRESULT StatusCode)
{
    LOG((RTC_TRACE, "CShareWin::showErrMessage - enter"));
    
    if ( SUCCEEDED(StatusCode) )
    {
        //
        // Return if this isn't an error
        //
        
        return;
    }
    
    //
    // Prepare the error strings
    //
    
    HRESULT         hr;
    CShareErrorInfo ErrorInfo;
    
    hr = PrepareErrorStrings(
        m_fOutgoingCall,
        StatusCode,
        &ErrorInfo);
    
    if(SUCCEEDED(hr))
    {        
        //
        // Create the dialog box
        //
        
        CErrorMessageLiteDlg *pErrorDlgLite =
            new CErrorMessageLiteDlg;
        
        if (pErrorDlgLite)
        {
            //
            //  Call the modal dialog box
            //
            
            pErrorDlgLite->DoModal(m_hWnd, (LPARAM)&ErrorInfo);
            
            delete pErrorDlgLite;
        }
        else
        {
            LOG((RTC_ERROR, "CShareWin::showErrMessage - "
                "failed to create dialog"));
        }
    }
    
    LOG((RTC_TRACE, "CShareWin::showErrMessage - exit"));
}

/////////////////////////////////////////////////////////////////////////////
//
//

HRESULT CShareWin::PrepareErrorStrings(
                                       BOOL    bOutgoingCall,
                                       HRESULT StatusCode,
                                       CShareErrorInfo *pErrorInfo)
{    
    LOG((RTC_TRACE, "CShareWin::PrepareErrorStrings - enter"));
    
    UINT    nID1 = 0;
    UINT    nID2 = 0;
    WORD    wIcon = OIC_HAND;
    PWSTR   pString = NULL;
    PWSTR   pFormat = NULL;
    DWORD   dwLength;
    
    if (StatusCode == RTC_E_MESSENGER_UNAVAILABLE  )
    {
        nID1 = IDS_MESSENGER_UNAVAILABLE_1;
        nID2 = IDS_MESSENGER_UNAVAILABLE_2;
        pErrorInfo->Message3 = NULL ;
        wIcon = OIC_HAND;
    }
    else if ( FAILED(StatusCode) )
    {
        if ( HRESULT_FACILITY(StatusCode) == FACILITY_SIP_STATUS_CODE )
        {
            // by default we use a generic message
            // we blame the network
            //
            nID1 = IDS_MB_SIPERROR_GENERIC_1;
            nID2 = IDS_MB_SIPERROR_GENERIC_2;
            
            // the default is a warning for this class
            wIcon = OIC_WARNING;
            
            switch( HRESULT_CODE(StatusCode) )
            {
            case 405:   // method not allowed
            case 406:   // not acceptable
            case 488:   // not acceptable here
            case 606:   // not acceptable
                
                // reusing the "apps don't match" error
                // 
                nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
                nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2;
                
                break;
                
            case 404:   // not found
            case 410:   // gone
            case 604:   // does not exist anywhere
            case 700:   // ours, no client is running on the callee
                
                // not found
                // 
                nID1 = IDS_MB_SIPERROR_NOTFOUND_1;
                nID2 = IDS_MB_SIPERROR_NOTFOUND_2;
                
                // information
                wIcon = OIC_INFORMATION;
                
                break;
                
            case 401:
            case 407:
                
                // auth failed
                // 
                nID1 = IDS_MB_SIPERROR_AUTH_FAILED_1;
                nID2 = IDS_MB_SIPERROR_AUTH_FAILED_2;
                
                break;
                
            case 408:   // timeout
                
                // timeout. this also cover the case when
                //  the callee is lazy and doesn't answer the call
                //
                // if we are in the connecting state, we may assume
                // that the other end is not answering the phone.
                // It's not perfect, but I don't have any choice
                
                if (m_enAppState == AS_CONNECTING)
                {
                    nID1 = IDS_MB_SIPERROR_NOTANSWERING_1;
                    nID2 = IDS_MB_SIPERROR_NOTANSWERING_2;
                    
                    // information
                    wIcon = OIC_INFORMATION;
                }
                
                break;            
                
            case 480:   // not available
                
                // callee has not made him/herself available..
                // 
                nID1 = IDS_MB_SIPERROR_NOTAVAIL_1;
                nID2 = IDS_MB_SIPERROR_NOTAVAIL_2;
                
                // information
                wIcon = OIC_INFORMATION;
                
                break;
                
            case 486:   // busy here
            case 600:   // busy everywhere
                
                // callee has not made him/herself available..
                // 
                nID1 = IDS_MB_SIPERROR_BUSY_1;
                nID2 = IDS_MB_SIPERROR_BUSY_2;
                
                // information
                wIcon = OIC_INFORMATION;
                
                break;
                
            case 500:   // server internal error
            case 503:   // service unavailable
            case 504:   // server timeout
                
                //  blame the server
                //
                nID1 = IDS_MB_SIPERROR_SERVER_PROBLEM_1;
                nID2 = IDS_MB_SIPERROR_SERVER_PROBLEM_2;
                
                break;
                
            case 603:   // decline
                
                nID1 = IDS_MB_SIPERROR_DECLINE_1;
                nID2 = IDS_MB_SIPERROR_DECLINE_2;
                
                // information
                wIcon = OIC_INFORMATION;
                
                break;
            }
            
            //
            //  The third string displays the SIP code
            //
            
            PWSTR pFormat = RtcAllocString(
                _Module.GetResourceInstance(),
                IDS_MB_DETAIL_SIP);
            
            if(pFormat)
            {
                // find the length
                dwLength = 
                    ocslen(pFormat) // format length
                    -  2               // length of %d
                    +  0x10;           // enough for a number...
                
                pString = (PWSTR)RtcAlloc((dwLength + 1)*sizeof(WCHAR));
                
                if(pString)
                {
                    _snwprintf(pString, dwLength + 1, pFormat, HRESULT_CODE(StatusCode) );
                }
                
                RtcFree(pFormat);
                pFormat = NULL;
                
                pErrorInfo->Message3 = pString;
                pString = NULL;
            }
        }
        else
        {
            // Two cases - incoming and outgoing calls
            if(bOutgoingCall)
            {
                if(StatusCode == HRESULT_FROM_WIN32(WSAHOST_NOT_FOUND) )
                {
                    // Use the generic message in this case
                    //
                    nID1 = IDS_MB_HRERROR_NOTFOUND_1;
                    nID2 = IDS_MB_HRERROR_NOTFOUND_2;
                    
                    // it's not malfunction
                    wIcon = OIC_INFORMATION;
                    
                }
                else if (StatusCode == HRESULT_FROM_WIN32(WSAECONNRESET))
                {
                    // Even thoough it can be caused by any hard reset of the 
                    // remote end, in most of the cases it is caused when the 
                    // other end doesn't have SIP client running.
                    
                    nID1 = IDS_MB_HRERROR_CLIENT_NOTRUNNING_1;
                    nID2 = IDS_MB_HRERROR_CLIENT_NOTRUNNING_2;
                    
                    wIcon = OIC_INFORMATION;
                    
                }
                else if (StatusCode == RTC_E_INVALID_SIP_URL ||
                    StatusCode == RTC_E_DESTINATION_ADDRESS_MULTICAST)
                {
                    nID1 = IDS_MB_HRERROR_INVALIDADDRESS_1;
                    nID2 = IDS_MB_HRERROR_INVALIDADDRESS_2;
                    
                    wIcon = OIC_HAND;
                }
                else if (StatusCode == RTC_E_DESTINATION_ADDRESS_LOCAL)
                {
                    nID1 = IDS_MB_HRERROR_LOCAL_MACHINE_1;
                    nID2 = IDS_MB_HRERROR_LOCAL_MACHINE_2;
                    
                    wIcon = OIC_HAND;
                }
                else if (StatusCode == RTC_E_SIP_TIMEOUT)
                {
                    nID1 = IDS_MB_HRERROR_SIP_TIMEOUT_OUT_1;
                    nID2 = IDS_MB_HRERROR_SIP_TIMEOUT_OUT_2;
                    
                    wIcon = OIC_HAND;
                }
                else if (StatusCode == RTC_E_SIP_CODECS_DO_NOT_MATCH || 
                    StatusCode == RTC_E_SIP_PARSE_FAILED)
                {
                    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
                    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_OUT_2;
                    
                    wIcon = OIC_INFORMATION;
                } 
                else
                {
                    nID1 = IDS_MB_HRERROR_GENERIC_OUT_1;
                    nID2 = IDS_MB_HRERROR_GENERIC_OUT_2;
                    
                    wIcon = OIC_HAND;
                }
            }
            else
            {
                // incoming call
                if (StatusCode == RTC_E_SIP_TIMEOUT)
                {
                    nID1 = IDS_MB_HRERROR_SIP_TIMEOUT_IN_1;
                    nID2 = IDS_MB_HRERROR_SIP_TIMEOUT_IN_2;
                    
                    wIcon = OIC_HAND;
                }
                else if (StatusCode == RTC_E_SIP_CODECS_DO_NOT_MATCH || 
                    StatusCode == RTC_E_SIP_PARSE_FAILED)
                {
                    nID1 = IDS_MB_HRERROR_APPS_DONT_MATCH_1;
                    nID2 = IDS_MB_HRERROR_APPS_DONT_MATCH_IN_2;
                    
                    wIcon = OIC_INFORMATION;
                }
                else
                {
                    nID1 = IDS_MB_HRERROR_GENERIC_IN_1;
                    nID2 = IDS_MB_HRERROR_GENERIC_IN_2;
                    
                    wIcon = OIC_HAND;
                }
            }
            
            //
            //  The third string displays the error code and text
            //
            
            PWSTR   pErrorText = NULL;
            
            dwLength = 0;
            
            // retrieve the error text
            if ( HRESULT_FACILITY(StatusCode) == FACILITY_RTC_INTERFACE )
            {
                // I hope it's the core 
                HANDLE  hRTCModule = GetModuleHandle(_T("RTCDLL.DLL"));
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_HMODULE |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    hRTCModule,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }
            
            if(dwLength == 0)
            {
                // normal system errors
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    StatusCode,
                    0,
                    (LPTSTR)&pErrorText, // that's ugly
                    0,
                    NULL);
            }
            
            // load the format
            // load a simpler one if the associated
            // text for Result could not be found
            
            pFormat = RtcAllocString(
                _Module.GetResourceInstance(),
                dwLength > 0 ? 
                IDS_MB_DETAIL_HR : IDS_MB_DETAIL_HR_UNKNOWN);
            
            if(pFormat)
            {
                LPCTSTR szInserts[] = {
                    (LPCTSTR)UlongToPtr(StatusCode), // ugly
                        pErrorText
                };
                
                PWSTR   pErrorTextCombined = NULL;
                
                // format the error message
                dwLength = ::FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    pFormat,
                    0,
                    0,
                    (LPTSTR)&pErrorTextCombined,
                    0,
                    (va_list *)szInserts);
                
                if(dwLength > 0)
                {
                    // set the error info
                    // this additional operation is needed
                    //  because we need RtcAlloc allocated memory
                    
                    pErrorInfo->Message3 = RtcAllocString(pErrorTextCombined);
                }
                
                if(pErrorTextCombined)
                {
                    LocalFree(pErrorTextCombined);
                }
                
                RtcFree(pFormat);
                pFormat = NULL;
                
            }
            
            if(pErrorText)
            {
                LocalFree(pErrorText);
            }
        }
    }
    
    //
    // Prepare the first string.
    //
    
    pString = RtcAllocString(
        _Module.GetResourceInstance(),
        nID1);
    
    pErrorInfo->Message1 = pString;
    
    pErrorInfo->Message2 = RtcAllocString(
        _Module.GetResourceInstance(),
        nID2);
    
    pErrorInfo->ResIcon = (HICON)LoadImage(
        0,
        MAKEINTRESOURCE(wIcon),
        IMAGE_ICON,
        0,
        0,
        LR_SHARED);
    
    LOG((RTC_TRACE, "CShareWin::PrepareErrorStrings - exit"));
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\sharewin.h ===
// sharewin.h : Declaration of the CShareWin

#ifndef __SHAREWIN_H_
#define __SHAREWIN_H_

#define WM_LAUNCH           WM_USER+100
#define WM_PLACECALL        WM_USER+101
#define WM_LISTEN           WM_USER+102
#define WM_CORE_EVENT       WM_USER+103
#define WM_CONTEXTDATA      WM_USER+104
#define WM_MESSENGER_UNLOCKED   WM_USER+105
#define WM_GETCHALLENGE         WM_USER+106

#define RTC_E_MESSENGER_UNAVAILABLE     ((HRESULT)0x80FF0099L)

#define UI_WIDTH    248
#define UI_HEIGHT   104
#define UI_ICON_SIZE 24
#define UI_TOOLBAR_CX 80

//lock&key timeout constants
#define TID_LOCKKEY_TIMEOUT           1000
#define LOCKKEY_TIMEOUT_DELAY         30000


typedef enum APP_STATE
{
    AS_IDLE,
    AS_CONNECTING,
    AS_CONNECTED

} APP_STATE;

typedef BOOL (WINAPI *WTSREGISTERSESSIONNOTIFICATION)(HWND, DWORD);
typedef BOOL (WINAPI *WTSUNREGISTERSESSIONNOTIFICATION)(HWND);

#include "err.h"

/////////////////////////////////////////////////////////////////////////////
// CShareWin
class CShareWin : 
    public CWindowImpl<CShareWin>
{
 
public:
    CShareWin();

    ~CShareWin();

    static CWndClassInfo& GetWndClassInfo();

BEGIN_MSG_MAP(CShareWin)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_LAUNCH, OnLaunch)
    MESSAGE_HANDLER(WM_PLACECALL, OnPlaceCall)
    MESSAGE_HANDLER(WM_LISTEN, OnListen)
    MESSAGE_HANDLER(WM_CORE_EVENT, OnCoreEvent)
    MESSAGE_HANDLER(WM_CONTEXTDATA, OnContextData)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    MESSAGE_HANDLER(WM_COMMAND, OnCommand)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_WTSSESSION_CHANGE, OnWtsSessionChange)
    MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
    MESSAGE_HANDLER(WM_MESSENGER_UNLOCKED, OnMessengerUnlocked)
    MESSAGE_HANDLER(WM_GETCHALLENGE, OnGetChallenge)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
END_MSG_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);  

    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnLaunch(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPlaceCall(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnListen(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCoreEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnWtsSessionChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    void showRetryDlg();

    LPSTR     m_pszChallenge;//must be ANSI string 
                //....since we encrypt single byte strings
    
private:
    BOOL CreateTBar();

    HRESULT OnClientEvent(IRTCClientEvent * pEvent);

    HRESULT OnSessionStateChangeEvent(IRTCSessionStateChangeEvent * pEvent);

    void SetStatusText(UINT uID);

    void UpdateVisual();

    void Resize();

    HRESULT StartListen(BOOL fStatic);

    HRESULT StartCall(BSTR bstrURI);

    HRESULT GetNetworkAddress(BSTR bstrPreferredAddress, BSTR * pbstrURI);

    HRESULT SendNetworkAddress();

    void showErrMessage(HRESULT StatusCode);

    HRESULT PrepareErrorStrings(
                                 BOOL    bOutgoingCall,
                                 HRESULT StatusCode,
                                 CShareErrorInfo
                                 *pErrorInfo);

    int ShowMessageBox(UINT uTextID, UINT uCaptionID, UINT uType);

    // Interfaces to RTC
    CComPtr<IRTCClient>     m_pRTCClient;
    CComPtr<IRTCSession>    m_pRTCSession;

    // Interfaces to Messenger
    CComPtr<IMsgrSessionManager> m_pMSessionManager;
    CComPtr<IMsgrSession>        m_pMSession;

    CComBSTR                     m_bstrSigninName;

    APP_STATE m_enAppState;
    BOOL      m_fWhiteboardRequested;
    BOOL      m_fAppShareRequested;
    BOOL      m_fOutgoingCall;
    BOOL      m_fAcceptContextData;

    // Icon
    HICON     m_hIcon;

    // Controls
    CWindow   m_Status;
    HWND      m_hWndToolbar;

    // Libary for terminal services
    HMODULE   m_hWtsLib;

    //lock & key
    BOOL      m_bUnlocked;
    long      m_lPID_Lock;
    IMsgrLock *m_pMsgrLockKey;

    LRESULT OnGetChallenge( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnMessengerUnlocked(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT startLockKeyTimer( );
};

extern CShareWin   * g_pShareWin;
extern const TCHAR * g_szWindowClassName;

#endif //__SHAREWIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\share\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E456B10E_A36A_42F2_B591_3CCF7BE6868F__INCLUDED_)
#define AFX_STDAFX_H__E456B10E_A36A_42F2_B591_3CCF7BE6868F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define OEMRESOURCE     // setting this gets OIC_ constants in windows.h

#define _ATL_APARTMENT_THREADED
#include <atlbase.h>

#include <commctrl.h>
#include <exdisp.h>
#include <shellapi.h>
#include <wtsapi32.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <atlwin.h>
#include <atlhost.h>

#include <rtccore.h>
#include <rtcerr.h>

#include "rtclog.h"
#include "rtcmem.h"
#include "rtcutils.h"

#include "sessions.h"
#include "msgrua.h"
#include "mdisp.h"
#include "rtcshare.h"
#include "shareres.h"
#include "sharewin.h"
#include "shareimpl.h"

EXTERN_C const IID DIID_DMsgrSessionEvents;
EXTERN_C const IID DIID_DMsgrSessionManagerEvents;

extern const WCHAR g_cszAppShareGUID[];
extern const WCHAR g_cszWhiteboardGUID[];

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E456B10E_A36A_42F2_B591_3CCF7BE6868F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\asock.h ===
#ifndef __sipcli_asock_h__
#define __sipcli_asock_h__

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <schannel.h>
#include <security.h>
#include "timer.h"
#define SOCKET_WINDOW_CLASS_NAME    \
    _T("SipSocketWindowClassName-8b6971c6-0cee-4668-b687-b57d11b7da38")
#define WM_SOCKET_MESSAGE               (WM_USER + 0)
#define WM_PROCESS_SIP_MSG_MESSAGE      (WM_USER + 1)

enum CONNECTION_STATE
{
    CONN_STATE_NOT_CONNECTED = 0,
    CONN_STATE_CONNECTION_PENDING,
    CONN_STATE_SSL_NEGOTIATION_PENDING,
    CONN_STATE_CONNECTED
};


typedef struct {
    PSTR pszHostName;
    USHORT usPort;
    ULONG ProxyIP;
    USHORT ProxyPort;
} HttpProxyInfo;



enum    CONNECT_FLAG
{
    //
    // If this flag is set, then the SSL socket will NOT validate
    // the server certificate.  This mode should ONLY be used 
    // during testing, since this defeats the whole purpose of SSL.
    //
    
    CONNECT_FLAG_DISABLE_CERT_VALIDATION = 0x00000001,
};


//  enum    SECURITY_STATE
//  {
//      SECURITY_STATE_CLEAR,           // running in clear-text mode
//      SECURITY_STATE_NEGOTIATING,
//      SECURITY_STATE_CONNECTED,
//  };

// We need to make sure we use the right length because in UDP if the
// incoming message is larger the buffer we give, the message will get
// dropped.

//Right now the send and Recv buffer sizes are 1500. 
//XXXXTODO Accomodate the frame size deltas to them.
#define RECV_BUFFER_SIZE        0x5DC 
#define SSL_RECV_BUFFER_SIZE    0x3000
#define SEND_BUFFER_SIZE        3000

class ASYNC_SOCKET;
class SIP_STACK;

///////////////////////////////////////////////////////////////////////////////
// I/O Completion callbacks                                                  
///////////////////////////////////////////////////////////////////////////////


//  class __declspec(novtable) RECV_COMPLETION_INTERFACE
//  {
//  public:    

//      virtual void OnRecvComplete(
//          IN DWORD ErrorCode,
//          IN DWORD BytesRcvd
//          ) = 0;
//  };


//  class __declspec(novtable) SEND_COMPLETION_INTERFACE
//  {
//  public:    
//       virtual void OnSendComplete(
//          IN DWORD ErrorCode
//          ) = 0;
//  };


// Note that the connection could complete after
// the call has been hung up, etc. OnConnectComplete()
// should always check to see if it is in the right state.
// Alternatively, if we choose to delete the object before
// the connect completion is notified, we need to remove
// the notification interface from the connect notification list.

// AddRef() the interface if the Connect() call returned pending
// and Release() it after the connection completed.
// The socket's connect completion routine should check for any
// interfaces waiting for the connect completion. If none are waiting,
// we should just delete the socket (Release() should do it).
class __declspec(novtable) CONNECT_COMPLETION_INTERFACE
{
public:    

    // Only called for TCP sockets
    virtual void OnConnectComplete(
        IN DWORD ErrorCode
        ) = 0;
};


class __declspec(novtable) ACCEPT_COMPLETION_INTERFACE
{
public:    

    // Only called for TCP sockets
    virtual void OnAcceptComplete(
        IN DWORD ErrorCode,
        IN ASYNC_SOCKET *pAcceptedSocket
        ) = 0;
};


// Users of a socket need to add error notification interfaces
// for both incoming as well as outgoing connections.
// When an object using a socket is deleted, it needs to remove
// itself from the socket's error notification list.
class __declspec(novtable) ERROR_NOTIFICATION_INTERFACE
{
public:    

    virtual void OnSocketError(
        IN DWORD ErrorCode
        ) = 0;
};


///////////////////////////////////////////////////////////////////////////////
// Send Buffer and Queue Node
///////////////////////////////////////////////////////////////////////////////

// Ref counted buffer used for send requests.
// This makes managing multiple outstanding send requests
// for a send completion interface simpler.
struct SEND_BUFFER
{
    PSTR    m_Buffer;
    DWORD   m_BufLen;
    ULONG   m_RefCount;

    inline SEND_BUFFER(
        IN  PSTR Buffer,
        IN  DWORD BufLen
        );
    inline ~SEND_BUFFER();
    
    inline ULONG AddRef();
    inline ULONG Release();
};


inline
SEND_BUFFER::SEND_BUFFER(
    PSTR  pBuf,
    DWORD BufLen
    )
{
    m_Buffer       = pBuf;
    m_BufLen       = BufLen;
    m_RefCount     = 1;
}


inline
SEND_BUFFER::~SEND_BUFFER()
{
    if (m_Buffer != NULL)
        free(m_Buffer);

    LOG((RTC_TRACE, "~SEND_BUFFER() done this %x", this));
}


// We live in  a single-threaded world.
inline ULONG SEND_BUFFER::AddRef()
{
    m_RefCount++;
    return m_RefCount;
}


inline ULONG SEND_BUFFER::Release()
{
    m_RefCount--;
    if (m_RefCount != 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
        return 0;
    }
}


struct SEND_BUF_QUEUE_NODE
{
    LIST_ENTRY                  m_ListEntry;
    
    SEND_BUFFER                *m_pSendBuffer;
//      SEND_COMPLETION_INTERFACE  *m_pSendCompletion;
    
    inline SEND_BUF_QUEUE_NODE(
        IN  SEND_BUFFER                *pSendBuffer
//          IN  SEND_COMPLETION_INTERFACE  *pSendCompletion
        );
    
};


inline
SEND_BUF_QUEUE_NODE::SEND_BUF_QUEUE_NODE(
    IN  SEND_BUFFER                *pSendBuffer
    )
{
    m_pSendBuffer       = pSendBuffer;
//      m_pSendCompletion   = pSendCompletion;
}


struct CONNECT_COMPLETION_LIST_NODE
{
    LIST_ENTRY                     m_ListEntry;
    
    CONNECT_COMPLETION_INTERFACE  *m_pConnectCompletion;
    
    inline CONNECT_COMPLETION_LIST_NODE(
        IN  CONNECT_COMPLETION_INTERFACE *pConnectCompletion
        );
    
};


inline
CONNECT_COMPLETION_LIST_NODE::CONNECT_COMPLETION_LIST_NODE(
    IN  CONNECT_COMPLETION_INTERFACE  *pConnectCompletion
    )
{
    m_pConnectCompletion   = pConnectCompletion;
}


struct ERROR_NOTIFICATION_LIST_NODE
{
    LIST_ENTRY                     m_ListEntry;
    
    ERROR_NOTIFICATION_INTERFACE  *m_pErrorNotification;
    
    inline ERROR_NOTIFICATION_LIST_NODE(
        IN  ERROR_NOTIFICATION_INTERFACE *pErrorNotification
        );
    
};


inline
ERROR_NOTIFICATION_LIST_NODE::ERROR_NOTIFICATION_LIST_NODE(
    IN  ERROR_NOTIFICATION_INTERFACE  *pErrorNotification
    )
{
    m_pErrorNotification = pErrorNotification;
}


///////////////////////////////////////////////////////////////////////////////
// ASYNC_SOCKET class
///////////////////////////////////////////////////////////////////////////////

enum SSL_SUBSTATE 
{
    SSL_TUNNEL_NOT_CONNECTED = 0, 
    SSL_TUNNEL_PENDING, 
    SSL_TUNNEL_DONE
};

class ASYNC_SOCKET:
    public TIMER

{

public:
    ASYNC_SOCKET(
        IN  SIP_STACK                   *pSipStack,
        IN  SIP_TRANSPORT                Transport,
        IN  ACCEPT_COMPLETION_INTERFACE *pAcceptCompletion
        );
    ~ASYNC_SOCKET();
    
    ULONG AddRef();
    
    ULONG Release();

    inline BOOL IsSocketOpen();

    inline CONNECTION_STATE GetConnectionState();

    DWORD SetLocalAddr();

    // For a TCP listen socket, we need to listen for the
    // FD_ACCEPT event alone.
    DWORD Create(
        IN BOOL IsListenSocket = FALSE
        );
    
    void  Close();
    
    DWORD Bind(
        IN SOCKADDR_IN  *pLocalAddr
        );
    
    DWORD Send(
        IN  SEND_BUFFER                 *pSendBuffer
        );

    // For UDP socket the call completes synchronously.
    DWORD Connect(
        IN  SOCKADDR_IN  *pDestSockAddr,
        IN LPCWSTR       RemotePrincipalName = NULL,
        IN DWORD         ConnectFlags = 0,
        IN HttpProxyInfo *pHPInfo = NULL
        );

    DWORD AddToConnectCompletionList(
        IN CONNECT_COMPLETION_INTERFACE *pConnectCompletion
        );
    
    void RemoveFromConnectCompletionList(
        IN CONNECT_COMPLETION_INTERFACE   *pConnectCompletion
        );
    
    // For TCP sockets only
    DWORD Listen();
    
    DWORD AddToErrorNotificationList(
        IN ERROR_NOTIFICATION_INTERFACE *pErrorNotification
        );
    
    void RemoveFromErrorNotificationList(
        IN ERROR_NOTIFICATION_INTERFACE   *pErrorNotification
        );
    
    void ProcessNetworkEvent(
        IN  WORD    NetworkEvent,
        IN  WORD    ErrorCode
        );

    void ProcessSipMsg(
        IN SIP_MESSAGE *pSipMsg
        );

    VOID OnTimerExpire();

    inline SOCKET GetSocket();

    inline SIP_TRANSPORT GetTransport();

    // Set to 'SOCK' in constructor
    ULONG                   m_Signature;
    
    // Linked list of sockets.
    LIST_ENTRY                  m_ListEntry;

    SOCKADDR_IN                 m_LocalAddr;
    SOCKADDR_IN                 m_RemoteAddr;
    SSL_SUBSTATE                m_SSLTunnelState;
    PSTR                        m_SSLTunnelHost;
    USHORT                      m_SSLTunnelPort;


private:

    // This socket belongs to this SIP_STACK
    SIP_STACK                  *m_pSipStack;
    
    ULONG                       m_RefCount;
    HWND                        m_Window;
    SOCKET                      m_Socket;
    SIP_TRANSPORT               m_Transport;
    BOOL                        m_isListenSocket;
    ///// Context related to recv.
    PSTR                        m_RecvBuffer;
    DWORD                       m_RecvBufLen;
    // The message that we are decoding from the buffer we receive.
    // In the case of TCP this could be a partially parsed message.
    SIP_MESSAGE                *m_pSipMsg;

    DWORD                       m_BytesReceived;
    DWORD                       m_StartOfCurrentSipMsg;
    DWORD                       m_BytesParsed;
    
    ///// Context related to send.
    BOOL                        m_WaitingToSend;
    DWORD                       m_BytesSent;
    // Queue of buffers to be sent.
    // If another send is issued while we are currently processing
    // a send request on this socket, the buffer is added to the queue
    // and will be sent after the current send request completes.
    LIST_ENTRY                  m_SendPendingQueue;

    DWORD                       m_SocketError;
    
    ///// Context related to connect.
    CONNECTION_STATE            m_ConnectionState;

    // Linked list of CONNECT_COMPLETION_LIST_NODE
    // If a connection is pending the connect completion interface
    // is added to this list. Once the connection is complete (with
    // success or error) all the notification interfaces in this
    // list are notified.
    LIST_ENTRY                  m_ConnectCompletionList;

    // Linked list of ERROR_NOTIFICATION_LIST_NODE
    // All users of sockets should add an error notification interface
    // to this list. If there is an error on the socket, then all the
    // interfaces in this list are notified and the socket is closed.
    LIST_ENTRY                  m_ErrorNotificationList;
    
    ///// Context related to accept.
    ACCEPT_COMPLETION_INTERFACE *m_pAcceptCompletion;
    
    ///// Context related to SSL.
    
    // SECURITY_STATE               m_SecurityState;

    PWSTR                        m_SecurityRemotePrincipalName;
    CredHandle                   m_SecurityCredentials;
    TimeStamp                    m_SecurityCredentialsExpirationTime;
    CtxtHandle                   m_SecurityContext;
    TimeStamp                    m_SecurityContextExpirationTime;
    SecPkgContext_StreamSizes    m_SecurityContextStreamSizes;

    // m_SSLRecvBuffer is a buffer used to receive data from the
    // socket in SSL mode. The decrypted data is stored in m_RecvBuffer.
    // length is SSL_RECV_BUFFER_SIZE
    PSTR                         m_SSLRecvBuffer;
    ULONG                        m_SSLRecvBufLen;
    ULONG                        m_SSLBytesReceived;
    ULONG                        m_SSLRecvDecryptIndex;

    ///// Callbacks
    
    void OnRecvReady(
        IN int Error
        );

    void OnRecvComplete(
        IN DWORD ErrorCode,
        IN DWORD BytesRcvd
        );

    void OnSendReady(
        IN int Error
        );

    // Only called for TCP sockets
    void OnConnectReady(
        IN int Error
        );

    // Only called for TCP sockets
    void OnAcceptReady(
        IN int Error
        );

    // Only called for TCP sockets
    void OnCloseReady(
        IN int Error
        );

    void NotifyConnectComplete(
        IN DWORD Error
        );
    
    void NotifyError(
        IN DWORD Error
        );

    void OnError(
        IN DWORD Error
        );
    
    void OnConnectError(
        IN DWORD Error
        );
    
    ///// Helper functions

    void  ParseAndProcessSipMsg();
    
    // For a TCP listen socket, we need to listen for the
    // FD_ACCEPT event alone.
    DWORD CreateSocketWindowAndSelectEvents();
    
    DWORD CreateRecvBuffer();
    
    DWORD SetSocketAndSelectEvents(
        IN SOCKET Socket
        );
    
    void  SetRemoteAddr(
        IN SOCKADDR_IN *pRemoteAddr
        );
    
    DWORD SendOrQueueIfSendIsBlocking(
        IN SEND_BUFFER                 *pParamSendBuffer
        );
    
    DWORD CreateSendBufferAndSend(
        IN  PSTR           InputBuffer,
        IN  ULONG          InputBufLen
        );
    
    DWORD SendHelperFn(
        IN  SEND_BUFFER *pSendBuffer
        );
    
    void ProcessPendingSends(
        IN DWORD Error
        );
    
    DWORD RecvHelperFn(
        OUT DWORD *pBytesRcvd
        );
    
    void AsyncProcessSipMsg(
        IN SIP_MESSAGE *pSipMsg
        );
    
    HRESULT AcquireCredentials(
        IN  DWORD       ConnectFlags
        );
    
    void AdvanceNegotiation();

    HRESULT GetHttpProxyResponse(
        IN ULONG BytesReceived
        );
    HRESULT SendHttpConnect();

    HRESULT DecryptSSLRecvBuffer();
    
    DWORD EncryptSendBuffer(
        IN  PSTR           InputBuffer,
        IN  ULONG          InputBufLen,
        OUT SEND_BUFFER  **ppEncryptedSendBuffer
        );

#if DBG
    void DumpContextInfo(
        IN  DWORD DbgLevel
        );
#endif // DBG

};


inline BOOL
ASYNC_SOCKET::IsSocketOpen()
{
    return (m_Socket != NULL && m_SocketError == NO_ERROR);
}


inline CONNECTION_STATE
ASYNC_SOCKET::GetConnectionState()
{
    return m_ConnectionState;
}


inline SOCKET
ASYNC_SOCKET::GetSocket()
{
    return m_Socket;
}


inline SIP_TRANSPORT
ASYNC_SOCKET::GetTransport()
{
    return m_Transport;
}

#endif // __sipcli_asock_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\asyncwi.h ===
#ifndef __sipcli_asyncwi_h__
#define __sipcli_asyncwi_h__

#define WORKITEM_WINDOW_CLASS_NAME              \
    _T("WorkItemWindowClass-c4572861-a2f6-41bd-afae-92538b59267b")

#define WORKITEM_COMPLETION_WINDOW_CLASS_NAME   \
    _T("WorkitemCompletionWindowClass-0ade6260-d1b4-483a-ae9d-42277907e898")


// This class should store all the windows etc
// and should be a member of the sip stack.
class ASYNC_WORKITEM_MGR
{
public:

    ASYNC_WORKITEM_MGR();
    ~ASYNC_WORKITEM_MGR();
    
    HRESULT Start();
    HRESULT Stop();
    
    HRESULT CreateWorkItemWindow();
    VOID DestroyWorkItemWindow();

    VOID ShutdownWorkItemThread();
    inline BOOL WorkItemThreadShouldStop();
    
    inline HWND GetWorkItemWindow();
    inline HWND GetWorkItemCompletionWindow();

private:
    HWND            m_WorkItemWindow;
    HWND            m_WorkItemCompletionWindow;

    HANDLE          m_WorkItemThreadHandle;
    DWORD           m_WorkItemThreadId;
    
    BOOL            m_WorkItemThreadShouldStop;
    // BOOL            m_WorkItemThreadHasStopped;

    HRESULT CreateWorkItemCompletionWindow();
    VOID DestroyWorkItemCompletionWindow();
    HRESULT StartWorkItemThread();
};


// This is an abstract base class providing the implemenation
// for processing of async work items.
// The following stuff specific to the work item needs to be
// implemented for each work item.
// Get WorkItemParam to start the work item
// (done in the main thread).
// Process WorkItemParam and obtain WorkItemResponse
// (done in the async work item thread).
// Process WorkItemResponse and make callback.
// (done in the main thread).

// Note that even though the work item object is accessed by
// the main thread and the async work item thread, they never
// access the same member at the same time.

class __declspec(novtable) ASYNC_WORKITEM
{
public:

    ASYNC_WORKITEM(
        IN ASYNC_WORKITEM_MGR *pWorkItemMgr
        );

    virtual ~ASYNC_WORKITEM();
    
    HRESULT StartWorkItem();
    
    VOID CancelWorkItem();

    VOID OnWorkItemComplete();

    VOID ProcessWorkItemAndPostResult();
    
    // virtual HRESULT GetWorkItemParam() = 0;

    virtual VOID ProcessWorkItem() = 0;
    
    virtual VOID NotifyWorkItemComplete() = 0;

private:

    ASYNC_WORKITEM_MGR     *m_pWorkItemMgr;
    BOOL                    m_WorkItemCanceled;

    inline HWND GetWorkItemWindow();
    inline HWND GetWorkItemCompletionWindow();

};

inline BOOL
ASYNC_WORKITEM_MGR::WorkItemThreadShouldStop()
{
    return m_WorkItemThreadShouldStop;
}

inline HWND
ASYNC_WORKITEM_MGR::GetWorkItemWindow()
{
    return m_WorkItemWindow;
}

inline HWND
ASYNC_WORKITEM_MGR::GetWorkItemCompletionWindow()
{
    return m_WorkItemCompletionWindow;
}


inline HWND
ASYNC_WORKITEM::GetWorkItemWindow()
{
    return m_pWorkItemMgr->GetWorkItemWindow();
}

inline HWND
ASYNC_WORKITEM::GetWorkItemCompletionWindow()
{
    return m_pWorkItemMgr->GetWorkItemCompletionWindow();
}





#endif // __sipcli_asyncwi_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\asyncwi.cpp ===
#include "precomp.h"
#include "asyncwi.h"

#define WM_ASYNC_WORKITEM_MESSAGE               (WM_USER + 0)
#define WM_ASYNC_WORKITEM_COMPLETION_MESSAGE    (WM_USER + 1)
#define WM_ASYNC_WORKITEM_SHUTDOWN_MESSAGE      (WM_USER + 2)

DWORD WINAPI
WorkItemThreadProc(
    IN LPVOID   pVoid
    )
{
    ENTER_FUNCTION("WorkItemThreadProc");
    
    HRESULT hr;
    ASYNC_WORKITEM_MGR *pWorkItemMgr;

    pWorkItemMgr = (ASYNC_WORKITEM_MGR *) pVoid;
    ASSERT(pWorkItemMgr != NULL);
    
    // Create workitem window
    hr = pWorkItemMgr->CreateWorkItemWindow();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateWorkItemWindow failed %x",
             __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "%s - creating window done - starting message loop",
         __fxName));
    // Do message loop.
    MSG msg;
    while ( 0 < GetMessage( &msg, 0, 0, 0 ) )
    {
        // TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    LOG((RTC_TRACE, "%s - Work item thread exiting ", __fxName));
    
    return 0;
}


// Process the work item, store the response
// and post the message to the main thread saying
// the request is complete.
// Do the processing required for the quit message
// and post a message back saying the async work item thread is done
// and quit.
LRESULT WINAPI
WorkItemWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    )
{
    ENTER_FUNCTION("WorkItemWindowProc");
    
    ASYNC_WORKITEM      *pWorkItem;
    ASYNC_WORKITEM_MGR  *pWorkItemMgr;

    switch (MessageID)
    {
    case WM_ASYNC_WORKITEM_MESSAGE:

        pWorkItem = (ASYNC_WORKITEM *) Parameter1;
        ASSERT(pWorkItem != NULL);
        
        LOG((RTC_TRACE, "%s processing WorkItem: %x",
             __fxName, pWorkItem));
        
        pWorkItem->ProcessWorkItemAndPostResult();

        return 0;
        
    case WM_ASYNC_WORKITEM_SHUTDOWN_MESSAGE:

        pWorkItemMgr = (ASYNC_WORKITEM_MGR *) Parameter1;
        
        LOG((RTC_TRACE, "%s processing shutdown WorkItemMgr: %x",
             __fxName, pWorkItemMgr));

        pWorkItemMgr->ShutdownWorkItemThread();
        
        return 0;
        
    default:
        return DefWindowProc(Window, MessageID, Parameter1, Parameter2);
    }
}


// Process the work item completion and make the callback
LRESULT WINAPI
WorkItemCompletionWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    )
{
    ENTER_FUNCTION("WorkItemCompletionWindowProc");
    
    ASYNC_WORKITEM *pWorkItem;

    switch (MessageID)
    {
                     
    case WM_ASYNC_WORKITEM_COMPLETION_MESSAGE:

        pWorkItem = (ASYNC_WORKITEM *) Parameter1;
        ASSERT(pWorkItem != NULL);
        
        LOG((RTC_TRACE, "%s processing WorkItemCompletion: %x",
             __fxName, pWorkItem));
        
        pWorkItem->OnWorkItemComplete();

        return 0;
        
    default:
        return DefWindowProc(Window, MessageID, Parameter1, Parameter2);
    }
}


HRESULT
RegisterWorkItemWindowClass()
{
    WNDCLASS    WindowClass;
    
    ZeroMemory(&WindowClass, sizeof WindowClass);

    WindowClass.lpfnWndProc     = WorkItemWindowProc;
    WindowClass.lpszClassName   = WORKITEM_WINDOW_CLASS_NAME;
    WindowClass.hInstance       = _Module.GetResourceInstance();

    if (!RegisterClass(&WindowClass))
    {
        DWORD Error = GetLastError();
        LOG((RTC_ERROR, "WorkItemWindowClass RegisterClass failed: %x", Error));
        // return E_FAIL;
    }

    LOG((RTC_TRACE, "Registering WorkItemWindowClass succeeded"));
    return S_OK;
}


HRESULT
RegisterWorkItemCompletionWindowClass()
{
    WNDCLASS    WindowClass;
    
    ZeroMemory(&WindowClass, sizeof WindowClass);

    WindowClass.lpfnWndProc     = WorkItemCompletionWindowProc;
    WindowClass.lpszClassName   = WORKITEM_COMPLETION_WINDOW_CLASS_NAME;
    WindowClass.hInstance       = _Module.GetResourceInstance();

    if (!RegisterClass(&WindowClass))
    {
        DWORD Error = GetLastError();
        LOG((RTC_ERROR, "WorkItemCompletion RegisterClass failed: %x", Error));
        // return E_FAIL;
    }

    LOG((RTC_TRACE, "registering WorkItemCompletionWindowClass succeeded"));
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// ASYNC_WORKITEM_MGR
///////////////////////////////////////////////////////////////////////////////


ASYNC_WORKITEM_MGR::ASYNC_WORKITEM_MGR()
{
    m_WorkItemWindow            = NULL;
    m_WorkItemCompletionWindow  = NULL;

    m_WorkItemThreadHandle      = NULL;
    m_WorkItemThreadId          = 0;
    
    m_WorkItemThreadShouldStop  = FALSE;
    // m_WorkItemThreadHasStopped  = FALSE;
}


ASYNC_WORKITEM_MGR::~ASYNC_WORKITEM_MGR()
{
    // Close the thread handle ?
}


HRESULT
ASYNC_WORKITEM_MGR::Start()
{
    ENTER_FUNCTION("ASYNC_WORKITEM_MGR::Start");
    
    HRESULT hr;

    // Create workitem completion window
    hr = CreateWorkItemCompletionWindow();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateWorkItemCompletionWindow failed %x",
             __fxName, hr));
        return hr;
    }
    
    // Start the thread.
    hr = StartWorkItemThread();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s StartWorkItemThread failed %x",
             __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "%s - succeeded", __fxName));
    return S_OK;
}


HRESULT
ASYNC_WORKITEM_MGR::CreateWorkItemWindow()
{
    DWORD Error;
    
    // Create the Timer Window
    m_WorkItemWindow = CreateWindow(
                           WORKITEM_WINDOW_CLASS_NAME,
                           NULL,
                           WS_DISABLED,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           NULL,           // No Parent
                           NULL,           // No menu handle
                           _Module.GetResourceInstance(),
                           NULL
                           );

    if (!m_WorkItemWindow)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "WorkItem window CreateWindow failed 0x%x",
             Error));
        return HRESULT_FROM_WIN32(Error);
    }

    // SetWindowLongPtr(m_WorkItemWindow, GWLP_USERDATA, (LONG_PTR)this);

    return S_OK;
}


HRESULT
ASYNC_WORKITEM_MGR::CreateWorkItemCompletionWindow()
{
    DWORD Error;
    
    // Create the Timer Window
    m_WorkItemCompletionWindow = CreateWindow(
                                     WORKITEM_COMPLETION_WINDOW_CLASS_NAME,
                                     NULL,
                                     WS_DISABLED,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     NULL,           // No Parent
                                     NULL,           // No menu handle
                                     _Module.GetResourceInstance(),
                                     NULL
                                     );
    
    if (!m_WorkItemCompletionWindow)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "WorkItemCompletion CreateWindow failed 0x%x",
             Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


VOID
ASYNC_WORKITEM_MGR::DestroyWorkItemWindow()
{
    ENTER_FUNCTION("ASYNC_WORKITEM_MGR::DestroyWorkItemWindow");

    if (m_WorkItemWindow != NULL)
    {
        if (!DestroyWindow(m_WorkItemWindow))
        {
            LOG((RTC_ERROR, "%s - Destroying WorkItem window failed %x",
                 __fxName, GetLastError()));
        }
        m_WorkItemWindow = NULL;
    }
}


VOID
ASYNC_WORKITEM_MGR::DestroyWorkItemCompletionWindow()
{
    ENTER_FUNCTION("ASYNC_WORKITEM_MGR::DestroyWorkItemCompletionWindow");
    
    if (m_WorkItemCompletionWindow != NULL)
    {
        if (!DestroyWindow(m_WorkItemCompletionWindow))
        {
            LOG((RTC_ERROR, "%s - Destroying WorkItemCompletion window failed %x",
                 __fxName, GetLastError()));
        }
        m_WorkItemCompletionWindow = NULL;
    }
}


HRESULT
ASYNC_WORKITEM_MGR::StartWorkItemThread()
{
    ENTER_FUNCTION("ASYNC_WORKITEM_MGR::StartWorkItemThread");
    
    DWORD Error;
    
    m_WorkItemThreadHandle = CreateThread(NULL,
                                          0,
                                          WorkItemThreadProc,
                                          this,
                                          0,
                                          &m_WorkItemThreadId);
    
    if (m_WorkItemThreadHandle == NULL)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "%s CreateThread failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


// Set a shared variable.
// Send an event to the thread to stop.
// The thread will send an event back when
// shutdown is complete.
HRESULT
ASYNC_WORKITEM_MGR::Stop()
{
    ENTER_FUNCTION("ASYNC_WORKITEM_MGR::Stop");

    DWORD Error;
    
    m_WorkItemThreadShouldStop = TRUE;

    if (!PostMessage(m_WorkItemWindow,
                     WM_ASYNC_WORKITEM_SHUTDOWN_MESSAGE,
                     (WPARAM) this, 0))
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "%s PostMessage failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    DWORD WaitStatus = WaitForSingleObject(m_WorkItemThreadHandle,
                                           INFINITE);
    if (WaitStatus != WAIT_OBJECT_0)
    {
        Error = GetLastError();
        LOG((RTC_ERROR,
             "%s WaitForSingleObject failed WaitStatus: %x Error: %x",
             __fxName, WaitStatus, Error));
    }
    
    CloseHandle(m_WorkItemThreadHandle);
    m_WorkItemThreadHandle = NULL;

    DestroyWorkItemCompletionWindow();

    return S_OK;
}


// To be called by the workitem thread only
// (when the main thread requests the work item thread to shutdown).
VOID
ASYNC_WORKITEM_MGR::ShutdownWorkItemThread()
{
    ENTER_FUNCTION("ASYNC_WORKITEM_MGR::ShutdownWorkItemThread");

    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    DestroyWorkItemWindow();
    
    PostQuitMessage(0);

    LOG((RTC_TRACE, "%s - done", __fxName));
}


///////////////////////////////////////////////////////////////////////////////
// ASYNC_WORKITEM
///////////////////////////////////////////////////////////////////////////////



ASYNC_WORKITEM::ASYNC_WORKITEM(
    IN ASYNC_WORKITEM_MGR *pWorkItemMgr
    ) :
    m_pWorkItemMgr(pWorkItemMgr),
    m_WorkItemCanceled(FALSE)
{
    LOG((RTC_TRACE, "Created Async workitem %x", this));
}


ASYNC_WORKITEM::~ASYNC_WORKITEM()
{
    LOG((RTC_TRACE, "deleting Async workitem %x", this));
}


// The user should set up the
// params before calling StartWorkItem().
HRESULT
ASYNC_WORKITEM::StartWorkItem()
{
    HRESULT hr;

    ENTER_FUNCTION("ASYNC_WORKITEM::StartWorkItem");
    
//      hr = GetWorkItemParam();
//      if (hr != S_OK)
//      {
//          LOG((RTC_ERROR, "%s GetWorkItemParam failed: %x",
//               __fxName, hr));
//          return hr;
//      }

    // Post the message to the work item thread.
    if (!PostMessage(GetWorkItemWindow(),
                     WM_ASYNC_WORKITEM_MESSAGE,
                     (WPARAM) this, 0))
    {
        DWORD Error = GetLastError();
        LOG((RTC_ERROR, "%s PostMessage failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    LOG((RTC_TRACE, "%s(%x) Done", __fxName, this));

    return S_OK;
}


VOID
ASYNC_WORKITEM::CancelWorkItem()
{
    ENTER_FUNCTION("ASYNC_WORKITEM::CancelWorkItem");
    
    LOG((RTC_TRACE, "%s - called this : %x ",
         __fxName, this));
    ASSERT(!m_WorkItemCanceled);
    m_WorkItemCanceled = TRUE;
}


VOID
ASYNC_WORKITEM::OnWorkItemComplete()
{
    ENTER_FUNCTION("ASYNC_WORKITEM::OnWorkItemComplete");
    
    LOG((RTC_TRACE, "%s(%x) Enter", __fxName, this)); 

    // If workitem hasn't been canceled,
    // make the callback with the result.
    if (!m_WorkItemCanceled)
    {
        NotifyWorkItemComplete();
    }
    else
    {
        LOG((RTC_TRACE, "%s - workitem: %x has previously been canceled",
             __fxName, this));
    }

    LOG((RTC_TRACE, "%s(%x) Done", __fxName, this)); 

    // Delete the work item.
    delete this;    
}


VOID
ASYNC_WORKITEM::ProcessWorkItemAndPostResult()
{
    ENTER_FUNCTION("ASYNC_WORKITEM::ProcessWorkItemAndPostResult");

    // Note that we shouldn't access "this" once we post the
    // work item completion as the main thread will delete the
    // work item once it notices the completion.
    // So, we store this member.
    ASYNC_WORKITEM_MGR *pWorkItemMgr = m_pWorkItemMgr;
    
    if (pWorkItemMgr->WorkItemThreadShouldStop())
    {
        pWorkItemMgr->ShutdownWorkItemThread();
    }

    if (!m_WorkItemCanceled)
    {
        ProcessWorkItem();
        
        if (!PostMessage(GetWorkItemCompletionWindow(),
                         WM_ASYNC_WORKITEM_COMPLETION_MESSAGE,
                         (WPARAM) this, 0))
        {
            DWORD Error = GetLastError();
            LOG((RTC_ERROR, "%s PostMessage failed %x", __fxName, Error));
        }    

        if (pWorkItemMgr->WorkItemThreadShouldStop())
        {
            pWorkItemMgr->ShutdownWorkItemThread();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\asock.cpp ===
#include "precomp.h"
#include "sipstack.h"
#include "sipcall.h"


#define IsSecHandleValid(Handle) \
    !(((Handle) -> dwLower == -1 && (Handle) -> dwUpper == -1))

static __inline GetLastResult(void)
{ return HRESULT_FROM_WIN32(GetLastError()); }


// Note that the window is destroyed in the destructor and so
// a window message is delivered only if the socket is still valid.

LRESULT WINAPI
SocketWindowProc(
    IN HWND    Window, 
    IN UINT    MessageID,
    IN WPARAM  Parameter1,
    IN LPARAM  Parameter2
    )
{

    ASYNC_SOCKET *      pAsyncSocket;

    ENTER_FUNCTION("SocketWindowProc");

    switch (MessageID)
    {
    case WM_SOCKET_MESSAGE:

        pAsyncSocket = (ASYNC_SOCKET *) GetWindowLongPtr(Window, GWLP_USERDATA);

        if (pAsyncSocket == NULL)
        {
            LOG((RTC_ERROR, "%s Window %x does not have an associated socket",
                 __fxName, Window));
            return 0;
        }
        
        ASSERT(pAsyncSocket->GetSocket() == (SOCKET) Parameter1);
        
        LOG((RTC_TRACE, "WM_SOCKET_MESSAGE rcvd: Window %x pAsyncSocket: %x "
             "pAsyncSocket->GetSocket: %x Parameter1: %x",
             Window, pAsyncSocket, pAsyncSocket->GetSocket(), Parameter1));

        pAsyncSocket->ProcessNetworkEvent(WSAGETSELECTEVENT(Parameter2),
                                          WSAGETSELECTERROR(Parameter2));
        return 0;

    case WM_PROCESS_SIP_MSG_MESSAGE:

        pAsyncSocket = (ASYNC_SOCKET *) GetWindowLongPtr(Window, GWLP_USERDATA);

        if (pAsyncSocket == NULL)
        {
            LOG((RTC_ERROR, "%s Window %x does not have an associated socket",
                 __fxName, Window));
            return 0;
        }
        
        LOG((RTC_TRACE, "WM_PROCESS_SIP_MSG_MESSAGE rcvd: Window %x pAsyncSocket: %x "
             "pAsyncSocket->GetSocket: %x Parameter1: %x",
             Window, pAsyncSocket, pAsyncSocket->GetSocket(), Parameter1));

        pAsyncSocket->ProcessSipMsg((SIP_MESSAGE *) Parameter1);

        return 0;

    default:
        return DefWindowProc(Window, MessageID, Parameter1, Parameter2);
    }
}


ASYNC_SOCKET::ASYNC_SOCKET(
    IN  SIP_STACK                   *pSipStack,
    IN  SIP_TRANSPORT                Transport,
    IN  ACCEPT_COMPLETION_INTERFACE *pAcceptCompletion
    ) : TIMER(pSipStack->GetTimerMgr())
{
    m_Signature             = 'SOCK';

    m_ListEntry.Flink       = NULL;
    m_ListEntry.Blink       = NULL;
    
    ZeroMemory(&m_LocalAddr, sizeof(SOCKADDR_IN));
    ZeroMemory(&m_RemoteAddr, sizeof(SOCKADDR_IN));

    m_pSipStack             = pSipStack;
    m_pSipStack->AddRef();
    
    m_RefCount              = 1;
    m_Window                = NULL;
    m_Socket                = NULL;
    m_Transport             = Transport;
    m_isListenSocket        = FALSE;

    m_RecvBuffer            = NULL;
    m_RecvBufLen            = 0;

    m_pSipMsg               = NULL;
    m_BytesReceived         = 0;
    m_StartOfCurrentSipMsg  = 0;
    m_BytesParsed           = 0;
    
    m_WaitingToSend         = FALSE;
    m_BytesSent             = 0;
    InitializeListHead(&m_SendPendingQueue);

    m_SocketError           = NO_ERROR;
    m_ConnectionState       = CONN_STATE_NOT_CONNECTED;
    
    InitializeListHead(&m_ConnectCompletionList);
    InitializeListHead(&m_ErrorNotificationList);
    
    m_pAcceptCompletion     = pAcceptCompletion;

    SecInvalidateHandle(&m_SecurityCredentials);
    SecInvalidateHandle(&m_SecurityContext);

    m_SecurityRemotePrincipalName = NULL;
    m_SSLRecvBuffer         = NULL;
    m_SSLRecvBufLen         = 0;
    m_SSLBytesReceived      = 0;
    m_SSLRecvDecryptIndex   = 0;

    m_SSLTunnelState        = SSL_TUNNEL_NOT_CONNECTED;
    m_SSLTunnelHost         = NULL;
    m_SSLTunnelPort         = 0;

}


// XXX Get rid of any send completion stuff
// There should be no connect completion / error notification
// interfaces in the list.
ASYNC_SOCKET::~ASYNC_SOCKET()
{
    // Close the socket and window.
    Close();

    if (m_ListEntry.Flink != NULL)
    {
        // Remove the socket from the list
        RemoveEntryList(&m_ListEntry);
    }

    if (m_pSipStack != NULL)
        m_pSipStack->Release();

    if (m_RecvBuffer != NULL)
        free(m_RecvBuffer);
    
    if (m_pSipMsg != NULL)
        delete m_pSipMsg;
    
    if (m_SSLTunnelHost != NULL)
        free(m_SSLTunnelHost);

    if( IsTimerActive() )
    {
        KillTimer();
    }

    ////////// Send related context.
    
    // Free all the buffers queued up in m_SendPendingQueue.
    SEND_BUF_QUEUE_NODE *pSendBufQueueNode;
    LIST_ENTRY *pListEntry = NULL;
    while (!IsListEmpty(&m_SendPendingQueue))
    {
        pListEntry = RemoveHeadList(&m_SendPendingQueue);
        pSendBufQueueNode = CONTAINING_RECORD(pListEntry,
                                             SEND_BUF_QUEUE_NODE,
                                             m_ListEntry);
        // DBGOUT((LOG_VERBOSE, "deleting pSendBufQueueNode: 0x%x",
        // pSendBufQueueNode));

        if (pSendBufQueueNode->m_pSendBuffer != NULL)
        {
            pSendBufQueueNode->m_pSendBuffer->Release();
        }

        delete pSendBufQueueNode;
        // XXX Should we make the callback here ?
    }

    ASSERT(IsListEmpty(&m_ConnectCompletionList));
    ASSERT(IsListEmpty(&m_ErrorNotificationList));    

    if (m_SecurityRemotePrincipalName != NULL)
    {
        free(m_SecurityRemotePrincipalName);
    }

    if (m_SSLRecvBuffer != NULL)
    {
        free(m_SSLRecvBuffer);
    }
    
    LOG((RTC_TRACE, "~ASYNC_SOCKET() this: %x done", this));
}


// We live in  a single-threaded world.
ULONG ASYNC_SOCKET::AddRef()
{
    m_RefCount++;

    LOG((RTC_TRACE, "ASYNC_SOCKET::AddRef(this - %x) - %d",
         this, m_RefCount));
    
    return m_RefCount;
}


ULONG ASYNC_SOCKET::Release()
{
    m_RefCount--;

    LOG((RTC_TRACE, "ASYNC_SOCKET::Release(this - %x) - %d",
         this, m_RefCount));
    
    if (m_RefCount != 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
        return 0;
    }
}


void
ASYNC_SOCKET::ProcessNetworkEvent(
    IN WORD NetworkEvent,
    IN WORD ErrorCode
    )
{
    // assert that only one bit is set.
    ASSERT(NetworkEvent != 0 && (NetworkEvent & (NetworkEvent - 1)) == 0);

    LOG((RTC_TRACE, "ASYNC_SOCKET::ProcessNetworkEvent event: %x ErrorCode: %x",
         NetworkEvent, ErrorCode));
    
    if (NetworkEvent & FD_READ) 
    {
        OnRecvReady(ErrorCode);
        return;
    }

    if (NetworkEvent & FD_WRITE)
    {
        OnSendReady(ErrorCode);
        return;
    }

    // TCP only
    if (NetworkEvent & FD_CONNECT)
    {
        OnConnectReady(ErrorCode);
        return;
    }

    // TCP only
    if (NetworkEvent & FD_ACCEPT)
    {
        OnAcceptReady(ErrorCode);
        return;
    }

    // TCP only
    if (NetworkEvent & FD_CLOSE)
    {
        OnCloseReady(ErrorCode);
        return;
    }
}


// For a TCP listen socket, we need to listen for the
// FD_ACCEPT event alone.
DWORD
ASYNC_SOCKET::CreateSocketWindowAndSelectEvents()
{
    DWORD Error;

    ENTER_FUNCTION("ASYNC_SOCKET::CreateSocketWindowAndSelectEvents");
    
    m_Window = CreateWindow(
                    SOCKET_WINDOW_CLASS_NAME,
                    NULL,
                    WS_DISABLED, // XXX Is this the right style ?
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL,           // No Parent
                    NULL,           // No menu handle
                    _Module.GetResourceInstance(),
                    NULL
                    );

    if (!m_Window)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "CreateWindow failed 0x%x", Error));
        return Error;
    }
    
    LOG((RTC_TRACE, "%s created socket window %d(0x%x) ",
         __fxName, m_Window, m_Window));
    
    SetWindowLongPtr(m_Window, GWLP_USERDATA, (LONG_PTR)this);

    LONG Events = 0;
    
    if (m_Transport == SIP_TRANSPORT_TCP ||
        m_Transport == SIP_TRANSPORT_SSL)
    {
        if (m_isListenSocket)
        {
            Events = FD_ACCEPT;
        }
        else
        {
            Events = FD_READ | FD_WRITE | FD_CONNECT | FD_CLOSE;
        }
    }
    else if (m_Transport == SIP_TRANSPORT_UDP)
    {
        //ASSERT(!IsListenSocket);
        Events = FD_READ | FD_WRITE;
    }

    int SelectReturn;
    SelectReturn = WSAAsyncSelect(m_Socket, m_Window,
                                  WM_SOCKET_MESSAGE, Events);
    if (SelectReturn == SOCKET_ERROR)
    {
        Error = WSAGetLastError();
        LOG((RTC_ERROR, "WSAAsyncSelect failed : 0x%x", Error));
        DestroyWindow(m_Window);
        return Error;
    }

    return NO_ERROR;
}


DWORD
ASYNC_SOCKET::CreateRecvBuffer()
{
    DWORD   RecvBufferSize = RECV_BUFFER_SIZE;

    if( m_isListenSocket && (m_Transport == SIP_TRANSPORT_UDP) )
    {
        //
        // Its 11000 to take care of the biggest provisioning/roaming info
        // packet we could get from the SIP proxy. 10000 bytes is the limit on
        // provisioning/roaming information
        //
        RecvBufferSize = 11000;
        LOG((RTC_TRACE, "allocating big 11K Recv Buffer" ));
    }

    if(m_Transport == SIP_TRANSPORT_SSL)
    {
        RecvBufferSize = SSL_RECV_BUFFER_SIZE;
        LOG((RTC_TRACE, "allocating SSL_RECV_BUFFER_SIZE Buffer" ));
    }

    m_RecvBuffer = (PSTR) malloc( RecvBufferSize );
    if (m_RecvBuffer == NULL)
    {
        LOG((RTC_ERROR, "allocating m_RecvBuffer failed"));
        return ERROR_OUTOFMEMORY;
    }
    
    m_RecvBufLen = RecvBufferSize;
    m_StartOfCurrentSipMsg = 0;
    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        m_SSLRecvBuffer = (PSTR) malloc(SSL_RECV_BUFFER_SIZE);
        if (m_SSLRecvBuffer == NULL)
        {
            LOG((RTC_ERROR, "allocating m_SSLRecvBuffer failed"));
            return ERROR_OUTOFMEMORY;
        }

        m_SSLRecvBufLen = SSL_RECV_BUFFER_SIZE;
    }

    m_pSipMsg = new SIP_MESSAGE();
    if (m_pSipMsg == NULL)
    {
        // We can not process the message.
        LOG((RTC_ERROR, "allocating m_pSipMsg failed"));
        return ERROR_OUTOFMEMORY;
    }
    
    return NO_ERROR;
}

// XXX Should probably set some socket options for LINGER etc.
// For a TCP listen socket, we need to listen for the
// FD_ACCEPT event alone.
DWORD
ASYNC_SOCKET::Create(
    IN BOOL IsListenSocket //  = FALSE
    )
{
    DWORD Error;
    int   SocketType;
    int   SocketProtocol;

    ENTER_FUNCTION("ASYNC_SOCKET::Create");

    m_isListenSocket = IsListenSocket;
    if (m_Transport == SIP_TRANSPORT_UDP)
    {
        SocketType      = SOCK_DGRAM;
        SocketProtocol  = IPPROTO_UDP;
    }
    else if (m_Transport == SIP_TRANSPORT_TCP ||
             m_Transport == SIP_TRANSPORT_SSL)
    {
        SocketType      = SOCK_STREAM;
        SocketProtocol  = IPPROTO_TCP;
    }
    else 
    {
        return RTC_E_SIP_TRANSPORT_NOT_SUPPORTED;
    }
    
    m_Socket = socket(AF_INET, SocketType, SocketProtocol);
    if (m_Socket == INVALID_SOCKET)
    {
        Error = WSAGetLastError();
        LOG((RTC_ERROR, "socket failed : 0x%x", Error));
        return Error;
    }

    Error = CreateRecvBuffer();
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR,
             "%s  CreateRecvBuffer failed %x", __fxName, Error));
        closesocket(m_Socket);
    }

    Error = CreateSocketWindowAndSelectEvents();
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR,
             "%s  CreateSocketWindowAndSelectEvents failed %x",
             __fxName, Error));
        closesocket(m_Socket);
    }

    LOG((RTC_TRACE,
         "%s succeeded - AsyncSocket: %x socket %d(0x%x) window: %x Transport: %d",
         __fxName, this, m_Socket, m_Socket, m_Window, m_Transport));
    
    return Error;
}


DWORD
ASYNC_SOCKET::SetSocketAndSelectEvents(
    IN SOCKET Socket
    )
{
    m_Socket = Socket;
    return CreateSocketWindowAndSelectEvents();
}

void
ASYNC_SOCKET::Close()
{
    ENTER_FUNCTION("ASYNC_SOCKET::Close");
    DWORD Error;
    if (m_Socket != NULL && m_Socket != INVALID_SOCKET)
    {
        closesocket(m_Socket);
        m_Socket = NULL;
    }

    if (m_Window != NULL)
    {
        SetWindowLongPtr(m_Window, GWLP_USERDATA, NULL);
        if (!DestroyWindow(m_Window))
        {
            Error = GetLastError();
            LOG((RTC_ERROR, "%s - Destroying socket window(%x) failed %x",
                 __fxName, m_Window, Error));
        }
        m_Window = NULL;
    }

    // Clean up SSL state
    if (IsSecHandleValid(&m_SecurityCredentials))
    {
        FreeCredentialsHandle(&m_SecurityCredentials);
        SecInvalidateHandle(&m_SecurityCredentials);
    }

    if (IsSecHandleValid(&m_SecurityContext))
    {
        DeleteSecurityContext(&m_SecurityContext);
        SecInvalidateHandle(&m_SecurityContext);
    }

    if (m_SecurityRemotePrincipalName)
    {
        free(m_SecurityRemotePrincipalName);
        m_SecurityRemotePrincipalName = NULL;
    }
}


DWORD
ASYNC_SOCKET::Bind(
    IN SOCKADDR_IN  *pLocalAddr
    )
{
    int   BindReturn = 0;
    DWORD WinsockErr = NO_ERROR;

    ENTER_FUNCTION("ASYNC_SOCKET::Bind");
    
    LOG((RTC_TRACE, "%s - calling bind()", __fxName));
    
    BindReturn = bind(m_Socket, (SOCKADDR *) pLocalAddr, sizeof(SOCKADDR_IN));

    if (BindReturn == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "bind(%d.%d.%d.%d:%d) failed : 0x%x",
             PRINT_SOCKADDR(pLocalAddr), WinsockErr));
        return WinsockErr;
    }

    LOG((RTC_TRACE, "%s - bind() done", __fxName));
    
    if (pLocalAddr->sin_port != htons(0))
    {
        CopyMemory(&m_LocalAddr, pLocalAddr, sizeof(SOCKADDR_IN));
        return NO_ERROR;
    }
    else
    {
        return SetLocalAddr();
    }
}


DWORD
ASYNC_SOCKET::SetLocalAddr()
{
    int   GetsocknameReturn = 0;
    DWORD WinsockErr        = NO_ERROR;
    int   LocalAddrLen      = sizeof(m_LocalAddr);

    ENTER_FUNCTION("ASYNC_SOCKET::SetLocalAddr");
    
    // We need to call getsockname() after the connection is complete
    // and build any PDUs only after that.

    LOG((RTC_TRACE, "%s - calling getsockname()", __fxName));

    GetsocknameReturn = getsockname(m_Socket, (SOCKADDR *) &m_LocalAddr,
                                    &LocalAddrLen);
    
    if (GetsocknameReturn == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "getsockname failed : 0x%x", WinsockErr));
        return WinsockErr;
    }

    LOG((RTC_TRACE, "%s - getsockname() done", __fxName));
    
    LOG((RTC_TRACE, "ASYNC_SOCKET::SetLocalAddr done : %d.%d.%d.%d:%d",
         PRINT_SOCKADDR(&m_LocalAddr)));

    return NO_ERROR;
}


void
ASYNC_SOCKET::SetRemoteAddr(
    IN SOCKADDR_IN *pRemoteAddr
    )
{
    CopyMemory(&m_RemoteAddr, pRemoteAddr, sizeof(SOCKADDR_IN));
}



///////////////////////////////////////////////////////////////////////////////
// Send
///////////////////////////////////////////////////////////////////////////////


// XXX TODO Need to do an async OnError() here as we don't want to
// call the error notification interface within the context of the
// Send() call.
// Note that we need to notify all the users of this socket about
// this error.

DWORD
ASYNC_SOCKET::Send(
    IN SEND_BUFFER                 *pSendBuffer
    )
{
    DWORD        Error;
    SEND_BUFFER *pEncryptedSendBuffer = NULL;

    ENTER_FUNCTION("ASYNC_SOCKET::Send");
    
    // Check if have an error earlier
    if (m_SocketError != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s returning m_SocketError: %x",
             __fxName, m_SocketError));
        return m_SocketError;
    }

    if (m_ConnectionState != CONN_STATE_CONNECTED)
    {
        LOG((RTC_ERROR,
             "%s Send called in state %d - returning WSAENOTCONN",
             __fxName, m_ConnectionState));
        return WSAENOTCONN; // return private hresult code
    }
    
    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        Error = EncryptSendBuffer(pSendBuffer->m_Buffer,
                                  pSendBuffer->m_BufLen,
                                  &pEncryptedSendBuffer);
        if (Error != NO_ERROR)
        {
            LOG((RTC_ERROR, "%s EncryptSendBuffer failed %x",
                 __fxName, Error));
            return Error;
        }

        Error = SendOrQueueIfSendIsBlocking(pEncryptedSendBuffer);
        pEncryptedSendBuffer->Release();
        
        if (Error != NO_ERROR)
        {
            LOG((RTC_ERROR, "%s SendOrQueueIfSendIsBlocking failed %x",
                 __fxName, Error));
            return Error;
        }
    }
    else
    {
        Error = SendOrQueueIfSendIsBlocking(pSendBuffer);
        if (Error != NO_ERROR)
        {
            LOG((RTC_ERROR, "%s SendOrQueueIfSendIsBlocking failed %x",
                 __fxName, Error));
            return Error;
        }
    }

    return NO_ERROR;
}


DWORD
ASYNC_SOCKET::SendOrQueueIfSendIsBlocking(
    IN SEND_BUFFER                 *pSendBuffer
    )
{
    DWORD        WinsockErr;

    ENTER_FUNCTION("ASYNC_SOCKET::SendOrQueueIfSendIsBlocking");
    
    if (!m_WaitingToSend)
    {
        // If we are not currently executing a send operation, then we
        // need to send the buffer now.

        m_BytesSent = 0;
        WinsockErr = SendHelperFn(pSendBuffer);
        if (WinsockErr == NO_ERROR)
        {
            m_BytesSent = 0;
            return NO_ERROR;
        }
        else if (WinsockErr != WSAEWOULDBLOCK)
        {
            // XXX Notify everyone using this socket.
            m_SocketError = WinsockErr; 
            return WinsockErr;
        }
    }

    ASSERT(m_WaitingToSend);

    // Add the buffer to the pending send queue
    SEND_BUF_QUEUE_NODE *pSendBufQueueNode;
    pSendBufQueueNode = new SEND_BUF_QUEUE_NODE(pSendBuffer);
    if (pSendBufQueueNode == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating pSendBufQueueNode failed",
             __fxName));
        return ERROR_OUTOFMEMORY;
    }
    
    InsertTailList(&m_SendPendingQueue,
                   &pSendBufQueueNode->m_ListEntry);
    pSendBuffer->AddRef();
    // return WSAEWOULDBLOCK;
    // We implement the required processing for WSAEWOULDBLOCK error here
    // and so we return NO_ERROR.
    return NO_ERROR;
}


// Send the first one in the pending queue.
// Updates m_BytesSent and m_WaitingToSend
DWORD
ASYNC_SOCKET::SendHelperFn(
    IN  SEND_BUFFER *pSendBuffer
    )
{
    DWORD WinsockErr;
    DWORD SendReturn;

    ENTER_FUNCTION("ASYNC_SOCKET::SendHelperFn");
    
    // XXX BIG hack - see comment above
//      if (m_Transport == SIP_TRANSPORT_SSL)
//      {
//          SEND_BUFFER *pEncryptedSendBuffer;
//          HRESULT      hr;
        
//          hr = EncryptSendBuffer(pSendBuffer->m_Buffer,
//                                 pSendBuffer->m_BufLen,
//                                 &pEncryptedSendBuffer);
//          if (hr != S_OK)
//          {
//              LOG((RTC_ERROR, "%s EncryptSendBuffer failed %x",
//                   __fxName, hr));
//              return hr;
//          }

//          WinsockErr = SendHelperFnHack(m_Socket,
//                                        pEncryptedSendBuffer->m_Buffer,
//                                        pEncryptedSendBuffer->m_BufLen);
//          pEncryptedSendBuffer->Release();
//          if (WinsockErr != NO_ERROR)
//          {
//              LOG((RTC_ERROR, "%s SendHelperFnHack failed %x",
//                   __fxName, WinsockErr));
//              return WinsockErr;
//          }

//          return NO_ERROR;
//      }
    while (m_BytesSent < pSendBuffer->m_BufLen)
    {
        SendReturn = send(m_Socket, pSendBuffer->m_Buffer + m_BytesSent,
                          pSendBuffer->m_BufLen - m_BytesSent, 0);
        if (SendReturn == SOCKET_ERROR)
        {
            WinsockErr = WSAGetLastError();
            LOG((RTC_ERROR, "%s - send failed 0x%x",
                 __fxName, WinsockErr));
            if (WinsockErr == WSAEWOULDBLOCK)
            {
                m_WaitingToSend = TRUE;
            }
            return WinsockErr;
        }

        m_BytesSent += SendReturn;
    }

    return NO_ERROR; 
}


DWORD
ASYNC_SOCKET::CreateSendBufferAndSend(
    IN  PSTR           InputBuffer,
    IN  ULONG          InputBufLen
    )
{
    PSTR         OutputBuffer;
    DWORD        Error;
    SEND_BUFFER *pSendBuffer;

    ENTER_FUNCTION("ASYNC_SOCKET::CreateSendBufferAndSend");
    
    OutputBuffer = (PSTR) malloc(InputBufLen);

    if (OutputBuffer == NULL)
    {
        LOG((RTC_ERROR, "%s : failed to allocate send buffer %d bytes",
             __fxName, InputBufLen));
        return ERROR_OUTOFMEMORY;
    }

    CopyMemory (OutputBuffer, InputBuffer, InputBufLen);

    pSendBuffer = new SEND_BUFFER(OutputBuffer, InputBufLen);
    if (pSendBuffer == NULL)
    {
        LOG((RTC_ERROR, "%s : failed to allocate send buffer",
             __fxName));
        free(OutputBuffer);
        return ERROR_OUTOFMEMORY;
    }

    Error = SendOrQueueIfSendIsBlocking(pSendBuffer);

    pSendBuffer->Release();
        
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s SendOrQueueIfSendIsBlocking failed %x",
             __fxName, Error));
        return Error;
    }
    return NO_ERROR;
}


// if (WinsockErr == NO_ERROR) or if we hit a non-WSAEWOULDBLOCK error
// while sending a buffer, we just call the send completions for all
// the pending sends with the error.
// If there is an error, we just call the send completion function
// for each of the pending sends with the error.
// XXX TODO If there is an error we should just call OnError()

void
ASYNC_SOCKET::ProcessPendingSends(
    IN DWORD Error
    )
{
    DWORD WinsockErr = Error;
    ASSERT(Error != WSAEWOULDBLOCK);
    
    while (!IsListEmpty(&m_SendPendingQueue))
    {
        SEND_BUFFER                *pSendBuffer;
        SEND_BUF_QUEUE_NODE        *pSendBufQueueNode;
        LIST_ENTRY                 *pListEntry;
        
        pListEntry = m_SendPendingQueue.Flink;
        pSendBufQueueNode = CONTAINING_RECORD(pListEntry,
                                              SEND_BUF_QUEUE_NODE,
                                              m_ListEntry);
        pSendBuffer = pSendBufQueueNode->m_pSendBuffer;
        
        if (WinsockErr == NO_ERROR)
        {
            WinsockErr = SendHelperFn(pSendBuffer);
        }

        if (WinsockErr == WSAEWOULDBLOCK)
        {
            return;
        }
        else
        {
            m_BytesSent = 0;
            pSendBuffer->Release();
            // XXX needs to be changed after moving to async resolution.
            // pSendCompletion->OnSendComplete(WinsockErr);
            RemoveEntryList(pListEntry);
            delete pSendBufQueueNode;
        }
    }
}


void
ASYNC_SOCKET::OnSendReady(
    IN int Error
    )
{
    DWORD WinsockErr;

    // ASSERT(m_WaitingToSend);
    ENTER_FUNCTION("ASYNC_SOCKET::OnSendReady");
    LOG((RTC_TRACE, "%s - Enter", __fxName));
    m_WaitingToSend = FALSE;
    ProcessPendingSends(Error);
        
//      if (m_Transport != SIP_TRANSPORT_SSL)
//      {
//          m_WaitingToSend = FALSE;
//          ProcessPendingSends(Error);
//      }
//      else
//      {
//          // LOG((RTC_ERROR, "ASYNC_SOCKET::OnSendReady SSL NYI"));
//          if (m_SecurityState == SECURITY_STATE_CONNECTED)
//          {
//              m_WaitingToSend = FALSE;
//              ProcessPendingSends(Error);
//          }
//      }
}


// Any pending sends with the send completion interface
// are canceled.
// The send completion interface is not called.
//  void
//  ASYNC_SOCKET::CancelPendingSends(
//      IN SEND_COMPLETION_INTERFACE   *pSendCompletion
//      )
//  {
//      LIST_ENTRY                 *pListEntry;
//      LIST_ENTRY                 *pListEntryNext;
//      SEND_BUF_QUEUE_NODE        *pSendBufQueueNode;

//      pListEntry = m_SendPendingQueue.Flink;
    
//      while (pListEntry != &m_SendPendingQueue)
//      {
//          pSendBufQueueNode = CONTAINING_RECORD(pListEntry,
//                                                SEND_BUF_QUEUE_NODE,
//                                                m_ListEntry);
//          pListEntryNext = pListEntry->Flink;
        
//          if (pSendBufQueueNode->m_pSendCompletion == pSendCompletion)
//          {
//              // Should we call the send completion interface ?
//              pSendBufQueueNode->m_pSendBuffer->Release();
//              RemoveEntryList(pListEntry);
//              delete pSendBufQueueNode;
//          }

//          pListEntry = pListEntryNext;
//      }
//  }



///////////////////////////////////////////////////////////////////////////////
// Recv
///////////////////////////////////////////////////////////////////////////////

// The recv completion interface is given to us when the socket is
// initialized.  As we receive data we keep sending the data to the
// Completion interface. We keep pumping data to the recv completion
// interface till we encounter an error. The data is received into
// the buffer given to us in the Recv() call.

// What should we do if we get an FD_READ event and we have no buffer.
// We should probably wait for the caller to pass in a buffer. We support
// a maximum of only one recv request for the socket.
// If we make it mandatory that the Recv() function has to be called in
// OnRecvComplete() then we can do all the receive processing in
// OnRecvReady() only.
// Recv() just sets the recv buffer. recv() is acutally called when FD_READ
// is notified. Note that the OnRecvComplete() call should always make
// a call to specify the recv buffer for the next recv().


DWORD
ASYNC_SOCKET::RecvHelperFn(
    OUT DWORD *pBytesRcvd
    )
{
    DWORD RecvReturn;
    DWORD WinsockErr;

    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        RecvReturn = recv(m_Socket, m_SSLRecvBuffer + m_SSLBytesReceived,
                          m_SSLRecvBufLen - m_SSLBytesReceived, 0);
    }
    else
    {
        RecvReturn = recv(m_Socket, m_RecvBuffer + m_BytesReceived,
                          m_RecvBufLen - m_BytesReceived, 0);
    }

    if (RecvReturn == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "recv failed 0x%x", WinsockErr));
        *pBytesRcvd = 0;
        return WinsockErr;
    }
    
    *pBytesRcvd = RecvReturn;
    return NO_ERROR;
}


void
ASYNC_SOCKET::OnRecvReady(
    IN int Error
    )
{
    if (Error != NO_ERROR)
    {
        OnRecvComplete(Error, 0);
        return;
    }

    DWORD WinsockErr;
    DWORD BytesRcvd = 0;

    if(m_SSLTunnelState == SSL_TUNNEL_PENDING &&
        (m_ConnectionState == CONN_STATE_SSL_NEGOTIATION_PENDING))
    {
        LOG((RTC_TRACE,"Receive response from tunnel proxy"));

    }

    WinsockErr = RecvHelperFn(&BytesRcvd);
    if (WinsockErr != WSAEWOULDBLOCK)
    {
        OnRecvComplete(WinsockErr, BytesRcvd);
    }
}


void
ASYNC_SOCKET::OnRecvComplete(
    IN DWORD ErrorCode,
    IN DWORD BytesRcvd
    )
{
    HRESULT hr;

    ENTER_FUNCTION("ASYNC_SOCKET::OnRecvComplete");

    LOG((RTC_TRACE, "ASYNC_SOCKET::OnRecvComplete ErrorCode: %x, BytesRcvd: %d",
         ErrorCode, BytesRcvd));
    
    if (ErrorCode != NO_ERROR || BytesRcvd == 0)
    {
        ASSERT(BytesRcvd == 0);

        LOG((RTC_ERROR, "OnRecvComplete Error: 0x%x(%d) BytesRcvd : %d",
             ErrorCode, ErrorCode, BytesRcvd));

        if( (m_Transport == SIP_TRANSPORT_SSL) && (m_SSLTunnelState == SSL_TUNNEL_PENDING)) {
            // handling for http tunnel
            // currently do nothing
        }

        // If we are currently parsing a TCP SIP message, then
        // we should set the IsEndOfData flag 

        else if ((m_Transport == SIP_TRANSPORT_TCP || m_Transport == SIP_TRANSPORT_SSL)
             && m_BytesReceived - m_StartOfCurrentSipMsg != 0)
        {
            hr = ParseSipMessageIntoHeadersAndBody(
                     m_RecvBuffer + m_StartOfCurrentSipMsg,
                     m_BytesReceived - m_StartOfCurrentSipMsg,
                     &m_BytesParsed,
                     TRUE,           // IsEndOfData
                     m_pSipMsg
                     );
            
            ASSERT(hr != S_FALSE);
            if (hr == S_OK)
            {
                LOG((RTC_TRACE,
                     "Processing last TCP message StartOfMsg: %d BytesParsed: %d ",
                     m_StartOfCurrentSipMsg, m_BytesParsed));
                m_pSipStack->ProcessMessage(m_pSipMsg, this);
            }
            // If parsing fails we drop the bytes.
            //Send 400
            if(m_pSipMsg != NULL && m_pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
            {
                LOG((RTC_TRACE,
                    "Dropping incoming Sip Message in asock, sending 400"));
                hr = m_pSipStack->CreateIncomingReqfailCall(GetTransport(), m_pSipMsg, this, 400);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "Asock::OnRecvComplete Sending 400 failed 0x%x", hr));
                }
            }

        }
        
        // Set the socket error. Any future calls on the socket
        // will be notified with this error.
        // XXX We should notify the error immediately.
        // m_SocketError = (ErrorCode != NO_ERROR) ? ErrorCode : WSAECONNRESET;
        //Do not close socket if it is UDP and a listen socket (Bug #337491)
        if (m_Transport != SIP_TRANSPORT_UDP || !m_isListenSocket)
            OnError((ErrorCode != NO_ERROR) ? ErrorCode : WSAECONNRESET);
        return;
    }
    
    if (m_Transport == SIP_TRANSPORT_SSL)
    {

        m_SSLBytesReceived += BytesRcvd;
        
        switch(m_ConnectionState)
        {
        case CONN_STATE_SSL_NEGOTIATION_PENDING:
            if(m_SSLTunnelState == SSL_TUNNEL_PENDING) {
                // should get response from proxy
                // undo the byte counts for buffer reuse
                m_SSLBytesReceived -= BytesRcvd;
                hr = GetHttpProxyResponse(BytesRcvd);
                if(hr != NO_ERROR) 
                {
                    LOG((RTC_ERROR,"%s get proxy response failed error %x",__fxName, hr));
                    OnError((hr != NO_ERROR) ? hr : WSAECONNRESET);
                    break;
                }
                m_SSLTunnelState = SSL_TUNNEL_DONE;
                AdvanceNegotiation();
            }
            else AdvanceNegotiation();
            break;

        case CONN_STATE_CONNECTED:
            hr = DecryptSSLRecvBuffer();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "DecryptSSLRecvBuffer failed %x", hr));
                // XXX close connection and notify everyone.
                OnError(hr);
                return;
            }
            ParseAndProcessSipMsg();
            break;

        default:
            ASSERT(FALSE);
            break;
        }
    }
    else
    {
        m_BytesReceived += BytesRcvd;
        ParseAndProcessSipMsg();
    }
}


// ProcessMessage() could some times end up in a modal dialog box
// which could return only after the user presses okay.  We don't
// the processing of the current buffer to block till this happens.
// So, the processing of each SIP message happens as a work item
// of its own.
void
ASYNC_SOCKET::AsyncProcessSipMsg(
    IN SIP_MESSAGE *pSipMsg
    )
{
    if (!PostMessage(m_Window,
                     WM_PROCESS_SIP_MSG_MESSAGE,
                     (WPARAM) pSipMsg, 0))
    {
        DWORD Error = GetLastError();
        
        LOG((RTC_ERROR,
             "ASYNC_SOCKET::AsyncProcessSipMsg PostMessage failed : %x",
             Error));
    }
}


// This method is called from SocketWindowProc
void
ASYNC_SOCKET::ProcessSipMsg(
    IN SIP_MESSAGE *pSipMsg
    )
{
    LOG((RTC_TRACE, "ASYNC_SOCKET::ProcessSipMsg"));
    m_pSipStack->ProcessMessage(pSipMsg, this);
    free(pSipMsg->BaseBuffer);
    delete pSipMsg;
}


void
ASYNC_SOCKET::ParseAndProcessSipMsg()
{
    HRESULT hr;

    ENTER_FUNCTION("ASYNC_SOCKET::ParseAndProcessSipMsg");

    if (m_StartOfCurrentSipMsg >= m_BytesReceived)
    {
        LOG((RTC_ERROR,
             "%s no new bytes to parse start: %d Bytesrcvd: %d - this shouldn't happen",
             __fxName, m_StartOfCurrentSipMsg, m_BytesReceived));
        return;
    }
    
    while (m_StartOfCurrentSipMsg < m_BytesReceived)
    {
        // This could be non-NULL if we have parsed part of SIP message.
        if (m_pSipMsg == NULL)
        {
            m_pSipMsg = new SIP_MESSAGE();
            if (m_pSipMsg == NULL)
            {
                // We can not process the message.
                LOG((RTC_ERROR, "%s allocating m_pSipMsg failed", __fxName));
                return;
            }
        }
        
        hr = ParseSipMessageIntoHeadersAndBody(
                 m_RecvBuffer + m_StartOfCurrentSipMsg,
                 m_BytesReceived - m_StartOfCurrentSipMsg,
                 &m_BytesParsed,
                 (m_Transport == SIP_TRANSPORT_UDP) ? TRUE : FALSE,
                 m_pSipMsg
                 );

        if (hr == S_OK)
        {
            SIP_MESSAGE *pSipMsg       = NULL;
            PSTR         NewBaseBuffer = NULL;
            
            LOG((RTC_TRACE,
                 "Processing message StartOfMsg: %d BytesParsed: %d ",
                 m_StartOfCurrentSipMsg, m_BytesParsed));

            NewBaseBuffer = (PSTR) malloc(m_BytesParsed);
            if (NewBaseBuffer == NULL)
            {
                LOG((RTC_ERROR, "%s Allocating NewBaseBuffer failed", __fxName));
                // Drop the message.
                m_StartOfCurrentSipMsg += m_BytesParsed;
                m_BytesParsed = 0;
                delete m_pSipMsg;
                m_pSipMsg = NULL;
                return;
            }

            CopyMemory(NewBaseBuffer,
                       m_RecvBuffer + m_StartOfCurrentSipMsg,
                       m_BytesParsed);

            pSipMsg = m_pSipMsg;
            m_pSipMsg = NULL;
            pSipMsg->SetBaseBuffer(NewBaseBuffer);

            AsyncProcessSipMsg(pSipMsg);

            m_StartOfCurrentSipMsg += m_BytesParsed;
            m_BytesParsed = 0;
        }
        else if (hr == S_FALSE)
        {
            // We need to receive more data before we can parse
            // a complete SIP message.
            //This means that we need to allocate more size for the recv buffer

            LOG((RTC_ERROR, "%s Parse sip message returned S_FALSE",
                 __fxName));
            break;
        }
        else
        {
            // We need to drop the message.
            // At this level of parsing something basic went wrong

            //Send 400
            if(m_pSipMsg != NULL && m_pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
            {
                LOG((RTC_TRACE,
                    "Dropping incoming Sip Message in asock, sending 400"));

                hr = m_pSipStack->CreateIncomingReqfailCall(GetTransport(),
                                                            m_pSipMsg, this, 400);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
                }
            }
            
            LOG((RTC_WARN,
                 "Failed to parse SIP message StartOfMsg: %d BytesReceived: %d hr: 0x%x",
                 m_StartOfCurrentSipMsg, m_BytesReceived, hr));
            DebugDumpMemory(m_RecvBuffer + m_StartOfCurrentSipMsg,
                            m_BytesReceived - m_StartOfCurrentSipMsg);

            m_BytesReceived = 0;
            m_StartOfCurrentSipMsg = 0;
            m_BytesParsed = 0;
            // Reuse the SIP_MESSAGE structure for the next message.
            m_pSipMsg->Reset();
            
            return;
        }
    }
    

    if (m_StartOfCurrentSipMsg == m_BytesReceived)
    {
        // This means we have parsed all the received data.
        // We can start receiving from the beginning of m_RecvBuffer again.
        // This is what we should hit for UDP always.
        m_BytesReceived = 0;
        m_StartOfCurrentSipMsg = 0;
    }
    else if (m_Transport == SIP_TRANSPORT_UDP)
    {
        ASSERT(hr == S_FALSE);
        //Send 400
        if(m_pSipMsg != NULL && m_pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
        {
            LOG((RTC_TRACE,
                "Dropping incoming Sip Message in asock, sending 400"));
            hr = m_pSipStack->CreateIncomingReqfailCall(GetTransport(), m_pSipMsg, this, 400);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "CreateIncomingReqfailCall failed 0x%x", hr));
            }
        }
        LOG((RTC_WARN,
             "Dropping incomplete UDP message StartOfMsg: %d BytesReceived: %d",
             m_StartOfCurrentSipMsg, m_BytesReceived));
        DebugDumpMemory(m_RecvBuffer + m_StartOfCurrentSipMsg,
                        m_BytesReceived - m_StartOfCurrentSipMsg);
        
        m_BytesReceived = 0;
        m_StartOfCurrentSipMsg = 0;
        m_BytesParsed = 0;
        // Reuse the SIP_MESSAGE structure for the next message.
        m_pSipMsg->Reset();
    }
    else
    {
        // For TCP we keep receiving into the same buffer.
        
        ASSERT(hr == S_FALSE);

        if (m_StartOfCurrentSipMsg > 0)
        {
            // We need to copy the partial SIP message to the beginning of the
            // buffer and recv() into the buffer.
            MoveMemory(m_RecvBuffer, m_RecvBuffer + m_StartOfCurrentSipMsg,
                       m_BytesReceived - m_StartOfCurrentSipMsg);
            m_BytesReceived -= m_StartOfCurrentSipMsg;
            m_StartOfCurrentSipMsg = 0;
            m_pSipMsg->SetBaseBuffer(m_RecvBuffer);
        }

        // Double the recv buffer if we have less than 400 bytes free.
        if (m_RecvBufLen - m_BytesReceived < 400)
        {
            //store temporary pointer
            PSTR tmpRecvBuffer = m_RecvBuffer;
            // Reallocate
            m_RecvBuffer = (PSTR) realloc(m_RecvBuffer, 
                                          2*m_RecvBufLen);
            if( m_RecvBuffer ==  NULL )
            {
                LOG((RTC_ERROR, "%s - realloc recv buffer failed", __fxName));
                //We are not freeing the recv buffer if realloc fails
                m_RecvBuffer = tmpRecvBuffer;
                // Drop the message.
                m_BytesReceived = 0;
                m_StartOfCurrentSipMsg = 0;
                m_BytesParsed = 0;
                // Reuse the SIP_MESSAGE structure for the next message.
                m_pSipMsg->Reset();
                return;
            }
            LOG((RTC_TRACE, "Doubling the Recv Buffer for TCP "
                 "new recv buf len: %d bytes received: %x",
                 m_RecvBufLen, m_BytesReceived));
            m_RecvBufLen *= 2;
            m_pSipMsg->SetBaseBuffer(m_RecvBuffer);
        }
    }
}




///////////////////////////////////////////////////////////////////////////////
// Connect
///////////////////////////////////////////////////////////////////////////////

DWORD
ASYNC_SOCKET::Connect(
    IN SOCKADDR_IN  *pDestSockAddr,
    IN LPCWSTR       RemotePrincipalName, // = NULL
    IN DWORD         ConnectFlags,         // = 0
    IN HttpProxyInfo *pHPInfo
    )
{
    int   ConnectReturn = 0;
    DWORD WinsockErr = NO_ERROR;
    ULONG CopyLength;
    HRESULT hr;

    ENTER_FUNCTION("ASYNC_SOCKET::Connect");

    ASSERT(m_ConnectionState == CONN_STATE_NOT_CONNECTED);
    
    SetRemoteAddr(pDestSockAddr);

    //
    // Store a copy of the remote principal name.
    // We need this during SSL negotiation in order to verify the expected identity of the peer.
    //

    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        if (!RemotePrincipalName)
        {
            LOG((RTC_ERROR, "%s: in SSL mode, RemotePrincipalName is required",
                 __fxName));
            return ERROR_INVALID_PARAMETER;
        }

        if (m_SecurityRemotePrincipalName)
            free(m_SecurityRemotePrincipalName);

        CopyLength = (wcslen(RemotePrincipalName) + 1) * sizeof(WCHAR);
        m_SecurityRemotePrincipalName = (PWSTR) malloc(CopyLength);
        if (m_SecurityRemotePrincipalName == NULL)
        {
            LOG((RTC_ERROR, "%s failed to allocate m_SecurityRemotePrincipalName",
                 __fxName));
            return ERROR_OUTOFMEMORY;
        }

        CopyMemory(m_SecurityRemotePrincipalName, RemotePrincipalName, CopyLength);
        // m_SecurityState = SECURITY_STATE_NEGOTIATING;

        ASSERT(!IsSecHandleValid (&m_SecurityCredentials));

        hr = AcquireCredentials(ConnectFlags);
        if (FAILED(hr))
        {
            LOG((RTC_ERROR, "%s AcquireCredentials failed: %x",
                 __fxName, hr));
            return ERROR_GEN_FAILURE; // XXX Result;
        }

        if(pHPInfo) 
        {
            m_SSLTunnelState = SSL_TUNNEL_PENDING;

            m_SSLTunnelHost = (PSTR)malloc(strlen(pHPInfo->pszHostName)+1);
            if(!m_SSLTunnelHost) 
            {
                LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
                return E_OUTOFMEMORY;
            }

            strcpy(m_SSLTunnelHost,pHPInfo->pszHostName);

            m_SSLTunnelPort = pHPInfo->usPort;

            LOG((RTC_TRACE,"%s uses SSL tunnel, host %s port %d",
                __fxName,m_SSLTunnelHost,m_SSLTunnelPort));
        }
    
    }
    else
    {
        // m_SecurityState = SECURITY_STATE_CLEAR;
    }

    LOG((RTC_TRACE, "%s - calling connect(socket: %x, destaddr: %d.%d.%d.%d:%d, port: %d)",
         __fxName, 
         m_Socket, 
         PRINT_SOCKADDR(pDestSockAddr), 
         ntohs(((SOCKADDR_IN*)pDestSockAddr)->sin_port)));
    
    ConnectReturn = connect(m_Socket, (SOCKADDR *) pDestSockAddr,
                            sizeof(SOCKADDR_IN));

    if (ConnectReturn == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        if (WinsockErr == WSAEWOULDBLOCK)
        {
            ASSERT(m_Transport != SIP_TRANSPORT_UDP);
            LOG((RTC_TRACE,
                 "%s connect returned WSAEWOULDBLOCK - waiting for OnConnectReady",
                 __fxName));
            m_ConnectionState = CONN_STATE_CONNECTION_PENDING;
        }
        else
        {
            LOG((RTC_ERROR, "%s connect(%d.%d.%d.%d:%d) failed : 0x%x",
                 __fxName, PRINT_SOCKADDR(pDestSockAddr), WinsockErr));
        }
        return WinsockErr;
    }

    LOG((RTC_TRACE, "%s - connect() done", __fxName));
    
    WinsockErr = SetLocalAddr();
    if (WinsockErr != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s - SetLocalAddr failed %x",
             __fxName, WinsockErr));
        return WinsockErr;
    }
    
    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        // This shouldn't ever happen as SSL is over TCP and so
        // connect() will return WSAEWOULDBLOCK here if successful.
        m_ConnectionState = CONN_STATE_SSL_NEGOTIATION_PENDING;
        if(m_SSLTunnelState == SSL_TUNNEL_PENDING) {
            LOG((RTC_TRACE,"%s sends http connect",__fxName));
            return SendHttpConnect();
        }
        AdvanceNegotiation();
    }
    else
    {
        m_ConnectionState = CONN_STATE_CONNECTED;
    }
    
    // m_WaitingToSend = FALSE;
    return NO_ERROR;
}


// If the connect fails then is it sufficient to notify all
// the pending send completions about the error.
// Does any one need to implement a connect completion at all ?
// Once the connection is established, FD_WRITE will also be
// notified and this will take care of sending the pending buffers.
void
ASYNC_SOCKET::OnConnectReady(
    IN int Error
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::OnConnectReady");
    LOG((RTC_TRACE, "%s - enter Error: %x",
         __fxName, Error));

    DWORD WinsockErr;

    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s - Error: %d dest: %d.%d.%d.%d:%d",
             __fxName, Error, PRINT_SOCKADDR(&m_RemoteAddr)));
        OnConnectError(Error);
        return;
    }

    WinsockErr = SetLocalAddr();
    if (WinsockErr != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s - SetLocalAddr failed %x",
             __fxName, WinsockErr));
        NotifyConnectComplete(Error);
        return;
    }
    
    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        // Start the SSL negotiation.
        ASSERT(IsSecHandleValid(&m_SecurityCredentials));
        ASSERT(!IsSecHandleValid(&m_SecurityContext));
        ASSERT(m_SSLRecvBuffer);

        m_ConnectionState = CONN_STATE_SSL_NEGOTIATION_PENDING;
        if(m_SSLTunnelState == SSL_TUNNEL_PENDING) {
            LOG((RTC_TRACE,"%s sends http connect",__fxName));
            Error = SendHttpConnect();
            if(Error != NO_ERROR) NotifyConnectComplete(Error);
            return;
        }
        AdvanceNegotiation();
    }
    else
    {
        m_ConnectionState = CONN_STATE_CONNECTED;
        NotifyConnectComplete(NO_ERROR);
    }
}


DWORD
ASYNC_SOCKET::AddToConnectCompletionList(
    IN CONNECT_COMPLETION_INTERFACE *pConnectCompletion
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::AddToConnectCompletionList");
    
    // Add the buffer to the pending send queue
    CONNECT_COMPLETION_LIST_NODE *pConnectCompletionListNode;
    pConnectCompletionListNode = new CONNECT_COMPLETION_LIST_NODE(
                                          pConnectCompletion);
    if (pConnectCompletionListNode == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating pConnectCompletionListNode failed",
             __fxName));
        return ERROR_OUTOFMEMORY;
    }
    
    InsertTailList(&m_ConnectCompletionList,
                   &pConnectCompletionListNode->m_ListEntry);

    return NO_ERROR;
}


// The connect completion interface is deleted from the queue.
// The connect completion interface is not called.
void
ASYNC_SOCKET::RemoveFromConnectCompletionList(
    IN CONNECT_COMPLETION_INTERFACE   *pConnectCompletion
    )
{
    LIST_ENTRY                      *pListEntry;
    LIST_ENTRY                      *pListEntryNext;
    CONNECT_COMPLETION_LIST_NODE    *pConnectCompletionListNode;

    pListEntry = m_ConnectCompletionList.Flink;
    
    while (pListEntry != &m_ConnectCompletionList)
    {
        pConnectCompletionListNode = CONTAINING_RECORD(
                                          pListEntry,
                                          CONNECT_COMPLETION_LIST_NODE,
                                          m_ListEntry);
        pListEntryNext = pListEntry->Flink;
        
        if (pConnectCompletionListNode->m_pConnectCompletion == pConnectCompletion)
        {
            RemoveEntryList(pListEntry);
            delete pConnectCompletionListNode;
        }

        pListEntry = pListEntryNext;
    }
}


void
ASYNC_SOCKET::NotifyConnectComplete(
    IN DWORD Error
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::NotifyConnectComplete");

    // The callbacks could release the reference on this socket causing
    // its deletion. So keep a reference to keep the socket alive till
    // this routine is done.
    AddRef();
    
    while (!IsListEmpty(&m_ConnectCompletionList))
    {
        CONNECT_COMPLETION_INTERFACE  *pConnectCompletion;
        CONNECT_COMPLETION_LIST_NODE  *pConnectCompletionListNode;
        LIST_ENTRY                    *pListEntry;
        
        pListEntry = RemoveHeadList(&m_ConnectCompletionList);
        pConnectCompletionListNode = CONTAINING_RECORD(
                                          pListEntry,
                                          CONNECT_COMPLETION_LIST_NODE,
                                          m_ListEntry);
        pConnectCompletion = pConnectCompletionListNode->m_pConnectCompletion;
        // if we succeeded, or failed without ssl tunnel, we proceed with error, 
        // otherwise we have an unexpected error (with ssl tunnel)
        pConnectCompletion->OnConnectComplete(((Error == NO_ERROR) || m_SSLTunnelState == SSL_TUNNEL_NOT_CONNECTED)?
            Error : RTC_E_SIP_SSL_TUNNEL_FAILED);
        delete pConnectCompletionListNode;
    }

    Release();
}


void
ASYNC_SOCKET::OnConnectError(
    IN  DWORD Error
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::OnConnectError");
    LOG((RTC_ERROR, "%s (0x%x) - enter", __fxName, Error));
    
    m_SocketError = Error;
    Close();
    NotifyConnectComplete(Error);
}


///////////////////////////////////////////////////////////////////////////////
// Accept
///////////////////////////////////////////////////////////////////////////////

// The accept completion interface is given to us when the socket is
// initialized. As we receive incoming connections we keep sending
// them to the Completion interface.  No one makes a accept request
// explicitly.

DWORD
ASYNC_SOCKET::Listen()
{
    int   ListenReturn = 0;
    DWORD WinsockErr   = NO_ERROR;
    
    ListenReturn = listen(m_Socket, SOMAXCONN);
    
    if (ListenReturn == SOCKET_ERROR)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "listen failed 0x%x", WinsockErr));
    }
    return WinsockErr;
}


// XXX TODO need to check whether m_pAcceptCompletion is NULL.
void
ASYNC_SOCKET::OnAcceptReady(
    IN int Error
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::OnAcceptReady");

    LOG((RTC_TRACE, "%s - enter ", __fxName));
    
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "OnAcceptReady Ready 0x%x", Error));
        if (m_pAcceptCompletion != NULL)
        {
            m_pAcceptCompletion->OnAcceptComplete(Error, NULL);
        }
        else
        {
            LOG((RTC_ERROR, "%s - m_pAcceptCompletion is NULL",
                 __fxName));
        }
        
        return;
    }

    DWORD       WinsockErr;
    SOCKADDR_IN RemoteAddr;
    int         RemoteAddrLen = sizeof(RemoteAddr);
    
    SOCKET NewSocket = accept(m_Socket, (SOCKADDR *) &RemoteAddr,
                              &RemoteAddrLen);
    if (NewSocket == INVALID_SOCKET)
    {
        WinsockErr = WSAGetLastError();
        LOG((RTC_ERROR, "accept failed 0x%x", WinsockErr));
        if (WinsockErr != WSAEWOULDBLOCK)
        {
            m_pAcceptCompletion->OnAcceptComplete(WinsockErr, NULL);
        }
        return;
    }

    LOG((RTC_TRACE, "%s  accepted new socket %d(0x%x)",
         __fxName, NewSocket, NewSocket));
    
    ASYNC_SOCKET *pAsyncSock = new ASYNC_SOCKET(m_pSipStack,
                                                SIP_TRANSPORT_TCP,
                                                NULL);
    if (pAsyncSock == NULL)
    {
        // we can not handle this new connection now.
        LOG((RTC_ERROR, "allocating pAsyncSock failed"));
        closesocket(NewSocket);
        m_pAcceptCompletion->OnAcceptComplete(ERROR_OUTOFMEMORY, NULL);
        return;
    }

    Error = pAsyncSock->SetSocketAndSelectEvents(NewSocket);
    if (Error != NO_ERROR)
    {
        // we can not handle this new connection now.
        pAsyncSock->Close();
        delete pAsyncSock;
        m_pAcceptCompletion->OnAcceptComplete(Error, NULL);
        return;
    }

    Error = pAsyncSock->CreateRecvBuffer();
    if (Error != NO_ERROR)
    {
        // we can not handle this new connection now.
        pAsyncSock->Close();
        delete pAsyncSock;
        m_pAcceptCompletion->OnAcceptComplete(Error, NULL);
        return;
    }

    Error = pAsyncSock->SetLocalAddr();
    if (Error != NO_ERROR)
    {
        // we can not handle this new connection now.
        pAsyncSock->Close();
        delete pAsyncSock;
        m_pAcceptCompletion->OnAcceptComplete(Error, NULL);
        return;
    }

    pAsyncSock->SetRemoteAddr(&RemoteAddr);

    pAsyncSock->m_ConnectionState = CONN_STATE_CONNECTED;
    
    m_pAcceptCompletion->OnAcceptComplete(NO_ERROR, pAsyncSock);

    LOG((RTC_TRACE, "%s - exit ", __fxName));
}


// Should we just call the send completions with the error ?
// Do we need to do anything else ?
// Do we need to do anything with the recv() ?
// XXX Should we close the socket if we encounter an error ?
// Once we get a FD_CLOSE we should not get an FD_SEND or FD_RECV ?
void
ASYNC_SOCKET::OnCloseReady(
    IN int Error
    )
{
    LOG((RTC_TRACE, "ASYNC_SOCKET::OnCloseReady - enter "));
    
    if (Error == NO_ERROR)
    {
        Error = WSAECONNRESET;
    }

    OnError(Error);
    
    LOG((RTC_TRACE, "ASYNC_SOCKET::OnCloseReady - exit "));
}


//  void
//  ASYNC_SOCKET::InternalDisconnect()
//  {
//      if (m_Socket != NULL)
//      {
//          Close();
//          ProcessPendingSends(WSAECONNRESET);
//          // NotifyDisconnect();
//      }
//  }


DWORD
ASYNC_SOCKET::AddToErrorNotificationList(
    IN ERROR_NOTIFICATION_INTERFACE *pErrorNotification
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::AddToConnectionCompletionQueue");
    
    // Add the buffer to the pending send queue
    ERROR_NOTIFICATION_LIST_NODE *pErrorNotificationListNode;
    pErrorNotificationListNode = new ERROR_NOTIFICATION_LIST_NODE(
                                          pErrorNotification);
    if (pErrorNotificationListNode == NULL)
    {
        LOG((RTC_ERROR, "%s - allocating pErrorNotificationListNode failed",
             __fxName));
        return ERROR_OUTOFMEMORY;
    }
    
    InsertTailList(&m_ErrorNotificationList,
                   &pErrorNotificationListNode->m_ListEntry);

    return NO_ERROR;
}


// The error notification interface is deleted from the queue.
// The error notification interface is not called.
void
ASYNC_SOCKET::RemoveFromErrorNotificationList(
    IN ERROR_NOTIFICATION_INTERFACE   *pErrorNotification
    )
{
    LIST_ENTRY                      *pListEntry;
    LIST_ENTRY                      *pListEntryNext;
    ERROR_NOTIFICATION_LIST_NODE    *pErrorNotificationListNode;

    pListEntry = m_ErrorNotificationList.Flink;
    
    while (pListEntry != &m_ErrorNotificationList)
    {
        pErrorNotificationListNode = CONTAINING_RECORD(
                                          pListEntry,
                                          ERROR_NOTIFICATION_LIST_NODE,
                                          m_ListEntry);
        pListEntryNext = pListEntry->Flink;
        
        if (pErrorNotificationListNode->m_pErrorNotification == pErrorNotification)
        {
            RemoveEntryList(pListEntry);
            delete pErrorNotificationListNode;
        }

        pListEntry = pListEntryNext;
    }
}


// XXX TODO Should we do async notification of error/connect completion
// similar to async processing of messages - Note that an error
// notification could result in a dialog box being shown and this
// could result in the call getting stuck for a long time.
// I think the right solution would be to have non-blocking callbacks to
// the UI/Core.

void
ASYNC_SOCKET::NotifyError(
    IN DWORD Error
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::NotifyError");
    
    LOG((RTC_ERROR, "%s (%x) this: %x - Enter", __fxName, Error, this));
    
    // The callbacks could release the reference on this socket causing
    // its deletion. So keep a reference to keep the socket alive till
    // this routine is done.
    AddRef();
    
    while (!IsListEmpty(&m_ErrorNotificationList))
    {
        ERROR_NOTIFICATION_INTERFACE  *pErrorNotification;
        ERROR_NOTIFICATION_LIST_NODE  *pErrorNotificationListNode;
        LIST_ENTRY                    *pListEntry;
        
        pListEntry = RemoveHeadList(&m_ErrorNotificationList);
        pErrorNotificationListNode = CONTAINING_RECORD(
                                          pListEntry,
                                          ERROR_NOTIFICATION_LIST_NODE,
                                          m_ListEntry);
        pErrorNotification = pErrorNotificationListNode->m_pErrorNotification;
        
        pErrorNotification->OnSocketError(Error);
        delete pErrorNotificationListNode;
    }

    Release();

    LOG((RTC_ERROR, "%s this: %x - Exit", __fxName, this));
}


void
ASYNC_SOCKET::OnError(
    IN DWORD Error
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::OnError");
    LOG((RTC_ERROR, "%s (0x%x) - enter", __fxName, Error));

    if (m_ConnectionState != CONN_STATE_CONNECTED)
    {
        OnConnectError(Error);
    }
    else
    {
        m_SocketError = Error;
        Close();
        NotifyError(Error);
    }
}



///////////////////////////////////////////////////////////////////////////////
// SSL
///////////////////////////////////////////////////////////////////////////////


HRESULT ASYNC_SOCKET::AcquireCredentials(
    IN  DWORD       ConnectFlags
    )
{
    SECURITY_STATUS     Status;
    SCHANNEL_CRED       PackageData;

    ASSERT(m_Transport == SIP_TRANSPORT_SSL);
    ASSERT(!IsSecHandleValid(&m_SecurityCredentials));

    //
    // Acquire the credentials handle.
    //

    ZeroMemory(&PackageData, sizeof PackageData);

    PackageData.dwVersion = SCHANNEL_CRED_VERSION;
    PackageData.dwFlags = SCH_CRED_NO_DEFAULT_CREDS;

    if (ConnectFlags & CONNECT_FLAG_DISABLE_CERT_VALIDATION)
    {
        LOG((RTC_TRACE, "SECURE_SOCKET: WARNING! CERTIFICATE VALIDATION IS DISABLED!"));
        PackageData.dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
    }
    else
    {
        PackageData.dwFlags |= SCH_CRED_AUTO_CRED_VALIDATION;
    }

    Status = AcquireCredentialsHandle(
                 NULL,                           // name of principal (this user).  NULL means default user.
                 UNISP_NAME_W,                   // name of security package
                 SECPKG_CRED_OUTBOUND,           // direction of credential use
                 NULL,                           // logon ID (not used)
                 &PackageData,                   // package-specific data (not used)
                 //      NULL,                           // package-specific data (not used)
                 NULL, NULL,                     // get key function and parameter (not used)
                 &m_SecurityCredentials,         // return pointer
                 &m_SecurityCredentialsExpirationTime  // time when the credentials will expire
                 );

    if (Status != ERROR_SUCCESS)
    {
        LOG((RTC_ERROR, "APP: AcquireCredentialsHandle failed :%x", Status));

        SecInvalidateHandle(&m_SecurityCredentials);
        return HRESULT_FROM_WIN32(Status);
    }

    LOG((RTC_TRACE, "SECURE_SOCKET: acquired credentials"));

    return S_OK;
}


void ASYNC_SOCKET::AdvanceNegotiation()
{
    ULONG               ContextRequirements;
    ULONG               ContextAttributes;
    SecBufferDesc       OutputBufferDesc;
    SecBuffer           OutputBufferArray [1];
    PCtxtHandle         InputContextHandle;
    SecBufferDesc       InputBufferDesc;
    SecBuffer           InputBufferArray  [2];
    SECURITY_STATUS     Status;
    HRESULT             Result;
    ULONG               ExtraIndex;

    ExtraIndex = 0;

    do { // structured goto

        ASSERT(m_ConnectionState == CONN_STATE_SSL_NEGOTIATION_PENDING);

        // Initialize the security context.
        // This returns an initial buffer set for transmission.

        ContextRequirements = 0
            | ISC_REQ_REPLAY_DETECT
            | ISC_REQ_CONFIDENTIALITY
            | ISC_REQ_INTEGRITY
            | ISC_REQ_IDENTIFY
            | ISC_REQ_STREAM
            | ISC_REQ_ALLOCATE_MEMORY;

        ASSERT(m_SSLRecvBuffer);

        // Prepare the input buffers.
        // According to wininet sources, the SECBUFFER_EMPTY is for
        // collecting data that was not processed by SSPI.

        InputBufferDesc.ulVersion = SECBUFFER_VERSION;
        InputBufferDesc.cBuffers = 2;
        InputBufferDesc.pBuffers = InputBufferArray;

        ASSERT(ExtraIndex <= m_SSLBytesReceived);

        InputBufferArray[0].BufferType = SECBUFFER_TOKEN;
        InputBufferArray[0].cbBuffer = m_SSLBytesReceived - ExtraIndex;
        InputBufferArray[0].pvBuffer = m_SSLRecvBuffer + ExtraIndex;

        LOG((RTC_TRACE, "SECURE_SOCKET: submitting token to "
             "security context, %u bytes",
             InputBufferArray[0].cbBuffer));
        DebugDumpMemory(InputBufferArray[0].pvBuffer,
                        InputBufferArray[0].cbBuffer);

        // The provider changes SECBUFFER_EMPTY to SECBUFFER_EXTRA if
        // there was more data in the request than was needed to drive
        // the context state transition.

        InputBufferArray[1].BufferType = SECBUFFER_EMPTY;
        InputBufferArray[1].cbBuffer = 0;
        InputBufferArray[1].pvBuffer = NULL;

        // Prepare the output buffers.  During negotiation, we always
        // expect to extract a single output buffer, of type
        // SECBUFFER_TOKEN.  This is to be transmitted to the peer.

        OutputBufferDesc.ulVersion = SECBUFFER_VERSION;
        OutputBufferDesc.cBuffers = 1;
        OutputBufferDesc.pBuffers = OutputBufferArray;

        OutputBufferArray[0].pvBuffer = NULL;
        OutputBufferArray[0].cbBuffer = 0;
        OutputBufferArray[0].BufferType = SECBUFFER_TOKEN;

        
        InputContextHandle =
            IsSecHandleValid(&m_SecurityContext) ? &m_SecurityContext : NULL;

        // Initialize the security context

        Status = InitializeSecurityContext(
                     &m_SecurityCredentials,         // security credentials
                     InputContextHandle,             // input security context
                     m_SecurityRemotePrincipalName,  // name of the target of the context
                     ContextRequirements,            // context requirements
                     0,                              // reserved
                     SECURITY_NETWORK_DREP,          // data representation (byte ordering)
                     &InputBufferDesc,               // input buffers (if any)
                     0,                              // reserved
                     &m_SecurityContext,             // return security context
                     &OutputBufferDesc,              // return output buffers
                     &ContextAttributes,             // return context attributes (ISC_RET_*)
                     &m_SecurityContextExpirationTime
                     );

        switch (Status) {
        case    SEC_E_OK:
            // Negotiation has completed.

            LOG((RTC_TRACE, "SECURE_SOCKET: security negotiation has "
                 "completed successfully"));

            Status = QueryContextAttributes(&m_SecurityContext,
                                            SECPKG_ATTR_STREAM_SIZES,
                                            &m_SecurityContextStreamSizes);
            if (Status != SEC_E_OK)
            {
                LOG((RTC_ERROR, "SECURE_SOCKET: failed to get stream sizes"
                     " from context: %x", Status));
                OnConnectError(Status);
                return;
            }

            LOG((RTC_TRACE, "SECURE_SOCKET: stream sizes: header %u trailer"
                 " %u max message %u buffers %u block size %u",
                 m_SecurityContextStreamSizes.cbHeader,
                 m_SecurityContextStreamSizes.cbTrailer,
                 m_SecurityContextStreamSizes.cbMaximumMessage,
                 m_SecurityContextStreamSizes.cBuffers,
                 m_SecurityContextStreamSizes.cbBlockSize));

            // m_SecurityState = SECURITY_STATE_CONNECTED;
            m_ConnectionState = CONN_STATE_CONNECTED;

            break;

        case    SEC_E_INCOMPLETE_MESSAGE:
            // We have not yet received enough data from the network
            // to drive a transition in the state of the security
            // context.  Keep receiving data.

            LOG((RTC_TRACE, "SECURE_SOCKET: SEC_E_INCOMPLETE_MESSAGE,"
                 " will wait for more data from network"));

            // If we were processing data from a position other than
            // the start of the receive buffer, then we need to move
            // the data to the start of the buffer.

            if (ExtraIndex)
            {
                ASSERT(ExtraIndex <= m_SSLBytesReceived);

                MoveMemory(m_SSLRecvBuffer, m_SSLRecvBuffer + ExtraIndex,
                            m_SSLBytesReceived - ExtraIndex);
                m_SSLBytesReceived -= ExtraIndex;
            }

            return;

        case    SEC_I_CONTINUE_NEEDED:
            // This is the expected outcome of
            // InitializeSecurityContext during negotiation.

            LOG((RTC_TRACE, "SECURE_SOCKET: SEC_I_CONTINUE_NEEDED"));
            break;

        default:

#ifdef RTCLOG        
            // Although these states are legal negotiation return
            // codes for some security packages, these should never
            // occur for SSL.  Therefore, we don't consider them legal
            // here, and just abort the negotiation if we ever get one
            // of these.

            switch (Status)
            {
            case    SEC_I_COMPLETE_NEEDED:
                LOG((RTC_ERROR,
                     "SECURE_SOCKET: InitializeSecurityContext returned "
                     "SEC_I_COMPLETE_NEEDED -- never expected this to happen"));
                break;

            case    SEC_I_COMPLETE_AND_CONTINUE:
                LOG((RTC_ERROR, "SECURE_SOCKET: InitializeSecurityContext "
                     "returned SEC_I_COMPLETE_AND_CONTINUE -- never expected "
                     "this to happen"));
                break;

            case    SEC_E_INVALID_TOKEN:
                LOG((RTC_ERROR, "SECURE_SOCKET: InitializeSecurityContext"
                     " returned SEC_E_INVALID_TOKEN, token contents:"));

                DebugDumpMemory(InputBufferArray[0].pvBuffer,
                                 InputBufferArray[0].cbBuffer);
                break;
            }

#endif // #ifdef RTCLOG        

            LOG((RTC_ERROR, "SECURE_SOCKET: negotiation failed: %x", Status));
            OnConnectError(Status);
            return;
        }

#ifdef RTCLOG        
        DumpContextInfo(RTC_TRACE);
#endif // #ifdef RTCLOG        

        ASSERT(OutputBufferDesc.cBuffers == 1);
        ASSERT(OutputBufferDesc.pBuffers == OutputBufferArray);

        if (OutputBufferArray[0].pvBuffer)
        {
            // InitializeSecurityContext returned data which it
            // expects us to send to the peer security context.
            // Allocate a send buffer for it and send it.

            LOG((RTC_TRACE, "SECURE_SOCKET: InitializeSecurityContext "
                 "returned data (%u bytes):",
                 OutputBufferArray[0].cbBuffer));
            DebugDumpMemory ((PUCHAR) OutputBufferArray[0].pvBuffer,
                             OutputBufferArray[0].cbBuffer);

//              Result = SendHelperFnHack(m_Socket,
//                                        (PSTR) OutputBufferArray[0].pvBuffer,
//                                        OutputBufferArray[0].cbBuffer);

            Result = CreateSendBufferAndSend(
                         (PSTR) OutputBufferArray[0].pvBuffer,
                         OutputBufferArray[0].cbBuffer
                         );

            FreeContextBuffer(OutputBufferArray[0].pvBuffer);
            
            if (Result != NO_ERROR && Result != WSAEWOULDBLOCK)
            {
                LOG((RTC_ERROR, "SECURE_SOCKET: failed to send security "
                     "negotiation token"));

                OnConnectError(Result);
                return;
            }

            LOG((RTC_TRACE, "SECURE_SOCKET: sent security token to remote peer,"
                 " waiting for peer to respond..."));
        
            if( IsTimerActive() )
            {
                KillTimer();
            }
            Result = StartTimer(SSL_DEFAULT_TIMER);
            if (Result != S_OK)
            {
                LOG((RTC_ERROR, 
                    "ASYNC_SOCKET::AdvanceNegotiation - StartTimer failed %x", 
                    Result));
                OnConnectError(Result);
                return;
            }
        }

        // XXX TODO If the negotiation is already completed then the
        // extra buffer should probably be decrypted into a SIP message
        // and shouldn't be passed to InitializeSecurityContext() again.
        if (InputBufferArray[1].BufferType == SECBUFFER_EXTRA
            && InputBufferArray[1].cbBuffer > 0)
        {

            LOG((RTC_TRACE, "SECURE_SOCKET: security context consumed %u "
                 "bytes, returned %u extra bytes, repeating loop...",
                 InputBufferArray[0].cbBuffer - InputBufferArray[1].cbBuffer,
                 InputBufferArray[1].cbBuffer));

            ASSERT(InputBufferArray[0].cbBuffer == m_SSLBytesReceived - ExtraIndex);
            ASSERT(ExtraIndex + InputBufferArray[1].cbBuffer < m_SSLBytesReceived);

            ExtraIndex +=
                InputBufferArray[0].cbBuffer - InputBufferArray[1].cbBuffer;
            continue;
        }

        break;
        
    } while (TRUE);

    m_SSLBytesReceived = 0; // XXX

    if (m_ConnectionState == CONN_STATE_CONNECTED)
    {
        NotifyConnectComplete(NO_ERROR);
    }
}


// We shouldn't call OnError() within this function.
// The caller of this function should call OnError() if this
// function fails - do this after changing all error codes
// passed and returned to HRESULT
HRESULT
ASYNC_SOCKET::DecryptSSLRecvBuffer()
{
    SecBuffer           BufferArray[4];
    SecBufferDesc       BufferDesc;
    SECURITY_STATUS     Status;
    HRESULT             Result;

    ENTER_FUNCTION("ASYNC_SOCKET::DecryptSSLRecvBuffer");
    
    while (m_SSLRecvDecryptIndex < m_SSLBytesReceived)
    {
        // Is there more data waiting to be decrypted?

        BufferArray[0].BufferType = SECBUFFER_DATA;
        BufferArray[0].pvBuffer = m_SSLRecvBuffer + m_SSLRecvDecryptIndex;
        BufferArray[0].cbBuffer = m_SSLBytesReceived - m_SSLRecvDecryptIndex;
        BufferArray[1].BufferType = SECBUFFER_EMPTY;
        BufferArray[1].pvBuffer = NULL;
        BufferArray[1].cbBuffer = 0;
        BufferArray[2].BufferType = SECBUFFER_EMPTY;
        BufferArray[2].pvBuffer = NULL;
        BufferArray[2].cbBuffer = 0;
        BufferArray[3].BufferType = SECBUFFER_EMPTY;
        BufferArray[3].pvBuffer = NULL;
        BufferArray[3].cbBuffer = 0;
        
        BufferDesc.ulVersion = SECBUFFER_VERSION;
        BufferDesc.cBuffers = 4;
        BufferDesc.pBuffers = BufferArray;
        
        LOG((RTC_TRACE, "SECURE_SOCKET: decrypting buffer size: %d (first 0x200):",
             m_SSLBytesReceived - m_SSLRecvDecryptIndex));
        
        DebugDumpMemory(BufferArray[0].pvBuffer,
                        min(BufferArray[0].cbBuffer, 0x200));
        
        Status = DecryptMessage(&m_SecurityContext, &BufferDesc, 0, NULL);
#ifdef RTCLOG        
#define Dx(Index) 0 ? ((void)0) :                                             \
            LOG((RTC_TRACE, "- buffer [%u]: type %u length %u",               \
                 Index, BufferArray[Index].BufferType,                        \
                 BufferArray[Index].cbBuffer))
        Dx(0);
        Dx(1);
        Dx(2);
        Dx(3);
#undef  Dx
#endif

        if (!(Status == SEC_E_OK || Status == SEC_E_INCOMPLETE_MESSAGE))
        {
            LOG((RTC_ERROR, "SECURE_SOCKET: failed to decrypt message: %x",
                 Status));
            
            // This is really fatal.  We'll lose sync.
            // For now, though, we just truncate the data and return.
            
            m_SSLBytesReceived = 0;
            m_SSLRecvDecryptIndex = 0;
            
            LOG((RTC_ERROR, "SECURE_SOCKET: terminating connection due to "
                 "failure to decrypt"));
            return HRESULT_FROM_WIN32(Status);
        }
        
        // If you give DecryptMessage too little data for even one
        // message, then you get SEC_E_INCOMPLETE_MESSAGE, which
        // makes sense.  You're expected to accumulate more data,
        // then call DecryptMessage again.
        
        // However, if you call DecryptMessage with enough data
        // for more than one buffer (some overflow), then you
        // still get SEC_E_INCOMPLETE_MESSAGE!
        
        if (BufferArray[0].BufferType == SECBUFFER_STREAM_HEADER
            && BufferArray[1].BufferType == SECBUFFER_DATA
            && BufferArray[2].BufferType == SECBUFFER_STREAM_TRAILER)
        {
            // A buffer was successfully decrypted.
            // Store it in m_RecvBuffer.
            
            LOG((RTC_TRACE, "SECURE_SOCKET: decrypted message:"));
            DebugDumpMemory(BufferArray[1].pvBuffer,
                             BufferArray[1].cbBuffer);

            if (m_BytesReceived + BufferArray[1].cbBuffer > m_RecvBufLen)
            {
                // allocate bigger recv buffer
                PSTR NewRecvBuffer;
                NewRecvBuffer = (PSTR) malloc(m_BytesReceived + BufferArray[1].cbBuffer);
                if (NewRecvBuffer == NULL)
                {
                    LOG((RTC_ERROR, "%s  allocating NewRecvBuffer failed",
                         __fxName));
                    return E_OUTOFMEMORY;
                }

                m_RecvBufLen = m_BytesReceived + BufferArray[1].cbBuffer;

                CopyMemory(NewRecvBuffer, m_RecvBuffer, m_BytesReceived);
                free(m_RecvBuffer);
                m_RecvBuffer = NewRecvBuffer;
            }
            
            CopyMemory(m_RecvBuffer + m_BytesReceived, BufferArray[1].pvBuffer,
                       BufferArray[1].cbBuffer);
            m_BytesReceived += BufferArray[1].cbBuffer;
            
            //m_SSLRecvDecryptIndex +=
            //BufferArray[0].cbBuffer +
            //BufferArray[1].cbBuffer +
            //  BufferArray[2].cbBuffer;

            // XXX
            if (BufferArray[3].BufferType == SECBUFFER_EXTRA)
            {
                m_SSLRecvDecryptIndex =
                    m_SSLBytesReceived - BufferArray[3].cbBuffer;
            }
            else 
            {
                m_SSLRecvDecryptIndex +=
                    BufferArray[0].cbBuffer +
                    BufferArray[1].cbBuffer +
                    BufferArray[2].cbBuffer;
            }
            
            ASSERT(m_SSLRecvDecryptIndex <= m_SSLBytesReceived);
        }
        else if (Status == SEC_E_INCOMPLETE_MESSAGE &&
                 BufferArray[0].BufferType == SECBUFFER_MISSING)
        {
            // First check to see if we got too little data for even a single buffer.
            // SCHANNEL indicates this by returning the first two
            // (?!) buffers as SECBUFFER_MISSING.
            
            LOG((RTC_WARN, "SECURE_SOCKET: not enough data for first "
                 "message in buffer, need at least (%u %08XH) more bytes",
                 BufferArray[0].cbBuffer,
                 BufferArray[0].cbBuffer));
            
            // We need to receive more data
            break;
        }
        else
        {
            LOG((RTC_ERROR, "SECURE_SOCKET: not really sure what "
                 "to make of this, spazzing Status %x", Status));
            
            m_SSLRecvDecryptIndex = 0;
            m_SSLBytesReceived = 0;
            
            return RTC_E_SIP_SSL_TUNNEL_FAILED;
        }
    }

    if (m_SSLRecvDecryptIndex == m_SSLBytesReceived)
    {
        m_SSLRecvDecryptIndex = 0;
        m_SSLBytesReceived = 0;
    }
    else if (m_SSLRecvDecryptIndex > 0)
    {
        ASSERT(m_SSLRecvDecryptIndex <= m_SSLBytesReceived);

        MoveMemory(m_SSLRecvBuffer, m_SSLRecvBuffer + m_SSLRecvDecryptIndex,
                   m_SSLBytesReceived - m_SSLRecvDecryptIndex);
        m_SSLBytesReceived -= m_SSLRecvDecryptIndex;
        m_SSLRecvDecryptIndex = 0;
    }

    return S_OK;
}


DWORD
ASYNC_SOCKET::EncryptSendBuffer(
    IN  PSTR           InputBuffer,
    IN  ULONG          InputBufLen,
    OUT SEND_BUFFER  **ppEncryptedSendBuffer
    )
{
    SECURITY_STATUS     Status;
    HRESULT             Result;
    SecBuffer           BufferArray[0x10];
    SecBufferDesc       BufferDesc;
    PSTR                OutputBuffer;
    ULONG               OutputLength;

    ENTER_FUNCTION("ASYNC_SOCKET::EncryptSendBuffer");

    ASSERT(m_Socket != INVALID_SOCKET);

    // Right now, we do not support breaking large blocks into smaller
    // blocks.  If the application submits a buffer that is too large,
    // we just fail.

    if (InputBufLen > m_SecurityContextStreamSizes.cbMaximumMessage)
    {
        LOG((RTC_ERROR, "SECURE_SOCKET: send buffer is too large"
             " for security context -- rejecting"));
        return ERROR_GEN_FAILURE;
    }

    // Allocate enough space for the header, message body, and the trailer.

    OutputLength = InputBufLen +
        m_SecurityContextStreamSizes.cbHeader +
        m_SecurityContextStreamSizes.cbTrailer;

    OutputBuffer = (PSTR) malloc( OutputLength );

    if (OutputBuffer == NULL)
    {
        LOG((RTC_ERROR, "%s : failed to allocate send buffer %d bytes",
             __fxName, OutputLength));
        return ERROR_OUTOFMEMORY;
    }

    BufferArray[0].BufferType = SECBUFFER_STREAM_HEADER;
    BufferArray[0].cbBuffer = m_SecurityContextStreamSizes.cbHeader;
    BufferArray[0].pvBuffer = OutputBuffer;

    BufferArray[1].BufferType = SECBUFFER_DATA;
    BufferArray[1].cbBuffer = InputBufLen;
    BufferArray[1].pvBuffer =
        OutputBuffer + m_SecurityContextStreamSizes.cbHeader;

    BufferArray[2].BufferType = SECBUFFER_STREAM_TRAILER;
    BufferArray[2].cbBuffer = m_SecurityContextStreamSizes.cbTrailer;
    BufferArray[2].pvBuffer =
        OutputBuffer + m_SecurityContextStreamSizes.cbHeader + InputBufLen;

    BufferArray[3].BufferType = SECBUFFER_EMPTY;
    BufferArray[3].cbBuffer = 0;
    BufferArray[3].pvBuffer = NULL;

    BufferDesc.ulVersion = SECBUFFER_VERSION;
    BufferDesc.cBuffers = 4;
    BufferDesc.pBuffers = BufferArray;

    CopyMemory (BufferArray[1].pvBuffer, InputBuffer, InputBufLen);

    Status = EncryptMessage (&m_SecurityContext, 0, &BufferDesc, 0);
    if (Status != SEC_E_OK)
    {
        free(OutputBuffer);
        LOG((RTC_ERROR, "SECURE_SOCKET: failed to encrypt buffer: %x", Status));
        //return HRESULT_FROM_WIN32 (Status);
        return Status;
    }

    ASSERT(BufferArray[0].BufferType == SECBUFFER_STREAM_HEADER);
    ASSERT(BufferArray[0].cbBuffer == m_SecurityContextStreamSizes.cbHeader);
    ASSERT(BufferArray[1].BufferType == SECBUFFER_DATA);
    ASSERT(BufferArray[1].cbBuffer == InputBufLen);
    ASSERT(BufferArray[2].BufferType == SECBUFFER_STREAM_TRAILER);
    ASSERT(BufferArray[2].cbBuffer <= m_SecurityContextStreamSizes.cbTrailer);

    OutputLength = 
        BufferArray[0].cbBuffer + 
        BufferArray[1].cbBuffer +
        BufferArray[2].cbBuffer;

    LOG((RTC_TRACE, "SECURE_SOCKET: encrypted buffer input buffer (%u bytes):",
        InputBufLen));
    DebugDumpMemory(InputBuffer, InputBufLen);
    LOG((RTC_TRACE, "- encrypted buffer (%u bytes):",
        OutputLength));
    DebugDumpMemory (OutputBuffer, OutputLength);

    SEND_BUFFER *pSendBuffer = new SEND_BUFFER(OutputBuffer, OutputLength);
    if (pSendBuffer == NULL)
    {
        LOG((RTC_ERROR, "%s : failed to allocate send buffer %d bytes",
             __fxName, OutputLength));
        free(OutputBuffer);
        return ERROR_OUTOFMEMORY;
    }

    *ppEncryptedSendBuffer = pSendBuffer;
    return NO_ERROR;
}

VOID 
ASYNC_SOCKET::OnTimerExpire()
{
    //This timer is used only for SSL negotiation
    if(m_ConnectionState == CONN_STATE_SSL_NEGOTIATION_PENDING)
    {
       if (m_SSLTunnelState == SSL_TUNNEL_PENDING )
        {
            // we have sent the HTTPS connect, waiting for HTTP response
            LOG((RTC_ERROR, "ASYNC_SOCKET::OnTimerExpire - no HTTP response"
                            " received for HTTPS CONNECT tunneling request"));
            OnConnectError(RTC_E_SIP_SSL_TUNNEL_FAILED);
        }
        else
        {                           
            LOG((RTC_ERROR, 
            "ASYNC_SOCKET::OnTimerExpire - SSL socket still not connected"));
            OnConnectError(RTC_E_SIP_SSL_NEGOTIATION_TIMEOUT);
        }
    }
    return;
}

/////////////////////////////////////
// SSL Tunnel
/////////////////////////////////////

HRESULT
ASYNC_SOCKET::SendHttpConnect()
{
    DWORD dwResult;
    PSTR pszSendBuf;
    ULONG ulSendBufLen;
    HRESULT hr = S_OK;
    
    ENTER_FUNCTION("ASYNC_SOCKET::SendHttpConnect");
    LOG((RTC_TRACE,"%s entered",__fxName));
    
    ASSERT(m_SSLTunnelHost);
    // 83 = 77(request text) + 5(max digits of USHORT) + 1 (NULL)
    ulSendBufLen = 83+2*strlen(m_SSLTunnelHost);
    pszSendBuf = (PSTR)malloc(ulSendBufLen);
    if(!pszSendBuf) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        return E_OUTOFMEMORY;
    }
    
    ulSendBufLen = _snprintf(pszSendBuf,ulSendBufLen,
        "CONNECT %s:%d HTTP/1.0\r\nHost: %s\r\nProxy-Connection: Keep-Alive\r\nPragma: no-cache\r\n\r\n",
        m_SSLTunnelHost,m_SSLTunnelPort,m_SSLTunnelHost);
    LOG((RTC_TRACE,"%s send request:\r\n%ssize %d", 
        __fxName,pszSendBuf, ulSendBufLen));
    
    dwResult = CreateSendBufferAndSend(pszSendBuf,ulSendBufLen);
    // pszSendBuf should have been copied, free pszSendBuf
    free(pszSendBuf);

    if (dwResult != NO_ERROR && dwResult != WSAEWOULDBLOCK)
    {
        LOG((RTC_ERROR, "%s failed to send http connect", __fxName));
        return HRESULT_FROM_WIN32(dwResult);
    }

    ASSERT(!IsTimerActive());
    if (IsTimerActive())
    {
        LOG((RTC_WARN, "%s Timer already active, killing timer, this %p",
                        __fxName, this));
        hr = KillTimer();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s KillTimer failed %x, this %p",
                            __fxName, hr, this));
            return hr;
        }
    }
 
    hr = StartTimer(HTTPS_CONNECT_DEFAULT_TIMER);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s StartTimer failed %x, this %p",
                        __fxName, hr, this));
        return hr;
    }

//  AdvanceNegotiation();
    LOG((RTC_TRACE,"%s exits",__fxName));
    return NO_ERROR;
}

HRESULT
ASYNC_SOCKET::GetHttpProxyResponse(
    IN ULONG BytesReceived
    )
{
    ENTER_FUNCTION("ASYNC_SOCKET::GetProxyResponse");
    LOG((RTC_TRACE,"%s entered",__fxName));
    
    USHORT usStatusID;

    PSTR pszProxyResponse;
    PSTR pszResponseStatus;
    HRESULT hr = S_OK;

    ASSERT(IsTimerActive());
    if (!IsTimerActive())
    {
        LOG((RTC_ERROR, "%s timer is not active, this %p",
                        __fxName, this));
        return E_FAIL;
    }

    hr = KillTimer();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s KillTimer failed %x, this %p",
                        __fxName, hr, this));
        return hr;
    }

    pszProxyResponse = (PSTR)malloc(BytesReceived+1);
    if(!pszProxyResponse) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        return E_OUTOFMEMORY;
    }
    strncpy(pszProxyResponse,m_SSLRecvBuffer,BytesReceived);
    pszProxyResponse[BytesReceived]='\0';

    pszResponseStatus = (PSTR)malloc(4*sizeof(char));
    if(!pszResponseStatus) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        free(pszProxyResponse);
        return E_OUTOFMEMORY;
    }
    strncpy(pszResponseStatus,m_SSLRecvBuffer+9,3);
    pszResponseStatus[3]='\0';

    usStatusID = (USHORT)atoi(pszResponseStatus);
    if(usStatusID != 200) 
    {
        LOG((RTC_ERROR,"%s cannot connect to http proxy, status %d string %s",
            __fxName, usStatusID, pszResponseStatus));
        free(pszProxyResponse);
        free(pszResponseStatus);
        return RTC_E_SIP_SSL_TUNNEL_FAILED;
    }
        
    LOG((RTC_TRACE,"%s ProxyResponse:\r\n%s\nStatus: %d",
        __fxName,
        pszProxyResponse,
        usStatusID));
        
    free(pszProxyResponse);
    free(pszResponseStatus);
    return NO_ERROR;
}

#ifdef RTCLOG        

struct  STRING_TABLE_STRUCT
{
    ULONG       Value;
    LPCSTR     Text;
};

#define BEGIN_STRING_TABLE(Name) const static STRING_TABLE_STRUCT Name[] = {
#define END_STRING_TABLE() { 0, NULL } };
#define STRING_TABLE_ENTRY(Value) { Value, #Value },

BEGIN_STRING_TABLE(StringTable_Protocol)
    STRING_TABLE_ENTRY(SP_PROT_SSL2_CLIENT)
    STRING_TABLE_ENTRY(SP_PROT_SSL2_SERVER)
    STRING_TABLE_ENTRY(SP_PROT_SSL3_CLIENT)
    STRING_TABLE_ENTRY(SP_PROT_SSL3_SERVER)
    STRING_TABLE_ENTRY(SP_PROT_PCT1_CLIENT)
    STRING_TABLE_ENTRY(SP_PROT_PCT1_SERVER)
    STRING_TABLE_ENTRY(SP_PROT_TLS1_CLIENT)
    STRING_TABLE_ENTRY(SP_PROT_TLS1_SERVER)
END_STRING_TABLE()

BEGIN_STRING_TABLE(StringTable_Algorithm)
    STRING_TABLE_ENTRY(CALG_RC2)
    STRING_TABLE_ENTRY(CALG_RC4)
    STRING_TABLE_ENTRY(CALG_DES)
    STRING_TABLE_ENTRY(CALG_3DES)
    STRING_TABLE_ENTRY(CALG_SKIPJACK)
    STRING_TABLE_ENTRY(CALG_MD5)
    STRING_TABLE_ENTRY(CALG_SHA)
    STRING_TABLE_ENTRY(CALG_RSA_KEYX)
    STRING_TABLE_ENTRY(CALG_DH_EPHEM)
//  STRING_TABLE_ENTRY(CALG_EXCH_KEA)
END_STRING_TABLE()


static LPCSTR FindString (
    IN  CONST STRING_TABLE_STRUCT *     Table,
    IN  ULONG   Value)
{
    CONST STRING_TABLE_STRUCT * Pos;

    for (Pos = Table; Pos -> Text; Pos++) {
        if (Pos -> Value == Value)
            return Pos -> Text;
    }

    return NULL;
}

static LPCSTR
FindString2(
    IN  const STRING_TABLE_STRUCT *     Table,
    IN  ULONG   Value,
    IN  CHAR   Buffer[0x10]
    )
{
    CONST STRING_TABLE_STRUCT * Pos;

    for (Pos = Table; Pos -> Text; Pos++) {
        if (Pos -> Value == Value)
            return Pos -> Text;
    }

    _itoa(Value, Buffer, 10);
    return Buffer;
}



void
ASYNC_SOCKET::DumpContextInfo(
    IN  DWORD DbgLevel
    )
{
    SecPkgContext_ConnectionInfo        ConnectionInfo;
    SECURITY_STATUS     Status;
    CHAR                Buffer[0x10];
    LPCTSTR             Text;

    if (!IsSecHandleValid(&m_SecurityContext)) {
        LOG((DbgLevel, "SECURE_SOCKET: no security context has been created"));
        return;
    }

    Status = QueryContextAttributes(&m_SecurityContext, SECPKG_ATTR_CONNECTION_INFO, &ConnectionInfo);
    switch (Status) {
    case    SEC_E_OK:
        break;

    case    SEC_E_INVALID_HANDLE:
        // too early
        return;

    default:
        LOG((DbgLevel, "SECURE_SOCKET: failed to query context attributes: %x",
             Status));
        return;
    }

    LOG((DbgLevel, "SECURE_SOCKET: context connection info:"));

    LOG((DbgLevel, "- protocol: %s",
        FindString2(StringTable_Protocol, ConnectionInfo.dwProtocol, Buffer)));

    LOG((DbgLevel, "- cipher: %s, %u bits",
        FindString2(StringTable_Algorithm, ConnectionInfo.aiCipher, Buffer),
        ConnectionInfo.dwCipherStrength));

    LOG((DbgLevel, "- hash: %s, %u bits",
        FindString2(StringTable_Algorithm, ConnectionInfo.aiHash, Buffer),
        ConnectionInfo.dwHashStrength));

    LOG((DbgLevel, "- key exchange algorithm: %s, %u bits",
        FindString2(StringTable_Algorithm, ConnectionInfo.aiExch, Buffer),
        ConnectionInfo.dwExchStrength));

}

#endif //#ifdef RTCLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\dbgutil.h ===
#ifndef __sipcli_dbgutil_h__
#define __sipcli_dbgutil_h__

#ifdef ASSERT
#undef ASSERT
#endif // ASSERT

#ifdef ASSERTMSG
#undef ASSERTMSG
#endif // ASSERTMSG

#if defined(DBG)

__inline void SipAssert(LPCSTR file, DWORD line, LPCSTR condition, LPCSTR msg)
{
    LOG((RTC_ERROR,
         "Assertion FAILED : File: %s Line: %d, condition: %s %s%s",
         file, line, condition,
         (msg == NULL) ? "" : "Msg: ",
         (msg == NULL) ? "" : msg));
    DebugBreak();
}

#ifndef _PREFIX_

#define ASSERT(condition) if(condition);else\
    { SipAssert(__FILE__, __LINE__, #condition, NULL); }

#define ASSERTMSG(msg, condition) if(condition);else\
    { SipAssert(__FILE__, __LINE__, #condition, msg); }


#else // _PREFIX_

// Hack to work around prefix errors

#define ASSERT(condition)   if(condition);else exit(1)
#define ASSERTMSG(msg, condition)   if(condition);else exit(1)

#endif // _PREFIX_

void DebugDumpMemory (
	const void *	Data,
	ULONG			Length);

#else // DBG
// Retail build

#define ASSERT(condition)              ((void)0)
#define ASSERTMSG(msg, condition)      ((void)0)
#define	DebugDumpMemory(x,y)		((void)0)

#endif // DBG

#endif // __sipcli_dbgutil_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\dbgutil.cpp ===
#include "precomp.h"

#if defined(DBG)

static __inline CHAR ToHexA (UCHAR x)
{
    x &= 0xF;
    if (x < 10) return x + '0';
    return (x - 10) + 'A';
}


void DebugDumpMemory (
    IN const void      *Data,
    IN ULONG            Length
    )
{
    const UCHAR *   DataPos;        // position within data
    const UCHAR *   DataEnd;        // end of valid data
    const UCHAR *   RowPos;     // position within a row
    const UCHAR *   RowEnd;     // end of single row
    CHAR            Text    [0x100];
    LPSTR           TextPos;
    ULONG           RowWidth;
    ULONG           Index;

    ATLASSERT (Data != NULL || Length == 0);

    DataPos = (PUCHAR) Data;
    DataEnd = DataPos + Length;

    while (DataPos < DataEnd) {
        RowWidth = (DWORD)(DataEnd - DataPos);

        if (RowWidth > 16)
            RowWidth = 16;

        RowEnd = DataPos + RowWidth;

        TextPos = Text;
        *TextPos++ = '\t';

        for (RowPos = DataPos, Index = 0; Index < 0x10; Index++, RowPos++) {
            if (RowPos < RowEnd) {
                *TextPos++ = ToHexA ((*RowPos >> 4) & 0xF);
                *TextPos++ = ToHexA (*RowPos & 0xF);
            }
            else {
                *TextPos++ = ' ';
                *TextPos++ = ' ';
            }

            *TextPos++ = ' ';
        }

        *TextPos++ = ' ';
        *TextPos++ = ':';

        for (RowPos = DataPos; RowPos < RowEnd; RowPos++) {
            if (*RowPos < ' ')
                *TextPos++ = '.';
            else
                *TextPos++ = *RowPos;
        }

        //*TextPos++ = '\r';
        //*TextPos++ = '\n';
        *TextPos = 0;

        // OutputDebugStringA (Text);
        LOG((RTC_TRACE, "%s", Text));

        ATLASSERT (RowEnd > DataPos);       // make sure we are walking forward

        DataPos = RowEnd;
    }
}


void DumpSipMsg(
         IN DWORD        DbgLevel,
         IN SIP_MESSAGE *pSipMsg
         )
{
    LOG((DbgLevel, "Dumping SIP Message :\n"));
    LOG((DbgLevel, "MsgType    : %d\n", pSipMsg->MsgType));
    LOG((DbgLevel, "ParseState : %d\n", pSipMsg->ParseState));
    LOG((DbgLevel, "ContentLengthSpecified : %d\n", pSipMsg->ContentLengthSpecified));

    if (pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
    {
        LOG((DbgLevel, "MethodId : %d MethodText : %.*s\nRequest URI: %.*s\n",
               pSipMsg->Request.MethodId,
               pSipMsg->Request.MethodText.GetLength(),
               pSipMsg->Request.MethodText.GetString(pSipMsg->BaseBuffer),
               pSipMsg->Request.RequestURI.GetLength(),
               pSipMsg->Request.RequestURI.GetString(pSipMsg->BaseBuffer)));
    }
    else
    {
    }
    
    LIST_ENTRY        *pListEntry;
    SIP_HEADER_ENTRY  *pHeaderEntry;

    pListEntry = pSipMsg->m_HeaderList.Flink;

    while(pListEntry != &pSipMsg->m_HeaderList)
    {
        pHeaderEntry = CONTAINING_RECORD(pListEntry,
                                         SIP_HEADER_ENTRY,
                                         ListEntry);
        LOG((DbgLevel, "HeaderId: %d, HeaderName: %.*s, HeaderValue: %.*s HeaderValueLen: %d\n",
               pHeaderEntry->HeaderId,
               pHeaderEntry->HeaderName.GetLength(),
               pHeaderEntry->HeaderName.GetString(pSipMsg->BaseBuffer),
               pHeaderEntry->HeaderValue.GetLength(),
               pHeaderEntry->HeaderValue.GetString(pSipMsg->BaseBuffer),
               pHeaderEntry->HeaderValue.GetLength()
               ));
        pListEntry = pListEntry->Flink;
    }

    if (pSipMsg->MsgBody.Length != 0)
    {
        LOG((DbgLevel, "MsgBody: %.*s\n MsgBody Length: %d\n",
               pSipMsg->MsgBody.GetLength(),
               pSipMsg->MsgBody.GetString(pSipMsg->BaseBuffer),
               pSipMsg->MsgBody.GetLength()
               ));
    }
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\md5digest.h ===
#include "sipstack.h"

//
// SIP MD5 Digest Authentication Implementation
//
// Written by Arlie Davis, August 2000
//

#pragma once



//
// This method parses the parameters from the WWW-Authenticate line.
// DigestParametersText points to the string that contains the Digest 
// authentication parameters. For example, DigestParametersText could be:
//
//      qop="auth", realm="localhost", nonce="c0c3dd7896f96bba353098100000d03637928b037ba2f3f17ed861457949"
//

//  HRESULT DigestParseChallenge (
//      IN  ANSI_STRING *       ChallengeText,
//      OUT SECURITY_CHALLENGE *  ReturnChallenge);

//
// This method updates the state of the instance, based on the contents of a Digest
// challenge / response.
//
// DigestParameters should be filled in by using DigestParseParameters.
// This method builds an appropriate response to the challenge.
// The authorization line can be used in a new HTTP/SIP request,
// as long as the method and URI do not change.
//
// On entry, ReturnAuthorizationLine must point to a valid target buffer.
// MaximumLength must be set to the length of the buffer.  (Length is ignored.)
// On return, Length will contain the number of bytes stored.
//

//  HRESULT DigestBuildResponse (
//      IN  SECURITY_CHALLENGE *  DigestChallenge,
//      IN  DIGEST_PARAMETERS * DigestParameters,
//      IN  OUT ANSI_STRING *   ReturnAuthorizationLine);


//
// This method parses the parameters from the WWW-Authenticate line.
// DigestParametersText points to the string that contains the Digest 
// authentication parameters. For example, DigestParametersText could be:
//
//      qop="auth", realm="localhost", nonce="c0c3dd7896f96bba353098100000d03637928b037ba2f3f17ed861457949"
//

HRESULT ParseAuthProtocolFromChallenge(
    IN  ANSI_STRING        *ChallengeText,
    OUT ANSI_STRING        *ReturnRemainder, 
    OUT SIP_AUTH_PROTOCOL  *ReturnAuthProtocol
    );

HRESULT ParseAuthChallenge(
    IN  ANSI_STRING      *ChallengeText,
    OUT SECURITY_CHALLENGE *ReturnChallenge
    );


//
// This method updates the state of the instance, based on the contents of a Digest
// challenge / response.
//
// DigestParameters should be filled in by using DigestParseParameters.
// This method builds an appropriate response to the challenge.
// The authorization line can be used in a new HTTP/SIP request,
// as long as the method and URI do not change.
//
// On exit with S_OK ReturnAuthorizationLine contains
// a buffer allocated with malloc(). The caller should free it with free().

HRESULT BuildAuthResponse(
    IN     SECURITY_CHALLENGE  *pDigestChallenge,
    IN     SECURITY_PARAMETERS *pDigestParameters,
    IN OUT ANSI_STRING       *pReturnAuthorizationLine
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\dnssrv.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnssrv.c

Abstract:

    Routines for processing SRV DNS records per RFC 2052.

Author:

    Based on the code in net\netlib\dnssrv.c by
    Cliff Van Dyke (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#define	STRICT

#include "precomp.h"
#include <align.h>

#pragma warning( disable : 4214 )
#include <windns.h>
// #include <dnsapi.h>
#pragma warning( default : 4214 )

//
// Context describing the SRV records for a DNS name.
//
typedef struct _DNS_SRV_CONTEXT {

    //
    // Flags to pass to DNS Query.
    //

    ULONG DnsQueryFlags;

    //
    // Complete list of DNS records as returned from DnsQuery.
    //
    PDNS_RECORD DnsRecords;

    //
    // List of A DNS records
    //
    PDNS_RECORD ADnsRecords;

    //
    // The current priority that is being processed.
    //
    ULONG CurrentPriority;

    //
    // Sum of the weights of all the SRV records at the current priority.
    //
    ULONG TotalWeight;

    //
    // Index into SrvRecordArray of the next SRV record to be processed.
    //
    ULONG Index;

    //
    // Number of SrvRecords
    //
    ULONG SrvRecordCount;
    //
    // Array of DNS SRV records.
    //
    PDNS_RECORD SrvRecordArray[1];
    // This field must be the last field in the structure.

} DNS_SRV_CONTEXT, *PDNS_SRV_CONTEXT;

#if DNS_DEBUG
#include <stdio.h>
#define DnsPrint(_x_) printf _x_
#else // DNS_DEBUG
#define DnsPrint(_x_)
#endif // DNS_DEBUG



//
// Globals for doing random number generation.
//

ULONG DnsSrvSeed;
BOOLEAN DnsSrvRandomInitialized;

int
__cdecl
DnsSrvComparePriority(
    const void * Param1,
    const void * Param2
    )
/*++

Routine Description:

    qsort/bsearch comparison routine for an array of SRV PDNS_RECORDs

Arguments:

Return Value:

--*/
{
    const PDNS_RECORD DnsRecord1 = *((PDNS_RECORD *)Param1);
    const PDNS_RECORD DnsRecord2 = *((PDNS_RECORD *)Param2);

    return DnsRecord1->Data.SRV.wPriority - DnsRecord2->Data.SRV.wPriority;
}


HRESULT
DnsSrvOpen(
    IN LPSTR DnsRecordName,
    IN DWORD DnsQueryFlags,
    OUT PHANDLE RetSrvContext
    )
/*++

Routine Description:

    Read the specified SRV record from DNS.

Arguments:

    DnsRecordName - DNS name of the SRV record to lookup

    DnsQueryFlags - Flags to pass to DNS query

    RetSrvContext - Returns an opaque context describing the SRV record.
        This context must be freed using DnsSrvClose.

Return Value:

    Status of the operation.

    NO_ERROR: SrvContext was returned successfully.

--*/

{
    NET_API_STATUS NetStatus;
    PDNS_SRV_CONTEXT SrvContext = NULL;
    PDNS_RECORD DnsRecords = NULL;
    PDNS_RECORD DnsRecord;
    PDNS_RECORD ADnsRecords = NULL;
    ULONG SrvRecordCount;
    ULONG SrvPriority;
    BOOLEAN SortByPriority = FALSE;
    ULONG Index;

    //
    // Seed the random number generator if it needs to be.
    //

    if ( !DnsSrvRandomInitialized ) {

#ifndef WIN32_CHICAGO
        union {
            LARGE_INTEGER time;
            UCHAR bytes[8];
        } u;
#else // WIN32_CHICAGO
        union {
            TimeStamp time;
            UCHAR bytes[8];
        } u;
#endif // WIN32_CHICAGO

        DnsSrvRandomInitialized = TRUE;

        (VOID) NtQuerySystemTime( &u.time );
        DnsSrvSeed = ((u.bytes[1] + 1) <<  0) |
               ((u.bytes[2] + 0) <<  8) |
               ((u.bytes[2] - 1) << 16) |
               ((u.bytes[1] + 0) << 24);
    }


    //
    // Initialization
    //

    *RetSrvContext = NULL;

    //
    // Get the SRV record from DNS.
    //

    NetStatus = DnsQuery_A( DnsRecordName,
                            DNS_TYPE_SRV,
                            DnsQueryFlags,
                            NULL,   // No list of DNS servers
                            &DnsRecords,
                            NULL );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Count the number of Srv records returned
    //
    // The array returned is several SRV records followed by several A records.
    //

    SrvRecordCount = 0;
    SrvPriority = DnsRecords->Data.SRV.wPriority;
    for ( DnsRecord = DnsRecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        if ( DnsRecord->wType == DNS_TYPE_SRV ) {
            SrvRecordCount ++;

            //
            // A zero weight is equivalent to a weight of one.
            //

            if ( DnsRecord->Data.SRV.wWeight == 0 ) {
                DnsRecord->Data.SRV.wWeight = 1;
            }

            //
            // Check if more than one priority is available.
            //

            if ( DnsRecord->Data.SRV.wPriority != SrvPriority ) {
                SortByPriority = TRUE;
            }

        } else if ( DnsRecord->wType == DNS_TYPE_A ) {
            ADnsRecords = DnsRecord;
            break;
        }
    }


    //
    // Allocate a context
    //

    SrvContext = (PDNS_SRV_CONTEXT)LocalAlloc( LMEM_ZEROINIT,
                             sizeof(DNS_SRV_CONTEXT) +
                                SrvRecordCount * sizeof(PDNS_RECORD) );

    if ( SrvContext == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the context.
    //

    SrvContext->DnsRecords = DnsRecords;
    DnsRecords = NULL;
    SrvContext->SrvRecordCount = SrvRecordCount;
    SrvContext->ADnsRecords = ADnsRecords;
    SrvContext->DnsQueryFlags = DnsQueryFlags;

    //
    // Convert the linked list to an array.
    //

    Index = 0;
    for ( DnsRecord = SrvContext->DnsRecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        if ( DnsRecord->wType == DNS_TYPE_SRV ) {
            SrvContext->SrvRecordArray[Index] = DnsRecord;
            Index++;
        } else if ( DnsRecord->wType == DNS_TYPE_A ) {
            break;
        }
    }

    //
    // Sort the array of SRV records into priority order.
    //

    if ( SortByPriority ) {
        qsort( SrvContext->SrvRecordArray,
               SrvContext->SrvRecordCount,
               sizeof(PDNS_RECORD),
               DnsSrvComparePriority );

    }

    //
    // Indicate that we're at the start of the list.
    //

    SrvContext->CurrentPriority = 0xFFFFFFFF;   // Invalid Priority
    SrvContext->Index = 0;


    //
    // Return the context to the caller.
    //

    *RetSrvContext = SrvContext;
    NetStatus = NO_ERROR;

    //
    // Cleanup
    //
Cleanup:
    if ( NetStatus != NO_ERROR ) {
        if ( SrvContext != NULL ) {
            DnsSrvClose( SrvContext );
        }
    }
    if ( DnsRecords != NULL ) {
        DnsRecordListFree ( DnsRecords, DnsFreeRecordListDeep );
    }
    return HRESULT_FROM_WIN32(NetStatus);
}


HRESULT
DnsSrvProcessARecords(
    IN PDNS_RECORD DnsARecords,
    IN LPSTR DnsHostName OPTIONAL,
    IN ULONG Port,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by DnsSrvOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    DnsARecords - A list of DNS A records that may (or may not) be for the
        host in question.

    DnsHostName - DNS Host name of the host to return A records for.
        If null, all A records are to be used.
        (Passing NULL seems bogus.  Perhaps this routine should mandate that the matched
        A records are in the "answer" section.)

    Port - Port number to return in the SockAddress structures.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        The returned sin_port field contains port from the SRV record.
        This buffer should be freed using LocalFree().

Return Value:

    NO_ERROR: IpAddresses were returned

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available.


--*/
{
    ULONG RecordCount;
    ULONG ByteCount;

    PDNS_RECORD DnsRecord;

    LPBYTE Where;
    PSOCKADDR_IN SockAddr;
    ULONG Size;

    //
    // Count the A and AAAA records.
    //

    RecordCount = 0;
    ByteCount = 0;
    for ( DnsRecord = DnsARecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        if ( (DnsRecord->wType == DNS_TYPE_A ||
              DnsRecord->wType == DNS_TYPE_AAAA ) &&
             ( DnsHostName == NULL ||
               DnsNameCompare_A( DnsHostName, (LPSTR)DnsRecord->pName ) ) ) {

            RecordCount ++;
            ByteCount += sizeof(SOCKET_ADDRESS);
            if ( DnsRecord->wType == DNS_TYPE_A ) {
                ByteCount += sizeof(SOCKADDR_IN);
            } else {
                ByteCount += sizeof(SOCKADDR_IN)+16;  // Originally guess large
                // ByteCount += sizeof(SOCKADDR_IN6); // ?? not checked in yet
            }
            ByteCount = ROUND_UP_COUNT( ByteCount, ALIGN_WORST );
        }
    }

    //
    // If there are no matching records,
    //  tell the caller.
    //

    if ( RecordCount == 0 ) {
        return HRESULT_FROM_WIN32(DNS_ERROR_RCODE_NAME_ERROR);
    }


    //
    // Allocate the return buffer.
    //

    *SockAddresses = (LPSOCKET_ADDRESS)LocalAlloc( 0, ByteCount );

    if ( *SockAddresses == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Where = ((LPBYTE)*SockAddresses)+ RecordCount * sizeof(SOCKET_ADDRESS);

    //
    // Copy the Addresses into the allocated buffer.
    //

    RecordCount = 0;
    for ( DnsRecord = DnsARecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        // ?? Until I really know how to translate.
        if ( DnsRecord->wType == DNS_TYPE_AAAA ) {
            continue;
        }


#ifndef _WINSOCK2_

        if ( (DnsRecord->wType == DNS_TYPE_A) &&
             ( DnsHostName == NULL ||
             DnsNameCompare_A( DnsHostName, (LPSTR)DnsRecord->pName ) ) ) 
        {
               
            SockAddr = (PSOCKADDR_IN) Where;
            (*SockAddresses)[RecordCount].lpSockaddr = (LPSOCKADDR) SockAddr;

            Size = sizeof(SOCKADDR_IN);
            RtlZeroMemory( Where, Size );   // Allow addresses to be compared

            SockAddr->sin_family = AF_INET;
            SockAddr->sin_port = htons((WORD)Port);
            SockAddr->sin_addr.S_un.S_addr = DnsRecord->Data.A.IpAddress;

            (*SockAddresses)[RecordCount].iSockaddrLength = Size;
            Where += ROUND_UP_COUNT(Size, ALIGN_WORST);

            RecordCount ++;
        }

#else

        if ( (DnsRecord->wType == DNS_TYPE_A ||
              DnsRecord->wType == DNS_TYPE_AAAA ) &&
             ( DnsHostName == NULL ||
               DnsNameCompare_A( DnsHostName, (LPSTR)DnsRecord->pName ) ) ) 


        {

            SockAddr = (PSOCKADDR_IN) Where;
            (*SockAddresses)[RecordCount].lpSockaddr = (LPSOCKADDR) SockAddr;


            if ( DnsRecord->wType == DNS_TYPE_A ) {

                Size = sizeof(SOCKADDR_IN);
                RtlZeroMemory( Where, Size );   // Allow addresses to be compared

                SockAddr->sin_family = AF_INET;
                SockAddr->sin_port = htons((WORD)Port);
                SockAddr->sin_addr.S_un.S_addr = DnsRecord->Data.A.IpAddress;

            } 
            
            else {
                SockAddr->sin_family = AF_INET6;

                Size = sizeof(SOCKADDR_IN)+16;  // Originally guess large
                // Size = sizeof(SOCKADDR_IN6); // ?? not checked in yet
                // ??
            }
            (*SockAddresses)[RecordCount].iSockaddrLength = Size;
            Where += ROUND_UP_COUNT(Size, ALIGN_WORST);

            RecordCount ++;
        }

#endif // _WINSOCK2_
}

    *SockAddressCount = RecordCount;
    return S_OK;


}

HRESULT
DnsSrvNext(
    IN HANDLE SrvContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by DnsSrvOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    SrvContextHandle - An opaque context describing the SRV records.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        The returned sin_port field contains port from the SRV record.
        This buffer should be freed using LocalFree().

    DnsHostName - Returns a pointer to the DnsHostName in the SRV record.
        This buffer need not be freed.
        The buffer is valid until the call to DnsSrvClose.

Return Value:

    NO_ERROR: IpAddresses were returned

    ERROR_NO_MORE_ITEMS: No more SRV records are available.

    Any other errors returned are those detected while trying to find the A
        records associated with the host of the SRV record.  The caller can
        note the error (perhaps so the caller can return this status to
        his caller if no usefull server was found) then call DnsSrvNext
        again to get the next SRV record.  The caller can inspect this error
        and return immediately if the caller deems the error serious.

    The following interesting errors might be returned:

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available for this SRV record.


--*/
{
    NET_API_STATUS NetStatus;

    PDNS_SRV_CONTEXT SrvContext = (PDNS_SRV_CONTEXT) SrvContextHandle;
    PDNS_RECORD *DnsArray;
    PDNS_RECORD SrvDnsRecord;
    PDNS_RECORD DnsARecords = NULL;

    ULONG Index;
    ULONG RandomWeight;
    ULONG PreviousWeights;

    //
    // If we're at the end of the list,
    //  tell the caller.
    //

    *SockAddressCount = 0;
    *SockAddresses = NULL;
    if ( ARGUMENT_PRESENT( DnsHostName )) {
        *DnsHostName = NULL;
    }

    if ( SrvContext->Index >= SrvContext->SrvRecordCount ) {
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }

    //
    // If we're at the end of a priority,
    //  computes the collective weights for the next priority.
    //

    DnsArray = SrvContext->SrvRecordArray;
    if ( DnsArray[SrvContext->Index]->Data.SRV.wPriority != SrvContext->CurrentPriority ) {

        //
        // Set the current priority.
        //

        SrvContext->CurrentPriority = DnsArray[SrvContext->Index]->Data.SRV.wPriority;

        //
        // Loop through all of the entries for this priority adding up the weight.
        //
        // This won't overflow since we're adding USHORTs into a ULONG.
        //

        SrvContext->TotalWeight = 0;
        for ( Index=SrvContext->Index; Index<SrvContext->SrvRecordCount; Index++ ) {
           if ( DnsArray[Index]->Data.SRV.wPriority == SrvContext->CurrentPriority ) {
               SrvContext->TotalWeight += DnsArray[Index]->Data.SRV.wWeight;
           }
        }

    }

    //
    // Pick one of the records at weighted random.
    //

	if (0 != SrvContext->TotalWeight)
	    RandomWeight = (RtlUniform( &DnsSrvSeed ) % SrvContext->TotalWeight) + 1;
	else
	    RandomWeight = RtlUniform( &DnsSrvSeed ) + 1;
		
    DnsPrint(( "%ld in %ld chance\n", RandomWeight, SrvContext->TotalWeight ));

    PreviousWeights = 0;
    for ( Index=SrvContext->Index; Index<SrvContext->SrvRecordCount; Index++ ) {
       ASSERTMSG( NULL, DnsArray[Index]->Data.SRV.wPriority == SrvContext->CurrentPriority );

       PreviousWeights += DnsArray[Index]->Data.SRV.wWeight;
       DnsPrint(( "  Prev %ld %s\n", PreviousWeights, DnsArray[Index]->Data.SRV.nameTarget ));

       //
       // If the randomly picked weight includes this entry,
       //   use this entry.
       //

       if ( PreviousWeights >= RandomWeight ) {

           //
           // Move the picked entry to the current position in the array.
           //

           if ( Index != SrvContext->Index ) {
               PDNS_RECORD TempDnsRecord;

               TempDnsRecord = DnsArray[Index];
               DnsArray[Index] = DnsArray[SrvContext->Index];
               DnsArray[SrvContext->Index] = TempDnsRecord;

           }

           break;
       }
    }

    //
    // Move to the next entry for the next iteration.
    //
    // TotalWeight is the total weight of the remaining records
    // for this priority.
    //
    SrvDnsRecord = DnsArray[SrvContext->Index];
    SrvContext->TotalWeight -= SrvDnsRecord->Data.SRV.wWeight;
    SrvContext->Index ++;
    if ( ARGUMENT_PRESENT( DnsHostName )) {
        *DnsHostName = (LPSTR) SrvDnsRecord->Data.SRV.pNameTarget;
    }

    //
    // If A records were returned along with the SRV records,
    //  see if the A records for this host were returned.
    //

    if ( SrvContext->ADnsRecords != NULL ) {
        NetStatus = DnsSrvProcessARecords( SrvContext->ADnsRecords,
                                           (LPSTR)SrvDnsRecord->Data.SRV.pNameTarget,
                                           SrvDnsRecord->Data.SRV.wPort,
                                           SockAddressCount,
                                           SockAddresses );

        if ( NetStatus != DNS_ERROR_RCODE_NAME_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Try getting the A records from DNS.
    //

    //DebugF(_T("DnsSrvNext(): Looking up A record for %S...\n"),
    //        (LPSTR) SrvDnsRecord->Data.SRV.nameTarget);
    NetStatus = DnsQuery_A( (LPSTR) SrvDnsRecord->Data.SRV.pNameTarget,
                            DNS_TYPE_A,
                            SrvContext->DnsQueryFlags,
                            NULL,   // No list of DNS servers
                            &DnsARecords,
                            NULL );

    if ( NetStatus != NO_ERROR ) {
        //
        // Ignore the real status.  The SRV record might have a bogus host name.  We'd
        // rather ignore the SRV record and press on than error out early.
        //
        //DebugF(_T("DnsSrvNext(): Looking up A record for %S failed: 0x%x\n"),
        //        (LPSTR) SrvDnsRecord->Data.SRV.nameTarget, NetStatus);
        NetStatus = DNS_ERROR_RCODE_NAME_ERROR;
        goto Cleanup;
    }

    NetStatus = DnsSrvProcessARecords( DnsARecords,
                                       (LPSTR)SrvDnsRecord->Data.SRV.pNameTarget,
                                       SrvDnsRecord->Data.SRV.wPort,
                                       SockAddressCount,
                                       SockAddresses );


Cleanup:
    if ( DnsARecords != NULL ) {
        DnsRecordListFree ( DnsARecords, DnsFreeRecordListDeep );
    }
    return HRESULT_FROM_WIN32(NetStatus);
}


VOID
DnsSrvClose(
    IN HANDLE SrvContextHandle
    )
/*++

Routine Description:

    Free the context allocated by DnsSrvOpen

Arguments:

    SrvContextHandle - An opaque context describing the SRV records.

Return Value:

    Status of the operation.

    NO_ERROR: SrvContext was returned successfully.

--*/

{
    PDNS_SRV_CONTEXT SrvContext = (PDNS_SRV_CONTEXT) SrvContextHandle;

    if ( SrvContext != NULL ) {

        //
        // Free the RR set.
        //

        DnsRecordListFree ( SrvContext->DnsRecords, DnsFreeRecordListDeep );

        //
        // Free the context itself
        //
        LocalFree( SrvContext );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\messagecall.cpp ===
//messagecall.cpp
//Instant messaging support for phoenix
#include "precomp.h"
#include "resolve.h"
#include "sipstack.h"
#include "sipcall.h"
#include "messagecall.h"
#include <string.h>
#include "register.h"

///////////////////////////////////////////////////////////////////////////////
// IMSession
///////////////////////////////////////////////////////////////////////////////

IMSESSION::IMSESSION(
        IN  SIP_PROVIDER_ID    *pProviderId,
        IN  SIP_STACK          *pSipStack,
        IN  REDIRECT_CONTEXT   *pRedirectContext,
        IN  PSTR                RemoteURI,
        IN  DWORD               RemoteURILen
        ):    SIP_MSG_PROCESSOR( 
                    SIP_MSG_PROC_TYPE_MESSAGE, 
                    pSipStack, 
                    pRedirectContext )
{
    ASSERT(pSipStack);
    LOG((RTC_TRACE, "Inside IMSESSION::IMSESSION"));

    if (pProviderId != NULL)
    {
        CopyMemory(&m_ProviderGuid, pProviderId, sizeof(GUID));
    }
    else
    {
        ZeroMemory(&m_ProviderGuid, sizeof(GUID));
    }
    if(RemoteURI)
    {
        SetRemoteForIncomingSession(RemoteURI, RemoteURILen);
    }
    m_State             = SIP_CALL_STATE_IDLE;
    m_isFirstMessage    = TRUE;
    m_pNotifyInterface  = NULL;
    m_UsrStatus         = USR_STATUS_IDLE;
}

IMSESSION::~IMSESSION()
{
    m_pNotifyInterface = NULL;
    LOG((RTC_TRACE, "~IMSESSION() done"));
}
    
STDMETHODIMP_(ULONG) 
IMSESSION::AddRef()
{
    return MsgProcAddRef();

}

STDMETHODIMP_(ULONG) 
IMSESSION::Release()
{
    return MsgProcRelease();

}

STDMETHODIMP 
IMSESSION::QueryInterface(
        IN  REFIID riid,
        OUT LPVOID *ppv
        )
{
    //The problem is that both base classes derive IUnknown
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_IIMSession)
    {
        *ppv = static_cast<IIMSession *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;

}
HRESULT 
IMSESSION::SetTransport(    
        IN  SIP_TRANSPORT   Transport
        )
{
    m_Transport = Transport;
    return S_OK;
}

HRESULT
IMSESSION::AddParty(
    IN SIP_PARTY_INFO *pPartyInfo
    )
{
    HRESULT       hr;

    ENTER_FUNCTION("IMSESSION::AddParty");
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    
    if (wcsncmp(pPartyInfo ->URI, L"sip:", 4) == 0)
    {
        // SIP URL
        
        PSTR    szSipUrl;
        ULONG   SipUrlLen;
        SIP_URL DecodedSipUrl;
        ULONG   BytesParsed = 0;

        hr = UnicodeToUTF8(pPartyInfo ->URI, &szSipUrl, &SipUrlLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UnicodeToUTF8(sipurl) failed %x",
                 __fxName, hr));
            szSipUrl = NULL;
            return hr;
        }

        hr = ParseSipUrl(szSipUrl, SipUrlLen, &BytesParsed, &DecodedSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseSipUrl failed %x",
                 __fxName, hr));
            free(szSipUrl);
            return hr;
        }

        hr = SIP_MSG_PROCESSOR::SetRequestURI(&DecodedSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetRequestURI failed %x",
                 __fxName, hr));
            free(szSipUrl);
            return hr;
        }

        if (DecodedSipUrl.m_TransportParam == SIP_TRANSPORT_UNKNOWN)
        {
            LOG((RTC_ERROR, "%s Unknown transport specified in SIP URL",
                 __fxName));
            free(szSipUrl);
            return RTC_E_SIP_TRANSPORT_NOT_SUPPORTED;
        }


        // XXX TODO - we should use the asynchronous resolution functions.
        
        // if maddr param is present - this should be the request destination.
        // if provider is not present - resolve the SIP URL.
        if (DecodedSipUrl.m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0 ||
            IsEqualGUID(m_ProviderGuid, GUID_NULL))
        {
            hr = ResolveSipUrlAndSetRequestDestination(&DecodedSipUrl, TRUE,
                                                       FALSE, FALSE, TRUE);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ResolveSipUrlAndSetRequestDestination failed %x",
                     __fxName, hr));
                free(szSipUrl);
                return hr;
            }
        }
        else
        {
            // Set the request destination to the proxy.
            hr = ResolveProxyAddressAndSetRequestDestination();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "%s ResolveProxyAddressAndSetRequestDestination failed : %x",
                     __fxName, hr));
                free(szSipUrl);
                return hr;
            }
        }
        free(szSipUrl);
    }
    else
    {   
        //does not have Sip:
        LOG((RTC_ERROR, "Remote URI does not have Sip:*"));
    }

    LOG((RTC_TRACE,
         "%s - call set RequestURI to : %s", __fxName, m_RequestURI));

    hr = SetRemoteForOutgoingCall(m_RequestURI, m_RequestURILen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRemoteForOutgoingCall failed %x",
             __fxName, hr));
        return hr;
    }
    
    LOG((RTC_TRACE,
         "%s - call set Remote to : %s", __fxName, m_Remote));

    return S_OK;
}

// Notify functions

VOID 
IMSESSION::NotifySessionStateChange(
    IN SIP_CALL_STATE CallState,
    IN HRESULT        StatusCode,       //=0
    IN PSTR           ReasonPhrase,     // = NULL
    IN ULONG          ReasonPhraseLen   // = 0
    )
{
    HRESULT hr;
    SIP_CALL_STATUS CallStatus;
    LPWSTR          wsStatusText = NULL;
    ENTER_FUNCTION("IMSESSION::NotifySessionStateChange");
    
    m_State                      = CallState;
    CallStatus.State             = CallState;
    CallStatus.Status.StatusCode = StatusCode;
    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - UTF8ToUnicode failed %x", 
                __fxName, hr));
            wsStatusText = NULL;
        }
    }
    CallStatus.Status.StatusText = wsStatusText;
    if (m_pNotifyInterface)
    {
        // m_pNotifyInterface->AddRef();
        m_pNotifyInterface->NotifyCallChange(&CallStatus);
        // m_pNotifyInterface->Release();
    }
    else
    {
        LOG((RTC_WARN, "%s : SipNotifyInterface is NULL",
            __fxName));
    }
    if (wsStatusText != NULL)
        free(wsStatusText);
}


HRESULT
IMSESSION::CancelAllTransactions()
{
    //Cleanup Incoming MessageQ
    LIST_ENTRY              *pListEntry;
    INCOMING_MESSAGE_TRANSACTION    *pSipTransaction;
    BOOL                     CallDisconnected = FALSE;
    
    pListEntry = m_IncomingTransactionList.Flink;

    // Go through all the current transactions to check if CSeq
    // matches.
    while (pListEntry != &m_IncomingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            INCOMING_MESSAGE_TRANSACTION,
                                            m_ListEntry );
        pSipTransaction->TerminateTransactionOnByeOrCancel(&CallDisconnected);

        pListEntry = pListEntry->Flink;
    }
    return S_OK;
}

STDMETHODIMP 
IMSESSION::SetNotifyInterface(
    IN   ISipCallNotify *    pNotifyInterface
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "SIP_STACK::SetNotifyInterface - 0x%x",
         pNotifyInterface));
    m_pNotifyInterface = pNotifyInterface;
    return S_OK;
}

VOID 
IMSESSION::OnError()
{
    InitiateCallTerminationOnError(0);
}

//Virtual fn in msg proc
//For new transactions. Called from ProcessRequest in msgproc
HRESULT
IMSESSION::CreateIncomingTransaction(
    IN  SIP_MESSAGE  *pSipMsg,
    IN  ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    
    if (m_State == SIP_CALL_STATE_DISCONNECTED)
    {
        //This is to take care of the case when IMSession is closed
        // at both ends at the same time
        if(pSipMsg->GetMethodId() == SIP_METHOD_BYE)
        {
            hr = CreateIncomingByeTransaction(pSipMsg, pResponseSocket);
            if (hr != S_OK)
                return hr;
        }
        return S_OK;
    }
    switch(pSipMsg->GetMethodId())
    {
    case SIP_METHOD_MESSAGE:
        hr = CreateIncomingMessageTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
        
    case SIP_METHOD_BYE:
        hr = CreateIncomingByeTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;

    case SIP_METHOD_INFO:
        hr = CreateIncomingInfoTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
    //XXX:TODO Take care of cancel:right now not supported

    default:
        LOG((RTC_TRACE, "IMSESSION::CreateIncomingTransaction - Invalid method obtained"));
        hr = CreateIncomingReqFailTransaction(pSipMsg, pResponseSocket, 405);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "IMSESSION Creating reqfail transaction failed %x",
                 hr));
            return hr;
        }
        break;
    }
    return S_OK;
}


//Transaction related functions
HRESULT 
IMSESSION::CreateOutgoingMessageTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount,
    IN  PSTR                        MsgBody,
    IN  ULONG                       MsgBodyLen,
    IN  PSTR                        ContentType,
    IN  ULONG                       ContentTypeLen,
    IN  long                        lCookie
)
{
    HRESULT hr = S_OK;
    OUTGOING_MESSAGE_TRANSACTION *pOutgoingMsgTransaction;

    ENTER_FUNCTION("IMSESSION::CreateOutgoingMsgTransaction");

    LOG((RTC_TRACE, "%s - Enter", __fxName));

    pOutgoingMsgTransaction =
        new OUTGOING_MESSAGE_TRANSACTION(
                this, SIP_METHOD_MESSAGE,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                lCookie);
    if (pOutgoingMsgTransaction == NULL)
    {
        LOG((RTC_WARN, 
            "%s:: Creating OUTGOING_MESSAGE_TRANSACTION failed", __fxName));
        return E_OUTOFMEMORY;
    }

    hr = pOutgoingMsgTransaction->CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP,
             AdditionalHeaderArray,
             AdditionalHeaderCount,
             MsgBody, MsgBodyLen,
             ContentType, ContentTypeLen
             );
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: OUTGOING_MESSAGE_TRANSACTION::CheckRequestSocketAndSendRequestMsg failed",
             __fxName));
        pOutgoingMsgTransaction->OnTransactionDone();
        return hr;
    }
    //Change State
    if(m_State == SIP_CALL_STATE_IDLE)
    {
        m_State = SIP_CALL_STATE_CONNECTING;
        NotifySessionStateChange(SIP_CALL_STATE_CONNECTING);
    }
    return S_OK;

}
//called by IMSESSION::CreateIncomingMessageSession
HRESULT 
IMSESSION::CreateIncomingMessageTransaction(
    IN  SIP_MESSAGE *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("IMSESSION::CreateIncomingMessageTransaction");
    LOG((RTC_TRACE, "entering %s", __fxName));
    
    INCOMING_MESSAGE_TRANSACTION *pIncomingMessageTransaction
        = new INCOMING_MESSAGE_TRANSACTION(this,
                                              pSipMsg->GetMethodId(),
                                              pSipMsg->GetCSeq());
    if (pIncomingMessageTransaction == NULL)
    {
        LOG((RTC_WARN, 
            "%s:: Creating INCOMING_MESSAGE_TRANSACTION failed", 
            __fxName));
        return E_OUTOFMEMORY;
    }

    hr = pIncomingMessageTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s::SetResponseSocketAndVia failed", __fxName));
        pIncomingMessageTransaction->OnTransactionDone();
        return hr;
    }

    hr = pIncomingMessageTransaction->ProcessRequest(pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s::ProcessRequest failed", __fxName));
        //Should not delete the transaction. The transaction should handle the error
        //and delete itself
        return hr;
    }
    NotifyIncomingSipMessage(pSipMsg);

    if(m_State == SIP_CALL_STATE_IDLE)
    {
        m_State = SIP_CALL_STATE_CONNECTED;
        NotifySessionStateChange(SIP_CALL_STATE_CONNECTED);
    }
    return hr;
}

HRESULT 
IMSESSION::CreateOutgoingByeTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount
    )
{
    HRESULT hr;
    OUTGOING_BYE_MESSAGE_TRANSACTION *pOutgoingByeTransaction;

    ENTER_FUNCTION("IMSession::CreateOutgoingByeTransaction");

    LOG((RTC_TRACE, "%s - Enter", __fxName));

    //Make sure no message entries in the msgproc for this session
    hr = CancelAllTransactions();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CancelAllTransactions failed %x",
             __fxName, hr));
    }

    pOutgoingByeTransaction =
        new OUTGOING_BYE_MESSAGE_TRANSACTION(
                this, SIP_METHOD_BYE,
                GetNewCSeqForRequest(),
                AuthHeaderSent
                );
    if (pOutgoingByeTransaction == NULL)
    {
        LOG((RTC_WARN, 
            "%s:: Creating OUTGOING_MESSAGE_TRANSACTION failed", 
            __fxName));
        return E_OUTOFMEMORY;
    }

    hr = pOutgoingByeTransaction->CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP,
             AdditionalHeaderArray,
             AdditionalHeaderCount,
             NULL, 0,    // No Message Body
             NULL, 0     //No ContentType
             );
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: CheckRequestSocketAndSendRequestMsg failed", __fxName));
        pOutgoingByeTransaction->OnTransactionDone();
        return hr;
    }
    return S_OK;

}

HRESULT 
IMSESSION::CreateIncomingByeTransaction(
    IN  SIP_MESSAGE *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;
    BOOL    fNotifyDisconnect = FALSE;

    ENTER_FUNCTION("IMSESSION::CreateIncomingByeTransaction");
    LOG((RTC_TRACE, "entering %s", __fxName));
    
    if (m_State != SIP_CALL_STATE_DISCONNECTED)
    {
        m_State = SIP_CALL_STATE_DISCONNECTED;
        hr = CancelAllTransactions();
        if (hr != S_OK)
        {
            LOG((RTC_WARN, 
                "%s:: CancelAllTransactions failed", __fxName));
            return hr;
        }
        fNotifyDisconnect = TRUE;
    }
    
    INCOMING_BYE_MESSAGE_TRANSACTION *pIncomingByeTransaction
        = new INCOMING_BYE_MESSAGE_TRANSACTION(this,
                                              pSipMsg->GetMethodId(),
                                              pSipMsg->GetCSeq());
    if (pIncomingByeTransaction == NULL)
    {
        LOG((RTC_WARN, 
            "%s:: Creating INCOMING_BYE_MESSAGE_TRANSACTION failed", 
            __fxName));
        hr = E_OUTOFMEMORY;
        pIncomingByeTransaction->OnTransactionDone();
        return hr;
    }

    hr = pIncomingByeTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: SetResponseSocketAndVia failed", __fxName));
        pIncomingByeTransaction->OnTransactionDone();
        return hr;
    }
    
    hr = pIncomingByeTransaction->ProcessRequest(pSipMsg, 
                                                 pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: ProcessRequest failed", __fxName));
        //Should not delete the transaction. The transaction should handle the error
        //and delete itself
        return hr;
    }

    // Notify should always be done last.
    if (fNotifyDisconnect)
    {
       LOG((RTC_TRACE, 
            "%s:: NotifySessionStateChange: SIP_CALL_STATE_DISCONNECTED", __fxName));
        NotifySessionStateChange(SIP_CALL_STATE_DISCONNECTED);
    }
    return hr;
}

HRESULT 
IMSESSION::CreateOutgoingInfoTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount,
    IN  PSTR                        MsgBody,
    IN  ULONG                       MsgBodyLen,
    IN  PSTR                        ContentType,
    IN  ULONG                       ContentTypeLen,
    IN  long                        lCookie,
    IN  USR_STATUS                  UsrStatus
    )
{
    HRESULT hr;
    OUTGOING_INFO_MESSAGE_TRANSACTION *pOutgoingInfoTransaction;

    ENTER_FUNCTION("IMSession::CreateOutgoingInfoTransaction");

    LOG((RTC_TRACE, "%s - Enter", __fxName));

    pOutgoingInfoTransaction =
        new OUTGOING_INFO_MESSAGE_TRANSACTION(
                this, SIP_METHOD_INFO,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                lCookie,
                UsrStatus
                );
    if (pOutgoingInfoTransaction == NULL)
    {
        LOG((RTC_WARN, 
            "%s:: Creating OUTGOING_INFO_TRANSACTION failed", __fxName));
        return E_OUTOFMEMORY;
    }


    hr = pOutgoingInfoTransaction->CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_BYE_SENT_TCP,
             AdditionalHeaderArray,
             AdditionalHeaderCount,
             MsgBody, 
             MsgBodyLen,
             ContentType,
             ContentTypeLen
             );
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: CheckRequestSocketAndSendRequestMsg failed", __fxName));
        pOutgoingInfoTransaction->OnTransactionDone();
        return hr;
    }
    return S_OK;

}

HRESULT 
IMSESSION::CreateIncomingInfoTransaction(
    IN  SIP_MESSAGE *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("IMSESSION::CreateIncomingInfoTransaction");
    LOG((RTC_TRACE, "entering %s", __fxName));
    
    INCOMING_INFO_MESSAGE_TRANSACTION *pIncomingInfoTransaction
        = new INCOMING_INFO_MESSAGE_TRANSACTION(this,
                                              pSipMsg->GetMethodId(),
                                              pSipMsg->GetCSeq());
    if (pIncomingInfoTransaction == NULL)
    {
        LOG((RTC_WARN, 
            "%s:: Creating INCOMING_INFO_MESSAGE_TRANSACTION failed", 
            __fxName));
        hr = E_OUTOFMEMORY;
        pIncomingInfoTransaction->OnTransactionDone();
        return hr;
    }

    hr = pIncomingInfoTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: SetResponseSocketAndVia failed", __fxName));
        pIncomingInfoTransaction->OnTransactionDone();
        return hr;
    }
    
    hr = pIncomingInfoTransaction->ProcessRequest(pSipMsg, 
                                                 pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, 
            "%s:: ProcessRequest failed", __fxName));
        //Should not delete the transaction. The transaction should handle the error
        //and delete itself
        return hr;
    }

    // Notify should always be done last.
    if(m_pNotifyInterface)
    {
        SIP_PARTY_INFO  CallerInfo;
        OFFSET_STRING   DisplayName;
        OFFSET_STRING   AddrSpec;
        OFFSET_STRING   Params;
        ULONG           BytesParsed = 0;
        HRESULT         hr;
        hr = ParseNameAddrOrAddrSpec(m_Remote, m_RemoteLen, &BytesParsed,
                                            '\0', // no header list separator
                                            &DisplayName, &AddrSpec);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -ParseNameAddrOrAddrSpec failed %x",
                    __fxName, hr));
            return hr;
        }

        //Get CallerInfo
        CallerInfo.DisplayName = NULL;
        CallerInfo.URI         = NULL;
        CallerInfo.PartyContactInfo = NULL;

        if (DisplayName.GetLength() != 0)
        {
            //Remove Quotes before passing to core
            if((DisplayName.GetString(m_Remote))[0] == '\"')
            {
                    hr = UTF8ToUnicode(DisplayName.GetString(m_Remote+1),
                               DisplayName.GetLength()-2,
                               &CallerInfo.DisplayName
                               );
            }
            else
            {
                hr = UTF8ToUnicode(DisplayName.GetString(m_Remote),
                               DisplayName.GetLength(),
                               &CallerInfo.DisplayName
                               );
            }
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                    __fxName, hr));
                CallerInfo.DisplayName = NULL;
                return hr;
            }
        }
        
        if (AddrSpec.GetLength() != 0)
        {
            hr = UTF8ToUnicode(AddrSpec.GetString(m_Remote),
                               AddrSpec.GetLength(),
                               &CallerInfo.URI
                               );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                    __fxName, hr));
                free(CallerInfo.DisplayName);
                return hr;
            }
        }
        CallerInfo.State = SIP_PARTY_STATE_CONNECTING;
    
        m_pNotifyInterface->AddRef();
        m_pNotifyInterface->NotifyUsrStatus(m_UsrStatus, &CallerInfo);
        m_pNotifyInterface->Release();
        
        free(CallerInfo.DisplayName);
        free(CallerInfo.URI);

    }
    return hr;
}

STDMETHODIMP
IMSESSION::SendTextMessage(
    IN BSTR msg,
    IN BSTR bstrContentType,
    IN long lCookie
    )
{
    ENTER_FUNCTION("IMSESSION::SendTextMessage");
    HRESULT       hr;
    SIP_TRANSPORT Transport;
    SOCKADDR_IN   DstAddr;
    PSTR ContentType = NULL;
    ULONG ContentTypeLen = 0;
    ULONG MsgBodyLen = 0;
    PSTR MsgBody =NULL;
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }
    if(m_RequestSocketErrorCode != 0)
    {
        LOG((RTC_ERROR, "%s - m_RequestSocketErrorCode is %x",
            __fxName, m_RequestSocketErrorCode));
        return m_RequestSocketErrorCode;
    }

    if(msg != NULL)
    {
        hr = UnicodeToUTF8(msg, &MsgBody, &MsgBodyLen);//MsgBodyLen is in bytes
        if(FAILED(hr))
        {
           LOG((RTC_ERROR, "Failed to convert MsgBody to Unicode %x",
                     hr));
           if(MsgBody)
               free(MsgBody);
            return hr; 
        }
        if(bstrContentType != NULL)
        {
            hr = UnicodeToUTF8(bstrContentType, &ContentType, &ContentTypeLen);//MsgBodyLen is in bytes
            if(FAILED(hr))
            {
               LOG((RTC_ERROR, "Failed to convert ContentType to Unicode %x",
                         hr));
               if(MsgBody)
                   free(MsgBody);
               if(ContentType)
                   free(ContentType);
               return hr; 
            }
        }
        else
        {
            ContentType = SIP_CONTENT_TYPE_MSGTEXT_TEXT;
            ContentTypeLen = sizeof(SIP_CONTENT_TYPE_MSGTEXT_TEXT)-1;
        }
    }
    // Create outgoing MESSAGE transaction.
    hr = CreateOutgoingMessageTransaction(
             FALSE,     // Auth Header not sent
             NULL,
             0,   // No Additional headers
             MsgBody,
             MsgBodyLen,
             ContentType,
             ContentTypeLen,
             lCookie
             );
    //Free the variables if allocated
    if(msg != NULL)
    {
        free(MsgBody);
        if(bstrContentType != NULL)
            free(ContentType);
    }
    if(hr != S_OK)
    {
       LOG((RTC_ERROR, "%s -CreateOutgoingMessageTransactionFailed %x",
                __fxName, hr));
        return hr;
    }
    
    if(m_State == SIP_CALL_STATE_IDLE)
    {
        m_State = SIP_CALL_STATE_CONNECTING;
        NotifySessionStateChange(SIP_CALL_STATE_CONNECTING); 
    }
    return S_OK;
}

void
IMSESSION::EncodeXMLBlob(
    OUT PSTR    pstrXMLBlob,
    OUT DWORD*  dwBlobLen,
    IN  USR_STATUS  UsrStatus
    )
{
    *dwBlobLen = 0;
    //encode the XML version header.
    *dwBlobLen += sprintf( &pstrXMLBlob[*dwBlobLen], XMLVERSION_TAG1_TEXT );
    
    //encode the KEY tag.
    *dwBlobLen += sprintf( &pstrXMLBlob[*dwBlobLen], KEY_TAG1_TEXT );
    
    //encode the status tag for IP address.
    *dwBlobLen += sprintf( &pstrXMLBlob[*dwBlobLen], USRSTATUS_TAG1_TEXT,
        GetTextFromStatus( UsrStatus) );
    
    //encode Keyend.
    *dwBlobLen += sprintf( &pstrXMLBlob[*dwBlobLen], KEYEND_TAG1_TEXT );
    pstrXMLBlob[*dwBlobLen] = '\0';    
    return;
}


HRESULT IMSESSION::SendUsrStatus(
        IN USR_STATUS  UsrStatus,
        IN long        lCookie
        )
{
    ENTER_FUNCTION("IMSESSION::SendUsrStatus");
    HRESULT       hr;
    ULONG MsgBodyLen;
    PSTR  MsgBody;
    ULONG EncodeMsgBodyLen;
    m_UsrStatus = UsrStatus;
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }
    if(m_RequestSocketErrorCode != 0)
    {
        LOG((RTC_ERROR, "%s - m_RequestSocketErrorCode is %x",
            __fxName, m_RequestSocketErrorCode));
        return m_RequestSocketErrorCode;
    }

    if(m_isFirstMessage)
    {
        LOG((RTC_ERROR, "%s Info called before first msg sent - aborted",
            __fxName));
        return E_FAIL;
    }
    MsgBodyLen = INFO_XML_LENGTH;
    MsgBody = (PSTR)malloc((MsgBodyLen+1)*sizeof(char));
    if(MsgBody == NULL)
    {
       LOG((RTC_ERROR, "Allocation for MsgBody failed"));
        return E_OUTOFMEMORY; 
    }

    if(UsrStatus == USR_STATUS_TYPING)
    {
        EncodeXMLBlob(MsgBody,&EncodeMsgBodyLen,USR_STATUS_TYPING);
        ASSERT(MsgBodyLen == EncodeMsgBodyLen);
    }
    else if(UsrStatus == USR_STATUS_IDLE)
    {
        EncodeXMLBlob(MsgBody,&EncodeMsgBodyLen,USR_STATUS_IDLE);
        ASSERT(MsgBodyLen == EncodeMsgBodyLen);
    }
    else
    {
        LOG((RTC_ERROR, "%s UsrStatus from Core did not match any existing status, INFO aborted"
            , __fxName));
        free(MsgBody);
        return E_FAIL;
    }

    // Create outgoing INFO transaction.
    hr = CreateOutgoingInfoTransaction(
             FALSE,     // Auth Header not sent
             NULL,
             0,   // No Additional headers
             MsgBody,
             MsgBodyLen,
             SIP_CONTENT_TYPE_MSGXML_TEXT,
             sizeof(SIP_CONTENT_TYPE_MSGXML_TEXT)-1,
             lCookie,
             UsrStatus
             );
    free(MsgBody);
    if(hr != S_OK)
    {
       LOG((RTC_ERROR, "%s -CreateOutgoingInfoTransactionFailed %x",
                __fxName, hr));
        return hr;
    }
    return S_OK;
}

STDMETHODIMP
IMSESSION::Cleanup()
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    HRESULT hr = CreateOutgoingByeTransaction(FALSE,
                                          NULL, 0 // No Additional headers
                                          );
    m_State = SIP_CALL_STATE_DISCONNECTED;
    NotifySessionStateChange(SIP_CALL_STATE_DISCONNECTED);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "Creating BYE transaction failed"));
    }
    return hr;
}

HRESULT
IMSESSION::NotifyIncomingSipMessage(
    IN  SIP_MESSAGE    *pSipMsg
    )
{
    SIP_PARTY_INFO  CallerInfo;
    OFFSET_STRING   DisplayName;
    OFFSET_STRING   AddrSpec;
    OFFSET_STRING   Params;
    ULONG           BytesParsed = 0;
    HRESULT         hr;
    LPWSTR wsContentType = NULL;
    PSTR    ContentTypeHdrValue = NULL;
    ULONG   ContentTypeHdrValueLen;
    BSTR bstrmsg = NULL;
    BSTR bstrContentType = NULL;

    ENTER_FUNCTION("IMSESSION::NotifyIncomingSipMessage");
    hr = ParseNameAddrOrAddrSpec(m_Remote, m_RemoteLen, &BytesParsed,
                                        '\0', // no header list separator
                                        &DisplayName, &AddrSpec);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s -ParseNameAddrOrAddrSpec failed %x",
                __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "Incoming Call from Display Name: %.*s  URI: %.*s",
         DisplayName.GetLength(),
         DisplayName.GetString(m_Remote),
         AddrSpec.GetLength(),
         AddrSpec.GetString(m_Remote)
         )); 

    //Get CallerInfo
    CallerInfo.DisplayName = NULL;
    CallerInfo.URI         = NULL;
    if (DisplayName.GetLength() != 0)
    {
        //Remove Quotes before passing to core
        if((DisplayName.GetString(m_Remote))[0] == '\"')
        {
                hr = UTF8ToUnicode(DisplayName.GetString(m_Remote+1),
                           DisplayName.GetLength()-2,
                           &CallerInfo.DisplayName
                           );
        }
        else
        {
            hr = UTF8ToUnicode(DisplayName.GetString(m_Remote),
                           DisplayName.GetLength(),
                           &CallerInfo.DisplayName
                           );
        }
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                __fxName, hr));
            goto error;
        }
    }
        
    if (AddrSpec.GetLength() != 0)
    {
        hr = UTF8ToUnicode(AddrSpec.GetString(m_Remote),
                           AddrSpec.GetLength(),
                           &CallerInfo.URI
                           );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                __fxName, hr));
            goto error;
        }
    }
        
    CallerInfo.State = SIP_PARTY_STATE_CONNECTING;
    
    //Extract Message Contents
    if (pSipMsg->MsgBody.Length != 0)
    {
        // We have Message Body. Check type.

        hr = pSipMsg->GetSingleHeader(SIP_HEADER_CONTENT_TYPE,
                             &ContentTypeHdrValue,
                             &ContentTypeHdrValueLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - Couldn't find Content-Type header %x",
                __fxName, hr));
            hr =  E_FAIL;
            goto error;
        }
      
        hr = UTF8ToUnicode(ContentTypeHdrValue,
                            ContentTypeHdrValueLen,
                           &wsContentType);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
            __fxName,
             hr));
            goto error;
        }

        bstrContentType = SysAllocString(wsContentType);
        free(wsContentType);
        if (bstrContentType == NULL)
        {
            LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
            __fxName, hr));
            hr = E_OUTOFMEMORY;
            goto error;
        }

        LPWSTR wsmsg;
        hr = UTF8ToUnicode(pSipMsg->MsgBody.GetString(pSipMsg->BaseBuffer),
                            pSipMsg->MsgBody.Length,
                           &wsmsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
            __fxName,
             hr));
            wsmsg = NULL;
            goto error;
        }

        bstrmsg = SysAllocString(wsmsg);
        free(wsmsg);
        if (bstrmsg == NULL)
        {
            LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
            __fxName, hr));
            hr =E_OUTOFMEMORY;
            goto error;
        }
    }
    if(m_pNotifyInterface)
    {
        m_pNotifyInterface->AddRef();
        m_pNotifyInterface->NotifyIncomingMessage(
            this,
            bstrmsg,
            bstrContentType,
            &CallerInfo);
        m_pNotifyInterface->Release();
    }
    if(CallerInfo.DisplayName)
        free(CallerInfo.DisplayName);
    if(CallerInfo.URI)
        free(CallerInfo.URI);
    if(bstrmsg)
        SysFreeString(bstrmsg);
    if(bstrContentType)
        SysFreeString(bstrContentType);
    return S_OK;

error:
    if(CallerInfo.DisplayName)
        free(CallerInfo.DisplayName);
    if(CallerInfo.URI)
        free(CallerInfo.URI);
    if(bstrmsg)
        SysFreeString(bstrmsg);
    if(bstrContentType)
        SysFreeString(bstrContentType);
    return hr;
}


HRESULT 
IMSESSION::SetCreateIncomingMessageParams(
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket,
        IN  SIP_TRANSPORT   Transport
        )
{
    HRESULT hr;
    PSTR        Header;
    ULONG       HeaderLen;
    ENTER_FUNCTION("IMSESSION::SetCreateIncomingMessageParams");

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "%s -Get To Header failed %x",
               __fxName, hr));
        return hr;
    }

    hr = SetLocalForIncomingCall(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "%s -SetLocalForIncomingCall failed %x",
               __fxName, hr));
       return hr;
    }

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "%s -Get CallId Header failed %x",
               __fxName, hr));
        return hr;
    }

    hr = SetCallId(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN, "%s -Set Callid failed %x",
               __fxName, hr));
        return hr;
    }

    if (Transport != SIP_TRANSPORT_UDP &&
        m_pRequestSocket == NULL)
    {
        hr = SetRequestSocketForIncomingSession(pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s SetRequestSocketForIncomingSession failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    return S_OK;
    
}

//SIP_CALL_STATE 
STDMETHODIMP
IMSESSION::GetIMSessionState(SIP_CALL_STATE * ImState)
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    *ImState = m_State;
    return S_OK;
}

inline VOID 
IMSESSION::SetIMSessionState(
    IN SIP_CALL_STATE CallState
    )
{
    m_State = CallState;
}


inline BOOL 
IMSESSION::IsSessionDisconnected()
{
    return (m_State == SIP_CALL_STATE_DISCONNECTED);

}

HRESULT
IMSESSION::SetLocalURI(
                       IN BSTR bstrLocalDisplayName, 
                       IN BSTR bstrLocalURI
                       )
{
    SetLocalForOutgoingCall(bstrLocalDisplayName, bstrLocalURI);
    return S_OK;
}

STDMETHODIMP 
IMSESSION::AcceptSession()
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    m_State = SIP_CALL_STATE_CONNECTED;
    NotifySessionStateChange(SIP_CALL_STATE_CONNECTED);
    return S_OK;
}

void
IMSESSION::SetIsFirstMessage(BOOL isFirstMessage)
{
    m_isFirstMessage = isFirstMessage;
}

// Note that this function notifies the Core and this call could
// block and on return the transaction and call could both be deleted.
// So, we should make sure we don't touch any state after calling this
// function.
VOID
IMSESSION::InitiateCallTerminationOnError(
    IN HRESULT StatusCode,  // = 0
    IN long    lCookie
    )
{
    LOG((RTC_TRACE,
             "Inside IMSESSION::InitiateCallTerminationOnError"));
    ENTER_FUNCTION("IMSESSION::InitiateCallTerminationOnError");
    HRESULT hr;
    if (m_State == SIP_CALL_STATE_DISCONNECTED)
    {
        // do nothing
        LOG((RTC_TRACE,
             "%s already disconnected", __fxName));

        return;
    }
    NotifyMessageInfoCompletion(
        HRESULT_FROM_SIP_ERROR_STATUS_CODE(StatusCode),
        lCookie);
    //we are removing the BYE on error to be compatible with MSN IM (Bug #312990)
    
    //hr = CreateOutgoingByeTransaction(FALSE,
    //                                  NULL, 0 // No Additional headers
    //                                  );
    //if (hr != S_OK)
    //{
    //    LOG((RTC_ERROR,
    //         "InitiateCallTerminationOnError creating BYE transaction failed"));
   // }

    // We have to notify the user even if creating the BYE transaction failed.
    // Don't wait till the BYE transaction completes

    //TODO add the reason phrase and len to the notify

    //LOG((RTC_TRACE,
    //         "Sent StatusMessage %d to Core before disconnect", StatusCode));
    //NotifySessionStateChange(SIP_CALL_STATE_DISCONNECTED, StatusCode);
}


HRESULT
IMSESSION::ProcessRedirect(
    IN SIP_MESSAGE *pSipMsg,
    IN long        lCookie,
    IN PSTR        MsgBody,
    IN ULONG       MsgBodyLen,
    IN PSTR        ContentType,
    IN ULONG       ContentTypeLen,
    IN USR_STATUS  UsrStatus
    )
{
    // For now redirects are also failures
    HRESULT hr = S_OK;
    BSTR    bstrMsgBody = NULL;
    BSTR    bstrContentType = NULL;
    SIP_CALL_STATUS CallStatus;
    LPWSTR          wsStatusText = NULL;
    PSTR            ReasonPhrase = NULL;
    ULONG           ReasonPhraseLen = 0;


    ENTER_FUNCTION("SIP_CALL::ProcessRedirect");

    if (m_pRedirectContext == NULL)
    {
        m_pRedirectContext = new REDIRECT_CONTEXT();
        if (m_pRedirectContext == NULL)
        {
            LOG((RTC_ERROR, "%s allocating redirect context failed",
                 __fxName));


            return E_OUTOFMEMORY;
        }
    }

    if(MsgBodyLen !=0)
    {
        LPWSTR wsMsgBody = NULL;
        hr = UTF8ToUnicode(MsgBody,
            MsgBodyLen,
            &wsMsgBody);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                __fxName,
                hr));
            goto error;
        }
        
        bstrMsgBody = SysAllocString(wsMsgBody);
        free(wsMsgBody);
        if (bstrMsgBody == NULL)
        {
            LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
                __fxName, hr));
            hr = E_OUTOFMEMORY;
            goto error;            
        }

        if(ContentTypeLen !=0)
        {
            LPWSTR wsContentType = NULL;
            hr = UTF8ToUnicode(ContentType,
                ContentTypeLen,
                &wsContentType);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
                    __fxName,
                    hr));
                goto error;
            }
        
            bstrContentType = SysAllocString(wsContentType);
            free(wsContentType);
            if (bstrContentType == NULL)
            {
                LOG((RTC_WARN, "%s -bstrContentType allocation failed %x",
                    __fxName, hr));
                hr = E_OUTOFMEMORY;
                goto error;            
            }
        }
    }
    hr = m_pRedirectContext->AppendContactHeaders(pSipMsg);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AppendContactHeaders failed %x",
             __fxName, hr));
        // XXX Shutdown call ?
        goto error;
    }

    pSipMsg->GetReasonPhrase(&ReasonPhrase, &ReasonPhraseLen);
    
    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UTF8ToUnicode failed %x",
             __fxName, hr));
            wsStatusText = NULL;
        }
    }
    
    CallStatus.State = SIP_CALL_STATE_DISCONNECTED;
    CallStatus.Status.StatusCode =
        HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode());
    CallStatus.Status.StatusText = wsStatusText;

    // Keep a reference till the notify completes to make sure
    // that the SIP_CALL object is alive when the notification
    // returns.
    AddRef();
    if(m_pNotifyInterface != NULL)
        hr = m_pNotifyInterface->NotifyMessageRedirect(m_pRedirectContext,
                                            &CallStatus,
                                            bstrMsgBody,
                                            bstrContentType,
                                            UsrStatus,
                                            lCookie);
    // If a new call is created as a result that call will AddRef()
    // the redirect context.
    if(bstrMsgBody != NULL)
        SysFreeString(bstrMsgBody);
    if(bstrContentType != NULL)
        SysFreeString(bstrContentType);
    if(m_pRedirectContext != NULL)
        m_pRedirectContext->Release();
    m_pRedirectContext = NULL;
    if (wsStatusText != NULL)
        free(wsStatusText);

    Release();

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s NotifyRedirect failed %x",
             __fxName, hr));
    }

    return hr;

error:
    if(m_pRedirectContext != NULL)
        m_pRedirectContext->Release();
    m_pRedirectContext = NULL;
    if(bstrMsgBody != NULL)
        SysFreeString(bstrMsgBody);
    if(bstrContentType != NULL)
        SysFreeString(bstrContentType);

    return hr;
}

VOID IMSESSION::NotifyMessageInfoCompletion(
        IN HRESULT StatusCode,
        IN long lCookie
        )
{
    SIP_STATUS_BLOB StatusBlob;
    StatusBlob.StatusCode = StatusCode;
    StatusBlob.StatusText = NULL;
    if(m_pNotifyInterface != NULL)
    {
        LOG((RTC_ERROR, "Notifying MessageCompletion StatusCode %x", StatusCode));
        m_pNotifyInterface->NotifyMessageCompletion(&StatusBlob, lCookie);
    }
    else
    {
        LOG((RTC_ERROR, "NotifyInterface for MessageCompletion not present. StatusCode %x",
             StatusCode));
    }
}

HRESULT IMSESSION::OnIpAddressChange()
{
    HRESULT hr = S_OK;
    ENTER_FUNCTION("IMSESSION::OnIpAddressChange");
    LOG((RTC_TRACE, "%s - Enter this: %x", __fxName, this));
    hr = CheckListenAddrIntact();
    if(hr == S_OK)
        return hr;

    MsgProcAddRef();
    hr = SIP_MSG_PROCESSOR::OnIpAddressChange();
    if(hr != S_OK)
    {
        LOG((RTC_ERROR, "%s- failed at msgproc%x", __fxName, hr));
        MsgProcRelease();
        return hr;
    }
    // Create outgoing MESSAGE transaction.
    if(m_isFirstMessage)
        m_isFirstMessage = FALSE;
    hr = CreateOutgoingMessageTransaction(
             FALSE,     // Auth Header not sent
             NULL,
             0,     // No Additional headers
             NULL,  //MsgBody,
             0,      //MsgBodyLen,
             NULL,  //ContentType,
             0,     //ContentTypeLen,
             0     //lCookie
             );
    if(hr != S_OK)
    {
       LOG((RTC_ERROR, "%s- CreateOutgoingMessageTransactionFailed %x",
                __fxName, hr));
       MsgProcRelease();
       return hr;
    }
    
    if(m_State == SIP_CALL_STATE_IDLE)
    {
        m_State = SIP_CALL_STATE_CONNECTING;
        //NotifySessionStateChange(SIP_CALL_STATE_CONNECTING); 
    }
    MsgProcRelease();
    LOG((RTC_TRACE, "%s - Exit this: %x", __fxName, this));
    return hr;
}

HRESULT IMSESSION::GetIsIMSessionAuthorizedFromCore(
        IN BSTR   bstrCallerURI,
        OUT BOOL  * bAuthorized
        )
{
    HRESULT hr;
    ENTER_FUNCTION("IMSESSION::GetIsIMSessionAuthorizedFromCore");
    ISipStackNotify *pSipStackNotify;
    pSipStackNotify = m_pSipStack->GetNotifyInterface();
    if(pSipStackNotify != NULL)
    {
        hr = pSipStackNotify->IsIMSessionAuthorized(
                                    bstrCallerURI, 
                                    bAuthorized);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - failed %x", __fxName, hr));
            return hr;
        }
    }
    else
    {
        LOG((RTC_WARN, "%s - SipStackNotifyInterface is NULL", __fxName));
        return E_FAIL;
    }
    return S_OK;
}
//TODO Content_Type: text/plain; charset="us-ascii".

///////////////////////////////////////////////////////////////////////////////
// INCOMING MESSAGE TRANSACTION
///////////////////////////////////////////////////////////////////////////////

INCOMING_MESSAGE_TRANSACTION::INCOMING_MESSAGE_TRANSACTION(
    IN IMSESSION        *pImSession,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq
    ) :
    INCOMING_TRANSACTION(pImSession, MethodId, CSeq)
{
    m_pImSession          = pImSession;
    LOG((RTC_TRACE, 
        "INCOMING_MESSAGE_TRANSACTION::INCOMING_MESSAGE_TRANSACTION"));
}

HRESULT
INCOMING_MESSAGE_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    //This must be a retransmission. Just retransmit the response.
    // A new request is handled in CreateIncomingMessageTransaction()

    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    ENTER_FUNCTION("INCOMING_MESSAGE_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "entering %s", __fxName));

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:
        PSTR            FromHeader;
        ULONG           FromHeaderLen;
        BSTR            bstrCallerURI;
        ULONG           BytesParsed;
        LPWSTR          wsCallerURI;
        OFFSET_STRING   DisplayName;
        OFFSET_STRING   AddrSpec;
        BOOL            isAuthorized;
        //Check for authorization (offline/ blocked buddy)
        hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &FromHeader, &FromHeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s getting From header failed %x",
                 __fxName, hr));
            return hr;
        }
        BytesParsed = 0;
        hr = ParseNameAddrOrAddrSpec(FromHeader, FromHeaderLen, &BytesParsed,
                                     '\0', // no header list separator
                                     &DisplayName, &AddrSpec);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseNameAddrOrAddrSpec failed at %d",
                 __fxName, BytesParsed));
            return hr;
        }

        hr = UTF8ToUnicode(AddrSpec.GetString(FromHeader),
                           AddrSpec.GetLength(),
                           &wsCallerURI);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
            __fxName,
             hr));
            return hr;
        }

        bstrCallerURI = SysAllocString(wsCallerURI);
        free(wsCallerURI);
        if (bstrCallerURI == NULL)
        {
            LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
            __fxName, hr));
            return E_OUTOFMEMORY;
        }
        isAuthorized = TRUE;
        hr = m_pImSession->GetIsIMSessionAuthorizedFromCore(
                                bstrCallerURI, 
                                &isAuthorized);
        if(bstrCallerURI != NULL)
            SysFreeString(bstrCallerURI);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - GetIsIMSessionAuthorizedFromCore failed %x", 
                __fxName, hr));
            return hr;
        }
        if(!isAuthorized)
        {
            LOG((RTC_ERROR, "%s - Not authorized sending 480", __fxName));
            hr = CreateAndSendResponseMsg(480,
                                 SIP_STATUS_TEXT(480),
                                 SIP_STATUS_TEXT_SIZE(480),
                                 NULL,
                                 TRUE, 
                                 NULL, 0,  // No Message Body
                                 NULL, 0  //No Content Type
                                 );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, 
                    " %s CreateAndSendResponseMsg failed", __fxName));
                OnTransactionDone();
                return hr;
            }
            m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;
            // This timer will just ensure that we maintain state to
            // deal with retransmits of requests
            hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, 
                    "%s StartTimer failed", __fxName));
                OnTransactionDone();
                return hr;
            }
            return E_FAIL;
        }

        LOG((RTC_TRACE, "%s sending 200", __fxName));
        hr = ProcessRecordRouteContactAndFromHeadersInRequest(pSipMsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s ProcessRecordRouteContactAndFromHeadersInRequest failed", __fxName));
            OnTransactionDone();
            return hr;
        }

        hr = CreateAndSendResponseMsg(200,
                             SIP_STATUS_TEXT(200),
                             SIP_STATUS_TEXT_SIZE(200),
                             NULL,
                             TRUE, 
                             NULL, 0,  // No Message Body
                             NULL, 0  //No Content Type
                             );

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                " %s CreateAndSendResponseMsg failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;
        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s StartTimer failed", __fxName));
            OnTransactionDone();
            return hr;
        }

        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s RetransmitResponse failed in state INCOMING_TRANS_FINAL_RESPONSE_SENT",
                __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
    
}

HRESULT
INCOMING_MESSAGE_TRANSACTION::SendResponse(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT hr;
    ASSERT(m_State != INCOMING_TRANS_FINAL_RESPONSE_SENT);
    LOG((RTC_TRACE, 
        "Sending INCOMING_MESSAGE_TRANSACTION::CreateAndSendResponseMsg %d", StatusCode));
    hr = CreateAndSendResponseMsg(StatusCode, ReasonPhrase, ReasonPhraseLen, NULL, TRUE,
                         NULL, 0,  // No Message Body
                         NULL, 0   //No Content Type
                         );
    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    return hr;
}


HRESULT
INCOMING_MESSAGE_TRANSACTION::RetransmitResponse()
{
    DWORD Error;
    LOG((RTC_TRACE,
        "Inside INCOMING_MESSAGE_TRANSACTION::RetransmitResponse"));
    // Send the buffer.
    Error = m_pResponseSocket->Send( m_pResponseBuffer );
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
        LOG((RTC_ERROR, 
            "INCOMING_MESSAGE_TRANSACTION::RetransmitResponse failed"));
        return HRESULT_FROM_WIN32(Error);
    }
    return S_OK;
}

VOID
INCOMING_MESSAGE_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_MESSAGE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();
        break;

        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }
    return;
}

//Called from CleanupBeforeBye
HRESULT
INCOMING_MESSAGE_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    LOG((RTC_TRACE,
        "INCOMING_MESSAGE_TRANSACTION::TerminateTransactionOnByeOrCancel"));

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// OUTGOING BYE_MESSAGE TRANSACTION
///////////////////////////////////////////////////////////////////////////////

OUTGOING_MESSAGE_TRANSACTION::OUTGOING_MESSAGE_TRANSACTION(
    IN IMSESSION        *pImSession,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq,
    IN BOOL             AuthHeaderSent,
    IN long             lCookie
    ) :
    OUTGOING_TRANSACTION(pImSession, MethodId, CSeq, AuthHeaderSent)
{
    m_pImSession = pImSession;
    m_lCookie = lCookie;
    LOG((RTC_TRACE,
        "OUTGOING_MESSAGE_TRANSACTION::OUTGOING_MESSAGE_TRANSACTION"));
}

OUTGOING_MESSAGE_TRANSACTION::~OUTGOING_MESSAGE_TRANSACTION()
{
}

HRESULT
OUTGOING_MESSAGE_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    LOG((RTC_TRACE,
         "OUTGOING_MESSAGE_TRANSACTION::ProcessProvisionalResponse()"));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;
        
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_RETRY_INTERVAL_T2);
        if (hr != S_OK)
            return hr;
    }

    // Ignore the Provisional response if a final response
    // has already been received.
    return S_OK;
}

HRESULT
OUTGOING_MESSAGE_TRANSACTION::ProcessRedirectResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("OUTGOING_MESSAGE_TRANSACTION::ProcessRedirectResponse");

    // 380 is also a failure from our point of view.
    // We don't support redirect from a TLS session.
    if (pSipMsg->GetStatusCode() == 380 ||
        m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL)
    {
        LOG((RTC_TRACE, "%s: Processing non-200 StatusCode: %d",
            __fxName, pSipMsg->GetStatusCode()));
        m_pImSession->NotifyMessageInfoCompletion(
            HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
            m_lCookie);
        return S_OK;
    }

    hr = m_pImSession->ProcessRedirect(
                pSipMsg, 
                m_lCookie,
                m_szMsgBody,
                m_MsgBodyLen,
                m_ContentType,
                m_ContentTypeLen,
                USR_STATUS_IDLE   //If the msgbody is not null, this parameter is not used by core
                );

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  ProcessRedirect failed %x",
             __fxName, hr));
        //Notify the core
        m_pImSession->InitiateCallTerminationOnError(hr, m_lCookie);
    }
    return S_OK;
}



HRESULT
OUTGOING_MESSAGE_TRANSACTION::ProcessAuthRequiredResponse(
    IN  SIP_MESSAGE *pSipMsg,
    OUT BOOL        &fDelete
    )
{
    HRESULT                     hr = S_OK;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;
    REGISTER_CONTEXT           *pRegisterContext;

    ENTER_FUNCTION("OUTGOING_MESSAGE_TRANSACTION::ProcessAuthRequiredResponse");
    
    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s - ProcessAuthRequired failed %x", __fxName, hr ));
        m_pImSession->NotifyMessageInfoCompletion(
            HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
            m_lCookie);
        goto done;
    }

    hr = m_pImSession -> CreateOutgoingMessageTransaction(
        TRUE, &SipHdrElement, 1, 
        m_szMsgBody,
        m_MsgBodyLen, 
        m_ContentType,
        m_ContentTypeLen,
        m_lCookie          //Cookie
        );

    free( SipHdrElement.HeaderValue );

    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s-CreateOutgoingMessageTransaction failed %x",
             __fxName, hr ));
    }

done:

    TransactionRelease();
    return hr;
}

HRESULT
OUTGOING_MESSAGE_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    BOOL    fDelete = TRUE;
    PSTR ToHeader;
    ULONG ToHeaderLen;
    
    ENTER_FUNCTION("OUTGOING_MESSAGE_TRANSACTION::ProcessFinalResponse");
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;
        if (IsSuccessfulResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received successful response : %d",
                 __fxName, pSipMsg->GetStatusCode()));
            //Update Remote Tag
            if(m_pImSession->GetIsFirstMessage() == TRUE)
            {
                hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO,
                                              &ToHeader, &ToHeaderLen);
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s - To header not found", __fxName));
                }
                hr = m_pImSession->AddTagFromRequestOrResponseToRemote(
                                        ToHeader, ToHeaderLen );
                if (hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s-AddTagFromResponseToRemote failed %x",
                         __fxName, hr));
                }
                hr = m_pImSession->ProcessRecordRouteAndContactHeadersInResponse(pSipMsg);
                if (hr != S_OK)
                {
                    LOG((RTC_WARN,
                         "%s - processing Record-Route/Contact in response failed %x",
                         __fxName, hr));
                }
                m_pImSession->SetIsFirstMessage(FALSE);
           }
           m_pImSession->NotifyMessageInfoCompletion(
                HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode()),
                m_lCookie);

        }
        else if (IsRedirectResponse(pSipMsg))
        {
            if(m_pImSession->GetIsFirstMessage() == TRUE)
                ProcessRedirectResponse(pSipMsg);
        }
        else if (IsAuthRequiredResponse(pSipMsg))
        {
            hr = ProcessAuthRequiredResponse(pSipMsg, fDelete );
        }
        else if (IsFailureResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received non-200 %d",
                 __fxName, pSipMsg->GetStatusCode()));
            if(m_pImSession->GetIsFirstMessage())
                m_pImSession->SetIsFirstMessage(FALSE);
            m_pImSession->NotifyMessageInfoCompletion(
                HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
                m_lCookie);
        }

        // OnTransactionDone kills the timer
        // KillTimer();

        if( fDelete == TRUE )
        {
            TransactionRelease();
        }
    }
    return S_OK;
}


HRESULT
OUTGOING_MESSAGE_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_MESSAGE_TRANSACTION::MaxRetransmitsDone()
{
    return (m_pImSession->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 11 ||
            m_pImSession->IsSessionDisconnected());
}


VOID
OUTGOING_MESSAGE_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;

    ENTER_FUNCTION("OUTGOING_MESSAGE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
        // we have to retransmit the request even after receiving
        // a provisional response.
    case OUTGOING_TRANS_REQUEST_SENT:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating transaction",
                 __fxName));
            // Terminate the call
            hr = RTC_E_SIP_TIMEOUT;   // Timeout
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            if (hr != S_OK)
                goto error;

            if (m_TimerValue*2 >= SIP_TIMER_RETRY_INTERVAL_T2)
                m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T2;
            else
                m_TimerValue *= 2;

            hr = StartTimer(m_TimerValue);
            if (hr != S_OK)
                goto error;
        }
        break;

    case OUTGOING_TRANS_INIT:
    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

 error:
    DeleteTransactionAndTerminateCallIfFirstMessage(hr);
}

VOID
OUTGOING_MESSAGE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstMessage(
    IN HRESULT TerminateStatusCode
    )
{
    IMSESSION   *pImSession;
    long       lCookie;

    ENTER_FUNCTION("OUTGOING_MESSAGE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstMessage");
    LOG((RTC_TRACE, "%s - enter", __fxName));

    //ASSERT(TerminateStatusCode != 0);
    
    pImSession = m_pImSession;
    // Deleting the transaction could result in the
    // call being deleted. So, we AddRef() it to keep it alive.
    pImSession->AddRef();
    lCookie = m_lCookie;
    // Delete the transaction before you call
    // InitiateCallTerminationOnError as that call will notify the UI
    // and could get stuck till the dialog box returns.
    OnTransactionDone();

    // Terminate the call
    pImSession->InitiateCallTerminationOnError(TerminateStatusCode, lCookie);
    pImSession->Release();
    LOG((RTC_TRACE, "%s - Leave", __fxName));
}

VOID
OUTGOING_MESSAGE_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT hr
    )
{
    DeleteTransactionAndTerminateCallIfFirstMessage(hr);
}


///////////////////////////////////////////////////////////////////////////////
// INCOMING BYE_MESSAGE TRANSACTION
///////////////////////////////////////////////////////////////////////////////


INCOMING_BYE_MESSAGE_TRANSACTION::INCOMING_BYE_MESSAGE_TRANSACTION(
    IN IMSESSION        *pImSession,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq
    ) :
    INCOMING_TRANSACTION(pImSession, MethodId, CSeq)
{
    m_pImSession            = pImSession;
    LOG((RTC_TRACE,
        "INCOMING_BYE_MESSAGE_TRANSACTION::INCOMING_BYE_MESSAGE_TRANSACTION"));
}


// This must be a retransmission. Just retransmit the response.
// A new request is handled in CreateIncoming***Transaction()
HRESULT
INCOMING_BYE_MESSAGE_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    ENTER_FUNCTION("INCOMING_BYE_MESSAGE_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "entering %s", __fxName));

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:
        LOG((RTC_TRACE, "%s sending 200", __fxName));
        hr = CreateAndSendResponseMsg(200,
                             SIP_STATUS_TEXT(200),
                             SIP_STATUS_TEXT_SIZE(200),
                             NULL, 
                             TRUE,
                             NULL, 0,  // No Message Body
                             NULL, 0  //No Content Type
                             );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s CreateAndSendResponseMsg failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s StartTimer failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
            "%s RetransmitResponse failed in state INCOMING_TRANS_FINAL_RESPONSE_SENT"
            , __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_BYE_MESSAGE_TRANSACTION::SendResponse(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT hr;
    ASSERT(m_State != INCOMING_TRANS_FINAL_RESPONSE_SENT);
    LOG((RTC_TRACE, 
        "Sending INCOMING_BYE_MESSAGE_TRANSACTION::CreateAndSendResponseMsg %d", StatusCode));
    hr = CreateAndSendResponseMsg(StatusCode,
                        ReasonPhrase,
                        ReasonPhraseLen,
                        NULL,
                        TRUE,
                        NULL, 0,  // No Message Body
                        NULL, 0  //No Content Type
                         );
    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    return hr;
}


HRESULT
INCOMING_BYE_MESSAGE_TRANSACTION::RetransmitResponse()
{
    DWORD Error;
    
    // Send the buffer.
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
    LOG((RTC_ERROR, 
        "INCOMING_BYE_MESSAGE_TRANSACTION::RetransmitResponse failed"));
        return HRESULT_FROM_WIN32(Error);
    }
    return S_OK;
}


VOID
INCOMING_BYE_MESSAGE_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_BYE_MESSAGE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}


HRESULT
INCOMING_BYE_MESSAGE_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    LOG((RTC_TRACE, 
        "Inside INCOMING_BYE_MESSAGE_TRANSACTION::TerminateTransactionOnByeOrCancel"));
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// OUTGOING BYE_MESSAGE TRANSACTION
///////////////////////////////////////////////////////////////////////////////

OUTGOING_BYE_MESSAGE_TRANSACTION::OUTGOING_BYE_MESSAGE_TRANSACTION(
    IN IMSESSION        *pImSession,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq,
    IN BOOL             AuthHeaderSent
    ) :
    OUTGOING_TRANSACTION(pImSession, MethodId, CSeq, AuthHeaderSent)
{
    LOG((RTC_TRACE,
        "Inside OUTGOING_BYE_MESSAGE_TRANSACTION::OUTGOING_BYE_MESSAGE_TRANSACTION"));
    m_pImSession = pImSession;
}


HRESULT
OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    LOG((RTC_TRACE,
         "OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessProvisionalResponse()"));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;
        
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_RETRY_INTERVAL_T2);
        if (hr != S_OK)
            return hr;
    }

    // Ignore the Provisional response if a final response
    // has already been received.
    return S_OK;
}


HRESULT
OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessAuthRequiredResponse(
    IN  SIP_MESSAGE *pSipMsg,
    OUT BOOL        &fDelete
    )
{
    HRESULT                     hr = S_OK;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;
    REGISTER_CONTEXT           *pRegisterContext;

    ENTER_FUNCTION("OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessAuthRequiredResponse");

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        goto done;
    }

    hr = m_pImSession->CreateOutgoingByeTransaction(TRUE, &SipHdrElement, 1);

    free(SipHdrElement.HeaderValue);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingByeTransaction failed %x",
             __fxName, hr));
        
        goto done;
    }

    hr = S_OK;

done:
    TransactionRelease();
    return hr;
}


HRESULT
OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    BOOL    fDelete = TRUE;    

    ENTER_FUNCTION("OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessFinalResponse");
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;
        if (IsSuccessfulResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received successful response : %d",
                 __fxName, pSipMsg->GetStatusCode()));
        }
        else if (IsAuthRequiredResponse(pSipMsg))
        {
            hr = ProcessAuthRequiredResponse( pSipMsg, fDelete );
        }
        else if (IsFailureResponse(pSipMsg) ||
                 IsRedirectResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received non-200 %d",
                 __fxName, pSipMsg->GetStatusCode()));
        }
        
        // OnTransactionDone kills the timer
        // KillTimer();
                
        if( fDelete == TRUE )
        {
            TransactionRelease();
        }
    }
    return S_OK;
}


HRESULT
OUTGOING_BYE_MESSAGE_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_BYE_MESSAGE_TRANSACTION::MaxRetransmitsDone()
{
    return (m_pImSession->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 11);
}


VOID
OUTGOING_BYE_MESSAGE_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;
    
    ENTER_FUNCTION("OUTGOING_BYE_MESSAGE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
        // we have to retransmit the request even after receiving
        // a provisional response.
    case OUTGOING_TRANS_REQUEST_SENT:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating transaction",
                 __fxName));
            // Terminate the call
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            if (hr != S_OK)
                goto error;

            if (m_TimerValue*2 >= SIP_TIMER_RETRY_INTERVAL_T2)
                m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T2;
            else
                m_TimerValue *= 2;

            hr = StartTimer(m_TimerValue);
            if (hr != S_OK)
                goto error;
        }
        break;

    case OUTGOING_TRANS_INIT:
    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

 error:
    // This should initiate call deletion.
    // We shouldn't call InitiateCallTerminationOnError()
    // as we are already doing the BYE transaction.
    OnTransactionDone();
}

///////////////////////////////////////////////////////////////////////////////
// INCOMING INFO_MESSAGE TRANSACTION
///////////////////////////////////////////////////////////////////////////////


INCOMING_INFO_MESSAGE_TRANSACTION::INCOMING_INFO_MESSAGE_TRANSACTION(
    IN IMSESSION        *pImSession,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq
    ) :
    INCOMING_TRANSACTION(pImSession, MethodId, CSeq)
{
    m_pImSession            = pImSession;
    LOG((RTC_TRACE,
        "INCOMING_INFO_MESSAGE_TRANSACTION::INCOMING_INFO_MESSAGE_TRANSACTION"));
}


// This must be a retransmission. Just retransmit the response.
// A new request is handled in CreateIncoming***Transaction()
HRESULT
INCOMING_INFO_MESSAGE_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    ENTER_FUNCTION("INCOMING_INFO_MESSAGE_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "entering %s", __fxName));

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:

        PSTR    ContentTypeHdrValue;
        ULONG   ContentTypeHdrValueLen;
        USR_STATUS UsrStatus;

        PSTR            FromHeader;
        ULONG           FromHeaderLen;
        BSTR            bstrCallerURI;
        ULONG           BytesParsed;
        LPWSTR          wsCallerURI;
        OFFSET_STRING   DisplayName;
        OFFSET_STRING   AddrSpec;
        BOOL            isAuthorized;
        //Check for authorization (offline/ blocked buddy)
        hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &FromHeader, &FromHeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s getting From header failed %x",
                 __fxName, hr));
            return hr;
        }
        BytesParsed = 0;
        hr = ParseNameAddrOrAddrSpec(FromHeader, FromHeaderLen, &BytesParsed,
                                     '\0', // no header list separator
                                     &DisplayName, &AddrSpec);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ParseNameAddrOrAddrSpec failed at %d",
                 __fxName, BytesParsed));
            return hr;
        }

        hr = UTF8ToUnicode(AddrSpec.GetString(FromHeader),
                           AddrSpec.GetLength(),
                           &wsCallerURI);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s -UTF8ToUnicode failed %x",
            __fxName,
             hr));
            return hr;
        }

        bstrCallerURI = SysAllocString(wsCallerURI);
        free(wsCallerURI);
        if (bstrCallerURI == NULL)
        {
            LOG((RTC_WARN, "%s -bstrmsg allocation failed %x",
            __fxName, hr));
            return E_OUTOFMEMORY;
        }
        hr = m_pImSession->GetIsIMSessionAuthorizedFromCore(
                                bstrCallerURI, 
                                &isAuthorized);
        SysFreeString(bstrCallerURI);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - GetIsIMSessionAuthorizedFromCore failed %x", 
                __fxName, hr));
            return hr;
        }
        if(!isAuthorized)
        {
            LOG((RTC_ERROR, "%s - Not authorized sending 480", __fxName));
            hr = CreateAndSendResponseMsg(480,
                                 SIP_STATUS_TEXT(480),
                                 SIP_STATUS_TEXT_SIZE(480),
                                 NULL,
                                 TRUE, 
                                 NULL, 0,  // No Message Body
                                 NULL, 0  //No Content Type
                                 );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, 
                    "%s CreateAndSendResponseMsg failed", __fxName));
                OnTransactionDone();
                return hr;
            }

            m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;
    
            // This timer will just ensure that we maintain state to
            // deal with retransmits of requests
            hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, 
                    "%s StartTimer failed", __fxName));
                OnTransactionDone();
                return hr;
            }
            return E_FAIL;
        }

        if (pSipMsg->MsgBody.Length != 0)
        {
            // We have Message Body. Check type.

            hr = pSipMsg->GetSingleHeader(SIP_HEADER_CONTENT_TYPE,
                                 &ContentTypeHdrValue,
                                 &ContentTypeHdrValueLen);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s - Couldn't find Content-Type header %x",
                    __fxName, hr));
                OnTransactionDone();
                return E_FAIL;
            }
            if (IsContentTypeAppXml(ContentTypeHdrValue, 
                ContentTypeHdrValueLen))
            {
                //Parse XMLBlob and get status
                hr = ParseStatXMLBlob (
                    pSipMsg->MsgBody.GetString(pSipMsg->BaseBuffer),
                    pSipMsg->MsgBody.Length,
                    &UsrStatus
                    );
                if(hr != S_OK)
                {
                    LOG((RTC_ERROR, "%s Messagebody of INFO does not match sending 415", 
                        __fxName));
                    hr = CreateAndSendResponseMsg(415,
                        SIP_STATUS_TEXT(415),
                        SIP_STATUS_TEXT_SIZE(415),
                        NULL, 
                        TRUE,
                        NULL, 0,  // No Message Body
                        NULL, 0  //No Content Type
                        );
                    
                    OnTransactionDone();
                    return hr;
                    
                }
                m_pImSession->SetUsrStatus(UsrStatus);
            }
            else
            {
                LOG((RTC_ERROR, "%s Content-Type of INFO does not match sending 415", 
                    __fxName));
                 hr = CreateAndSendResponseMsg(415,
                    SIP_STATUS_TEXT(415),
                    SIP_STATUS_TEXT_SIZE(415),
                    NULL, 
                    TRUE,
                    NULL, 0,  // No Message Body
                    NULL, 0 // No content Type
                    );
                OnTransactionDone();
                return hr;
            }
        }
        else
        {
        LOG((RTC_TRACE, "%s No messagebody in INFO", 
            __fxName));
        }

        hr = ProcessRecordRouteContactAndFromHeadersInRequest(pSipMsg);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s ProcessRecordRouteContactAndFromHeadersInRequest failed", __fxName));
            OnTransactionDone();
            return hr;
        }

        LOG((RTC_TRACE, "%s sending 200", __fxName));
        hr = CreateAndSendResponseMsg(200,
            SIP_STATUS_TEXT(200),
            SIP_STATUS_TEXT_SIZE(200),
            NULL, 
            TRUE,
            NULL, 0,  // No Message Body
            NULL, 0  //No Content Type
            );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s CreateAndSendResponseMsg failed", __fxName));
            OnTransactionDone();
            return hr;
        }

        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;
    
        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
                "%s StartTimer failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
    
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, 
            "RetransmitResponse failed in state INCOMING_TRANS_FINAL_RESPONSE_SENT"));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_INFO_MESSAGE_TRANSACTION::SendResponse(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT hr;
    ASSERT(m_State != INCOMING_TRANS_FINAL_RESPONSE_SENT);
    LOG((RTC_TRACE, 
        "Sending INCOMING_INFO_MESSAGE_TRANSACTION::CreateAndSendResponseMsg %d", StatusCode));
    hr = CreateAndSendResponseMsg(StatusCode,
                        ReasonPhrase,
                        ReasonPhraseLen,
                        NULL,
                        TRUE,
                        NULL, 0,  // No Message Body
                        NULL, 0  //No Content Type
                         );
    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    return hr;
}


HRESULT
INCOMING_INFO_MESSAGE_TRANSACTION::RetransmitResponse()
{
    DWORD Error;
    
    // Send the buffer.
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
    LOG((RTC_ERROR, 
        "INCOMING_INFO_MESSAGE_TRANSACTION::RetransmitResponse failed"));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


VOID
INCOMING_INFO_MESSAGE_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_INFO_MESSAGE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}


HRESULT
INCOMING_INFO_MESSAGE_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    LOG((RTC_TRACE, 
        "Inside INCOMING_INFO_MESSAGE_TRANSACTION::TerminateTransactionOnByeOrCancel"));
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// OUTGOING INFO_MESSAGE TRANSACTION
///////////////////////////////////////////////////////////////////////////////

OUTGOING_INFO_MESSAGE_TRANSACTION::OUTGOING_INFO_MESSAGE_TRANSACTION(
    IN IMSESSION        *pImSession,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq,
    IN BOOL             AuthHeaderSent,
    IN long             lCookie,
    IN USR_STATUS       UsrStatus
    ) :
    OUTGOING_TRANSACTION(pImSession, MethodId, CSeq, AuthHeaderSent)
{
    LOG((RTC_TRACE,
        "Inside OUTGOING_INFO_MESSAGE_TRANSACTION::OUTGOING_INFO_MESSAGE_TRANSACTION"));
    m_pImSession = pImSession;
    m_lCookie = lCookie;
    m_InfoUsrStatus = UsrStatus;
}

HRESULT
OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    LOG((RTC_TRACE,
         "OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessProvisionalResponse()"));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;
        
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_RETRY_INTERVAL_T2);
        if (hr != S_OK)
            return hr;
    }

    // Ignore the Provisional response if a final response
    // has already been received.
    return S_OK;
}

HRESULT
OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessRedirectResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessRedirectResponse");

    // 380 is also a failure from our point of view.
    // We don't support redirect from a TLS session.
    if (pSipMsg->GetStatusCode() == 380 ||
        m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL)
    {
        LOG((RTC_TRACE, "%s: Processing non-200 StatusCode: %d",
           __fxName, pSipMsg->GetStatusCode()));
        m_pImSession->NotifyMessageInfoCompletion(
           HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
           m_lCookie);

        return S_OK;
    }

    hr = m_pImSession->ProcessRedirect(
                pSipMsg, 
                m_lCookie,
                NULL, NULL,   //No MsgBody
                NULL, NULL,   //No contentType
                m_InfoUsrStatus
                );

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s  ProcessRedirect failed %x",
             __fxName, hr));
        //Notify the core
        m_pImSession->InitiateCallTerminationOnError(hr, m_lCookie);
    }

    return S_OK;
}


HRESULT
OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessAuthRequiredResponse(
    IN  SIP_MESSAGE *pSipMsg,
    OUT BOOL        &fDelete
    )
{
    HRESULT                     hr;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;
    REGISTER_CONTEXT           *pRegisterContext;

    ENTER_FUNCTION("OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessAuthRequiredResponse");

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        m_pImSession->NotifyMessageInfoCompletion(
            HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
            m_lCookie);
        goto done;
    }

    hr = m_pImSession->CreateOutgoingInfoTransaction(TRUE, &SipHdrElement, 1,
                                                      m_szMsgBody,
                                                      m_MsgBodyLen, 
                                                      m_ContentType,
                                                      m_ContentTypeLen,
                                                      m_lCookie,        //cookie
                                                      m_InfoUsrStatus       
                                                      );
    free(SipHdrElement.HeaderValue);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingInfoTransaction failed %x",
             __fxName, hr));
        goto done;
    }

    hr = S_OK;

done:
    TransactionRelease();
    return hr;
}


HRESULT
OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    BOOL    fDelete = TRUE;
            
    ENTER_FUNCTION("OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessFinalResponse");
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;
        if (IsSuccessfulResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received successful response : %d",
                 __fxName, pSipMsg->GetStatusCode()));
            m_pImSession->NotifyMessageInfoCompletion(
                HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode()),
                m_lCookie);

        }
        else if (IsAuthRequiredResponse(pSipMsg))
        {
            hr = ProcessAuthRequiredResponse( pSipMsg, fDelete );
        }
        else if (IsFailureResponse(pSipMsg) ||
                IsRedirectResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s received non-200 %d",
                 __fxName, pSipMsg->GetStatusCode()));
            m_pImSession->NotifyMessageInfoCompletion(
                HRESULT_FROM_SIP_ERROR_STATUS_CODE(pSipMsg->GetStatusCode()),
                m_lCookie);
        }
  
        // OnTransactionDone kills the timer
        // KillTimer();
        if( fDelete == TRUE )
        {
            TransactionRelease();
        }
    }
    return S_OK;
}

HRESULT
OUTGOING_INFO_MESSAGE_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_INFO_MESSAGE_TRANSACTION::MaxRetransmitsDone()
{
    return (m_pImSession->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 11 ||
            m_pImSession->IsSessionDisconnected());
}


VOID
OUTGOING_INFO_MESSAGE_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;
    
    ENTER_FUNCTION("OUTGOING_INFO_MESSAGE_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
        // we have to retransmit the request even after receiving
        // a provisional response.
    case OUTGOING_TRANS_REQUEST_SENT:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating transaction",
                 __fxName));
            // Terminate the call
            hr = RTC_E_SIP_TIMEOUT;
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            if (hr != S_OK)
                goto error;

            if (m_TimerValue*2 >= SIP_TIMER_RETRY_INTERVAL_T2)
                m_TimerValue = SIP_TIMER_RETRY_INTERVAL_T2;
            else
                m_TimerValue *= 2;

            hr = StartTimer(m_TimerValue);
            if (hr != S_OK)
                goto error;
        }
        break;

    case OUTGOING_TRANS_INIT:
    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

 error:
    DeleteTransactionAndTerminateCallIfFirstMessage(hr);
}

VOID
OUTGOING_INFO_MESSAGE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstMessage(
    IN HRESULT TerminateStatusCode
    )
{
    
    IMSESSION   *pImSession;
    long       lCookie;

    ENTER_FUNCTION("OUTGOING_MESSAGE_TRANSACTION::DeleteTransactionAndTerminateCallIfFirstMessage");
    LOG((RTC_TRACE, "%s - enter", __fxName));

    //ASSERT(TerminateStatusCode != 0);
    
    pImSession = m_pImSession;
    // Deleting the transaction could result in the
    // call being deleted. So, we AddRef() it to keep it alive.
    pImSession->AddRef();
    lCookie = m_lCookie;
    
    // Delete the transaction before you call
    // InitiateCallTerminationOnError as that call will notify the UI
    // and could get stuck till the dialog box returns.
    //delete this;
     OnTransactionDone();
    // Terminate the call
    pImSession->InitiateCallTerminationOnError(TerminateStatusCode, lCookie);
    pImSession->Release();
    LOG((RTC_TRACE, "%s - Leave", __fxName));
}

VOID
OUTGOING_INFO_MESSAGE_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT      hr
    )
{
    DeleteTransactionAndTerminateCallIfFirstMessage(hr);
}


//xml related parsing
PSTR
GetTextFromStatus( 
    IN  USR_STATUS UsrStatus 
    )
{
    static  PSTR    pstr[4] = { "idle", 
                                "type",
                              };
    
    return pstr[UsrStatus];
}


DWORD
GetTagType(
    PSTR*   ppXMLBlobTag,
    DWORD   dwTagLen
    )
{
    CHAR    pstrTemp[40];

    HRESULT hr = GetNextWord( ppXMLBlobTag, pstrTemp, sizeof pstrTemp );

    if( hr == S_OK )
    {
        if( strcmp( pstrTemp, USRSTATUS_TAG_TEXT) == 0 )
        {
            return USRSTATUS_TAG;
        }
        else if( strcmp( pstrTemp, KEY_TAG_TEXT) == 0 )
        {
            return KEY_TAG;
        }
        else if( strcmp( pstrTemp, KEYEND_TAG_TEXT) == 0 )
        {
            return KEYEND_TAG;
        }
        else if( strcmp( pstrTemp, XMLVERSION_TAG_TEXT) == 0 )
        {
            return XMLVERSION_TAG;
        }
    }

    return XMLUNKNOWN_TAG;
}


HRESULT
ProcessStatusTag(
    IN  PSTR    pXMLBlobTag, 
    IN  DWORD   dwTagLen,
    OUT USR_STATUS* UsrStatus
    )
{
    PSTR    pstrTemp;
    CHAR    ch;

    SkipWhiteSpaces( pXMLBlobTag );
    
    if( strncmp( pXMLBlobTag, "status=", strlen("status=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("status=");

    SkipWhiteSpaces( pXMLBlobTag );

    pstrTemp = pXMLBlobTag;

    while(  (*pXMLBlobTag != NULL_CHAR) && (*pXMLBlobTag != NEWLINE_CHAR) && 
            (*pXMLBlobTag != BLANK_CHAR) && (*pXMLBlobTag != TAB_CHAR) )
    {
        pXMLBlobTag++;
    }

    ch = *pXMLBlobTag;
    *pXMLBlobTag = NULL_CHAR;

    if( strcmp( pstrTemp, "\"idle\"" ) == 0 )
    {
        *UsrStatus = USR_STATUS_IDLE;
    }
    else if( strcmp( pstrTemp, "\"type\"" ) == 0 )
    {
        *UsrStatus = USR_STATUS_TYPING;
    }
    else
    {
        return E_FAIL;
    }

    *pXMLBlobTag = ch;

    return S_OK;
}

HRESULT ParseStatXMLBlob (
                  IN PSTR xmlBlob,
                  IN DWORD dwXMLBlobLen,
                  OUT USR_STATUS* UsrStatus
                  )
{
    DWORD dwTagLen;
    char* pXMLBlobTag;
    PSTR pXMLBlobTagSave;
    HRESULT hr;
    pXMLBlobTag = (PSTR)malloc(dwXMLBlobLen*sizeof(char));

    if (pXMLBlobTag == NULL) 
    {
        return E_OUTOFMEMORY;
    }

    pXMLBlobTagSave = pXMLBlobTag;

    //Put a \0 at the end of the XML blob. This would help us in parsing.
    xmlBlob[ dwXMLBlobLen-1 ] = '\0';
    
    //Get the XML version tag.
    hr = GetNextTag( xmlBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        free(pXMLBlobTagSave);
        return hr;
    }
    
    if( GetTagType(&pXMLBlobTag, dwTagLen ) != XMLVERSION_TAG )
    {
        free(pXMLBlobTagSave);
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;

    //Get keyboard tag
    hr = GetNextTag( xmlBlob, (char *)pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        free(pXMLBlobTagSave);
        return hr;
    }
    
    if( GetTagType( &pXMLBlobTag, dwTagLen ) != KEY_TAG )
    {
        free(pXMLBlobTagSave);
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;
    
    //Get keyboard tag
    hr = GetNextTag( xmlBlob, (char *)pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        free(pXMLBlobTagSave);
        return hr;
    }

    //get status tag
    if( GetTagType(&pXMLBlobTag, dwTagLen ) != USRSTATUS_TAG )
    {
        free(pXMLBlobTagSave);
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;

    hr = ProcessStatusTag(
        pXMLBlobTag, 
        dwTagLen,
        UsrStatus
        );
    if(hr == S_OK)
        LOG((RTC_TRACE, "ParseStatXMLBlob::User status is %d", *UsrStatus));
    else
    {
        free(pXMLBlobTagSave);
        return E_FAIL;
    }

    //Get keyboard end tag
    hr = GetNextTag( xmlBlob,(char *) pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        free(pXMLBlobTagSave);
        return hr;
    }
    
    if( GetTagType(&pXMLBlobTag, dwTagLen ) != KEYEND_TAG )
    {
        free(pXMLBlobTagSave);
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;
    free(pXMLBlobTagSave);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\md5digest.cpp ===
//
// SIP MD5 Digest Authentication Implementation
//
// Written by Arlie Davis, August 2000
//

#include "precomp.h"
#include "md5digest.h"
#include "util.h"

//
// This comes from nt/public/internal/ds/inc/crypto.
// MD5 requires linking to nt/public/internal/ds/lib/*/rsa32.lib.
// Yes, all of this is private NT source.
//

#include <md5.h>


//
// For use in printf argument lists
//

#define COUNTED_STRING_PRINTF(CountedString) \
    (CountedString) -> Length / sizeof (*(CountedString) -> Buffer), \
    (CountedString) -> Buffer

#define UNICODE_STRING_PRINTF       COUNTED_STRING_PRINTF
#define ANSI_STRING_PRINTF          COUNTED_STRING_PRINTF


#define INITIALIZE_CONST_COUNTED_STRING(Text) \
    { sizeof (Text) - sizeof (*Text), sizeof (Text) - sizeof (*Text), (Text) }

#define INITIALIZE_CONST_UNICODE_STRING     INITIALIZE_CONST_COUNTED_STRING
#define INITIALIZE_CONST_ANSI_STRING        INITIALIZE_CONST_COUNTED_STRING

//
// Global strings
//

static CONST ANSI_STRING String_QualityOfProtection = INITIALIZE_CONST_ANSI_STRING ("qop");
static CONST ANSI_STRING String_Realm       = INITIALIZE_CONST_ANSI_STRING ("realm");
static CONST ANSI_STRING String_Nonce       = INITIALIZE_CONST_ANSI_STRING ("nonce");
static CONST ANSI_STRING String_Algorithm   = INITIALIZE_CONST_ANSI_STRING ("algorithm");
static CONST ANSI_STRING String_Auth        = INITIALIZE_CONST_ANSI_STRING ("auth");
static CONST ANSI_STRING String_AuthInt     = INITIALIZE_CONST_ANSI_STRING ("auth-int");
static CONST ANSI_STRING String_MD5         = INITIALIZE_CONST_ANSI_STRING ("md5");
static CONST ANSI_STRING String_MD5Sess     = INITIALIZE_CONST_ANSI_STRING ("md5-sess");
static CONST ANSI_STRING String_Colon       = INITIALIZE_CONST_ANSI_STRING (":");
static CONST ANSI_STRING String_NonceCount1 = INITIALIZE_CONST_ANSI_STRING ("00000001");
static CONST ANSI_STRING String_Digest      = INITIALIZE_CONST_ANSI_STRING ("Digest");
static CONST ANSI_STRING String_GssapiData  = INITIALIZE_CONST_ANSI_STRING ("gssapi-data");
static CONST ANSI_STRING String_Opaque      = INITIALIZE_CONST_ANSI_STRING ("opaque");



//
// Parsing Routines
//





//
// Remove all of the whitespace from the beginning of a string.
//

void ParseSkipSpace (
    IN  OUT ANSI_STRING *   String)
{
    USHORT  Index;

    ASSERT(String);
    ASSERT(String -> Buffer);

    Index = 0;
    while (Index < String -> Length / sizeof (CHAR)
        && isspace (String -> Buffer [Index]))
        Index++;

    String -> Buffer += Index;
    String -> Length -= Index * sizeof (CHAR);
}

static inline BOOL IsValidParameterNameChar (
    IN  CHAR    Char)
{
    return isalnum (Char) || Char == '-' || Char == '_';
}

#define HTTP_PARAMETER_SEPARATOR    ','
#define HTTP_PARAMETER_ASSIGN_CHAR  '='
#define HTTP_PARAMETER_DOUBLEQUOTE  '\"'

//
// Given a string in this form:
//
//      parm1="foo", parm2="bar", parm3=baz
//
// this function returns parm1 in ReturnName, foo in ReturnValue,
// and parm2="bar, parm3=baz in Remainder.
//
// Parameter values may be quoted, or may not.
// All parameters are separated by commas.
// SourceText == ReturnRemainder is legal.
//
// Return values:
//      S_OK: successfully scanned a parameter
//      S_FALSE: no more data
//      E_INVALIDARG: input is invalid
//

HRESULT ParseScanNamedParameter (
    IN  ANSI_STRING *   SourceText,
    OUT ANSI_STRING *   ReturnRemainder,
    OUT ANSI_STRING *   ReturnName,
    OUT ANSI_STRING *   ReturnValue)
{
    ANSI_STRING     Remainder;
    HRESULT         Result;
    

    Remainder = *SourceText;

    ParseSkipSpace (&Remainder);

    //
    // Scan through the characters of the name of the parameter.
    //

    ReturnName -> Buffer = Remainder.Buffer;

    for (;;) {
        if (Remainder.Length == 0) {
            //
            // Hit the end of the string without ever hitting an equal sign.
            // If we never accumulated anything, then return S_FALSE.
            // Otherwise, it's invalid.
            //

            if (Remainder.Buffer == ReturnName -> Buffer) {
                *ReturnRemainder = Remainder;
                return S_FALSE;
            }
            else {
                LOG((RTC_TRACE, "ParseScanNamedParameter: invalid string (%.*s)\n",
                    ANSI_STRING_PRINTF (SourceText)));

                return E_FAIL;
            }
        }

        if (Remainder.Buffer [0] == HTTP_PARAMETER_ASSIGN_CHAR) {
            //
            // Found the end of the parameter name.
            // Update ReturnName and terminate the loop.
            //

            ReturnName -> Length = ((USHORT)(Remainder.Buffer - ReturnName -> Buffer)) * sizeof (CHAR);

            Remainder.Buffer++;
            Remainder.Length -= sizeof (CHAR);

            break;
        }

        //
        // Validate the character.
        //

        if (!IsValidParameterNameChar (Remainder.Buffer[0])) {
            LOG((RTC_TRACE, "ParseScanNamedParameter: bogus character in parameter name (%.*s)\n",
                ANSI_STRING_PRINTF (SourceText)));
            return E_INVALIDARG;
        }

        Remainder.Buffer++;
        Remainder.Length -= sizeof (CHAR);
    }

    //
    // Now parse the value of the parameter (portion after the equal sign)
    //

    ParseSkipSpace (&Remainder);

    if (Remainder.Length == 0) {
        //
        // The string ends before the parameter has any value at all.
        // Well, it's legal enough.
        //

        ReturnValue -> Length = 0;
        *ReturnRemainder = Remainder;
        return S_OK;
    }

    if (Remainder.Buffer [0] == HTTP_PARAMETER_DOUBLEQUOTE) {
        //
        // The parameter value is quoted.
        // Scan until we hit the next double-quote.
        //

        Remainder.Buffer++;
        Remainder.Length -= sizeof (CHAR);

        ReturnValue -> Buffer = Remainder.Buffer;

        for (;;) {
            if (Remainder.Length == 0) {
                //
                // The matching double-quote was never found.
                //

                LOG((RTC_TRACE, "ParseScanNamedParameter: parameter value had no matching double-quote: (%.*s)\n",
                    ANSI_STRING_PRINTF (SourceText)));

                return E_INVALIDARG;
            }

            if (Remainder.Buffer [0] == HTTP_PARAMETER_DOUBLEQUOTE) {
                ReturnValue -> Length = ((USHORT)(Remainder.Buffer - ReturnValue -> Buffer)) * sizeof (CHAR);
                Remainder.Buffer++;
                Remainder.Length -= sizeof (CHAR);
                break;
            }

            Remainder.Buffer++;
            Remainder.Length -= sizeof (CHAR);
        }

        ParseSkipSpace (&Remainder);

        //
        // Make sure the next character, if any, is a comma.
        //

        if (Remainder.Length > 0) {
            if (Remainder.Buffer [0] != HTTP_PARAMETER_SEPARATOR) {
                LOG((RTC_TRACE, "ParseScanNamedParameter: trailing character after quoted parameter value is NOT a comma! (%.*s)\n",
                    ANSI_STRING_PRINTF (SourceText)));
                return E_INVALIDARG;
            }

            Remainder.Buffer++;
            Remainder.Length -= sizeof (CHAR);
        }

        *ReturnRemainder = Remainder;
    }
    else {
        //
        // The parameter is not quoted.
        // Scan until we hit the first comma.
        //

        ReturnValue -> Buffer = Remainder.Buffer;

        for (;;) {
            if (Remainder.Length == 0) {
                ReturnValue -> Length = ((USHORT)(Remainder.Buffer - ReturnValue -> Buffer)) * sizeof (CHAR);
                ReturnRemainder -> Length = 0;
                break;
            }

            if (Remainder.Buffer [0] == HTTP_PARAMETER_SEPARATOR) {
                ReturnValue -> Length = ((USHORT)(Remainder.Buffer - ReturnValue -> Buffer)) * sizeof (CHAR);
                Remainder.Buffer++;
                Remainder.Length -= sizeof (CHAR);

                *ReturnRemainder = Remainder;
                break;
            }

            Remainder.Buffer++;
            Remainder.Length -= sizeof (CHAR);
        }
    }

#if 1
    LOG((RTC_TRACE, "ParseScanNamedParameter: parameter name (%.*s) value (%.*s) remainder (%.*s)\n",
        ANSI_STRING_PRINTF (ReturnName),
        ANSI_STRING_PRINTF (ReturnValue),
        ANSI_STRING_PRINTF (ReturnRemainder)));
#endif

    return S_OK;
}


//
// MD5 Support Stuff
//

#define MD5_HASHLEN         0x10
#define MD5_HASHTEXTLEN     0x20

typedef UCHAR MD5_HASH      [MD5_HASHLEN];
typedef CHAR MD5_HASHTEXT   [MD5_HASHTEXTLEN+1];


void CvtHex(
    IN  UCHAR          *Bin,
    OUT CHAR           *Hex,
    IN  ULONG           ulHashLen )
{
    unsigned short i;
    unsigned char j;

    for (i = 0; i < ulHashLen; i++) {
        j = (Bin[i] >> 4) & 0xf;
        if (j <= 9)
            Hex[i*2] = (j + '0');
         else
            Hex[i*2] = (j + 'a' - 10);
        j = Bin[i] & 0xf;
        if (j <= 9)
            Hex[i*2+1] = (j + '0');
         else
            Hex[i*2+1] = (j + 'a' - 10);
    };
    Hex[ulHashLen*2] = '\0';
};


static void MD5Update (
    IN  MD5_CTX *       Context,
    IN  CONST ANSI_STRING * AnsiString)
{
    MD5Update (Context, (PUCHAR) AnsiString -> Buffer, AnsiString -> Length);
}

static void MD5Final (
    OUT MD5_HASH            ReturnHash,
    IN  MD5_CTX *       Context)
{
    MD5Final (Context);
    CopyMemory (ReturnHash, Context -> digest, MD5_HASHLEN);
}


//
// DigestParameters points to the string that contains the Digest authentication parameters.
// This is pulled from the WWW-Authenticate header in the 4xx response.
// For example, DigestParameters could be:
//
//      qop="auth", realm="localhost", nonce="c0c3dd7896f96bba353098100000d03637928b037ba2f3f17ed861457949"
//
// This function parses the data and builds the authorization line.
// The authorization line can be used in a new HTTP/SIP request,
// as long as the method and URI do not change.
//
// On exit with S_OK ReturnAuthorizationLine contains
// a buffer allocated with malloc(). The caller should free it with free()

HRESULT BuildDigestResponse(
    IN  SECURITY_CHALLENGE *  Challenge,
    IN  SECURITY_PARAMETERS * Parameters,
    IN  OUT ANSI_STRING *   ReturnAuthorizationLine
    )
{
    MD5_HASH        HA1;
    MD5_HASH        HA2;
    MD5_HASHTEXT    HA1Text;
    MD5_HASHTEXT    HA2Text;
    MD5_HASH        ResponseHash;
    MD5_HASHTEXT    ResponseHashText;
    MD5_CTX         MD5Context;
    ANSI_STRING *   NonceCount;
    MESSAGE_BUILDER Builder;

    ENTER_FUNCTION("BuildDigestResponse");

    ASSERT(Challenge);
    ASSERT(Parameters);
    ASSERT(ReturnAuthorizationLine);

    ReturnAuthorizationLine -> Length = 0;

    if (Challenge -> QualityOfProtection.Length > 0
        && !RtlEqualString (&Challenge -> QualityOfProtection,
        const_cast<ANSI_STRING *>(&String_Auth), TRUE))
    {
        LOG((RTC_TRACE,
             "%s - unsupported quality of protection (%.*s)",
             __fxName, ANSI_STRING_PRINTF (&Challenge -> QualityOfProtection)));

        return RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
    }

    //
    // For SIP, the nonce count is always one, because nonces are never reused.
    //

    NonceCount = const_cast<ANSI_STRING *> (&String_NonceCount1);


    //
    // Calculate HA1.
    //

    MD5Init (&MD5Context);
    MD5Update (&MD5Context, &Parameters -> Username);
    MD5Update (&MD5Context, &String_Colon);
    MD5Update (&MD5Context, &Challenge -> Realm);
    MD5Update (&MD5Context, &String_Colon);
    MD5Update (&MD5Context, &Parameters -> Password);
    MD5Final (HA1, &MD5Context);

    //
    // If we are doing MD5 session, then:
    //
    //      HA1 = MD5 ( MD5 (username:realm:password) :nonce:clientnonce )
    //
    // Otherwise, for normal (single-shot) authentication:
    //
    //      HA1 = MD5 ( username:realm:password )
    //

    if (RtlEqualString (&Challenge -> Algorithm,
        const_cast<ANSI_STRING *> (&String_MD5Sess), TRUE))
    {
        LOG((RTC_TRACE, "%s - calculating HA1 for md5 sess",
             __fxName));
        MD5Init (&MD5Context);
        // MD5Update (&MD5Context, HA1, MD5_HASHLEN);

        // RFC 2617 supposedly has a bug here in the code.

        CvtHex (HA1, HA1Text, MD5_HASHLEN);
        MD5Update (&MD5Context, (PUCHAR) HA1Text, MD5_HASHTEXTLEN);
        
        MD5Update (&MD5Context, &String_Colon);
        MD5Update (&MD5Context, &Challenge -> Nonce);
        MD5Update (&MD5Context, &String_Colon);
        MD5Update (&MD5Context, &Parameters -> ClientNonce);
        MD5Final (HA1, &MD5Context);
    };

    CvtHex (HA1, HA1Text, MD5_HASHLEN);

    //
    // Calculate the response digest.
    //

    // calculate H(A2)
    MD5Init (&MD5Context);
    MD5Update (&MD5Context, &Parameters -> RequestMethod);
    MD5Update (&MD5Context, &String_Colon);
    MD5Update (&MD5Context, &Parameters -> RequestURI);
    if (RtlEqualString (&Challenge -> QualityOfProtection,
        const_cast<ANSI_STRING *> (&String_AuthInt), TRUE))
    {
#if 0
        MD5Update (&MD5Context, &String_Colon);
        MD5Update (&MD5Context, (PUCHAR) HEntity, MD5_HASHTEXTLEN);
#else
        //
        // Integrity authentication is not supported.
        // In order to provide for integrity authentication,
        // add an argument to this function which takes the
        // MD5 signature of the content body (entity) of the
        // message, and repair this #if 0.
        //

        LOG((RTC_TRACE, "DIGEST: message integrity authentication (qop=auth-int) is not supported\n"));
        return RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
#endif
    };

    MD5Final(HA2, &MD5Context);
    CvtHex(HA2, HA2Text, MD5_HASHLEN );

    // calculate response
    MD5Init(&MD5Context);
    MD5Update (&MD5Context, (PUCHAR) HA1Text, MD5_HASHTEXTLEN);
    MD5Update (&MD5Context, &String_Colon);
    MD5Update (&MD5Context, &Challenge -> Nonce);
    MD5Update (&MD5Context, &String_Colon);
    if (Challenge -> QualityOfProtection.Length > 0)
    {
        MD5Update (&MD5Context, NonceCount);
        MD5Update (&MD5Context, &String_Colon);
        MD5Update (&MD5Context, &Parameters -> ClientNonce);
        MD5Update (&MD5Context, &String_Colon);
        MD5Update (&MD5Context, &Challenge -> QualityOfProtection);
        MD5Update (&MD5Context, &String_Colon);
    };
    MD5Update (&MD5Context, (PUCHAR) HA2Text, MD5_HASHTEXTLEN);
    MD5Final(ResponseHash, &MD5Context);
    CvtHex(ResponseHash, ResponseHashText, MD5_HASHLEN );

    PSTR    Header;
    ULONG   HeaderLength;

    HeaderLength =
        strlen("Digest ") +
        strlen("username=\"")       + Parameters->Username.Length   +
        strlen("\", realm=\"")      + Challenge->Realm.Length       +
        strlen("\", algorithm=\"")  + Challenge->Algorithm.Length   +
        strlen("\", uri=\"")        + Parameters->RequestURI.Length +
        strlen("\", nonce=\"")      + Challenge->Nonce.Length       +
        strlen("\", response=\"")   + MD5_HASHTEXTLEN +  strlen("\"") + 1;
        
    if (Challenge -> QualityOfProtection.Length > 0)
    {
        HeaderLength +=
            strlen("\", qop=\"")    + Challenge->QualityOfProtection.Length +
            strlen("\", nc=\"")     + NonceCount->Length                    +
            strlen("\", cnonce=\"") + Parameters->ClientNonce.Length;
    }

    if (Challenge->Opaque.Length > 0)
    {
        HeaderLength +=
            strlen("\", opaque=\"") + Challenge->Opaque.Length;
    }
    
    Header = (PSTR) malloc(HeaderLength * sizeof(CHAR));
    if (Header == NULL)
    {
        LOG((RTC_ERROR, "%s - failed to allocate header HeaderLength: %d",
             __fxName, HeaderLength));
        return E_OUTOFMEMORY;
    }
    
    //
    // Build the HTTP/SIP response line.
    //

//      Builder.PrepareBuild (
//          ReturnAuthorizationLine -> Buffer,
//          ReturnAuthorizationLine -> MaximumLength);

    Builder.PrepareBuild(Header, HeaderLength);

    Builder.Append ("Digest ");
    Builder.Append ("username=\"");
    Builder.Append (&Parameters -> Username);
    Builder.Append ("\", realm=\"");
    Builder.Append (&Challenge -> Realm);

    if (Challenge -> QualityOfProtection.Length > 0)
    {
        Builder.Append ("\", qop=\"");
        Builder.Append (&Challenge -> QualityOfProtection);
    }

    Builder.Append ("\", algorithm=\"");
    Builder.Append (&Challenge -> Algorithm);
    Builder.Append ("\", uri=\"");
    Builder.Append (&Parameters -> RequestURI);
    Builder.Append ("\", nonce=\"");
    Builder.Append (&Challenge->Nonce);

    if (Challenge -> QualityOfProtection.Length > 0)
    {
        Builder.Append ("\", nc=\"");
        Builder.Append (NonceCount);
        Builder.Append ("\", cnonce=\"");
        Builder.Append (&Parameters->ClientNonce);
    }
    
    if (Challenge->Opaque.Length > 0)
    {
        Builder.Append ("\", opaque=\"");
        Builder.Append (&Challenge->Opaque);
    }
    
    Builder.Append ("\", response=\"");
    Builder.Append (ResponseHashText, MD5_HASHTEXTLEN);
    Builder.Append ("\"");

    if (Builder.OverflowOccurred())
    {
        LOG((RTC_TRACE,
             "%s - not enough buffer space -- need %u bytes, got %u\n",
             __fxName, Builder.GetLength(), HeaderLength));
        ASSERT(FALSE);

        free(Header);
        return E_FAIL;
    }

    ASSERT((USHORT) Builder.GetLength() <= HeaderLength);

    ReturnAuthorizationLine->Length         = (USHORT) Builder.GetLength();
    ReturnAuthorizationLine->MaximumLength  = (USHORT) HeaderLength;
    ReturnAuthorizationLine->Buffer         = Header;

    //
    // Brag a little.
    //

#if 1
    LOG((RTC_TRACE, "DIGEST: successfully built digest response:\n"));
    LOG((RTC_TRACE, "- username (%.*s) (password not shown) method (%.*s) uri (%.*s)\n",
        ANSI_STRING_PRINTF (&Parameters -> Username),
        ANSI_STRING_PRINTF (&Parameters -> RequestMethod),
        ANSI_STRING_PRINTF (&Parameters -> RequestURI)));

    LOG((RTC_TRACE, "- challenge: realm (%.*s) qop (%.*s) algorithm (%.*s) nonce (%.*s)\n",
        ANSI_STRING_PRINTF (&Challenge -> Realm),
        ANSI_STRING_PRINTF (&Challenge -> QualityOfProtection),
        ANSI_STRING_PRINTF (&Challenge -> Algorithm),
        ANSI_STRING_PRINTF (&Challenge -> Nonce)));

    LOG((RTC_TRACE, "- HA1 (%s) HA2 (%s)\n", HA1Text, HA2Text));
    LOG((RTC_TRACE, "- response hash (%s)\n", ResponseHashText));
    LOG((RTC_TRACE, "- authorization line: %.*s\n",
        ANSI_STRING_PRINTF (ReturnAuthorizationLine)));
#endif

    return S_OK;
}


//Encode the userid:passwd using base64.

// On exit with S_OK ReturnAuthorizationLine contains
// a buffer allocated with malloc(). The caller should free it with free().

HRESULT BuildBasicResponse(
    IN  SECURITY_CHALLENGE  *Challenge,
    IN  SECURITY_PARAMETERS *Parameters,
    IN  OUT ANSI_STRING     *ReturnAuthorizationLine
    )
{
    ENTER_FUNCTION("BasicBuildResponse");
    
    HRESULT     hr;
    int         CredBufLen;
    int         CredValueLen;
    PSTR        CredBuf;
    PSTR        Header;
    ULONG       HeaderLength;

    ASSERT(Challenge->AuthProtocol == SIP_AUTH_PROTOCOL_BASIC);

    if (Parameters->Username.Buffer == NULL ||
        Parameters->Username.Length == 0)
    {
        LOG((RTC_ERROR, "%s - Invalid Username", __fxName));
        // ASSERT(FALSE);
        return E_INVALIDARG;
    }

    CredBufLen = Parameters->Username.Length + Parameters->Password.Length + 2;

    CredBuf = (PSTR) malloc(CredBufLen);
    if (CredBuf == NULL)
    {
        LOG((RTC_TRACE, "%s allocating CredBuf failed", __fxName));
        return E_OUTOFMEMORY;
    }

    CredValueLen = _snprintf(CredBuf, CredBufLen, "%.*s:%.*s",
                             ANSI_STRING_PRINTF(&Parameters->Username),
                             ANSI_STRING_PRINTF(&Parameters->Password));
    if (CredValueLen < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
        free(CredBuf);
        return E_FAIL;
    }

    // LOG((RTC_INFO, "%s : user:password is <%s>", __fxName, CredBuf));

    // Length of the header
    HeaderLength =
            6           // "basic "
        +   (CredValueLen + 2) / 3 * 4; // base64 stuff without '\0'
    
    // allocate the header
    Header = (PSTR)malloc(HeaderLength + 1);
    if (!Header)
    {
        free(CredBuf);
        return E_OUTOFMEMORY;
    }
    
    // prepare the header
    strcpy(Header, "Basic ");

    NTSTATUS ntStatus = base64encode(
                            CredBuf, CredValueLen,
                            Header + 6, HeaderLength - 5,
                            NULL);

    if(ntStatus != 0)
    {
        LOG((RTC_ERROR, "%s: error (%x) returned by base64encode",
             __fxName, ntStatus));
        
        free(CredBuf);
        free(Header);

        return E_UNEXPECTED;
    }

    ReturnAuthorizationLine->Length         = (USHORT) HeaderLength;
    ReturnAuthorizationLine->MaximumLength  = (USHORT) HeaderLength;
    ReturnAuthorizationLine->Buffer         = Header;

    free(CredBuf);
    
    return S_OK;
}


HRESULT ParseAuthProtocolFromChallenge(
    IN  ANSI_STRING        *ChallengeText,
    OUT ANSI_STRING        *ReturnRemainder, 
    OUT SIP_AUTH_PROTOCOL  *ReturnAuthProtocol
    )
{
    ENTER_FUNCTION("ParseAuthProtocolFromChallenge");
    // Check for basic / digest
    if (ChallengeText->Length > 5 &&
        _strnicmp(ChallengeText->Buffer, "basic", 5) == 0)
    {
        *ReturnAuthProtocol            = SIP_AUTH_PROTOCOL_BASIC;
        
        ReturnRemainder->Buffer        = ChallengeText->Buffer + 5;
        ReturnRemainder->Length        = ChallengeText->Length - 5;
        ReturnRemainder->MaximumLength = ChallengeText->MaximumLength - 5;
    }
    else if (ChallengeText->Length > 6 &&
             _strnicmp(ChallengeText->Buffer, "digest", 6) == 0)
    {
        *ReturnAuthProtocol            = SIP_AUTH_PROTOCOL_MD5DIGEST;
        
        ReturnRemainder->Buffer        = ChallengeText->Buffer + 6;
        ReturnRemainder->Length        = ChallengeText->Length - 6;
        ReturnRemainder->MaximumLength = ChallengeText->MaximumLength - 6;
    }
    else
    {
        LOG((RTC_ERROR, "%s  failed Unknown Auth protocol in challenge: %.*s",
             __fxName, ANSI_STRING_PRINTF(ChallengeText)));
        return RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
    }

    return S_OK;
}


HRESULT ParseAuthChallenge(
    IN  ANSI_STRING        *ChallengeText,
    OUT SECURITY_CHALLENGE *ReturnChallenge
    )
{
    ANSI_STRING     Remainder;
    ANSI_STRING     Name;
    ANSI_STRING     Value;
    HRESULT         Result;

    ENTER_FUNCTION("ParseAuthChallenge");

    ASSERT(ReturnChallenge);
    ZeroMemory (ReturnChallenge, sizeof (SECURITY_CHALLENGE));

    Result = ParseAuthProtocolFromChallenge(ChallengeText,
                                            &Remainder,
                                            &ReturnChallenge->AuthProtocol);
    if (Result != S_OK)
    {
        return Result;
    }

    // XXX Also need to parse opaque parameter.
    while (ParseScanNamedParameter (&Remainder, &Remainder, &Name, &Value) == S_OK)
    {

#define NAMED_PARAMETER(Field) \
        if (RtlEqualString (&Name, const_cast<ANSI_STRING *> (&String_##Field), TRUE)) ReturnChallenge -> Field = Value;

        NAMED_PARAMETER (QualityOfProtection)
        else NAMED_PARAMETER (Realm)
        else NAMED_PARAMETER (Nonce)
        else NAMED_PARAMETER (Algorithm)
        else NAMED_PARAMETER (GssapiData)
        else NAMED_PARAMETER (Opaque)
        else
        {
            LOG((RTC_TRACE, "%s: parameter, name (%.*s) value (%.*s)\n",
                 __fxName,
                 ANSI_STRING_PRINTF (&Name),
                 ANSI_STRING_PRINTF (&Value)));
        }
    }

    if (!ReturnChallenge -> Realm.Length)
    {
        LOG((RTC_ERROR, "%s - realm parameter is missing!",
             __fxName));
        return E_FAIL;
    }
    
    if (ReturnChallenge->AuthProtocol == SIP_AUTH_PROTOCOL_MD5DIGEST)
    {
        if (!ReturnChallenge -> Nonce.Length)
        {
            LOG((RTC_ERROR, "%s - Digest: nonce parameter is missing!",
                 __fxName));
            return E_FAIL;
        }
        if (ReturnChallenge -> Algorithm.Length)
        {
            // We support only md5 and md5-sess - otherwise return error.
            
            if (!RtlEqualString(&ReturnChallenge->Algorithm,
                                const_cast<ANSI_STRING *> (&String_MD5),
                                TRUE) &&
                !RtlEqualString(&ReturnChallenge->Algorithm,
                                const_cast<ANSI_STRING *> (&String_MD5Sess),
                                TRUE))
            {
                LOG((RTC_ERROR, "%s - Digest: unsupported Algorithm (%.*s)",
                     __fxName, ANSI_STRING_PRINTF(&ReturnChallenge->Algorithm)));
                return RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
            }
        }
        else
        {
            LOG((RTC_TRACE,
                 "%s - no algorithm specified - assuming MD5",
                 __fxName));
            ReturnChallenge -> Algorithm = String_MD5;
        }
    }


#if 1
    LOG((RTC_TRACE,
         "%s - AuthProtocol:%d qop (%.*s) realm (%.*s) nonce (%.*s) algorithm (%.*s)",
         __fxName,
         ReturnChallenge->AuthProtocol,
         ANSI_STRING_PRINTF(&ReturnChallenge -> QualityOfProtection),
         ANSI_STRING_PRINTF(&ReturnChallenge -> Realm),
         ANSI_STRING_PRINTF(&ReturnChallenge -> Nonce),
         ANSI_STRING_PRINTF(&ReturnChallenge -> Algorithm)
         ));
#endif

    return S_OK;
}


// On exit with S_OK pReturnAuthorizationLine contains
// a buffer allocated with malloc(). The caller should free it with free().

HRESULT BuildAuthResponse(
    IN     SECURITY_CHALLENGE  *pDigestChallenge,
    IN     SECURITY_PARAMETERS *pDigestParameters,
    IN OUT ANSI_STRING         *pReturnAuthorizationLine
    )
{
    if (pDigestChallenge->AuthProtocol == SIP_AUTH_PROTOCOL_BASIC)
    {
        return BuildBasicResponse(pDigestChallenge, pDigestParameters,
                                  pReturnAuthorizationLine);
    }
    else if (pDigestChallenge->AuthProtocol == SIP_AUTH_PROTOCOL_MD5DIGEST)
    {
        return BuildDigestResponse(pDigestChallenge, pDigestParameters,
                                   pReturnAuthorizationLine);
    }
    else
    {
        ASSERT(FALSE);
        return RTC_E_SIP_AUTH_TYPE_NOT_SUPPORTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\dnssrv.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnssrv.h

Abstract:

    Routines for processing SRV DNS records.

Author:

    Cliff Van Dyke (cliffv) 28-Feb-1997

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#ifndef _DNS_SRV_H_
#define _DNS_SRV_H_


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <windns.h>    

//
// Externally visible procedures.
//

//////////////////////////////////////////////////////////////////
//
//  WinSock 1 stuff. 
//
//////////////////////////////////////////////////////////////////

#ifndef _WINSOCK2_

typedef struct sockaddr FAR *LPSOCKADDR;
typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr ;
    INT iSockaddrLength ;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, FAR * LPSOCKET_ADDRESS ;

#endif // _WINSOCK2_

//////////////////////////////////////////////////////////////////
//
//  End of WinSock 1 stuff
//
//////////////////////////////////////////////////////////////////

static LPCSTR psz_SipUdpDNSPrefix = "_sip._udp.";
static LPCSTR psz_SipTcpDNSPrefix = "_sip._tcp.";
static LPCSTR psz_SipSslDNSPrefix = "_sip._ssl.";

HRESULT
DnsSrvOpen(
    IN LPSTR DnsRecordName,
    IN DWORD DnsQueryFlags,
    OUT PHANDLE SrvContextHandle
    );

HRESULT
DnsSrvProcessARecords(
    IN PDNS_RECORD DnsARecords,
    IN LPSTR DnsHostName OPTIONAL,
    IN ULONG Port,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL
    );

HRESULT
DnsSrvNext(
    IN HANDLE SrvContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    );

VOID
DnsSrvClose(
    IN HANDLE SrvContextHandle
    );

#ifdef __cplusplus
}
#endif // __cplusplus
    
#endif // _DNS_SRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\messagecall.h ===
//messagecall.h
//Instant messaging for phoenix

#ifndef __sipcli_messagecall_h__
#define __sipcli_messagecall_h__

#include "sipcall.h"

class INCOMING_MESSAGE_TRANSACTION;
class OUTGOING_MESSAGE_TRANSACTION;
class INCOMING_BYE_MESSAGE_TRANSACTION;
class OUTGOING_BYE_MESSAGE_TRANSACTION;

///////////////////////////////////////////////////////////////////////////////
// IM_MESSAGE Call
///////////////////////////////////////////////////////////////////////////////

class IMSESSION
    : public IIMSession, 
      public SIP_MSG_PROCESSOR
{
    
public:

    IMSESSION(
        IN  SIP_PROVIDER_ID    *pProviderId,
        IN  SIP_STACK          *pSipStack,
        IN  REDIRECT_CONTEXT   *pRedirectContext,
        IN  PSTR                RemoteURI = NULL,
        IN  DWORD               RemoteURILen = 0 
        );

    ~IMSESSION();

    //IMSession Interfaces
    STDMETHODIMP SendTextMessage(
        IN BSTR msg,
        IN BSTR ContentType,
        IN long lCookie
        );

    STDMETHODIMP AcceptSession();

    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(
        IN  REFIID riid,
        OUT LPVOID *ppv
        );
    
    STDMETHODIMP GetIMSessionState(SIP_CALL_STATE * ImState);
    
    inline VOID SetIMSessionState(
        IN SIP_CALL_STATE CallState
        );

    inline BOOL IsSessionDisconnected();

    
    VOID OnError();

    HRESULT CreateOutgoingByeTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount
        );

    HRESULT CreateOutgoingInfoTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount,
        IN  PSTR                        MsgBody,
        IN  ULONG                       MsgBodyLen,
        IN  PSTR                        ContentType,
        IN  ULONG                       ContentTypeLen,
        IN  long                        lCookie,
        IN  USR_STATUS                  UsrStatus
        );

    HRESULT CreateOutgoingMessageTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount,
        IN  PSTR                        MsgBody,
        IN  ULONG                       MsgBodyLen,
        IN  PSTR                        ContentType,
        IN  ULONG                       ContentTypeLen,
        IN  long                        lCookie
        );

    STDMETHODIMP Cleanup();

    HRESULT SetTransport(    
        IN  SIP_TRANSPORT   Transport
        );

    HRESULT NotifyIncomingSipMessage(
        IN  SIP_MESSAGE    *pSipMsg
        );

    HRESULT CreateIncomingMessageTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    HRESULT SetCreateIncomingMessageParams(
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket,
        IN  SIP_TRANSPORT   Transport
        );
    HRESULT SetLocalURI(
        IN BSTR bstrLocalDisplayName, 
        IN BSTR bstrLocalUserURI
        );
    STDMETHODIMP AddParty (
        IN    SIP_PARTY_INFO *    PartyInfo
        );
    
    STDMETHODIMP SetNotifyInterface(
        IN   ISipCallNotify *    pNotifyInterface
        );

    VOID NotifyMessageInfoCompletion(
        IN HRESULT StatusCode,
        IN long lCookie
        );

    void SetIsFirstMessage(BOOL isFirstMessage);

    STDMETHODIMP SendUsrStatus(
        IN USR_STATUS  UsrStatus,
        IN long        lCookie
        );

    inline void SetUsrStatus(
         IN USR_STATUS              UsrStatus
         );

    VOID
    InitiateCallTerminationOnError(
        IN HRESULT StatusCode,
        IN long    lCookie = 0
        );

    HRESULT ProcessRedirect(
        IN SIP_MESSAGE *pSipMsg,
        IN long         lCookie,
        IN PSTR        MsgBody,
        IN ULONG       MsgBodyLen,
        IN PSTR        ContentType,
        IN ULONG       ContentTypeLen,
        IN USR_STATUS  UsrStatus
        );

    VOID NotifySessionStateChange(
        IN SIP_CALL_STATE CallState,
        IN HRESULT        StatusCode = 0,
        IN PSTR           ReasonPhrase = NULL,
        IN ULONG          ReasonPhraseLen = 0
        );
    HRESULT OnIpAddressChange();

    STDMETHODIMP GetIsIMSessionAuthorizedFromCore(
        IN BSTR pszCallerURI,
        OUT BOOL  * bAuthorized
        );

    inline BOOL GetIsFirstMessage();

protected:

    HRESULT ProcessNotifyIncomingMessage(
        IN BSTR msg
        );

    HRESULT CancelAllTransactions();

    //Transaction related functions

    HRESULT CreateIncomingByeTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT CreateIncomingInfoTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE  *pSipMsg,
        IN  ASYNC_SOCKET *pResponseSocket
        );
    void
    EncodeXMLBlob(
        OUT PSTR    pstrXMLBlob,
        OUT DWORD*  dwBlobLen,
        IN  USR_STATUS  UsrStatus
        );

    //Variables

    BOOL                    m_isFirstMessage;

    ISipCallNotify         *m_pNotifyInterface;
    SIP_CALL_STATE         m_State;

    CHAR                    m_LocalHostName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD                   m_LocalHostNameLen;
    USR_STATUS              m_UsrStatus;
};

///////////////////////////////////////////////////////////////////////////////
// Message Transactions
///////////////////////////////////////////////////////////////////////////////

class INCOMING_MESSAGE_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_MESSAGE_TRANSACTION(
        IN IMSESSION        *pImSession,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT SendResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();

private:
    HRESULT RetransmitResponse();

    IMSESSION        *m_pImSession;

};


class OUTGOING_MESSAGE_TRANSACTION : public OUTGOING_TRANSACTION
{
public:
    OUTGOING_MESSAGE_TRANSACTION(
        IN IMSESSION        *pImSession,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq,
        IN BOOL             AuthHeaderSent,
        IN long             lCookie
        );
    
    ~OUTGOING_MESSAGE_TRANSACTION();

    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

private:    

    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    BOOL MaxRetransmitsDone();

    HRESULT ProcessRedirectResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN  SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );

    VOID DeleteTransactionAndTerminateCallIfFirstMessage(
        IN HRESULT TerminateStatusCode
    );

    VOID TerminateTransactionOnError(
    IN HRESULT      hr
    );

    IMSESSION        *m_pImSession;
    long             m_lCookie;
};

class INCOMING_BYE_MESSAGE_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_BYE_MESSAGE_TRANSACTION(
        IN IMSESSION        *pImSession,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT SendResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();

private:
    
    HRESULT RetransmitResponse();
    
    IMSESSION        *m_pImSession;
};


class OUTGOING_BYE_MESSAGE_TRANSACTION : public OUTGOING_TRANSACTION  
{
public:
    OUTGOING_BYE_MESSAGE_TRANSACTION(
        IN IMSESSION        *pImSession,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq,
        IN BOOL          AuthHeaderSent
        );
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN  SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );
    
    BOOL MaxRetransmitsDone();
    

    IMSESSION        *m_pImSession;
};

class INCOMING_INFO_MESSAGE_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_INFO_MESSAGE_TRANSACTION(
        IN IMSESSION        *pImSession,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT SendResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();
    
private:
    
    HRESULT RetransmitResponse();
    
    IMSESSION        *m_pImSession;
};


class OUTGOING_INFO_MESSAGE_TRANSACTION : public OUTGOING_TRANSACTION  
{
public:
    OUTGOING_INFO_MESSAGE_TRANSACTION(
        IN IMSESSION       *pImSession,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq,
        IN BOOL             AuthHeaderSent,
        IN long             lCookie,
        IN USR_STATUS       UsrStatus
        );
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();
    
private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessRedirectResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN  SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );
    
    BOOL MaxRetransmitsDone();

    VOID DeleteTransactionAndTerminateCallIfFirstMessage(
        IN HRESULT TerminateStatusCode
        );

    VOID TerminateTransactionOnError(
    IN HRESULT      hr
    );
    
    IMSESSION        *m_pImSession;
    long             m_lCookie;
    //Stored for redirects
    USR_STATUS       m_InfoUsrStatus;
};

void IMSESSION::SetUsrStatus(
         IN USR_STATUS              UsrStatus
         )
{
    m_UsrStatus = UsrStatus;
}

BOOL IMSESSION::GetIsFirstMessage()
{
    return m_isFirstMessage;
}
//xml parsing related info
#define INFO_XML_LENGTH 96      //assuming 4 char status
#define USRSTATUS_TAG_TEXT         "status"
#define XMLVERSION_TAG_TEXT         "?xml"
#define KEY_TAG_TEXT            "KeyboardActivity"
#define KEYEND_TAG_TEXT        "/KeyboardActivity"


#define XMLVERSION_TAG1_TEXT        "<?xml version=\"1.0\"?>\n"
#define USRSTATUS_TAG1_TEXT        "     <status status=\"%s\" />\n"
#define KEY_TAG1_TEXT       "     <KeyboardActivity>\n"
#define KEYEND_TAG1_TEXT          "</KeyboardActivity>\n" // \n needed at end?
enum
{
    XMLUNKNOWN_TAG = 0,
    XMLVERSION_TAG     ,
    USRSTATUS_TAG     ,
    KEY_TAG        ,
    KEYEND_TAG     ,

};

PSTR
GetTextFromStatus( 
    IN  USR_STATUS UsrStatus 
    );

DWORD
GetTagType(
    PSTR*   ppXMLBlobTag,
    DWORD   dwTagLen
    );

HRESULT
ProcessStatusTag(
    IN  PSTR    pXMLBlobTag, 
    IN  DWORD   dwTagLen,
    OUT USR_STATUS* UsrStatus
    );

HRESULT ParseStatXMLBlob (
                  IN PSTR xmlBlob,
                  IN DWORD dwXMLBlobLen,
                  OUT USR_STATUS *UsrStatus
                  );
/*
Messages of interest

#define SIP_STATUS_INFO_TRYING                              100
#define SIP_STATUS_INFO_RINGING                             180
#define SIP_STATUS_INFO_CALL_FORWARDING                     181
#define SIP_STATUS_INFO_QUEUED                              182
#define SIP_STATUS_SESSION_PROGRESS                         183

#define SIP_STATUS_SUCCESS                                  200

Msgs Below N/A right now

#define SIP_STATUS_CLIENT_UNAUTHORIZED                      401 - Auth reqd
#define SIP_STATUS_CLIENT_PROXY_AUTHENTICATION_REQUIRED     407 - Auth reqd
#define SIP_STATUS_REDIRECT_ALTERNATIVE_SERVICE             380 - error
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\msgproc.h ===
#ifndef __sipcli_msgproc_h__
#define __sipcli_msgproc_h__

class REGISTER_CONTEXT;
class REDIRECT_CONTEXT;
class SIP_TRANSACTION;

enum REQUEST_SOCKET_STATE
{
    REQUEST_SOCKET_INIT = 0,
    REQUEST_SOCKET_RESOLVING,
    REQUEST_SOCKET_CONNECTING,
    REQUEST_SOCKET_CONNECTED,
    //    REQUEST_SOCKET_TERMINATED
};


enum SIP_MSG_PROC_TYPE
{
    SIP_MSG_PROC_TYPE_REGISTER = 0,
    SIP_MSG_PROC_TYPE_RTP_CALL,
    SIP_MSG_PROC_TYPE_PINT_CALL,
    SIP_MSG_PROC_TYPE_MESSAGE,
    SIP_MSG_PROC_TYPE_OPTIONS,
    SIP_MSG_PROC_TYPE_REQFAIL,
    SIP_MSG_PROC_TYPE_WATCHER,
    SIP_MSG_PROC_TYPE_BUDDY,
    SIP_MSG_PROC_TYPE_IM,
    SIP_MSG_PROC_TYPE_GAME,
    SIP_MSG_PROC_TYPE_REFRESH
};

class SIP_STACK;
class SIP_MSG_PROCESSOR;

typedef struct {
    SIP_MSG_PROCESSOR *pProcessor;
    HttpProxyInfo     *pHPInfo;
    BOOL              fTunnelSuccess;
} HttpProxyResolveContext;

class __declspec(novtable) SIP_MSG_PROCESSOR :
    public CONNECT_COMPLETION_INTERFACE,
    public ERROR_NOTIFICATION_INTERFACE,
    public DNS_RESOLUTION_COMPLETION_INTERFACE
{
public:

    STDMETHODIMP_(ULONG) MsgProcAddRef();
    STDMETHODIMP_(ULONG) MsgProcRelease();
    
    SIP_MSG_PROCESSOR(
        IN  SIP_MSG_PROC_TYPE   MsgProcType,
        IN  SIP_STACK          *pSipStack,
        IN  REDIRECT_CONTEXT   *pRedirectContext
        );

    virtual ~SIP_MSG_PROCESSOR();

    // Callbacks
    void OnConnectComplete(
        IN DWORD ErrorCode
        );
    
    void OnSocketError(
        IN DWORD ErrorCode
        );

    void OnDnsResolutionComplete(
        IN HRESULT      ErrorCode,
        IN SOCKADDR_IN *pSockAddr,
        IN PSTR         pszHostName,
        IN USHORT       usPort
        );
    
    HRESULT OnRequestSocketConnectComplete(
        IN DWORD ErrorCode
        );
    
    HRESULT AddTagFromRequestOrResponseToRemote(
        IN  PSTR  ToHeader,
        IN  ULONG ToHeaderLen
        );
    
    HRESULT SetProxyInfo(
        IN SIP_SERVER_INFO *pProxyInfo
        );
    
    HRESULT SetCredentials(
        IN  SIP_USER_CREDENTIALS *pUserCredentials,
        IN  LPCOLESTR             Realm  
        );

    HRESULT SetCredentials(
        IN  LPCOLESTR   Username,
        IN  LPCOLESTR   Password,
        IN  LPCOLESTR   Realm
        );
    
    BOOL DoesMessageBelongToMsgProc(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessMessage(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT CheckListenAddrIntact();
    
    inline LPCWSTR GetRemotePrincipalName();

    inline PSTR GetLocalContact();

    inline ULONG GetLocalContactLen();
    
    inline PSTR GetRemote();

    inline ULONG GetRemoteLen();
    
    inline PSTR GetLocal();

    inline ULONG GetLocalLen();
    
    inline PSTR GetCallId();

    inline ULONG GetCallIdLen();

    inline PSTR GetRequestURI();

    inline ULONG GetRequestURILen();

    inline PSTR GetUsername();

    inline ULONG GetUsernameLen();

    inline PSTR GetPassword();
    
    inline ULONG GetPasswordLen();

    inline PSTR GetRealm();
    
    inline ULONG GetRealmLen();

    inline SIP_AUTH_PROTOCOL GetAuthProtocol();

    inline SIP_TRANSPORT GetTransport();
    
    inline SIP_STACK *GetSipStack();

    inline SIP_MSG_PROC_TYPE GetMsgProcType();

    inline ULONG GetNewCSeqForRequest();

    inline ULONG GetLocalCSeq();

    inline VOID SetLocalCSeq( ULONG CSeq );

    inline virtual VOID SetHighestRemoteCSeq(
        IN ULONG CSeq
        );

    inline BOOL IsRequestSocketReleased();

    inline REQUEST_SOCKET_STATE GetRequestSocketState();

    HRESULT CreateRequestMsg(
        IN  SIP_METHOD_ENUM             MethodId,
        IN  ULONG                       CSeq,
        IN  PSTR                        ToHeader,
        IN  ULONG                       ToHeaderLen,
        IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
        IN  ULONG                       AdditionalHeaderCount,
        IN  PSTR                        MsgBody,
        IN  ULONG                       MsgBodyLen,  
        IN  PSTR                        ContentType,
        IN  ULONG                       ContentTypeLen,  
        OUT SEND_BUFFER               **ppRequestBuffer
        );

    HRESULT SendRequestMsg(
        IN SEND_BUFFER                 *pSendBuffer
        );
    
    HRESULT ConnectRequestSocket();
    
    HRESULT SetRequestSocketForIncomingSession(
        IN  ASYNC_SOCKET   *pResponseSocket
        );

    HRESULT GetListenAddr(
        IN  ASYNC_SOCKET   *pAsyncSock,
        IN  BOOL            IsDestExternalToNat,
        OUT SOCKADDR_IN    *pListenAddr
        );
    
    HRESULT OnlyGetListenAddr(
        IN  ASYNC_SOCKET   *pAsyncSock,
        IN  BOOL            IsDestExternalToNat,
        OUT SOCKADDR_IN    *pListenAddr
        );

    HRESULT SetLocalContact();

    HRESULT ProcessRecordRouteContactAndFromHeadersInRequest(
        IN LIST_ENTRY  *pRecordRouteHeaderList,
        IN SIP_MESSAGE *pSipMsg
        );
    
    HRESULT ProcessRecordRouteAndContactHeadersInResponse(
        IN SIP_MESSAGE *pSipMsg
        );
    
    HRESULT SetLocalForOutgoingCall(
        IN  LPCOLESTR  wsLocalDisplayName,
        IN  LPCOLESTR  wsLocalURI
        );

    HRESULT GetCredentialsFromUI(
        IN  PSTR  Realm,
        IN  ULONG RealmLen
        ); 

    HRESULT GetCredentialsForRealm(
        IN  PSTR  Realm,
        IN  ULONG RealmLen
        ); 

    HRESULT
    CheckFromToInRequest(
        IN SIP_MESSAGE *pSipMsg
        );
     
    HRESULT
    CheckFromToInResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    inline 
    BOOL GetTunnel();

    inline 
    BOOL SetTunnel();
    
    HRESULT GetHostAndPort(
        OUT PSTR *ppszStr,
        OUT USHORT* pPort
        );

    HRESULT GetNewHttpProxyContextSetHostAndPort(
        IN  PSTR    host,
        IN  USHORT  port
        );
    
    VOID FreeHttpProxyContext();

    static
    LRESULT WINAPI HttpProxyProcessWinProc( 
        IN  HWND    Window,
        IN  UINT    MessageID,
        IN  WPARAM  Parameter1,
        IN  LPARAM  Parameter2);

    VOID ReleaseRequestSocket();

    // Called at shutdown time - delete any transactions left.
    VOID Shutdown();

    inline SOCKADDR_IN* GetLocalSockAddr();

    virtual HRESULT OnIpAddressChange();

    virtual HRESULT OnDeregister(
        SIP_PROVIDER_ID    *pProviderID
        );
    
    virtual BOOL IsSessionDisconnected() = 0;

    inline BOOL CredentialsSet();

    // Set to 'SMSP' in constructor
    ULONG                   m_Signature;
    
    // Linked list for SIP Message Processor (m_MsgProcList in SIP_STACK)
    LIST_ENTRY              m_ListEntry;
    
    // Lists of incoming and outgoing transactions
    LIST_ENTRY              m_IncomingTransactionList;
    LIST_ENTRY              m_OutgoingTransactionList;

    
    
protected:

    SIP_MSG_PROC_TYPE       m_MsgProcType;

    // The SIP_STACK this call belongs to.
    SIP_STACK              *m_pSipStack;

    SIP_TRANSPORT           m_Transport;
    
    ULONG                   m_RefCount;

    GUID                    m_ProviderGuid;

    // Used for SSL connections
    PWSTR                   m_RemotePrincipalName;
    
    // Address for sending new requests
    SOCKADDR_IN             m_RequestDestAddr;
    ASYNC_SOCKET           *m_pRequestSocket;
    //The error code is currently used only for IM. this is set when DNS Resolution fails.


    HRESULT                   m_RequestSocketErrorCode;
    REQUEST_SOCKET_STATE    m_RequestSocketState;
    PSTR                    m_ProxyAddress;
    ULONG                   m_ProxyAddressLen;

    DNS_RESOLUTION_WORKITEM *m_pDnsWorkItem;

    // This is TRUE only if the client is behind a NAT server
    // and the destination is external to the NAT.
    BOOL                    m_IsDestExternalToNat;

    // This socket is not normally used. We usually listen on
    // the sockets in the listen socket list of the sip stack.
    // This listen socket will be used only in the ISA client
    // installed scenario when we are communicating with an
    // external destination. In this scenario, we will be listening
    // on the external edge of the proxy.
    ASYNC_SOCKET           *m_pListenSocket;

    // address for listen socket, whether proxy or NAT or internal
    SOCKADDR_IN             m_ListenAddr;

    
    CHAR                    m_RequestVia[64];
    ULONG                   m_RequestViaLen;

    // This is the Contact header value we fill in for future requests.
    // Setup m_LocalContact just before you send the request/response
    // using the socket you use to send the request/response
    CHAR                    m_LocalContact[160];
    ULONG                   m_LocalContactLen;

    PSTR                    m_LocalContactTag;

    ULONG                   m_LocalCSeq;

    // This is the highest CSeq of incoming transaction
    // that has been deleted.
    ULONG                   m_HighestRemoteCSeq;

    PSTR                    m_RequestURI;
    DWORD                   m_RequestURILen;
    
    PSTR                    m_pszRequestDest;
    ULONG                   m_ulRequestDestLen;
    ULONG                   m_ulRequestPort;

    // Requests from this side have this as From and
    // requests from the other side have this as To.
    PSTR                    m_Local;
    DWORD                   m_LocalLen;
    FROM_TO_HEADER          m_DecodedLocal;

    // This URI is used to construct the origin line
    //of the SDP blob in PINT calls.
    PSTR                    m_LocalURI;
    // Used to check whether an incoming message belongs to this call.
    DWORD                   m_LocalURILen;

    // Requests from this side have this as To and
    // requests from the other side have this as From.
    // We should not use m_Remote for BYE messages
    // sent to multiple OKs after the first one. We should
    // also keep this in mind when we process responses to
    // those BYE messages.
    PSTR                    m_Remote;
    DWORD                   m_RemoteLen;
    // Used to check whether an incoming message belongs to this call.
    FROM_TO_HEADER          m_DecodedRemote;

    PSTR                    m_CallId;
    DWORD                   m_CallIdLen;

    // List of RECORD_ROUTE_HEADER structures
    LIST_ENTRY              m_RouteHeaderList;
    
    REDIRECT_CONTEXT       *m_pRedirectContext;

    PSTR                    m_Username;
    ULONG                   m_UsernameLen;
    PSTR                    m_Password;
    ULONG                   m_PasswordLen;
    PSTR                    m_Realm;
    ULONG                   m_RealmLen;
    BOOL                    m_fCredentialsSet;
    
    SIP_AUTH_PROTOCOL       m_AuthProtocol;

    HWND                    m_PrxyProcWndw;

    HINTERNET               m_hInet;
    HINTERNET               m_hHttpSession;
    HINTERNET               m_hHttpRequest;

//  static  
//  BOOL                    m_RegWnd;
    BOOL                    m_SSLTunnel;

    HttpProxyResolveContext    *m_pHPContext;
    SOCKADDR_IN                 m_OriginalReqDestAddr;

    LONG                m_lRegisterAccept;
    PSTR                m_Methodsparam;
    ULONG               m_MethodsparamLen;

    HRESULT SetRequestVia();

    HRESULT SetRemotePrincipalName(
        IN  LPCWSTR RemotePrincipalName
        );

    HRESULT ResolveSipUrlAndSetRequestDestination(
        IN SIP_URL  *pDecodedSipUrl,
        IN BOOL      fUseTransportFromSipUrl,
        IN BOOL      fUseSesssionTransportIfNoTransportParam,
        IN BOOL      fSetRequestURI,
        IN BOOL      fSessionInit
        );
    
    HRESULT ResolveSipUrlAndSetRequestDestination(
        IN PSTR     DstUrl,
        IN ULONG    DstUrlLen,
        IN BOOL     fUseTransportFromSipUrl,
        IN BOOL      fUseSesssionTransportIfNoTransportParam,
        IN BOOL      fSetRequestURI,
        IN BOOL      fSessionInit
        );

    HRESULT ResolveProxyAddressAndSetRequestDestination();

    HRESULT SetRequestDestination(
        IN SOCKADDR_IN *pDstAddr
        );

    HRESULT CreateCallId();

    HRESULT SetCallId(
        IN  PSTR    CallId,
        IN  DWORD   CallIdLen
        );
    
    HRESULT SetRemoteForOutgoingCall(
        IN  LPCOLESTR  wsRemoteDisplayName,
        IN  LPCOLESTR  wsRemoteURI
        );
    
    HRESULT SetRemoteForOutgoingCall(
        IN  PSTR    DestUrl,
        IN  ULONG   DestUrlLen
        );
    
    HRESULT SetLocalForIncomingCall(
        IN  PSTR    ToHeader,
        IN  DWORD   ToHeaderLen
        );
    
    HRESULT SetRemoteForIncomingSession(
        IN  PSTR    FromHeader,
        IN  DWORD   FromHeaderLen
        );

    HRESULT SetRequestURI(
        IN SIP_URL  *pSipUrl
        );
    
    // This is implemented by RTP_CALL and PINT_CALL
    virtual HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        ) = 0;

    HRESULT CreateIncomingReqFailTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket,
        IN ULONG         StatusCode,
        IN SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray = NULL,
        IN ULONG AdditionalHeaderCount = 0
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    // Clean up state depending on the message processor
    virtual VOID OnError() = 0;

    HRESULT CreateHttpProxyProcessWindow();
    HRESULT DestroyHttpProxyProcessWindow();
    inline HWND GetHttpProxyProcessWindow();
    
    HRESULT
    UseHttpProxy(
        IN PSTR pszHostName,
        IN USHORT usPort
        );

    HRESULT
    ResolveHttpProxy(void);

    HRESULT
    ResolveHttpProxyCleanUp(void);

    static
    VOID CALLBACK HttpProxyCallback(
        IN HINTERNET    hInternet,
        DWORD_PTR       dwHPContext,
        DWORD           dwInternetStatus,
        LPVOID          lpvStatusInformation,
        DWORD           dwStatusInformationLength
        );

    HRESULT DropRequestIfBadToTag(
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );
    
private:

    VOID NotifyRequestSocketConnectComplete(
        IN HRESULT      ErrorCode
        );
    
    HRESULT AsyncNotifyTransaction(
        IN UINT                  MessageId,
        IN SIP_TRANSACTION      *pSipTransaction,
        IN DWORD                 ErrorCode
        );

    HRESULT SetRemoteForOutgoingCallHelperFn();

    HRESULT ConstructRouteHeadersFromRequest(
        IN LIST_ENTRY  *pRecordRouteHeaderList,
        IN PSTR         ContactHeader,
        IN ULONG        ContactHeaderLen
        );
    
    HRESULT ConstructRouteHeader(
        IN  PSTR                     DisplayName,
        IN  ULONG                    DisplayNameLen,
        IN  PSTR                     SipUrl,
        IN  ULONG                    SipUrlLen,
        OUT RECORD_ROUTE_HEADER    **ppRouteHeader
        );
    
    HRESULT ConstructRouteHeader(
        IN  PSTR                     DisplayName,
        IN  ULONG                    DisplayNameLen,
        IN  SIP_URL                 *pSipUrl,
        OUT RECORD_ROUTE_HEADER    **ppRouteHeader
        );
    
    VOID FreeRouteHeaderList();
    
};


inline SIP_MSG_PROC_TYPE
SIP_MSG_PROCESSOR::GetMsgProcType()
{
    return m_MsgProcType;
}


inline LPCWSTR
SIP_MSG_PROCESSOR::GetRemotePrincipalName()
{
    return m_RemotePrincipalName;
}


inline PSTR
SIP_MSG_PROCESSOR::GetLocalContact()
{
    return m_LocalContact;
}


inline ULONG
SIP_MSG_PROCESSOR::GetLocalContactLen()
{
    return m_LocalContactLen;
}

    
inline PSTR
SIP_MSG_PROCESSOR::GetLocal()
{
    return m_Local;
}


inline ULONG
SIP_MSG_PROCESSOR::GetLocalLen()
{
    return m_LocalLen;
}


inline PSTR
SIP_MSG_PROCESSOR::GetRemote()
{
    return m_Remote;
}


inline ULONG
SIP_MSG_PROCESSOR::GetRemoteLen()
{
    return m_RemoteLen;
}


inline PSTR
SIP_MSG_PROCESSOR::GetCallId()
{
    return m_CallId;
}


inline ULONG
SIP_MSG_PROCESSOR::GetCallIdLen()
{
    return m_CallIdLen;
}


inline PSTR
SIP_MSG_PROCESSOR::GetRequestURI()
{
    return m_RequestURI;
}


inline ULONG
SIP_MSG_PROCESSOR::GetRequestURILen()
{
    return m_RequestURILen;
}


inline PSTR
SIP_MSG_PROCESSOR::GetUsername()
{
    return m_Username;
}


inline ULONG
SIP_MSG_PROCESSOR::GetUsernameLen()
{
    return m_UsernameLen;
}


inline PSTR
SIP_MSG_PROCESSOR::GetPassword()
{
    return m_Password;
}


inline PSTR
SIP_MSG_PROCESSOR::GetRealm()
{
    return m_Realm;
}

inline ULONG
SIP_MSG_PROCESSOR::GetRealmLen()
{
    return m_RealmLen;
}


inline SIP_AUTH_PROTOCOL
SIP_MSG_PROCESSOR::GetAuthProtocol()
{
    return m_AuthProtocol;
}

inline SIP_TRANSPORT
SIP_MSG_PROCESSOR::GetTransport()
{
    return m_Transport;
}


inline SIP_STACK *
SIP_MSG_PROCESSOR::GetSipStack()
{
    return m_pSipStack;
}



inline ULONG
SIP_MSG_PROCESSOR::GetLocalCSeq()
{
    return m_LocalCSeq;
}


inline VOID
SIP_MSG_PROCESSOR::SetLocalCSeq(
    ULONG CSeq
    )
{
    m_LocalCSeq = CSeq;
}


inline ULONG
SIP_MSG_PROCESSOR::GetNewCSeqForRequest()
{
    return ++m_LocalCSeq;
}

inline VOID
SIP_MSG_PROCESSOR::SetHighestRemoteCSeq(
    IN ULONG CSeq
    )
{
    if (CSeq > m_HighestRemoteCSeq)
    {
        m_HighestRemoteCSeq = CSeq;
    }
}

    
inline REQUEST_SOCKET_STATE
SIP_MSG_PROCESSOR::GetRequestSocketState()
{
    return m_RequestSocketState;
}

    
inline BOOL
SIP_MSG_PROCESSOR::IsRequestSocketReleased()
{
    return (m_RequestSocketState == REQUEST_SOCKET_INIT);
}


inline HWND
SIP_MSG_PROCESSOR::GetHttpProxyProcessWindow(void) 
{
    return m_PrxyProcWndw;
}

inline BOOL
SIP_MSG_PROCESSOR::SetTunnel()
{
    m_SSLTunnel = TRUE;
    return TRUE;
}


inline BOOL
SIP_MSG_PROCESSOR::GetTunnel() 
{
    return m_SSLTunnel;
}

inline SOCKADDR_IN*
SIP_MSG_PROCESSOR::GetLocalSockAddr()
{
    if(m_pRequestSocket!= NULL)
        return &(m_pRequestSocket->m_LocalAddr);
    else return NULL;
}


inline BOOL
SIP_MSG_PROCESSOR::CredentialsSet()
{
    return m_fCredentialsSet;
}


#define SIP_MSG_PROCESSOR_WINDOW_CLASS  _T("HttpProxy_Process_Window_Class")
#define WM_HttpProxy_PROCESS_SUCCESS_MESSAGE   (WM_USER + 10)
#define WM_HttpProxy_PROCESS_FINAL_MESSAGE       (WM_USER + 11)

const DWORD PRXY_RESOLVE_TIMEOUT = 5000;    // in milliseconds
const USHORT SIP_TUNNEL_DEFAULT_PORT = 80;

#endif // __sipcli_msgproc_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\options.cpp ===
//options.cpp

#include "precomp.h"
#include "sipstack.h"
#include "OPTIONS.h"
//#include "resolve.h"

///////////////////////////////////////////////////////////////////////////////
// OPTIONS_MSGPROC
///////////////////////////////////////////////////////////////////////////////


OPTIONS_MSGPROC::OPTIONS_MSGPROC(
        IN  SIP_STACK         *pSipStack
    ) :
    SIP_MSG_PROCESSOR(SIP_MSG_PROC_TYPE_OPTIONS, pSipStack, NULL )
{
}


OPTIONS_MSGPROC::~OPTIONS_MSGPROC()
{
    LOG((RTC_TRACE, "~OPTIONS_MSGPROC()"));
    
}

STDMETHODIMP_(ULONG) 
OPTIONS_MSGPROC::AddRef()
{
    return MsgProcAddRef();

}

STDMETHODIMP_(ULONG) 
OPTIONS_MSGPROC::Release()
{
    return MsgProcRelease();

}
/*
STDMETHODIMP 
OPTIONS_MSGPROC::QueryInterface(
        IN  REFIID riid,
        OUT LPVOID *ppv
        )
{
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;

}
*/


HRESULT
OPTIONS_MSGPROC::StartIncomingCall(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT     hr;
    PSTR        Header;
    ULONG       HeaderLen;

    ENTER_FUNCTION("OPTIONS::StartIncomingCall");
    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    m_Transport = Transport;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting To header failed %x",
             __fxName, hr));
    }

    if(hr == S_OK)
    {
        hr = SetLocalForIncomingCall(Header, HeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetLocalForIncomingCall failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    //if no from, drop the error msg - cannot send
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s getting From header failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = SetRemoteForIncomingSession(Header, HeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRemoteForIncomingSession failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_CALL_ID, &Header, &HeaderLen);
    if (hr != S_OK)
    {
        //Drop the call: No valid Call-Id
        LOG((RTC_ERROR, "%s getting Call-ID header failed %x",
             __fxName, hr));
        return hr;
    }
    hr = SetCallId(Header, HeaderLen);
    if (hr != S_OK)
    {
            LOG((RTC_ERROR, "%s SetCallId failed %x",
                 __fxName, hr));
            return hr;
    }
   
    if (Transport != SIP_TRANSPORT_UDP &&
        m_pRequestSocket == NULL)
    {
        hr = SetRequestSocketForIncomingSession(pResponseSocket);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s SetRequestSocketForIncomingSession failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    hr = CreateIncomingTransaction(pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s OPTIONS_MSGPROC::CreateIncomingTransaction failed %x",
             __fxName, hr));
        return hr;
    }
  
    return S_OK;
}


HRESULT
OPTIONS_MSGPROC::CreateIncomingTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT         hr;

    LOG((RTC_TRACE, "CreateIncomingRequestTransaction()"));

    INCOMING_OPTIONS_TRANSACTION* pIncomingOptionsTransaction
        = new INCOMING_OPTIONS_TRANSACTION(this,
                                          pSipMsg->GetMethodId(),
                                          pSipMsg->GetCSeq()
                                          );
    if (pIncomingOptionsTransaction == NULL)
        return E_OUTOFMEMORY;

    hr = pIncomingOptionsTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        pIncomingOptionsTransaction->OnTransactionDone();
        return hr;
    }
    
    hr = pIncomingOptionsTransaction->ProcessRequest(pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        // We shouldn't delete the transaction here.
        // If the media processing fails we send a 488 and wait for the ACK.
        // The transaction will delete itself once it is done.
        return hr;
    }
    
    return S_OK;
}


BOOL
OPTIONS_MSGPROC::IsSessionDisconnected()
{
    return FALSE;
}


VOID 
OPTIONS_MSGPROC::OnError()
{
    LOG((RTC_TRACE, "REGISTER_CONTEXT::OnError - enter"));
}


///////////////////////////////////////////////////////////////////////////////
// Incoming OPTIONS
///////////////////////////////////////////////////////////////////////////////


INCOMING_OPTIONS_TRANSACTION::INCOMING_OPTIONS_TRANSACTION(
    IN OPTIONS_MSGPROC        *pOptions,
    IN SIP_METHOD_ENUM  MethodId,
    IN ULONG            CSeq
    ) :
    INCOMING_TRANSACTION(pOptions, MethodId, CSeq)
{
    m_pOptions            = pOptions;
}

HRESULT
INCOMING_OPTIONS_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    ENTER_FUNCTION("INCOMING_OPTIONS_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "%s - Enter", __fxName));

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:
        LOG((RTC_TRACE, "%s Processing Options request transaction", __fxName));
        int ReasonPhraseLen;
        PCHAR ReasonPhrase;
        // Get SDP Options and pass it to ResponseMessage
        PSTR    MediaSDPOptions;
        hr = m_pOptions->GetSipStack()->GetMediaManager()->
                GetSDPOption(INADDR_ANY, 
                                &MediaSDPOptions);

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s: GetSDPOptions failed %x",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }

        hr = CreateAndSendResponseMsg(
                 200,
                 SIP_STATUS_TEXT(200),
                 SIP_STATUS_TEXT_SIZE(200),
                 NULL,    // No Method string
                 FALSE,   // No Contact header  
                 MediaSDPOptions, strlen(MediaSDPOptions), //MsgBody
                 SIP_CONTENT_TYPE_SDP_TEXT, //Content Type
                 sizeof(SIP_CONTENT_TYPE_SDP_TEXT)-1
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s  CreateAndSendResponseMsg failed %x - deleting transaction",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        
        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed %x - deleting transaction",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  resending final response failed %x",
                 __fxName, hr));
            OnTransactionDone();
            return hr;
        }
        break;
    case INCOMING_TRANS_ACK_RCVD:
    case INCOMING_TRANS_REQUEST_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
INCOMING_OPTIONS_TRANSACTION::RetransmitResponse()
{
    DWORD Error;

    ENTER_FUNCTION("INCOMING_OPTIONS_TRANSACTION::RetransmitResponse");
    // Send the buffer.
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
        LOG((RTC_ERROR, "%s Send failed %x", __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


VOID
INCOMING_OPTIONS_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;

    ENTER_FUNCTION("INCOMING_OPTIONS_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
    // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}

HRESULT
INCOMING_OPTIONS_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\msgproc.cpp ===
#include "precomp.h"
#include "sipstack.h"
#include "sipcall.h"
#include "msgproc.h"
#include "util.h"
#include "reqfail.h"



#define IsCRLF( pstrSignedBuffer )  ((*pstrSignedBuffer == '\r') && (*(pstrSignedBuffer+1) == '\n'))

// BOOL SIP_MSG_PROCESSOR::m_RegWnd = FALSE;

SIP_MSG_PROCESSOR::SIP_MSG_PROCESSOR(
        IN  SIP_MSG_PROC_TYPE   MsgProcType,
        IN  SIP_STACK          *pSipStack,
        IN  REDIRECT_CONTEXT   *pRedirectContext
        )
{
    m_Signature             = 'SMSP';

    m_MsgProcType           = MsgProcType;
    
    m_pSipStack             = pSipStack;
    m_pSipStack->AddRef();
    m_pSipStack->IncrementNumMsgProcessors();

    m_ListEntry.Flink       = NULL;
    m_ListEntry.Blink       = NULL;
    
    ENTER_FUNCTION("SIP_MSG_PROCESSOR Constructor");
    LOG((RTC_TRACE,"%s entered",__fxName));

    InitializeListHead(&m_IncomingTransactionList);
    InitializeListHead(&m_OutgoingTransactionList);

    m_Transport             = SIP_TRANSPORT_UDP; // default XXX

    m_RefCount              = 1;

    m_RemotePrincipalName   = NULL;
    ZeroMemory(&m_RequestDestAddr, sizeof(m_RequestDestAddr));
    m_pRequestSocket        = NULL;
    m_RequestSocketErrorCode = 0;
    m_RequestSocketState    = REQUEST_SOCKET_INIT;
    m_pDnsWorkItem          = NULL;

    m_IsDestExternalToNat   = FALSE;

    m_pListenSocket         = NULL;

    ZeroMemory(&m_ListenAddr, sizeof(m_ListenAddr));
    
    m_RequestViaLen         = 0;
    m_LocalContactLen       = 0;

    m_LocalContactTag       = NULL;
    
    m_LocalCSeq             = 0;
    m_HighestRemoteCSeq     = 0;

    m_RequestURI            = NULL;
    m_RequestURILen         = 0;
    m_pszRequestDest        = NULL;
    m_ulRequestDestLen      = 0;
    m_ulRequestPort         = 0;
    m_Local                 = NULL;
    m_LocalLen              = 0;
    m_LocalURI              = NULL;
    m_Remote                = NULL;
    m_RemoteLen             = 0;
    m_CallId                = NULL;
    m_CallIdLen             = 0;

    InitializeListHead(&m_RouteHeaderList);

    m_Username              = NULL;
    m_UsernameLen           = 0;
    m_Password              = NULL;
    m_PasswordLen           = 0;
    m_Realm                 = NULL;
    m_RealmLen              = 0;
    m_fCredentialsSet       = FALSE;
    m_AuthProtocol          = SIP_AUTH_PROTOCOL_NONE;

    m_ProxyAddress          = NULL;
    m_ProxyAddressLen       = 0;

    m_pHPContext            = NULL;

    m_PrxyProcWndw          = NULL;
    m_hInet                 = NULL;
    m_hHttpSession          = NULL;
    m_hHttpRequest          = NULL;
    m_SSLTunnel             = FALSE;

    m_pRedirectContext = pRedirectContext;
    if( m_pRedirectContext != NULL )
    {
        m_pRedirectContext->AddRef();
    }
    m_lRegisterAccept = 0;

    m_Methodsparam = NULL;

    m_MethodsparamLen = 0;



    pSipStack->AddToMsgProcList(this);
}


SIP_MSG_PROCESSOR::~SIP_MSG_PROCESSOR()
{
    if (m_ListEntry.Flink != NULL)
    {
        // Remove the Msg Processor from the list
        RemoveEntryList(&m_ListEntry);
    }

    ASSERT(IsListEmpty(&m_IncomingTransactionList));
    ASSERT(IsListEmpty(&m_OutgoingTransactionList));

    if (m_pRedirectContext != NULL)
    {
        m_pRedirectContext->Release();
    }

    if (m_ProxyAddress != NULL)
    {
        free(m_ProxyAddress);
    }

    if (m_RemotePrincipalName != NULL)
    {
        free(m_RemotePrincipalName);
    }
    
    if (m_pRequestSocket != NULL)
    {
        ReleaseRequestSocket();
    }

    if (m_pDnsWorkItem != NULL)
    {
        m_pDnsWorkItem->CancelWorkItem();
    }

    if (m_pListenSocket != NULL)
    {
        m_pListenSocket->Release();
    }
    
    if (m_LocalContactTag != NULL)
    {
        free(m_LocalContactTag);
    }
    
    if (m_RequestURI != NULL)
        free(m_RequestURI);

    if (m_pszRequestDest != NULL)
        free(m_pszRequestDest);

    if (m_Local != NULL)
        free(m_Local);

    if (m_LocalURI != NULL)
        free(m_LocalURI);

    if (m_Remote != NULL)
        free(m_Remote);

    if (m_CallId != NULL)
        free(m_CallId);

    FreeRouteHeaderList();
    
    if (m_Username != NULL)
    {
        free(m_Username);
    }

    if (m_Password != NULL)
    {
        free(m_Password);
    }

    if (m_Realm != NULL)
    {
        free(m_Realm);
    }

    if (m_pHPContext != NULL)
    {
        FreeHttpProxyContext();
    }

    if(m_Methodsparam != NULL)
    {
        free(m_Methodsparam);
    }

    if (m_PrxyProcWndw != NULL)
    {
        DestroyHttpProxyProcessWindow();
    }

    if (m_hHttpRequest != NULL)
    {
        InternetCloseHandle(m_hHttpRequest);
    }
    if (m_hHttpSession != NULL)
    {
        InternetCloseHandle(m_hHttpSession);
    }
    if (m_hInet != NULL)
    {
        InternetCloseHandle(m_hInet);
    }

    // We release the msg processor's reference on the SIP stack after
    // we make the call on the SIP stack.

    // Just being extra careful as this could make a callback to Core.
    SIP_STACK *pSipStack = m_pSipStack;

    pSipStack->OnMsgProcessorDone();
    
    pSipStack->Release();
    
    LOG((RTC_TRACE, "~SIP_MSG_PROCESSOR(this - %x) done", this));
}

    
// We live in a single threaded world.
STDMETHODIMP_(ULONG)
SIP_MSG_PROCESSOR::MsgProcAddRef()
{
    m_RefCount++;
    LOG((RTC_TRACE, "SIP_MSG_PROCESSOR::MsgProcAddRef this: %x m_RefCount: %d",
         this, m_RefCount));
    return m_RefCount;
}


STDMETHODIMP_(ULONG)
SIP_MSG_PROCESSOR::MsgProcRelease()
{
    m_RefCount--;
    LOG((RTC_TRACE, "SIP_MSG_PROCESSOR::MsgProcRelease this: %x m_RefCount: %d",
         this, m_RefCount));
    if (m_RefCount != 0)
    {
        return m_RefCount;
    }
    else
    {
        delete this;
        return 0;
    }
}


HRESULT
SIP_MSG_PROCESSOR::SetRemotePrincipalName(
    IN  LPCWSTR RemotePrincipalName
    )
{
    DWORD CopyLength = 0;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRemotePrincipalName");
    
    if (m_RemotePrincipalName != NULL)
        free(m_RemotePrincipalName);

    CopyLength = (wcslen(RemotePrincipalName) + 1) * sizeof(WCHAR);
    
    m_RemotePrincipalName = (PWSTR) malloc(CopyLength);
    if (m_RemotePrincipalName == NULL)
    {
        LOG((RTC_ERROR, "%s failed to allocate m_RemotePrincipalName",
             __fxName));
        return E_OUTOFMEMORY;
    }

    CopyMemory(m_RemotePrincipalName, RemotePrincipalName, CopyLength);

    wcstok(m_RemotePrincipalName, L":");
    LOG((RTC_TRACE, "%s set to %ls", __fxName, m_RemotePrincipalName));
    return S_OK;
}


// Note that function also gets called while sending
// Contact header in the 200 OK for an incoming call and
// we can not get all the information from the request socket.

HRESULT
SIP_MSG_PROCESSOR::GetListenAddr(
    IN  ASYNC_SOCKET   *pAsyncSock,
    IN  BOOL            IsDestExternalToNat,
    OUT SOCKADDR_IN    *pListenAddr
    )
{
    HRESULT     hr;
    SOCKADDR_IN ListenAddr;
    BOOL        fTcp;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::GetListenAddr");

    hr = OnlyGetListenAddr(pAsyncSock,IsDestExternalToNat,pListenAddr);

    // We get the listen address from the listen address list in the sip stack.
    // If none is found we create a listen socket here to listen on this address.
    // This could happen in the ISA client installed scenario where we
    // connect to an external destination and getsockname() gives the
    // external address of the proxy.
    if (hr != S_OK)
    {
        pListenAddr->sin_addr.s_addr = pAsyncSock->m_LocalAddr.sin_addr.s_addr;
        if (m_pListenSocket != NULL &&
            m_pListenSocket->m_LocalAddr.sin_addr.s_addr == pListenAddr->sin_addr.s_addr &&
            m_pListenSocket->GetTransport() == m_Transport)
        {
            pListenAddr->sin_port = m_pListenSocket->m_LocalAddr.sin_port;
            LOG((RTC_WARN,
                 "%s using msgproc's m_pListenSocket %d.%d.%d.%d:%d",
                 __fxName, PRINT_SOCKADDR(pListenAddr)));
        }
        else
        {
            if (m_pListenSocket != NULL)
            {
                m_pListenSocket->Release();
                m_pListenSocket = NULL;
            }
            
            LOG((RTC_WARN,
                 "%s sip stack not listening on %d.%d.%d.%d - creating listen socket",
                 __fxName,
                 NETORDER_BYTES0123(pListenAddr->sin_addr.s_addr)));

            ZeroMemory(&ListenAddr, sizeof(ListenAddr));
            ListenAddr.sin_family = AF_INET;
            ListenAddr.sin_addr.s_addr = pAsyncSock->m_LocalAddr.sin_addr.s_addr;
            
            fTcp = (m_Transport == SIP_TRANSPORT_UDP) ? FALSE : TRUE;
            hr = m_pSipStack->CreateListenSocket(fTcp, &ListenAddr,
                                                 &m_pListenSocket);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s CreateListenSocket failed %x",
                     __fxName, hr));
                return hr;
            }
            
            pListenAddr->sin_addr.s_addr = m_pListenSocket->m_LocalAddr.sin_addr.s_addr;
            pListenAddr->sin_port = m_pListenSocket->m_LocalAddr.sin_port;
        }
    }
    
    ASSERT(pListenAddr->sin_addr.s_addr != 0);
    ASSERT(pListenAddr->sin_port != 0);
    
    CopyMemory(&m_ListenAddr,pListenAddr,sizeof(SOCKADDR_IN));
    return S_OK;
}

HRESULT
SIP_MSG_PROCESSOR::OnlyGetListenAddr(
    IN  ASYNC_SOCKET   *pAsyncSock,
    IN  BOOL            IsDestExternalToNat,
    OUT SOCKADDR_IN    *pListenAddr
    )
{
    HRESULT     hr;
    SOCKADDR_IN ListenAddr;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::OnlyGetListenAddr");

    ASSERT(pAsyncSock->m_LocalAddr.sin_addr.s_addr != 0);

    // For SSL we don't have a real listen addr.
    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        CopyMemory(pListenAddr, &pAsyncSock->m_LocalAddr,
                   sizeof(SOCKADDR_IN));
        return S_OK;
    }
    
    BOOL        fTcp = (m_Transport == SIP_TRANSPORT_UDP) ? FALSE : TRUE;
    ZeroMemory(&ListenAddr, sizeof(ListenAddr));
    
    if (IsDestExternalToNat)
    {
        if (m_pSipStack->GetPublicListenAddr(
               pAsyncSock->m_LocalAddr.sin_addr.s_addr,
               fTcp,
               &ListenAddr
               ))
        {
            // We have a public listen address.
            ASSERT(ListenAddr.sin_addr.s_addr != 0);
            ASSERT(ListenAddr.sin_port != 0);
            CopyMemory(pListenAddr,&ListenAddr,sizeof(SOCKADDR_IN));
            return S_OK;
        }

        // In some error cases, the public address could become unavailable
        // before we get the address. If this is the case, we just send the
        // local address.
    }

    ListenAddr.sin_addr.s_addr = pAsyncSock->m_LocalAddr.sin_addr.s_addr;

    // If the SIP stack is already listening on the interface we pass in
    // pListenAddr, the port will be returned in pListenAddr.
 
    if (m_pSipStack->GetListenAddr(&ListenAddr, fTcp))
    {
        CopyMemory(pListenAddr,&ListenAddr,sizeof(SOCKADDR_IN));   
        return S_OK;
    }
    
    return E_FAIL;
    
    
}

// Get the IP address for m_LocalContact using the socket.
// Should we have a display name and user name in the contact ?

// This function could be called while sending the first INVITE or
// the first 200. XXX Do we need to call it for each message we send ?

// Update m_LocalContact

HRESULT
SIP_MSG_PROCESSOR::SetLocalContact()
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetLocalContact");

    ASSERT(m_pRequestSocket != NULL);
    ASSERT(m_RequestSocketState == REQUEST_SOCKET_CONNECTED);
    
    int             RetVal;
    SOCKADDR_IN     ListenAddr;
    HRESULT         hr;
    MESSAGE_BUILDER Builder;
    
    BOOL isRegisterMethodsAdded = (m_MsgProcType == SIP_MSG_PROC_TYPE_REGISTER && 
                                   m_MethodsparamLen != 0 &&
                                   m_Methodsparam != NULL);
    
    hr = GetListenAddr(m_pRequestSocket,
                       m_IsDestExternalToNat, &ListenAddr);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetListenAddr failed %x", __fxName, hr));
        return hr;
    }

    Builder.PrepareBuild(m_LocalContact, sizeof(m_LocalContact));

    Builder.AppendVaArgs("<sip:%d.%d.%d.%d:%d",
                         PRINT_SOCKADDR(&ListenAddr));
    if (m_Transport != SIP_TRANSPORT_UDP)
    {
        Builder.AppendVaArgs(";transport=%s",
                             GetTransportText(m_Transport, FALSE) // lower case transport
                             );
    }

    if (m_LocalContactTag != NULL)
    {
        Builder.AppendVaArgs(";tag=%s",
                             m_LocalContactTag);
    }
    
    Builder.Append(">");
    
    if (isRegisterMethodsAdded)
    {
        Builder.AppendVaArgs(";methods=%s",
                             m_Methodsparam);
    }

    // we need to have the proxy replace the contact
    if (m_Transport == SIP_TRANSPORT_SSL)
    {
        Builder.Append(";proxy=replace");
    }
    
    if (Builder.OverflowOccurred())
    {
        LOG((RTC_TRACE,
             "%s - not enough buffer space for local contact",
             __fxName));
        ASSERT(FALSE);

        return E_FAIL;
    }

    m_LocalContactLen = Builder.GetLength();
    if (m_LocalContactLen < sizeof(m_LocalContact))
    {
        m_LocalContact[m_LocalContactLen] = '\0';
    }

    LOG((RTC_TRACE, "%s to %.*s : length: %d",
         __fxName, m_LocalContactLen, m_LocalContact, m_LocalContactLen));
    return S_OK;
}


// This function is called each time the request socket is changed.
// The request socket should have been set and connected to the destination
// before this function is called.
// Update m_LocalContact
// XXX We should get the port from the SIP_STACK
// Can we get the local address before the asynchronous TCP connection
// succeeds ?
HRESULT
SIP_MSG_PROCESSOR::SetRequestVia()
{
    int         RetVal;
    SOCKADDR_IN ListenAddr;
    HRESULT     hr;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRequestVia");
        
    ASSERT(m_pRequestSocket != NULL);
    ASSERT(m_RequestSocketState == REQUEST_SOCKET_CONNECTED);
    
    hr = GetListenAddr(m_pRequestSocket,
                       m_IsDestExternalToNat, &ListenAddr);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s GetListenAddr failed %x",
             __fxName, hr));
        return hr;
    }
    
    RetVal = _snprintf(m_RequestVia,
                       sizeof(m_RequestVia),
                       "%s/%s %d.%d.%d.%d:%d",
                       SIP_VERSION_2_0_TEXT,
                       GetTransportText(m_Transport, TRUE), // upper case transport
                       PRINT_SOCKADDR(&ListenAddr));
    if (RetVal < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
        return E_FAIL;
    }

    m_RequestViaLen = RetVal;

    LOG((RTC_TRACE, "SetRequestVia to %s Length %d this: %x",
         m_RequestVia, m_RequestViaLen, this ));
    
    return S_OK;
}


// This should be called while sending the first request
// for an outbound session.
// for an outgoing call and whenever we process a Contact in 200
// or for an incoming call whenever we process a Contact in INVITE
// Update m_RequestDestAddr, m_pRequestSocket
HRESULT
SIP_MSG_PROCESSOR::SetRequestDestination(
    IN SOCKADDR_IN *pDstAddr
    )
{
    HRESULT     hr;
    SOCKADDR_IN RequestDestAddr;
    BOOL        IsDestExternalToNat;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRequestDestination");
    LOG((RTC_TRACE, "%s Enter", __fxName));

    hr = m_pSipStack->MapDestAddressToNatInternalAddress(
             htonl(INADDR_ANY),
             pDstAddr, m_Transport,
             &RequestDestAddr, &IsDestExternalToNat
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s MapDestAddressToNatInternalAddress failed %x",
             __fxName, hr));
        return hr;
    }

    m_IsDestExternalToNat = IsDestExternalToNat;

    // XXX TODO Should we take care of transport here ?
    if (m_pRequestSocket != NULL &&
        AreSockaddrEqual(&RequestDestAddr, &m_RequestDestAddr))
    {
        // Nothing to be done.
        LOG((RTC_TRACE, "%s - Request destination is the same - doing nothing",
             __fxName));
        return S_OK;
    }

    if (m_pRequestSocket != NULL)
    {
        ReleaseRequestSocket();
    }
    
    CopyMemory(&m_RequestDestAddr, &RequestDestAddr, sizeof(SOCKADDR_IN));

    hr = ConnectRequestSocket();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ConnectRequestSocket failed %x",
             __fxName, hr));
        return hr;
    }
    
    LOG((RTC_TRACE, "%s Exit", __fxName));
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::ConnectRequestSocket()
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ConnectRequestSocket");
    LOG((RTC_TRACE, "%s Enter", __fxName));
    
    HRESULT hr;
    HttpProxyInfo *pHPInfo;

    ReleaseRequestSocket();

    if(m_pHPContext &&
       m_pHPContext->pHPInfo &&
       m_pHPContext->pHPInfo->pszHostName)
    {
        LOG((RTC_TRACE,"%s Host is %s",
            __fxName,m_pHPContext->pHPInfo->pszHostName));
    }

    if(m_pHPContext) 
    {
        pHPInfo = m_pHPContext->pHPInfo;
    }
    else
    {
        pHPInfo = NULL;
    }

    hr = m_pSipStack->GetSocketToDestination(
             &m_RequestDestAddr, m_Transport,
             m_RemotePrincipalName,
             this,
             pHPInfo,
             &m_pRequestSocket
             );

    if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
    {
        LOG((RTC_ERROR, "%s GetSocketToDestination failed %x",
             __fxName, hr));
        return hr;
    }

    if (hr == S_OK)
    {
        // If we have a connected socket (i.e. we don't have to wait for one
        // to be established) set via/contact etc.
        LOG(( RTC_TRACE, "%s - We already have a socket this: %x",
              __fxName, this));
    
        hr = OnRequestSocketConnectComplete(NO_ERROR);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s OnRequestSocketConnectComplete failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else
    {
        m_RequestSocketState = REQUEST_SOCKET_CONNECTING;
    }

    // If connection is pending, the callback will take care of the
    // processing.

    LOG((RTC_TRACE, "%s Exit", __fxName));
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::SetRequestSocketForIncomingSession(
    IN ASYNC_SOCKET *pAsyncSock
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRequestSocketForIncomingSession");
    HRESULT hr;
    
    LOG((RTC_TRACE, "%s(%x) - Enter", __fxName, pAsyncSock));
    
    ASSERT(m_pRequestSocket == NULL);

    m_pRequestSocket = pAsyncSock;
    m_pRequestSocket->AddRef();
    m_RequestSocketState = REQUEST_SOCKET_CONNECTED;

    // The request destination is the destination of the socket

    CopyMemory(&m_RequestDestAddr, &(pAsyncSock->m_RemoteAddr),
               sizeof(SOCKADDR_IN));

    hr = SetRequestVia();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRequestVia failed %x",
             __fxName, hr));
        return hr;
    }

    hr = SetLocalContact();
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetLocalContact failed %x",
             __fxName, hr));
        return hr;
    }

    LOG((RTC_TRACE, "%s(%x) - Exit", __fxName, pAsyncSock));
    
    return S_OK;
}

    
VOID
SIP_MSG_PROCESSOR::ReleaseRequestSocket()
{
    if (m_pRequestSocket != NULL)
    {
        m_pRequestSocket->RemoveFromConnectCompletionList(this);
        m_pRequestSocket->RemoveFromErrorNotificationList(this);
        m_pRequestSocket->Release();
        m_pRequestSocket = NULL;
    }
    
    m_RequestSocketState = REQUEST_SOCKET_INIT;
}


HRESULT
SIP_MSG_PROCESSOR::OnDeregister(
    SIP_PROVIDER_ID    *pProviderID
    )
{
    return S_OK;
}

    
HRESULT
SIP_MSG_PROCESSOR::OnIpAddressChange()
{
    LOG((RTC_TRACE, "SIP_MSG_PROCESSOR::OnIpAddressChange - Enter this: %x", 
        this));
    if((CheckListenAddrIntact() == S_OK))
        return S_OK;

    MsgProcAddRef();

    // Release the request socket and kill all outgoing transactions.
    OnSocketError( 0 );

    // Also notify incoming transactions here.
    LIST_ENTRY             *pListEntry;
    INCOMING_TRANSACTION   *pSipTransaction;

    pListEntry = m_IncomingTransactionList.Flink;

    while( pListEntry != &m_IncomingTransactionList )
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            INCOMING_TRANSACTION,
                                            m_ListEntry);

        pListEntry = pListEntry->Flink;
        LOG((RTC_TRACE, "SIP_MSG_PROCESSOR::OnIpAddressChange -SipTransaction %x",
                            pSipTransaction));

        // Note that this could result in the deletion of the transaction.
        // So, we get the next list member before we make the callback
        
        if (!pSipTransaction->IsTransactionDone())
        {
            AsyncNotifyTransaction(
                WM_SIP_STACK_TRANSACTION_SOCKET_ERROR, pSipTransaction, 0);
            // pSipTransaction->OnSocketError( 0 );
        }
    }
    
    MsgProcRelease();
    LOG((RTC_TRACE, "SIP_MSG_PROCESSOR::OnIpAddressChange - Exit this: %x",
        this));
    return S_OK;
}

HRESULT
SIP_MSG_PROCESSOR::CheckListenAddrIntact()
{
    SOCKADDR_IN     ListenAddr;
    HRESULT         hr;
    BOOL            bResult = FALSE;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CheckListenAddrIntact");
    LOG((RTC_TRACE,"Entering %s",__fxName));
    if(m_pRequestSocket!= NULL &&
       (m_pRequestSocket->m_LocalAddr.sin_addr.s_addr != htonl(INADDR_ANY)))
    {
        ZeroMemory(&ListenAddr, sizeof(SOCKADDR_IN));
        hr = OnlyGetListenAddr(m_pRequestSocket,m_IsDestExternalToNat, &ListenAddr);
        // if listen address is present, check if the listen address obtained equals the
        // address in m_pListenSocket
        if (hr == S_OK) 
        {
            bResult = AreSockaddrEqual(&ListenAddr,&m_ListenAddr);
        }
    }

    LOG((RTC_TRACE,"%s Exits - Intact %d",__fxName, bResult));

    return bResult? S_OK : E_FAIL;
}

VOID
SIP_MSG_PROCESSOR::OnSocketError(
    IN DWORD ErrorCode
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::OnSocketError");

    LOG((RTC_ERROR, "%s (%x) this: %x - Enter", __fxName, ErrorCode, this));

    // Keep a reference on the object as the error notifications could
    // destroy the object.
    MsgProcAddRef();

    ReleaseRequestSocket();

    // Also notify outgoing transactions here.
    LIST_ENTRY             *pListEntry;
    OUTGOING_TRANSACTION   *pSipTransaction;

    pListEntry = m_OutgoingTransactionList.Flink;

    pListEntry = m_OutgoingTransactionList.Flink;

    LOG((RTC_TRACE, "%s - outgoing trans list: %x First transaction: %x this: %x",
         __fxName, &m_OutgoingTransactionList, pListEntry, this));

    while (pListEntry != &m_OutgoingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            OUTGOING_TRANSACTION,
                                            m_ListEntry);

        LOG((RTC_TRACE, "%s this: %x  pListEntry: %x", __fxName, this, pListEntry));
        
        pListEntry = pListEntry->Flink;

        LOG((RTC_TRACE, "%s this: %x  next transaction: %x", __fxName, this, pListEntry));

        // We notify the error asynchronously (using a windows
        // message) as the error notification routine could get stuck
        // in a dialog box.  While the dialog box is shown more
        // outgoing transactions could get added and this creates
        // complexity.
        if (!pSipTransaction->IsTransactionDone())
        {
            AsyncNotifyTransaction(
                WM_SIP_STACK_TRANSACTION_SOCKET_ERROR,
                pSipTransaction, ErrorCode);
        }
    }

    MsgProcRelease();
    
    LOG((RTC_ERROR, "%s this: %x - Exit", __fxName, this));
}


// Post a message to the sip stack window.
HRESULT
SIP_MSG_PROCESSOR::AsyncNotifyTransaction(
    IN UINT                  MessageId,
    IN SIP_TRANSACTION      *pSipTransaction,
    IN DWORD                 ErrorCode
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::AsyncNotifyTransaction");
    
    if (!PostMessage(m_pSipStack->GetSipStackWindow(),
                     MessageId, (WPARAM) pSipTransaction, (LPARAM) ErrorCode))
    {
        DWORD Error = GetLastError();
        
        LOG((RTC_ERROR, "%s PostMessage failed : %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }
    
    // Keep a reference on the transaction. This reference
    // is released after the error is processed in the window proc.
    pSipTransaction->TransactionAddRef();

    // Keep track of this reference we are adding. In shutdown
    // we release these references as we also shutdown the
    // sip stack window.
    pSipTransaction->IncrementAsyncNotifyCount();

    return S_OK;
}



// If DNS name - return S_OK
// and handle the request using a work item. Also set
// request socket state to resolving.
// If ip address - call SetRequestDestination.
// Note that we return S_OK even if the resolution is pending.
// The caller is expected to check the state of the request
// socket using GetRequestSocketState.

// fUseTransportFromSipUrl - Use the Transport specified in the
// transport parameter of the SIP URL.

// fUseSesssionTransportIfNoTransportParam - If the SIP URL
// does not have any transport parameters, then use the current transport
// of the session. This is useful for Record-Route headers for which
// the server never inserts a transport param. This should be TRUE only
// if fUseTransportFromSipUrl is also TRUE.

// fSessionInit is TRUE when we are creating a new outbound session.
// When processing record-route / Contact headers, etc. this is FALSE.

HRESULT
SIP_MSG_PROCESSOR::ResolveSipUrlAndSetRequestDestination(
    IN SIP_URL  *pDecodedSipUrl,
    IN BOOL      fUseTransportFromSipUrl,
    IN BOOL      fUseSesssionTransportIfNoTransportParam,
    IN BOOL      fSetRequestURI,
    IN BOOL      fSessionInit
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ResolveSipUrlAndSetRequestDestination");
    LOG((RTC_TRACE,"%s entered",__fxName));

    HRESULT         hr;
    SOCKADDR_IN     DstAddr;
    SIP_TRANSPORT   Transport = m_Transport;

    HRESULT         ResolveHr;
    PSTR            pszDest;
    ULONG           ulDestLen;
    
    LOG((RTC_TRACE,"%s decoded %s:%d len %d original %s:%d len %d",
         __fxName, pDecodedSipUrl->m_Host.Buffer, pDecodedSipUrl->m_Port,
         pDecodedSipUrl->m_Host.Length, m_pszRequestDest,
         m_ulRequestPort, m_ulRequestDestLen));

    if (fSetRequestURI)
    {
        hr = SetRequestURI(pDecodedSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetRequestURI failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    // If we already have a request socket for SSL, then we
    // don't change that.
    if (m_Transport == SIP_TRANSPORT_SSL &&
        !fSessionInit)
    {
        LOG((RTC_TRACE, "%s - SSL transport - not changing request destination",
             __fxName));
        return S_OK;
    }

    if (m_Transport != SIP_TRANSPORT_SSL &&
        !fSessionInit &&
        pDecodedSipUrl->m_TransportParam == SIP_TRANSPORT_SSL)
    {
        ASSERT(fUseTransportFromSipUrl);
        LOG((RTC_TRACE, "%s - can not change request destination from non-SSL to SSL",
             __fxName));
        return S_OK;
    }

    if (fUseTransportFromSipUrl &&
        pDecodedSipUrl->m_TransportParam == SIP_TRANSPORT_UNKNOWN)
    {
        LOG((RTC_ERROR, "%s Invalid Transport : %.*s", __fxName,
             pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_TRANSPORT].Length,
             pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_TRANSPORT].Buffer));
        return RTC_E_SIP_TRANSPORT_NOT_SUPPORTED;
    }
        
    if (fUseSesssionTransportIfNoTransportParam &&
        !pDecodedSipUrl->IsTransportParamPresent())
    {
        ASSERT(fUseTransportFromSipUrl);
        pDecodedSipUrl->m_TransportParam = m_Transport;
    }
    
    if (pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0)
    {
        pszDest = pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Buffer;
        ulDestLen = pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length;
    }
    else 
    {
        pszDest = pDecodedSipUrl->m_Host.Buffer;
        ulDestLen = pDecodedSipUrl->m_Host.Length;
    }

    if (m_pszRequestDest && 
        AreCountedStringsEqual(pszDest, ulDestLen,
                               m_pszRequestDest,
                               m_ulRequestDestLen,
                               FALSE) &&
        (pDecodedSipUrl->m_Port == m_ulRequestPort) &&
        (pDecodedSipUrl->m_TransportParam == m_Transport))
    {
        // We are going through the same request destination, no change
        LOG((RTC_TRACE, "%s no change in request destination",__fxName));
        return S_OK;
    }
        
    ResolveHr = m_pSipStack->AsyncResolveSipUrl(
                    pDecodedSipUrl,
                    this,
                    &DstAddr,
                    &Transport,
                    &m_pDnsWorkItem,
                    fUseTransportFromSipUrl
                    );

    if (ResolveHr != S_OK && ResolveHr != HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
    {
        LOG((RTC_ERROR, "%s AsyncResolveSipUrl failed %x",
             __fxName, ResolveHr));
        return ResolveHr;
    }

    // Don't change the transport when using SSL transport.
    LOG((RTC_TRACE, "%s resolved sip url with transport %d",
         __fxName, Transport));
    if (fUseTransportFromSipUrl && m_Transport != SIP_TRANSPORT_SSL)
    {
        m_Transport = Transport;
    }

    // Remote principal name is not set if the proxy is not
    // specified.
    if (m_Transport == SIP_TRANSPORT_SSL &&
        m_RemotePrincipalName == NULL)
    {
        if (pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0)
        {
            hr = UTF8ToUnicode(pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Buffer,
                               pDecodedSipUrl->m_KnownParams[SIP_URL_PARAM_MADDR].Length,
                               &m_RemotePrincipalName);
        }
        else
        {
            hr = UTF8ToUnicode(pDecodedSipUrl->m_Host.Buffer,
                               pDecodedSipUrl->m_Host.Length,
                               &m_RemotePrincipalName);
        }

        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - setting remote principal name failed %x",
                 __fxName, hr));
            return hr;
        }
        
        LOG((RTC_TRACE, "%s RemotePrincipalName set to %ls",
             __fxName, m_RemotePrincipalName));
    }

    if (m_pszRequestDest)
        free(m_pszRequestDest);

    m_pszRequestDest = (PSTR) malloc(ulDestLen + 1);
    if (!m_pszRequestDest) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        return HRESULT_FROM_WIN32(E_OUTOFMEMORY);
    }

    m_ulRequestDestLen = ulDestLen;
    m_pszRequestDest = strncpy(m_pszRequestDest,pszDest,ulDestLen);
    m_pszRequestDest[ulDestLen] = '\0';

    m_ulRequestPort = pDecodedSipUrl->m_Port;

    if (ResolveHr == S_OK)
    {
        hr = SetRequestDestination(&DstAddr);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - SetRequestDestination failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    else if (ResolveHr == HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
    {
        m_RequestSocketState = REQUEST_SOCKET_RESOLVING;
    }

    LOG((RTC_TRACE,"%s exits",__fxName));
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::ResolveSipUrlAndSetRequestDestination(
    IN PSTR     DstUrl,
    IN ULONG    DstUrlLen,
    IN BOOL     fUseTransportFromSipUrl,
    IN BOOL     fUseSesssionTransportIfNoTransportParam,
    IN BOOL     fSetRequestURI,
    IN BOOL     fSessionInit
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ResolveSipUrlAndSetRequestDestination");

    SIP_URL DecodedSipUrl;
    HRESULT hr;
    ULONG   BytesParsed = 0;

    hr = ParseSipUrl(DstUrl, DstUrlLen, &BytesParsed,
                     &DecodedSipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s ParseSipUrl failed %x",
             __fxName, hr));
        return hr;
    }

    return ResolveSipUrlAndSetRequestDestination(
               &DecodedSipUrl,
               fUseTransportFromSipUrl,
               fUseSesssionTransportIfNoTransportParam,
               fSetRequestURI, fSessionInit
               );
}

HRESULT
SIP_MSG_PROCESSOR::ResolveProxyAddressAndSetRequestDestination()
{
    HRESULT          hr;
    int              ProxyURIValueLen;
    int              ProxyURIBufLen;
    PSTR             ProxyURI         = NULL;
    SIP_TRANSPORT    Transport;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ResolveProxyAddressAndSetRequestDestination");

    ProxyURIBufLen = 4 + strlen(m_ProxyAddress) + 1;
        
    ProxyURI = (PSTR) malloc(ProxyURIBufLen);
    if (ProxyURI == NULL)
    {
        LOG((RTC_TRACE, "%s allocating ProxyURI failed", __fxName));
        return E_OUTOFMEMORY;
    }

    ProxyURIValueLen = _snprintf(ProxyURI, ProxyURIBufLen,
                                 "sip:%s", m_ProxyAddress);
    if (ProxyURIValueLen < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
        free(ProxyURI);
        return E_FAIL;
    }


    hr = ResolveSipUrlAndSetRequestDestination(
             ProxyURI, ProxyURIValueLen, FALSE, FALSE, FALSE, TRUE
             );

    free(ProxyURI);

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ResolveSipUrlAndSetRequestDestination failed %x",
             __fxName, hr));
        return RTC_E_INVALID_PROXY_ADDRESS;
    }

    return S_OK;
}


// XXX Need to notify transaction even if the request destination
// has not changed.
VOID
SIP_MSG_PROCESSOR::OnDnsResolutionComplete(
    IN HRESULT      ErrorCode,
    IN SOCKADDR_IN *pSockAddr,
    IN PSTR         pszHostName,
    IN USHORT       usPort
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::OnDnsResolutionComplete");

    LOG(( RTC_TRACE, "%s Entered host %s port %d", __fxName, pszHostName,usPort ));
    
    HRESULT hr;
    
    // The DNS work item has completed.
    m_pDnsWorkItem = NULL;

    if (ErrorCode == S_OK)
    {
        // XXX TODO need to check change in transport
        // call set request destination.
        if (m_pRequestSocket != NULL &&
            AreSockaddrEqual(pSockAddr, &m_RequestDestAddr))
        {
            LOG((RTC_TRACE, "%s DNS resolution completed - no change in dest",
                 __fxName));
            if (m_pRequestSocket->GetConnectionState() == CONN_STATE_CONNECTED)
            {
                m_RequestSocketState = REQUEST_SOCKET_CONNECTED;
                NotifyRequestSocketConnectComplete(S_OK);
            }
            return;
        }
        else
        {
       
            hr = SetRequestDestination(pSockAddr);
            if (hr != S_OK && hr != HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
            {
                LOG((RTC_ERROR, "%s  failed %x", __fxName, hr));
                m_RequestSocketErrorCode = hr;
                NotifyRequestSocketConnectComplete(hr);
                return;
            }
        }
    }
     else
    {
        LOG((RTC_ERROR, "%s - error : %x", __fxName, ErrorCode));
        m_RequestSocketErrorCode = ErrorCode;        
        // Try one more time with UseHttpProxy tunneling if transport is ssl
        if(m_Transport == SIP_TRANSPORT_SSL) 
        {
            // error is host not resolved, try once more with UseHttpProxy
            hr = UseHttpProxy(pszHostName, 
                                (usPort == 0)? 
                                    GetSipDefaultPort(SIP_TRANSPORT_SSL):
                                    usPort
                             );
            if (hr != S_OK) 
            {
                LOG((RTC_ERROR,"%s UseHttpProxy failed",__fxName));
                m_RequestSocketErrorCode = hr;
                ReleaseRequestSocket();
                NotifyRequestSocketConnectComplete(hr);
            }
            else
            {
                LOG((RTC_ERROR, "%s - setting m_RequestSocketErrorCode to 0. Old value is %d",
                        __fxName, m_RequestSocketErrorCode));
                m_RequestSocketErrorCode = 0;
            }
            return;
        }
        ReleaseRequestSocket();
        NotifyRequestSocketConnectComplete(ErrorCode);
        return;
    }
}


VOID
SIP_MSG_PROCESSOR::OnConnectComplete(
    IN DWORD ErrorCode
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::OnConnectComplete");

    
    LOG(( RTC_TRACE, "%s Received a connect notification for socket this: %x",
          __fxName, this ));
    // if connect succeeded 
    if (m_Transport != SIP_TRANSPORT_SSL || ErrorCode == S_OK) 
    {
        OnRequestSocketConnectComplete(ErrorCode);
    }
    // else if we failed with HTTP tunnel already
    else if (ErrorCode == RTC_E_SIP_SSL_TUNNEL_FAILED) 
    {
        m_RequestDestAddr = m_OriginalReqDestAddr;
        OnRequestSocketConnectComplete(ErrorCode);
    }
    // otherwise we try one more time with http tunnel
    else  
    {
        LOG((RTC_ERROR,"%s connect failed %x retry connecting via HTTP tunnel",
            __fxName, ErrorCode));
      
        ASSERT(m_pszRequestDest);
        if (m_pszRequestDest == NULL)
        {
            LOG((RTC_ERROR, "%s no request destination, cannot use HTTP tunnel", __fxName));
            OnRequestSocketConnectComplete(ErrorCode);
            return;
        }

       
        hr = UseHttpProxy(m_pszRequestDest,ntohs(m_RequestDestAddr.sin_port));
        // failed using HttpProxy
        if ( hr != S_OK )
        {
            LOG((RTC_ERROR,"%s UseHttpProxy failed",__fxName));
            OnRequestSocketConnectComplete(ErrorCode);
        }
        return;
    }
}


// This will update via / contact fields for this session
HRESULT
SIP_MSG_PROCESSOR::OnRequestSocketConnectComplete(
    IN DWORD ErrorCode
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::OnRequestSocketConnectComplete");
        
    LOG(( RTC_TRACE, "%s - Enter this: %x ", __fxName, this ));
    
    if (ErrorCode == NO_ERROR)
    {
        m_RequestSocketState = REQUEST_SOCKET_CONNECTED;

        hr = m_pRequestSocket->AddToErrorNotificationList(this);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s: AddToErrorNotificationList failed %x",
                 __fxName, hr));
            NotifyRequestSocketConnectComplete(hr);
            return hr;
        }
        
        // If the callid is not set yet - create the call id
        if (m_CallId == NULL)
        {
            // This should be done only after the connection to the destination is
            // complete.
            hr = CreateCallId();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s: CreateCallId failed %x",
                     __fxName, hr));
                NotifyRequestSocketConnectComplete(hr);
                return hr; 
            }
        }
        
        hr = SetRequestVia();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetRequestVia failed %x",
                 __fxName, hr));
            NotifyRequestSocketConnectComplete(hr);
            return hr;
        }

        hr = SetLocalContact();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s SetLocalContact failed %x",
                 __fxName, hr));
            NotifyRequestSocketConnectComplete(hr);
            return hr;
        }
    }
    else
    {
        LOG((RTC_ERROR, "Releasing socket and notifying transactions"));
        ReleaseRequestSocket();
    }
    NotifyRequestSocketConnectComplete(ErrorCode);
    LOG(( RTC_TRACE, "%s - Exit this: %x ", __fxName, this ));
    return S_OK;
}


VOID
SIP_MSG_PROCESSOR::NotifyRequestSocketConnectComplete(
    IN HRESULT      ErrorCode
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::NotifyRequestSocketConnectComplete");
    
    // Also notify outgoing transactions here.
    LIST_ENTRY             *pListEntry;
    OUTGOING_TRANSACTION   *pSipTransaction;
    
    pListEntry = m_OutgoingTransactionList.Flink;

    if (ErrorCode == NO_ERROR)
    {
        LOG(( RTC_TRACE, "Socket for this session is now connected this: %x",
              this ));
    }
    else
    {
        LOG((RTC_ERROR, "%s - Error: %x", __fxName, ErrorCode));
    }
    

    while (pListEntry != &m_OutgoingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            OUTGOING_TRANSACTION,
                                            m_ListEntry);

        pListEntry = pListEntry->Flink;

        // Note that this could result in the deletion of the transaction.
        // So, we get the next list member before we make the callback
        if (!pSipTransaction->IsTransactionDone())
        {
            // pSipTransaction->OnRequestSocketConnectComplete(ErrorCode);
            AsyncNotifyTransaction(
                WM_SIP_STACK_TRANSACTION_REQ_SOCK_CONNECT_COMPLETE,
                pSipTransaction, ErrorCode);
        }
    }

}


HRESULT
SIP_MSG_PROCESSOR::CreateCallId()
{
    PSTR     UuidStr;
    ULONG    UuidStrLen;
    HRESULT  hr = S_OK;
    int      RetVal;

    ASSERT(m_pRequestSocket != NULL);

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CreateCallId");

    hr = CreateUuid(&UuidStr, &UuidStrLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateUuid failed %x", __fxName, hr));
        return hr;
    }
    
    DWORD LocalIp = m_pRequestSocket->m_LocalAddr.sin_addr.s_addr;
    ASSERT(LocalIp != 0);

    m_CallId = (PSTR) malloc(UuidStrLen + 30);
    if (m_CallId == NULL)
    {
        free(UuidStr);
        LOG((RTC_ERROR, "%s allocating m_CallId failed", __fxName));
        return E_OUTOFMEMORY;
    }
    
    m_CallIdLen = _snprintf(m_CallId,
                            UuidStrLen + 30,
                            "%.*s@%d.%d.%d.%d",
                            UuidStrLen, UuidStr,
                            NETORDER_BYTES0123(LocalIp)
                            );
    free(UuidStr);
    if ((int)m_CallIdLen < 0)
    {
        free(m_CallId);
        m_CallId = NULL;
        LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
        return E_FAIL;
    }

    LOG((RTC_TRACE, "CreateCallId %s Length: %d",
         m_CallId, m_CallIdLen));

    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::SetCallId(
    IN  PSTR    CallId,
    IN  DWORD   CallIdLen
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetCallId");
    
    m_CallIdLen = CallIdLen;
    m_CallId = (PSTR) malloc(CallIdLen + 1);
    if (m_CallId == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating m_CallId failed", __fxName));
        return E_OUTOFMEMORY;
    }
    
    strncpy(m_CallId, CallId, CallIdLen);
    m_CallId[m_CallIdLen] = '\0';

    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::SetLocalForOutgoingCall(
    IN  LPCOLESTR  wsLocalDisplayName,
    IN  LPCOLESTR  wsLocalURI
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetLocalForOutgoingCall");

    HRESULT hr;
    int     LocalValueLen = 0;
    ULONG   LocalBufLen   = 0;
    if (wsLocalDisplayName != NULL && wcslen(wsLocalDisplayName ) != 0)
    {
        hr = UnicodeToUTF8(wsLocalDisplayName,
                           &m_DecodedLocal.m_DisplayName.Buffer,
                           &m_DecodedLocal.m_DisplayName.Length);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UnicodeToUTF8(displayname) failed %x",
                 __fxName, hr));
            return hr;
        }
        LOG((RTC_TRACE, "Setting the Local Display Name %s",
             m_DecodedLocal.m_DisplayName.Buffer));
    }

    ASSERT(wsLocalURI != NULL);
    if (wsLocalURI == NULL)
    {
        LOG((RTC_ERROR, "%s LocalURI cannot be NULL", __fxName));
        return E_FAIL;
    }
    
    hr = UnicodeToUTF8( wsLocalURI, &m_LocalURI, &m_LocalURILen );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s UnicodeToUTF8(localuri) failed %x",
             __fxName, hr));
        return hr;
    }

    //Check if local URI parsing succeeds
    //else send RTC_E_INVALID_ADDRESS_LOCAL to core
    ULONG bytesParsed = 0;
    SIP_URL        SipUrl;
    hr = ParseSipUrl(
            m_LocalURI,
            m_LocalURILen,
            &bytesParsed,
            &SipUrl
            );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Local URI parsing failed %x",
             __fxName, hr));
        hr = RTC_E_INVALID_ADDRESS_LOCAL;
        return hr;
    }

    hr = AllocCountedString(m_LocalURI, m_LocalURILen,
                            &m_DecodedLocal.m_SipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(localuri) failed %x",
             __fxName, hr));
        return hr;
    }

    // Allocate the tag.
    hr = CreateUuid(&m_DecodedLocal.m_TagValue.Buffer,
                    &m_DecodedLocal.m_TagValue.Length);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateUuid failed %x",
             __fxName, hr));
        return hr;
    }
    // "DisplayName" <LocalURI> ; tag = TagValue
    LocalBufLen = m_DecodedLocal.m_DisplayName.Length + m_LocalURILen
        + m_DecodedLocal.m_TagValue.Length + 16;
    m_Local = (PSTR) malloc(LocalBufLen);
    if (m_Local == NULL)
    {
        LOG((RTC_ERROR, "%s allocating m_Local failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    if (wsLocalDisplayName != NULL && wcslen(wsLocalDisplayName ) != 0)
    {
        LocalValueLen = _snprintf(m_Local, LocalBufLen,
                                  "\"%.*s\" <%.*s>;tag=%.*s",
                                  m_DecodedLocal.m_DisplayName.Length,
                                  m_DecodedLocal.m_DisplayName.Buffer,
                                  m_LocalURILen,
                                  m_LocalURI,
                                  m_DecodedLocal.m_TagValue.Length,
                                  m_DecodedLocal.m_TagValue.Buffer);
    }
    else
    {
        LocalValueLen = _snprintf(m_Local, LocalBufLen,
                                  "<%.*s>;tag=%.*s",
                                  m_LocalURILen,
                                  m_LocalURI,
                                  m_DecodedLocal.m_TagValue.Length,
                                  m_DecodedLocal.m_TagValue.Buffer);
    }
    
//      LocalValueLen = _snprintf(m_Local, LocalBufLen,
//                                "%.*s",
//                                m_LocalURILen,
//                                m_LocalURI );
    if (LocalValueLen < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed returning E_FAIL",
             __fxName));
        return E_FAIL;
    }

    m_LocalLen = LocalValueLen;
    return S_OK;
}


// No tag is added. Tag from the final response will be
// added later to Remote.
HRESULT
SIP_MSG_PROCESSOR::SetRemoteForOutgoingCallHelperFn()
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRemoteForOutgoingCallHelperFn");

    int     RemoteValueLen = 0;
    ULONG   RemoteBufLen   = 0;
    
    ASSERT(m_Remote == NULL && m_RemoteLen == 0);
    
    // "DisplayName" <LocalURI>
    RemoteBufLen = m_DecodedRemote.m_DisplayName.Length +
        m_DecodedRemote.m_SipUrl.Length + 10;
    m_Remote = (PSTR) malloc(RemoteBufLen);
    if (m_Remote == NULL)
    {
        LOG((RTC_ERROR, "%s allocating m_Remote failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    if (m_DecodedRemote.m_DisplayName.Length != 0)
    {
        RemoteValueLen = _snprintf(m_Remote, RemoteBufLen,
                                   "\"%.*s\" <%.*s>",
                                   m_DecodedRemote.m_DisplayName.Length,
                                   m_DecodedRemote.m_DisplayName.Buffer,
                                   m_DecodedRemote.m_SipUrl.Length,
                                   m_DecodedRemote.m_SipUrl.Buffer);
    }
    else
    {
        RemoteValueLen = _snprintf(m_Remote, RemoteBufLen,
                                   "<%.*s>",
                                   m_DecodedRemote.m_SipUrl.Length,
                                   m_DecodedRemote.m_SipUrl.Buffer);
    }
    
    if (RemoteValueLen < 0)
    {
        LOG((RTC_ERROR, "%s _snprintf failed returning E_FAIL",
             __fxName));
        return E_FAIL;
    }

    m_RemoteLen = RemoteValueLen;
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::SetRemoteForOutgoingCall(
    IN  LPCOLESTR  wsRemoteDisplayName,
    IN  LPCOLESTR  wsRemoteURI
    )
{
    HRESULT hr;
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRemoteForOutgoingCall");

    if (wsRemoteDisplayName != NULL)
    {
        hr = UnicodeToUTF8(wsRemoteDisplayName,
                           &m_DecodedRemote.m_DisplayName.Buffer,
                           &m_DecodedRemote.m_DisplayName.Length);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UnicodeToUTF8(displayname) failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    ASSERT(wsRemoteURI != NULL);
    if (wsRemoteURI == NULL)
    {
        LOG((RTC_ERROR, "%s RemoteURI can not be NULL",
             __fxName));
        return E_FAIL;
    }
    
    hr = UnicodeToUTF8( wsRemoteURI,
                        &m_DecodedRemote.m_SipUrl.Buffer,
                        &m_DecodedRemote.m_SipUrl.Length);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s UnicodeToUTF8(remoteuri) failed %x",
             __fxName, hr));
        return hr;
    }

    hr = SetRemoteForOutgoingCallHelperFn();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetRemoteForOutgoingCallHelperFn failed %x ",
             __fxName, hr));
        return hr;
    }
    
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::SetRemoteForOutgoingCall(
    IN  PSTR    DestURI,
    IN  ULONG   DestURILen
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRemoteForOutgoingCall");
    
    hr = AllocString(DestURI, DestURILen,
                     &m_DecodedRemote.m_SipUrl.Buffer,
                     &m_DecodedRemote.m_SipUrl.Length);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - AllocString failed %x",
             __fxName, hr));
        return hr;
    }
    
    hr = SetRemoteForOutgoingCallHelperFn();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - SetRemoteForOutgoingCallHelperFn failed %x ",
             __fxName, hr));
        return hr;
    }
    
    return S_OK;
}

// Add Tag from 2xx response for the first INVITE to remote
HRESULT
SIP_MSG_PROCESSOR::AddTagFromRequestOrResponseToRemote(
    IN  PSTR  ToHeader,
    IN  ULONG ToHeaderLen
    )
{
    ENTER_FUNCTION( "SIP_MSG_PROCESSOR::AddTagFromRequestOrResponseToRemote" );

    HRESULT hr = S_OK;
    ULONG   BytesParsed = 0;
    FROM_TO_HEADER DecodedToHeader;

    if( m_DecodedRemote.m_TagValue.Buffer != NULL )
    {
        free( (PVOID)m_DecodedRemote.m_TagValue.Buffer );
        m_DecodedRemote.m_TagValue.Buffer = NULL;
        m_DecodedRemote.m_TagValue.Length = 0;
    }

    hr = ParseFromOrToHeader(ToHeader, ToHeaderLen, &BytesParsed,
                             &DecodedToHeader);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - Parse To header failed %x",
             __fxName, hr));
        return hr;
    }

    if (DecodedToHeader.m_TagValue.Length == 0)
    {
        LOG((RTC_WARN, "%s To header does not have a tag",
             __fxName));
        return S_OK;
    }
    
    hr = AllocCountedString(DecodedToHeader.m_TagValue.Buffer,
                            DecodedToHeader.m_TagValue.Length,
                            &m_DecodedRemote.m_TagValue);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(tag) failed %x",
             __fxName, hr));
        return hr;
    }

    free(m_Remote);

    hr = AllocString(ToHeader, ToHeaderLen,
                     &m_Remote, &m_RemoteLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocString(m_Remote) failed %x",
             __fxName, hr));
        return hr;
    }

    m_RemoteLen = ToHeaderLen;
    return S_OK;
}


// Add Tag to the To header.
HRESULT
SIP_MSG_PROCESSOR::SetLocalForIncomingCall(
    IN  PSTR    ToHeader,
    IN  DWORD   ToHeaderLen
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetLocalForIncomingCall");

    HRESULT hr;
    ULONG   BytesParsed = 0;
    ULONG LocalBufLen;
    int LocalValueLen = 0;
    hr = ParseFromOrToHeader(ToHeader, ToHeaderLen, &BytesParsed,
                             &m_DecodedLocal);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ParseFromOrToHeader failed %x",
             __fxName, hr));
        return hr;
    }
    ASSERT(m_Local == NULL && m_LocalLen == 0);

    // We add a tag only if one is not present in the header
    // already. Should we reject the call if the first INVITE
    // already has a tag for the To header ?
    if (m_DecodedLocal.m_TagValue.Length == 0)
    {
        // Allocate the tag.
        hr = CreateUuid(&m_DecodedLocal.m_TagValue.Buffer,
                        &m_DecodedLocal.m_TagValue.Length);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s CreateUuid failed %x",
                 __fxName, hr));
            return hr;
        }
        // Local; tag = TagValue
        LocalBufLen = ToHeaderLen + m_DecodedLocal.m_TagValue.Length + 10;
        m_Local = (PSTR) malloc(LocalBufLen);
        if (m_Local == NULL)
        {
            LOG((RTC_ERROR, "%s allocating m_Local failed", __fxName));
            return E_OUTOFMEMORY;
        }

        LocalValueLen = _snprintf(m_Local, LocalBufLen,
                                  "%.*s;tag=%.*s",
                                  ToHeaderLen, ToHeader,
                                  m_DecodedLocal.m_TagValue.Length,
                                  m_DecodedLocal.m_TagValue.Buffer);
        if (LocalValueLen < 0)
        {
            LOG((RTC_ERROR, "%s _snprintf failed", __fxName));
            return E_FAIL;
        }
        m_LocalLen = LocalValueLen;
    }
    else
    {
        m_Local = (PSTR) malloc(ToHeaderLen);
        if (m_Local == NULL)
        {
            LOG((RTC_ERROR, "%s allocating m_Local failed", __fxName));
            return E_OUTOFMEMORY;
        }
        strncpy(m_Local, ToHeader, ToHeaderLen);
        m_LocalLen = ToHeaderLen;
    }
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::SetRemoteForIncomingSession(
    IN  PSTR    FromHeader,
    IN  DWORD   FromHeaderLen
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRemoteForIncomingSession");

    HRESULT hr;
    ULONG   BytesParsed = 0;

    hr = ParseFromOrToHeader(FromHeader, FromHeaderLen, &BytesParsed,
                             &m_DecodedRemote);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ParseFromOrToHeader failed %x",
             __fxName, hr));
        return hr;
    }

    ASSERT(m_Remote == NULL && m_RemoteLen == 0);
    
    hr = AllocString(FromHeader, FromHeaderLen,
                     &m_Remote, &m_RemoteLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - AllocString failed %x",
             __fxName, hr));
        return hr;
    }

    return S_OK;
}


// Copy the user, password, host, port, user-param and other-params
// Omit everything else.
HRESULT
SIP_MSG_PROCESSOR::SetRequestURI(
    IN SIP_URL  *pSipUrl
    )
{
    HRESULT         hr;
    MESSAGE_BUILDER Builder;
    int             RequestURIBufLen;
    LIST_ENTRY     *pListEntry;
    SIP_URL_PARAM  *pSipUrlParam;
    
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetRequestURI");

    if (m_RequestURI != NULL)
    {
        free(m_RequestURI);
        m_RequestURI = NULL;
    }

    RequestURIBufLen = 5;   // "sip:" + '\0'
    RequestURIBufLen += pSipUrl->m_User.Length;
    RequestURIBufLen += 1 + pSipUrl->m_Password.Length;
    RequestURIBufLen += 1 + pSipUrl->m_Host.Length;
    RequestURIBufLen += 10; // for port

    if (pSipUrl->m_KnownParams[SIP_URL_PARAM_USER].Length != 0)
    {
        RequestURIBufLen += GetSipUrlParamName(SIP_URL_PARAM_USER)->Length;
        RequestURIBufLen += 2 + pSipUrl->m_KnownParams[SIP_URL_PARAM_USER].Length;
    }
    
    pListEntry = pSipUrl->m_OtherParamList.Flink;

    while (pListEntry != &pSipUrl->m_OtherParamList)
    {
        pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_PARAM,
                                         m_ListEntry);
        RequestURIBufLen +=
            pSipUrlParam->m_ParamName.Length +
            pSipUrlParam->m_ParamValue.Length + 2;

        pListEntry = pListEntry->Flink;
    }
    
    m_RequestURI = (PSTR) malloc(RequestURIBufLen);
    if (m_RequestURI == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating m_RequestURI failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    Builder.PrepareBuild(m_RequestURI, RequestURIBufLen);

    Builder.Append("sip:");
    
    if (pSipUrl->m_User.Length != 0)
    {
        Builder.Append(&pSipUrl->m_User);
    }

    if (pSipUrl->m_Password.Length != 0)
    {
        Builder.Append(":");
        Builder.Append(&pSipUrl->m_Password);
    }
        
    if (pSipUrl->m_User.Length != 0 ||
        pSipUrl->m_Password.Length != 0)
    {
        Builder.Append("@");
    }

    if (pSipUrl->m_Host.Length != 0)
    {
        Builder.Append(&pSipUrl->m_Host);
    }

    if (pSipUrl->m_Port != 0)
    {
        CHAR PortBuffer[10];
        Builder.Append(":");
        _itoa(pSipUrl->m_Port, PortBuffer, 10);
        Builder.Append(PortBuffer);
    }

    if (pSipUrl->m_KnownParams[SIP_URL_PARAM_USER].Length != 0)
    {
        Builder.Append(";");
        Builder.Append(GetSipUrlParamName(SIP_URL_PARAM_USER));
        Builder.Append("=");
        Builder.Append(&pSipUrl->m_KnownParams[SIP_URL_PARAM_USER]);
    }
    
    pListEntry = pSipUrl->m_OtherParamList.Flink;

    while (pListEntry != &pSipUrl->m_OtherParamList)
    {
        pSipUrlParam = CONTAINING_RECORD(pListEntry,
                                         SIP_URL_PARAM,
                                         m_ListEntry);
        Builder.Append(";");
        Builder.Append(&pSipUrlParam->m_ParamName);

        if (pSipUrlParam->m_ParamValue.Length != 0)
        {
            Builder.Append("=");
            Builder.Append(&pSipUrlParam->m_ParamValue);
        }

        pListEntry = pListEntry->Flink;
    }

    if (Builder.OverflowOccurred())
    {
        LOG((RTC_TRACE,
             "%s - not enough buffer space -- need %u bytes, got %u\n",
             __fxName, Builder.GetLength(), RequestURIBufLen));
        ASSERT(FALSE);

        free(m_RequestURI);
        m_RequestURI = NULL;
        return E_FAIL;
    }
    
    m_RequestURILen = Builder.GetLength();
    m_RequestURI[m_RequestURILen] = '\0';

    LOG((RTC_TRACE, "%s to %s len: %d BufLen: %d",
         __fxName, m_RequestURI, m_RequestURILen, RequestURIBufLen));

    return S_OK;
}

    
HRESULT
SIP_MSG_PROCESSOR::SetCredentials(
    IN  SIP_USER_CREDENTIALS *pUserCredentials,
    IN  LPCOLESTR             Realm
    )
{
    return SetCredentials(pUserCredentials->Username,
                          pUserCredentials->Password,
                          Realm);
}


HRESULT
SIP_MSG_PROCESSOR::SetCredentials(
    IN  LPCOLESTR   Username,
    IN  LPCOLESTR   Password,
    IN  LPCOLESTR   Realm
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetCredentials");

    LOG((RTC_TRACE, "%s Username: %ls Realm: %ls",
         __fxName,
         PRINTABLE_STRING_W(Username),
         PRINTABLE_STRING_W(Realm))); 

    ASSERT(!m_fCredentialsSet);
    
    m_fCredentialsSet = TRUE;
    
    if(m_Username != NULL)
    {
        free(m_Username);
        m_Username = NULL;
    }

    if(m_Password != NULL)
    {
        free(m_Password);
        m_Password = NULL;
    }

    if (m_Realm != NULL)
    {
        free(m_Realm);
        m_Realm = NULL;
    }

    if (Username != NULL)
    {
        hr = UnicodeToUTF8(Username,
                           &m_Username, &m_UsernameLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UTF8ToUnicode(m_Username) failed", __fxName));
            return hr;
        }
    }

    if (Password != NULL)
    {
        hr = UnicodeToUTF8(Password,
                           &m_Password, &m_PasswordLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UTF8ToUnicode(m_Password) failed", __fxName));
            return hr;
        }
    }
    
    if (Realm != NULL)
    {
        hr = UnicodeToUTF8(Realm, &m_Realm, &m_RealmLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s UnicodeToUTF8(m_Realm) failed", __fxName));
            return hr;
        }
    }

    return S_OK;
}


//called in sipstack
HRESULT 
SIP_MSG_PROCESSOR::SetProxyInfo(
    IN SIP_SERVER_INFO *pProxyInfo
    )
{
    HRESULT hr;
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SetProxyInfo");

    ASSERT(pProxyInfo);

    hr = UnicodeToUTF8(pProxyInfo->ServerAddress,
                       &m_ProxyAddress, &m_ProxyAddressLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - setting Proxy address failed %x",
             __fxName, hr));
        return hr;
    }
    
    if (pProxyInfo->TransportProtocol == SIP_TRANSPORT_SSL)
    {
        hr = SetRemotePrincipalName(pProxyInfo->ServerAddress);
        if (hr != S_OK)
        {
            LOG((RTC_TRACE, "%s SetRemotePrincipalName failed",
                 __fxName));
            return hr;
        }
    }
    
    m_Transport = pProxyInfo->TransportProtocol;
    m_AuthProtocol = pProxyInfo->AuthProtocol;

        
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::ConstructRouteHeader(
    IN  PSTR                     DisplayName,
    IN  ULONG                    DisplayNameLen,
    IN  PSTR                     SipUrl,
    IN  ULONG                    SipUrlLen,
    OUT RECORD_ROUTE_HEADER    **ppRouteHeader
    )
{
    HRESULT              hr;
    RECORD_ROUTE_HEADER *pRouteHeader;
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ConstructRouteHeader");

    pRouteHeader = new RECORD_ROUTE_HEADER();
    if (pRouteHeader == NULL)
    {
        LOG((RTC_ERROR, "%s  allocating route header failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    hr = AllocCountedString(DisplayName, DisplayNameLen,
                            &pRouteHeader->m_DisplayName);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(displayname) failed %x",
             __fxName, hr));
        delete pRouteHeader;
        return hr;
    }

    hr = AllocCountedString(SipUrl, SipUrlLen,
                            &pRouteHeader->m_SipUrl);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(SipUrl) failed %x",
             __fxName, hr));
        delete pRouteHeader;
        return hr;
    }

    *ppRouteHeader = pRouteHeader;
    return S_OK;
}



INT
SIP_MESSAGE::GetExpireTimeoutFromResponse(
    IN  PSTR        LocalContact,
    IN  ULONG       LocalContactLen,
    IN  INT         ulDefaultTimer
    )
{
    HRESULT         hr;
    PSTR            expiresHdr;
    ULONG           expiresHdrLen;
    INT             expireTimeout = 0;
    LIST_ENTRY     *pListEntry;
    CONTACT_HEADER *pContactHeader;
    LIST_ENTRY      ContactList;

    // Extract the timeout value from contact header.
    InitializeListHead(&ContactList);

    hr = ParseContactHeaders(&ContactList);
    if( hr == S_OK )
    {
        pListEntry = ContactList.Flink;

        while (pListEntry != &ContactList)
        {
            pContactHeader = CONTAINING_RECORD(pListEntry,
                                               CONTACT_HEADER,
                                               m_ListEntry);

            //The LocalContact is in form "<sip:172.31.56.81:2345>" and the 
            //pContactHeader->m_SipUrl.Buffer is in form "sip:172.31.56.81:2345"
            if( _strnicmp( pContactHeader->m_SipUrl.Buffer,
                           LocalContact, LocalContactLen ) == 0 )
            {
                expireTimeout = pContactHeader->m_ExpiresValue;
                
                if( expireTimeout > ulDefaultTimer )
                {
                    expireTimeout = ulDefaultTimer;
                }

                break;
            }

            pListEntry = pListEntry->Flink;
        }

        FreeContactHeaderList(&ContactList);
    }

    if( expireTimeout == 0 )
    {
        //Use the expires header
        hr = GetSingleHeader(   SIP_HEADER_EXPIRES,
                                &expiresHdr,
                                &expiresHdrLen );
    
        if( hr == S_OK )
        {
            expireTimeout = ParseExpiresValue( expiresHdr, 
                expiresHdrLen );
            
            if( expireTimeout > ulDefaultTimer )
            {
                expireTimeout = ulDefaultTimer;
            }
        }
        else
        {
            //No expires header.
            return -1;
        }
    }

    return expireTimeout;
}


HRESULT
SIP_MSG_PROCESSOR::ConstructRouteHeader(
    IN  PSTR                     DisplayName,
    IN  ULONG                    DisplayNameLen,
    IN  SIP_URL                 *pSipUrl,
    OUT RECORD_ROUTE_HEADER    **ppRouteHeader
    )
{
    HRESULT              hr;
    RECORD_ROUTE_HEADER *pRouteHeader;
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ConstructRouteHeader");

    pRouteHeader = new RECORD_ROUTE_HEADER();
    if (pRouteHeader == NULL)
    {
        LOG((RTC_ERROR, "%s  allocating route header failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    hr = AllocCountedString(DisplayName, DisplayNameLen,
                            &pRouteHeader->m_DisplayName);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AllocCountedString(displayname) failed %x",
             __fxName, hr));
        delete pRouteHeader;
        return hr;
    }

    hr = pSipUrl->GetString(&pRouteHeader->m_SipUrl.Buffer,
                            &pRouteHeader->m_SipUrl.Length);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s get sip url string failed %x",
             __fxName, hr));
        delete pRouteHeader;
        return hr;
    }
    
    *ppRouteHeader = pRouteHeader;
    return S_OK;
}


VOID
SIP_MSG_PROCESSOR::FreeRouteHeaderList()
{
    LIST_ENTRY          *pListEntry;
    RECORD_ROUTE_HEADER *pRouteHeader;

    while (!IsListEmpty(&m_RouteHeaderList))
    {
        pListEntry = RemoveHeadList(&m_RouteHeaderList);

        pRouteHeader = CONTAINING_RECORD(pListEntry,
                                         RECORD_ROUTE_HEADER,
                                         m_ListEntry);
        delete pRouteHeader;
    }
}


HRESULT
SIP_MSG_PROCESSOR::ConstructRouteHeadersFromRequest(
    IN LIST_ENTRY  *pRecordRouteHeaderList,
    IN PSTR         ContactHeader,
    IN ULONG        ContactHeaderLen
    )
{
    ULONG                BytesParsed = 0;
    OFFSET_STRING        ContactHeaderDisplayName;
    OFFSET_STRING        ContactHeaderSipUrl;
    RECORD_ROUTE_HEADER *pRecordRouteHeader;
    LIST_ENTRY          *pListEntry;
    RECORD_ROUTE_HEADER *pRouteHeader;
    HRESULT              hr;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ConstructRouteHeadersFromRequest");
    ASSERT(pRecordRouteHeaderList != NULL &&
           !IsListEmpty(pRecordRouteHeaderList));
    
    if (ContactHeader != NULL)
    {
        BytesParsed = 0;
        hr = ParseNameAddrOrAddrSpec(ContactHeader, ContactHeaderLen,
                                     &BytesParsed,
                                     ',', // ',' separates Contact headers
                                     &ContactHeaderDisplayName,
                                     &ContactHeaderSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s ParseNameAddrOrAddrSpec(ContactHeader) failed %x",
                 __fxName, hr));
            return hr;
        }
    }
    
    // We replace any currently existing Route header list
    FreeRouteHeaderList();

    // We have to copy the list to the new Route list as the record
    // route header list is needed for the incoming transaction.
    
    pListEntry = pRecordRouteHeaderList->Flink;
    while (pListEntry != pRecordRouteHeaderList)
    {
        pRecordRouteHeader = CONTAINING_RECORD(pListEntry,
                                               RECORD_ROUTE_HEADER,
                                               m_ListEntry);

        hr = ConstructRouteHeader(pRecordRouteHeader->m_DisplayName.Buffer,
                                  pRecordRouteHeader->m_DisplayName.Length,
                                  pRecordRouteHeader->m_SipUrl.Buffer,
                                  pRecordRouteHeader->m_SipUrl.Length,
                                  &pRouteHeader);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ConstructRouteHeader failed %x",
                 __fxName, hr));
            return hr;
        }
        InsertTailList(&m_RouteHeaderList, &pRouteHeader->m_ListEntry);
        
        pListEntry = pListEntry->Flink;
    }
    
    // If Contact header is present add it to the end of the list.
    if (ContactHeader != NULL)
    {
        // Add the Contact header to the end of Route.
        hr = ConstructRouteHeader(
                 ContactHeaderDisplayName.GetString(ContactHeader),
                 ContactHeaderDisplayName.GetLength(),
                 ContactHeaderSipUrl.GetString(ContactHeader),
                 ContactHeaderSipUrl.GetLength(),
                 &pRouteHeader);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ConstructRouteHeader failed %x",
                 __fxName, hr));
            return hr;
        }

        InsertTailList(&m_RouteHeaderList, &pRouteHeader->m_ListEntry);
    }

    return S_OK;
}


// If Record-Route header(s) are present construct Route header
// and set the request destination from the first Route header.
// else if Contact is present set request destination from Contact.
// else if From has resolvable URL set request destination from From.
HRESULT
SIP_MSG_PROCESSOR::ProcessRecordRouteContactAndFromHeadersInRequest(
    IN LIST_ENTRY  *pRecordRouteHeaderList,
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    PSTR    ContactHeader    = NULL;
    ULONG   ContactHeaderLen = 0;
    ULONG   BytesParsed = 0;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ProcessRecordRouteContactAndFromHeadersInRequest");
    LOG((RTC_TRACE,"%s entered",__fxName));

    hr = pSipMsg->GetFirstHeader(SIP_HEADER_CONTACT,
                                 &ContactHeader, &ContactHeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN,
             "%s Contact header not found in Request - will use From header",
             __fxName));
    }

    if (pRecordRouteHeaderList != NULL &&
        !IsListEmpty(pRecordRouteHeaderList))
    {
        // Construct Route header
        hr = ConstructRouteHeadersFromRequest(
                 pRecordRouteHeaderList,
                 ContactHeader,
                 ContactHeaderLen
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s ConstructRouteHeadersFromRecordRouteHeadersInRequest failed %x",
                 __fxName, hr));
            return hr ;
        }

        // Set request destination based on the first element
        // of the Route.
        LIST_ENTRY          *pListEntry;
        RECORD_ROUTE_HEADER *pRouteHeader;
        
        pListEntry = RemoveHeadList(&m_RouteHeaderList);
        pRouteHeader = CONTAINING_RECORD(pListEntry,
                                         RECORD_ROUTE_HEADER,
                                         m_ListEntry);
        
        hr = ResolveSipUrlAndSetRequestDestination(
                 pRouteHeader->m_SipUrl.Buffer,
                 pRouteHeader->m_SipUrl.Length,
                 TRUE, TRUE, TRUE, FALSE);
        
        delete pRouteHeader;
        
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s ResolveSipUrlAndSetRequestDestination failed (route) %x",
                 __fxName, hr));
            return hr;
        }
    }
    else if (ContactHeader != NULL)
    {
        // Set request destination based on the Contact.
        OFFSET_STRING   ContactHeaderDisplayName;
        OFFSET_STRING   ContactHeaderSipUrl;
        
        hr = ParseNameAddrOrAddrSpec(
                 ContactHeader, ContactHeaderLen,
                 &BytesParsed,
                 ',', // ',' separates Contact headers
                 &ContactHeaderDisplayName,
                 &ContactHeaderSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s  ParseNameAddrOrAddrSpec(contact header) failed %x",
                 __fxName, hr));
            return hr;
        }
        
        hr = ResolveSipUrlAndSetRequestDestination(
                 ContactHeaderSipUrl.GetString(ContactHeader),
                 ContactHeaderSipUrl.GetLength(),
                 TRUE, FALSE, TRUE, FALSE);

        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s ResolveSipUrlAndSetRequestDestination (contact) failed %x",
                 __fxName,hr));
            return hr;
        }
    }
    else
    {
        // Set request destination based on the From for UDP calls only.
        // For TCP/SSL session we will continue to use the connection established.
        
        if (m_Transport == SIP_TRANSPORT_UDP)
        {
            hr = ResolveSipUrlAndSetRequestDestination(
                     m_DecodedRemote.m_SipUrl.Buffer,
                     m_DecodedRemote.m_SipUrl.Length,
                     TRUE, TRUE, TRUE, FALSE);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "%s ResolveSipUrlAndSetRequestDestination failed (from) %x",
                     __fxName,hr));
                return hr;
            }
        }
    }
        
    return S_OK;
}

    
// If Record-Route header(s) are present construct Route header
// and set the request destination from the first Route header.
// else if Contact is present set request destination from Contact.

// XXX If we process Record-Route/Contact headers for requests other
// than the first INVITE, then we need to be careful about freeing
// any existing Route. Also in this case if we get a Contact header
// without the Record-Route, should we update the request destination
// based on just the Contact or should we leave the Route as it is.
HRESULT
SIP_MSG_PROCESSOR::ProcessRecordRouteAndContactHeadersInResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT         hr;
    PSTR            ContactHeader    = NULL;
    ULONG           ContactHeaderLen = 0;
    ULONG           BytesParsed      = 0;
    LIST_ENTRY      RouteHeaderList;
    OFFSET_STRING   ContactHeaderDisplayName;
    OFFSET_STRING   ContactHeaderSipUrl;
    
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ProcessRecordRouteAndContactHeadersInResponse");
    LOG((RTC_TRACE,"%s entered",__fxName));

    // 
    // If Record-Route headers present
    //   Reverse list
    //   Add Contact header to end of list if present
    //   set request destination based on Route headers
    // else if Contact header is present
    //   set request destination based on Contact header

    InitializeListHead(&RouteHeaderList);
    hr = pSipMsg->ParseRecordRouteHeaders(&RouteHeaderList);
    if (hr != S_OK && hr != RTC_E_SIP_HEADER_NOT_PRESENT)
    {
        LOG((RTC_ERROR, "%s - ParseRecordRouteHeaders failed %x",
             __fxName, hr));
        return hr;
    }

    hr = pSipMsg->GetFirstHeader(SIP_HEADER_CONTACT,
                                 &ContactHeader, &ContactHeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_WARN,
             "%s Contact header not found in response",
             __fxName));
    }
    else
    {
        hr = ParseNameAddrOrAddrSpec(ContactHeader, ContactHeaderLen,
                                     &BytesParsed,
                                     ',', // ',' separates Contact headers
                                     &ContactHeaderDisplayName,
                                     &ContactHeaderSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s  ParseNameAddrOrAddrSpec(contact header) failed %x",
                 __fxName, hr));
            return hr;
        }
    }

                       
    if (!IsListEmpty(&RouteHeaderList))
    {
        FreeRouteHeaderList();
        ReverseList(&RouteHeaderList);
        MoveListToNewListHead(&RouteHeaderList, &m_RouteHeaderList);

        // If Contact header is present add it to the end of the list.
        if (ContactHeader != NULL)
        {
            RECORD_ROUTE_HEADER *pRouteHeader;
            
            // Add the Contact header to the end of Route.
            hr = ConstructRouteHeader(
                     ContactHeaderDisplayName.GetString(ContactHeader),
                     ContactHeaderDisplayName.GetLength(),
                     ContactHeaderSipUrl.GetString(ContactHeader),
                     ContactHeaderSipUrl.GetLength(),
                     &pRouteHeader);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s ConstructRouteHeader failed %x",
                     __fxName, hr));
                return hr;
            }
            
            InsertTailList(&m_RouteHeaderList, &pRouteHeader->m_ListEntry);
        }
        
        // Set request destination based on the first element
        // of the Route.
        LIST_ENTRY          *pListEntry;
        RECORD_ROUTE_HEADER *pRouteHeader;
        
        pListEntry = RemoveHeadList(&m_RouteHeaderList);
        pRouteHeader = CONTAINING_RECORD(pListEntry,
                                         RECORD_ROUTE_HEADER,
                                         m_ListEntry);
        
        hr = ResolveSipUrlAndSetRequestDestination(
                 pRouteHeader->m_SipUrl.Buffer,
                 pRouteHeader->m_SipUrl.Length,
                 TRUE, TRUE, TRUE, FALSE);
        
        
        delete pRouteHeader;
        
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s ResolveSipUrlAndSetRequestDestination failed (route) %x",
                 __fxName,hr));
            return hr;
        }
    }
    else if (ContactHeader != NULL)
    {

        hr = ResolveSipUrlAndSetRequestDestination(
                 ContactHeaderSipUrl.GetString(ContactHeader),
                 ContactHeaderSipUrl.GetLength(),
                 TRUE, FALSE, TRUE, FALSE);
        

        if (hr != S_OK)
        {
            LOG((RTC_ERROR,
                 "%s ResolveSipUrlAndSetRequestDestination failed (contact) %x",
                 __fxName,hr));
            return hr;
        }
    }
    else
    {
        LOG((RTC_TRACE,
             "%s - No Record-Route/Contact headers not updating request destination",
             __fxName));
    }
        
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::DropRequestIfBadToTag(
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT         hr = S_OK;
    PSTR            ToHeader = NULL;
    ULONG           ToHeaderLen = 0;
    FROM_TO_HEADER  DecodedFromHeader;
    FROM_TO_HEADER  DecodedToHeader;
    ULONG           BytesParsed = 0;
    
    ENTER_FUNCTION("DropRequestIfBadToTag");

    // Drop the request if the To tag doesn't match
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, 
                                    &ToHeader, 
                                    &ToHeaderLen);
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s Couldn't find To header %x", __fxName, hr ));
        
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                    pResponseSocket->GetTransport(),
                                    pSipMsg,
                                    pResponseSocket,
                                    400,
                                    NULL,
                                    0 );
        
        return E_FAIL;
    }

    hr = ParseFromOrToHeader(ToHeader, 
                             ToHeaderLen, 
                             &BytesParsed,
                             &DecodedToHeader);
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s - Parse To header failed %x", __fxName, hr ));
        
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                    pResponseSocket->GetTransport(),
                                    pSipMsg,
                                    pResponseSocket,
                                    400,
                                    NULL,
                                    0 );

        return E_FAIL;
    }

    if( (m_DecodedLocal.m_TagValue.Length != DecodedToHeader.m_TagValue.Length) ||
        strncmp(m_DecodedLocal.m_TagValue.Buffer,
                DecodedToHeader.m_TagValue.Buffer, 
                m_DecodedLocal.m_TagValue.Length)
      )
    {
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                    pResponseSocket->GetTransport(),
                                    pSipMsg,
                                    pResponseSocket,
                                    481,
                                    NULL,
                                    0 );

        return E_FAIL;
    }

    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::CheckFromToInRequest(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr = S_OK;
    PSTR ToHeader = NULL;
    ULONG ToHeaderLen = 0;
    PSTR FromHeader = NULL;
    ULONG FromHeaderLen = 0;
    FROM_TO_HEADER DecodedFromHeader;
    FROM_TO_HEADER DecodedToHeader;
    ULONG BytesParsed = 0;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CheckFromToInRequest");

    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);
    //Incoming To is checked with stored From
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, 
                                    &ToHeader, 
                                    &ToHeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Couldn't find To header %x",
             __fxName, hr));
        return E_FAIL;
    }
    hr = ParseFromOrToHeader(ToHeader, 
                             ToHeaderLen, 
                             &BytesParsed,
                             &DecodedToHeader);
    BytesParsed = 0;
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - Parse To header failed %x",
             __fxName, hr));
        return E_FAIL;
    }
   //For retransmissions support: We check if TO header contains a tag. If not we do not do
   //check for the TO tag
   //Do not test tag for Notify since tag update is on Notify (in addition to 200 OK)

   if(pSipMsg->GetMethodId() == SIP_METHOD_NOTIFY ||
       pSipMsg->GetMethodId() == SIP_METHOD_SUBSCRIBE ||
        DecodedToHeader.m_TagValue.Length == 0)
   {
       if(!AreFromToHeadersEqual(&m_DecodedLocal, &DecodedToHeader, FALSE, FALSE))
       {
           LOG((RTC_ERROR,
               "%s - Incoming To HeaderTag is not same as stored Local",
               __fxName));
           return E_FAIL;
       }
   }
   else
   {
       if(!AreFromToHeadersEqual(&m_DecodedLocal, &DecodedToHeader, FALSE, TRUE))
       {
           LOG((RTC_ERROR,
               "%s - Incoming To HeaderTag is not same as stored Local",
               __fxName));
           return E_FAIL;
       }
   }
    //Incoming From is checked with stored To
    hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, 
                                    &FromHeader, 
                                    &FromHeaderLen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s Couldn't find From header %x",
             __fxName, hr));
        return E_FAIL;
    }
    hr = ParseFromOrToHeader(FromHeader, 
                                FromHeaderLen, 
                                &BytesParsed,
                                &DecodedFromHeader);
    BytesParsed = 0;
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - Parse From header failed %x",
             __fxName, hr));
        return E_FAIL;
    }
    //Always check the from tag except for notify
    if(pSipMsg->GetMethodId() != SIP_METHOD_NOTIFY)
    {
        if(!AreFromToHeadersEqual(&m_DecodedRemote, &DecodedFromHeader, FALSE, TRUE))
        {
            LOG((RTC_ERROR,
                 "%s - Incoming From Header is not same as stored Remote",
                 __fxName));
            return E_FAIL;
        }
    }
    else
    {
        if(!AreFromToHeadersEqual(&m_DecodedRemote, &DecodedFromHeader, FALSE, FALSE))
        {
            LOG((RTC_ERROR,
                 "%s - Incoming From Header is not same as stored Remote",
                 __fxName));
            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::CheckFromToInResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr = S_OK;
    PSTR ToHeader = NULL;
    ULONG ToHeaderLen = 0;
    PSTR FromHeader = NULL;
    ULONG FromHeaderLen = 0;
    FROM_TO_HEADER DecodedFromHeader;
    FROM_TO_HEADER DecodedToHeader;
    ULONG BytesParsed = 0;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CheckFromToInResponse");
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);
    if (IsFinalResponse(pSipMsg))
    {
        //Incoming From is checked with stored Local
        hr = pSipMsg->GetSingleHeader(SIP_HEADER_FROM, 
                                        &FromHeader, 
                                        &FromHeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s Couldn't find From header %x",
                 __fxName, hr));
            return E_FAIL;
        }
        hr = ParseFromOrToHeader(FromHeader, 
                                    FromHeaderLen, 
                                    &BytesParsed,
                                    &DecodedFromHeader);
        BytesParsed = 0;
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - Parse From header failed %x",
                 __fxName, hr));
            return E_FAIL;
        }
        
        if( pSipMsg->CSeqMethodId == SIP_METHOD_NOTIFY )
        {            
            if(!AreFromToHeadersEqual(&m_DecodedLocal, &DecodedFromHeader, TRUE, FALSE))
            {
                LOG((RTC_TRACE,
                     "%s - Incoming From Header is not same as stored Local",
                     __fxName));
                return E_FAIL;
            }
        }
        else if(!AreFromToHeadersEqual(&m_DecodedLocal, &DecodedFromHeader, TRUE, TRUE))
        {
            LOG((RTC_TRACE,
                 "%s - Incoming From Header is not same as stored Local",
                 __fxName));
            return E_FAIL;
        }
        
        //Incoming To is checked with stored Remote
        hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, 
                                        &ToHeader, 
                                        &ToHeaderLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s Couldn't find To header %x",
                 __fxName, hr));
            return E_FAIL;
        }
        hr = ParseFromOrToHeader(ToHeader, 
                                    ToHeaderLen, 
                                    &BytesParsed,
                                    &DecodedToHeader);
        BytesParsed = 0;
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - Parse To header failed %x",
                 __fxName, hr));
            return E_FAIL;
        }
        //Do not check To tag for 407 to accomodate the case when we send 2 messages simulatneously, and both gets
        //407, the 200 ok for 1 comes before 407 of 2nd.
        if( (pSipMsg->Response.StatusCode == 407) ||
            (pSipMsg->CSeqMethodId == SIP_METHOD_SUBSCRIBE) )
        {
            if(!AreFromToHeadersEqual(&m_DecodedRemote, &DecodedToHeader, TRUE, FALSE))
            {
                LOG((RTC_TRACE,
                     "%s - Incoming To Header is not same as stored Remote",
                     __fxName));
                return E_FAIL;
            }
        }
        else
        {
            if(!AreFromToHeadersEqual(&m_DecodedRemote, &DecodedToHeader, TRUE, TRUE))
            {
                LOG((RTC_TRACE,
                     "%s - Incoming To Header is not same as stored Remote",
                     __fxName));
                return E_FAIL;
            }
        }
    }

    return S_OK;
}

BOOL
SIP_MSG_PROCESSOR::DoesMessageBelongToMsgProc(
    IN SIP_MESSAGE *pSipMsg
    )
{
    PSTR  CallId;
    ULONG CallIdLen;

    pSipMsg->GetCallId(&CallId, &CallIdLen);
    return (CallIdLen == m_CallIdLen &&
            !strncmp(m_CallId, CallId, CallIdLen) &&
            m_MsgProcType != SIP_MSG_PROC_TYPE_REQFAIL);
}


// Shutdown any existing transactions so that the references
// on the msg processor will be released.
VOID
SIP_MSG_PROCESSOR::Shutdown()
{
    LIST_ENTRY             *pListEntry;
    OUTGOING_TRANSACTION   *pOutgoingTransaction;
    INCOMING_TRANSACTION   *pIncomingTransaction;
    HRESULT hr;
    ULONG   i = 0;
    ULONG   AsyncNotifyCount = 0;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::Shutdown");
    
    LOG((RTC_TRACE,
         "%s - shutting down msgproc (%x) type: %d refcount : %d ",
         __fxName, this, m_MsgProcType, m_RefCount));

    // The deletions will release the reference on this
    // SIP_MSG_PROCESSOR causing its deletion. So keep a reference to
    // keep the SIP_MSG_PROCESSOR alive till this routine is done.
    MsgProcAddRef();

    // Clean up any state that could cause callbacks
    // such as DNS work items, HTTP Proxy callbacks etc.

    hr = ResolveHttpProxyCleanUp();
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,"%s ResolveHttpProxyCleanUp failed",__fxName));
    }

    hr = DestroyHttpProxyProcessWindow();
    if(hr != S_OK)
    {
        LOG((RTC_ERROR,"%s DestroyHttpProxyProcessWindow failed",__fxName));
    }
    ReleaseRequestSocket();
    FreeHttpProxyContext();
   
    pListEntry = m_OutgoingTransactionList.Flink;

    while (pListEntry != &m_OutgoingTransactionList)
    {
        pOutgoingTransaction = CONTAINING_RECORD(pListEntry,
                                                 OUTGOING_TRANSACTION,
                                                 m_ListEntry);

        pListEntry = pListEntry->Flink;

        // Get this before calling OnTransactionDone()
        AsyncNotifyCount = pOutgoingTransaction->GetAsyncNotifyCount();

        LOG((RTC_TRACE, "%s this: %x OutgoingTrans : %x AsyncNotifyCount: %x",
             __fxName, this, pOutgoingTransaction, AsyncNotifyCount));
        //delete pOutgoingTransaction;
        if (!pOutgoingTransaction->IsTransactionDone())
        {
            pOutgoingTransaction->OnTransactionDone();
        }

        // Release any references held for async notifications
        for (i = 0; i < AsyncNotifyCount; i++)
        {
            pOutgoingTransaction->DecrementAsyncNotifyCount();
            pOutgoingTransaction->TransactionRelease();
        }
    }

    pListEntry = m_IncomingTransactionList.Flink;

    while (pListEntry != &m_IncomingTransactionList)
    {
        pIncomingTransaction = CONTAINING_RECORD(pListEntry,
                                                 INCOMING_TRANSACTION,
                                                 m_ListEntry);

        pListEntry = pListEntry->Flink;

        // Get this before calling OnTransactionDone()
        AsyncNotifyCount = pIncomingTransaction->GetAsyncNotifyCount();
        
        LOG((RTC_TRACE, "%s this: %x IncomingTrans : %x AsyncNotifyCount: %x",
             __fxName, this, pIncomingTransaction, AsyncNotifyCount));
        
        // delete pIncomingTransaction;
        if (!pIncomingTransaction->IsTransactionDone())
        {
            pIncomingTransaction->OnTransactionDone();
        }

        // Release any references held for async notifications
        for (i = 0; i < AsyncNotifyCount; i++)
        {
            pIncomingTransaction->DecrementAsyncNotifyCount();
            pIncomingTransaction->TransactionRelease();
        }
    }

    MsgProcRelease();
}


// XXX How should we handle the scenario where the buffer size is
// not sufficient.
// Since we know what will be in the message, we should compute
// the length of the buffer before allocating the buffer.
// Content-Length, Content-Type, User-Agent, Messsage Body

// This method adds all the common headers. Any additional headers
// should be passed in AdditionalHeaderArray.

// To header is usually picked up from m_Remote. In the special case
// where the ACK is to be sent for a non 2xx final response we use
// the To header from the response.
HRESULT
SIP_MSG_PROCESSOR::CreateRequestMsg(
    IN  SIP_METHOD_ENUM             MethodId,
    IN  ULONG                       CSeq,
    IN  PSTR                        ToHeader,
    IN  ULONG                       ToHeaderLen,
    IN  SIP_HEADER_ARRAY_ELEMENT   *AdditionalHeaderArray,
    IN  ULONG                       AdditionalHeaderCount,
    IN  PSTR                        MsgBody,
    IN  ULONG                       MsgBodyLen,  
    IN  PSTR                        ContentType,
    IN  ULONG                       ContentTypeLen, 
    OUT SEND_BUFFER               **ppRequestBuffer
    )
{
    HRESULT             hr;
    ULONG               BufLen      = SEND_BUFFER_SIZE;
    ULONG               BytesFilled = 0;
    SEND_BUFFER *pSendBuffer = NULL;
    SIP_HEADER_ARRAY_ELEMENT    pAuthHeaderElement;
    BOOL                        fSignatureNeeded = TRUE;
    ULONG                       tempBufLen;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CreateRequestMsg");

    PSTR Buffer = (PSTR) malloc(BufLen);
    if (Buffer == NULL)
    {
        LOG((RTC_ERROR, "%s Allocating Buffer failed", __fxName));
        return E_OUTOFMEMORY;
    }

    hr = AppendRequestLine(Buffer, BufLen, &BytesFilled,
                           MethodId, m_RequestURI, m_RequestURILen);
    if (hr != S_OK)
        goto error;

    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_VIA, m_RequestVia, m_RequestViaLen);
    if (hr != S_OK)
        goto error;

    // The buffer to be signed starts here.
    tempBufLen = BytesFilled;

    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_FROM, m_Local, m_LocalLen);
    if (hr != S_OK)
        goto error;

    if (ToHeaderLen == 0)
    {
        hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                          SIP_HEADER_TO, m_Remote, m_RemoteLen);
        if (hr != S_OK)
            goto error;
    }
    else
    {
        hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                          SIP_HEADER_TO, ToHeader, ToHeaderLen);
        if (hr != S_OK)
            goto error;
    }
    
    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_CALL_ID, m_CallId, m_CallIdLen);
    if (hr != S_OK)
        goto error;

    hr = AppendCSeqHeader(Buffer, BufLen, &BytesFilled,
                          CSeq, MethodId);
    if (hr != S_OK)
        goto error;

    hr = AppendRecordRouteHeaders(Buffer, BufLen, &BytesFilled,
                                  SIP_HEADER_ROUTE, &m_RouteHeaderList);
    if (hr != S_OK)
        goto error;

    // For SSL send Contact only for register message
    // if (m_Transport != SIP_TRANSPORT_SSL || MethodId == SIP_METHOD_REGISTER)

    hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                      SIP_HEADER_CONTACT, m_LocalContact, m_LocalContactLen);
    if (hr != S_OK)
        goto error;

    hr = AppendUserAgentHeaderToRequest(Buffer, BufLen, &BytesFilled);
    if (hr != S_OK)
        goto error;

    if (AdditionalHeaderCount != 0)
    {
        for (ULONG i = 0; i < AdditionalHeaderCount; i++)
        {
            
            hr = AppendHeader(Buffer, BufLen, &BytesFilled,
                              AdditionalHeaderArray[i].HeaderId,
                              AdditionalHeaderArray[i].HeaderValue,
                              AdditionalHeaderArray[i].HeaderValueLen);
            if (hr != S_OK)
                goto error;
        }

    }
    
    if (MsgBody == NULL)
    {
        // Created with a ref count of 1.
        pSendBuffer = new SEND_BUFFER(Buffer, SEND_BUFFER_SIZE);
        if (pSendBuffer == NULL)
        {
            LOG((RTC_ERROR, "%s Allocating SEND_BUFFER failed", __fxName));
            hr = E_OUTOFMEMORY;
            goto error;
        }

        hr = AppendEndOfHeadersAndNoMsgBody(Buffer, BufLen,
                                            &BytesFilled);
        if (hr != S_OK)
            goto error;
    }
    else
    {

        if ((BytesFilled + MsgBodyLen + ContentTypeLen + 100) > BufLen)
        {
            //The additional 100 is to accomodate the headers.
            BufLen = BytesFilled + MsgBodyLen + ContentTypeLen +100;

            //store temporary pointer
            void * tmpBuffer = Buffer;
            // Reallocate
            Buffer = (PSTR) realloc(Buffer, BufLen);
            if (Buffer ==  NULL)
            {
                //free buffer
                free(tmpBuffer);
                hr =E_OUTOFMEMORY;
                goto error;
            }
            pSendBuffer = new SEND_BUFFER(Buffer, BufLen);
            if (pSendBuffer == NULL)
            {
                LOG((RTC_ERROR, "%s Allocating SEND_BUFFER failed", __fxName));
                hr = E_OUTOFMEMORY;
                goto error;
            }

        }
        else
        {
            // Created with a ref count of 1.
            pSendBuffer = new SEND_BUFFER(Buffer, SEND_BUFFER_SIZE);
            if (pSendBuffer == NULL)
            {
                LOG((RTC_ERROR, "%s Allocating SEND_BUFFER failed", __fxName));
                hr = E_OUTOFMEMORY;
                goto error;
            }
        }

        hr = AppendMsgBody(Buffer, BufLen, &BytesFilled,
                           MsgBody, MsgBodyLen, 
                           ContentType, ContentTypeLen
                           );
        if (hr != S_OK)
           goto error;
    }


    pSendBuffer->m_BufLen = BytesFilled;
    *ppRequestBuffer      = pSendBuffer;

    LOG((RTC_TRACE, "CreateRequestMsg done BufLen: %d", BytesFilled));
    return S_OK;
    
 error:
    if (pSendBuffer != NULL)
    {
        // Deleting pSendBuffer will also free Buffer.
        delete pSendBuffer;
    }
    else if (Buffer != NULL)
    {
        free(Buffer);
    }
    
    *ppRequestBuffer = NULL;
    return hr;
}


// Returns HRESULT_FROM_WIN32(WSAEWOULDBLOCK)
// if we are trying to reestablish the TCP/SSL connection
// to the destination due to a error on Send()
// XXX Callers need to check for this value and wait for connect completion
// 
HRESULT
SIP_MSG_PROCESSOR::SendRequestMsg(
    IN SEND_BUFFER                 *pSendBuffer
    )
{
    DWORD   Error;
    HRESULT hr;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::SendRequestMsg");
    
    LOG((RTC_TRACE, "%s - enter", __fxName));

    ASSERT(m_pRequestSocket != NULL);
    ASSERT(m_RequestSocketState == REQUEST_SOCKET_CONNECTED);

    // XXX Do we need this check ?
    // Check if a request socket exists
    if (m_pRequestSocket != NULL)
    {
        Error = m_pRequestSocket->Send(pSendBuffer);
        if (Error == NO_ERROR)
        {
            return S_OK;
        }
        else 
        {
            ReleaseRequestSocket();
            
            // For UDP transport we always create the socket and connect
            // it to the destination. For TCP sometimes we try to use
            // an incoming TCP connection for sending requests. In this
            // case if there is an error, then we establish a new connection
            // to the destination.
            if (m_Transport == SIP_TRANSPORT_UDP)
            {
                LOG((RTC_ERROR, "%s m_pRequestSocket->Send() failed for UDP %x",
                     __fxName, Error));
                return HRESULT_FROM_WIN32(Error);
            }
            else
            {
                LOG((RTC_WARN,
                     "%s m_pRequestSocket->Send() failed for TCP/SSL %x "
                     "will try another connection", __fxName, Error));
            }
        }
    }

    if (m_RequestDestAddr.sin_addr.s_addr == htonl(0))
    {
        // This could happen if the first incoming INVITE has no
        // Record-Route/Contact header and it also doesn't have the
        // address in the From header.
        LOG((RTC_ERROR, "%s - RequestDestAddr is 0 - this shouldn't happen",
             __fxName));
        return RTC_E_SIP_REQUEST_DESTINATION_ADDR_NOT_PRESENT;
    }
    
    // Establish request socket connection and
    // queue the send request.
    hr = m_pSipStack->GetSocketToDestination(&m_RequestDestAddr,
                                             m_Transport, m_RemotePrincipalName,
                                             this,
                                             NULL,
                                             &m_pRequestSocket);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s m_pSipStack->GetSocketToDestination() failed %x",
             __fxName, hr));
        if (hr == HRESULT_FROM_WIN32(WSAEWOULDBLOCK))
        {
            m_RequestSocketState = REQUEST_SOCKET_CONNECTING;
        }
        return hr;
    }
    
    Error = m_pRequestSocket->Send(pSendBuffer);
    if (Error != NO_ERROR)
    {
        LOG((RTC_ERROR, "%s m_pRequestSocket->Send() failed %x",
             __fxName, Error));
        return HRESULT_FROM_WIN32(Error);
    }

    LOG((RTC_TRACE, "%s - exit", __fxName));
    return S_OK;
}



// pResponseSocket is the socket on which the message
// arrived.
HRESULT
SIP_MSG_PROCESSOR::ProcessMessage(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ProcessMessage");

    //    pResponseSocket->GetTransport() != SIP_TRANSPORT_SSL)
    if (m_Transport == SIP_TRANSPORT_SSL &&
        pResponseSocket != m_pRequestSocket)
    {
        LOG((RTC_WARN,
             "%s msgproc transport is ssl - message transport non-SSL : %d",
             __fxName, pResponseSocket->GetTransport()));
        return E_FAIL;
    }

    if (pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST)
    {
        return ProcessRequest(pSipMsg, pResponseSocket);
    }
    else if (pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE)
    {
        return ProcessResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


HRESULT
SIP_MSG_PROCESSOR::CreateIncomingReqFailTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket,
    IN ULONG         StatusCode,
    SIP_HEADER_ARRAY_ELEMENT   *pAdditionalHeaderArray,
    ULONG AdditionalHeaderCount
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CreateIncomingReqFailTransaction");
    
    INCOMING_REQFAIL_TRANSACTION * pIncomingReqfailTransaction
        = new INCOMING_REQFAIL_TRANSACTION(this,
                                           pSipMsg->GetMethodId(),
                                           pSipMsg->GetCSeq(),
                                           StatusCode
                                           );
    if (pIncomingReqfailTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s allocating pIncomingReqfailTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }

    if (pSipMsg->GetMethodId() == SIP_METHOD_UNKNOWN)
    {
        hr = pIncomingReqfailTransaction->SetMethodStr(
                 pSipMsg->GetMethodStr(),
                 pSipMsg->GetMethodStrLen()
                 );
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  SetMethodStr failed %x",
                 __fxName, hr));
            return hr;
        }
    }

    hr = pIncomingReqfailTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        pIncomingReqfailTransaction->OnTransactionDone();
        return hr;
    }
    
    hr = pIncomingReqfailTransaction->ProcessRequest(pSipMsg, pResponseSocket,
                                                     pAdditionalHeaderArray,
                                                     AdditionalHeaderCount
                                                    );
    if (hr != S_OK)
    {
        return hr;
    }

    return S_OK;
}


// Go through existing incoming transactions and process
// the request if the CSeq is present.
// If not present, if CSeq <= highest CSeq of incoming
// transaction, this is an old CSeq - send 400.
// else create a new incoming transaction.

// Note that this algorithm has some problems in that
// we might end up sending 400 to a valid request if the
// requests are received out of order, but this will be
// under very rare circumstances. To actually process this case
// correctly, we need to maintain more state.

HRESULT
SIP_MSG_PROCESSOR::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    // Find the transaction that the message belongs to.
    HRESULT                     hr = S_OK;
    LIST_ENTRY                 *pListEntry;
    INCOMING_TRANSACTION       *pSipTransaction;
    SIP_HEADER_ARRAY_ELEMENT    AdditionalHeaderArray[1];
    ULONG                       AdditionalHeaderCount = 0;
    PSTR                        pBadCSeqHeaderValue = NULL;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ProcessRequest");
    
    pListEntry = m_IncomingTransactionList.Flink;
    
    // Go through all the current transactions to check if CSeq
    // matches.
    while (pListEntry != &m_IncomingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            INCOMING_TRANSACTION,
                                            m_ListEntry);
        
        if (pSipTransaction->GetCSeq() == pSipMsg->GetCSeq())
        {
            if (pSipTransaction->GetMethodId() == pSipMsg->GetMethodId() ||
                (pSipTransaction->GetMethodId() == SIP_METHOD_INVITE &&
                 pSipMsg->GetMethodId() == SIP_METHOD_ACK))
            {
                if (!pSipTransaction->IsTransactionDone())
                {
                    hr = pSipTransaction->ProcessRequest(pSipMsg,
                                                         pResponseSocket);
                }
                return hr;
            }
            else if (pSipMsg->GetMethodId() == SIP_METHOD_CANCEL)
            {
                // CANCEL has the same CSeq as the request it is canceling.
                hr = CreateIncomingTransaction(pSipMsg, pResponseSocket);
                return hr;
            }
            else
            {
                // Different request with an already existing CSeq
                // - Send 400.
                LOG((RTC_WARN,
                     "%s - Different request with an already existing "
                     "CSeq: %d - Method %d Sending 400",
                     __fxName, pSipMsg->GetCSeq(), pSipMsg->GetMethodId()));
                
                if (pSipMsg->GetMethodId() != SIP_METHOD_ACK)
                {
                    return CreateIncomingReqFailTransaction(
                               pSipMsg, pResponseSocket, 400
                               );
                }
            }
        }

        pListEntry = pListEntry->Flink;
    }

    // Check if this is a new CSeq
    if (pSipMsg->GetCSeq() <= m_HighestRemoteCSeq)
    {
        ULONG StatusCode;
        if (pSipMsg->GetMethodId() == SIP_METHOD_CANCEL)
        {
            // For cancel we send a transaction not present.
            StatusCode = 481;
        }
        else
        {
            StatusCode = 400;
        }
                    
        LOG((RTC_WARN,
             "%s - Stale CSeq m_HighestRemoteCSeq: %d"
             " msg CSeq: %d - Method %d Sending %d",
             __fxName, m_HighestRemoteCSeq, pSipMsg->GetCSeq(),
             pSipMsg->GetMethodId(), StatusCode));
                
        // This is a request with an old CSeq
        if (pSipMsg->GetMethodId() != SIP_METHOD_ACK)
        {
            if( pSipMsg->GetMethodId() == SIP_METHOD_NOTIFY )
            {
                hr = GetBadCSeqHeader( m_HighestRemoteCSeq,
                        &AdditionalHeaderArray[AdditionalHeaderCount] );

                if( hr != S_OK )
                {
                    LOG(( RTC_WARN, "%s - Failed to get Bad CSeq header", __fxName ));
                }
                else
                {
                    pBadCSeqHeaderValue = (&AdditionalHeaderArray[ AdditionalHeaderCount ]) -> HeaderValue;
                    AdditionalHeaderCount++;
                }
            }

            hr = CreateIncomingReqFailTransaction(
                       pSipMsg, 
                       pResponseSocket, 
                       StatusCode,
                       (AdditionalHeaderCount!=0) ? AdditionalHeaderArray:NULL,
                       AdditionalHeaderCount
                       );

            if( pBadCSeqHeaderValue != NULL )
            {
                delete pBadCSeqHeaderValue;
            }

            return hr;
        }
        return S_OK;
    }
    else 
    {
        // If it does not belong to any of the transactions
        // and is not an old CSeq,
        // we create a new transaction.
        hr = CreateIncomingTransaction(pSipMsg, pResponseSocket);
        return hr;
    }
}


HRESULT
SIP_MSG_PROCESSOR::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    // Find the transaction that the message belongs to.
    HRESULT                 hr = S_OK;
    LIST_ENTRY             *pListEntry;
    OUTGOING_TRANSACTION   *pSipTransaction;
    
    pListEntry = m_OutgoingTransactionList.Flink;

    while (pListEntry != &m_OutgoingTransactionList)
    {
        pSipTransaction = CONTAINING_RECORD(pListEntry,
                                            OUTGOING_TRANSACTION,
                                            m_ListEntry);
        ULONG MsgCSeq;
        SIP_METHOD_ENUM MsgCSeqMethodId;
        pSipMsg->GetCSeq(&MsgCSeq, &MsgCSeqMethodId);
        if (pSipTransaction->GetCSeq() == MsgCSeq &&
            pSipTransaction->GetMethodId() == MsgCSeqMethodId)
        {
            if (!pSipTransaction->IsTransactionDone())
            {
                hr = pSipTransaction->ProcessResponse(pSipMsg);
            }
            
            return hr;
        }
        pListEntry = pListEntry->Flink;
    }

    // If it does not belong to any of the transactions we just drop
    // the response ?
    return S_OK;
}


HRESULT
SIP_MSG_PROCESSOR::GetCredentialsFromUI(
    IN  PSTR  Realm,
    IN  ULONG RealmLen
    )
{
    HRESULT     hr;
    BSTR        bstrUsername = NULL;
    BSTR        bstrPassword = NULL;
    BSTR        bstrRealm    = NULL;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::GetCredentialsFromUI");
    
    hr = UTF8ToBstr(Realm, RealmLen, &bstrRealm);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - UTF8ToBstr(realm) failed %x",
             __fxName, hr));
        return hr;
    }

    if (GetUsername() != NULL)
    {
        hr = UTF8ToBstr(GetUsername(), GetUsernameLen(),
                        &bstrUsername);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s - UTF8ToBstr(Username) failed %x",
                 __fxName, hr));
            SysFreeString(bstrRealm);
            return hr;
        }
    }
    
    // Keep a reference till the call completes to make sure
    // that the SIP_CALL object is alive when the call
    // returns.
    MsgProcAddRef();
    
    hr = m_pSipStack ->GetCredentialsFromUI(
             &m_ProviderGuid,
             bstrRealm,
             &bstrUsername,
             &bstrPassword
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetCredentialsFromUI failed %x",
             __fxName, hr));
        SysFreeString(bstrRealm);
        if (bstrUsername != NULL)
        {
            SysFreeString(bstrUsername);
        }
        goto done;
    }
    
    // After returning from GetCredentialsFromUI() make sure that
    // the call is still alive. If call is disconnected do nothing.
    if (IsSessionDisconnected())
    {
        LOG((RTC_WARN, "%s - Call has been disconnected already",
             __fxName));
        hr = RTC_E_SIP_CALL_DISCONNECTED;
        SysFreeString(bstrUsername);
        SysFreeString(bstrPassword);
        SysFreeString(bstrRealm);
        goto done;
    }

    // Copy the credentials obtained from the UI to the call.
    hr = SetCredentials(bstrUsername, bstrPassword, bstrRealm);
    SysFreeString(bstrUsername);
    SysFreeString(bstrPassword);
    SysFreeString(bstrRealm);
    
done:
    
    MsgProcRelease();
    return hr;
}


HRESULT
SIP_MSG_PROCESSOR::GetCredentialsForRealm(
    IN  PSTR  Realm,
    IN  ULONG RealmLen
    )
{
    HRESULT     hr;
    BSTR        bstrUsername = NULL;
    BSTR        bstrPassword = NULL;
    BSTR        bstrRealm    = NULL;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::GetCredentialsForRealm");

    if (m_fCredentialsSet)
    {
        LOG((RTC_ERROR, "%s - Credentials already set previously",
             __fxName));
        return E_FAIL;
    }
    
    hr = UTF8ToBstr(Realm, RealmLen, &bstrRealm);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - UTF8ToBstr(realm) failed %x",
             __fxName, hr));
        return hr;
    }

    hr = m_pSipStack ->GetCredentialsForRealm(
             bstrRealm,
             &bstrUsername,
             &bstrPassword,
             &m_AuthProtocol
             );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - GetCredentialsForRealm failed %x",
             __fxName, hr));
        SysFreeString(bstrRealm);
        return hr;
    }
    
    // Copy the credentials obtained from the Core to the call.
    hr = SetCredentials(bstrUsername, bstrPassword, bstrRealm);
    SysFreeString(bstrUsername);
    SysFreeString(bstrPassword);
    SysFreeString(bstrRealm);

    return hr;
}


VOID
ConvertHexToBinary(  
    IN  PSTR    HexBuffer,
    IN  ULONG   HexBufferLen,
    IN  PSTR    BinaryBuffer,
    OUT ULONG  &BinayBufferLen
    )
{
    ULONG iIndex;

    //HexBufferLen is assumed to be an even number.

    for( iIndex= 0, BinayBufferLen=0; iIndex < HexBufferLen; iIndex++ )
    {
        BinaryBuffer[BinayBufferLen++] = 
            (HexBuffer[iIndex] << 4) & (HexBuffer[iIndex+1] );
        
        iIndex += 2;
    }
    
    BinaryBuffer[BinayBufferLen] = '\0';
}


HRESULT SIP_MSG_PROCESSOR::CreateHttpProxyProcessWindow(void)
{
    

    DWORD         Error;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::CreateHttpProxyProcessWindow");
   
    m_PrxyProcWndw = CreateWindow(
                           SIP_MSG_PROCESSOR_WINDOW_CLASS,
                           NULL,
                           WS_DISABLED,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           CW_USEDEFAULT,
                           NULL,           // No Parent
                           NULL,           // No menu handle
                           _Module.GetResourceInstance(),
                           NULL
                           );

    if (!m_PrxyProcWndw)
    {
        Error = GetLastError();
        LOG((RTC_ERROR, "%s failed 0x%x",__fxName,Error));
        return HRESULT_FROM_WIN32(Error);
    }
    LOG((RTC_TRACE,"%s exits with window %x",__fxName, m_PrxyProcWndw));
    return S_OK;
}

HRESULT SIP_MSG_PROCESSOR::DestroyHttpProxyProcessWindow(void)
{
    DWORD Error;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::DestroyHttpProxyProcessWindow");
    LOG((RTC_TRACE,"%s entered",__fxName));
    if (m_PrxyProcWndw != NULL)
    {
        if(!DestroyWindow(m_PrxyProcWndw)) 
        {
            Error = GetLastError();
            LOG((RTC_ERROR,"%s failed error %x",__fxName,Error));
            return HRESULT_FROM_WIN32(Error);
        }
        m_PrxyProcWndw = NULL;
    }
    LOG((RTC_TRACE,"%s exits",__fxName));
    return S_OK;
}

LRESULT WINAPI SIP_MSG_PROCESSOR::HttpProxyProcessWinProc(  
        IN  HWND    Window,
        IN  UINT    MessageID,
        IN  WPARAM  Parameter1,
        IN  LPARAM  Parameter2) 
{
    SIP_MSG_PROCESSOR *pProcessor;
    HttpProxyResolveContext *pHPContext;
    HttpProxyInfo *pHPInfo;
    HRESULT hr = S_OK;
    HRESULT NotifyHr = S_OK;
    SOCKADDR_IN sockin;
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::HttpProxyProcessWinProc");
    LOG((RTC_TRACE,"%s entered window %x message %x",__fxName, Window, MessageID));
    BOOL result;

    switch(MessageID ) {
    case WM_HttpProxy_PROCESS_SUCCESS_MESSAGE:

        LOG((RTC_TRACE,"%s receives WM_HttpProxy_PROCESS_SUCCESS_MESSAGE",
                    __fxName));
    
        pHPContext = (HttpProxyResolveContext*)Parameter2;
        ASSERT(pHPContext);
        pProcessor = pHPContext->pProcessor;
        ASSERT(pProcessor);

        pHPInfo = pHPContext->pHPInfo;
        ASSERT(pHPInfo);
        
        LOG((RTC_TRACE,"%s receives proxy IP %d.%d.%d.%d:%d",
                       __fxName,
                       NETORDER_BYTES0123(pHPInfo->ProxyIP),
                       ntohs(pHPInfo->ProxyPort)));

        sockin.sin_addr.s_addr = pHPInfo->ProxyIP;
        sockin.sin_family = AF_INET;
        sockin.sin_port = pHPInfo->ProxyPort;
        
        // we live in a single threaded world
        result = pProcessor->SetTunnel();
        
        hr = pProcessor->SetRequestDestination(&sockin);
        if (hr != S_OK) 
        {
            LOG((RTC_ERROR,"%s SetRequestDestination failed",__fxName));
            pProcessor->OnRequestSocketConnectComplete(hr);
        }
                
        hr = pProcessor->DestroyHttpProxyProcessWindow();
        if(hr != S_OK)
        {
            LOG((RTC_ERROR,"%s DestroyHttpProxyProcessWindow failed",__fxName));
        }
                  
        hr = pProcessor->ResolveHttpProxyCleanUp();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,"%s ResolveHttpProxyCleanUp failed",__fxName));
        }
    
        pProcessor->FreeHttpProxyContext();

        break;
    case WM_HttpProxy_PROCESS_FINAL_MESSAGE:
        
        LOG((RTC_TRACE,"%s receives WM_HttpProxy_PROCESS_FINAL_MESSAGE",
                    __fxName));
    
        pHPContext = (HttpProxyResolveContext*)Parameter2;
        ASSERT(pHPContext);
        pProcessor = pHPContext->pProcessor;
        ASSERT(pProcessor);

        hr = pProcessor->DestroyHttpProxyProcessWindow();
        if(hr != S_OK)
        {
            LOG((RTC_ERROR,"%s DestroyHttpProxyProcessWindow failed",__fxName));
        }
                  
        hr = pProcessor->ResolveHttpProxyCleanUp();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR,"%s ResolveHttpProxyCleanUp failed",__fxName));
        }

        if (!pHPContext->fTunnelSuccess)
            pProcessor->OnRequestSocketConnectComplete(RTC_E_SIP_SSL_TUNNEL_FAILED);
    
        pProcessor->FreeHttpProxyContext();
                  
        break;

    default:
        return DefWindowProc(Window,MessageID,Parameter1,Parameter2);
    
    }
    return hr;
}

VOID CALLBACK SIP_MSG_PROCESSOR::HttpProxyCallback(
    HINTERNET hInternet,
    DWORD_PTR dwHPContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    )
{
    BOOL                        bHttpProxyInfo;
    BOOL                        bPostMsg;
    HWND                        hWindow;
    SIP_MSG_PROCESSOR          *pProcessor;
    DWORD                       Error;
    HRESULT                     hr;
    HttpProxyResolveContext    *pHPContext;
    BOOL                        bInternetQuery;    
    INTERNET_DIAGNOSTIC_SOCKET_INFO  SocketInfo;
    DWORD                       dwSize;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::HttpProxyCallback");
    LOG((RTC_TRACE,"Entering callback %s %x",__fxName, dwInternetStatus));

    if ((dwInternetStatus != INTERNET_STATUS_REQUEST_COMPLETE) &&
        (dwInternetStatus != INTERNET_STATUS_SENDING_REQUEST))
    {
        LOG((RTC_TRACE, "%s do nothing", __fxName));
        return;
    }

    if (dwInternetStatus == INTERNET_STATUS_REQUEST_COMPLETE)
    {
        INTERNET_ASYNC_RESULT *pAsyncResult = (INTERNET_ASYNC_RESULT *)lpvStatusInformation;
        if (pAsyncResult->dwError == ERROR_INTERNET_OPERATION_CANCELLED)
        {
            LOG((RTC_TRACE, "%s AsyncResult is ERROR_INTERNET_OPERATION_CANCELLED %x, do nothing", 
                            __fxName, pAsyncResult->dwError));
            return;
        }

    }

    pHPContext =((HttpProxyResolveContext*)dwHPContext);   
    ASSERT(pHPContext);
    
    pProcessor = pHPContext->pProcessor;
    ASSERT(pProcessor);
        
    hWindow = pProcessor->GetHttpProxyProcessWindow();

    // only attempt to get the option query if we have not succeeded
    if (dwInternetStatus == INTERNET_STATUS_SENDING_REQUEST)
    {

        // try to get the proxy information every status
        
        dwSize = sizeof(SocketInfo);
        bInternetQuery = InternetQueryOption(pProcessor->m_hHttpRequest, 
            INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO, 
            (void *) &SocketInfo, 
            &dwSize);
        
        if(!bInternetQuery)
        {
            Error = GetLastError();
            LOG((RTC_ERROR, "%s unable to get proxy port Error: %x",__fxName, Error));
        }
        else 
        {
            // we get the proxy socket information from WinInet
            
            SOCKET s = SocketInfo.Socket;
            SOCKADDR_IN mySockAddr;
            int         mySockAddrLen = sizeof(mySockAddr);
            
            if (Error = getpeername(s,(SOCKADDR*)&mySockAddr,&mySockAddrLen) != 0)
            {
                Error = WSAGetLastError();
                LOG((RTC_ERROR,"%s cannot get sockaddr %x",__fxName,Error));
            }
            else
            {
                // we get sockaddr from the socket, we need to extract the IP addr and port
                
                LOG((RTC_TRACE,"%s get sockaddr %d.%d.%d.%d:%d",
                    __fxName,
                    PRINT_SOCKADDR(&mySockAddr)
                    ));
                pHPContext->pHPInfo->ProxyIP = mySockAddr.sin_addr.s_addr;
                
                if (mySockAddr.sin_port)
                    pHPContext->pHPInfo->ProxyPort = mySockAddr.sin_port;
                else 
                    pHPContext->pHPInfo->ProxyPort = htons(SIP_TUNNEL_DEFAULT_PORT);
                
                pHPContext->fTunnelSuccess = TRUE;
                
                // we post success message right away
                bPostMsg = PostMessage(hWindow,
                    WM_HttpProxy_PROCESS_SUCCESS_MESSAGE,
                    0,
                    (LPARAM)dwHPContext);
                Error = GetLastError();
                LOG((RTC_TRACE,"%s PostMessage result %x error %x",__fxName,bPostMsg, Error));
                
            }           
        }
    }
    else
    {
        // in state INTERNET_STATUS_REQUEST_COMPLETE
        INTERNET_ASYNC_RESULT *pAsyncResult = (INTERNET_ASYNC_RESULT *)lpvStatusInformation;
        LOG((RTC_TRACE, "%s AsyncResult is %x", __fxName, pAsyncResult->dwError));
      
        // we inform WinProc everything is done
        bPostMsg = PostMessage(hWindow,
            WM_HttpProxy_PROCESS_FINAL_MESSAGE,
            0,
            (LPARAM)dwHPContext);
        Error = GetLastError();
        LOG((RTC_TRACE,"%s PostMessage result %x error %x",__fxName,bPostMsg, Error));

            
    }
    LOG((RTC_TRACE,"%s exits",__fxName));
    return;
}

HRESULT
SIP_MSG_PROCESSOR::UseHttpProxy(
    IN PSTR pszHostName,
    IN USHORT usPort
    )
{

    HRESULT hr = S_OK;

    ENTER_FUNCTION("SIP_MSG_PROCESSOR::UseHttpProxy");

    LOG((RTC_TRACE, "%s try resolve HttpProxy",__fxName));

    hr = CreateHttpProxyProcessWindow();
    if (hr != S_OK) 
    {
        LOG((RTC_ERROR,"%s CreateHttpProxyProcessWindow failed",__fxName));
        goto createhttpproxywindow_failed;
    }
    ASSERT(m_PrxyProcWndw);

    hr = GetNewHttpProxyContextSetHostAndPort(pszHostName,usPort);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR,"%s GetNewHttpProxyContextSetHostAndPort failed",__fxName));
        goto resolvehttpproxy_failed;
    }

    m_OriginalReqDestAddr = m_RequestDestAddr;

    ASSERT(m_pHPContext);
    ASSERT(m_pHPContext->pHPInfo);
    ASSERT(m_pHPContext->pHPInfo->pszHostName);
   
    hr = ResolveHttpProxy();
    if (hr != S_OK) 
    {
        LOG((RTC_ERROR,"%s ResolveHttpProxy failed",__fxName));
        goto resolvehttpproxy_failed;
    }

    return hr;
resolvehttpproxy_failed:
    FreeHttpProxyContext();
    DestroyHttpProxyProcessWindow();
createhttpproxywindow_failed:
    
    return hr;
}

HRESULT
SIP_MSG_PROCESSOR::ResolveHttpProxy(void)
{
    HRESULT         hr = S_OK;
    DWORD           Error;

    INTERNET_STATUS_CALLBACK    dwInternetStatusCallback;
    
    BOOL            bResult;
    
    LPWSTR          lpwzHost = NULL;
    LPWSTR          lpwzVerb = NULL;

    
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ResolveHttpProxy");
    LOG((RTC_TRACE,"%s entered",__fxName));

    ASSERT(m_pHPContext);
    ASSERT(m_pHPContext->pHPInfo);
    ASSERT(m_pHPContext->pHPInfo->pszHostName);
    ASSERT(m_PrxyProcWndw);

    hr = UTF8ToUnicode(m_pHPContext->pHPInfo->pszHostName,
                       strlen(m_pHPContext->pHPInfo->pszHostName),
                       &lpwzHost);
    if(hr != S_OK) 
    {
        LOG((RTC_ERROR,"%s unable to convert strings",__fxName));
        goto othererror;
    }

    ASSERT(hr == S_OK);

    hr = UTF8ToUnicode("HEAD",5,&lpwzVerb);
    if(hr != S_OK) 
    {
        LOG((RTC_ERROR,"%s unable to convert strings",__fxName));
        goto othererror;
    }
    ASSERT(hr == S_OK);

    LOG((RTC_TRACE,"Entering %s with host %s",__fxName,
        m_pHPContext->pHPInfo->pszHostName));
    
    m_hInet = InternetOpen(NULL,
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            INTERNET_FLAG_ASYNC);
    if(!m_hInet) 
    {
        Error = GetLastError();
        LOG((RTC_ERROR,"%s InternetOpen fails %x",__fxName, Error));
        goto winineterror;
    }
    ASSERT(m_hInet);
    LOG((RTC_TRACE,"%s opens internet, handle %x",__fxName,m_hInet));

    dwInternetStatusCallback = 
        InternetSetStatusCallback(
            m_hInet,SIP_MSG_PROCESSOR::HttpProxyCallback);
    if(dwInternetStatusCallback == INTERNET_INVALID_STATUS_CALLBACK)
    {
        Error = GetLastError();
        LOG((RTC_ERROR,"%s unable to establish status callback function %x",__fxName, Error));
        goto winineterror;
    }
    ASSERT(dwInternetStatusCallback!=INTERNET_INVALID_STATUS_CALLBACK);
    LOG((RTC_TRACE,"%s sets internet callback %x",__fxName,dwInternetStatusCallback));
    
    m_hHttpSession = InternetConnect(m_hInet, 
                                    lpwzHost,
                                    INTERNET_DEFAULT_HTTPS_PORT,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    (DWORD)m_pHPContext);
    
    if(!m_hHttpSession) 
    {
        Error = GetLastError();
        LOG((RTC_ERROR,"%s InternetConnect fails %x",__fxName, Error));
        goto winineterror;
    }
    ASSERT(m_hHttpSession);
    LOG((RTC_TRACE,"%s connects HTTP session %x",__fxName,m_hHttpSession));

    m_hHttpRequest = HttpOpenRequest(m_hHttpSession,
                                    lpwzVerb,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_NO_CACHE_WRITE
                                    | INTERNET_FLAG_SECURE,
                                    (DWORD)m_pHPContext);
    
    if(!m_hHttpRequest) 
    {
        Error = GetLastError();
        LOG((RTC_ERROR,"%s HttpOpenRequest fails %x",__fxName, Error));
        goto winineterror;
    }
    ASSERT(m_hHttpRequest);
    LOG((RTC_TRACE,"%s opens HTTP request %x",__fxName,m_hHttpRequest));
    
    bResult = HttpSendRequest(m_hHttpRequest,NULL,0,NULL,0);
    
    // bResult should fail as this is an asynchronous call
    Error = GetLastError();
    LOG((RTC_TRACE,"%s sends request result %x error %x",
        __fxName, bResult, Error));
    

    free(lpwzHost);
    free(lpwzVerb);
    
    return hr;

winineterror:

    hr = HRESULT_FROM_WIN32(Error);
    ResolveHttpProxyCleanUp();

othererror:
    if (lpwzHost) free(lpwzHost);
    if (lpwzVerb) free(lpwzVerb);

    return hr;
}

HRESULT
SIP_MSG_PROCESSOR::ResolveHttpProxyCleanUp(void) 
{
    HRESULT hr = S_OK;
    DWORD Error;
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::ResolveHttpProxyCleanUp");
    LOG((RTC_TRACE,"%s entered",__fxName));

    if(m_hHttpRequest) {
        if(!InternetCloseHandle(m_hHttpRequest)) {
            Error = GetLastError();
            LOG((RTC_ERROR,"%s clean up hHttpRequest error %x",__fxName,Error));
            hr = HRESULT_FROM_WIN32(Error);
        }
        
        m_hHttpRequest = NULL;
    }
    
    if(m_hHttpSession) {
        if(!InternetCloseHandle(m_hHttpSession)) {
            Error = GetLastError();
            LOG((RTC_ERROR,"%s clean up hHttpSession error %x",__fxName,Error));
            hr = HRESULT_FROM_WIN32(Error);
        }

        m_hHttpSession = NULL;
    }
    
    if(m_hInet) {
        if(!InternetCloseHandle(m_hInet)) {
            Error = GetLastError();
            LOG((RTC_ERROR,"%s clean up hInet error %x",__fxName,Error));
            hr = HRESULT_FROM_WIN32(Error);
        }

        m_hInet = NULL;
    }
    LOG((RTC_TRACE,"%s exits returning %x",__fxName,hr));
    return hr;
}

HRESULT
SIP_MSG_PROCESSOR::GetNewHttpProxyContextSetHostAndPort(
    IN  PSTR    host,
    IN  USHORT  port
    )
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::GetNewHttpProxyContextSetHostAndPort");
    LOG((RTC_TRACE,"%s entered host %s port %d",__fxName,host,port)); 

    // Always get a new HttpProxyResolveContext for multiple service 
    // provide /w SSL. The existing HttpProxyResolveContext should be 
    // passed to HttpProxyCallback or HttpProxyProcessWinProc already.

    // This thread could retain this new HttpProxyResolveContext until it
    // passes to HttpProxyCallback or HttpProxyProcessWinProc.

    m_pHPContext = (HttpProxyResolveContext*) malloc(sizeof(HttpProxyResolveContext));
    LOG((RTC_TRACE,"%s has m_HPContext %x",__fxName,m_pHPContext));
    if(!m_pHPContext) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        return E_OUTOFMEMORY;
    }
    ASSERT(m_pHPContext);

    ZeroMemory(m_pHPContext,sizeof(HttpProxyResolveContext));
    MsgProcAddRef();    
    m_pHPContext->pProcessor = this;

    m_pHPContext->pHPInfo = (HttpProxyInfo*)malloc(sizeof(HttpProxyInfo));
    if(!m_pHPContext->pHPInfo) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        free(m_pHPContext);
        m_pHPContext = NULL;
        return E_OUTOFMEMORY;
    }
    
    m_pHPContext->pHPInfo->pszHostName = (PSTR)malloc(strlen(host)+1);
    if(!m_pHPContext->pHPInfo->pszHostName) 
    {
        LOG((RTC_ERROR,"%s unable to allocate memory",__fxName));
        free(m_pHPContext->pHPInfo);
        free(m_pHPContext);
        m_pHPContext = NULL;
        return E_OUTOFMEMORY;
    }
    ASSERT(m_pHPContext->pHPInfo->pszHostName);
    
    strcpy(m_pHPContext->pHPInfo->pszHostName,host);
    m_pHPContext->pHPInfo->usPort = port;
    m_pHPContext->pHPInfo->ProxyIP = 0;
    m_pHPContext->pHPInfo->ProxyPort = 0;

    m_pHPContext->fTunnelSuccess = FALSE;

    LOG((RTC_TRACE,"%s host now %s port now %d",__fxName,
        m_pHPContext->pHPInfo->pszHostName,
        m_pHPContext->pHPInfo->usPort));
    return S_OK;
}   

VOID
SIP_MSG_PROCESSOR::FreeHttpProxyContext()
{
    ENTER_FUNCTION("SIP_MSG_PROCESSOR::FreeHttpProxyContext");
    LOG((RTC_TRACE,"%s entered context: %x",__fxName, m_pHPContext));

    if (m_pHPContext == NULL)
    {
        return;
    }
    

    if(m_pHPContext->pHPInfo) 
    {
        if(m_pHPContext->pHPInfo->pszHostName) 
        {
            LOG((RTC_TRACE,"%s free context hostname",__fxName));
            free(m_pHPContext->pHPInfo->pszHostName);
        }
        free(m_pHPContext->pHPInfo);
    }
    
    LOG((RTC_TRACE,"%s free context",__fxName));
    
    free(m_pHPContext);
    m_pHPContext = NULL;
    MsgProcRelease();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\pintcall.cpp ===
#include "precomp.h"
#include "sipstack.h"
#include "sipcall.h"
#include "pintcall.h"
#include "presence.h"
#include "register.h"

#define IsPartyInDisconnectMode( State )    (   (State == SIP_PARTY_STATE_DISCONNECTED) ||      \
                                                (State == SIP_PARTY_STATE_REJECTED)     ||      \
                                                (State == SIP_PARTY_STATE_DISCONNECTING)||      \
                                                (State == SIP_PARTY_STATE_ERROR)        ||      \
                                                (State == SIP_PARTY_STATE_IDLE)         ||      \
                                                (State == SIP_PARTY_STATE_DISCONNECT_INITIATED) \
                                            )

static LONG lSessionID = 0;
///////////////////////////////////////////PINT_CALL functions/////////////////


inline HRESULT
HRESULT_FROM_PINT_STATUS_CODE(ULONG StatusCode)
{
    if ((HRESULT) StatusCode <= 0)
    {
        return (HRESULT) StatusCode;
    }
    else
    {
        return MAKE_HRESULT(SEVERITY_ERROR,
                            FACILITY_PINT_STATUS_CODE,
                            StatusCode);
    }
}


HRESULT
PINT_CALL::CreateIncomingNotifyTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("PINT_CALL::CreateIncomingNotifyTransaction");
    LOG(( RTC_TRACE, "%s - Entered : %lx", __fxName, hr ));
    
    // Create a new NOTIFY transaction.
    INCOMING_NOTIFY_TRANSACTION *pIncomingNotifyTransaction
        = new INCOMING_NOTIFY_TRANSACTION(  static_cast<SIP_MSG_PROCESSOR*> (this),
                                            pSipMsg->GetMethodId(),
                                            pSipMsg->GetCSeq(),
                                            TRUE );

    if (pIncomingNotifyTransaction == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pIncomingNotifyTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        pIncomingNotifyTransaction->OnTransactionDone();
        return hr;  
    }

    hr = pIncomingNotifyTransaction->ProcessRequest(pSipMsg, pResponseSocket );
    if (hr != S_OK)
    {
        //Should not delete the transaction. The transaction should handle the error
        //and delete itself
        return hr;            
    }

    // This should be called after creating the transaction as otherwise
    // the notification could result in the SIP_CALL getting deleted.
    // Update the state of each phone party and notify the app about that.

    //Process the state of the invloved phone parties.
    if( IsSessionDisconnected() == FALSE )
    {
        hr = ProcessPintNotifyMessage( pSipMsg );
    }

    LOG(( RTC_TRACE, "ProcessPintNotifyMessage returned : %lx", hr ));
    
    if (hr != S_OK)
    {
        return hr;            
    }

    LOG(( RTC_TRACE, "%s - Exited : %lx", __fxName, hr ));

    return S_OK;
}


// If this is PINT_CALL then all the telephone parties in
// state SIP_PARTY_STATE_CONNECT_INITIATED should be
// transferred to SIP_PARTY_STATE_REJECTED

HRESULT            
PINT_CALL::HandleInviteRejected(
    IN SIP_MESSAGE *pSipMsg
    )
{
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;
    PLIST_ENTRY         pLE;
    SIP_PARTY_STATE     dwState;
    HRESULT             hr = S_OK;
    ULONG               RejectedStatusCode = pSipMsg -> GetStatusCode();
    CHAR                pstrTemp[20];
    int                 retVal;
    PSTR                warnningHdr;
    ULONG               warningHdrLen;

    ENTER_FUNCTION("PINT_CALL::HandleInviteRejected");
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));

    for( pLE=m_PartyInfoList.Flink; pLE != &m_PartyInfoList; pLE = pLE->Flink )
    {
        pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );

        dwState = pPintPartyInfo -> State;

        if( ( dwState == SIP_PARTY_STATE_CONNECT_INITIATED ) ||
            ( pPintPartyInfo -> Status == PARTY_STATUS_RECEIVED_START ) )
        {
            pPintPartyInfo -> State = SIP_PARTY_STATE_REJECTED;

            // Extract the reason of rejection.
            hr = pSipMsg->GetSingleHeader(  SIP_HEADER_WARNING,
                                            &warnningHdr,
                                            &warningHdrLen );

            if( hr == S_OK )
            {
                hr = GetNextWord( &warnningHdr, pstrTemp, sizeof pstrTemp );

                if( hr == S_OK )
                {
                    // XXX TODO Does the Warning header contain a SIP status code
                    // or a PINT status code ?
                    retVal = atoi( pstrTemp );
                    RejectedStatusCode = (retVal !=0 )? retVal:RejectedStatusCode;
                }
            }
        }
        
        //Notify of change in the state
        if( dwState != pPintPartyInfo -> State )
        {
            hr = NotifyPartyStateChange(
                     pPintPartyInfo,
                     HRESULT_FROM_SIP_ERROR_STATUS_CODE(RejectedStatusCode) );
            if( hr != S_OK )
                break;
        }
    }

    LOG(( RTC_TRACE, "%s - Exited : %lx", __fxName, hr ));

    return hr;
}


VOID
PINT_CALL::ProcessPendingInvites()
{
    PLIST_ENTRY pLE;
    HRESULT     hr = S_OK;
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;

    if( m_fINVITEPending == TRUE )
    {
        m_fINVITEPending = FALSE;

        // If SIP call state is CONNECTED then send a reINVITE
        if( m_State == SIP_CALL_STATE_CONNECTED )
        {
            PSTR SDPBlob;

            hr = CreateSDPBlobForInvite( &SDPBlob );
            if( hr == S_OK )
            {
                hr = CreateOutgoingInviteTransaction(
                         FALSE,
                         FALSE,
                         NULL, 0,   // No Additional headers
                         SDPBlob, strlen(SDPBlob),
                         FALSE, 0);
                free( (PVOID) SDPBlob );
            }

            for(pLE = m_PartyInfoList.Flink; 
                pLE != &m_PartyInfoList; 
                pLE = pLE->Flink )
            {
                pPintPartyInfo =
                    CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );

                if( pPintPartyInfo -> State == SIP_PARTY_STATE_IDLE )
                {
                    if( hr != S_OK )
                    {
                        PLIST_ENTRY pLE = &pPintPartyInfo -> pListEntry;
                        RemovePartyFromList( pLE, pPintPartyInfo );
                    }
                    else
                    {
                        // change the state
                        pPintPartyInfo -> State = SIP_PARTY_STATE_CONNECT_INITIATED;
                        NotifyPartyStateChange( pPintPartyInfo, 0 );
                    }
                }
                else if( pPintPartyInfo -> State == SIP_PARTY_STATE_DISCONNECT_INITIATED )
                {
                    if( hr == S_OK )
                    {
                        NotifyPartyStateChange( pPintPartyInfo, 0 );

                        pPintPartyInfo -> fMarkedForRemove = TRUE;
                    }
                }
            }
        }
    }

    return;
}


HRESULT
PINT_CALL::SetRemote(
    IN  PSTR  ProxyAddress
    )
{
    PSTR                calledPartyURI;
    PINT_PARTY_INFO    *pPintPartyInfo;
    HRESULT             hr = S_OK;
    LIST_ENTRY         *pLE;
    PSTR                DestSipUrl;
    ULONG               DestSipUrlLen;

    ENTER_FUNCTION("PINT_CALL::SetRemote");
    
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));

    // The second structure should be remote party info.
    pLE = m_PartyInfoList.Flink->Flink;
    
    pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );
    calledPartyURI = pPintPartyInfo->URI;

    DestSipUrlLen = strlen(ProxyAddress) + strlen("sip:%s@%s;user=phone") +
        strlen(calledPartyURI);
    
    DestSipUrl = (PSTR) malloc(DestSipUrlLen + 10);

    if( DestSipUrl == NULL )
    {
        LOG((RTC_ERROR, "%s allocating DestSipUrl failed",
             __fxName)); 
        return E_OUTOFMEMORY;
    }

    // That's the CORRECT length
    DestSipUrlLen = sprintf( DestSipUrl, "sip:%s@%s;user=phone",
                              calledPartyURI,
                              ProxyAddress );

    hr = SetRemoteForOutgoingCall(DestSipUrl, DestSipUrlLen);

    free(DestSipUrl);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetRemoteForOutgoingCall failed %x",
             __fxName, hr));
        return hr;
    }

    LOG(( RTC_TRACE, "%s - Exited - %lx", __fxName, hr ));

    return hr;
}


PINT_CALL::PINT_CALL(
    IN  SIP_PROVIDER_ID    *pProviderId,
    IN  SIP_STACK          *pSipStack,
    IN  REDIRECT_CONTEXT   *pRedirectContext,
    OUT HRESULT            *phr

    ) : SIP_CALL(   pProviderId,
                    SIP_CALL_TYPE_PINT,
                    pSipStack,
                    pRedirectContext)
{
    LOG(( RTC_TRACE, "PINT_CALL() - Entered" ));

    *phr = S_OK;

    m_LocalHostNameLen = MAX_COMPUTERNAME_LENGTH;
    if( GetComputerNameA( m_LocalHostName, &m_LocalHostNameLen ) == FALSE )
    {
        strcpy( m_LocalHostName, DEFAULT_LOCALHOST_NAME );
        m_LocalHostNameLen = strlen( DEFAULT_LOCALHOST_NAME );
    }

    // Add the local phone number as a party in the party info list.
    PINT_PARTY_INFO *pPintPartyInfo = new PINT_PARTY_INFO;
            
    if( pPintPartyInfo == NULL )
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    pPintPartyInfo -> DisplayName = NULL;
    pPintPartyInfo -> DisplayNameLen = 0;

    pPintPartyInfo -> URI = NULL;
    pPintPartyInfo -> URILen = 0;

    pPintPartyInfo -> State = SIP_PARTY_STATE_IDLE;
    pPintPartyInfo -> RejectedStatusCode = 0;

    InitializeListHead(&m_PartyInfoList);
    InsertTailList( &m_PartyInfoList, &pPintPartyInfo -> pListEntry );
    m_PartyInfoListLen ++;

    m_fINVITEPending = FALSE;
    m_dwExpires = 3600;

    LOG(( RTC_TRACE, "PINT_CALL() - Exited - success" ));
}


HRESULT
PINT_CALL::CreateIncomingTransaction(
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    HRESULT hr;

    ENTER_FUNCTION("PINT_CALL::CreateIncomingTransaction");
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));
    
    switch(pSipMsg->GetMethodId())
    {
    case SIP_METHOD_BYE:
        hr = CreateIncomingByeTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
        
    case SIP_METHOD_CANCEL:
        hr = CreateIncomingCancelTransaction(pSipMsg, pResponseSocket);
        if (hr != S_OK)
            return hr;
        break;
    
    case SIP_METHOD_NOTIFY:

        hr = CreateIncomingNotifyTransaction(pSipMsg, pResponseSocket);
        
        if( hr != S_OK )
        {
            return hr;
        }

        break;

    case SIP_METHOD_OPTIONS:
        // Not implemented yet.
        ASSERT(FALSE);
        break;
        
    case SIP_METHOD_ACK:
        // send some error ?
        break;
        
    case SIP_METHOD_SUBSCRIBE:
    
        if( pSipMsg -> GetExpireTimeoutFromResponse( NULL, 0,
            SUBSCRIBE_DEFAULT_TIMER ) == 0 )
        {
            // UNSUB message.
            hr = CreateIncomingUnsubTransaction( pSipMsg, pResponseSocket );
            if( hr != S_OK )
            {
                return hr;
            }
                    
            break;
        }

        // fall through into defult

    default:
        // send some error ?
        hr = CreateIncomingReqFailTransaction(pSipMsg, pResponseSocket, 405);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s  Creating reqfail transaction failed %x",
                 __fxName, hr));
            return hr;
        }
        break;
    }
    
    LOG(( RTC_TRACE, "%s - Exited - SUCCESS", __fxName ));
    return S_OK;
}


HRESULT
PINT_CALL::CreateIncomingUnsubTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "PINT_CALL::CreateIncomingUnsubTransaction - Entered- %p",
        this ));
    
    INCOMING_UNSUB_TRANSACTION *pIncomingUnsubTransaction
        = new INCOMING_UNSUB_TRANSACTION(   static_cast <SIP_MSG_PROCESSOR *> (this),
                                            pSipMsg->GetMethodId(),
                                            pSipMsg->GetCSeq(),
                                            TRUE );

    if( pIncomingUnsubTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = pIncomingUnsubTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if( hr != S_OK )
    {
        goto error;
    }
    
    hr = pIncomingUnsubTransaction->ProcessRequest( pSipMsg, pResponseSocket );
    if( hr != S_OK )
    {
        //Should not delete the transaction. The transaction should handle the error
        //and delete itself
    }

    LOG(( RTC_TRACE, "PINT_CALL::CreateIncomingUnsubTransaction - Exited- %p",
        this ));
    return hr;

error:
    pIncomingUnsubTransaction->OnTransactionDone();
    return hr;
}


HRESULT
PINT_CALL::SetRequestURI(
    IN  PSTR ProxyAddress
    )
{
    HRESULT hr = S_OK;

    ENTER_FUNCTION("PINT_CALL:SetRequestURI");
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));
    
    //
    // The Request URI is: 'sip:R2C@sip.microsoft.com;tsp=sip.microsoft.com
    //

    m_RequestURILen = (2* strlen(ProxyAddress)) +
        //strlen( PINT_R2C_STRING ) +
        strlen( PINT_TSP_STRING ) + m_LocalURILen + 20;

    m_RequestURI = (PSTR) malloc( m_RequestURILen + 1 );

    if( m_RequestURI == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // exact length
        m_RequestURILen = sprintf( m_RequestURI, "%s%s%s%s", PINT_R2C_STRING,
                                   ProxyAddress, PINT_TSP_STRING, ProxyAddress );
    }
    
    LOG(( RTC_TRACE, "%s - Exited - %lx", __fxName, hr ));
    return hr;
}


HRESULT
PINT_CALL::StartOutgoingCall(
    IN  LPCOLESTR  LocalPhoneURI
    )
{
    HRESULT             hr = S_OK;
    PSTR                SDPBlob;
    LIST_ENTRY         *pLE;
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;
    
    ASSERT(m_State == SIP_CALL_STATE_IDLE);

    ENTER_FUNCTION("PINT_CALL::StartOutgoingCall");
    
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));

    hr = ResolveProxyAddressAndSetRequestDestination();
    if (hr != S_OK)
    {
                     
        LOG((RTC_ERROR,
             "%s ResolveProxyAddressAndSetRequestDestination failed : %x",
             __fxName));
        return hr;
    }

    hr = CreateSDPBlobForInvite( &SDPBlob );

    if( hr == S_OK )
    {
        // create outgoing INVITE transaction.
        hr = CreateOutgoingInviteTransaction(
                 FALSE,
                 TRUE,
                 NULL, 0,   // No Additional headers
                 SDPBlob, strlen(SDPBlob),
                 FALSE, 0);

        free( (PVOID) SDPBlob );

        if( hr == S_OK )
        {
            //change the state of all the parties to CONNECT_INITIATED
            for( pLE = m_PartyInfoList.Flink; pLE != &m_PartyInfoList; pLE = pLE->Flink )
            {
                pPintPartyInfo = 
                    CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );
        
                pPintPartyInfo -> State = SIP_PARTY_STATE_CONNECT_INITIATED;

                NotifyPartyStateChange( pPintPartyInfo, 0 );
            }
        }
    }

    LOG(( RTC_TRACE, "%s - Exited - %lx", __fxName, hr ));
    return hr;
}


//
// The string passed in is a number string. 
// This function increments the number.
//

void
IncrementText(
    IN  PSTR    pstrValue
    )
{
    DWORD dwLen = strlen( pstrValue ) - 1;

    if( (pstrValue[ dwLen] >= '0') && (pstrValue[ dwLen ] <= '8') )
    {
        pstrValue[ dwLen ] = pstrValue[ dwLen ] + 1;
    }
    else if( pstrValue[ dwLen ] == '9' )
    {
        pstrValue[ dwLen ] = '0';
        pstrValue[ dwLen+1 ] = '0';
        pstrValue[ dwLen+2 ] = NULL_CHAR;
    }
}


//
// Remove the party if present
//

HRESULT
PINT_CALL::RemoveParty(
    IN   LPOLESTR  PartyURI
    )
{
	LIST_ENTRY         *pLE;
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;
    PSTR                pstrPartyURI;
    DWORD               dwPartyURILen;
    HRESULT             hr = S_OK;

    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "RemoveParty() Entered" ));
    
    hr = UnicodeToUTF8( PartyURI, &pstrPartyURI, &dwPartyURILen );

    if( hr != S_OK )
    {
        return hr;
    }

    pLE = &m_PartyInfoList;

    // Never remove the first party.
    if( m_PartyInfoList.Flink -> Flink != &m_PartyInfoList )
    {
        pLE = m_PartyInfoList.Flink -> Flink;
    }
	
    while( pLE != &m_PartyInfoList )
    {
        pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );
        
        if( pPintPartyInfo -> URI == NULL )
        {
            RemovePartyFromList( pLE, pPintPartyInfo );
        }
        else if( strcmp( pPintPartyInfo -> URI, pstrPartyURI ) == 0 )
        {
            if( (m_State == SIP_CALL_STATE_IDLE) ||
                (IsPartyInDisconnectMode( pPintPartyInfo -> State ) ) )
            {
                LOG(( RTC_TRACE, "Party being removed is IDLE" ));
                
                RemovePartyFromList( pLE, pPintPartyInfo );
            }
            else
            {
                PSTR SDPBlob;
                    
                LOG(( RTC_TRACE, "Party being removed is not IDLE" ));
                
                pPintPartyInfo -> State = SIP_PARTY_STATE_DISCONNECT_INITIATED;
                
                //use higher SDP version to indicate a change.
                IncrementText( pPintPartyInfo -> SessionVersion );

                //change the stop time to a non-zero value
                strcpy( pPintPartyInfo -> RequestStopTime,
                    pPintPartyInfo -> RequestStartTime );

                IncrementText( pPintPartyInfo -> RequestStopTime );

                if( ProcessingInviteTransaction() )
                {
                    LOG(( RTC_TRACE, 
                        "INVITE transaction is pending-queuing remove request:%s,%s",
                        pPintPartyInfo->DisplayName, pPintPartyInfo->URI ));

                    m_fINVITEPending = TRUE;
                }
                else
                {
                    //send a 'stop now' request to drop this call leg                                
                    hr = CreateSDPBlobForInvite( &SDPBlob );
                    if( hr == S_OK )
                    {
                        hr = CreateOutgoingInviteTransaction(
                                 FALSE,
                                 FALSE,
                                 NULL, 0,   // No Additional headers
                                 SDPBlob, strlen(SDPBlob),
                                 FALSE, 0);
                        free( (PVOID) SDPBlob );
                
                        if( hr == S_OK )
                        {
                            NotifyPartyStateChange( pPintPartyInfo, 0 );

                            pPintPartyInfo -> fMarkedForRemove = TRUE;
                        }
                    }
                }
                            
                pLE = pLE->Flink;
            }
        }
        else
        {
            pLE = pLE->Flink;
        }
    }

    LOG(( RTC_TRACE, "RemoveParty() Exited" ));

    free( (PVOID) pstrPartyURI );
    pstrPartyURI = NULL;
    return hr;
}


HRESULT
PINT_CALL::AddParty(
    IN SIP_PARTY_INFO *pPartyInfo
    )
{
    HRESULT             hr;
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    PINT_PARTY_INFO    *pPintPartyInfo = new PINT_PARTY_INFO;

    LOG(( RTC_TRACE, "AddParty() Entered" ));
    
    if( pPintPartyInfo == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = UnicodeToUTF8( pPartyInfo -> DisplayName, 
        &pPintPartyInfo->DisplayName,
        &pPintPartyInfo->DisplayNameLen );

    if( hr != S_OK )
    {
        delete pPintPartyInfo;
        return hr;
    }

    hr = UnicodeToUTF8( pPartyInfo -> URI,
        &pPintPartyInfo->URI, &pPintPartyInfo->URILen );

    if( (hr != S_OK) || (pPintPartyInfo->URI == NULL) )
    {
        free( (PVOID) pPintPartyInfo->DisplayName );
        pPintPartyInfo->DisplayName = NULL;
        delete pPintPartyInfo;
        return hr;
    }

    pPintPartyInfo -> State = SIP_PARTY_STATE_IDLE;
    pPintPartyInfo -> RejectedStatusCode = 0;

    InsertTailList( &m_PartyInfoList, &pPintPartyInfo -> pListEntry );
    m_PartyInfoListLen ++;

    if( ProcessingInviteTransaction() )
    {
        LOG(( RTC_TRACE, "INVITE transaction is pending-queuing request:%s,%s",
                pPintPartyInfo->DisplayName, pPintPartyInfo->URI ));

        m_fINVITEPending = TRUE;
        return S_OK;
    }

    // If SIP call state is CONNECTED then send a reINVITE
    if( m_State == SIP_CALL_STATE_CONNECTED )
    {
        PSTR SDPBlob;

        hr = CreateSDPBlobForInvite( &SDPBlob );
        if( hr == S_OK )
        {
            hr = CreateOutgoingInviteTransaction(
                     FALSE,
                     FALSE,
                     NULL, 0,   // No Additional headers
                     SDPBlob, strlen(SDPBlob),
                     FALSE, 0);
            free( (PVOID) SDPBlob );
        }

        if( hr != S_OK )
        {
            PLIST_ENTRY pLE = &pPintPartyInfo -> pListEntry;
            RemovePartyFromList( pLE, pPintPartyInfo );
            return hr;
        }
        
        // change the state
        pPintPartyInfo -> State = SIP_PARTY_STATE_CONNECT_INITIATED;
        NotifyPartyStateChange( pPintPartyInfo, 0 );
    }

    LOG(( RTC_TRACE, "AddParty() Exited - SUCCESS" ));
    return S_OK;
}


HRESULT
PINT_CALL::GetAndStoreMsgBodyForInvite(
    IN  BOOL    IsFirstInvite,
    OUT PSTR   *pszMsgBody,
    OUT ULONG  *pMsgBodyLen
    )
{
    HRESULT hr;

    ENTER_FUNCTION("PINT_CALL::GetAndStoreMsgBodyForInvite");

    hr = CreateSDPBlobForInvite(pszMsgBody);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s CreateSDPBlobForInvite failed %x",
             __fxName, hr));
        return hr;
    }

    *pMsgBodyLen = strlen(*pszMsgBody);
    return S_OK;
}


HRESULT
PINT_CALL::CreateSDPBlobForSubscribe(
    IN  PSTR  * pSDPBlob )
{
    return CreateSDPBlobForInvite( pSDPBlob );
}


HRESULT
PINT_CALL::CreateSDPBlobForInvite(
    IN  PSTR  * pSDPBlob )
{
    HRESULT             hr = S_OK;
    LIST_ENTRY         *pLE = NULL;
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;
    DWORD               dwNextOffset = 0;
    DWORD               dwSDPBlobSize;

    ENTER_FUNCTION("PINT_CALL::CreateSDPBlobForInvite");
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));
    
    dwSDPBlobSize = m_PartyInfoListLen * 
        ( PINT_STATUS_DESCRIPTOR_SIZE + m_LocalURILen + m_LocalHostNameLen );
    
    *pSDPBlob = (PSTR) malloc( dwSDPBlobSize );
    if( *pSDPBlob == NULL )
    {
        return E_OUTOFMEMORY;
    }

	for( pLE = m_PartyInfoList.Flink; pLE != &m_PartyInfoList; pLE = pLE->Flink )
    {
        pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );
        
        if( pPintPartyInfo -> State != SIP_PARTY_STATE_REJECTED )
        {
            EncodePintStatusBlock( pPintPartyInfo,
                                   *pSDPBlob, 
                                   &dwNextOffset,
                                   m_LocalHostName );
        }

        ASSERT( dwSDPBlobSize > dwNextOffset );
    }

    LOG(( RTC_TRACE, "%s - Exited", __fxName ));
    return S_OK;
}


void
PINT_CALL::EncodePintStatusBlock( 
    IN      PINT_PARTY_INFO    *pPintPartyInfo, 
    IN      PSTR                SDPBlob, 
    IN  OUT DWORD              *pdwNextOffset,
    IN      PSTR                LocalHostName
    )
{
    DWORD   dwNextOffset = *pdwNextOffset;

    LOG(( RTC_TRACE, "EncodePintStatusBlock() Entered" ));
    
    //SDP version line
    strcpy( &SDPBlob[dwNextOffset], SDP_VERSION_TEXT );
    dwNextOffset += strlen( SDP_VERSION_TEXT );
    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;

    //origin header
    EncodeSDPOriginHeader( pPintPartyInfo, SDPBlob, &dwNextOffset,
        LocalHostName );
    
    //session header
    strcpy( &SDPBlob[dwNextOffset], SDP_SESSION_HEADER );
    dwNextOffset += SDP_HEADER_LEN;
    strcpy( &SDPBlob[ dwNextOffset ], PINT_SDP_SESSION );
    dwNextOffset += strlen( PINT_SDP_SESSION );
    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;

    //contact header
    EncodeSDPContactHeader( pPintPartyInfo, SDPBlob, &dwNextOffset );

    //time header
    EncodeSDPTimeHeader( pPintPartyInfo, SDPBlob, &dwNextOffset );

    //status header
    EncodeSDPStatusHeader( pPintPartyInfo, SDPBlob, &dwNextOffset );

    //media header
    EncodeSDPMediaHeader( pPintPartyInfo, SDPBlob, &dwNextOffset );

    //SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    //SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;
    SDPBlob[ dwNextOffset ] = NULL_CHAR;

    *pdwNextOffset = dwNextOffset;

    LOG(( RTC_TRACE, "EncodePintStatusBlock() Exited" ));
}


void
PINT_CALL::EncodeSDPOriginHeader(
    IN      PINT_PARTY_INFO    *pPintPartyInfo, 
    IN      PSTR                SDPBlob, 
    IN  OUT DWORD              *pdwNextOffset,
    IN      PSTR                LocalHostName
)
{
    DWORD   dwNextOffset = *pdwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPOriginHeader() Entered" ));
    
    //Origin line
    strcpy( &SDPBlob[dwNextOffset], SDP_ORIGIN_HEADER );
    dwNextOffset += SDP_HEADER_LEN;
    
    //skip 'sip:' from m_LocalURI
    strcpy( &SDPBlob[dwNextOffset], &m_LocalURI[4] );
    dwNextOffset += (m_LocalURILen - 4);
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;
    
    strcpy( &SDPBlob[dwNextOffset], pPintPartyInfo -> SessionID );
    dwNextOffset += strlen( pPintPartyInfo -> SessionID );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;

    strcpy( &SDPBlob[dwNextOffset], pPintPartyInfo -> SessionVersion );
    dwNextOffset += strlen( pPintPartyInfo -> SessionVersion );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;

    strcpy( &SDPBlob[dwNextOffset], LOCAL_USER_NETWORK_TYPE );
    dwNextOffset += strlen( LOCAL_USER_NETWORK_TYPE );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;

    strcpy( &SDPBlob[dwNextOffset], LOCAL_USER_ADDRESS_TYPE );
    dwNextOffset += strlen( LOCAL_USER_ADDRESS_TYPE );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;

    strcpy( &SDPBlob[dwNextOffset], LocalHostName );
    dwNextOffset += strlen( LocalHostName );

    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;
    
    *pdwNextOffset = dwNextOffset;    

    LOG(( RTC_TRACE, "EncodeSDPOriginHeader() Exited" ));
}


void
PINT_CALL::EncodeSDPContactHeader(
    IN      PINT_PARTY_INFO    *pPintPartyInfo, 
    IN      PSTR                SDPBlob, 
    IN  OUT DWORD              *pdwNextOffset
    )
{
    DWORD   dwNextOffset = *pdwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPContactHeader() Entered" ));
    
    //contact line
    strcpy( &SDPBlob[dwNextOffset], SDP_CONTACT_HEADER );
    dwNextOffset += SDP_HEADER_LEN;
    
    strcpy( &SDPBlob[dwNextOffset], PINT_NETWORK_TYPE );
    dwNextOffset += strlen( PINT_NETWORK_TYPE );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;
    
    strcpy( &SDPBlob[dwNextOffset], PINT_ADDR_TYPE );
    dwNextOffset += strlen( PINT_ADDR_TYPE );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;

    strcpy( &SDPBlob[dwNextOffset], pPintPartyInfo -> URI );
    dwNextOffset += strlen( pPintPartyInfo -> URI );

    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;
    *pdwNextOffset = dwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPContactHeader() Exited" ));
}


void
PINT_CALL::EncodeSDPTimeHeader(
    IN      PINT_PARTY_INFO    *pPintPartyInfo, 
    IN      PSTR                SDPBlob, 
    IN  OUT DWORD              *pdwNextOffset
    )
{
    DWORD   dwNextOffset = *pdwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPTimeHeader() Entered" ));
    
    //time line
    strcpy( &SDPBlob[dwNextOffset], SDP_TIME_HEADER );
    dwNextOffset += SDP_HEADER_LEN;
    
    strcpy( &SDPBlob[dwNextOffset], pPintPartyInfo -> RequestStartTime );
    dwNextOffset += strlen( pPintPartyInfo -> RequestStartTime  );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;
    
    strcpy( &SDPBlob[dwNextOffset], pPintPartyInfo -> RequestStopTime );
    dwNextOffset += strlen( pPintPartyInfo -> RequestStopTime );
    
    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;
    *pdwNextOffset = dwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPTimeHeader() Exited" ));
}


void
PINT_CALL::EncodeSDPStatusHeader(
    IN      PINT_PARTY_INFO    *pPintPartyInfo,
    IN      PSTR                SDPBlob,
    IN  OUT DWORD              *pdwNextOffset
    )
{
    DWORD   dwNextOffset = *pdwNextOffset;
    CHAR    statusBuffer[10];

    LOG(( RTC_TRACE, "EncodeSDPStatusHeader() Entered" ));
    
    if( pPintPartyInfo -> Status == PARTY_STATUS_IDLE )
    {
        strcpy( &SDPBlob[dwNextOffset], SDP_REQUEST_HEADER );
        dwNextOffset += strlen( SDP_REQUEST_HEADER );
            
        strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_REQUEST_START_TEXT );
        dwNextOffset += strlen( PARTY_STATUS_REQUEST_START_TEXT );
    }
    else if( pPintPartyInfo -> State == SIP_PARTY_STATE_DISCONNECT_INITIATED )
    {
        strcpy( &SDPBlob[dwNextOffset], SDP_REQUEST_HEADER );
        dwNextOffset += strlen( SDP_REQUEST_HEADER );
        
        strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_REQUEST_STOP_TEXT );
        dwNextOffset += strlen( PARTY_STATUS_REQUEST_STOP_TEXT );
    }
    else
    {
        strcpy( &SDPBlob[dwNextOffset], SDP_STATUS_HEADER );
        dwNextOffset += strlen( SDP_STATUS_HEADER );
    
        SDPBlob[ dwNextOffset++ ] = OPEN_PARENTH_CHAR;

        _itoa( pPintPartyInfo -> Status, statusBuffer, 10 );
        strcpy( &SDPBlob[ dwNextOffset ], statusBuffer );
        dwNextOffset += strlen( statusBuffer );

        SDPBlob[ dwNextOffset++ ] = CLOSE_PARENTH_CHAR;
        SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;

        //status line
        switch( pPintPartyInfo -> Status )
        {
        case PARTY_STATUS_PENDING:
            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_PENDING_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_PENDING_TEXT );
        
            break;

        case PARTY_STATUS_RECEIVED_START:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_RECEIVED_START_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_RECEIVED_START_TEXT );
        
            break;

        case PARTY_STATUS_STARTING:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_STARTING_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_STARTING_TEXT );
        
            break;

        case PARTY_STATUS_ANSWERED:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_ANSWERED_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_ANSWERED_TEXT );
        
            break;

        case PARTY_STATUS_RECEIVED_STOP:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_RECEIVED_STOP_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_RECEIVED_STOP_TEXT );
        
            break;

        case PARTY_STATUS_ENDING:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_ENDING_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_ENDING_TEXT );
        
            break;

        case PARTY_STATUS_DROPPED:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_DROPPED_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_DROPPED_TEXT );
        
            break;

        case PARTY_STATUS_RECEIVED_BYE:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_RECEIVED_BYE_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_RECEIVED_BYE_TEXT );
        
            break;
        case PARTY_STATUS_FAILED:

            strcpy( &SDPBlob[dwNextOffset], PARTY_STATUS_FAILED_TEXT );
            dwNextOffset += strlen( PARTY_STATUS_FAILED_TEXT );
        
            break;
        }
    }
    
    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;
        
    *pdwNextOffset = dwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPStatusHeader() Exited" ));
}


void
PINT_CALL::EncodeSDPMediaHeader(
    IN      PINT_PARTY_INFO    *pPintPartyInfo,
    IN      PSTR                SDPBlob,
    IN  OUT DWORD              *pdwNextOffset
    )
{
    DWORD   dwNextOffset = *pdwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPMediaHeader() Entered" ));
    
    //media line
    strcpy( &SDPBlob[dwNextOffset], SDP_MEDIA_HEADER );
    dwNextOffset += SDP_HEADER_LEN;
    
    strcpy( &SDPBlob[dwNextOffset], PINT_SDP_MEDIA );
    dwNextOffset += strlen( PINT_SDP_MEDIA );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;
    
    strcpy( &SDPBlob[dwNextOffset], PINT_SDP_MEDIAPORT );
    dwNextOffset += strlen( PINT_SDP_MEDIAPORT );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;
    
    strcpy( &SDPBlob[dwNextOffset], PINT_SDP_MEDIATRANSPORT );
    dwNextOffset += strlen( PINT_SDP_MEDIATRANSPORT );
    SDPBlob[ dwNextOffset++ ] = BLANK_CHAR;
    
    SDPBlob[ dwNextOffset++ ] = '-';
    SDPBlob[ dwNextOffset++ ] = RETURN_CHAR;
    SDPBlob[ dwNextOffset++ ] = NEWLINE_CHAR;

    *pdwNextOffset = dwNextOffset;

    LOG(( RTC_TRACE, "EncodeSDPMediaHeader() Exited" ));
}


HRESULT
PINT_CALL::ValidateCallStatusBlock( 
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "ValidateCallStatusBlock() Entered" ));
    
    if( strncmp(
        pPintCallStatus->mediaInfo.pstrMediaType, 
        PINT_MEDIA_TYPE, 
        strlen (PINT_MEDIA_TYPE) ) != 0 )
    {
        return E_FAIL;
    }

    if( strncmp( pPintCallStatus->partyContactInfo.pstrNetworkType,
        PINT_NETWORK_TYPE, 
        strlen (PINT_NETWORK_TYPE) ) != 0 )
    {
        return E_FAIL;
    }

    if( strncmp( pPintCallStatus->partyContactInfo.pstrAddressType,
        PINT_ADDR_TYPE, 
        strlen (PINT_ADDR_TYPE) ) != 0 )
    {
        return E_FAIL;
    }

    LOG(( RTC_TRACE, "ValidateCallStatusBlock() Exited - %lx", hr ));
    return hr;
}


HRESULT
PINT_CALL::ProcessPintNotifyMessage(
    IN SIP_MESSAGE  *pSipMsg
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwPintBlobLen = 0;
    DWORD       dwParsedLen = 0;
    PSTR        pPintSDPBlob = NULL;
    PSTR        pPintBlobLine = NULL, pBuffer = NULL;
    DWORD       dwLineLen = 0;
    LIST_ENTRY  PintCallStatusList;
    PLIST_ENTRY pLE;
    BOOLEAN     fSeenVersionLine = FALSE;

    PINT_SDP_ATTRIBUTE          sdpAttribute;
    PINTCALL_STATUS_DESRIPTION *pPintCallStatus = NULL;
    
    LOG(( RTC_TRACE, "ProcessPintNotifyMessage() Entered" ));
    
    if( pSipMsg -> MsgBody.Length == 0 )
    {
        //no state to update
        return hr;
    }

    pPintSDPBlob = pSipMsg -> MsgBody.GetString( pSipMsg->BaseBuffer );
    dwPintBlobLen = pSipMsg -> MsgBody.Length;

    pBuffer = pPintBlobLine = (PSTR) malloc( dwPintBlobLen );
    if( pPintBlobLine == NULL )
    {
        return E_OUTOFMEMORY;
    }

    InitializeListHead( &PintCallStatusList );
    
    dwParsedLen += SkipNewLines( &pPintSDPBlob, dwPintBlobLen - dwParsedLen );

    //
    // Create a list of SDP blocks, then validate each one of them for correct-
    // ness and pass on the correct ones to update the status of the phone party
    //
    
    while( dwParsedLen < dwPintBlobLen )
    {
        dwLineLen = GetNextLine( &pPintSDPBlob,
                    pPintBlobLine, dwPintBlobLen - dwParsedLen );

        dwParsedLen += dwLineLen + 1;
        
        if( dwLineLen == 0 )
        {
            //skip this line.
            continue;
        }

        sdpAttribute = GetSDPAttribute( &pPintBlobLine );

        if( (sdpAttribute != SDP_VERSION) && (fSeenVersionLine == FALSE) )
        {
            continue;
        }
        
        switch( sdpAttribute )
        {
        case SDP_VERSION:
            
            //new description block
            pPintCallStatus = new PINTCALL_STATUS_DESRIPTION;
            
            if( pPintCallStatus == NULL )
            {
                break;
            }
            
            ZeroMemory( (PVOID)pPintCallStatus, sizeof PINTCALL_STATUS_DESRIPTION );
            ParseSDPVersionLine( &pPintBlobLine, pPintCallStatus );

            InsertTailList( &PintCallStatusList, &pPintCallStatus->pListEntry );
            
            fSeenVersionLine = TRUE;

            break;

        case SDP_ORIGIN:

            ParseSDPOriginLine( &pPintBlobLine, pPintCallStatus );
            
            break;

        case SDP_SESSION:

            ParseSDPSessionLine( &pPintBlobLine, pPintCallStatus );
            break;

        case SDP_CONTACT:

            ParseSDPContactLine( &pPintBlobLine, pPintCallStatus );
            break;

        case SDP_TIME:

            ParseSDPTimeLine( &pPintBlobLine, pPintCallStatus );
            break;

        case SDP_STATUS_ATTRIBUTE:

            ParseSDPStatusLine( &pPintBlobLine, pPintCallStatus );
            break;

        case SDP_MEDIA_DESCR:

            ParseSDPMediaLine( &pPintBlobLine, pPintCallStatus );
            break;

        default:
            //skip this line.
            break;
        }

        if( pPintCallStatus == NULL )
        {
            //
            //exit while loop if memory alloc fails or the very first line
            //in the blob is not a 'v=' line.
            //
            break;
        }
    }

    while( !IsListEmpty( &PintCallStatusList ) )
    {
        pLE = RemoveHeadList( &PintCallStatusList );

        pPintCallStatus = CONTAINING_RECORD( pLE, 
            PINTCALL_STATUS_DESRIPTION, 
            pListEntry );

        hr = ValidateCallStatusBlock( pPintCallStatus );

        if( hr == S_OK )
        {
            hr = ChangePintCallStatus( pPintCallStatus );
        }

        delete pPintCallStatus;
        
        if( hr == RTC_E_SIP_CALL_DISCONNECTED )
        {
            LOG(( RTC_TRACE, 
                "Exitingg ProcessPintNotifyMessage since the call is dropped - %p:%lx",
                this, hr ));
            break;
        }
    }

    while( !IsListEmpty( &PintCallStatusList ) )
    {
        pLE = RemoveHeadList( &PintCallStatusList );

        pPintCallStatus = CONTAINING_RECORD( pLE, 
            PINTCALL_STATUS_DESRIPTION, 
            pListEntry );

        delete pPintCallStatus;
    }

    if( pBuffer != NULL )
    {
        free( pBuffer );
    }

    LOG(( RTC_TRACE, "ProcessPintNotifyMessage() Exited - %lx", hr ));
    return hr;
}


HRESULT
PINT_CALL::StatusBlockMatchingPartyInfo( 
    IN  PINT_PARTY_INFO            *pPintPartyInfo, 
    IN  PINTCALL_STATUS_DESRIPTION *pPintCallStatus 
    )
{
    if( strcmp( pPintPartyInfo -> URI,
        pPintCallStatus -> partyContactInfo.pstrPartyPhoneNumber ) == 0 )
    {
        if( strcmp( pPintCallStatus ->originInfo.pstrSessionID, 
            pPintPartyInfo -> SessionID ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//
// If there is an error in parsing the error code it is as good as receiving
// an unknown error code. So a 0 is returned.
//
ULONG
PINT_CALL::GetRejectedStatusCode(
    IN  PINTCALL_STATUS_DESRIPTION *pPintCallStatus
    )
{
    ULONG   RejectedStatusCode = 0;    // an unknown value by default

    //if status code of format (#) or (##) then copy # as rejectedstatuscode
    if( ( pPintCallStatus->pstrPartyStatusCode[0] == OPEN_PARENTH_CHAR ))
    {
        if(pPintCallStatus->pstrPartyStatusCode[2] == CLOSE_PARENTH_CHAR )
        {
            // it is (#)
            if( (pPintCallStatus->pstrPartyStatusCode[1] >= '5') &&
                (pPintCallStatus->pstrPartyStatusCode[1] <= '9') )
            {
                RejectedStatusCode = pPintCallStatus->pstrPartyStatusCode[1] - '0';
            }
        }
        else if(pPintCallStatus->pstrPartyStatusCode[3] == CLOSE_PARENTH_CHAR )
        {
            // it is (##)
            // allow 10-99
            if( (pPintCallStatus->pstrPartyStatusCode[1] >= '1') &&
                (pPintCallStatus->pstrPartyStatusCode[1] <= '9') &&
                (pPintCallStatus->pstrPartyStatusCode[2] >= '0') &&
                (pPintCallStatus->pstrPartyStatusCode[2] <= '9') )
            {
                RejectedStatusCode = pPintCallStatus->pstrPartyStatusCode[1] - '0';

                RejectedStatusCode *= 10;
                RejectedStatusCode += pPintCallStatus->pstrPartyStatusCode[2] - '0';
            }
        }
    }

    return RejectedStatusCode;
}

HRESULT
PINT_CALL::ChangePintCallStatus(
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT             hr = S_OK;
    LIST_ENTRY         *pLE = m_PartyInfoList.Flink;
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;
    ULONG               RejectedStatusCode = 0;
    SIP_PARTY_STATE     dwState;

    LOG(( RTC_TRACE, "ChangePintCallStatus() Entered" ));
    
    while( pLE != &m_PartyInfoList )
    {
        pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );

        // Locate the party phone number in the party list.
        if( StatusBlockMatchingPartyInfo( pPintPartyInfo, pPintCallStatus ) )
        {
            //save status change time to be sent out in next request.
            strcpy( pPintPartyInfo -> RequestStartTime,
                pPintCallStatus -> pstrStatusChangeTime );    
    
            //save session update version to be sent out in next request.
            strcpy( pPintPartyInfo -> SessionVersion,
                pPintCallStatus -> originInfo.pstrVersion  );
        
            dwState = pPintPartyInfo -> State;

            if( dwState == SIP_PARTY_STATE_DISCONNECTED )
            {
                pLE = pLE->Flink;
                continue;
            }

            if( !strcmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_PENDING_TEXT ) )
            {
                pPintPartyInfo -> State = SIP_PARTY_STATE_PENDING;
                pPintPartyInfo -> Status = PARTY_STATUS_PENDING;
            }
            else if( !strcmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_RECEIVED_START_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_RECEIVED_START;
                pPintPartyInfo -> State = SIP_PARTY_STATE_PENDING;
            }
            else if( !strcmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_STARTING_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_STARTING;
                pPintPartyInfo -> State = SIP_PARTY_STATE_CONNECTING;
            }
            else if( !strcmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_ANSWERED_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_ANSWERED;
                pPintPartyInfo -> State = SIP_PARTY_STATE_CONNECTED;
            }
            else if( !strcmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_RECEIVED_STOP_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_RECEIVED_STOP;
            }
            else if( !strcmp( pPintCallStatus-> pstrPartyStatus,
                    PARTY_STATUS_ENDING_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_ENDING;
                pPintPartyInfo -> State = SIP_PARTY_STATE_DISCONNECTING;
            }
            else if( !strcmp( pPintCallStatus->pstrPartyStatus, 
                    PARTY_STATUS_DROPPED_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_DROPPED;
                pPintPartyInfo -> State = SIP_PARTY_STATE_DISCONNECTED;
            }
            else if( !strcmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_RECEIVED_BYE_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_RECEIVED_BYE;
                pPintPartyInfo -> State = SIP_PARTY_STATE_DISCONNECTING;
            }
            else if( !_stricmp( pPintCallStatus->pstrPartyStatus,
                    PARTY_STATUS_FAILED_TEXT ) )
            {
                pPintPartyInfo -> Status = PARTY_STATUS_FAILED;
                pPintPartyInfo -> State = SIP_PARTY_STATE_REJECTED;

            }
            else
            {
                //ASSERT( 0 );
                LOG(( RTC_WARN, "Wrong status string passed by the PINT server: %s", 
                    pPintCallStatus->pstrPartyStatus ));
                
                pPintPartyInfo -> State = SIP_PARTY_STATE_ERROR;
            }

            if( dwState != pPintPartyInfo -> State )
            {
                RejectedStatusCode = GetRejectedStatusCode( pPintCallStatus );

                hr = NotifyPartyStateChange(
                         pPintPartyInfo,
                         HRESULT_FROM_PINT_STATUS_CODE( RejectedStatusCode ) );

                if( hr != S_OK )
                {
                    break;
                }

                // If the party URI is same as local phone URI and the
                // party state is disconnecd or rejected then drop the call.
                if( strcmp( m_LocalPhoneURI, pPintPartyInfo -> URI ) == 0 )
                {
                    if( (pPintPartyInfo -> State == SIP_PARTY_STATE_REJECTED) ||
                        (pPintPartyInfo -> State == SIP_PARTY_STATE_DISCONNECTED) )
                    {
                        hr = CleanupCallTypeSpecificState();
                        if (hr != S_OK)
                        {
                            LOG((RTC_ERROR, 
                                "CleanupCallTypeSpecificState failed %x", hr));
                        }                

                        //
                        // Notify should be the last thing you do. The 
                        // notification callback could block till some dialog 
                        // box is clicked and when it returns the transaction 
                        // and call could get deleted as well.
                        //

                        NotifyCallStateChange(
                            SIP_CALL_STATE_REJECTED,
                            HRESULT_FROM_PINT_STATUS_CODE(RejectedStatusCode),
                            NULL,
                            0 );
                        
                        LOG((   RTC_TRACE, 
                                "Exiting ChangePintCallStatus since the call is dropped - %p",
                                this ));
                        
                        return RTC_E_SIP_CALL_DISCONNECTED;
                    }
                }
            }
        }
        
        if( (pPintPartyInfo -> fMarkedForRemove == TRUE) &&
            (pPintPartyInfo -> State == SIP_PARTY_STATE_DISCONNECTED) )
        {
            RemovePartyFromList( pLE, pPintPartyInfo );
        }
        else
        {
            pLE = pLE->Flink;
        }
    }

    LOG(( RTC_TRACE, "ChangePintCallStatus() Exited" ));
    return hr;
}


HRESULT
PINT_CALL::GetExpiresHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement
    )
{
    pHeaderElement->HeaderId = SIP_HEADER_EXPIRES;
    
    pHeaderElement->HeaderValue = (PSTR) malloc( 10 );
    
    if( pHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    _ultoa( m_dwExpires, pHeaderElement->HeaderValue, 10 );

	pHeaderElement->HeaderValueLen = 
		strlen( pHeaderElement->HeaderValue );

    return S_OK;
}

PSTR
PartyStateToString(
    DWORD dwCallState
    )
{
    static PSTR apszCallStateStrings[] = {
                        "SIP_PARTY_STATE_IDLE",				
                        "SIP_PARTY_STATE_CONNECT_INITIATED",	
	
                        "SIP_PARTY_STATE_PENDING",			
                        "SIP_PARTY_STATE_CONNECTING",			
                        "SIP_PARTY_STATE_CONNECTED",			

                        "SIP_PARTY_STATE_REJECTED",			
	                    
                        "SIP_PARTY_STATE_DISCONNECT_INITIATED",
                        "SIP_PARTY_STATE_DISCONNECTING",		
                        "SIP_PARTY_STATE_DISCONNECTED",		

                        "SIP_PARTY_STATE_ERROR"
                        };

    // return corresponding string
    return apszCallStateStrings[dwCallState];
}


HRESULT
PINT_CALL::NotifyPartyStateChange( 
    IN  PINT_PARTY_INFO   * pPintPartyInfo,
    IN  HRESULT             RejectedStatusCode
    )
{
    HRESULT         hr = S_OK;
    SIP_PARTY_INFO  sipPartyInfo;

    LOG(( RTC_TRACE, "NotifyPartyStateChange() Entered" ));
    
    sipPartyInfo.PartyContactInfo = NULL;
    
    if( (pPintPartyInfo -> DisplayNameLen == 0) ||
        (pPintPartyInfo -> DisplayName[0] == NULL_CHAR)
      )
    {
        if( pPintPartyInfo -> DisplayName != NULL )
        {
            free( pPintPartyInfo -> DisplayName );
        }

        pPintPartyInfo -> DisplayNameLen = strlen( NO_DISPLAY_NAME );
        
        pPintPartyInfo -> DisplayName = 
            (PSTR) malloc( pPintPartyInfo -> DisplayNameLen + 1 );

        if( pPintPartyInfo -> DisplayName == NULL )
        {
            return E_OUTOFMEMORY;
        }

        strcpy( pPintPartyInfo -> DisplayName, NO_DISPLAY_NAME );
    }
    
    hr = UTF8ToUnicode( pPintPartyInfo -> DisplayName,
                            pPintPartyInfo -> DisplayNameLen,
                            &sipPartyInfo.DisplayName );
	if(hr != S_OK )
    {
        return hr;
    }
    
    hr = UTF8ToUnicode( pPintPartyInfo -> URI, 
                        pPintPartyInfo -> URILen,
                        &sipPartyInfo.URI );
    if( hr != S_OK )
    {
        free( sipPartyInfo. DisplayName );
        sipPartyInfo.DisplayName = NULL;
        return hr;
    }

	sipPartyInfo. State = pPintPartyInfo -> State;
    sipPartyInfo. StatusCode = RejectedStatusCode;

    if( m_pNotifyInterface )
    {
        m_pNotifyInterface -> AddRef();
        m_pNotifyInterface -> NotifyPartyChange( &sipPartyInfo );
        m_pNotifyInterface -> Release();

        LOG(( RTC_TRACE, "Party state change notified- %s:%s", 
            pPintPartyInfo -> URI, 
            PartyStateToString( sipPartyInfo.State) ));
    }
    else
    {
        LOG(( RTC_WARN,
            "m_pNotifyInterface is NULL in a NotifyPartyStateChange call" ));
        hr = E_FAIL;
    }
    
    free( sipPartyInfo. DisplayName );
    sipPartyInfo. DisplayName = NULL;
    free( sipPartyInfo. URI );
    sipPartyInfo. URI = NULL;

    LOG(( RTC_TRACE, "NotifyPartyStateChange() Exited" ));

    return hr;
}


void
PINT_CALL::ParseSDPVersionLine( 
    OUT PSTR                       * ppPintBlobLine, 
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;
    CHAR    pstrTemp[10];

    LOG(( RTC_TRACE, "ParseSDPVersionLine() Entered" ));
    
    hr = GetNextWord( ppPintBlobLine, pstrTemp, sizeof pstrTemp );
    
    if( hr == S_OK )
    {
        pPintCallStatus -> dwSDPVersion = atoi( pstrTemp );
    }

    LOG(( RTC_TRACE, "ParseSDPVersionLine() Exited - %lx", hr ));
    return;
}


HRESULT
PINT_CALL::ParseSDPOriginLine( 
    OUT PSTR * ppPintBlobLine, 
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "ParseSDPOriginLine() Entered" ));
    
    //skip the origin user
    hr = SkipNextWord( ppPintBlobLine );

    if( hr == S_OK )
    {
        //get the origin session id
        hr = GetNextWord( ppPintBlobLine, 
                pPintCallStatus ->originInfo.pstrSessionID, 
                sizeof pPintCallStatus ->originInfo.pstrSessionID );
    
        if( hr == S_OK )
        {
            //get the origin version
            hr = GetNextWord( ppPintBlobLine, 
                    pPintCallStatus ->originInfo.pstrVersion, 
                    sizeof pPintCallStatus ->originInfo.pstrVersion );
        }

        if( hr == S_OK )
        {
            //get the network type
            hr = GetNextWord( ppPintBlobLine, 
                    pPintCallStatus ->originInfo.pstrNetworkType, 
                    sizeof pPintCallStatus ->originInfo.pstrNetworkType );
        }
    }

    LOG(( RTC_TRACE, "ParseSDPOriginLine() Exited - %lx", hr ));
    
    return hr;
}


void
PINT_CALL::ParseSDPSessionLine( 
    PSTR * ppPintBlobLine, 
    PINTCALL_STATUS_DESRIPTION * pPintCallStatus )
{
    //no processing required. This might change later

    return;
}


void
PINT_CALL::ParseSDPContactLine( 
    OUT PSTR * ppPintBlobLine, 
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "ParseSDPContactLine() Entered" ));
    
    hr = GetNextWord( ppPintBlobLine, 
        pPintCallStatus ->partyContactInfo.pstrNetworkType, 
        sizeof pPintCallStatus ->partyContactInfo.pstrNetworkType );

    if( hr == S_OK )
    {
        hr = GetNextWord( ppPintBlobLine, 
            pPintCallStatus ->partyContactInfo.pstrAddressType, 
            sizeof pPintCallStatus ->partyContactInfo.pstrAddressType );

        if( hr == S_OK )
        {
            hr = GetNextWord( ppPintBlobLine, 
                pPintCallStatus ->partyContactInfo.pstrPartyPhoneNumber, 
                sizeof pPintCallStatus ->partyContactInfo.pstrPartyPhoneNumber);
        }
    }

    LOG(( RTC_TRACE, "ParseSDPContactLine() Exited" ));
    return;
}


void
PINT_CALL::ParseSDPTimeLine( 
    OUT PSTR * ppPintBlobLine, 
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "ParseSDPTimeLine() Entered" ));
    
    hr = GetNextWord( ppPintBlobLine,
        pPintCallStatus ->pstrStatusChangeTime, 
        sizeof pPintCallStatus ->originInfo.pstrVersion );

    LOG(( RTC_TRACE, "ParseSDPTimeLine() Exited - %lx", hr ));

    return;
}


void
PINT_CALL::ParseSDPMediaLine( 
    OUT PSTR * ppPintBlobLine,
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "ParseSDPMediaLine() Entered- %s", *ppPintBlobLine ));
    
    hr = GetNextWord( ppPintBlobLine,
        pPintCallStatus ->mediaInfo.pstrMediaType, 
        sizeof pPintCallStatus ->mediaInfo.pstrMediaType );

    if( hr == S_OK )
    {
        hr = SkipNextWord( ppPintBlobLine );

        if( hr == S_OK )
        {
            hr = GetNextWord( ppPintBlobLine,
                pPintCallStatus ->mediaInfo.pstrTransportType, 
                sizeof pPintCallStatus ->mediaInfo.pstrTransportType );
        }
    }

    LOG(( RTC_TRACE, "ParseSDPMediaLine() Exited - %lx", hr ));

    return;
}


void
PINT_CALL::ParseSDPStatusLine( 
    OUT PSTR * ppPintBlobLine, 
    IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "ParseSDPStatusLine() Entered" ));
    
    //skip the next word.
    hr = GetNextWord( ppPintBlobLine,
                pPintCallStatus -> pstrPartyStatusCode,
                sizeof pPintCallStatus -> pstrPartyStatusCode );
    
    if( hr == S_OK )
    {
        hr = GetNextWord( ppPintBlobLine,
                pPintCallStatus -> pstrPartyStatus,
                sizeof pPintCallStatus -> pstrPartyStatus );
    }

    LOG(( RTC_TRACE, "ParseSDPStatusLine() Exited - %lx", hr ));
    return;
}


//
// This function copies the next line from the block of data into the pLine
// array. The line is terminated by a \n or the end of the buffer.
// Returns the length of the line excluding \n.
//

DWORD
GetNextLine( 
    OUT PSTR * ppBlock,
    IN  PSTR   pLine,
    IN  DWORD  dwBlockLen
    )
{
    DWORD   iIndex =0;
    PSTR    pBlock = *ppBlock;

    LOG(( RTC_TRACE, "GetNextLine() Entered" ));
    
    *pLine = NULL_CHAR;

    while( iIndex < dwBlockLen )
    {
        if( *pBlock == NEWLINE_CHAR )
        {
            pBlock++;
            break;
        }
        else
        {
            pLine[iIndex] = *pBlock;
            pBlock++;
        }
        
        iIndex++;
    }

    pLine[iIndex] = NULL_CHAR;

    //skip '\r' as well
    if( pLine[iIndex-1] == RETURN_CHAR )
    {
         pLine[iIndex-1] = NULL_CHAR;
    }
    
    *ppBlock = pBlock;

    LOG(( RTC_TRACE, "GetNextLine() Exited: length: %d", iIndex ));

    return iIndex;
}


DWORD
SkipNewLines( 
    OUT PSTR * ppBlock,
    IN  DWORD dwBlockLen
    )
{
    DWORD   iIndex = 0;
    PSTR    pBlock = *ppBlock;

    LOG(( RTC_TRACE, "SkipNewLines() Entered" ));
    
    while( iIndex < dwBlockLen  )
    {
        if( (*pBlock == NEWLINE_CHAR) || (*pBlock == RETURN_CHAR) )
        {
            pBlock++;
        }
        else
        {
            break;
        }
        
        iIndex++;
    }

    *ppBlock = pBlock;

    LOG(( RTC_TRACE, "SkipNewLines() Exited" ));
    return iIndex;
}


HRESULT
SkipNextWord( 
    OUT PSTR * ppBlock
    )
{
    CHAR pstrTemp[10];

    return GetNextWord( ppBlock, pstrTemp, sizeof pstrTemp );
}


PINT_SDP_ATTRIBUTE
PINT_CALL::GetSDPAttribute( 
    OUT PSTR * ppLine 
    )
{
    PINT_SDP_ATTRIBUTE sdpAttribute;
    PSTR pLine = *ppLine;

    LOG(( RTC_TRACE, "GetSDPAttribute() Entered" ));
    
    if( (pLine[0] == NULL_CHAR) || (pLine[1] != '=') )
    {
        return SDP_ATTRIBUTE_ERROR;
    }

    switch( *pLine )
    {
    case 'v':

        sdpAttribute = SDP_VERSION;
        break;
    
    case 'o':

        sdpAttribute = SDP_ORIGIN;
        break;

    case 's':

        sdpAttribute = SDP_SESSION;
        break;

    case 'c':

        sdpAttribute = SDP_CONTACT;
        break;

    case 't':

        sdpAttribute = SDP_TIME;
        break;

    case 'a':

        if( strncmp( &pLine[2], STATUS_HEADER_TEXT,
                strlen( STATUS_HEADER_TEXT ) ) == 0 )
        {
            sdpAttribute = SDP_STATUS_ATTRIBUTE;

            //skip 'status:'
            pLine += strlen( STATUS_HEADER_TEXT );
        }
        else
        {
            sdpAttribute = SDP_UNKNOWN;
        }

        break;

    case 'm':

        sdpAttribute = SDP_MEDIA_DESCR;
        break;

    default:

        sdpAttribute = SDP_UNKNOWN;
        break;
    }

    //skip 'v='
    *ppLine = pLine + SIP_ATTRIBUTE_LEN;

    LOG(( RTC_TRACE, "GetSDPAttribute() Exited" ));
    return sdpAttribute;
}


HRESULT
PINT_CALL::CleanupCallTypeSpecificState()
{
    LIST_ENTRY * pLE;
    PINT_PARTY_INFO    *pPintPartyInfo = NULL;

    ENTER_FUNCTION("PINT_CALL::CleanupCallTypeSpecificState");
    LOG(( RTC_TRACE, "%s Entered", __fxName ));

    for( pLE = m_PartyInfoList.Flink; pLE != &m_PartyInfoList; )
    {
        pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );

        RemovePartyFromList( pLE, pPintPartyInfo );
    }

    LOG(( RTC_TRACE, "%s Exited", __fxName ));
    return S_OK;
}


VOID
PINT_CALL::RemovePartyFromList(
    OUT PLIST_ENTRY        &pLE,
    IN  PINT_PARTY_INFO    *pPintPartyInfo
    )
{
    RemoveEntryList( pLE );
    m_PartyInfoListLen --;

    pLE = pLE->Flink;
    
    if( pPintPartyInfo -> DisplayName != NULL )
    {
        free( (PVOID) pPintPartyInfo -> DisplayName );
        pPintPartyInfo -> DisplayName = NULL;
    }

    if( pPintPartyInfo -> URI != NULL )
    {
        free( (PVOID) pPintPartyInfo -> URI );
        pPintPartyInfo -> URI = NULL;
    }

    delete pPintPartyInfo;
}


HRESULT
PINT_CALL::CreateOutgoingUnsubTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ULONG                       dwNoOfHeaders
    )
{
    HRESULT hr;
    OUTGOING_UNSUB_TRANSACTION *pOutgoingUnsubTransaction;
    SIP_HEADER_ARRAY_ELEMENT    HeaderElementArray[2];
    DWORD                       dwNoOfHeader = 0;
    SIP_HEADER_ARRAY_ELEMENT   *ExpHeaderElement;

    ENTER_FUNCTION("SIP_CALL::CreateOutgoingUnsubTransaction");
    
    LOG(( RTC_TRACE, "%s - Entered", __fxName ));

    ExpHeaderElement = &HeaderElementArray[0];

    ExpHeaderElement->HeaderId = SIP_HEADER_EXPIRES;
    ExpHeaderElement->HeaderValueLen = strlen( UNSUB_EXPIRES_HEADER_TEXT );
    ExpHeaderElement->HeaderValue =
            (PSTR)malloc( ExpHeaderElement->HeaderValueLen + 1 );

    if( ExpHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    strcpy( ExpHeaderElement->HeaderValue, UNSUB_EXPIRES_HEADER_TEXT );
    dwNoOfHeader++;

    if (pAuthHeaderElement != NULL)
    {
        HeaderElementArray[dwNoOfHeader] = *pAuthHeaderElement;
        dwNoOfHeader++;
    }
    
    pOutgoingUnsubTransaction = 
        new OUTGOING_UNSUB_TRANSACTION(
                static_cast<SIP_MSG_PROCESSOR*>(this),
                SIP_METHOD_SUBSCRIBE,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                SIP_MSG_PROC_TYPE_PINT_CALL );
    
    if( pOutgoingUnsubTransaction == NULL )
    {
        free( ExpHeaderElement->HeaderValue );
        return E_OUTOFMEMORY;
    }

    hr = pOutgoingUnsubTransaction -> CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP,
             HeaderElementArray, dwNoOfHeader,
             NULL, 0, //No Msg Body
             NULL, 0 // No content Type
             );
        
    free( ExpHeaderElement->HeaderValue );    
    
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "%s - CheckRequestSocketAndSendRequestMsg failed %x", __fxName, hr));
        pOutgoingUnsubTransaction->OnTransactionDone();
        return hr;
    }

    LOG(( RTC_TRACE, "%s Exited - SUCCESS", __fxName ));

    return S_OK;
}


HRESULT
PINT_CALL::CreateOutgoingSubscribeTransaction(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ULONG                       ulNoOfHeaders
    )
{
    HRESULT                         hr;
    DWORD                           dwNoOfHeaders = 0;
    SIP_HEADER_ARRAY_ELEMENT        HeaderArray[2];
    SIP_HEADER_ARRAY_ELEMENT       *pExpiresHeader = NULL;
    OUTGOING_SUBSCRIBE_TRANSACTION *pOutgoingSubscribeTransaction;
    PSTR                            SDPBlob = NULL;
    
    ENTER_FUNCTION("PINT_CALL::CreateOutgoingSubscribeTransaction");

    LOG((RTC_TRACE, "%s - enter", __fxName));
    
    pOutgoingSubscribeTransaction =
        new OUTGOING_SUBSCRIBE_TRANSACTION(
                this, SIP_METHOD_SUBSCRIBE,
                GetNewCSeqForRequest(),
                AuthHeaderSent, TRUE, TRUE
                );
    
    if (pOutgoingSubscribeTransaction == NULL)
    {
        LOG((RTC_ERROR, "%s allocating pOutgoingSubscribeTransaction failed",
             __fxName));
        return E_OUTOFMEMORY;
    }
    
    hr = GetExpiresHeader( &HeaderArray[dwNoOfHeaders] );
    if( hr == S_OK )
    {
        pExpiresHeader = &HeaderArray[dwNoOfHeaders];
        dwNoOfHeaders++;
    }

    if( pAuthHeaderElement != NULL )
    {
        HeaderArray[dwNoOfHeaders] = *pAuthHeaderElement;
        dwNoOfHeaders++;
    }


    //send out a SUBSCRIBE request
    hr = CreateSDPBlobForSubscribe( &SDPBlob );
    if( hr == S_OK )
    {
        hr = pOutgoingSubscribeTransaction->CheckRequestSocketAndSendRequestMsg(
                (m_Transport == SIP_TRANSPORT_UDP) ?
                SIP_TIMER_RETRY_INTERVAL_T1 :
                SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP,
                HeaderArray, dwNoOfHeaders,
                SDPBlob, strlen( SDPBlob ),
                SIP_CONTENT_TYPE_SDP_TEXT,
                sizeof(SIP_CONTENT_TYPE_SDP_TEXT)-1
                );

        free( SDPBlob );
    }
    
    if( pExpiresHeader != NULL )
    {
        free( (PVOID) pExpiresHeader->HeaderValue );
    }
    
    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "%s - CheckRequestSocketAndSendRequestMsg failed %x",
            __fxName, hr ));
        pOutgoingSubscribeTransaction->OnTransactionDone();
        return hr;
    }

    LOG(( RTC_TRACE, "%s - Exited - SUCCESS", __fxName ));
    return S_OK;
}


//RTP call specific functions
STDMETHODIMP 
PINT_CALL::StartStream(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie        
        )
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}

                     
STDMETHODIMP
PINT_CALL::StopStream(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie        
        )
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}


//
// No incoming INVITE transaction. So not required.
//

HRESULT
PINT_CALL::Accept()
{
    ASSERT(FALSE);
    return E_NOTIMPL;

}


HRESULT
PINT_CALL::Reject(
    IN  SIP_STATUS_CODE StatusCode
    )
{
    ASSERT(FALSE);
    return E_NOTIMPL;

}



////////////////OUTGOING SUBSCRIBE TRANSACTION/////////////////////////////////


OUTGOING_SUBSCRIBE_TRANSACTION::OUTGOING_SUBSCRIBE_TRANSACTION(
    IN SIP_MSG_PROCESSOR   *pSipMsgProc,
    IN SIP_METHOD_ENUM      MethodId,
    IN ULONG                CSeq,
    IN BOOL                 AuthHeaderSent,
    IN BOOL                 fIsSipCall,
    IN BOOL                 fIsFirstSubscribe
    ) :
    OUTGOING_TRANSACTION(pSipMsgProc, MethodId, CSeq, AuthHeaderSent)
{
    LOG(( RTC_TRACE, "OUTGOING_SUBSCRIBE_TRANSACTION:%p created", this ));

    if( fIsSipCall == TRUE )
    {
        m_pPintCall = static_cast <PINT_CALL*> (pSipMsgProc);
        m_pSipBuddy = NULL;
    }
    else
    {
        m_pPintCall = NULL;
        m_pSipBuddy = static_cast <CSIPBuddy*> (pSipMsgProc);
    }
        
    m_fIsFirstSubscribe = fIsFirstSubscribe;
    m_fIsSipCall = fIsSipCall;
}


OUTGOING_SUBSCRIBE_TRANSACTION::~OUTGOING_SUBSCRIBE_TRANSACTION()
{
    // XXX When should we actually set this to NULL ?

    LOG(( RTC_TRACE, "OUTGOING_SUBSCRIBE_TRANSACTION:%p deleted", this ));
}


HRESULT
OUTGOING_SUBSCRIBE_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    LOG(( RTC_TRACE,
         "OUTGOING_SUBSCRIBE_TRANSACTION::ProcessProvisionalResponse()" ));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;

        // We have to deal with 183 responses here.
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_INTERVAL_AFTER_PROV_RESPONSE_RCVD);
        if (hr != S_OK)
            return hr;
    }

    // Ignore the Provisional response if a final response
    // has already been received.

    return S_OK; 
}


HRESULT
OUTGOING_SUBSCRIBE_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr = S_OK;
    PSTR    ToHeader;
    ULONG   ToHeaderLen;
    BOOL    fDelete = TRUE;

    ENTER_FUNCTION( "OUTGOING_SUBSCRIBE_TRANSACTION::ProcessFinalResponse" );
    
    if( m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD )
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;
        
        // Do not process the response if already session disconnected.
        if( (m_fIsSipCall == TRUE && m_pPintCall -> IsSessionDisconnected()) ||
            (m_fIsSipCall == FALSE && m_pSipBuddy -> IsSessionDisconnected())
          )
        {
            TransactionRelease();
            return S_OK;
        }

        if (IsSuccessfulResponse(pSipMsg))
        {
            LOG((RTC_TRACE, "%s: Processing 200", __fxName));
            
            if( m_fIsSipCall )
            {
                m_pPintCall -> SetSubscribeEnabled( TRUE );
            }
            else
            {
                m_pSipBuddy -> HandleBuddySuccessfulResponse( pSipMsg );
            }
        }
        else if( IsAuthRequiredResponse(pSipMsg) )
        {
            hr = ProcessAuthRequiredResponse( pSipMsg, fDelete );
        }
        else if( IsRedirectResponse( pSipMsg ) )
        {
            if( m_fIsSipCall == FALSE )
            {
                ProcessRedirectResponse( pSipMsg );
            }
        }
        else
        {
            ProcessFailureResponse( pSipMsg );
        }

        if( fDelete )
        {
            TransactionRelease();
        }
    }

    return hr;
}


HRESULT
OUTGOING_SUBSCRIBE_TRANSACTION::ProcessAuthRequiredResponse(
    IN  SIP_MESSAGE *pSipMsg,
    OUT BOOL        &fDelete
    )
{
    HRESULT                     hr;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;
    REGISTER_CONTEXT           *pRegisterContext;

    ENTER_FUNCTION("OUTGOING_SUBSCRIBE_TRANSACTION::ProcessAuthRequiredResponse");

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        
        ProcessFailureResponse( pSipMsg );
        
        goto done;
    }

    if( m_fIsSipCall )
    {
        m_pPintCall -> CreateOutgoingSubscribeTransaction( TRUE, 
            &SipHdrElement, 1 );
    }
    else
    {
        // This subascription has been rejected explicitly.
        m_pSipBuddy->CreateOutgoingSubscribe(   m_fIsFirstSubscribe, 
                                                TRUE, 
                                                &SipHdrElement, 
                                                1 );
    }

    free(SipHdrElement.HeaderValue);
    
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - CreateOutgoingByeTransaction failed %x",
             __fxName, hr));
        goto done;
    }

    hr = S_OK;

done:

    TransactionRelease();
    return hr;

}


HRESULT
OUTGOING_SUBSCRIBE_TRANSACTION::ProcessFailureResponse(
    SIP_MESSAGE    *pSipMsg
    )
{
    LOG(( RTC_TRACE, "Processing non-200 StatusCode: %d",
         pSipMsg->Response.StatusCode ));

    if( m_fIsSipCall )
    {
        m_pPintCall -> SetSubscribeEnabled( FALSE );
    }
    else
    {
        // This subascription has been rejected explicitly.
        m_pSipBuddy -> BuddySubscriptionRejected( pSipMsg );
    }

    return S_OK;
}


HRESULT
OUTGOING_SUBSCRIBE_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


HRESULT
OUTGOING_SUBSCRIBE_TRANSACTION::ProcessRedirectResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ENTER_FUNCTION( "OUTGOING_SUBSCRIBE_TRANSACTION::ProcessRedirectResponse" );

    LOG(( RTC_ERROR, "%s-Enter", __fxName ));

    // 380 is also a failure from our point of view.
    // We don't handle redirects for refreshes.
    // We don't support redirect from a TLS session.
    if( pSipMsg->GetStatusCode() == 380 || !m_fIsFirstSubscribe ||
        m_pSipMsgProc->GetTransport() == SIP_TRANSPORT_SSL)
    {
        return ProcessFailureResponse(pSipMsg);
    }

    hr = m_pSipBuddy -> ProcessRedirect(pSipMsg);
    
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "%s  ProcessRedirect failed %x",
             __fxName, hr));

        if( m_fIsFirstSubscribe )
        {
            m_pSipBuddy->InitiateBuddyTerminationOnError( hr );
        }
        return hr;
    }

    return S_OK;
}


BOOL
OUTGOING_SUBSCRIBE_TRANSACTION::MaxRetransmitsDone()
{
    if( m_fIsSipCall )
    {
        return (m_pPintCall->GetTransport() != SIP_TRANSPORT_UDP ||
                m_NumRetries >= 7);
    }
    else
    {
        return (m_pSipBuddy->GetTransport() != SIP_TRANSPORT_UDP ||
                m_NumRetries >= 7);
    }
}


VOID
OUTGOING_SUBSCRIBE_TRANSACTION::OnTimerExpire()
{
    HRESULT     hr;
    CSIPBuddy  *pSipBuddy;
    
    //If the session is already dead kill the transaction
    if( (m_fIsSipCall == TRUE && m_pPintCall -> IsSessionDisconnected()) ||
        (m_fIsSipCall == FALSE && m_pSipBuddy -> IsSessionDisconnected())
      )
    {
        OnTransactionDone();
        return;
    }

    switch (m_State)
    {
    case OUTGOING_TRANS_REQUEST_SENT:
        // Retransmit the request
        if( MaxRetransmitsDone() )
        {
            LOG((RTC_ERROR,
                 "MaxRetransmits for request Done terminating call" ));
            
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "retransmitting request m_NumRetries : %d", 
                m_NumRetries ));
            hr = RetransmitRequest();
            if (hr != S_OK)
            {
                goto error;
            }
            else
            {
                m_TimerValue *= 2;
                hr = StartTimer(m_TimerValue);
                if (hr != S_OK)
                {
                    goto error;
                }
            }
        }
        break;

    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // We haven't received the final response within the
        // timeout. Terminate the transaction and call.
        LOG((RTC_ERROR,
             "Received 1xx but didn't receive final response terminating call" ));
            
        goto error;
        break;

    // No timers in the following states
    case OUTGOING_TRANS_INIT:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

error:
    if( m_fIsSipCall == TRUE )
    {
        OnTransactionDone();
    }
    else
    {
        pSipBuddy = m_pSipBuddy;
        pSipBuddy->AddRef();
    
        // Note that deleting the transaction could result in the SIP_CALL
        // being deleted if this is the last transaction and call was
        // previously terminated.
        OnTransactionDone();

        pSipBuddy->InitiateBuddyTerminationOnError( RTC_E_SIP_TIMEOUT );
    
        pSipBuddy->Release();
    }
}

VOID
OUTGOING_SUBSCRIBE_TRANSACTION::TerminateTransactionOnError(
    IN HRESULT      hr
    )
{
    if( m_fIsSipCall == FALSE )
    {
        DeleteTransactionAndTerminateBuddyIfFirstSubscribe( hr );
    }
}


VOID
OUTGOING_SUBSCRIBE_TRANSACTION::DeleteTransactionAndTerminateBuddyIfFirstSubscribe(
    IN ULONG TerminateStatusCode
    )
{
    CSIPBuddy  *pSipBuddy = NULL;
    BOOL        IsFirstSubscribe;

    ENTER_FUNCTION("INCOMING_SUBSCRIBE_TRANSACTION::DeleteTransactionAndTerminateBuddyIfFirstSubscribe");
    LOG((RTC_TRACE, "%s - enter", __fxName));

    pSipBuddy = m_pSipBuddy;
    // Deleting the transaction could result in the
    // buddy being deleted. So, we AddRef() it to keep it alive.
    pSipBuddy->AddRef();
    
    IsFirstSubscribe = m_fIsFirstSubscribe;
    
    // Delete the transaction before you call
    // InitiateCallTerminationOnError as that call will notify the UI
    // and could get stuck till the dialog box returns.
    OnTransactionDone();
    
    if( IsFirstSubscribe )
    {
        // Terminate the call
        pSipBuddy -> InitiateBuddyTerminationOnError( TerminateStatusCode );
    }
    
    pSipBuddy->Release();
}


////////////////OUTGOING UNSUB TRANSACTION/////////////////////////////////


OUTGOING_UNSUB_TRANSACTION::OUTGOING_UNSUB_TRANSACTION(
    IN SIP_MSG_PROCESSOR   *pSipSession,
    IN SIP_METHOD_ENUM      MethodId,
    IN ULONG                CSeq,
    IN BOOL                 AuthHeaderSent,
    IN SIP_MSG_PROC_TYPE    sesssionType
    ) :
    OUTGOING_TRANSACTION(pSipSession, MethodId, CSeq, AuthHeaderSent)
{
    m_pPintCall = NULL;
    m_pSipWatcher = NULL;
    m_pSipBuddy = NULL;
    m_sesssionType = sesssionType;

    switch( m_sesssionType )
    {
    case SIP_MSG_PROC_TYPE_PINT_CALL:
        m_pPintCall = static_cast<PINT_CALL*> (pSipSession);
        break;

    case SIP_MSG_PROC_TYPE_WATCHER:

        m_pSipWatcher = static_cast<CSIPWatcher*> (pSipSession);
        break;

    case SIP_MSG_PROC_TYPE_BUDDY:

        m_pSipBuddy = static_cast<CSIPBuddy*> (pSipSession);
        break;
    }

}


OUTGOING_UNSUB_TRANSACTION::~OUTGOING_UNSUB_TRANSACTION()
{
    // XXX When should we actually set this to NULL ?

    LOG(( RTC_TRACE, "~OUTGOING_UNSUB_TRANSACTION() done" ));
}


HRESULT
OUTGOING_UNSUB_TRANSACTION::ProcessProvisionalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    LOG((RTC_TRACE,
         "OUTGOING_UNSUB_TRANSACTION::ProcessProvisionalResponse()"));
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        m_State = OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD;

        // We have to deal with 183 responses here.
        // Cancel existing timer and Start Timer
        KillTimer();
        hr = StartTimer(SIP_TIMER_INTERVAL_AFTER_PROV_RESPONSE_RCVD);
        if (hr != S_OK)
            return hr;
    }

    // Ignore the Provisional response if a final response
    // has already been received.

    return S_OK; 
}


HRESULT
OUTGOING_UNSUB_TRANSACTION::ProcessAuthRequiredResponse(
    IN  SIP_MESSAGE *pSipMsg
    )
{
    HRESULT                     hr;
    SIP_HEADER_ARRAY_ELEMENT    SipHdrElement;
    SECURITY_CHALLENGE          SecurityChallenge;

    ENTER_FUNCTION("OUTGOING_UNSUB_TRANSACTION::ProcessAuthRequiredResponse");

    // We need to addref the transaction as we could show credentials UI.
    TransactionAddRef();

    hr = ProcessAuthRequired(pSipMsg,
                             TRUE,          // Show Credentials UI if necessary
                             &SipHdrElement,
                             &SecurityChallenge );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s - ProcessAuthRequired failed %x",
             __fxName, hr));
        goto done;
    }

    switch( m_sesssionType )
    {
    case SIP_MSG_PROC_TYPE_PINT_CALL:

        hr = m_pPintCall -> CreateOutgoingUnsubTransaction( TRUE, 
                &SipHdrElement, 1 );

    case SIP_MSG_PROC_TYPE_BUDDY:

        hr = m_pSipBuddy -> CreateOutgoingUnsub( TRUE, &SipHdrElement, 1 );

    default:

        hr = E_FAIL;
    }

    free( SipHdrElement.HeaderValue );
    
    if (hr != S_OK)
    {
        LOG(( RTC_ERROR, "%s - CreateOutgoingNotify failed %x", __fxName, hr ));
    }

done:

    TransactionRelease();
    return hr;
}


HRESULT
OUTGOING_UNSUB_TRANSACTION::ProcessFinalResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;

    ENTER_FUNCTION( "OUTGOING_UNSUB_TRANSACTION::ProcessFinalResponse" );
    
    if (m_State != OUTGOING_TRANS_FINAL_RESPONSE_RCVD)
    {
        // This refcount must be released before returning from this function 
        // without any exception. Only in case of kerberos we keep this refcount.
        TransactionAddRef();

        OnTransactionDone();

        m_State = OUTGOING_TRANS_FINAL_RESPONSE_RCVD;

        if( IsAuthRequiredResponse(pSipMsg) )
        {
            hr = ProcessAuthRequiredResponse( pSipMsg );
        }
        else // success, failure or redirect
        {
            LOG(( RTC_TRACE,
                "%s: Processing %d", __fxName, pSipMsg->Response.StatusCode ));
            
            if( m_sesssionType == SIP_MSG_PROC_TYPE_PINT_CALL )
            {
                m_pPintCall -> SetSubscribeEnabled( FALSE );
                //if already sent a BYE or received a BYE then drop the call
            }
            else if( m_sesssionType == SIP_MSG_PROC_TYPE_BUDDY )
            {
                //Notify the Core about the buddy being removed.
                
                LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed", this ));
                m_pSipBuddy -> BuddyUnsubscribed();
            }
        }
        
        // Note that deleting the transaction could result in the SIP_CALL
        // being deleted if this is the last transaction and call was
        // previously terminated.
        TransactionRelease();

    }

    return S_OK;
}


HRESULT
OUTGOING_UNSUB_TRANSACTION::ProcessResponse(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr;
    
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_RESPONSE);

    if (IsProvisionalResponse(pSipMsg))
    {
        return ProcessProvisionalResponse(pSipMsg);
    }
    else if (IsFinalResponse(pSipMsg))
    {
        return ProcessFinalResponse(pSipMsg);
    }
    else
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
}


BOOL
OUTGOING_UNSUB_TRANSACTION::MaxRetransmitsDone()
{
    switch( m_sesssionType )
    {
    case SIP_MSG_PROC_TYPE_PINT_CALL:

        return (m_pPintCall->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 7);


    case SIP_MSG_PROC_TYPE_WATCHER:

        return (m_pSipWatcher->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 7);

    case SIP_MSG_PROC_TYPE_BUDDY:

        return (m_pSipBuddy->GetTransport() != SIP_TRANSPORT_UDP ||
            m_NumRetries >= 7);

    default:

        return TRUE;
    }
}


VOID
OUTGOING_UNSUB_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;

    ENTER_FUNCTION("OUTGOING_UNSUB_TRANSACTION::OnTimerExpire");
    
    switch (m_State)
    {
    case OUTGOING_TRANS_REQUEST_SENT:
        // Retransmit the request
        if (MaxRetransmitsDone())
        {
            LOG((RTC_ERROR,
                 "%s MaxRetransmits for request Done terminating call",
                 __fxName));
            
            goto error;
        }
        else
        {
            LOG((RTC_TRACE, "%s retransmitting request m_NumRetries : %d",
                 __fxName, m_NumRetries));
            hr = RetransmitRequest();
            if (hr != S_OK)
            {
                OnTransactionDone();
            }
            else
            {
                m_TimerValue *= 2;
                hr = StartTimer(m_TimerValue);
                if (hr != S_OK)
                {
                    goto error;
                }
            }
        }
        break;

    case OUTGOING_TRANS_PROVISIONAL_RESPONSE_RCVD:
        // We haven't received the final response within the
        // timeout. Terminate the transaction and call.
        LOG((RTC_ERROR,
             "%s Received 1xx but didn't receive final response terminating call",
             __fxName));
            
        goto error;
        break;

    case OUTGOING_TRANS_FINAL_RESPONSE_RCVD:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the ACK when we receive a
        // retransmit of the final response.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for handling response retransmits",
             __fxName));
        goto error;
        break;

    // No timers in the following states
    case OUTGOING_TRANS_INIT:
    default:
        ASSERT(FALSE);
        return;
    }

    return;

error:

    if( m_sesssionType == SIP_MSG_PROC_TYPE_PINT_CALL )
    {
        m_pPintCall -> InitiateCallTerminationOnError(0);
    }

    // Note that deleting the transaction could result in the SIP_CALL
    // being deleted if this is the last transaction and call was
    // previously terminated.
    OnTransactionDone();
}


HRESULT
PINT_CALL::Connect(
    IN   LPCOLESTR       LocalDisplayName,
    IN   LPCOLESTR       LocalUserURI,
    IN   LPCOLESTR       RemoteUserURI,
    IN   LPCOLESTR       LocalPhoneURI
    )
{

    HRESULT             hr;
    PINT_PARTY_INFO    *pPintPartyInfo;
    PLIST_ENTRY         pLE;

    ENTER_FUNCTION("PINT_CALL::Connect");
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "%s - SipStack is already shutdown", __fxName));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }


    LOG((RTC_TRACE,
         "%s - enter LocalDisplayName: %ls LocalUserURI: %ls "
         "RemoteUserURI: %ls LocalPhoneURI: %ls",
         __fxName,
         PRINTABLE_STRING_W(LocalDisplayName),
         PRINTABLE_STRING_W(LocalUserURI),
         PRINTABLE_STRING_W(RemoteUserURI),
         PRINTABLE_STRING_W(LocalPhoneURI)
         ));
    ASSERTMSG("SetNotifyInterface has to be called", m_pNotifyInterface);
    ASSERT(m_State == SIP_CALL_STATE_IDLE);
    
    //hr = SetLocal( LocalDisplayName, LocalUserURI );
    hr = SetLocalForOutgoingCall( LocalDisplayName, LocalUserURI );
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s SetLocalForOutgoingCall failed %x",
             __fxName, hr));
        return hr;
    }

    if (m_ProxyAddress == NULL)
    {
        LOG((RTC_ERROR, "%s No proxy address specified for PINT call",
             __fxName));
        return E_FAIL;
    }
    
    hr = SetRequestURI( m_ProxyAddress );
    if( hr != S_OK )
    {
        return hr;
    }

    if( m_PartyInfoListLen < 2 )
    {
        LOG((RTC_ERROR, "%s - m_PartyInfoListLen(%d) < 2 returning E_FAIL",
             __fxName, m_PartyInfoListLen));
        return E_FAIL;
    }

    pLE = m_PartyInfoList.Flink;

    // The first structure should be local party info.
    pPintPartyInfo = CONTAINING_RECORD( pLE, PINT_PARTY_INFO, pListEntry );

    hr = UnicodeToUTF8( LocalDisplayName,
            &pPintPartyInfo->DisplayName,
            &pPintPartyInfo->DisplayNameLen );

    if( hr != S_OK )
    {
        return hr;
    }

    hr = UnicodeToUTF8( LocalPhoneURI,
        &pPintPartyInfo->URI,
        &pPintPartyInfo->URILen );

    if( hr != S_OK )
    {
        return hr;
    }

    hr = UnicodeToUTF8( LocalPhoneURI, &m_LocalPhoneURI, 
        &m_LocalPhoneURILen );
    if( hr != S_OK )
    {
        return hr;
    }
    
    // The format of this URI should be aaa.bbb.ccc.ddd[:ppp]
    hr = SetRemote( m_ProxyAddress );
    if( hr != S_OK )
    {
        return hr;
    }

    // Start outgoing call
    return StartOutgoingCall( LocalPhoneURI );
}

            
INCOMING_NOTIFY_TRANSACTION::INCOMING_NOTIFY_TRANSACTION(
    IN SIP_MSG_PROCESSOR   *pSipMsgProc,
    IN SIP_METHOD_ENUM      MethodId,
    IN ULONG                CSeq,
    IN BOOL                 fIsSipCall
    ) :
    INCOMING_TRANSACTION(pSipMsgProc, MethodId, CSeq)
{
    LOG((RTC_TRACE, "Incoming NOTIFY created:%p", this ));
    
    if( fIsSipCall )
    {
        m_pPintCall = static_cast<PINT_CALL*> (pSipMsgProc);
        m_pSipBuddy = NULL;
    }
    else
    {
        m_pSipBuddy = static_cast<CSIPBuddy*> (pSipMsgProc);
        m_pPintCall = NULL;
    }

    m_fIsSipCall = fIsSipCall;
}

   
HRESULT
INCOMING_NOTIFY_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT(pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST);

    ENTER_FUNCTION("INCOMING_NOTIFY_TRANSACTION::ProcessRequest");
    LOG((RTC_TRACE, "entering %s: %p", __fxName, this ));

    switch (m_State)
    {
    case INCOMING_TRANS_INIT:
        
        LOG((RTC_TRACE, "%s sending 200", __fxName));
        
        //
        // Even if this is an UNSUB-NOTIFY, sending 481 is OK. A 481 would 
        // anyway tell the buddy machine that this session is unsubed.
        //

        if( (m_fIsSipCall == TRUE && m_pPintCall -> IsSessionDisconnected()) ||
            (m_fIsSipCall == FALSE && m_pSipBuddy -> IsSessionDisconnected()) )
        {
            hr = CreateAndSendResponseMsg(481,
                         SIP_STATUS_TEXT(481),
                         SIP_STATUS_TEXT_SIZE(481),
                         NULL,
                         TRUE,
                         NULL, 0,           // No presence information.
                         NULL, 0,           // No content Type
                         NULL, 0            // No header
                         );
        }
        else
        {
            hr = CreateAndSendResponseMsg(
                     200,
                     SIP_STATUS_TEXT(200),
                     SIP_STATUS_TEXT_SIZE(200),
                     NULL,   // No Method string
                     FALSE,  // No Contact Header
                     NULL, 0, //No message body
                     NULL, 0 // No content Type
                     );
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "%s CreateAndSendResponseMsg failed", __fxName));
                OnTransactionDone();
                return hr;
            }
        }

        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        
        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Retransmit the response
        LOG((RTC_TRACE, "%s retransmitting final response", __fxName));
        hr = RetransmitResponse();
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s RetransmitResponse failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        // We should never be in these states
        LOG((RTC_TRACE, "%s Invalid state %d", __fxName, m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_NOTIFY_TRANSACTION::RetransmitResponse()
{
    DWORD Error;
    
    // Send the buffer.
    Error = m_pResponseSocket->Send(m_pResponseBuffer);
    if (Error != NO_ERROR && Error != WSAEWOULDBLOCK)
    {
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


HRESULT
INCOMING_NOTIFY_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )    
{
    // Do nothing.
    return S_OK;
}


VOID
INCOMING_NOTIFY_TRANSACTION::OnTimerExpire()
{
    HRESULT   hr;

    ENTER_FUNCTION("INCOMING_NOTIFY_TRANSACTION::OnTimerExpire");

    switch (m_State)
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "%s deleting transaction after timeout for request retransmits",
             __fxName));
        OnTransactionDone();

        break;
        
        // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}


PINT_PARTY_INFO::PINT_PARTY_INFO()
{
    DisplayName = NULL;
    DisplayNameLen = 0;
    URI = NULL;
    URILen = 0;
    State = SIP_PARTY_STATE_IDLE;
    Status = PARTY_STATUS_IDLE;
	ErrorCode = 0;
	
    DWORD   dwSessionID = GetTickCount();
    _ultoa( dwSessionID , SessionID, 10 );

    dwSessionID = (ULONG)InterlockedIncrement( &lSessionID );
    
    _ultoa( dwSessionID, &SessionID[ strlen(SessionID) ], 10 );
    
    strcpy( SessionVersion, SessionID );

    strcpy( RequestStartTime, "0" );
    strcpy( RequestStopTime, "0" );

    fMarkedForRemove = FALSE;

}


INCOMING_UNSUB_TRANSACTION::INCOMING_UNSUB_TRANSACTION(
    IN SIP_MSG_PROCESSOR   *pSipMsgProc,
    IN SIP_METHOD_ENUM      MethodId,
    IN ULONG                CSeq,
    IN BOOL                 fIsPintCall
    ) :
    INCOMING_TRANSACTION(pSipMsgProc, MethodId, CSeq)
{
    if( fIsPintCall == TRUE )
    {
        m_pPintCall = static_cast<PINT_CALL *> (pSipMsgProc);
    }
}


// This must be a retransmission. Just retransmit the response.
// A new request is handled in CreateIncoming***Transaction()
HRESULT
INCOMING_UNSUB_TRANSACTION::ProcessRequest(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    ASSERT( pSipMsg->MsgType == SIP_MESSAGE_TYPE_REQUEST );
    ENTER_FUNCTION("INCOMING_UNSUB_TRANSACTION::ProcessRequest");
    switch( m_State )
    {
    case INCOMING_TRANS_INIT:

        hr = CreateAndSendResponseMsg(
                 200,
                 SIP_STATUS_TEXT(200),
                 SIP_STATUS_TEXT_SIZE(200),
                 NULL,
                 TRUE, 
                 NULL, 0,  // No Message Body
                 NULL, 0   // No content Type
                 );
        if( hr != S_OK )
        {
            LOG((RTC_ERROR, "%s CreateAndSendResponseMsg failed", __fxName));
            OnTransactionDone();
            return hr;
        }

        m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

        // This timer will just ensure that we maintain state to
        // deal with retransmits of requests
        hr = StartTimer(SIP_TIMER_MAX_INTERVAL);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "%s StartTimer failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        
        // Retransmit the response
        LOG((RTC_TRACE, "retransmitting final response" ));
        hr = RetransmitResponse();
        if( hr != S_OK )
        {
            LOG((RTC_ERROR, "%s RetransmitResponse failed", __fxName));
            OnTransactionDone();
            return hr;
        }
        break;
        
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        
        // We should never be in these states
        LOG((RTC_TRACE, "Invalid state %d", m_State));
        ASSERT(FALSE);
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
INCOMING_UNSUB_TRANSACTION::SendResponse(
    IN ULONG StatusCode,
    IN PSTR  ReasonPhrase,
    IN ULONG ReasonPhraseLen
    )
{
    HRESULT hr;
    ASSERT(m_State != INCOMING_TRANS_FINAL_RESPONSE_SENT);

    hr = CreateAndSendResponseMsg(
             StatusCode, ReasonPhrase, ReasonPhraseLen,
             NULL,
             TRUE, 
             NULL, 0,  // No Message Body
             NULL, 0 // No content Type
             );
    m_State = INCOMING_TRANS_FINAL_RESPONSE_SENT;

    return hr;
}


HRESULT
INCOMING_UNSUB_TRANSACTION::RetransmitResponse()
{
    DWORD Error;
    
    // Send the buffer.
    Error = m_pResponseSocket->Send( m_pResponseBuffer );
    if( Error != NO_ERROR && Error != WSAEWOULDBLOCK )
    {
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


VOID
INCOMING_UNSUB_TRANSACTION::OnTimerExpire()
{
    HRESULT hr;
    switch( m_State )
    {
    case INCOMING_TRANS_FINAL_RESPONSE_SENT:
        // Transaction done - delete the transaction
        // The timer in this state is just to keep the transaction
        // alive in order to retransmit the response when we receive a
        // retransmit of the request.
        LOG((RTC_TRACE,
             "deleting transaction after timeout for request retransmits" ));
        OnTransactionDone();

        break;
        
    // No timers in these states
    case INCOMING_TRANS_INIT:
    case INCOMING_TRANS_REQUEST_RCVD:
    case INCOMING_TRANS_ACK_RCVD:
    default:
        ASSERT(FALSE);
        break;
    }

    return;
}


HRESULT
INCOMING_UNSUB_TRANSACTION::TerminateTransactionOnByeOrCancel(
    OUT BOOL *pCallDisconnected
    )
{
    // Do nothing.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\options.h ===
//options.h

//The server is being queried as to its capabilities. 

//1. Server MAY respond to this request with a capability set. 
//2. A called user agent MAY return a status reflecting how it 
//   would have responded to an invitation, e.g.,600 (Busy). 
//3. Such a server SHOULD return an Allow header field indicating
//    the methods that it supports.

#ifndef __sipcli_options_h__
#define __sipcli_options_h__

#include "sipcall.h"

class OPTIONS_MSGPROC;

class INCOMING_OPTIONS_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_OPTIONS_TRANSACTION(
        IN OPTIONS_MSGPROC        *pOPTIONS,
        IN SIP_METHOD_ENUM  MethodId,
        IN ULONG            CSeq
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    VOID OnTimerExpire();

    HRESULT RetransmitResponse();

private:
    OPTIONS_MSGPROC    *m_pOptions;
    
    //virtual fn
    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );

};


// This class processes OPTIONS requests
class OPTIONS_MSGPROC :
    public SIP_MSG_PROCESSOR
{
public:
    OPTIONS_MSGPROC(
        IN  SIP_STACK         *pSipStack
        );

    ~OPTIONS_MSGPROC();
   
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    BOOL IsSessionDisconnected();

    HRESULT StartIncomingCall(
        IN  SIP_TRANSPORT   Transport,
        IN  SIP_MESSAGE    *pSipMsg,
        IN  ASYNC_SOCKET   *pResponseSocket
        );

private:
    //Virtual fns

    HRESULT CreateIncomingTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    VOID OnError();


};


#endif // __sipcli_OPTIONS_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\pintcall.h ===
#ifndef __sipcli_pintcall_h__
#define __sipcli_pintcall_h__


#include    "sipcall.h"
#include    "siputil.h"
class PINT_CALL;

enum PINT_PARTY_STATUS
{

    PARTY_STATUS_IDLE = 0,
    PARTY_STATUS_PENDING = 1,
    PARTY_STATUS_STARTING = 2,
    PARTY_STATUS_ANSWERED = 3,
    PARTY_STATUS_DROPPED = 4,
    PARTY_STATUS_FAILED = 5,

    PARTY_STATUS_ENDING = 12,

    PARTY_STATUS_RECEIVED_START = 100,
    PARTY_STATUS_RECEIVED_STOP = 101,
    PARTY_STATUS_RECEIVED_BYE = 102,
    
};    


/////////////////////NOTIFY Transaction
class INCOMING_NOTIFY_TRANSACTION : public INCOMING_TRANSACTION
{
public:
    INCOMING_NOTIFY_TRANSACTION(
        IN SIP_MSG_PROCESSOR   *pSipMsgProc,
        IN SIP_METHOD_ENUM      MethodId,
        IN ULONG                CSeq,
        BOOL                    fIsSipCall
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT SendResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();

    HRESULT RetransmitResponse();

private:

    PINT_CALL  *m_pPintCall;
    CSIPBuddy  *m_pSipBuddy;
    BOOL        m_fIsSipCall;

};


class OUTGOING_UNSUB_TRANSACTION : public OUTGOING_TRANSACTION
{
public:
    OUTGOING_UNSUB_TRANSACTION (
        IN SIP_MSG_PROCESSOR   *pSipSession,
        IN SIP_METHOD_ENUM      MethodId,
        IN ULONG                CSeq,
        IN BOOL                 AuthHeaderSent,
        IN SIP_MSG_PROC_TYPE    sesssionType
    );

    ~OUTGOING_UNSUB_TRANSACTION();
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessAuthRequiredResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    BOOL MaxRetransmitsDone();

    PINT_CALL   *m_pPintCall;
    CSIPWatcher *m_pSipWatcher;
    CSIPBuddy   *m_pSipBuddy;
    SIP_MSG_PROC_TYPE m_sesssionType;

};


class OUTGOING_SUBSCRIBE_TRANSACTION : public OUTGOING_TRANSACTION
{
public:

    OUTGOING_SUBSCRIBE_TRANSACTION(
        IN SIP_MSG_PROCESSOR   *pSipMsgProc,
        IN SIP_METHOD_ENUM      MethodId,
        IN ULONG                CSeq,
        IN BOOL                 AuthHeaderSent,
        IN BOOL                 fIsSipCall,
        IN BOOL                 fIsFirstSubscribe
        );
    
    ~OUTGOING_SUBSCRIBE_TRANSACTION ();
    
    HRESULT ProcessResponse(
        IN SIP_MESSAGE  *pSipMsg
        );

    VOID OnTimerExpire();

    HRESULT RefreshSubscription();

    HRESULT ProcessRedirectResponse(
        IN SIP_MESSAGE *pSipMsg
        );
    
    VOID TerminateTransactionOnError(
        IN HRESULT      hr
        );
    
    VOID DeleteTransactionAndTerminateBuddyIfFirstSubscribe(
        IN ULONG TerminateStatusCode
        );

    HRESULT ProcessAuthRequiredResponse(
        IN  SIP_MESSAGE *pSipMsg,
        OUT BOOL        &fDelete
        );

private:    
    HRESULT ProcessProvisionalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    HRESULT ProcessFinalResponse(
        IN SIP_MESSAGE *pSipMsg
        );

    BOOL MaxRetransmitsDone();

    HRESULT ProcessFailureResponse(
        SIP_MESSAGE    *pSipMsg
        );
   
    PINT_CALL  *m_pPintCall;
    CSIPBuddy  *m_pSipBuddy;
    BOOL        m_fIsSipCall;
    BOOL        m_fIsFirstSubscribe;
};


class PINT_PARTY_INFO
{
public:

    PSTR    DisplayName;
    DWORD   DisplayNameLen;
    PSTR    URI;
    DWORD   URILen;

    SIP_PARTY_STATE		State;  //party state reported to the application

    PINT_PARTY_STATUS   Status; //party status received from the PINT serever
	
    union {
		HRESULT			ErrorCode;

		SIP_STATUS_CODE	RejectedStatusCode;
	};

    CHAR                SessionID[21];  //use time() to create it initially
    CHAR                SessionVersion[21]; //initially same as sessionID, then copy from Notify each time we receive one.
    
    CHAR                RequestStartTime[21];   //initially 0. then copy from Notify each time we receive one.
    CHAR                RequestStopTime[21];    //needs to be something for stop-now

    LIST_ENTRY          pListEntry;
    
    BOOL                fMarkedForRemove;

    PINT_PARTY_INFO();
};



#define DEFAULT_LOCALHOST_NAME      "www.xxx.yyy.zzz"

#define LOCAL_USER_NETWORK_TYPE     "IN"
#define LOCAL_USER_ADDRESS_TYPE     "IP4"
#define LOCAL_USER_MEDIA_PORT       "1"
#define PINT_SDP_SESSION            "Session SDP"
#define SDP_VERSION_TEXT            "v=0"
#define MEDIA_SUBTYPE               "-"         //No media subtype
#define PINT_STATUS_DESCRIPTOR_SIZE 250         //In most case this size should be sufficient
#define SDP_ORIGIN_HEADER           "o="
#define SDP_SESSION_HEADER          "s="
#define SDP_CONTACT_HEADER          "c="
#define SDP_MEDIA_HEADER            "m="
#define SDP_TIME_HEADER             "t="
#define SDP_REQUEST_HEADER          "a=request:"
#define SDP_STATUS_HEADER           "a=status:"
#define PINT_SDP_MEDIA              "audio"
#define PINT_SDP_MEDIAPORT          "1"
#define PINT_SDP_MEDIATRANSPORT     "voice"
#define STATUS_HEADER_TEXT          "status:"


#define SDP_HEADER_LEN              2

#define NEWLINE_CHAR                '\n'
#define RETURN_CHAR                 '\r'
#define NULL_CHAR                   '\0'
#define BLANK_CHAR                  ' '
#define TAB_CHAR                    '\t'
#define OPEN_PARENTH_CHAR           '('
#define CLOSE_PARENTH_CHAR          ')'
#define QUOTE_CHAR                  '"'

#define PARTY_STATUS_PENDING_TEXT          "pending"
#define PARTY_STATUS_RECEIVED_START_TEXT   "received-start"
#define PARTY_STATUS_STARTING_TEXT         "starting"
#define PARTY_STATUS_ANSWERED_TEXT         "answered"
#define PARTY_STATUS_RECEIVED_STOP_TEXT    "received-stop"
#define PARTY_STATUS_ENDING_TEXT           "ending"
#define PARTY_STATUS_DROPPED_TEXT          "dropped"
#define PARTY_STATUS_RECEIVED_BYE_TEXT     "received-bye"
#define PARTY_STATUS_FAILED_TEXT           "failed:"

#define PARTY_STATUS_REQUEST_START_TEXT     "start now"
#define PARTY_STATUS_REQUEST_STOP_TEXT      "stop now"

//////////////////PINT call related definitions.


#define MAX_PHONE_NUMBER_LENGTH     48
#define LONGLONG_STRING_LEN         21 //long enough to hold a LONGLONG
#define MAX_PARTY_STATUS_LEN        64
#define MAX_TYPESTRING_LENGTH       32
#define LONG_STRING_LEN             11

#define PINT_R2C_STRING             "sip:R2C@" 
#define PINT_TSP_STRING             ";tsp=" 
#define PINT_ADDR_TYPE              "RFC2543"
#define PINT_NETWORK_TYPE           "TN"
#define PINT_TO_HEADER              " <sip:%s@%s;user=phone>"
#define SIP_URI_HEADER              "sip:"
#define PINT_MEDIA_TYPE             "audio"
#define NO_DISPLAY_NAME             "No Display"

#define UNSUB_EXPIRES_HEADER_TEXT   "0"

#define IsCRLFPresent( pBlock )     ( (*pBlock == RETURN_CHAR) && (*(pBlock+1) == NEWLINE_CHAR) )

#define SIP_ATTRIBUTE_LEN   2

enum PINT_SDP_ATTRIBUTE
{
    SDP_ATTRIBUTE_ERROR = 0,
    
    SDP_VERSION,
    SDP_ORIGIN,
    SDP_SESSION,
    SDP_CONTACT,
    SDP_TIME,
    SDP_STATUS_ATTRIBUTE,
    SDP_MEDIA_DESCR,
    
    SDP_UNKNOWN,

};


struct PINTCALL_MEDIA_INFO
{
    CHAR    pstrMediaType[MAX_TYPESTRING_LENGTH];       //We support only "audio"
    CHAR    pstrTransportType[MAX_TYPESTRING_LENGTH];   //We support only "voice"
    
};


struct PINTCALL_CONTACT_INFO
{
    CHAR    pstrPartyPhoneNumber[MAX_PHONE_NUMBER_LENGTH];
    CHAR    pstrNetworkType[MAX_TYPESTRING_LENGTH];         //should be "TN"
    CHAR    pstrAddressType[MAX_TYPESTRING_LENGTH];         //should be "RFC2543"

};


struct PINTCALL_ORIGIN_INFO
{
    CHAR    pstrSessionID[LONGLONG_STRING_LEN]; //long enough to hold a LONGLONG
    CHAR    pstrVersion[LONGLONG_STRING_LEN];   //long enough to hold a LONGLONG
    CHAR    pstrNetworkType[MAX_TYPESTRING_LENGTH]; //should be "IN"
};


struct PINTCALL_STATUS_DESRIPTION
{
    DWORD                   dwSDPVersion;
    PINTCALL_CONTACT_INFO   partyContactInfo;
    CHAR                    pstrPartyStatus[MAX_PARTY_STATUS_LEN];
        CHAR                pstrPartyStatusCode[MAX_PARTY_STATUS_LEN];
    PINTCALL_MEDIA_INFO     mediaInfo;
    CHAR                    pstrStatusChangeTime[LONGLONG_STRING_LEN];
    PINTCALL_ORIGIN_INFO    originInfo;
    
    LIST_ENTRY              pListEntry;
    BOOLEAN                 fInvalidStatusBlock;

};



class PINT_CALL : public SIP_CALL
{
public:
        
    PINT_CALL(
        IN  SIP_PROVIDER_ID   *pProviderId,
        IN  SIP_STACK         *pSipStack,
        IN  REDIRECT_CONTEXT  *pRedirectContext,
        OUT HRESULT           *phr
        );

    STDMETHODIMP Connect(
        IN   LPCOLESTR       LocalDisplayName,
        IN   LPCOLESTR       LocalUserURI,
        IN   LPCOLESTR       RemoteUserURI,
        IN   LPCOLESTR       LocalPhoneURI
        );

    STDMETHODIMP Accept();

    STDMETHODIMP Reject(
        IN SIP_STATUS_CODE StatusCode
        );


    STDMETHODIMP AddParty(
        IN   SIP_PARTY_INFO *pPartyInfo
        );

    STDMETHODIMP RemoveParty(
        IN   LPOLESTR  PartyURI
        );

    // XXX Is this Required ? Can we just call Disconnect ?
    STDMETHODIMP RemoveAllParties();

    STDMETHODIMP StartStream(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie        
        );
                     
    STDMETHODIMP StopStream(
        IN RTC_MEDIA_TYPE       MediaType,
        IN RTC_MEDIA_DIRECTION  Direction,
        IN LONG                 Cookie        
        );
    
    HRESULT StartOutgoingCall(
        IN   LPCOLESTR       LocalPhoneURI
        );

    HRESULT ConnectPintCall(void);

    HRESULT HandleInviteRejected(
        IN SIP_MESSAGE *pSipMsg 
        );

    VOID ProcessPendingInvites();
    
    PINT_SDP_ATTRIBUTE GetSDPAttribute( 
        OUT PSTR * ppLine 
        );

    HRESULT GetExpiresHeader(
        SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement
        );

    HRESULT CreateOutgoingSubscribeTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ULONG                       dwNoOfHeaders
        );

    HRESULT CreateOutgoingUnsubTransaction(
        IN  BOOL                        AuthHeaderSent,
        IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
        IN  ULONG                       dwNoOfHeaders
        );

    HRESULT CreateSDPBlobForSubscribe(
        IN  PSTR  * pSDPBlob );

    HRESULT CreateIncomingUnsubTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    VOID SetSubscribeEnabled(
        IN  BOOL fSubscribeEnabled
        )
    {
        m_fSubscribeEnabled = fSubscribeEnabled;
    }

private:

    HRESULT CleanupCallTypeSpecificState();
    
    HRESULT GetAndStoreMsgBodyForInvite(
        IN  BOOL    IsFirstInvite,
        OUT PSTR   *pszMsgBody,
        OUT ULONG  *pMsgBodyLen
        );

    HRESULT CreateIncomingTransaction(
        IN  SIP_MESSAGE *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT SetRequestURI(
        IN  PSTR  ProxyAddress
        );
    
    HRESULT SetRemote(
        IN  PSTR ProxyAddress
        );

    HRESULT CreateSDPBlobForInvite(
        IN  PSTR  * SDPBlob );
    
    void EncodePintStatusBlock( 
        IN      PINT_PARTY_INFO    *pPintPartyInfo, 
        IN      PSTR                SDPBlob, 
        IN  OUT DWORD              *pdwNextOffset,
        IN      PSTR                LocalHostName
        );

    void EncodeSDPOriginHeader(
        IN      PINT_PARTY_INFO    *pPintPartyInfo, 
        IN      PSTR                SDPBlob, 
        IN  OUT DWORD              *pdwNextOffset,
        IN      PSTR                LocalHostName
    );

    void EncodeSDPContactHeader(
        IN      PINT_PARTY_INFO    *pPintPartyInfo, 
        IN      PSTR                SDPBlob, 
        IN  OUT DWORD              *pdwNextOffset
        );

    void EncodeSDPTimeHeader(
        IN      PINT_PARTY_INFO    *pPintPartyInfo, 
        IN      PSTR                SDPBlob, 
        IN  OUT DWORD              *pdwNextOffset
        );
    
    void EncodeSDPStatusHeader(
        IN      PINT_PARTY_INFO    *pPintPartyInfo,
        IN      PSTR                SDPBlob,
        IN  OUT DWORD              *pdwNextOffset
        );

    void EncodeSDPMediaHeader(
        IN      PINT_PARTY_INFO    *pPintPartyInfo,
        IN      PSTR                SDPBlob,
        IN  OUT DWORD              *pdwNextOffset
        );

    HRESULT ValidateCallStatusBlock( 
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    HRESULT ProcessPintNotifyMessage(
        IN SIP_MESSAGE  *pSipMsg
        );

    HRESULT ChangePintCallStatus(
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    HRESULT NotifyPartyStateChange( 
        IN  PINT_PARTY_INFO   * pPintPartyInfo,
        IN  HRESULT             RejectedStatusCode
        );

    void ParseSDPVersionLine( 
        OUT PSTR                       * ppPintBlobLine, 
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    HRESULT ParseSDPOriginLine( 
        OUT PSTR * ppPintBlobLine, 
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    void ParseSDPSessionLine( 
        PSTR * ppPintBlobLine, 
        PINTCALL_STATUS_DESRIPTION * pPintCallStatus 
        );

    void ParseSDPContactLine( 
        OUT PSTR * ppPintBlobLine, 
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    void ParseSDPTimeLine( 
        OUT PSTR * ppPintBlobLine, 
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    void ParseSDPMediaLine( 
        OUT PSTR * ppPintBlobLine,
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );
    
    void ParseSDPStatusLine( 
        OUT PSTR * ppPintBlobLine, 
        IN  PINTCALL_STATUS_DESRIPTION * pPintCallStatus
        );

    HRESULT CreateIncomingNotifyTransaction(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT StatusBlockMatchingPartyInfo( 
        IN  PINT_PARTY_INFO            *pPintPartyInfo, 
        IN  PINTCALL_STATUS_DESRIPTION *pPintCallStatus 
        );   

    DWORD           m_dwExpires;

    ULONG GetRejectedStatusCode( 
        IN  PINTCALL_STATUS_DESRIPTION *pPintCallStatus 
        );

    VOID RemovePartyFromList(
        OUT PLIST_ENTRY        &pLE,
        IN  PINT_PARTY_INFO    *pPintPartyInfo
        );

    BOOL    m_fINVITEPending;

};


//
// Incoming UNSUB transaction.
//

class INCOMING_UNSUB_TRANSACTION : public INCOMING_TRANSACTION
{
public:

    INCOMING_UNSUB_TRANSACTION(
        IN SIP_MSG_PROCESSOR   *pSipMsgProc,
        IN SIP_METHOD_ENUM      MethodId,
        IN ULONG                CSeq,
        IN BOOL                 fIsPintCall
        );
    
    HRESULT ProcessRequest(
        IN SIP_MESSAGE  *pSipMsg,
        IN ASYNC_SOCKET *pResponseSocket
        );

    HRESULT TerminateTransactionOnByeOrCancel(
        OUT BOOL *pCallDisconnected
        );
    
    HRESULT SendResponse(
        IN ULONG StatusCode,
        IN PSTR  ReasonPhrase,
        IN ULONG ReasonPhraseLen
        );

    VOID OnTimerExpire();

    HRESULT RetransmitResponse();

private:

    CSIPBuddy  *m_pSipBuddy;
    PINT_CALL  *m_pPintCall;

};

#endif //__sipcli_pintcall_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\precomp.h ===
/****************************************************************************

  Copyright (c) 2000  Microsoft Corporation

  Product:      Microsoft Phoenix V1

  Module Name:  precomp.h

       Author:  Ajay Chitturi [ajaych]

     Abstract:  Precompiled headers for the SIP stack library

        Notes:

  Rev History:

****************************************************************************/



#define STRICT

//
// ATL uses _DEBUG to enable tracing
//

#if DBG && !defined(_DEBUG)
#define _DEBUG
#endif

// NT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Win32
#include <windows.h>

#ifndef _WINSOCK2_
#include <winsock.h>
#else
#include <winsock2.h>
#endif // _WINSOCK2_

#include <iphlpapi.h>
#include <tchar.h>
#include <rpc.h>
#include <wininet.h>

// #include <objbase.h>
// #include <oledb.h>
// #include <oledberr.h>

// ANSI
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#include <dpnathlp.h>
//
// ATL
//
// We don't want to link with MSVCRTD.DLL, so we define _ATL_NO_DEBUG_CRT.
// However, this means we need to provide our own definition of ATLASSERT.
//

#define _ATL_NO_DEBUG_CRT

#if DBG

// MSVC's debugger eats the last stack from on DebugBreak, so don't make this inline.
static void DebugAssertFailure (IN PCSTR ConditionText)
{ OutputDebugStringA (ConditionText); DebugBreak(); }

#define ATLASSERT(Condition) \
    if (!(Condition)) { DebugAssertFailure ("Assertion failed: " #Condition "\n"); } else

#else
#define ATLASSERT(Condition) __assume(Condition)
#endif

#include <atlbase.h>
extern CComModule _Module;
// #include <atlcom.h>

// Project
#include "rtcerr.h"
#include "rtclog.h"
#include "rtcsip.h"
#include "rtcmem.h"

// Local
#include "dbgutil.h"
#include "sipdef.h"
#include "siphdr.h"
#include "sipmsg.h"
#include "asock.h"
#include "timer.h"
#include "asyncwi.h"
#include "resolve.h"
#include "dnssrv.h"
#include "msgproc.h"
#include "sockmgr.h"
#include "md5digest.h"
#include "siputil.h"
#include "presence.h"

#ifdef RTCLOG
#define ENTER_FUNCTION(s) \
    const static CHAR  __fxName[] = s
#else
#define ENTER_FUNCTION(s)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\tapi\rtc\phoenix\src\sip\presence.cpp ===
#include    "precomp.h"
#include    "util.h"
#include    "sipstack.h"
#include    "presence.h"
#include    "resolve.h"
#include    "sipmsg.h"
#include    "sipcall.h"
#include    "pintcall.h"


//
// The ISIPBuddyManager implementation. This interface is implemented by
// SIP_STACK class.
//


/*
Routine Description
Returns the number of buddies in the buddy list of this UA.

Parameters:
None.

Return Value:
    INT - The number of buddies.
*/

STDMETHODIMP_(INT)
SIP_STACK::GetBuddyCount(void)
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG((RTC_TRACE, "SIP_STACK::GetBuddyCount - Entered"));

    return m_SipBuddyList.GetSize();
}



/*
Routine Description:
    Returns a buddy object by index in the buddy list.

Parameters:
    INT iIndex -    The index of the buddy in the buddy list.

Return Value:
    ISIPBuddy * pSipBuddy - The ISIPBuddy interface pointer if the index 
    passed is valid. The return value is NULL if invalid index is passed.
*/

STDMETHODIMP_(ISIPBuddy *)
SIP_STACK::GetBuddyByIndex(
    IN  INT iIndex
    )
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return NULL;
    }

    HRESULT     hr;
    CSIPBuddy * pSIPBuddy = m_SipBuddyList[iIndex];
    ISIPBuddy *pBuddy;

    LOG(( RTC_TRACE, "SIP_STACK::GetBuddyByIndex - Entered" ));
    
    if( pSIPBuddy != NULL )
    {
        hr = pSIPBuddy -> QueryInterface( IID_ISIPBuddy, (PVOID*)&pBuddy );

        if( hr == S_OK )
            return pBuddy;
    }

    LOG(( RTC_TRACE, "SIP_STACK::GetBuddyByIndex - Exited" ));

    return NULL;
}


/*
Routine Description:
    Add a new buddy object, which triggers a subscription to the
    remote presentity. The buddy object can be referenced by the
    application as long it does not call RemoveBuddy on this object.

Parameters:
    LPWSTR  lpwstrFriendlyName - The friendly name of the buddy object.
    ULONG   ulFriendlyNameLen - Number of wide chars in the friendly name.
    LPWSTR  lpwstrPresentityURI - The URI of the presentity to subscribe to.
    ULONG   ulPresentityURILen - Number of wide chars in the presentity URI 
    ISIPBuddy **ppSipBuddy - The ISIPBuddy interface pointer of the newly 
                            created buddy object.

Return Value:
    HRESULT
    S_OK            -   Success.
    E_OUTOFMEMORY   -   No memory to allocate.
    E_FAIL          -   The operation failed.
*/

STDMETHODIMP
SIP_STACK::AddBuddy(
    IN  LPWSTR                  lpwstrFriendlyName,
    IN  LPWSTR                  lpwstrPresentityURI,
    IN  LPWSTR                  lpwstrLocalUserURI,
    IN  SIP_PROVIDER_ID        *pProviderID,
    IN  SIP_SERVER_INFO        *pProxyInfo,
    IN  ISipRedirectContext    *pRedirectContext,
    OUT ISIPBuddy **            ppSipBuddy
    )
{
    HRESULT                 hr;
    BOOL                    fResult;
    CSIPBuddy              *pSipBuddy = NULL;
    SIP_USER_CREDENTIALS   *pUserCredentials = NULL;
    LPOLESTR                Realm = NULL;
    BOOL                    fSuccess;
    ULONG                   ProviderIndex;

    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    *ppSipBuddy = NULL;

    LOG(( RTC_TRACE, "SIP_STACK::AddBuddy - Entered" ));
    
    if (pProviderID != NULL &&
        !IsEqualGUID(*pProviderID, GUID_NULL))
    {
        hr = GetProfileUserCredentials(pProviderID, &pUserCredentials, &Realm);
        if (hr != S_OK)
        {
            LOG((RTC_WARN, "GetProfileUserCredentials failed %x",
                 hr));
            pUserCredentials = NULL;
        }
    }

    pSipBuddy = new CSIPBuddy(  this, 
                                lpwstrFriendlyName,
                                lpwstrPresentityURI,
                                pProviderID,
                                (REDIRECT_CONTEXT*)pRedirectContext,
                                &fSuccess );
    if( pSipBuddy == NULL )
    {
        return E_OUTOFMEMORY;
    }

    if( fSuccess == FALSE )
    {
        delete pSipBuddy;
        return E_OUTOFMEMORY;
    }

    if( pProxyInfo != NULL )
    {
        hr = pSipBuddy->SetProxyInfo( pProxyInfo );
        
        if( hr != S_OK )
        {
            goto cleanup;
        }
    }

    if( pUserCredentials != NULL )
    {               
        hr = pSipBuddy -> SetCredentials( pUserCredentials,
                                          Realm );
        if( hr != S_OK )
        {
            goto cleanup;
        }
    }

    hr = pSipBuddy -> SetLocalForOutgoingCall( lpwstrFriendlyName,
        lpwstrLocalUserURI );
    if( hr != S_OK )
    {
        goto cleanup;
    }

    hr = pSipBuddy -> SetRequestURIRemoteAndRequestDestination( 
                        lpwstrPresentityURI, (pProxyInfo != NULL) );
    if( hr != S_OK )
    {
        goto cleanup;
    }
    
    fResult = m_SipBuddyList.Add( pSipBuddy );
    if( fResult != TRUE )
    {
        goto cleanup;
    }

    hr = pSipBuddy -> CreateOutgoingSubscribe( TRUE, FALSE, NULL, 0 );
    if( hr != S_OK )
    {
        m_SipBuddyList.Remove( pSipBuddy );
        goto cleanup;
    }

    *ppSipBuddy = static_cast<ISIPBuddy *>(pSipBuddy);

    LOG(( RTC_TRACE, "SIP_STACK::AddBuddy - Exited-SIP Buddy:%p", *ppSipBuddy ));

    return S_OK;

cleanup:
    delete pSipBuddy;
    return hr;
}


/*
Routine Description:
    Remove a buddy from the list, which will cause 
    the buddy manager to cancel the subscription.

Parameters:
    ISIPBuddy * pSipBuddy   - The ISIPBuddy interface pointer of the buddy
                            object to be removed.

Return Value:
    HRESULT
    S_OK    - The buddy has been removed successfully from the buddy list. This
              means the application can't access this object anymore. The buddy
              manager might keep the actual buddy object until the UNSUB 
              transaction is completed successfully.

    E_FAIL  - There is no such buddy object in the buddy manager's list.
*/

STDMETHODIMP
SIP_STACK::RemoveBuddy(
    IN  ISIPBuddy *         pSipBuddy,
    IN  BUDDY_REMOVE_REASON buddyRemoveReason
    )
{
    INT     iBuddyIndex;
    HRESULT hr;
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "SIP_STACK::RemoveBuddy - Entered" ));
    
    CSIPBuddy * pCSIPBuddy = static_cast<CSIPBuddy *> (pSipBuddy);
    
    iBuddyIndex = m_SipBuddyList.Find( pCSIPBuddy );
    
    if( iBuddyIndex == -1 )
    {
        // Don't be harsh. Let the core release it's refcount
        return S_OK;
    }

    hr = pCSIPBuddy -> CreateOutgoingUnsub( FALSE, NULL, 0 );
    
    if( hr != S_OK )
    {
        return hr;
    }

    m_SipBuddyList.RemoveAt( iBuddyIndex );

    pCSIPBuddy -> SetState( BUDDY_STATE_DROPPED );

    LOG(( RTC_TRACE, "SIP_STACK::RemoveBuddy - Exited" ));
    return S_OK;
}


HRESULT
CSIPBuddy::SetRequestURIRemoteAndRequestDestination(
    IN  LPCOLESTR   wsDestURI,
    IN  BOOL        fPresenceProvider
    )
{
    HRESULT       hr;

    LOG(( RTC_TRACE, 
        "CSIPBuddy::SetRequestURIRemoteAndRequestDestination - Entered- %p", this ));

    if (wcsncmp(wsDestURI, L"sip:", 4) == 0)
    {
        // SIP URL
        
        PSTR    szSipUrl;
        ULONG   SipUrlLen;
        SIP_URL DecodedSipUrl;
        ULONG   BytesParsed = 0;

        hr = UnicodeToUTF8(wsDestURI, &szSipUrl, &SipUrlLen);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "UnicodeToUTF8(sipurl) failed %x", hr));
            return hr;
        }

        hr = ParseSipUrl(szSipUrl, SipUrlLen, &BytesParsed, &DecodedSipUrl);
        
        free(szSipUrl);
        
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "ParseSipUrl failed %x", hr));
            return hr;
        }

        hr = SIP_MSG_PROCESSOR::SetRequestURI(&DecodedSipUrl);
        if (hr != S_OK)
        {
            LOG((RTC_ERROR, "SetRequestURI failed %x", hr));
            return hr;
        }

        if (DecodedSipUrl.m_TransportParam == SIP_TRANSPORT_UNKNOWN)
        {
            LOG((RTC_ERROR, "Unknown transport specified in SIP URL" ));
            
            return RTC_E_SIP_TRANSPORT_NOT_SUPPORTED;
        }
        
        // If maddr param is present - this should be the request destination.
        // If provider is not present - resolve the SIP URL.
        if( (DecodedSipUrl.m_KnownParams[SIP_URL_PARAM_MADDR].Length != 0) ||
            (fPresenceProvider == FALSE) )
        {
            hr = ResolveSipUrlAndSetRequestDestination(&DecodedSipUrl, TRUE,
                                                       FALSE, FALSE, TRUE);
            if (hr != S_OK)
            {
                LOG((RTC_ERROR, "ResolveSipUrlAndSetRequestDestination failed %x",
                      hr));
                return hr;
            }
        }
        else
        {
            // Set the request destination to the proxy.
            hr = ResolveProxyAddressAndSetRequestDestination();
            if (hr != S_OK)
            {
                LOG((RTC_ERROR,
                     "ResolveProxyAddressAndSetRequestDestination failed : %x",
                     hr));
                return hr;
            }
        }
    }
    else
    {
        ASSERT(0);
    }

    LOG((RTC_TRACE, "call set RequestURI to : %s", m_RequestURI));

    hr = SetRemoteForOutgoingCall(m_RequestURI, m_RequestURILen);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "SetRemoteForOutgoingCall failed %x", hr));
        return hr;
    }
    
    LOG((RTC_TRACE, "call set Remote to : %s", m_Remote));

    LOG(( RTC_TRACE, 
        "CSIPBuddy::SetRequestURIRemoteAndRequestDestination - Exited- %p", this ));

    return S_OK;
}


HRESULT 
CSIPBuddy::GetExpiresHeader(
    SIP_HEADER_ARRAY_ELEMENT   *pHeaderElement
    )
{
    LOG(( RTC_TRACE, "CSIPBuddy::GetExpiresHeader - Entered- %p", this ));
    
    pHeaderElement->HeaderId = SIP_HEADER_EXPIRES;
    
    pHeaderElement->HeaderValue = new CHAR[ 10 ];
    
    if( pHeaderElement->HeaderValue == NULL )
    {
        return E_OUTOFMEMORY;
    }

    _ultoa( m_dwExpires, pHeaderElement->HeaderValue, 10 );

    pHeaderElement->HeaderValueLen = 
        strlen( pHeaderElement->HeaderValue );

    LOG(( RTC_TRACE, "CSIPBuddy::GetExpiresHeader - Exited- %p", this ));

    return S_OK;
}


HRESULT
CSIPBuddy::CreateOutgoingSubscribe(
    IN  BOOL                        fIsFirstSubscribe,
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ULONG                       dwNoOfHeaders
    )
{
    HRESULT                         hr;
    SIP_TRANSPORT                   Transport;
    SOCKADDR_IN                     DstAddr;
    DWORD                           dwNoOfHeader = 0;
    SIP_HEADER_ARRAY_ELEMENT        HeaderArray[2];
    SIP_HEADER_ARRAY_ELEMENT       *pExpiresHeader = NULL;
    DWORD                           iIndex;

    OUTGOING_SUBSCRIBE_TRANSACTION *pOutgoingSubscribeTransaction;
        
    LOG(( RTC_TRACE, "CSIPBuddy::CreateOutgoingSubscribe-Entered- %p", this ));
    
    pOutgoingSubscribeTransaction =
        new OUTGOING_SUBSCRIBE_TRANSACTION(
                this, SIP_METHOD_SUBSCRIBE,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                FALSE, 
                fIsFirstSubscribe
                );
    
    if( pOutgoingSubscribeTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = GetExpiresHeader( &HeaderArray[dwNoOfHeaders] );
    if( hr == S_OK )
    {
        pExpiresHeader = &HeaderArray[dwNoOfHeaders];
        dwNoOfHeaders++;
    }

    if( pAuthHeaderElement != NULL )
    {
        HeaderArray[dwNoOfHeader] = *pAuthHeaderElement;
        dwNoOfHeader++;
    }

    hr = pOutgoingSubscribeTransaction->CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP,
             HeaderArray, dwNoOfHeaders,
             NULL, 0,
             NULL, 0     //No ContentType
             );
    
    if( pExpiresHeader != NULL )
    {
        free( (PVOID) pExpiresHeader->HeaderValue );
    }

    if( hr != S_OK )
    {
        pOutgoingSubscribeTransaction->OnTransactionDone();
        return hr;
    }

    if( (m_BuddyState != BUDDY_STATE_RESPONSE_RECVD) &&
        (m_BuddyState != BUDDY_STATE_ACCEPTED) )
    {
        m_BuddyState = BUDDY_STATE_REQUEST_SENT;
    }

    LOG(( RTC_TRACE, "CSIPBuddy::CreateOutgoingSubscribe - Exited- %p", this ));
    return S_OK;
}


HRESULT
CSIPBuddy::CreateOutgoingUnsub(
    IN  BOOL                        AuthHeaderSent,
    IN  SIP_HEADER_ARRAY_ELEMENT   *pAuthHeaderElement,
    IN  ULONG                       dwNoOfHeaders
    )
{
    HRESULT hr;
    OUTGOING_UNSUB_TRANSACTION *pOutgoingUnsubTransaction;
    SIP_HEADER_ARRAY_ELEMENT    HeaderElementArray[2];
    DWORD                       dwNoOfHeader = 0;
    SIP_HEADER_ARRAY_ELEMENT   *ExpHeaderElement;

    LOG(( RTC_TRACE, "CSIPBuddy::CreateOutgoingUnsub - Entered- %p", this ));

    if( (IsSessionDisconnected() == TRUE) && (AuthHeaderSent==FALSE) )
    {
        // do nothing
        LOG(( RTC_ERROR, "Buddy-CreateOutgoingUnsub-buddy already dropped-%p",
            this ));
        
        return S_OK;
    }

    ExpHeaderElement = &HeaderElementArray[0];

    ExpHeaderElement->HeaderId = SIP_HEADER_EXPIRES;
    ExpHeaderElement->HeaderValueLen = strlen( UNSUB_EXPIRES_HEADER_TEXT );
    ExpHeaderElement->HeaderValue =
            new CHAR[ ExpHeaderElement->HeaderValueLen + 1 ];

    if( ExpHeaderElement->HeaderValue == NULL )
    {
        LOG(( RTC_ERROR, "Buddy-CreateOutgoingUnsub-could not alloc expire header-%p",
            this ));
        
        return E_OUTOFMEMORY;
    }

    strcpy( ExpHeaderElement->HeaderValue, UNSUB_EXPIRES_HEADER_TEXT );
    dwNoOfHeader++;

    if (pAuthHeaderElement != NULL)
    {
        HeaderElementArray[dwNoOfHeader] = *pAuthHeaderElement;
        dwNoOfHeader++;
    }
    
    pOutgoingUnsubTransaction =
        new OUTGOING_UNSUB_TRANSACTION(
                static_cast <SIP_MSG_PROCESSOR*> (this),
                SIP_METHOD_SUBSCRIBE,
                GetNewCSeqForRequest(),
                AuthHeaderSent,
                SIP_MSG_PROC_TYPE_BUDDY );
    
    if( pOutgoingUnsubTransaction == NULL )
    {
        LOG(( RTC_ERROR, "Buddy-CreateOutgoingUnsub-could alloc transaction-%p",
            this ));
        
        delete ExpHeaderElement->HeaderValue;
        return E_OUTOFMEMORY;
    }

    hr = pOutgoingUnsubTransaction -> CheckRequestSocketAndSendRequestMsg(
             (m_Transport == SIP_TRANSPORT_UDP) ?
             SIP_TIMER_RETRY_INTERVAL_T1 :
             SIP_TIMER_INTERVAL_AFTER_INVITE_SENT_TCP,
             HeaderElementArray, dwNoOfHeader,
             NULL, 0,
             NULL, 0     //No ContentType
             );
    
    delete ExpHeaderElement->HeaderValue;

    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "Buddy-CreateOutgoingUnsub-could not create request msg-%p",
            this ));

        pOutgoingUnsubTransaction->OnTransactionDone();
        return hr;
    }

    LOG(( RTC_TRACE, "CSIPBuddy::CreateOutgoingUnsub - Exited- %p", this ));

    return S_OK;
}


HRESULT
CSIPBuddy::CreateIncomingTransaction(
    IN  SIP_MESSAGE *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;
    INT     ExpireTimeout;

    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingTransaction - Entered- %p", this ));
    
    switch( pSipMsg->GetMethodId() )
    {
    case SIP_METHOD_NOTIFY:

        ExpireTimeout = pSipMsg -> GetExpireTimeoutFromResponse(
                NULL, 0, SUBSCRIBE_DEFAULT_TIMER );

        if( ExpireTimeout == 0 )
        {
            hr = CreateIncomingUnsubNotifyTransaction( pSipMsg, pResponseSocket );
        }
        else
        {
            hr = CreateIncomingNotifyTransaction( pSipMsg, pResponseSocket );
        }
        
        break;

    case SIP_METHOD_SUBSCRIBE:
        
        if( pSipMsg -> GetExpireTimeoutFromResponse( NULL, 0, 
            SUBSCRIBE_DEFAULT_TIMER ) == 0 )
        {
            // UNSUB message.
            hr = CreateIncomingUnsubTransaction( pSipMsg, pResponseSocket );
        }
        
        break;

    default:
        // send method not allowed.
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        405,
                                        NULL,
                                        0 );
        break;
    }
    
    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingTransaction - Exited- %p", this ));
    return hr;
}


HRESULT
CSIPBuddy::CreateIncomingUnsubTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;

    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingUnsubTransaction-Entered-%p",
        this ));

    // Cancel all existing transactions.
    INCOMING_UNSUB_TRANSACTION *pIncomingUnsubTransaction
        = new INCOMING_UNSUB_TRANSACTION(   static_cast<SIP_MSG_PROCESSOR *> (this),
                                            pSipMsg->GetMethodId(),
                                            pSipMsg->GetCSeq(),
                                            FALSE );

    if( pIncomingUnsubTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = pIncomingUnsubTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if( hr != S_OK )
    {
        goto error;
    }
    
    hr = pIncomingUnsubTransaction->ProcessRequest( pSipMsg, pResponseSocket );
    if( hr != S_OK )
    {
        // Should not delete the transaction. The transaction
        // should handle the error and delete itself
        return hr;
    }

    if( IsSessionDisconnected() == FALSE )
    {
        m_BuddyState = BUDDY_STATE_UNSUBSCRIBED;
        m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;
    
        // Notify should always be done last.
        if( m_pNotifyInterface != NULL )
        {
            LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed:%p", this ));
            m_pNotifyInterface -> BuddyUnsubscribed();
        }
    }

    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingUnsubTransaction - Exited- %p",
        this ));
    return hr;

error:
    pIncomingUnsubTransaction->OnTransactionDone();
    return hr;
}


HRESULT
CSIPBuddy::CreateIncomingUnsubNotifyTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr = S_OK;
    INCOMING_NOTIFY_TRANSACTION    *pIncomingUnsubTransaction = NULL;
    PSTR                            Header = NULL;
    ULONG                           HeaderLen = 0;

    LOG(( RTC_TRACE,
        "CSIPBuddy::CreateIncomingUnsubNotifyTransaction-Entered-%p", this ));
    
    if( m_BuddyState == BUDDY_STATE_RESPONSE_RECVD )
    {            
        //This is the first notify message.

        //We should also let the buddy set a new From tag, since this could
        //be the very first message we receive from the buddy endpoint.
        
        hr = pSipMsg->GetSingleHeader( SIP_HEADER_FROM, &Header, &HeaderLen );
        if( hr != S_OK )
        {
            return hr;
        }

        //Add the tag to m_Remote so that it would be used from henceforth.
        hr = AddTagFromRequestOrResponseToRemote( Header, HeaderLen );
        if( hr != S_OK )
        {
            return hr;
        }
    }
    
    // Cancel all existing transactions.
    INCOMING_NOTIFY_TRANSACTION *pIncomingNotifyTransaction
        = new INCOMING_NOTIFY_TRANSACTION(  static_cast<SIP_MSG_PROCESSOR *> (this),
                                            pSipMsg->GetMethodId(),
                                            pSipMsg->GetCSeq(),
                                            FALSE );

    if( pIncomingNotifyTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = pIncomingNotifyTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if( hr != S_OK )
    {
        goto error;
    }
    
    hr = pIncomingNotifyTransaction->ProcessRequest( pSipMsg, pResponseSocket );
    if( hr != S_OK )
    {
        // Should not delete the transaction. The transaction 
        // should handle the error and delete itself
        return hr;
    }

    // Notify should always be done last.
    if( IsSessionDisconnected() == FALSE )
    {
        m_BuddyState = BUDDY_STATE_UNSUBSCRIBED;
        m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;

        if( m_pNotifyInterface != NULL )
        {
            LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed:%p", this ));
            
            m_pNotifyInterface -> BuddyUnsubscribed();
        }
    }

    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingUnsubNotifyTransaction-Exited-%p",
        this ));
    return hr;

error:
    pIncomingUnsubTransaction -> OnTransactionDone();
    return hr;
}


//
// The ISIPBuddy implementation. This interface is implemented by
// CSIPBuddy class.
//


/*
Routine Description:
    Get the presence information of this buddy. This function will be called by
    the UA typically when it receives a SIPBUDDY_PRESENCEINFO_CHANGED event.

    Parameters:
        SIP_PRESENCE_INFO * pSipBuddyPresenceInfo - The pointer of the structure
            allocated by the calling entity. This structure is filled in with 
            available presence information about this buddy.

    Return Value:
        HRESULT 
        S_OK - The operation is successful.
        E_FAIL - The presence information could not be fetched. 

*/

STDMETHODIMP
CSIPBuddy::GetPresenceInformation(
    IN OUT  SIP_PRESENCE_INFO * pSipBuddyPresenceInfo
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "CSIPBuddy::GetPresenceInformation - Entered- %p", this ));
    
    CopyMemory( (PVOID)pSipBuddyPresenceInfo, 
        (PVOID)&m_PresenceInfo, 
        sizeof SIP_PRESENCE_INFO );

    LOG(( RTC_TRACE, "CSIPBuddy::GetPresenceInformation - Exited- %p", this ));
    return S_OK;
}


STDMETHODIMP
CSIPBuddy::SetNotifyInterface(
    IN   ISipBuddyNotify *    NotifyInterface
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "CSIPBuddy::SetNotifyInterface - Entered- %p", this ));

    m_pNotifyInterface = NotifyInterface;

    LOG(( RTC_TRACE, "CSIPBuddy::SetNotifyInterface - Exited- %p", this ));
    return S_OK;
}


//
// CSIPBuddy functions not exposed to the application.
//


CSIPBuddy::CSIPBuddy(
    IN  SIP_STACK          *pSipStack,
    IN  LPWSTR              lpwstrFriendlyName,
    IN  LPWSTR              lpwstrPresentityURI,
    IN  SIP_PROVIDER_ID    *pProviderID,
    IN  REDIRECT_CONTEXT   *pRedirectContext,
    OUT BOOL*               fSuccess
    ) :
    SIP_MSG_PROCESSOR( SIP_MSG_PROC_TYPE_BUDDY, pSipStack, pRedirectContext ),
    TIMER( pSipStack -> GetTimerMgr() )
{
    ULONG   ulFriendlyNameLen;
    ULONG   ulPresentityURILen;

    LOG(( RTC_TRACE, "CSIPBuddy::CSIPBuddy - Entered- %p", this ));

    *fSuccess = FALSE;
    
    m_lpwstrFriendlyName = NULL;

    ulFriendlyNameLen = wcslen( lpwstrFriendlyName );

    if( ulFriendlyNameLen != 0 )
    {
        m_lpwstrFriendlyName = new WCHAR[ulFriendlyNameLen + 1 ];
        if( m_lpwstrFriendlyName == NULL )
        {
            return;
        }

        CopyMemory( m_lpwstrFriendlyName, 
            lpwstrFriendlyName, 
            (ulFriendlyNameLen+1) * sizeof WCHAR );
    }

    ulPresentityURILen = wcslen( lpwstrPresentityURI );
    m_lpwstrPresentityURI = new WCHAR[ulPresentityURILen + 1 ];
    if( m_lpwstrPresentityURI == NULL )
    {
        return;
    }

    CopyMemory( m_lpwstrPresentityURI, 
        lpwstrPresentityURI, 
        (ulPresentityURILen+1) * sizeof WCHAR );

    *fSuccess = TRUE;
    
    ZeroMemory( (PVOID)&m_PresenceInfo, sizeof SIP_PRESENCE_INFO );
    m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;

    ulNumOfNotifyTransaction = 0;
    
    m_ProviderGuid = *pProviderID;

    //m_pRedirectContext = NULL;

    m_BuddyContactAddress[0] = NULL_CHAR;
    m_pNotifyInterface = NULL;
    m_BuddyState = BUDDY_STATE_NONE;
    m_NotifySeenAfterLastRefresh = FALSE;
    m_dwExpires = 1800;
    m_RetryState = BUDDY_RETRY_NONE;

    m_expiresTimeout = SUBSCRIBE_DEFAULT_TIMER;

    LOG(( RTC_TRACE, "CSIPBuddy::CSIPBuddy - Exited:%p", this ));
    return;
}


CSIPBuddy::~CSIPBuddy()
{
    if( m_lpwstrFriendlyName != NULL )
    {
        delete m_lpwstrFriendlyName;
        m_lpwstrFriendlyName = NULL;
    }

    if( m_lpwstrPresentityURI != NULL )
    {
        delete m_lpwstrPresentityURI;
        m_lpwstrPresentityURI = NULL;
    }

    if( IsTimerActive() )
    {
        KillTimer();
    }

    LOG(( RTC_TRACE, "CSIPBuddy object deleted:%p", this ));
}


VOID
CSIPBuddy::OnError()
{
    InitiateBuddyTerminationOnError( 0 );
}


STDMETHODIMP_(ULONG)
CSIPBuddy::AddRef()
{
    ULONG   ulRefCount = MsgProcAddRef();

    LOG(( RTC_TRACE, "CSIPBuddy::AddRef-%p-Refcount:%d", this, ulRefCount ));
    return ulRefCount;
}


STDMETHODIMP_(ULONG)
CSIPBuddy::Release()
{
    ULONG   ulRefCount = MsgProcRelease();
    
    LOG(( RTC_TRACE, "CSIPBuddy::Release-%p-Refcount:%d", this, ulRefCount ));
    return ulRefCount;
}


STDMETHODIMP
CSIPBuddy::QueryInterface(REFIID riid, LPVOID *ppv)
{
    LOG(( RTC_TRACE, "CSIPBuddy::QueryInterface -Entered - %p", this ));
    
    if (riid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if (riid == IID_ISIPBuddy)
    {
        *ppv = static_cast<ISIPBuddy *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();

    LOG(( RTC_TRACE, "CSIPBuddy::QueryInterface -Exited - %p", this ));
    return S_OK;
}


HRESULT
CSIPBuddy::CreateIncomingNotifyTransaction(
    IN SIP_MESSAGE  *pSipMsg,
    IN ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT                         hr = S_OK;
    INCOMING_NOTIFY_TRANSACTION    *pIncomingNotifyTransaction = NULL;
    PSTR                            Header = NULL;
    ULONG                           HeaderLen = 0;
    PARSED_PRESENCE_INFO            ParsedPresenceInfo;

    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingNotifyTransaction-Entered - %p",
        this ));
    
    // We have Message Body. Check type.
    hr = pSipMsg -> GetSingleHeader( 
                        SIP_HEADER_CONTENT_TYPE, 
                        &Header, 
                        &HeaderLen );

    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "CreateIncomingNotifyTransaction-no Content-Type %.*s",
            HeaderLen, Header ));

        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        400,
                                        NULL,
                                        0 );
    
        return E_FAIL;
    }

    if( !IsContentTypeXpidf( Header, HeaderLen ) )
    {
        LOG((RTC_ERROR, "CreateIncomingNotifyTransaction-invalid Content-Type %.*s",
            HeaderLen, Header ));

        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        415,
                                        NULL,
                                        0 );
    
        return E_FAIL;
    }

    //We should also let the buddy set a new From tag, since this could
    //be the very first message we receive from the buddy endpoint.
    
    hr = pSipMsg->GetSingleHeader( SIP_HEADER_FROM, &Header, &HeaderLen );
    if( hr != S_OK )
    {
        return hr;
    }

    //Add the tag to m_Remote so that it would be used from henceforth.
    hr = AddTagFromRequestOrResponseToRemote( Header, HeaderLen );
    if( hr != S_OK )
    {
        return hr;
    }
        
    if( (m_BuddyState == BUDDY_STATE_RESPONSE_RECVD) ||
        (m_BuddyState == BUDDY_STATE_REQUEST_SENT) )
    {            
        //This is the first notify message.

        m_BuddyState = BUDDY_STATE_ACCEPTED;
    }
    
    // This is a good NOTIFY message after the last refresh
    m_NotifySeenAfterLastRefresh = TRUE;
    
    // Create a new NOTIFY transaction.
    pIncomingNotifyTransaction = new INCOMING_NOTIFY_TRANSACTION(
                                        static_cast <SIP_MSG_PROCESSOR*>(this),
                                        pSipMsg->GetMethodId(),
                                        pSipMsg->GetCSeq(),
                                        FALSE );

    if( pIncomingNotifyTransaction == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //
    // This should make suure that all the subsequent refreshes are sent
    // directly to the watcher machine if no record route in invoked
    //
    hr = pIncomingNotifyTransaction->SetResponseSocketAndVia(
             pSipMsg, pResponseSocket);
    if (hr != S_OK)
    {
        goto cleanup;
    }

    // Update the state of buddy object and notify the app about that.
    //Process the state of the invloved phone parties.
    hr = ParseBuddyNotifyMessage( pSipMsg, &ParsedPresenceInfo );
    if( hr != S_OK )
    {
        pIncomingNotifyTransaction->CreateAndSendResponseMsg(
                 488,
                 SIP_STATUS_TEXT(488),
                 SIP_STATUS_TEXT_SIZE(488),
                 NULL,   // No Method string
                 FALSE,  // No Contact Header
                 NULL, 0, //No message body
                 NULL, 0 // No content Type
                 );

        goto cleanup;
    }

    hr = pIncomingNotifyTransaction->ProcessRequest( pSipMsg, pResponseSocket );
    if( hr != S_OK )
    {
        //Should not delete the transaction. The transaction
        //should handle the error and delete itself
        return hr;
    }

    if( IsSessionDisconnected() == FALSE )
    {
        hr = NotifyPresenceInfoChange( &ParsedPresenceInfo );
    }

    LOG(( RTC_TRACE, "CSIPBuddy::CreateIncomingNotifyTransaction-Exited - %p",
        this ));
    
    return S_OK;

cleanup:

    if( pIncomingNotifyTransaction != NULL )
    {
        pIncomingNotifyTransaction -> OnTransactionDone();
    }

    return hr;
}

HRESULT
CSIPBuddy::ParseBuddyNotifyMessage(
    IN  SIP_MESSAGE            *pSipMsg,
    OUT PARSED_PRESENCE_INFO   *pParsedPresenceInfo
    )
{
    HRESULT     hr = S_OK;
    DWORD       dwXMLBlobLen = 0;
    DWORD       dwUnParsedLen = 0;
    PSTR        pBuddyXMLBlob = NULL;
    PSTR        pXMLBlobTag = NULL, pBuffer = NULL;
    DWORD       dwTagLen = 0;

    LOG(( RTC_TRACE, "CSIPBuddy::ProcessBuddyNotifyMessage-Entered-%p", this ));
    
    if( pSipMsg -> MsgBody.Length == 0 )
    {
        //no state to update
        return hr;
    }

    pBuddyXMLBlob = pSipMsg -> MsgBody.GetString( pSipMsg->BaseBuffer );
    dwXMLBlobLen = pSipMsg -> MsgBody.Length;

    //Put a \0 at the end of the XML blob. This would help us in parsing.
    pBuddyXMLBlob[ dwXMLBlobLen-1 ] = '\0';

    pBuffer = pXMLBlobTag = new CHAR[ dwXMLBlobLen ];
    if( pXMLBlobTag == NULL )
    {
                    
        LOG((RTC_ERROR, "Presence parsing-allocating xml blob failed" ));
        return E_OUTOFMEMORY;
    }

    //Get the XML version tag.
    hr = GetNextTag( pBuddyXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "Presence parsing-No xml version tag" ));
        delete pBuffer;
        return hr;
    }
    
    if( GetPresenceTagType( &pXMLBlobTag, dwTagLen ) != XMLVER_TAG )
    {
        LOG((RTC_ERROR, "Presence parsing- bad version tag" ));
        delete pBuffer;
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;
    
    //Get the DOCTYPE tag.
    pXMLBlobTag = pBuffer;
    hr = GetNextTag( pBuddyXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "Presence parsing-No doctype tag" ));
        delete pBuffer;
        return hr;
    }
    
    if( GetPresenceTagType( &pXMLBlobTag, dwTagLen ) != DOCTYPE_TAG )
    {
        LOG((RTC_ERROR, "Presence parsing-bad doctype tag" ));
        delete pBuffer;
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;
    
    //Get the presence tag.
    pXMLBlobTag = pBuffer;
    hr = GetNextTag( pBuddyXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "Presence parsing-no presence tag" ));
        delete pBuffer;
        return hr;
    }
    
    if( GetPresenceTagType( &pXMLBlobTag, dwTagLen ) != PRESENCE_TAG )
    {
        LOG((RTC_ERROR, "Presence parsing-bad presence tag" ));
        delete pBuffer;
        return E_FAIL;
    }

    dwXMLBlobLen -= dwTagLen + 2;

    // skip unknown tags
    SkipUnknownTags( pBuddyXMLBlob, pXMLBlobTag, dwXMLBlobLen );

    //Get the presentity URI.
    pXMLBlobTag = pBuffer;
    hr = GetNextTag( pBuddyXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        delete pBuffer;
        return hr;
    }

    hr = VerifyPresentityURI( pXMLBlobTag, 
        dwTagLen, 
        pXMLBlobTag );

    dwXMLBlobLen -= dwTagLen + 3;
    
    if( hr != S_OK )
    {
        delete pBuffer;
        return hr;
    }

    // skip unknown tags
    SkipUnknownTags( pBuddyXMLBlob, pXMLBlobTag, dwXMLBlobLen );

    //Right now we support only one atom per notify.
    hr = GetAtomPresenceInformation( pBuddyXMLBlob, dwXMLBlobLen,
                pParsedPresenceInfo, pXMLBlobTag );

    delete pBuffer;

    LOG(( RTC_TRACE, "CSIPBuddy::ProcessBuddyNotifyMessage-Exited-%p", this ));
    return hr;
}



HRESULT
CSIPBuddy::NotifyPresenceInfoChange(
    PARSED_PRESENCE_INFO*   pParsedPresenceInfo
    )
{
    PLIST_ENTRY             pLE;
    ADDRESS_PRESENCE_INFO  *pAddressInfo;
    BOOL                    fIPDeviceSeen = FALSE;
    ULONG                   ulPhoneDeviceSeen = 0;

    SIP_PRESENCE_INFO       PresenceInfo;

    LOG(( RTC_TRACE, "CSIPBuddy::NotifyPresenceInfoChange-Entered-%p", this ));

    ZeroMemory(&PresenceInfo, sizeof(PresenceInfo));

    PresenceInfo.presenceStatus = BUDDY_ONLINE;

    for(    pLE = pParsedPresenceInfo->LEAddressInfo.Flink;
            pLE != &pParsedPresenceInfo->LEAddressInfo;
            pLE = pLE->Flink )
    {
        pAddressInfo = CONTAINING_RECORD( pLE, ADDRESS_PRESENCE_INFO, ListEntry );
        
        if( pAddressInfo -> fPhoneNumber == FALSE )
        {
            //We look at only one IP device per buddy
            if( fIPDeviceSeen == FALSE )
            {
                fIPDeviceSeen = TRUE;
                //This is an IP device.
                strcpy( m_BuddyContactAddress, pAddressInfo -> pstrAddressURI );

                PresenceInfo.activeStatus = pAddressInfo -> addressActiveStatus;
                PresenceInfo.activeMsnSubstatus = pAddressInfo -> addrMsnSubstatus;
                PresenceInfo.sipCallAcceptance = 
                    pAddressInfo -> addrMMCallStatus;
                PresenceInfo.IMAcceptnce = pAddressInfo -> addrIMStatus;
                PresenceInfo.appsharingStatus = 
                    pAddressInfo -> addrAppsharingStatus;

                strcpy( PresenceInfo.pstrSpecialNote, 
                    pAddressInfo -> pstrMiscInfo );
            }
        }
        else if( ulPhoneDeviceSeen < 2 )
        {
            //We look at onlu two phone numbers per buddy.
            ulPhoneDeviceSeen++;

            if( ulPhoneDeviceSeen == 1 )
            {
                PresenceInfo.phonesAvailableStatus.fLegacyPhoneAvailable = TRUE;
                
                strcpy( PresenceInfo.phonesAvailableStatus.pstrLegacyPhoneNumber,
                    pAddressInfo -> pstrAddressURI );
            }
            else
            {
                PresenceInfo.phonesAvailableStatus.fCellPhoneAvailable = TRUE;
                
                strcpy( PresenceInfo.phonesAvailableStatus.pstrCellPhoneNumber,
                    pAddressInfo -> pstrAddressURI );
            }
        }
    }

    if( !IsPresenceInfoSame( &m_PresenceInfo, &PresenceInfo ) )
    {
        CopyMemory(&m_PresenceInfo, &PresenceInfo, sizeof(m_PresenceInfo));

        //Notify the user about the new presence info.
        if( m_pNotifyInterface != NULL )
        {
            m_pNotifyInterface -> BuddyInfoChange();
        }
    }

    LOG(( RTC_TRACE, "CSIPBuddy::NotifyPresenceInfoChange - Exited - %p", this ));
    return S_OK;
}


HRESULT
CSIPBuddy::ProcessRedirect(
    IN SIP_MESSAGE *pSipMsg
    )
{
    // For now redirects are also failures
    HRESULT hr;
    
    ENTER_FUNCTION("CSIPBuddy::ProcessRedirect");

    // This SUB session is dead. A new session will be created. 
    // Put the buddy in dropped state.
    m_BuddyState = BUDDY_STATE_DROPPED;

    if( m_pRedirectContext == NULL )
    {
        m_pRedirectContext = new REDIRECT_CONTEXT();
        if( m_pRedirectContext == NULL )
        {
            LOG((RTC_ERROR, "%s allocating redirect context failed",
                 __fxName));
            return E_OUTOFMEMORY;
        }
    }

    hr = m_pRedirectContext->AppendContactHeaders(pSipMsg);
    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s AppendContactHeaders failed %x",
             __fxName, hr));
        // The session is Shutdown after we return an error from this function
        m_pRedirectContext->Release();
        m_pRedirectContext = NULL;
        return hr;
    }

    SIP_CALL_STATUS CallStatus;
    LPWSTR          wsStatusText = NULL;
    PSTR            ReasonPhrase = NULL;
    ULONG           ReasonPhraseLen = 0;
    

    pSipMsg -> GetReasonPhrase(&ReasonPhrase, &ReasonPhraseLen);
    
    if (ReasonPhrase != NULL)
    {
        hr = UTF8ToUnicode(ReasonPhrase, ReasonPhraseLen,
                           &wsStatusText);
        if (hr != S_OK)
        {
            wsStatusText = NULL;
        }
    }
    
    CallStatus.State             = SIP_CALL_STATE_DISCONNECTED;
    CallStatus.Status.StatusCode =
        HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode());
    CallStatus.Status.StatusText = wsStatusText;

    // Keep a reference till the notify completes to make sure
    // that the CSIPBuddy object is alive when the notification
    // returns.
    AddRef();
    if( m_pNotifyInterface != NULL )
    {
        hr = m_pNotifyInterface->NotifyRedirect(m_pRedirectContext,
                                            &CallStatus);
    }
    else
    {
        LOG((RTC_ERROR, "%s - NotifyInterface is NULL", __fxName));
    }

    // If a new call is created as a result that call will AddRef()
    // the redirect context.
    if(m_pRedirectContext != NULL)
        m_pRedirectContext->Release();
    m_pRedirectContext = NULL;
    if (wsStatusText != NULL)
        free(wsStatusText);

    Release();

    if (hr != S_OK)
    {
        LOG((RTC_ERROR, "%s NotifyRedirect failed %x",
             __fxName, hr));
    }

    return hr;
}


VOID
CSIPBuddy::HandleBuddySuccessfulResponse(
    IN  SIP_MESSAGE    *pSipMsg
    )
{
    PSTR    LocalContact;
    ULONG   LocalContactLen;
    HRESULT hr = S_OK;
    INT     expireTimeout = 0;
    PSTR    ToHeader;
    ULONG   ToHeaderLen = 0;

    LOG((RTC_TRACE, "CSIPBuddy::HandleBuddySuccessfulResponse-Entered:%p", this ));
    
    if( m_BuddyState != BUDDY_STATE_ACCEPTED )
    {
        m_BuddyState = BUDDY_STATE_RESPONSE_RECVD;
    }

    hr = pSipMsg -> GetSingleHeader(SIP_HEADER_TO, &ToHeader, &ToHeaderLen );

    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "To header not found" ));
        return;
    }

    hr = AddTagFromRequestOrResponseToRemote( ToHeader, ToHeaderLen );

    if( hr != S_OK )
    {
        LOG(( RTC_ERROR, "Buddy-AddTagFromResponseToRemote failed %x", hr ));
    }

    //In case of success refresh the subscription

    expireTimeout = pSipMsg  -> GetExpireTimeoutFromResponse(
        NULL, 0, SUBSCRIBE_DEFAULT_TIMER );

    if( (expireTimeout != 0) && (expireTimeout != -1) )
    {
        m_expiresTimeout = expireTimeout;
    }            

    if( (m_BuddyState == BUDDY_STATE_ACCEPTED) &&
        (m_expiresTimeout > FIVE_MINUTES) )
    {        
        //
        // This buddy has already been accepted. So we should recv another
        // NOTIFY in 5 minutes. If we dont recv it that means the buddy
        // machine crashed. In that case we drop and recreate the session.
        //

        //
        // If the SUB refresh timeout is less than 5 minutes we dont need this
        // mechanism to find out if the buddy machine is still alive or not.
        //

        m_NotifySeenAfterLastRefresh = FALSE;
                
        LOG(( RTC_TRACE, "Waitng for a notify within 5 minutes", this ));

        m_RetryState = BUDDY_WAIT_NOTIFY;

        hr = StartTimer( FIVE_MINUTES * 1000 );
    }
    else
    {
        LOG(( RTC_TRACE, "Will try to subscribe after %d seconds :%p", 
            m_expiresTimeout, this ));

        m_RetryState = BUDDY_REFRESH;

        hr = StartTimer( m_expiresTimeout * 1000 );
    }
}


VOID
CSIPBuddy::OnTimerExpire()
{
    HRESULT     hr;
    CSIPBuddy  *pSipBuddy = NULL;

    ENTER_FUNCTION("CSIPBuddy::OnTimerExpire");

    if( m_RetryState == BUDDY_REFRESH )
    {
        //
        //  Send the refresh SUB message.
        //
        hr = CreateOutgoingSubscribe( FALSE, FALSE, NULL, 0 );
    
        if( hr != S_OK )
        {
            AddRef();

            LOG((RTC_ERROR, "%s CreateOutgoingSubscribe failed %x",
                 __fxName, hr));

            InitiateBuddyTerminationOnError( hr );

            Release();
        }
    }
    else if( m_RetryState == BUDDY_RETRY )
    {
        if (m_pNotifyInterface != NULL)
        {
            //
            // The retry timer was started because there was some error
            // So we were waiting for 5 minutes. Now the core will delete
            // this buddy session and recreate a new one.
            //
            LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed:%p", this ));
            m_pNotifyInterface -> BuddyUnsubscribed();
        }
        else
        {
            LOG(( RTC_WARN, "%s - m_pNotifyInterface is NULL", __fxName ));
        }
    }
    else if( m_RetryState == BUDDY_WAIT_NOTIFY )
    {
        if( m_NotifySeenAfterLastRefresh == TRUE )
        {
            LOG(( RTC_TRACE, "Will try to subscribe after %d seconds :%p",
                m_expiresTimeout - FIVE_MINUTES, this ));

            m_RetryState = BUDDY_REFRESH;

            // Five minutes have already elapsed.
            hr = StartTimer( (m_expiresTimeout-FIVE_MINUTES) * 1000 );
        }
        else if( m_pNotifyInterface != NULL )
        {
            //
            // We didnt see a NOTIFY to the last refresh SUB even though this 
            // session has been accepted. So drop and recreate it.
            //
            
            // Create UNSUB transaction
            hr = CreateOutgoingUnsub( FALSE, NULL, 0 );
            if( hr != S_OK )
            {
                LOG((RTC_ERROR, "%s CreateOutgoingUnsub failed %x", __fxName, hr));
            }

            m_BuddyState = BUDDY_STATE_DROPPED;
            m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;

            LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed:%p", this ));
            m_pNotifyInterface -> BuddyUnsubscribed();
        }
        else
        {
            LOG(( RTC_WARN, "%s - m_pNotifyInterface is NULL", __fxName ));
        }
    }

}


// Note that this function notifies the Core and this call could
// block and on return the transaction and call could both be deleted.
// So, we should make sure we don't touch any state after calling this
// function.
VOID
CSIPBuddy::InitiateBuddyTerminationOnError(
    IN ULONG StatusCode  //= 0
    )
{
    ENTER_FUNCTION("CSIPBuddy::InitiateBuddyTerminationOnError");
    
    HRESULT hr;

    if( (m_BuddyState == BUDDY_STATE_UNSUBSCRIBED)  ||
        (m_BuddyState == BUDDY_STATE_DROPPED) )
    {
        // do nothing
        return;
    }
    
    // Create a UNSUB transaction
    hr = CreateOutgoingUnsub( FALSE, NULL, 0 );
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "%s CreateOutgoingUnsub failed %x", __fxName, hr));
    }

    m_BuddyState = BUDDY_STATE_DROPPED;
    m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;

    if( IsTimerActive() )
    {
        KillTimer();
    }

    //Start the retry timer 
    m_RetryState = BUDDY_RETRY;

    //Retry after 5 minutes
    hr = StartTimer( FIVE_MINUTES * 1000 );

    // Notify the core.. May block
    if(m_pNotifyInterface)
    {    
        m_pNotifyInterface -> BuddyRejected( StatusCode );
    }
}


VOID CSIPBuddy::BuddyUnsubscribed()
{
    if( (m_BuddyState == BUDDY_STATE_UNSUBSCRIBED)  ||
        (m_BuddyState == BUDDY_STATE_DROPPED) )
    {
        // do nothing
        return;
    }

    if( m_pNotifyInterface != NULL )
    {
        LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed:%p", this ));
        m_pNotifyInterface -> BuddyUnsubscribed();
    }
}



HRESULT
CSIPBuddy::VerifyPresentityURI( 
    IN  PSTR    pXMLBlobTag, 
    IN  DWORD   dwTagLen, 
    OUT PSTR    pstrPresentityURI
    )
{
    PSTR    pstrTemp;
    DWORD   dwTagType;

    dwTagType = GetPresenceTagType( &pXMLBlobTag, dwTagLen ); 
    
    if( dwTagType != PRESENTITY_TAG )
    {
        return E_FAIL;
    }

    SkipWhiteSpaces( pXMLBlobTag );

    if( strncmp( pXMLBlobTag, "uri=", strlen("uri=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("uri=");

    SkipWhiteSpaces( pXMLBlobTag );

    if( strncmp( pXMLBlobTag, "\"sip:", strlen("\"sip:") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("\"sip:");

    while( (*pXMLBlobTag != ';') && (*pXMLBlobTag != QUOTE_CHAR) && 
        (*pXMLBlobTag != NULL_CHAR) )
    {
        *pstrPresentityURI++ = *pXMLBlobTag++;
    }

    if( *pXMLBlobTag == NULL_CHAR )
    {
        return E_FAIL;
    }

    *pstrPresentityURI = NULL_CHAR;
    return S_OK;

}


HRESULT
CSIPBuddy::GetAtomPresenceInformation(
    IN  PSTR                    pstrXMLBlob,
    IN  DWORD                   dwXMLBlobLen,
    OUT PARSED_PRESENCE_INFO*   pParsedPresenceInfo,
    IN  PSTR                    pXMLBlobTag
    )
{
    HRESULT hr;

    // skip unknown tags
    SkipUnknownTags( pstrXMLBlob, pXMLBlobTag , dwXMLBlobLen );

    hr = GetAtomID( pstrXMLBlob, dwXMLBlobLen, pXMLBlobTag,
        pParsedPresenceInfo->pstrAtomID, ATOMID_LEN );

    if( hr != S_OK )
    {
        return hr;
    }

    // skip unknown tags
    SkipUnknownTags( pstrXMLBlob, pXMLBlobTag , dwXMLBlobLen );

    //There should be atleast one address info structure in the atom.
    hr = GetAddressInfo( pstrXMLBlob, dwXMLBlobLen,
        pParsedPresenceInfo, pXMLBlobTag );

    if( hr != S_OK )
    {
        return hr;
    }

    while( hr == S_OK )
    {
        hr = GetAddressInfo( pstrXMLBlob, dwXMLBlobLen,
            pParsedPresenceInfo, pXMLBlobTag );
    }

    if( hr != E_END_OF_ATOM )
    {
        return hr;
    }

    return S_OK;
}


HRESULT
CSIPBuddy::GetAtomID(
    IN  PSTR&                   pstrXMLBlob, 
    IN  DWORD&                  dwXMLBlobLen,
    IN  PSTR                    pXMLBlobTag,
    OUT PSTR                    pstrAtomID,
    IN  DWORD                   dwAtomIDLen
    )
{
    DWORD   dwTagLen = 0;
    HRESULT hr;
    DWORD   dwTagType;
    DWORD   iIndex = 0;

    // Get the atom ID tag.
    hr = GetNextTag( pstrXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        return hr;
    }
    
    dwTagType = GetPresenceTagType( &pXMLBlobTag, dwTagLen );

    if( dwTagType != ATOMID_TAG )
    {
        //Invalid presence document.
        return E_FAIL;
    }
    
    dwXMLBlobLen -= dwTagLen + 2;
    
    SkipWhiteSpaces( pXMLBlobTag );

    if( strncmp( pXMLBlobTag, "id=", strlen( "id=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen( "id=");

    SkipWhiteSpaces( pXMLBlobTag );

    //Extract quoted string.
    if( *pXMLBlobTag++ != QUOTE_CHAR )
    {
        return E_FAIL;
    }

    while( *pXMLBlobTag != QUOTE_CHAR )
    {
        if( (*pXMLBlobTag == NEWLINE_CHAR) || (*pXMLBlobTag == TAB_CHAR) ||
            (*pXMLBlobTag == BLANK_CHAR) || (*pXMLBlobTag == NULL_CHAR) )
        {
            return E_FAIL;
        }
        
        pstrAtomID[iIndex++] = *pXMLBlobTag++;
        if( iIndex == dwAtomIDLen )
        {
            pstrAtomID[iIndex] = NULL_CHAR;
            return S_OK;
        }
    }

    pstrAtomID[iIndex] = NULL_CHAR;        
    return S_OK;
}

    
HRESULT
CSIPBuddy::GetAddressInfo(
    IN  PSTR&                   pstrXMLBlob, 
    IN  DWORD&                  dwXMLBlobLen,
    OUT PARSED_PRESENCE_INFO*   pParsedPresenceInfo,
    IN  PSTR                    pXMLBlobTag
    )
{
    ADDRESS_PRESENCE_INFO * pAddrPresenceInfo = new ADDRESS_PRESENCE_INFO;
    DWORD   dwTagLen = 0;
    HRESULT hr;
    DWORD   dwTagType;
    PSTR    pTagBuffer = pXMLBlobTag;

    if( pAddrPresenceInfo == NULL )
    {
        return E_OUTOFMEMORY;
    }

    //Get the address URI, priority etc.
    hr = GetNextTag( pstrXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
    if( hr != S_OK )
    {
        delete pAddrPresenceInfo;
        return hr;
    }

    hr = GetAddressURI( pXMLBlobTag,
                        dwTagLen,
                        pAddrPresenceInfo );

    dwXMLBlobLen -= dwTagLen + 2;
    if( hr != S_OK )
    {
        delete pAddrPresenceInfo;
        return hr;
    }

    while( dwXMLBlobLen )
    {
        //reset the buffer
        pXMLBlobTag = pTagBuffer;

        hr = GetNextTag( pstrXMLBlob, pXMLBlobTag, dwXMLBlobLen, dwTagLen );
        if( hr != S_OK )
        {
            delete pAddrPresenceInfo;
            return hr;
        }

        dwXMLBlobLen -= dwTagLen + 2;

        dwTagType = GetPresenceTagType( &pXMLBlobTag, dwTagLen );
        switch( dwTagType )
        {
        case STATUS_TAG:

            ProcessStatusTag( pXMLBlobTag, dwTagLen, pAddrPresenceInfo );
            dwXMLBlobLen --;

            break;
        
        case MSNSUBSTATUS_TAG:

            ProcessMsnSubstatusTag( pXMLBlobTag, dwTagLen, pAddrPresenceInfo );
            dwXMLBlobLen --;

            break;
        
        case FEATURE_TAG:

            ProcessFeatureTag( pXMLBlobTag, dwTagLen, pAddrPresenceInfo );
            dwXMLBlobLen --;

            break;

        case ADDRESS_END_TAG:
            
            InsertTailList( &pParsedPresenceInfo->LEAddressInfo,
                &pAddrPresenceInfo->ListEntry );

            return S_OK;

        case NOTE_TAG:

            hr = ParseNoteText( pstrXMLBlob,
                                dwXMLBlobLen,
                                pAddrPresenceInfo->pstrMiscInfo,
                                sizeof pAddrPresenceInfo->pstrMiscInfo );
            if( hr != S_OK )
            {
                goto cleanup;                
            }

            break;

        case UNKNOWN_TAG:

            //skip the unknown tag.
            continue;

        case ATOM_END_TAG:
        case ADDRESS_TAG:
        default:

            goto cleanup;

        }
    }


cleanup:

    delete pAddrPresenceInfo;
    return E_FAIL;
}


HRESULT
CSIPBuddy::GetAddressURI(
    IN  PSTR    pXMLBlobTag,
    IN  DWORD   dwTagLen,
    OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
    )
{
    DWORD   dwTagType = GetPresenceTagType( &pXMLBlobTag, dwTagLen );
    INT     iIndex = 0;
    
    switch( dwTagType )
    {
    case ADDRESS_TAG:
        break;

    case ATOM_END_TAG:
        return E_END_OF_ATOM;

    default:
        return E_FAIL;
    }

    SkipWhiteSpaces( pXMLBlobTag );
    
    if( strncmp( pXMLBlobTag, "uri=", strlen("uri=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("uri=");

    SkipWhiteSpaces( pXMLBlobTag );
    
    if( strncmp( pXMLBlobTag, "\"sip:", strlen("\"sip:") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("\"sip:");

    while( (*pXMLBlobTag != QUOTE_CHAR) && (*pXMLBlobTag != NULL_CHAR) && 
        (*pXMLBlobTag != ';') )
    {
        pAddrPresenceInfo->pstrAddressURI[iIndex] = *pXMLBlobTag++;
        iIndex++;

        if( iIndex >= sizeof(pAddrPresenceInfo->pstrAddressURI) )
        {
            LOG(( RTC_ERROR, "Address URI in the NOTIFY too long" ));
            return E_FAIL;
        }
    }
    
    if( *pXMLBlobTag == NULL_CHAR )
    {
        return E_FAIL;
    }

    pAddrPresenceInfo->pstrAddressURI[iIndex] = NULL_CHAR;
    
    if( *pXMLBlobTag == ';' )
    {
        pXMLBlobTag++;

        //Get the URI parameters
        if( IsURIPhoneNumber( pXMLBlobTag + 1 ) )
        {
            pAddrPresenceInfo->fPhoneNumber = TRUE;

            if( iIndex >= 32 )
            {
                //Phone URI too long.
                LOG(( RTC_ERROR, "Phone URI in the NOTIFY too long" ));
                return E_FAIL;
            }
        }
    }

    return S_OK;
}


BOOL
CSIPBuddy::IsURIPhoneNumber( 
    PSTR    pXMLBlobTag
    )
{

    while( 1 )
    {
        SkipWhiteSpaces( pXMLBlobTag );
    
        // Check if it's user= parameter.
        if( strncmp( pXMLBlobTag, "user=", strlen("user=") ) )
        {
            pXMLBlobTag += strlen( "user=" );
                 
            SkipWhiteSpaces( pXMLBlobTag );   
            
            return (strncmp( pXMLBlobTag, "phone", strlen("phone") ) == 0);
        }

        // Skip the parameter.
        while( *pXMLBlobTag != ';')
        {
            if( (*pXMLBlobTag == NULL_CHAR) || (*pXMLBlobTag == QUOTE_CHAR) )
            {
                // End of user URI.
                return FALSE;
            }

            pXMLBlobTag++;
        }
    }
}


HRESULT
CSIPBuddy::ProcessStatusTag(
    IN  PSTR    pXMLBlobTag, 
    IN  DWORD   dwTagLen,
    OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
    )
{
    PSTR    pstrTemp;
    CHAR    ch;

    SkipWhiteSpaces( pXMLBlobTag );
    
    if( strncmp( pXMLBlobTag, "status=", strlen("status=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("status=");

    SkipWhiteSpaces( pXMLBlobTag );

    pstrTemp = pXMLBlobTag;

    while(  (*pXMLBlobTag != NULL_CHAR) && (*pXMLBlobTag != NEWLINE_CHAR) && 
            (*pXMLBlobTag != BLANK_CHAR) && (*pXMLBlobTag != TAB_CHAR) )
    {
        pXMLBlobTag++;
    }

    ch = *pXMLBlobTag;
    *pXMLBlobTag = NULL_CHAR;

    if( strcmp( pstrTemp, "\"inuse\"" ) == 0 )
    {
        pAddrPresenceInfo->addressActiveStatus = DEVICE_INUSE;
    }
    else if( strcmp( pstrTemp, "\"open\"" ) == 0 )
    {
        pAddrPresenceInfo->addressActiveStatus = DEVICE_ACTIVE;
    }
    else if( strcmp( pstrTemp, "\"inactive\"" ) == 0 )
    {
        pAddrPresenceInfo->addressActiveStatus = DEVICE_INACTIVE;
    }
    else if( strcmp( pstrTemp, "\"closed\"" ) == 0 )
    {
        pAddrPresenceInfo->addressActiveStatus = DEVICE_INACTIVE;
    }
    else
    {
        return E_FAIL;
    }

    *pXMLBlobTag = ch;

    return S_OK;
}


HRESULT
CSIPBuddy::ProcessMsnSubstatusTag(
    IN  PSTR    pXMLBlobTag, 
    IN  DWORD   dwTagLen,
    OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
    )
{
    PSTR    pstrTemp;
    CHAR    ch;

    SkipWhiteSpaces( pXMLBlobTag );
    
    if( strncmp( pXMLBlobTag, "substatus=", strlen("substatus=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen("substatus=");

    SkipWhiteSpaces( pXMLBlobTag );

    pstrTemp = pXMLBlobTag;

    while(  (*pXMLBlobTag != NULL_CHAR) && (*pXMLBlobTag != NEWLINE_CHAR) && 
            (*pXMLBlobTag != BLANK_CHAR) && (*pXMLBlobTag != TAB_CHAR) )
    {
        pXMLBlobTag++;
    }

    ch = *pXMLBlobTag;
    *pXMLBlobTag = NULL_CHAR;
    
    if( strcmp( pstrTemp, "\"online\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_ONLINE;
    }
    else if( strcmp( pstrTemp, "\"away\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_AWAY;
    }
    else if( strcmp( pstrTemp, "\"idle\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_IDLE;
    }
    else if( strcmp( pstrTemp, "\"busy\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_BUSY;
    }
    else if( strcmp( pstrTemp, "\"berightback\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_BE_RIGHT_BACK;
    }
    else if( strcmp( pstrTemp, "\"onthephone\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_ON_THE_PHONE;
    }
    else if( strcmp( pstrTemp, "\"outtolunch\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMsnSubstatus = MSN_SUBSTATUS_OUT_TO_LUNCH;
    }
    else
    {
        return E_FAIL;
    }

    *pXMLBlobTag = ch;

    return S_OK;
}

HRESULT
CSIPBuddy::ProcessFeatureTag(
    IN  PSTR                        pXMLBlobTag, 
    IN  DWORD                       dwTagLen,
    OUT ADDRESS_PRESENCE_INFO * pAddrPresenceInfo
    )
{
    PSTR    pstrTemp;
        
    SkipWhiteSpaces( pXMLBlobTag );
    
    if( strncmp( pXMLBlobTag, "feature=", strlen("feature=") ) != 0 )
    {
        return E_FAIL;
    }

    pXMLBlobTag += strlen( "status=" );

    SkipWhiteSpaces( pXMLBlobTag );

    pstrTemp = pXMLBlobTag;

    while(  (*pXMLBlobTag != NULL_CHAR) && (*pXMLBlobTag != NEWLINE_CHAR) && 
            (*pXMLBlobTag != BLANK_CHAR) && (*pXMLBlobTag != TAB_CHAR) )
    {
        pXMLBlobTag++;
    }

    *pXMLBlobTag = NULL_CHAR;

    if( strcmp( pstrTemp, "\"im\"" ) == 0 )
    {
        pAddrPresenceInfo->addrIMStatus = IM_ACCEPTANCE_ALLOWED;
    }
    else if( strcmp( pstrTemp, "\"no-im\"" ) == 0 )
    {
        pAddrPresenceInfo->addrIMStatus = IM_ACCEPTANCE_DISALLOWED;
    }
    else if( strcmp( pstrTemp, "\"multimedia-call\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMMCallStatus = SIPCALL_ACCEPTANCE_ALLOWED;
    }
    else if( strcmp( pstrTemp, "\"no-multimedia-call\"" ) == 0 )
    {
        pAddrPresenceInfo->addrMMCallStatus = SIPCALL_ACCEPTANCE_DISALLOWED;
    }
    else if( strcmp( pstrTemp, "\"app-sharing\"" ) == 0 )
    {
        pAddrPresenceInfo->addrAppsharingStatus = APPSHARING_ACCEPTANCE_ALLOWED;
    }
    else if( strcmp( pstrTemp, "\"no-app-sharing\"" ) == 0 )
    {
        pAddrPresenceInfo->addrAppsharingStatus = 
            APPSHARING_ACCEPTANCE_DISALLOWED;
    }
    else if( strcmp( pstrTemp, "\"voicemail\"" ) == 0 )
    {
        //ignore        
    }
    else if( strcmp( pstrTemp, "\"attendant\"" ) == 0 )
    {
        //ignore
    }
    else
    {
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
CSIPBuddy::ParseNoteText( 
    PSTR&   pstrBlob,
    DWORD&  dwXMLBlobLen,
    PSTR    pstrNote,
    DWORD   dwNoteLen
    )
{
    CHAR    ch;
    PSTR    pstrTemp = strstr( pstrBlob, "</note>" );

    if( pstrTemp == NULL )
    {
        return E_FAIL;
    }

    ch = *pstrTemp;
    *pstrTemp = NULL_CHAR;

    strncpy( pstrNote, pstrBlob, dwNoteLen -1 );
    pstrNote[dwNoteLen-1] = '\0';

    *pstrTemp = ch;
    pstrTemp += strlen( "</note>" );
    
    dwXMLBlobLen -= (ULONG)(pstrTemp - pstrBlob);
    
    pstrBlob = pstrTemp;

    return S_OK;
}


DWORD
GetPresenceTagType(
    PSTR*   ppXMLBlobTag,
    DWORD   dwTagLen
    )
{
    CHAR    pstrTemp[40];

    HRESULT hr = GetNextWord( ppXMLBlobTag, pstrTemp, sizeof pstrTemp );

    if( hr == S_OK )
    {
        if( strcmp( pstrTemp, FEATURE_TAG_TEXT) == 0 )
        {
            return FEATURE_TAG;
        }
        else if( strcmp( pstrTemp, STATUS_TAG_TEXT) == 0 )
        {
            return STATUS_TAG;
        }
        else if( strcmp( pstrTemp, MSNSUBSTATUS_TAG_TEXT) == 0 )
        {
            return MSNSUBSTATUS_TAG;
        }
        else if( strcmp( pstrTemp, NOTE_TAG_TEXT) == 0 )
        {
            return NOTE_TAG;
        }
        else if( strcmp( pstrTemp, ADDRESS_END_TAG_TEXT) == 0 )
        {
            return ADDRESS_END_TAG;
        }
        else if( strcmp( pstrTemp, ATOM_END_TAG_TEXT) == 0 )
        {
            return ATOM_END_TAG;
        }
        else if( strcmp( pstrTemp, ADDRESS_TAG_TEXT) == 0 )
        {
            return ADDRESS_TAG;
        }
        else if( strcmp( pstrTemp, DOCTYPE_TAG_TEXT) == 0 )
        {
            return DOCTYPE_TAG;
        }
        else if( strcmp( pstrTemp, PRESENCE_END_TAG_TEXT) == 0 )
        {
            return PRESENCE_END_TAG;
        }
        else if( strcmp( pstrTemp, XMLVER_TAG_TEXT) == 0 )
        {
            return XMLVER_TAG;
        }
        else if( strcmp( pstrTemp, PRESENCE_TAG_TEXT) == 0 )
        {
            return PRESENCE_TAG;
        }
        else if( strcmp( pstrTemp, ATOMID_TAG_TEXT) == 0 )
        {
            return ATOMID_TAG;
        }
        else if( strcmp( pstrTemp, PRESENTITY_TAG_TEXT) == 0 )
        {
            return PRESENTITY_TAG;
        }
    }

    return UNKNOWN_TAG;
}


VOID
CSIPBuddy::BuddySubscriptionRejected(
    IN SIP_MESSAGE *pSipMsg
    )
{
    HRESULT hr = S_OK;
    HRESULT StatusCode = ParsePresenceRejectCode( pSipMsg );
        
    m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;

    // Do not retry if the status code is 405 or 403
    if( (pSipMsg->GetStatusCode() != SIP_STATUS_CLIENT_METHOD_NOT_ALLOWED) &&
        (pSipMsg->GetStatusCode() != SIP_STATUS_CLIENT_FORBIDDEN) )
    {
        if( IsTimerActive() )
        {
            KillTimer();
        }

        //Start the retry timer 
        m_RetryState = BUDDY_RETRY;

        //Retry after 5 minutes
        hr = StartTimer( FIVE_MINUTES * 1000 );
    }

    if( StatusCode != 0 )
    {
        if(m_pNotifyInterface)
        {    
            m_pNotifyInterface -> BuddyRejected( StatusCode );
        }
    }
    
    m_BuddyState = BUDDY_STATE_REJECTED;
    return;
}


HRESULT
CSIPBuddy::ParsePresenceRejectCode(
    IN SIP_MESSAGE *pSipMsg
    )
{

    // return the status code for now

    return HRESULT_FROM_SIP_STATUS_CODE(pSipMsg->GetStatusCode());
}


BOOL
CSIPBuddy::IsSessionDisconnected()
{
    return( (m_BuddyState == BUDDY_STATE_REJECTED) ||
            (m_BuddyState == BUDDY_STATE_UNSUBSCRIBED) ||
            (m_BuddyState == BUDDY_STATE_DROPPED) );
}


HRESULT
CSIPBuddy::OnIpAddressChange()
{
    HRESULT hr;

    hr = CheckListenAddrIntact();
    if( hr == S_OK )
    {
        // Nothing needs to be done.
        return hr;
    }

    //
    // The IP address sent to the buddy machine is no longer valid drop the
    // session and let the core create a new session.
    //

    // Create a UNSUB transaction
    hr = CreateOutgoingUnsub( FALSE, NULL, 0 );
    if( hr != S_OK )
    {
        LOG((RTC_ERROR, "CreateOutgoingUnsub failed %x", hr));
    }

    m_BuddyState = BUDDY_STATE_DROPPED;
    m_PresenceInfo.presenceStatus = BUDDY_OFFLINE;

    // Notify the core.
    if( m_pNotifyInterface != NULL )
    {    
        LOG(( RTC_TRACE, "BuddyUnsubscribed notification passed:%p", this ));
        m_pNotifyInterface -> BuddyUnsubscribed();
    }

    return S_OK;
}


//
// The ISIPWatcherManager implementation. This interface is implemented by
// SIP_STACK class. This is the interface used to manage the watcher list 
// and to configure the presence information for the watchers.
//



/*
Routine Description:
    Set the presence information of the local presentity. This should trigger a
    NOTIFY being sent to all the watchers if the information they are allowed 
    to watch has changed.

Parameters:
    SIP_PRESENCE_INFO * pSipLocalPresenceInfo - The pointer of the presence
        structure. This structure is filled in with available presence 
        information about the local presence.

Return Value:
    HRESULT 
    S_OK - The operation is successful.
    E_FAIL - The presence information could not be fetched.

*/

STDMETHODIMP
SIP_STACK::SetPresenceInformation(
    IN SIP_PRESENCE_INFO * pSipLocalPresenceInfo
    )
{
    INT     iIndex;
    HRESULT hr;
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }


    if( IsPresenceInfoSame( &m_LocalPresenceInfo, pSipLocalPresenceInfo ) )
    {
        return S_OK;
    }

    LOG((RTC_TRACE, "SIP_STACK::SetPresenceInformation - Entered"));
    
    m_LocalPresenceInfo = *pSipLocalPresenceInfo;

    //
    // Prevent the changing of the list as a result of nested calls
    m_bIsNestedWatcherProcessing = TRUE;

    LONG listSize = (LONG)m_SipWatcherList.GetSize();

    for( iIndex=0; iIndex < listSize; iIndex++ )
    {
        m_SipWatcherList[iIndex]->PresenceParamsChanged();
    }

    // clean the deleted entries
    for( iIndex=0; iIndex < listSize; )
    {
        if(m_SipWatcherList[iIndex] == NULL)
        {
            m_SipWatcherList.RemoveAt(iIndex);

            listSize--;
        }
        else
        {
            iIndex ++;
        }
    }
    
    m_bIsNestedWatcherProcessing = FALSE;

    return S_OK;
}


/*
Routine Description
    Adds a watcher rule for this UA.

    Parameters:
        IN  LPWSTR  lpwstrURI - The watcher URI to be monitored by this rule.
        IN  BOOL    fallow  - To allow the watcher URI to subscribe or not. 
        IN  ULONG   ulWatcherURILen - Number of wide chars in the watcher URI.
        OUT ULONG * pulRuleID - The unique ID for this rule. 

Return Value:
    HRESULT
    S_OK - Operation successful.
    E_OUTOFMEMORY - The operation could not be completed due to lack of memory.

*/
STDMETHODIMP
AddWatcherRule(
    IN  LPWSTR  lpwstrURI,
    IN  BOOL    fAllow,
    IN  ULONG   ulWatcherURILen,
    OUT ULONG * pulRuleID
    )
{
    
    return E_NOTIMPL;

}


/*
Routine Description
    Get a watcher rule from its ID.

Parameters:
    LPWSTR  * plpwstrURI - The watcher URI monitored by this rule. Allocated
                by the presence stack. Should be freed by the calling entity.
    
    BOOL    *pfallow - Weather this URI is allowed or not.
    
    ULONG * ulWatcherURILen -  Number of wide chars in the watcher URI.
    
    ULONG   ulRuleID - The ID of the rule to be fetched.

Return Value:
    HRESULT
    S_OK - Operation successful.
    E_OUTOFMEMORY - The operation could not be completed due to lack of memory.
    E_INVALPARAM - Invalid rule ID.

*/

STDMETHODIMP
GetWatcherRuleByID(
    LPWSTR  * plpwstrURI,
    BOOL    *pfallow,
    ULONG * ulWatcherURILen,
    ULONG   ulRuleID
    )
{

    return E_NOTIMPL;


}



/*
Routine Description
Get a list of all the watcher rules.

Parameters:
    ULONG ** ppulRulesArray - Points to an array of rule IDs. This array is
    allocated by the presence stack and should be freed by the calling entity.

    ULONG *  pulNumberOfRules - Set to the number of watcher rules for this UA.

Return Value:
    HRESULT
    S_OK - Operation successful.
    E_OUTOFMEMORY - The operation could not be completed due to lack of memory.
    
*/

STDMETHODIMP
GetAllWatcherRules(
    ULONG ** ppulRulesArray,
    ULONG *  pulNumberOfRules
    )
{

    return E_NOTIMPL;

}



/*
Routine Description
    Remove a watcher rule.

Parameters:
    IN  ULONG      ulRuleID - The ID of the rule to be fetched.

Return Value:
    HRESULT
    S_OK - Operation successful.
    E_INVALPARAM - Invalid rule ID.
*/

STDMETHODIMP    
RemoveWatcherRule(
    IN  ULONG   ulRuleID
    )
{

    return E_NOTIMPL;

}


/*
Routine Description
    Returns the number of watchers for this UA.

Parameters:
    None.

Return Value:
    INT - The number of watchers.

*/

STDMETHODIMP_(INT)
SIP_STACK::GetWatcherCount(void)
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }
    LOG(( RTC_TRACE, "SIP_STACK::GetWatcherCount - Entered" ));

    return m_SipWatcherList.GetSize();
}


/*
Routine Description:
    Returns a watcher object by index in the watcher list.

Parameters:
    INT iIndex -    The index of the watcher in the watcher list.

Return Value:
    ISIPWatcher * pSipWatcher - The ISIPWatcher interface pointer if the index
        passed is valid. The return value is NULL if invalid index is passed.

*/


STDMETHODIMP_(ISIPWatcher *)
SIP_STACK::GetWatcherByIndex(
    IN  INT iIndex
    )
{
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return NULL;
    }
    
    CSIPWatcher *   pSIPWatcher = m_SipWatcherList[iIndex];
    ISIPWatcher *   pWatcher = NULL;
    HRESULT         hr;

    LOG(( RTC_TRACE, "SIP_STACK::GetWatcherByIndex - Entered" ));
    
    if( pSIPWatcher != NULL )
    {
        hr = pSIPWatcher -> QueryInterface( IID_ISIPWatcher,
            (PVOID*)&pWatcher );

        if( hr == S_OK )
        {
            return pWatcher;
        }
    }

    LOG(( RTC_TRACE, "SIP_STACK::GetWatcherByIndex - Exited" ));

    return NULL;
}



/*
Routine Description:
    Remove a watcher from the list, which will cause the watcher manager to
    cancel the subscription of this watcher.

Parameters:
    ISIPWatcher * pSipWatcher   - The ISIPWatcher interface pointer of the 
                                  watcher object to be removed.

Return Value:
    HRESULT
    S_OK    - The watcher has been removed successfully from the watcher list.
        This means the application can't access this object anymore. The 
        watcher manager might keep the actual watcher object until the UNSUB 
        transaction is completed successfully.

    E_FAIL  - There is no such watcher object in the watcher manager's list.

*/

STDMETHODIMP
SIP_STACK::RemoveWatcher(
    IN  ISIPWatcher        *pSipWatcher,
    IN  BUDDY_REMOVE_REASON watcherRemoveReason
    )
{
    INT iWatcherIndex;
    HRESULT hr;
    
    if(IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "SIP_STACK::RemoveWatcher - Entered" ));
    
    CSIPWatcher * pCSipWatcher = static_cast<CSIPWatcher *> (pSipWatcher);
    
    iWatcherIndex = m_SipWatcherList.Find( pCSipWatcher );
    
    if( iWatcherIndex == -1 )
    {
        //
        // Even if we dont have this object in the list let the core release
        // its refcount.
        //
        LOG(( RTC_TRACE, "SIP_STACK::RemoveWatcher - not found, Exited" ));
        return S_OK;
    }

    //
    // CreateOutgoingUnsub can trigger a WatcherOffline in case of an error,
    // Which makes Core call RemoveWatcher again..
    // So let's remove from the list first
    //

    if(m_bIsNestedWatcherProcessing)
    {
        m_SipWatcherList[iWatcherIndex] = NULL;
    }
    else
    {
        m_SipWatcherList.RemoveAt( iWatcherIndex );
    }

    //
    // An UNSUB transaction will be created here only if the user app
    // has removed this watcher. If this function is called as a result of
    // WatcherOffline notification then we dont create any UNSUB here. So
    // there are no reentrancy issues.
    //

    pCSipWatcher -> CreateOutgoingUnsub( FALSE, NULL, 0 );

    LOG(( RTC_TRACE, "SIP_STACK::RemoveWatcher - Exited" ));
    return S_OK;
}


/*

Routine Description
    Returns the number of watcher groups for this UA.

Parameters:
    DWORD   dwPresenceInfoRules - This is bit mask of flags indicating the 
        presence information to be revealed to any watcher in this group.

    ISIPWatcherGroup ** ppSipWatcherGroup - The pointer to the ISIPWatcherGroup
                           interface of the newly created watcher group object.

Return Value:
    INT - The number of watcher groups.

*/

/*STDMETHODIMP
GetWatcherGroupCount(
    IN  DWORD   dwPresenceInfoRules,
    OUT ISIPWatcherGroup ** ppSipWatcherGroup
    )
{

    return E_NOTIMPL;


}*/



/*

Routine Description:
    Returns a watcher group object by index in the watcher list.

Parameters:
    INT iIndex -    The index of the watcher group in the list.

Return Value:
    ISIPWatcherGroup * pSipWatcherGroup - The ISIPWatcherGroup interface pointer
    if the index passed is valid. The return value is NULL if invalid index is passed.

*/

/*STDMETHODIMP_(ISIPWatcherGroup *)
GetWatcherGroupByIndex(
    INT iIndex 
    )
{

    return E_NOTIMPL;    


}*/


/*
Routine Description:
    Remove a watcher group from the list. Removing a watcher group does not
    remove any of the watchers in that group. All the watchers in the group
    are not in any group anymore. They all carry the same presence information
    rules though unless new rules are set on any of the watcher object.

Parameters:
    ISIPWatcher * pSipWatcher - The ISIPWatcherGroup interface pointer of 
                    the watcher group object to be removed.

Return Value:
    HRESULT
    S_OK    - The watcher group has been removed successfully from the watcher
        group list. This means the application can't access this object anymore.

    E_FAIL  - There is no such watcher group object in the watcher group list.

*/


/*STDMETHODIMP
RemoveWatcherGroup(
    IN  ISIPWatcher * pSipWatcher
    )
{

    return E_NOTIMPL;    


}*/


/*
Routine Description:
Remove all the watcher groups in the watcher group list. This would result in all the watchers being without any group.

Parameters:
    None.

Return Value: 
    None.

*/
/*STDMETHODIMP
RemoveAllWatcherGroups(void)
{

    return E_NOTIMPL;    


}*/


/*
Routine Description:
    Creates a new watcher group.

Parameters:
    ISIPWatcher* pSipWatcher - The ISIPWatchergroup interface pointer of the
            watcher group object to be removed.
    PWSTR   pwstrFriendlyName - The friendly name of this watcher group.
    ULONG   ulFrindlyNameLen - Number of wide chars in the friendly name.   

Return Value:
    HRESULT
    S_OK - The watcher group has been removed successfully from the watcher 
    group list. This means the application can't access this object anymore.

    E_FAIL  - There is no such watcher group object in the watcher group list.
*/

/*STDMETHODIMP
CreateWatcherGroup(
    IN  ISIPWatcher* pSipWatcher,
    IN  PWSTR        pwstrFriendlyName,
    IN  ULONG       ulFrindlyNameLen
    )
{

    return E_NOTIMPL;

}*/

 



//
//
//Implementation of ISIPWatcherGroup interface. This interface is implemented
//by CSIPWatcherGroup class.
//
//




/*
Routine Description:
Get the watcher group's friendly name. 

Parameters:
    LPWSTR  *   plpwstrFriendlyName -  The wide string allocated by the SIP stack,
    containing the friendly name of the watcher. Could e NULL if no friendly name
    available for this watcher group. The calling entity should free this string.

    ULONG * pulFriendlyNameLen - The length of the friendly name.

Return Value:
    HRESULT
    S_OK - Operation successful.
    E_INVALPARAM - NO such watcher group.

*/

/*STDMETHODIMP
CSIPWatcherGroup::GetFriendlyName(
    OUT LPWSTR  *   plpwstrFriendlyName
    OUT ULONG * pulFriendlyNameLen
    )
{
    return E_NOTIMPL;    

}*/


/*
Routine Description:
Get the presence info rule of this watcher group. 

Parameters:
    None.

Return Value:
    DWORD 
The bit mask of flags indicating what kind of presence information is conveyed to the watchers of this watcher group.

*/

/*STDMETHODIMP_(DWORD)
CSIPWatcherGroup::GetPresenceInfoRules(void)
{

    return E_NOTIMPL;    
}*/


/*
Routine Description:
Set the presence info rule of this watcher group. 

Parameters:
    DWORD   dwPresenceRules -  The bit mask of flags indicating what kind of 
        presence information is conveyed to the watchers of this watcher group.

Return Value:
    None.

*/

/*STDMETHODIMP
CSIPWatcherGroup::SetPresenceInfoRules(
    DWORD   dwPresenceRules
    )
{


    return E_NOTIMPL;    

}*/


/*
Routine Description
Returns the number of watchers for this watcher group.

Parameters:
None.

Return Value:
    INT - The number of watchers.

*/

/*STDMETHODIMP_(INT)
CSIPWatcherGroup::GetWatcherCount(void)
{

    return E_NOTIMPL;

}*/


/*
Routine Description:
    Returns a watcher object by index in the watcher group.

Parameters:
    INT iIndex - The index of the watcher in the watcher group's watcher list.

Return Value:
    ISIPWatcher * pSipWatcher - The ISIPWatcher interface pointer if the index
        passed is valid. The return value is NULL if invalid index is passed.
*/

/*STDMETHODIMP_(ISIPWatcher * )
CSIPWatcherGroup::GetWatcherByIndex(
    INT iIndex
    )
{
    return E_NOTIMPL;    

}*/





//
//
// Implementation of ISIPWatcher interface. This interface is implemented by 
// CSIPWatcher class.
//
//


CSIPWatcher::CSIPWatcher(
    SIP_STACK  *pSipStack
    ) :
    SIP_MSG_PROCESSOR( SIP_MSG_PROC_TYPE_WATCHER, pSipStack, NULL ),
    TIMER( pSipStack -> GetTimerMgr() )
{
    LOG(( RTC_TRACE, "CSIPWatcher::CSIPWatcher - Entered:%p", this ));
    
    m_lpwstrFriendlyName = NULL;

    m_lpwstrPresentityURI = NULL;

    m_pstrPresentityURI = NULL;
    
    m_WatcherSipUrl = NULL;

    m_dwAtomID = 0;

    ulNumOfNotifyTransaction = 0;
    m_WatcherState = WATCHER_STATE_NONE;

    m_WatcherMonitorState = 0;
    m_BlockedStatus = WATCHER_BLOCKED;

    m_dwAbsoluteExpireTime = 0;
    
    m_fEnforceToTag = FALSE;

    LOG(( RTC_TRACE, "CSIPWatcher::CSIPWatcher - Exited:%p", this ));
    return;
}


CSIPWatcher::~CSIPWatcher()
{
    if( m_lpwstrFriendlyName != NULL )
    {
        delete m_lpwstrFriendlyName;
        m_lpwstrFriendlyName = NULL;
    }

    if( m_lpwstrPresentityURI != NULL )
    {
        delete m_lpwstrPresentityURI;
        m_lpwstrPresentityURI = NULL;
    }
    
    if( m_pstrPresentityURI != NULL )
    {
        delete m_pstrPresentityURI;
        m_pstrPresentityURI = NULL;
    }

    if( m_WatcherSipUrl != NULL )
    {
        delete m_WatcherSipUrl;
        m_WatcherSipUrl = NULL;
    }

    if( IsTimerActive() )
    {
        KillTimer();
    }
    
    LOG(( RTC_TRACE, "CSIPWatcher object deleted:%p", this ));
}


HRESULT
CSIPWatcher::CreateIncomingTransaction(
    IN  SIP_MESSAGE *pSipMsg,
    IN  ASYNC_SOCKET *pResponseSocket
    )
{
    HRESULT hr;
    
    LOG(( RTC_TRACE, "Watcher-CreateIncomingTransaction - Entered" ));
    
    if( (m_WatcherState == WATCHER_STATE_UNSUBSCRIBED) ||
        (m_WatcherState == WATCHER_STATE_DROPPED) )
    {
        //
        // Do nothing
        // We have already sent an UNSUB or we have already received an UNSUB
        // so this session is dead.
        // Send back a 481 
        return S_OK;
    }
    
    switch( pSipMsg->GetMethodId() )
    {
    case SIP_METHOD_SUBSCRIBE:
        
        hr = CreateIncomingSubscribeTransaction( pSipMsg, pResponseSocket, FALSE );
        if( hr != S_OK )
        {
            return hr;
        }
        
        break;

    default:

        // send method not allowed.
        hr = m_pSipStack -> CreateIncomingReqfailCall(
                                        pResponseSocket->GetTransport(),
                                        pSipMsg,
                                        pResponseSocket,
                                        405,
                                        NULL,
                                        0 );
        break;
    }
    
    LOG(( RTC_TRACE, "Watcher-CreateIncomingTransaction - Exited" ));
    return S_OK;
}



void
SIP_STACK::WatcherOffline( 
    IN  CSIPWatcher    *pCSIPWatcher
    )
{
    INT     iWatcherIndex;

    LOG(( RTC_TRACE, "SIP_STACK::WatcherOffline - Entered" ));
    
    //
    // Searching through the list helps us to not pass the 
    // watcher offline notification twice for the same watcher.
    //

    iWatcherIndex = m_SipWatcherList.Find( pCSIPWatcher );
    
    if( iWatcherIndex != -1 )
    {
        if( m_pNotifyInterface != NULL )
        {
            LOG(( RTC_TRACE, "WatcherOffline notification passed:%p", pCSIPWatcher ));

            m_pNotifyInterface -> WatcherOffline( pCSIPWatcher, 
                pCSIPWatcher -> GetPresentityURI() );
        }
    }
}



void
CSIPWatcher::GetContactURI( 
    OUT PSTR * pLocalContact, 
    OUT ULONG * pLocalContactLen
    )
{
    PSTR    pStr;

    if( m_LocalContact[0] == '<' )
    {
        *pLocalContact = m_LocalContact + 1;
    }
    else
    {
        *pLocalContact = m_LocalContact;
    }

    if( pStr = strchr( m_LocalContact, ';' ) )
    {
        *pLocalContactLen = (ULONG)(pStr - *pLocalContact);
    }
    else if( pStr = strchr( m_LocalContact, '>' ) )
    {
        *pLocalContactLen = (ULONG)(pStr - *pLocalContact);
    }
    else
    {
        *pLocalContactLen = m_LocalContactLen;
    }
}


STDMETHODIMP_(ULONG)
CSIPWatcher::AddRef()
{
    ULONG   ulRefCount = MsgProcAddRef();

    LOG(( RTC_TRACE, "CSIPWatcher::AddRef - %p - Refcount:%d", this, ulRefCount ));
    return ulRefCount;
}


STDMETHODIMP_(ULONG)
CSIPWatcher::Release()
{
    ULONG   ulRefCount = MsgProcRelease();
    
    LOG(( RTC_TRACE, "CSIPWatcher::Release - %p - Refcount:%d", this, ulRefCount ));
    return ulRefCount;
}



STDMETHODIMP
CSIPWatcher::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if( riid == IID_IUnknown )
    {
        *ppv = static_cast<IUnknown *>(this);
    }
    else if( riid == IID_ISIPWatcher )
    {
        *ppv = static_cast<ISIPWatcher *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    static_cast<IUnknown *>(*ppv)->AddRef();
    return S_OK;
}


VOID
CSIPWatcher::OnError()
{
    InitiateWatcherTerminationOnError( 0 );
}


HRESULT
SIP_STACK::CreateWatcherNotify(
    BLOCKED_WATCHER_INFO   *pBlockedWatcherInfo
    )
{
    return E_NOTIMPL;
}



STDMETHODIMP
CSIPWatcher::ChangeBlockedStatus(    
    IN  WATCHER_BLOCKED_STATUS BlockedStatus
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }
    
    LOG(( RTC_TRACE, "CSIPWatcher::ChangeBlockedStatus - Entered" ));
    
    // save the blocked status
    m_BlockedStatus = BlockedStatus;

    return PresenceParamsChanged();
}


HRESULT
CSIPWatcher::PresenceParamsChanged()
{
    HRESULT hr = S_OK;

    // check the "appear offline" status
    SIP_PRESENCE_INFO *pPresenceInfo = m_pSipStack->GetLocalPresenceInfo();
    
    LOG((RTC_TRACE, "CSIPWatcher::PresenceParamsChanged - Entered: %p", this));

    if( m_BlockedStatus == WATCHER_BLOCKED ||
        pPresenceInfo->presenceStatus == BUDDY_OFFLINE)
    {
        //If the watcher is currently monitoring then send an UNSUB
        if( m_WatcherState == WATCHER_STATE_ACCEPTED )
        {
            hr = CreateOutgoingUnsub( FALSE, NULL, 0 );

            WatcherDropped();
            
            return hr;
        }
    }
    else 
    {
        //If the watcher is still in monitoring state
        //then send it a notify.
        if( ( m_WatcherState == WATCHER_STATE_REJECTED ) ||
            ( m_WatcherState == WATCHER_STATE_ACCEPTED ) )
        {
            m_WatcherState = WATCHER_STATE_ACCEPTED;
            return CreateOutgoingNotify( FALSE, NULL, 0 );
        }

    }

    return S_OK;
}



/*
Routine Description:
    Get watcher group of this watcher. 

Parameters:
    None.

Return Value:
    ISIPWatcherGroup * pSipWatcherGroup - The  ISIPWatcherGroup interface of
        the watcher group of this watcher. Could be NULL if the watcer does not
        belong to any group.

*/
/*ISIPWatcherGroup * 
CSIPWatcher::GetWacherGroup(void)
{

    return E_NOTIMPL;

}*/


/*
Routine Description:
    Get the presence info rule of this watcher. 

Parameters:
    None.

Return Value:
    DWORD  - The bit mask of flags indicating what kind of presence 
        information is conveyed to this watcher.
*/

DWORD
GetPresenceInfoRules(void)
{
    return E_NOTIMPL;

}


/*
Routine Description:
Set the watcher's group. 

Parameters:
    ISIPWatcherGroup * pSipWatcherGroup - The new SIP watcher group to be set.

Return Value:
    HRESULT
    S_OK - Operation successful.
    E_INVALPARAM - NO such watcher group.
*/

/*STDMETHODIMP
SetWatcherGroup(
    IN  ISIPWatcherGroup * pSipWatcherGroup
    )
{

    return E_NOTIMPL;


}*/


/*
Routine Description:
    Approve a new subscription from a watcher. If the subscription is not a one
    time query, the watcher will be added into the list for further notifications.

Parameters:
    DWORD   dwPresenceInfoRules - This is bit mask of flags indicating the 
        presence information to be revealed to this watcher. If 
        pSipWatcherGroup parameter is nit NULL then this parameter is ignored
        and the presence information rules of the group are used by default.

Return Value:
    HRESULT
    S_OK - The operation performed successfully.

    E_OUTOFMEMORY - The operation could not be performed due to the lack of memory.
    E_INVALPARAM - The pSIPWatcherGroup parameter is invalid.
    E_FAIL - The operation failed.

*/

STDMETHODIMP
CSIPWatcher::ApproveSubscription(
    IN  DWORD   dwPresenceInfoRules
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    LOG(( RTC_TRACE, "CSIPWatcher::ApproveSubscription - Entered" ));
    
    HRESULT hr = m_pSipStack -> AcceptWatcher( this );

    if( hr != S_OK )
    {
        //This watcher is not in the list of the 
        //offering watchers of the sip stack.
        return hr;
    }
    
    if( m_WatcherState == WATCHER_STATE_OFFERING )
    {
        m_BlockedStatus = WATCHER_UNBLOCKED;

        // send a NOTIFY if the presence info is not Appear Offline
        SIP_PRESENCE_INFO *pPresenceInfo = m_pSipStack->GetLocalPresenceInfo();
        if(pPresenceInfo -> presenceStatus != BUDDY_OFFLINE)
        {
            //send a NOTIFY message
            m_WatcherState = WATCHER_STATE_ACCEPTED;
            
            return CreateOutgoingNotify( FALSE, NULL, 0 );
        }
        else
        {
            m_WatcherState = WATCHER_STATE_REJECTED;
            return S_OK;
        }
    }
    else
    {
        //The watcher is invalid state.
        return E_FAIL;
    }
}


/*

Routine Description:
    Reject the new subscription.

Parameters:
    WATCHER_REJECT_REASON ulReason - The reason for rejecting this watcher.

Return Value:
    HRESULT
    S_OK - The operation was successful.
    E_INVALPARAM - The watcher is already allowed subscription.
*/

STDMETHODIMP
CSIPWatcher::RejectSubscription(
    IN  WATCHER_REJECT_REASON ulReason
    )
{
    if(GetSipStack()->IsSipStackShutDown())
    {
        LOG((RTC_ERROR, "SipStack is already shutdown"));
        return RTC_E_SIP_STACK_SHUTDOWN;
    }

    HRESULT hr = m_pSipStack -> RejectWatcher( this );
        
    LOG(( RTC_TRACE, "CSIPWatcher::RejectSubscription - Entered" ));
    
    if( hr != S_OK )
    {
        //This watcher is not in the list of the 
        //offering watchers of the sip stack.
        return hr;
    }

    if( m_WatcherState == WATCHER_STATE_OFFERING )
    {
        m_BlockedStatus = WATCHER_BLOCKED;
        m_WatcherState = WATCHER_STATE_REJECTED;
    }
    else
    {
        // The watcher is invalid state.
        return E_FAIL;
    }

    return S_OK;
}


HRESULT
CSIPWatcher::StartIncomingWatcher(
    IN  SIP_TRANSPORT   Transport,
    IN  SIP_MESSAGE    *pSipMsg,
    IN  ASYNC_SOCKET   *pResponseSocket
    )
{
    ENTER_FUNCTION("CSIPWatcher::StartIncomingWatcher");
    
    HRESULT             hr;
    PSTR                Header;
    ULONG               HeaderLen;
    SIP_HEADER_ENTRY   *pHeaderEntry;
    ULONG               NumHeaders;


    LOG((RTC_TRACE, "%s - Enter", __fxName));
    
    m_Transport = Transport;

    hr = pSipMsg->GetSingleHeader(SIP_HEADER_TO, &Header, &HeaderLen);
    if (hr != S_OK)
        return hr;

    hr = SetLocalForIncomingCall(Header, HeaderLen);
    if (hr != S_OK)
 